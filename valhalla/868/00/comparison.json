{"files":[{"patch":"@@ -1141,1 +1141,1 @@\n-                                  classType.tsym, classType.getMetadata(), classType.getFlavor()) {\n+                                  classType.tsym, classType.getMetadata()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,7 +102,0 @@\n-    \/** Marks a type as a primitive class. We can't reuse the class file encoding (ACC_PRIMITIVE)\n-     * since the latter shares its value (0x800) with ACC_STRICT (javac speak: STRICT_FP) and while\n-     * STRICT_FP is not a valid flag for a class in the class file level, javac's ASTs flag a class\n-     * as being STRICT_FP so as to propagate the FP strictness to methods of the class thereby causing\n-     * a clash *\/\n-    public static final int PRIMITIVE_CLASS  = 1<<16;\n-\n@@ -119,1 +112,0 @@\n-    public static final int ACC_PRIMITIVE = 0x0800;\n@@ -458,1 +450,1 @@\n-        AdjustedClassFlags                = ClassFlags | ACC_PRIMITIVE | ACC_VALUE;\n+        AdjustedClassFlags                = ClassFlags | ACC_VALUE;\n@@ -460,7 +452,7 @@\n-        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedLocalClassFlags           = (long) LocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedLocalClassFlags           = (long) LocalClassFlags | VALUE_CLASS,\n+        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n@@ -492,1 +484,0 @@\n-            if (0 != (flags & PRIMITIVE_CLASS))     modifiers.add(Modifier.PRIMITIVE);\n@@ -548,1 +539,0 @@\n-        PRIMITIVE(Flags.PRIMITIVE_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -237,10 +237,0 @@\n-        boolean isReferenceProjection;\n-        try {\n-            isReferenceProjection = t.isReferenceProjection();\n-        } catch (CompletionFailure cf) {\n-            isReferenceProjection = false; \/\/ handle missing types gracefully.\n-        }\n-        if (isReferenceProjection) {\n-            buf.append('.');\n-            buf.append(t.tsym.name.table.names.ref);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -301,3 +301,0 @@\n-            if (this == PRIMITIVE_CLASSES) {\n-                return Errors.PrimitiveClassesNotSupported(minLevel.name);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -419,4 +418,0 @@\n-    public boolean isPrimitiveClass() {\n-        return (flags() & PRIMITIVE_CLASS) != 0;\n-    }\n-\n@@ -1359,1 +1354,1 @@\n-                new ClassType(Type.noType, null, null, List.nil(), Flavor.X_Typeof_X),\n+                new ClassType(Type.noType, null, null, List.nil()),\n@@ -1396,2 +1391,1 @@\n-                                              type.getMetadata(),\n-                                              type.getFlavor());\n+                                              type.getMetadata());\n@@ -1463,8 +1457,0 @@\n-            } finally {\n-                if (this.type != null && this.type.hasTag(CLASS)) {\n-                    ClassType ct = (ClassType) this.type;\n-                    ct.flavor = ct.flavor.metamorphose((this.flags_field & PRIMITIVE_CLASS) != 0);\n-                    if (!this.type.isIntersection() && this.erasure_field != null && this.erasure_field.hasTag(CLASS)) {\n-                        ((ClassType) this.erasure_field).flavor = ct.flavor;\n-                    }\n-                }\n@@ -1658,1 +1644,0 @@\n-                classType.flavor = Flavor.X_Typeof_X;\n@@ -2091,1 +2076,1 @@\n-                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null &&\n+                types.asSuper(owner.type, other.owner) != null &&\n@@ -2160,1 +2145,1 @@\n-                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null) {\n+                types.asSuper(owner.type, other.owner) != null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -98,2 +98,0 @@\n-    private final boolean allowPrimitiveClasses;\n-\n@@ -290,12 +288,3 @@\n-                Type arg = null;\n-                if (type.getTag() == ARRAY || type.getTag() == CLASS) {\n-                    \/* Temporary treatment for primitive class: Given a primitive class V that implements\n-                       I1, I2, ... In, V.class is typed to be Class<? extends Object & I1 & I2 .. & In>\n-                    *\/\n-                    if (allowPrimitiveClasses && type.isPrimitiveClass()) {\n-                        List<Type> bounds = List.of(objectType).appendList(((ClassSymbol) type.tsym).getInterfaces());\n-                        arg = new WildcardType(bounds.size() > 1 ? types.makeIntersectionType(bounds) : objectType, BoundKind.EXTENDS, boundClass);\n-                    } else {\n-                        arg = types.erasure(type);\n-                    }\n-                }\n+                Type arg;\n+                if (type.getTag() == ARRAY || type.getTag() == CLASS)\n+                    arg = types.erasure(type);\n@@ -688,2 +677,0 @@\n-        Options options = Options.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -235,4 +234,0 @@\n-    public boolean isPrimitiveClass() {\n-        return false;\n-    }\n-\n@@ -259,43 +254,1 @@\n-        if (this.isReferenceProjection())\n-            return true;\n-        return this.isValueClass() && !this.isPrimitiveClass();\n-    }\n-\n-    \/**\n-     * Return the `flavor' associated with a ClassType.\n-     * @see ClassType.Flavor\n-     *\/\n-    public Flavor getFlavor() {\n-        throw new AssertionError(\"Unexpected call to getFlavor() on a Type that is not a ClassType: \" + this);\n-    }\n-\n-    \/**\n-     * @return true IFF the receiver is a reference projection of a primitive class type and false\n-     * for primitives or plain references\n-     *\/\n-    public boolean isReferenceProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n-     * and null otherwise\n-     *\/\n-    public Type valueProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * @return the reference projection type IFF the receiver is a primitive class type\n-     * and null otherwise\n-     *\/\n-    public Type referenceProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * @return the reference projection type IFF the receiver is a primitive class type or self otherwise.\n-     *\/\n-    public Type referenceProjectionOrSelf() {\n-        Type projection = referenceProjection();\n-        return projection != null ? projection : this;\n+        return this.isValueClass();\n@@ -318,1 +271,1 @@\n-            else return new ClassType(outer1, typarams1, t.tsym, t.metadata, t.getFlavor()) {\n+            else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {\n@@ -1056,34 +1009,0 @@\n-    public static class ConstantPoolQType implements PoolConstant {\n-\n-        public final Type type;\n-        final Types types;\n-\n-        public ConstantPoolQType(Type type, Types types) {\n-            this.type = type;\n-            this.types = types;\n-        }\n-\n-        @Override\n-        public Object poolKey(Types types) {\n-            return this;\n-        }\n-\n-        @Override\n-        public int poolTag() {\n-            return ClassFile.CONSTANT_Class;\n-        }\n-\n-        public int hashCode() {\n-            return types.hashCode(type);\n-        }\n-\n-        public boolean equals(Object obj) {\n-            return (obj instanceof ConstantPoolQType) &&\n-                    types.isSameType(type, ((ConstantPoolQType)obj).type);\n-        }\n-\n-        public String toString() {\n-            return type.toString();\n-        }\n-    }\n-\n@@ -1092,79 +1011,0 @@\n-\n-        \/**\n-         * The 'flavor' of a ClassType indicates its reference\/primitive projectionness\n-         * viewed against the default nature of the associated class.\n-         *\/\n-        public enum Flavor {\n-\n-            \/**\n-             * Classic reference type. Also reference projection type of a reference-favoring aka\n-             * reference-default primitive class type\n-             *\/\n-            L_TypeOf_L,\n-\n-            \/**\n-             * Reference projection type of a primitive-favoring aka primitive-default\n-             * plain vanilla primitive class type,\n-             *\/\n-            L_TypeOf_Q,\n-\n-            \/**\n-             * Value projection type of a primitive-favoring aka primitive-default\n-             * plain vanilla primitive class type,\n-             *\/\n-            Q_TypeOf_Q,\n-\n-            \/**\n-             * Value projection type of a reference-favoring aka\n-             * reference-default primitive class type\n-             *\/\n-            Q_TypeOf_L,\n-\n-            \/**\n-             * Reference projection type of a class type of an as yet unknown default provenance, 'X' will be\n-             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n-             *\/\n-            L_TypeOf_X,\n-\n-            \/**\n-             * Value projection type of a class type of an as yet unknown default provenance, 'X' will be\n-             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n-             *\/\n-            Q_TypeOf_X,\n-\n-            \/**\n-             *  As yet unknown projection type of an as yet unknown default provenance class.\n-             *\/\n-            X_Typeof_X,\n-\n-            \/**\n-             *  An error type - we don't care to discriminate them any further.\n-             *\/\n-             E_Typeof_X;\n-\n-            \/\/ We don't seem to need X_Typeof_L or X_Typeof_Q so far.\n-\n-            \/\/ Transform a larval form into a more evolved form\n-            public Flavor metamorphose(boolean isPrimtiveClass) {\n-\n-                switch (this) {\n-\n-                    case E_Typeof_X:  \/\/ stunted form\n-                    case L_TypeOf_L:\n-                    case L_TypeOf_Q:\n-                    case Q_TypeOf_L:\n-                    case Q_TypeOf_Q:\n-                            \/\/ These are fully evolved sealed forms or stunted - no futher transformation\n-                            return this;\n-                    case L_TypeOf_X:\n-                            return isPrimtiveClass ? L_TypeOf_Q : L_TypeOf_L;\n-                    case Q_TypeOf_X:\n-                            return isPrimtiveClass ? Q_TypeOf_Q : Q_TypeOf_L;\n-                    case X_Typeof_X:\n-                            return isPrimtiveClass ? Q_TypeOf_Q : L_TypeOf_L;\n-                    default:\n-                            throw new AssertionError(\"Unexpected class type flavor\");\n-                }\n-            }\n-        }\n-\n@@ -1199,9 +1039,0 @@\n-        \/** The 'other' projection: If 'this' is type of a primitive class, then 'projection' is the\n-         *  reference projection type and vice versa. Lazily initialized, not to be accessed directly.\n-        *\/\n-        public ClassType projection;\n-\n-        \/** Is this L of default {L, Q, X} or Q of default {L, Q, X} ?\n-         *\/\n-        public Flavor flavor;\n-\n@@ -1213,5 +1044,1 @@\n-            this(outer, typarams, tsym, List.nil(), Flavor.L_TypeOf_L);\n-        }\n-\n-        public ClassType(Type outer, List<Type> typarams, TypeSymbol tsym, Flavor flavor) {\n-            this(outer, typarams, tsym, List.nil(), flavor);\n+            this(outer, typarams, tsym, List.nil());\n@@ -1221,1 +1048,1 @@\n-                         List<TypeMetadata> metadata, Flavor flavor) {\n+                         List<TypeMetadata> metadata) {\n@@ -1228,1 +1055,0 @@\n-            this.flavor = flavor;\n@@ -1237,1 +1063,1 @@\n-            return new ClassType(outer_field, typarams_field, tsym, md, flavor) {\n+            return new ClassType(outer_field, typarams_field, tsym, md) {\n@@ -1288,11 +1114,0 @@\n-            boolean isReferenceProjection;\n-            try {\n-                isReferenceProjection = isReferenceProjection();\n-            } catch (CompletionFailure cf) {\n-                isReferenceProjection = false; \/\/ handle missing types gracefully.\n-            }\n-            if (isReferenceProjection) {\n-                buf.append('.');\n-                buf.append(tsym.name.table.names.ref);\n-            }\n-\n@@ -1337,4 +1152,0 @@\n-        public Flavor getFlavor() {\n-            return flavor;\n-        }\n-\n@@ -1357,3 +1168,0 @@\n-            if (outer_field != null && outer_field.isReferenceProjection()) {\n-                outer_field = outer_field.valueProjection();\n-            }\n@@ -1391,5 +1199,0 @@\n-        @Override\n-        public boolean isPrimitiveClass() {\n-            return !isReferenceProjection() && tsym != null && tsym.isPrimitiveClass();\n-        }\n-\n@@ -1398,1 +1201,1 @@\n-            return !isReferenceProjection() && tsym != null && tsym.isValueClass();\n+            return tsym != null && tsym.isValueClass();\n@@ -1408,1 +1211,1 @@\n-            return !isReferenceProjection() && tsym != null && tsym.isIdentityClass();\n+            return tsym != null && tsym.isIdentityClass();\n@@ -1416,49 +1219,0 @@\n-        @Override\n-        public boolean isReferenceProjection() {\n-            \/\/ gaurd against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.L_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.isPrimitiveClass());\n-                }\n-            }\n-            return flavor == Flavor.L_TypeOf_Q;\n-        }\n-\n-        @Override\n-        public Type valueProjection() {\n-            if (!isReferenceProjection())\n-                return null;\n-\n-            if (projection !=  null)\n-                return projection;\n-\n-            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.Q_TypeOf_Q);\n-            projection.allparams_field = allparams_field;\n-            projection.supertype_field = supertype_field;\n-\n-            projection.interfaces_field = interfaces_field;\n-            projection.all_interfaces_field = all_interfaces_field;\n-            projection.projection = this;\n-            return projection;\n-        }\n-\n-        \/\/ return the reference projection type preserving parameterizations\n-        @Override\n-        public ClassType referenceProjection() {\n-\n-            if (!isPrimitiveClass())\n-                return null;\n-\n-            if (projection != null)\n-                return projection;\n-\n-            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.L_TypeOf_Q);\n-            projection.allparams_field = allparams_field;\n-            projection.supertype_field = supertype_field;\n-\n-            projection.interfaces_field = interfaces_field;\n-            projection.all_interfaces_field = all_interfaces_field;\n-            projection.projection = this;\n-            return projection;\n-        }\n-\n@@ -1513,1 +1267,1 @@\n-            super(outer, List.nil(), tsym, metadata, tsym.type.getFlavor());\n+            super(outer, List.nil(), tsym, metadata);\n@@ -2624,1 +2378,1 @@\n-            super(noType, List.nil(), tsym, List.nil(), Flavor.E_Typeof_X);\n+            super(noType, List.nil(), tsym, List.nil());\n@@ -2629,2 +2383,2 @@\n-                          List<TypeMetadata> metadata, Flavor flavor) {\n-            super(noType, List.nil(), null, metadata, flavor);\n+                          List<TypeMetadata> metadata) {\n+            super(noType, List.nil(), null, metadata);\n@@ -2637,1 +2391,1 @@\n-            return new ErrorType(originalType, tsym, md, getFlavor()) {\n+            return new ErrorType(originalType, tsym, md) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":12,"deletions":258,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-                                                      t.getMetadata(), t.getFlavor());\n+                                                      t.getMetadata());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -123,2 +122,0 @@\n-        Options options = Options.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -273,1 +270,1 @@\n-                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.getFlavor()) {\n+                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {\n@@ -605,10 +602,0 @@\n-        if (allowPrimitiveClasses) {\n-            boolean tValue = t.isPrimitiveClass();\n-            boolean sValue = s.isPrimitiveClass();\n-            if (tValue != sValue) {\n-                return tValue ?\n-                        isSubtype(t.referenceProjection(), s) :\n-                        !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n-            }\n-        }\n-\n@@ -1055,7 +1042,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        if (et.isPrimitiveClass()) {\n-                            et = et.referenceProjection();\n-                            if (es.isPrimitiveClass())\n-                                es = es.referenceProjection();  \/\/ V <: V, surely\n-                        }\n-                    }\n@@ -1161,1 +1141,1 @@\n-                         s.hasTag(BOT) || (s.hasTag(CLASS) && (!allowPrimitiveClasses || !s.isPrimitiveClass())) ||\n+                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n@@ -1228,1 +1208,0 @@\n-                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -1244,5 +1223,0 @@\n-                        if (allowPrimitiveClasses && et.isPrimitiveClass()) {\n-                            et = et.referenceProjection();\n-                            if (es.isPrimitiveClass())\n-                                es = es.referenceProjection();  \/\/ V <: V, surely\n-                        }\n@@ -1470,1 +1444,0 @@\n-                    && t.isReferenceProjection() == s.isReferenceProjection()\n@@ -1477,3 +1450,0 @@\n-                    if (et.isReferenceProjection()) {\n-                        et = et.valueProjection();\n-                    }\n@@ -1739,1 +1709,1 @@\n-            if (isSubtype(erasure(ts.type.referenceProjectionOrSelf()), erasure(ss.type))) {\n+            if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n@@ -1794,1 +1764,1 @@\n-                if (s.hasTag(ERROR) || (s.hasTag(BOT) && (!allowPrimitiveClasses || !t.isPrimitiveClass())))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT))\n@@ -1813,10 +1783,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        if (t.isPrimitiveClass()) {\n-                            \/\/ (s) Value ? == (s) Value.ref\n-                            t = t.referenceProjection();\n-                        }\n-                        if (s.isPrimitiveClass()) {\n-                            \/\/ (Value) t ? == (Value.ref) t\n-                            s = s.referenceProjection();\n-                        }\n-                    }\n@@ -2216,29 +2176,0 @@\n-     * Further caveats in Valhalla: There are two \"hazards\" we need to watch out for when using\n-     * this method.\n-     *\n-     * 1. Since Foo.ref and Foo.val share the same symbol, that of Foo.class, a call to\n-     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This MAY NOT BE correct\n-     *    depending on the call site. Foo.val is NOT a super type of Foo.ref either in the language\n-     *    model or in the VM's world view. An example of such an hazardous call used to exist in\n-     *    Gen.visitTypeCast. When we emit code for  (Foo) Foo.ref.instance a check for whether we\n-     *    really need the cast cannot\/shouldn't be gated on\n-     *\n-     *        asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n-     *\n-     *    but use !types.isSubtype(tree.expr.type, tree.clazz.type) which operates in terms of\n-     *    types. When we operate in terms of symbols, there is a loss of type information leading\n-     *    to a hazard. Whether a call to asSuper should be transformed into a isSubtype call is\n-     *    tricky. isSubtype returns just a boolean while asSuper returns richer information which\n-     *    may be required at the call site. Also where the concerned symbol corresponds to a\n-     *    generic class, an asSuper call cannot be conveniently rewritten as an isSubtype call\n-     *    (see that asSuper(ArrayList<String>.type, List<T>.tsym) != null while\n-     *    isSubType(ArrayList<String>.type, List<T>.type) is false;) So care needs to be exercised.\n-     *\n-     * 2. Given a primitive class Foo, a call to asSuper(Foo.type, SuperclassOfFoo.tsym) and\/or\n-     *    a call to asSuper(Foo.type, SuperinterfaceOfFoo.tsym) would answer null. In many places\n-     *    that is NOT what we want. An example of such a hazardous call used to occur in\n-     *    Attr.visitForeachLoop when checking to make sure the for loop's control variable of a type\n-     *    that implements Iterable: viz: types.asSuper(exprType, syms.iterableType.tsym);\n-     *    These hazardous calls should be rewritten as\n-     *    types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym); instead.\n-     *\n@@ -2257,6 +2188,0 @@\n-\n-        if (allowPrimitiveClasses && t.isPrimitiveClass()) {\n-            \/\/ No man may be an island, but the bell tolls for a value.\n-            return t.tsym == sym ? t : null;\n-        }\n-\n@@ -2393,12 +2318,3 @@\n-\n-        if ((sym.flags() & STATIC) != 0)\n-            return sym.type;\n-\n-        \/* If any primitive class types are involved, switch over to the reference universe,\n-           where the hierarchy is navigable. V and V.ref have identical membership\n-           with no bridging needs.\n-        *\/\n-        if (allowPrimitiveClasses && t.isPrimitiveClass())\n-            t = t.referenceProjection();\n-\n-        return memberType.visit(t, sym);\n+        return (sym.flags() & STATIC) != 0\n+            ? sym.type\n+            : memberType.visit(t, sym);\n@@ -2557,6 +2473,7 @@\n-                \/\/ erasure(projection(primitive)) = projection(erasure(primitive))\n-                Type erased = eraseClassType(t, recurse);\n-                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n-                    erased = new ClassType(erased.getEnclosingType(),\n-                            List.nil(), erased.tsym,\n-                            erased.getMetadata(), t.flavor);\n+                Type erased = t.tsym.erasure(Types.this);\n+                if (recurse) {\n+                    erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n+                            t.dropMetadata(Annotations.class).getMetadata());\n+                    return erased;\n+                } else {\n+                    return combineMetadata(erased, t);\n@@ -2564,1 +2481,0 @@\n-                return erased;\n@@ -2566,11 +2482,0 @@\n-                \/\/ where\n-                private Type eraseClassType(ClassType t, Boolean recurse) {\n-                    Type erased = t.tsym.erasure(Types.this);\n-                    if (recurse) {\n-                        erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n-                                                     t.dropMetadata(Annotations.class).getMetadata());\n-                        return erased;\n-                    } else {\n-                        return combineMetadata(erased, t);\n-                    }\n-                }\n@@ -2896,1 +2801,1 @@\n-                                         t.getMetadata(), t.getFlavor());\n+                                         t.getMetadata());\n@@ -4017,1 +3922,1 @@\n-                                 class1.tsym, List.nil(), class1.getFlavor());\n+                                 class1.tsym, List.nil());\n@@ -4577,1 +4482,1 @@\n-                                 cls.getMetadata(), cls.getFlavor());\n+                                 cls.getMetadata());\n@@ -5251,4 +5156,1 @@\n-                    if (types.allowPrimitiveClasses && type.isPrimitiveClass())\n-                        append('Q');\n-                    else\n-                        append('L');\n+                    append('L');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":18,"deletions":116,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -170,1 +169,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -189,4 +187,0 @@\n-    \/** Switch: allow primitive classes ?\n-     *\/\n-    boolean allowPrimitiveClasses;\n-\n@@ -808,1 +802,1 @@\n-                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));\n+                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env)));\n@@ -810,1 +804,1 @@\n-                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));\n+                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env)));\n@@ -1541,1 +1535,1 @@\n-                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n+                Type base = types.asSuper(exprType, syms.iterableType.tsym);\n@@ -1557,1 +1551,1 @@\n-                    if (types.asSuper(iterSymbol.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym) == null) {\n+                    if (types.asSuper(iterSymbol.type.getReturnType(), syms.iteratorType.tsym) == null) {\n@@ -1983,1 +1977,1 @@\n-            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n+            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&\n@@ -2172,2 +2166,1 @@\n-            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n-            \/\/ value conversions bring about a convergence.\n+            \/\/ Those were all the cases that could result in a primitive\n@@ -2175,2 +2168,1 @@\n-                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type\n-                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n+                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type : t)\n@@ -2187,1 +2179,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), allowPrimitiveClasses && t.isPrimitiveClass() ? t.referenceProjection() : t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), t))\n@@ -2190,1 +2182,1 @@\n-            \/\/ both are known to be reference types (or projections).  The result is\n+            \/\/ both are known to be reference types.  The result is\n@@ -2631,2 +2623,1 @@\n-                Type wcb = types.erasure(allowPrimitiveClasses && qualifierType.isPrimitiveClass() ?\n-                                         qualifierType.referenceProjection() : qualifierType.baseType());\n+                Type wcb = types.erasure(qualifierType.baseType());\n@@ -2638,2 +2629,1 @@\n-                        restype.getMetadata(),\n-                        restype.getFlavor());\n+                        restype.getMetadata());\n@@ -2808,10 +2798,0 @@\n-            \/\/ Check that it is an instantiation of a class and not a projection type\n-            if (allowPrimitiveClasses) {\n-                if (clazz.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n-                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n-                    }\n-                }\n-            }\n@@ -2842,2 +2822,1 @@\n-                                               clazztype.getMetadata(),\n-                                               clazztype.getFlavor());\n+                                               clazztype.getMetadata());\n@@ -2997,3 +2976,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n-                    }\n@@ -3072,3 +3048,0 @@\n-        \/\/ Likewise arg can't be null if it is a primitive class instance.\n-        if (allowPrimitiveClasses && arg.type.isPrimitiveClass())\n-            return arg;\n@@ -4412,9 +4385,0 @@\n-        if (allowPrimitiveClasses && tree.name == names._class && site.isPrimitiveClass()) {\n-            \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-             * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-             * always matching the behavior of Object::getClass\n-             *\/\n-             if (!tree.selected.hasTag(SELECT) || ((JCFieldAccess) tree.selected).name != names.val) {\n-                 tree.selected.setType(site = site.referenceProjection());\n-             }\n-        }\n@@ -4537,1 +4501,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n@@ -4580,2 +4544,0 @@\n-                } else if (allowPrimitiveClasses && site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n-                    return site.tsym;\n@@ -4688,3 +4650,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n-                    }\n@@ -4694,8 +4653,1 @@\n-                    \/\/ (a) If symbol is a primitive class and its reference projection\n-                    \/\/ is requested via the .ref notation, then adjust the computed type to\n-                    \/\/ reflect this.\n-                    if (allowPrimitiveClasses && owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n-                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n-                    }\n-\n-                    \/\/ (b) If the symbol's type is parameterized, erase it\n+                    \/\/ If the symbol's type is parameterized, erase it\n@@ -4728,1 +4680,1 @@\n-                                owntype.getMetadata(), owntype.getFlavor());\n+                                owntype.getMetadata());\n@@ -5046,5 +4998,0 @@\n-        if (!allowPrimitiveClasses) {\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n-        }\n-\n@@ -5055,13 +5002,10 @@\n-        if (!allowPrimitiveClasses) {\n-            result = types.createErrorType(names._default, site.tsym, site);\n-        } else {\n-            Symbol sym = switch (site.getTag()) {\n-                case WILDCARD -> throw new AssertionError(tree);\n-                case PACKAGE -> {\n-                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n-                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n-                    yield syms.errSymbol;\n-                }\n-                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n-                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n-            };\n+        Symbol sym = switch (site.getTag()) {\n+            case WILDCARD -> throw new AssertionError(tree);\n+            case PACKAGE -> {\n+                log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n+                        Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n+                yield syms.errSymbol;\n+            }\n+            case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n+            default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n+        };\n@@ -5069,4 +5013,2 @@\n-            if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-                site = types.skipTypeVars(site, true);\n-            }\n-            result = checkId(tree, site, sym, env, resultInfo);\n+        if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n+            site = types.skipTypeVars(site, true);\n@@ -5074,0 +5016,1 @@\n+        result = checkId(tree, site, sym, env, resultInfo);\n@@ -5163,1 +5106,1 @@\n-                                        clazztype.getMetadata(), clazztype.getFlavor());\n+                                        clazztype.getMetadata());\n@@ -5290,1 +5233,1 @@\n-                make.Modifiers(PUBLIC | ABSTRACT | (extending != null && TreeInfo.symbol(extending).isPrimitiveClass() ? PRIMITIVE_CLASS : 0)),\n+                make.Modifiers(PUBLIC | ABSTRACT),\n@@ -5313,1 +5256,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),\n@@ -5431,5 +5374,0 @@\n-            if (allowPrimitiveClasses && c.type.isPrimitiveClass()) {\n-                final Env<AttrContext> env = typeEnvs.get(c);\n-                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF))\n-                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":31,"deletions":93,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -187,1 +187,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -230,5 +229,0 @@\n-\n-    \/** Are primitive classes allowed\n-     *\/\n-    private final boolean allowPrimitiveClasses;\n-\n@@ -637,5 +631,0 @@\n-        } else {\n-            if (allowPrimitiveClasses && found.hasTag(CLASS)) {\n-                if (inferenceContext != infer.emptyContext)\n-                    checkParameterizationByPrimitiveClass(pos, found);\n-            }\n@@ -835,9 +824,0 @@\n-                \/\/ Projection types may not be mentioned in constructor references\n-                if (expr.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n-                    if (allowPrimitiveClasses && fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(expr, Errors.ProjectionCantBeInstantiated);\n-                        t = types.createErrorType(t);\n-                    }\n-                }\n@@ -879,1 +859,0 @@\n-     *  @param primitiveClassOK       If false, a primitive class does not qualify\n@@ -881,2 +860,2 @@\n-    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n-        if (t.isReference() && (!allowPrimitiveClasses || primitiveClassOK || !t.isPrimitiveClass()))\n+    Type checkRefType(DiagnosticPosition pos, Type t) {\n+        if (t.isReference())\n@@ -890,3 +869,3 @@\n-    \/** Check that type is an identity type, i.e. not a primitive\/value type\n-     *  nor its reference projection. When not discernible statically,\n-     *  give it the benefit of doubt and defer to runtime.\n+    \/** Check that type is an identity type, i.e. not a value type.\n+     *  When not discernible statically, give it the benefit of doubt\n+     *  and defer to runtime.\n@@ -908,1 +887,1 @@\n-        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n+        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface())\n@@ -912,9 +891,0 @@\n-    \/** Check that type is a reference type, i.e. a class, interface or array type\n-     *  or a type variable.\n-     *  @param pos           Position to be used for error reporting.\n-     *  @param t             The type to be checked.\n-     *\/\n-    Type checkRefType(DiagnosticPosition pos, Type t) {\n-        return checkRefType(pos, t, true);\n-    }\n-\n@@ -929,1 +899,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head, false);\n+            l.head = checkRefType(tl.head.pos(), l.head);\n@@ -965,49 +935,0 @@\n-    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n-        parameterizationByPrimitiveClassChecker.visit(t, pos);\n-    }\n-\n-    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n-     *  being used as type arguments and issues error against those usages.\n-     *\/\n-    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n-            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n-\n-        @Override\n-        public Void visitType(Type t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitClassType(ClassType t, DiagnosticPosition pos) {\n-            for (Type targ : t.allparams()) {\n-                if (allowPrimitiveClasses && targ.isPrimitiveClass()) {\n-                    log.error(pos, Errors.GenericParameterizationWithPrimitiveClass(t));\n-                }\n-                visit(targ, pos);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {\n-             return null;\n-        }\n-\n-        @Override\n-        public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {\n-            return visit(t.elemtype, pos);\n-        }\n-\n-        @Override\n-        public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {\n-            return visit(t.type, pos);\n-        }\n-    };\n-\n-\n-\n@@ -1162,5 +1083,1 @@\n-        Type varType = types.upward(t, types.captures(t)).baseType();\n-        if (allowPrimitiveClasses && varType.hasTag(CLASS)) {\n-            checkParameterizationByPrimitiveClass(pos, varType);\n-        }\n-        return varType;\n+        return types.upward(t, types.captures(t)).baseType();\n@@ -1189,1 +1106,0 @@\n-        \/\/ TODO - is enum so <init>\n@@ -1438,2 +1354,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE_CLASS);\n@@ -1453,4 +1369,0 @@\n-            \/\/ primitive classes are implicitly final value classes.\n-            if ((flags & PRIMITIVE_CLASS) != 0)\n-                implicit |= VALUE_CLASS | FINAL;\n-\n@@ -1497,1 +1409,1 @@\n-                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                               FINAL | NATIVE | SYNCHRONIZED)\n@@ -1501,1 +1413,1 @@\n-                        PRIMITIVE_CLASS | VALUE_CLASS)\n+                        VALUE_CLASS)\n@@ -1706,2 +1618,1 @@\n-                tree.selected.type.isParameterized() &&\n-                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n+                tree.selected.type.isParameterized()) {\n@@ -1711,2 +1622,0 @@\n-                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n-                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -2535,10 +2444,8 @@\n-        if (allowPrimitiveClasses) {\n-            Assert.check((tree.sym.flags_field & LOCKED) == 0);\n-            try {\n-                tree.sym.flags_field |= LOCKED;\n-                for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (l.head.hasTag(VARDEF)) {\n-                        JCVariableDecl field = (JCVariableDecl) l.head;\n-                        if (cyclePossible(field.sym)) {\n-                            checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n-                        }\n+        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        try {\n+            tree.sym.flags_field |= LOCKED;\n+            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                if (l.head.hasTag(VARDEF)) {\n+                    JCVariableDecl field = (JCVariableDecl) l.head;\n+                    if (cyclePossible(field.sym)) {\n+                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n@@ -2547,2 +2454,0 @@\n-            } finally {\n-                tree.sym.flags_field &= ~LOCKED;\n@@ -2550,0 +2455,2 @@\n+        } finally {\n+            tree.sym.flags_field &= ~LOCKED;\n@@ -2569,1 +2476,1 @@\n-            return (symbol.flags() & STATIC) == 0 && allowPrimitiveClasses && symbol.type.isPrimitiveClass();\n+            return (symbol.flags() & STATIC) == 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":24,"deletions":117,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -108,1 +107,0 @@\n-    boolean allowPrimitiveClasses;\n@@ -149,2 +147,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -512,4 +508,0 @@\n-        if (allowPrimitiveClasses) {\n-            ct.flavor = ct.flavor.metamorphose((c.flags_field & PRIMITIVE_CLASS) != 0);\n-        }\n-\n@@ -534,6 +526,0 @@\n-        if (allowPrimitiveClasses && ct.isPrimitiveClass()) {\n-            if (ct.projection != null) {\n-                ct.projection.typarams_field = ct.typarams_field;\n-                ct.projection.allparams_field = ct.allparams_field;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1592,1 +1592,1 @@\n-                    if (types.asSuper(sup.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null) {\n+                    if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1868,1 +1868,1 @@\n-                return types.asSuper(tree.target.referenceProjectionOrSelf(), syms.serializableType.tsym) != null;\n+                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-    private final boolean allowPrimitiveClasses;\n@@ -134,1 +133,0 @@\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -1237,3 +1235,0 @@\n-                \/\/ Make sure not to lose type fidelity due to symbol sharing between projections\n-                boolean requireReferenceProjection = allowPrimitiveClasses &&\n-                        tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref && tree.type.isReferenceProjection();\n@@ -1255,3 +1250,0 @@\n-                    if (requireReferenceProjection) {\n-                        tree.setType(tree.type.referenceProjection());\n-                    }\n@@ -1261,3 +1253,0 @@\n-                    if (requireReferenceProjection) {\n-                        tree.setType(tree.type.referenceProjection());\n-                    }\n@@ -1820,1 +1809,1 @@\n-        if (types.asSuper(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) == null) {\n+        if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {\n@@ -2204,2 +2193,1 @@\n-        return (tree == null) ? null :\n-                applyPrimitiveConversionsAsNeeded(boxIfNeeded(translate(tree), type), type);\n+        return (tree == null) ? null : boxIfNeeded(translate(tree), type);\n@@ -3233,11 +3221,0 @@\n-    \/** Apply primitive value\/reference conversions as needed *\/\n-    @SuppressWarnings(\"unchecked\")\n-    <T extends JCExpression> T applyPrimitiveConversionsAsNeeded(T tree, Type type) {\n-        boolean haveValue = tree.type.isPrimitiveClass();\n-        if (haveValue == type.isPrimitiveClass())\n-            return tree;\n-        \/\/ For narrowing conversion, insert a cast which should trigger a null check\n-        \/\/ For widening conversions, insert a cast if emitting a unified class file.\n-        return (T) make.TypeCast(type, tree);\n-    }\n-\n@@ -3642,1 +3619,1 @@\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type.referenceProjectionOrSelf()),\n+            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n@@ -3652,1 +3629,1 @@\n-            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n+            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n@@ -4244,5 +4221,0 @@\n-        \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-         * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-         * always matching the behavior of Object::getClass\n-         *\/\n-        boolean needPrimaryMirror = tree.name == names._class && tree.selected.type.isReferenceProjection();\n@@ -4250,3 +4222,0 @@\n-        if (needPrimaryMirror && allowPrimitiveClasses && tree.selected.type.isPrimitiveClass()) {\n-            tree.selected.setType(tree.selected.type.referenceProjection());\n-        }\n@@ -4260,1 +4229,1 @@\n-            Assert.checkNonNull(types.asSuper(currentClass.type.referenceProjectionOrSelf(), supSym));\n+            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":5,"deletions":36,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -154,1 +153,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -423,14 +421,0 @@\n-        if (allowPrimitiveClasses) {\n-            if (sym.kind == MTH || sym.kind == VAR) {\n-                \/* If any primitive class types are involved, ask the same question in the reference universe,\n-                   where the hierarchy is navigable\n-                *\/\n-                if (site.isPrimitiveClass())\n-                    site = site.referenceProjection();\n-            } else if (sym.kind == TYP) {\n-                \/\/ A type is accessible in a reference projection if it was\n-                \/\/ accessible in the value projection.\n-                if (site.isReferenceProjection())\n-                    site = site.valueProjection();\n-            }\n-        }\n@@ -491,7 +475,0 @@\n-        \/* If any primitive class types are involved, ask the same question in the reference universe,\n-           where the hierarchy is navigable\n-        *\/\n-        if (allowPrimitiveClasses && site.isPrimitiveClass()) {\n-            site = site.referenceProjection();\n-        }\n-\n@@ -1720,1 +1697,1 @@\n-                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n+                    if (types.asSuper(m1Owner.type, m2Owner) != null &&\n@@ -1725,1 +1702,1 @@\n-                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n+                    if (types.asSuper(m2Owner.type, m1Owner) != null &&\n@@ -3627,1 +3604,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n@@ -3680,1 +3657,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n+                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);\n@@ -3742,1 +3719,1 @@\n-                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata(), site.getFlavor());\n+                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata());\n@@ -3832,1 +3809,1 @@\n-                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -112,4 +111,0 @@\n-    \/** Switch: allow primitive classes.\n-     *\/\n-    boolean allowPrimitiveClasses;\n-\n@@ -294,1 +289,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -514,1 +508,0 @@\n-        case 'Q':\n@@ -518,4 +511,0 @@\n-                if ((char) signature[sigp] == 'Q' && !allowPrimitiveClasses) {\n-                    throw badClassFile(\"bad.class.signature\",\n-                                       quoteBadSignature());\n-                }\n@@ -580,1 +569,1 @@\n-        if (prefix != 'L' && (!allowPrimitiveClasses || prefix != 'Q'))\n+        if (prefix != 'L')\n@@ -585,1 +574,0 @@\n-        ClassType.Flavor flavor;\n@@ -598,1 +586,0 @@\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -602,2 +589,1 @@\n-                        \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n-                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n@@ -605,1 +591,1 @@\n-                    return new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    return new ClassType(outer, List.nil(), t, List.nil());\n@@ -616,2 +602,1 @@\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                outer = new ClassType(outer, sigToTypes('>'), t, List.nil(), flavor) {\n+                outer = new ClassType(outer, sigToTypes('>'), t, List.nil()) {\n@@ -681,2 +666,1 @@\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                    outer = new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    outer = new ClassType(outer, List.nil(), t, List.nil());\n@@ -2638,5 +2622,0 @@\n-        if ((flags & PRIMITIVE_CLASS) != 0) {\n-            if (!allowPrimitiveClasses || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n-                throw badClassFile(\"bad.access.flags\", Flags.toString(flags));\n-            }\n-        }\n@@ -2907,6 +2886,0 @@\n-        if ((flags & ACC_PRIMITIVE) != 0) {\n-            flags &= ~ACC_PRIMITIVE;\n-            if (allowPrimitiveClasses) {\n-                flags |= PRIMITIVE_CLASS;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -113,2 +113,0 @@\n-    private boolean allowPrimitiveClasses;\n-\n@@ -200,2 +198,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -1303,1 +1299,1 @@\n-                databuf.appendChar(allowPrimitiveClasses && t.isPrimitiveClass() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n+                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n@@ -1792,2 +1788,0 @@\n-        if ((flags & PRIMITIVE_CLASS) != 0)\n-            result |= ACC_PRIMITIVE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-    private boolean allowPrimitiveClasses;\n@@ -199,2 +198,1 @@\n-                PoolWriter poolWriter,\n-                boolean allowPrimitiveClasses) {\n+                PoolWriter poolWriter) {\n@@ -222,1 +220,0 @@\n-        this.allowPrimitiveClasses = allowPrimitiveClasses;\n@@ -1072,1 +1069,1 @@\n-            Type t = types.erasure(data instanceof  ConstantPoolQType ? ((ConstantPoolQType)data).type: (Type)data);\n+            Type t = types.erasure((Type)data);\n@@ -1786,6 +1783,2 @@\n-                if (!allowPrimitiveClasses) {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)));\n-                } else {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||\n-                            (old.isPrimitiveClass() != t.isPrimitiveClass() && types.isConvertible(types.erasure(old), types.erasure(t))));\n-                }\n+                Assert.check(types.isSubtype(types.erasure(old),\n+                                       types.erasure(t)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -138,2 +138,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -184,2 +182,0 @@\n-    boolean allowPrimitiveClasses;\n-\n@@ -275,14 +271,0 @@\n-    \/** Insert a reference to given type in the constant pool,\n-     *  checking for an array with too many dimensions;\n-     *  return the reference's index.\n-     *  @param type   The type for which a reference is inserted.\n-     *\/\n-    int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {\n-        checkDimension(pos, type);\n-        if (emitQtype) {\n-            return poolWriter.putClass(new ConstantPoolQType(type, types));\n-        } else {\n-            return poolWriter.putClass(type);\n-        }\n-    }\n-\n@@ -295,1 +277,2 @@\n-        return makeRef(pos, type, false);\n+        checkDimension(pos, type);\n+        return poolWriter.putClass(type);\n@@ -1072,2 +1055,1 @@\n-                                        poolWriter,\n-                                        allowPrimitiveClasses);\n+                                        poolWriter);\n@@ -2120,1 +2102,1 @@\n-                code.emitAnewarray(makeRef(pos, elemtype, elemtype.isPrimitiveClass()), type);\n+                code.emitAnewarray(makeRef(pos, elemtype), type);\n@@ -2346,1 +2328,0 @@\n-        \/\/ primitive reference conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n@@ -2349,9 +2330,2 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n-           !types.isSubtype(tree.expr.type, tree.clazz.type)) {\n-            checkDimension(tree.pos(), tree.clazz.type);\n-            if (tree.clazz.type.isPrimitiveClass()) {\n-                code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);\n-            } else {\n-                code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);\n-            }\n-\n+           types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {\n+            code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);\n@@ -2419,1 +2393,1 @@\n-            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.tools.javac.code.Type.ConstantPoolQType;\n@@ -128,2 +127,0 @@\n-        if (t.isReferenceProjection())\n-            t = t.valueProjection();\n@@ -133,8 +130,0 @@\n-    \/**\n-     * Puts a type into the pool and return its index. The type could be either a class, a type variable\n-     * or an array type.\n-     *\/\n-    int putClass(ConstantPoolQType t) {\n-        return pool.writeIfNeeded(t);\n-    }\n-\n@@ -399,1 +388,1 @@\n-                    Type ct = c instanceof ConstantPoolQType ? ((ConstantPoolQType)c).type : (Type)c;\n+                    Type ct = (Type)c;\n@@ -402,1 +391,1 @@\n-                      c instanceof ConstantPoolQType ? names.fromString(\"Q\" + externalize(ct.tsym.flatName()) + \";\") : externalize(ct.tsym.flatName());\n+                            externalize(ct.tsym.flatName());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -333,13 +333,0 @@\n-            if (selectedType.isReferenceProjection()) {\n-                switch (sym.kind) {\n-                    case MTH:\n-                    case VAR:\n-                        if (sym.isStatic() && sitesym != null && sitesym.kind == TYP) {\n-                            fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n-                        }\n-                        break;\n-                    case TYP:\n-                        fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n-                        break;\n-                }\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym, sym.type.getFlavor());\n+            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym);\n@@ -301,1 +301,1 @@\n-        if (types.asSuper(site.referenceProjectionOrSelf(), sym.getEnclosingElement()) == null)\n+        if (types.asSuper(site, sym.getEnclosingElement()) == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,1 +198,0 @@\n-        this.allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && fac.options.isSet(\"enablePrimitiveClasses\");\n@@ -223,1 +222,0 @@\n-        this.allowPrimitiveClasses = parser.allowPrimitiveClasses;\n@@ -262,4 +260,0 @@\n-    \/** Switch: are primitive classes allowed in this source level?\n-     *\/\n-     boolean allowPrimitiveClasses;\n-\n@@ -2614,1 +2608,1 @@\n-            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS | Flags.FINAL);\n+            long badModifiers = mods.flags & ~(Flags.VALUE_CLASS | Flags.FINAL);\n@@ -2971,1 +2965,1 @@\n-        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+        if ((isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n@@ -3566,4 +3560,0 @@\n-                if (isPrimitiveModifier()) {\n-                    flag = Flags.PRIMITIVE_CLASS;\n-                    break;\n-                }\n@@ -3844,5 +3834,0 @@\n-        if (name == names.primitive) {\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            }\n-        }\n@@ -3857,3 +3842,1 @@\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            } else if (shouldWarn) {\n+            if (shouldWarn) {\n@@ -4932,26 +4915,0 @@\n-    protected boolean isPrimitiveModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.primitive) {\n-            boolean isPrimitiveModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n-                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n-                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n-                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n-                case CLASS: case INTERFACE: case ENUM:\n-                    isPrimitiveModifier = true;\n-                    break;\n-                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n-                            || next.name() == names.value || (mode & EXPR) != 0)\n-                        isPrimitiveModifier = true;\n-                    break;\n-            }\n-            if (isPrimitiveModifier) {\n-                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -4970,1 +4927,1 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || new value Comparable() {} ??\n@@ -4972,1 +4929,1 @@\n-                            || next.name() == names.primitive || (mode & EXPR) != 0)\n+                            || (mode & EXPR) != 0)\n@@ -4997,1 +4954,1 @@\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                    if (next.name() == names.record || next.name() == names.identity\n@@ -5527,4 +5484,1 @@\n-        if (feature == Feature.PRIMITIVE_CLASSES && !allowPrimitiveClasses) {\n-            \/\/ primitive classes are special\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n-        } else if (preview.isPreview(feature) && !preview.isEnabled()) {\n+        if (preview.isPreview(feature) && !preview.isEnabled()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":53,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -1340,1 +1339,1 @@\n-                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil(), Flavor.X_Typeof_X);\n+                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4032,5 +4032,0 @@\n-# 0: string (expected version)\n-compiler.err.primitive.classes.not.supported=\\\n-    primitive classes are not supported\\n\\\n-     (use -source {0} or higher to enable primitive classes and pass compiler option: -XDenablePrimitiveClasses)\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -877,22 +877,7 @@\n-                if (t.isReferenceProjection()) {\n-                    \/\/ For parameterized types, we want V.ref<A1 ... An> not V<A1 ... An>.ref\n-                    JCExpression vp = Type(t.valueProjection());\n-                    if (vp.hasTag(Tag.TYPEAPPLY)) {\n-                        \/\/ vp now is V<A1 ... An>, build V.ref<A1 ... An>\n-                        JCFieldAccess f = Select(((JCTypeApply) vp).clazz, t.tsym);\n-                        f.name = names.ref;\n-                        tp = TypeApply(f, ((JCTypeApply) vp).arguments);\n-                    } else {\n-                        JCFieldAccess f = Select(vp, t.tsym);\n-                        f.name = names.ref;\n-                        tp = f;\n-                    }\n-                } else {\n-                    Type outer = t.getEnclosingType();\n-                    JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n-                            ? Select(Type(outer), t.tsym)\n-                            : QualIdent(t.tsym);\n-                    tp = t.getTypeArguments().isEmpty()\n-                            ? clazz\n-                            : TypeApply(clazz, Types(t.getTypeArguments()));\n-                }\n+                Type outer = t.getEnclosingType();\n+                JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n+                        ? Select(Type(outer), t.tsym)\n+                        : QualIdent(t.tsym);\n+                tp = t.getTypeArguments().isEmpty()\n+                        ? clazz\n+                        : TypeApply(clazz, Types(t.getTypeArguments()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-    public final Name primitive;\n@@ -217,2 +216,0 @@\n-    public final Name ref;\n-    public final Name val;\n@@ -316,1 +313,0 @@\n-        primitive = fromString(\"primitive\");\n@@ -423,1 +419,0 @@\n-        \/\/ primitive classes\n@@ -425,2 +420,0 @@\n-        ref = fromString(\"ref\");\n-        val = fromString(\"val\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-            \"0: #118(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n-            \"1: #118(): LOCAL_VARIABLE, {start_pc=2, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #120(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n+            \"1: #120(): LOCAL_VARIABLE, {start_pc=5, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n@@ -84,1 +84,1 @@\n-            \"0: #118(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #120(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/BridgeShouldHaveNoInteriorAnnotationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/api\/TestApisWithProjections.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.primitive.classes.not.supported\n-\n-public primitive class PrimitiveClassesNotSupported {\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveClassesNotSupported.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.projection.cant.be.instantiated\n-\/\/ options: -XDenablePrimitiveClasses\n-\n-public primitive class ProjectionCantBeInstantiated {\n-    int x = 42;\n-    public static void main(String[] args) {\n-        new ProjectionCantBeInstantiated();\n-        new ProjectionCantBeInstantiated.ref();\n-        new ProjectionCantBeInstantiated.val();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProjectionCantBeInstantiated.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValue.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValueType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayCreationWithQuestion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AsSuperTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AssortedTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AttributesTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AutoCloseableTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BogusIncompatibility.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BoxValCastTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CanonicalCtorTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNoNullCheckTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNullCheckTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ChainedAssignmentTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckBadSelector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckCyclicMembership.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFieldDescriptors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlags.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableCycles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableFlagFromClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableSyntheticFields.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash01.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckLocalClasses.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMakeDefault.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMultiDimensionalArrayStore.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullAssign.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullCastable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullWithQuestion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckQuestionInMessages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSeparateCompile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckStaticFinalAssign.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSuperCompileOnly.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSynchronized.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n@@ -10,1 +11,1 @@\n-\tprivate final int x, ymx;\n+    private final int x, ymx;\n@@ -12,1 +13,1 @@\n-\tV(int x, int y) {\n+    V(int x, int y) {\n@@ -14,2 +15,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -17,3 +18,3 @@\n-\t\tvalidate();                 \/\/ BAD to call instance method DU = {x, ymx}\n-\t\tthis.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n-\t\tV.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n+        validate();                 \/\/ BAD to call instance method DU = {x, ymx}\n+        this.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n+        V.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n@@ -21,2 +22,2 @@\n-\t\tSystem.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n-\t\tSystem.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n+        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n+        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n@@ -24,2 +25,2 @@\n-\t\tV v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n-\t\tv = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n+        V v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n+        v = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n@@ -27,2 +28,2 @@\n-\t\tymx = y - x;                \/\/ OK, implicit this for field write.\n-\t\tint l = this.ymx;           \/\/ OK, explicit this for DA field read.\n+        ymx = y - x;                \/\/ OK, implicit this for field write.\n+        int l = this.ymx;           \/\/ OK, explicit this for DA field read.\n@@ -30,2 +31,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -33,3 +34,3 @@\n-\t\tvalidate();                 \/\/ BAD to call instance method DU = {x}\n-\t\tthis.validate();            \/\/ BAD to call instance method DU = {x}\n-\t\tV.this.validate();          \/\/ BAD to call instance method DU = {x}\n+        validate();                 \/\/ BAD to call instance method DU = {x}\n+        this.validate();            \/\/ BAD to call instance method DU = {x}\n+        V.this.validate();          \/\/ BAD to call instance method DU = {x}\n@@ -37,2 +38,2 @@\n-\t\tSystem.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n-\t\tSystem.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n+        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n+        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n@@ -40,2 +41,2 @@\n-\t\tv = this;                   \/\/ BAD to create alias  DU = {x}\n-\t\tv = V.this;                 \/\/ BAD to create alias  DU = {x}\n+        v = this;                   \/\/ BAD to create alias  DU = {x}\n+        v = V.this;                 \/\/ BAD to create alias  DU = {x}\n@@ -43,1 +44,1 @@\n-\t\tthis.x = x;\n+        this.x = x;\n@@ -47,2 +48,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -50,3 +51,3 @@\n-\t\tvalidate();                 \/\/ OK: DU = {}\n-\t\tthis.validate();            \/\/ OK: DU = {}\n-\t\tV.this.validate();          \/\/ OK: DU = {}\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        V.this.validate();          \/\/ OK: DU = {}\n@@ -54,2 +55,2 @@\n-\t\tSystem.out.println(this);   \/\/ OK: DU = {}\n-\t\tSystem.out.println(V.this); \/\/ OK: DU = {}\n+        System.out.println(this);   \/\/ OK: DU = {}\n+        System.out.println(V.this); \/\/ OK: DU = {}\n@@ -57,5 +58,5 @@\n-\t\tv = this;                   \/\/ OK: DU = {}\n-\t\tv = V.this;                 \/\/ OK: DU = {}\n-\t\tassert (this.x > 0);        \/\/ OK: DU = {}\n-\t\tassert (this.y() > 0);      \/\/ OK: DU = {}\n-\t}\n+        v = this;                   \/\/ OK: DU = {}\n+        v = V.this;                 \/\/ OK: DU = {}\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n@@ -63,1 +64,1 @@\n-\tV() { \/\/ non-initial constructor. All, statements below are OK.\n+    V() { \/\/ non-initial constructor. All, statements below are OK.\n@@ -65,2 +66,2 @@\n-\t\tOK();                       \n-\t\tthis.OK();                  \n+        OK();\n+        this.OK();\n@@ -68,3 +69,3 @@\n-\t\tvalidate();                 \n-\t\tthis.validate();            \n-\t\tV.this.validate();          \n+        validate();\n+        this.validate();\n+        V.this.validate();\n@@ -72,2 +73,2 @@\n-\t\tSystem.out.println(this);   \n-\t\tSystem.out.println(V.this); \n+        System.out.println(this);\n+        System.out.println(V.this);\n@@ -75,2 +76,2 @@\n-\t\tV v = this;                 \n-\t\tv = V.this;                 \n+        V v = this;\n+        v = V.this;\n@@ -78,1 +79,1 @@\n-\t\tint l = this.ymx;           \n+        int l = this.ymx;\n@@ -80,3 +81,3 @@\n-\t\tassert (this.x > 0);        \n-\t\tassert (this.y() > 0);      \n-\t}\n+        assert (this.x > 0);\n+        assert (this.y() > 0);\n+    }\n@@ -84,2 +85,2 @@\n-\tstatic void OK() {\n-\t}\n+    static void OK() {\n+    }\n@@ -87,3 +88,3 @@\n-\tint x() {\n-\t\treturn x;\n-\t}\n+    int x() {\n+        return x;\n+    }\n@@ -91,3 +92,3 @@\n-\tint y() {\n-\t\treturn ymx + x;\n-\t}\n+    int y() {\n+        return ymx + x;\n+    }\n@@ -95,3 +96,3 @@\n-\tvoid validate() {\n-\t\tassert (x() > 0 && y() > 0);\n-\t}\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n@@ -99,5 +100,5 @@\n-\tpublic static void main(String... av) {\n-\t\tV z = new V(1, 10);\n-\t\tassert (z.x() == 1);\n-\t\tassert (z.y() == 10);\n-\t}\n+    public static void main(String... av) {\n+        V z = new V(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.java","additions":66,"deletions":65,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckValueModifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralNegativeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralTypingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilerNoBogusAssert.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilesJustFine.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConditionalInlineTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConstantPropagationTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CtorChain.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultNonInlines.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultOfPrimitiveReference.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n@@ -42,1 +43,1 @@\n- \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DocLintSyntheticsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DualNonDuplicateErrors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EmptyValueTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EnhancedForLoopTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes3.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericArrayRegression.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n@@ -35,1 +36,1 @@\n-  \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues1.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n@@ -37,1 +38,1 @@\n-  \n+\n@@ -41,1 +42,1 @@\n-  \n+\n@@ -45,1 +46,1 @@\n-  \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues2.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -37,1 +38,1 @@\n-  \n+\n@@ -41,1 +42,1 @@\n-  \n+\n@@ -44,1 +45,1 @@\n-    \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues3.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues4.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues5.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GetClassTypingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ImplicitIdentityTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InferredValueParameterizationTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineClassTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineDiamondTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerClassAttributeValuenessTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerValueNew.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InstanceofProjectionArray.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LocalValueNew.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LubWithInlines.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoCrashTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoUnnecessaryCast.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ParameterizedDefault.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Point.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PreloadAttributeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectedArrayDotClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProperTypeApplySelectTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QPointConsumer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n@@ -34,1 +35,1 @@\n-    class Inner { \n+    class Inner {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedSuperCtor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedThisTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/RefDotClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileGenerics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest01.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n@@ -46,1 +47,1 @@\n-            int l = 1234; \n+            int l = 1234;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SignatureTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SmallSetTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StaticSelectedThroughProjection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StreamsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperHashCodeEqualsToStringTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/T8279655.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestQualifierOnInit.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestReflectiveMirrors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ThisIsNotAnInstanceField.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeVarSynchronize.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnannotatedProjection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassBytecodeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassInnerClassesTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassNestHostTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnrelatedThisLeak.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValRefTokensTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAsEnclosingClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueBootstrapMethodsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n@@ -43,2 +44,2 @@\n-    \n-    public static void main(String [] args) {   \n+\n+    public static void main(String [] args) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueConstructorRef.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueCreationTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueNewReadWrite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValuesAsRefs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldOfGenericType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldRuntimeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    public static primitive class P {\n+    public static class P {\n@@ -62,1 +62,1 @@\n-        Supplier<P.ref> sxp = P::new;\n+        Supplier<P> sxp = P::new;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConstructorRefTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,15 +190,7 @@\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-XDenablePrimitiveClasses\"};\n-            setCompileOptions(testOptions);\n-            String[] sources = new String[] {\n-                    \"static static class StaticTest {}\",\n-                    \"native native class NativeTest {}\",\n-                    \"value value primitive class ValueTest {}\",\n-                    \"primitive primitive value class PrimitiveTest {}\"\n-            };\n-            for (String source : sources) {\n-                assertFail(\"compiler.err.repeated.modifier\", source);\n-            }\n-        } finally {\n-            setCompileOptions(previousOptions);\n+        String[] sources = new String[] {\n+                \"static static class StaticTest {}\",\n+                \"native native class NativeTest {}\",\n+                \"value value class ValueTest {}\"\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.repeated.modifier\", source);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"}]}