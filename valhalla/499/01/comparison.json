{"files":[{"patch":"@@ -2049,1 +2049,1 @@\n-  if (sig_type == JVM_SIGNATURE_CLASS) {\n+  if (sig_type == JVM_SIGNATURE_CLASS || sig_type == JVM_SIGNATURE_INLINE_TYPE) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Tests that all FieldAccess and FieldModification notifications\n+            are generated for primitive classes.\n+ * @requires vm.jvmti\n+ * @compile FieldAccessModify.java\n+ * @run main\/othervm\/native -agentlib:FieldAccessModify FieldAccessModify\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+\n+\n+public class FieldAccessModify {\n+\n+    private static final String agentLib = \"FieldAccessModify\";\n+\n+    private static primitive class MyPrimitive {\n+        public int MyPrimitive_fld1;\n+        public int MyPrimitive_fld2;\n+\n+        public MyPrimitive(int v1, int v2) { MyPrimitive_fld1 = v1; MyPrimitive_fld2 = v2; }\n+\n+        public static MyPrimitive create(int v1, int v2) {\n+            return new MyPrimitive(v1, v2);\n+        }\n+\n+        public String toString() {\n+            return \"MyPrimitive { fld1=\" + MyPrimitive_fld1 + \", fld2=\" + MyPrimitive_fld2 + \"}\";\n+        }\n+\n+    }\n+\n+    private static class InstanceHolder {\n+        public final MyPrimitive InstanceHolder_fld1;\n+\n+        public InstanceHolder(int v) {\n+            InstanceHolder_fld1 = MyPrimitive.create(v, v + 100);\n+        }\n+\n+        public String toString() {\n+            return \"InstanceHolder { fld1 is \" + InstanceHolder_fld1 + \"}\";\n+        }\n+    }\n+\n+    private static primitive class PrimitiveHolder {\n+        public MyPrimitive PrimitiveHolder_fld1;\n+\n+        public PrimitiveHolder(int v) {\n+            PrimitiveHolder_fld1 = MyPrimitive.create(v, v + 200);\n+        }\n+\n+        public String toString() {\n+            return \"PrimitiveHolder { fld1 is \" + PrimitiveHolder_fld1 + \"}\";\n+        }\n+    }\n+\n+    private static class TestHolder {\n+        public MyPrimitive primitiveObj = MyPrimitive.create(1, 1);\n+        public InstanceHolder instanceHolderObj = new InstanceHolder(1);\n+        public PrimitiveHolder primitiveHolderObj = new PrimitiveHolder(1);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            System.loadLibrary(agentLib);\n+        } catch (UnsatisfiedLinkError ex) {\n+            System.err.println(\"Failed to load \" + agentLib + \" lib\");\n+            System.err.println(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ex;\n+        }\n+\n+        \/\/ create objects for access testing before setting watchers\n+        TestHolder testHolder = new TestHolder();\n+\n+        if (!initWatchers(MyPrimitive.class, MyPrimitive.class.getDeclaredField(\"MyPrimitive_fld1\"))) {\n+            throw new RuntimeException(\"Watchers initializations error (MyPrimitive_fld1)\");\n+        }\n+        if (!initWatchers(MyPrimitive.class, MyPrimitive.class.getDeclaredField(\"MyPrimitive_fld2\"))) {\n+            throw new RuntimeException(\"Watchers initializations error (MyPrimitive_fld2)\");\n+        }\n+        if (!initWatchers(InstanceHolder.class, InstanceHolder.class.getDeclaredField(\"InstanceHolder_fld1\"))) {\n+            throw new RuntimeException(\"Watchers initializations error (InstanceHolder_fld1)\");\n+        }\n+        if (!initWatchers(PrimitiveHolder.class, PrimitiveHolder.class.getDeclaredField(\"PrimitiveHolder_fld1\"))) {\n+            throw new RuntimeException(\"Watchers initializations error (PrimitiveHolder_fld1)\");\n+        }\n+\n+        test(\"MyPrimitive (access)\", () -> {\n+                testHolder.primitiveObj.toString();     \/\/ should access both MyPrimitive_fld1 and MyPrimitive_fld2\n+            }, new TestResult() {\n+                public boolean MyPrimitive_fld1_access;\n+                public boolean MyPrimitive_fld2_access;\n+            });\n+\n+        test(\"InstanceHolder (access)\", () ->  {\n+                testHolder.instanceHolderObj.toString();\n+            }, new TestResult() {\n+                public boolean InstanceHolder_fld1_access;\n+                \/\/ MyPrimitive fields should be accessed too\n+                public boolean MyPrimitive_fld1_access;\n+                public boolean MyPrimitive_fld2_access;\n+            });\n+\n+        test(\"PrimitiveHolder (access)\", () ->  {\n+                testHolder.primitiveHolderObj.toString();\n+            }, new TestResult() {\n+                public boolean PrimitiveHolder_fld1_access;\n+                \/\/ MyPrimitive fields should be accessed too\n+                public boolean MyPrimitive_fld1_access;\n+                public boolean MyPrimitive_fld2_access;\n+            });\n+\n+        test(\"MyPrimitive (modify)\", () ->  {\n+                MyPrimitive obj = MyPrimitive.create(1, 1);\n+            }, new TestResult() {\n+                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld1_modify;\n+                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld2_modify;\n+            });\n+\n+        test(\"InstanceHolder (modify)\", () ->  {\n+                InstanceHolder obj = new InstanceHolder(10);\n+            }, new TestResult() {\n+                public boolean InstanceHolder_fld1_modify;\n+                \/\/ MyPrimitive fields should be modified too\n+                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld1_modify;\n+                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld2_modify;\n+            });\n+\n+        test(\"PrimitiveHolder (modify)\", () ->  {\n+                PrimitiveHolder obj = new PrimitiveHolder(11);\n+            }, new TestResult() {\n+                \/\/ KNOWN_ISSUE public boolean PrimitiveHolder_fld1_modify;\n+                \/\/ MyPrimitive fields should be modified too\n+                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld1_modify;\n+                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld2_modify;\n+            });\n+\n+    }\n+\n+    private static void log(String msg) {\n+        System.out.println(msg);\n+        System.out.flush();\n+    }\n+\n+    private static void assertTrue(boolean value) {\n+        if (!value) {\n+            throw new RuntimeException(\"assert\");\n+        }\n+    }\n+\n+    \/\/ For every access\/modify notification native part tries to locate\n+    \/\/ boolean \"<field_name>_access\"\/\"<field_name>_modify\" field and sets it to true\n+    private static class TestResult {\n+\n+        \/\/ verify that all fields are set to true\n+        public void verify() {\n+            Arrays.stream(this.getClass().getDeclaredFields()).forEach(f -> verify(f));\n+        }\n+\n+        private void verify(Field f) {\n+            try {\n+                if (!f.getBoolean(this)) {\n+                    throw new RuntimeException(f.getName() + \" notification is missed\");\n+                }\n+                log(\"  - \" + f.getName() + \": OK\");\n+            } catch (IllegalAccessException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface TestAction {\n+        void apply();\n+    }\n+\n+    private static void test(String descr, TestAction action, TestResult result) throws Exception {\n+        log(descr + \": starting\");\n+        if (!startTest(result)) {\n+            throw new RuntimeException(\"startTest failed\");\n+        }\n+        action.apply();\n+        \/\/ wait some time to ensure all posted events are handled\n+        Thread.sleep(500);\n+\n+        stopTest();\n+\n+        \/\/ check the results\n+        result.verify();\n+\n+        log(descr + \": OK\");\n+        log(\"\");\n+    }\n+\n+    private static native boolean initWatchers(Class cls, Field field);\n+    private static native boolean startTest(TestResult results);\n+    private static native void stopTest();\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Valhalla\/FieldAccessModify\/FieldAccessModify.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,334 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+static jvmtiEnv *jvmti = nullptr;\n+\n+\/\/ valid while a test is executed\n+static jobject testResultObject = nullptr;\n+static jclass testResultClass = nullptr;\n+\/\/ we log object values handling FieldModification event and this cause FieldAccess events are triggered.\n+\/\/ The flag to disable FieldAccess handling.\n+static bool disableAccessEvent = false;\n+\n+static void reportError(const char *msg, int err) {\n+    printf(\"%s, error: %d\\n\", msg, err);\n+}\n+\n+static void printJValue(const char *prefix, JNIEnv *jni_env, char signature_type, jvalue value) {\n+    \/\/ print new_value to ensure the value is valid\n+    \/\/ use String.valueOf(...) to get string representation\n+    \/*\n+    Z boolean\n+    B byte\n+    C char\n+    S short\n+    I int\n+    J long\n+    F float\n+    D double\n+    L fully-qualified-class ;   fully-qualified-class\n+    [ type                      type[]\n+    *\/\n+    char signature[64] = {};\n+    if (signature_type == 'Q' || signature_type == 'L') {\n+        sprintf(signature, \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+    } else {\n+        sprintf(signature, \"(%c)Ljava\/lang\/String;\", signature_type);\n+    }\n+\n+    jclass clsString = jni_env->FindClass(\"java\/lang\/String\");\n+    jmethodID mid = jni_env->GetStaticMethodID(clsString, \"valueOf\", signature);\n+    jstring objJStr = (jstring)jni_env->CallStaticObjectMethodA(clsString, mid, &value);\n+\n+    const char* objStr = \"UNKNOWN\";\n+    if (objJStr != nullptr) {\n+        objStr = jni_env->GetStringUTFChars(objJStr, nullptr);\n+    }\n+\n+    printf(\"    %s is: '%s'\\n\", prefix, objStr);\n+    fflush(0);\n+\n+    if (objJStr != nullptr) {\n+        jni_env->ReleaseStringUTFChars(objJStr, objStr);\n+    }\n+}\n+\n+\n+\/\/ logs the notification and updates currentTestResult\n+static void handleNotification(jvmtiEnv *jvmti, JNIEnv *jni_env,\n+    jmethodID method,\n+    jobject object,\n+    jfieldID field,\n+    jclass field_klass,\n+    bool modified,\n+    jlocation location)\n+{\n+    jvmtiError err;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n+    char *mname = nullptr;\n+    char *mgensig = nullptr;\n+    jclass methodClass = nullptr;\n+    char *csig = nullptr;\n+\n+    if (testResultObject == nullptr) {\n+        \/\/ we are out of test\n+        return;\n+    }\n+\n+    err = jvmti->GetFieldName(field_klass, field, &name, &signature, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"GetFieldName failed\", err);\n+        return;\n+    }\n+\n+    err = jvmti->GetMethodName(method, &mname, nullptr, &mgensig);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"GetMethodName failed\", err);\n+        return;\n+    }\n+\n+    err = jvmti->GetMethodDeclaringClass(method, &methodClass);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"GetMethodDeclaringClass failed\", err);\n+        return;\n+    }\n+\n+    err = jvmti->GetClassSignature(methodClass, &csig, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"GetClassSignature failed\", err);\n+        return;\n+    }\n+\n+    printf(\"  \\\"class: %s method: %s%s\\\" %s field: \\\"%s\\\" (type '%s'), location: %d\\n\",\n+        csig, mname, mgensig, modified ? \"modified\" : \"accessed\", name, signature, (int)location);\n+\n+    \/\/ For FieldModification event print current value.\n+    \/\/ Note: this will cause FieldAccess event.\n+    if (modified) {\n+        jvalue curValue = {};\n+        switch (signature[0]) {\n+        case 'L':\n+        case 'Q':\n+            curValue.l = jni_env->GetObjectField(object, field); break;\n+        case 'Z':   \/\/ boolean\n+            curValue.z = jni_env->GetBooleanField(object, field); break;\n+        case 'B':   \/\/ byte\n+            curValue.b = jni_env->GetByteField(object, field); break;\n+        case 'C':   \/\/ char\n+            curValue.c = jni_env->GetCharField(object, field); break;\n+        case 'S':   \/\/ short\n+            curValue.s = jni_env->GetShortField(object, field); break;\n+        case 'I':   \/\/ int\n+            curValue.i = jni_env->GetIntField(object, field); break;\n+        case 'J':   \/\/ long\n+            curValue.j = jni_env->GetLongField(object, field); break;\n+        case 'F':   \/\/ float\n+            curValue.f = jni_env->GetFloatField(object, field); break;\n+        case 'D':   \/\/ double\n+            curValue.d = jni_env->GetDoubleField(object, field); break;\n+        default:\n+            printf(\"ERROR: unexpected signature: %s\\n\", signature);\n+            return;\n+        }\n+        printJValue(\"current value: \", jni_env, signature[0], curValue);\n+    }\n+\n+    \/\/ set TestResult\n+    if (testResultObject != nullptr && testResultClass != nullptr) {\n+        jfieldID fieldID;\n+        \/\/ field names in TestResult are \"<field_name>_access\"\/\"<field_name>_modify\"\n+        char *fieldName = (char *)malloc(strlen(name) + 16);\n+        strcpy(fieldName, name);\n+        strcat(fieldName, modified ? \"_modify\" : \"_access\");\n+\n+        fieldID = jni_env->GetFieldID(testResultClass, fieldName, \"Z\");\n+        if (fieldID != nullptr) {\n+            jni_env->SetBooleanField(testResultObject, fieldID, JNI_TRUE);\n+        } else {\n+            \/\/ the field is not interesting for the test\n+        }\n+        \/\/ clear any possible exception\n+        jni_env->ExceptionClear();\n+\n+        free(fieldName);\n+    }\n+\n+    jvmti->Deallocate((unsigned char*)csig);\n+    jvmti->Deallocate((unsigned char*)mname);\n+    jvmti->Deallocate((unsigned char*)mgensig);\n+    jvmti->Deallocate((unsigned char*)name);\n+    jvmti->Deallocate((unsigned char*)signature);\n+}\n+\n+static void JNICALL\n+onFieldAccess(jvmtiEnv *jvmti_env,\n+            JNIEnv* jni_env,\n+            jthread thread,\n+            jmethodID method,\n+            jlocation location,\n+            jclass field_klass,\n+            jobject object,\n+            jfieldID field)\n+{\n+    if (disableAccessEvent) {\n+        return;\n+    }\n+    handleNotification(jvmti_env, jni_env, method, object, field, field_klass, false, location);\n+}\n+\n+static void JNICALL\n+onFieldModification(jvmtiEnv *jvmti_env,\n+            JNIEnv* jni_env,\n+            jthread thread,\n+            jmethodID method,\n+            jlocation location,\n+            jclass field_klass,\n+            jobject object,\n+            jfieldID field,\n+            char signature_type,\n+            jvalue new_value)\n+{\n+    disableAccessEvent = true;\n+\n+    handleNotification(jvmti_env, jni_env, method, object, field, field_klass, true, location);\n+\n+    printJValue(\"new value\", jni_env, signature_type, new_value);\n+\n+    disableAccessEvent = false;\n+}\n+\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved)\n+{\n+    jvmtiError err;\n+    jvmtiCapabilities caps = {};\n+    jvmtiEventCallbacks callbacks = {};\n+    jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+    if (res != JNI_OK || jvmti == nullptr) {\n+        reportError(\"GetEnv failed\", res);\n+        return JNI_ERR;\n+    }\n+\n+    caps.can_generate_field_modification_events = 1;\n+    caps.can_generate_field_access_events = 1;\n+    caps.can_tag_objects = 1;\n+    err = jvmti->AddCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"Failed to set capabilities\", err);\n+        return JNI_ERR;\n+    }\n+\n+    callbacks.FieldModification = &onFieldModification;\n+    callbacks.FieldAccess = &onFieldAccess;\n+\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"Failed to set event callbacks\", err);\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"Failed to set access notifications\", err);\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"Failed to set modification notifications\", err);\n+        return JNI_ERR;\n+    }\n+    setbuf(stdout, nullptr);\n+    return JNI_OK;\n+}\n+\n+\n+JNIEXPORT jboolean JNICALL\n+Java_FieldAccessModify_initWatchers(JNIEnv *env, jclass thisClass, jclass cls, jobject field)\n+{\n+    jfieldID fieldId;\n+    jvmtiError err;\n+\n+    if (jvmti == nullptr) {\n+        reportError(\"jvmti is NULL\", 0);\n+        return JNI_FALSE;\n+    }\n+\n+    fieldId = env->FromReflectedField(field);\n+\n+    err = jvmti->SetFieldModificationWatch(cls, fieldId);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"SetFieldModificationWatch failed\", err);\n+        return JNI_FALSE;\n+    }\n+\n+    err = jvmti->SetFieldAccessWatch(cls, fieldId);\n+    if (err != JVMTI_ERROR_NONE) {\n+        reportError(\"SetFieldAccessWatch failed\", err);\n+        return JNI_FALSE;\n+    }\n+\n+    return JNI_TRUE;\n+}\n+\n+\n+JNIEXPORT jboolean JNICALL\n+Java_FieldAccessModify_startTest(JNIEnv *env, jclass thisClass, jobject testResults)\n+{\n+    testResultObject = env->NewGlobalRef(testResults);\n+    testResultClass = (jclass)env->NewGlobalRef(env->GetObjectClass(testResultObject));\n+\n+    return JNI_TRUE;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_FieldAccessModify_stopTest(JNIEnv *env, jclass thisClass)\n+{\n+    if (testResultObject != nullptr) {\n+        env->DeleteGlobalRef(testResultObject);\n+        testResultObject = nullptr;\n+    }\n+    if (testResultClass != nullptr) {\n+        env->DeleteGlobalRef(testResultClass);\n+        testResultClass = nullptr;\n+    }\n+}\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Valhalla\/FieldAccessModify\/libFieldAccessModify.cpp","additions":334,"deletions":0,"binary":false,"changes":334,"status":"added"}]}