{"files":[{"patch":"@@ -510,1 +510,1 @@\n-            format_helper(regalloc, st, init_node, \":\", -1, nullptr);\n+            format_helper(regalloc, st, init_node, \":\", -2, nullptr);\n@@ -512,0 +512,5 @@\n+\n+          Node* larval_node = mcall->in(first_ind++);\n+          assert(larval_node != NULL && larval_node->is_Con(), \"is_larval node not found\");\n+          st->print(\" [is_larval\");\n+          format_helper(regalloc, st, larval_node, \":\", -1, NULL);\n@@ -513,1 +518,1 @@\n-        Node* fld_node = mcall->in(first_ind);\n+\n@@ -515,13 +520,6 @@\n-        if (iklass != nullptr) {\n-          st->print(\" [\");\n-          cifield = iklass->nonstatic_field_at(0);\n-          cifield->print_name_on(st);\n-          format_helper(regalloc, st, fld_node, \":\", 0, &scobjs);\n-        } else {\n-          format_helper(regalloc, st, fld_node, \"[\", 0, &scobjs);\n-        }\n-        for (uint j = 1; j < nf; j++) {\n-          fld_node = mcall->in(first_ind+j);\n-          if (iklass != nullptr) {\n-            st->print(\", [\");\n-            cifield = iklass->nonstatic_field_at(j);\n+        uint sec_fields_count = 0;\n+        for (uint j = 0; j < nf; j++) {\n+          Node* fld_node = mcall->in(first_ind + j);\n+          if (iklass != NULL) {\n+            st->print(\" [\");\n+            cifield = iklass->nonstatic_field_at(j - sec_fields_count);\n@@ -530,0 +528,15 @@\n+            sec_fields_count = 0;\n+            if (cifield->is_multifield_base() && !fld_node->bottom_type()->isa_vect()) {\n+              sec_fields_count = cifield->secondary_fields_count() - 1;\n+              for (uint f = 0; f < sec_fields_count; f++) {\n+                st->print(\" [\");\n+                fld_node = mcall->in(first_ind + j + f + 1);\n+                ciField* sec_field = static_cast<ciMultiField*>(cifield)->secondary_field_at(f);\n+                sec_field->print_name_on(st);\n+                format_helper(regalloc, st, fld_node, \":\", j + f + 1, &scobjs);\n+                if (f < sec_fields_count - 1) {\n+                  st->print(\",\");\n+                }\n+              }\n+              j += sec_fields_count;\n+            }\n@@ -531,1 +544,5 @@\n-            format_helper(regalloc, st, fld_node, \", [\", j, &scobjs);\n+            format_helper(regalloc, st, fld_node, \" [\", j, &scobjs);\n+          }\n+\n+          if (j < nf - 1) {\n+            st->print(\",\");\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -80,4 +80,0 @@\n-bool VectorSupport::is_vector_mask(Klass* klass) {\n-  return klass->is_subclass_of(vmClasses::vector_VectorMask_klass());\n-}\n-\n@@ -89,244 +85,0 @@\n-BasicType VectorSupport::klass2bt(InstanceKlass* ik) {\n-  assert(ik->is_subclass_of(vmClasses::vector_VectorPayload_klass()), \"%s not a VectorPayload\", ik->name()->as_C_string());\n-  fieldDescriptor fd; \/\/ find_field initializes fd if found\n-  \/\/ static final Class<?> ETYPE;\n-  Klass* holder = ik->find_field(vmSymbols::ETYPE_name(), vmSymbols::class_signature(), &fd);\n-\n-  assert(holder != nullptr, \"sanity\");\n-  assert(fd.is_static(), \"\");\n-  assert(fd.offset() > 0, \"\");\n-\n-  if (is_vector_mask(ik)) {\n-    return T_BOOLEAN;\n-  } else { \/\/ vector and mask\n-    oop value = ik->java_mirror()->obj_field(fd.offset());\n-    BasicType elem_bt = java_lang_Class::as_BasicType(value);\n-    return elem_bt;\n-  }\n-}\n-\n-jint VectorSupport::klass2length(InstanceKlass* ik) {\n-  fieldDescriptor fd; \/\/ find_field initializes fd if found\n-  \/\/ static final int VLENGTH;\n-  Klass* holder = ik->find_field(vmSymbols::VLENGTH_name(), vmSymbols::int_signature(), &fd);\n-\n-  assert(holder != nullptr, \"sanity\");\n-  assert(fd.is_static(), \"\");\n-  assert(fd.offset() > 0, \"\");\n-\n-  jint vlen = ik->java_mirror()->int_field(fd.offset());\n-  assert(vlen > 0, \"\");\n-  return vlen;\n-}\n-\n-#ifdef COMPILER2\n-Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, int num_elem, BasicType elem_bt, int larval, TRAPS) {\n-  assert(ik->is_inline_klass(), \"\");\n-  instanceOop obj = InlineKlass::cast(ik)->allocate_instance(THREAD);\n-  if (larval) obj->set_mark(obj->mark().enter_larval_state());\n-\n-  fieldDescriptor fd;\n-  Klass* def = ik->find_field(vmSymbols::mfield_name(), vmSymbols::type_signature(elem_bt), false, &fd);\n-  assert(fd.is_multifield_base() && fd.secondary_fields_count(fd.index()) == num_elem, \"\");\n-  return Handle(THREAD, obj);\n-}\n-\n-Symbol* VectorSupport::get_vector_payload_field_signature(BasicType elem_bt, int num_elem) {\n-  switch(elem_bt) {\n-    case T_BOOLEAN:\n-      switch(num_elem) {\n-        case  1: return vmSymbols::vector_VectorPayloadMF8Z_signature();\n-        case  2: return vmSymbols::vector_VectorPayloadMF16Z_signature();\n-        case  4: return vmSymbols::vector_VectorPayloadMF32Z_signature();\n-        case  8: return vmSymbols::vector_VectorPayloadMF64Z_signature();\n-        case 16: return vmSymbols::vector_VectorPayloadMF128Z_signature();\n-        case 32: return vmSymbols::vector_VectorPayloadMF256Z_signature();\n-        case 64: return vmSymbols::vector_VectorPayloadMF512Z_signature();\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_BYTE:\n-      switch(num_elem) {\n-        case  1: return vmSymbols::vector_VectorPayloadMF8B_signature();\n-        case  2: return vmSymbols::vector_VectorPayloadMF16B_signature();\n-        case  4: return vmSymbols::vector_VectorPayloadMF32B_signature();\n-        case  8: return vmSymbols::vector_VectorPayloadMF64B_signature();\n-        case 16: return vmSymbols::vector_VectorPayloadMF128B_signature();\n-        case 32: return vmSymbols::vector_VectorPayloadMF256B_signature();\n-        case 64: return vmSymbols::vector_VectorPayloadMF512B_signature();\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_SHORT:\n-      switch(num_elem) {\n-        case  4: return vmSymbols::vector_VectorPayloadMF64S_signature();\n-        case  8: return vmSymbols::vector_VectorPayloadMF128S_signature();\n-        case 16: return vmSymbols::vector_VectorPayloadMF256S_signature();\n-        case 32: return vmSymbols::vector_VectorPayloadMF512S_signature();\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_INT:\n-      switch(num_elem) {\n-        case  2: return vmSymbols::vector_VectorPayloadMF64I_signature();\n-        case  4: return vmSymbols::vector_VectorPayloadMF128I_signature();\n-        case  8: return vmSymbols::vector_VectorPayloadMF256I_signature();\n-        case 16: return vmSymbols::vector_VectorPayloadMF512I_signature();\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_LONG:\n-      switch(num_elem) {\n-        case  1: return vmSymbols::vector_VectorPayloadMF64L_signature();\n-        case  2: return vmSymbols::vector_VectorPayloadMF128L_signature();\n-        case  4: return vmSymbols::vector_VectorPayloadMF256L_signature();\n-        case  8: return vmSymbols::vector_VectorPayloadMF512L_signature();\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_FLOAT:\n-      switch(num_elem) {\n-        case  2: return vmSymbols::vector_VectorPayloadMF64F_signature();\n-        case  4: return vmSymbols::vector_VectorPayloadMF128F_signature();\n-        case  8: return vmSymbols::vector_VectorPayloadMF256F_signature();\n-        case 16: return vmSymbols::vector_VectorPayloadMF512F_signature();\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_DOUBLE:\n-      switch(num_elem) {\n-        case  1: return vmSymbols::vector_VectorPayloadMF64D_signature();\n-        case  2: return vmSymbols::vector_VectorPayloadMF128D_signature();\n-        case  4: return vmSymbols::vector_VectorPayloadMF256D_signature();\n-        case  8: return vmSymbols::vector_VectorPayloadMF512D_signature();\n-        default: ShouldNotReachHere();\n-      } break;\n-     default:\n-        ShouldNotReachHere();\n-  }\n-  return NULL;\n-}\n-\n-InstanceKlass* VectorSupport::get_vector_payload_klass(BasicType elem_bt, int num_elem) {\n-  switch(elem_bt) {\n-    case T_BOOLEAN:\n-      switch(num_elem) {\n-        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF8Z_klass));\n-        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF16Z_klass));\n-        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF32Z_klass));\n-        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64Z_klass));\n-        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128Z_klass));\n-        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256Z_klass));\n-        case 64: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512Z_klass));\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_BYTE:\n-      switch(num_elem) {\n-        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF8B_klass));\n-        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF16B_klass));\n-        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF32B_klass));\n-        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64B_klass));\n-        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128B_klass));\n-        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256B_klass));\n-        case 64: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512B_klass));\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_SHORT:\n-      switch(num_elem) {\n-        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64S_klass));\n-        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128S_klass));\n-        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256S_klass));\n-        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512S_klass));\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_INT:\n-      switch(num_elem) {\n-        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64I_klass));\n-        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128I_klass));\n-        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256I_klass));\n-        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512I_klass));\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_LONG:\n-      switch(num_elem) {\n-        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64L_klass));\n-        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128L_klass));\n-        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256L_klass));\n-        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512L_klass));\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_FLOAT:\n-      switch(num_elem) {\n-        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64F_klass));\n-        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128F_klass));\n-        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256F_klass));\n-        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512F_klass));\n-        default: ShouldNotReachHere();\n-      } break;\n-    case T_DOUBLE:\n-      switch(num_elem) {\n-        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64D_klass));\n-        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128D_klass));\n-        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256D_klass));\n-        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512D_klass));\n-        default: ShouldNotReachHere();\n-      } break;\n-    default:\n-        ShouldNotReachHere();\n-  }\n-  return NULL;\n-}\n-\n-Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n-  intptr_t is_larval = StackValue::create_stack_value(fr, reg_map, ov->is_larval())->get_int();\n-  jint larval = (jint)*((jint*)&is_larval);\n-  \/\/ Vector payload value in an aligned adjacent tuple (8, 16, 32 or 64 bytes).\n-  return allocate_vector_payload_helper(ik, num_elem, elem_bt, larval, THREAD); \/\/ safepoint\n-}\n-\n-instanceOop VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n-  assert(is_vector_payload_mf(ik), \"%s not a vector payload\", ik->name()->as_C_string());\n-  assert(ik->is_inline_klass(), \"\");\n-\n-  int num_elem = 0;\n-  BasicType elem_bt = T_ILLEGAL;\n-  for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n-    fieldDescriptor& fd = fs.field_descriptor();\n-    if (fd.is_multifield_base()) {\n-      elem_bt = fd.field_type();\n-      num_elem = fd.secondary_fields_count(fd.index());\n-      break;\n-    }\n-  }\n-  assert(num_elem != 0, \"\");\n-  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, num_elem, elem_bt, fr, reg_map, ov, CHECK_NULL);\n-  return (instanceOop)payload_instance();\n-}\n-\n-instanceOop VectorSupport::allocate_vector(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n-  assert(is_vector(ik), \"%s not a vector\", ik->name()->as_C_string());\n-  assert(ik->is_inline_klass(), \"\");\n-\n-  int num_elem = klass2length(ik);\n-  BasicType elem_bt = klass2bt(ik);\n-\n-  \/\/ On-heap vector values are represented as primitive class instances with a multi-field payload.\n-  InstanceKlass* payload_class = get_vector_payload_klass(elem_bt, num_elem);\n-  assert(payload_class->is_inline_klass(), \"\");\n-\n-  Handle payload_instance = VectorSupport::allocate_vector_payload(payload_class, num_elem, elem_bt, fr, reg_map, ov, CHECK_NULL);\n-\n-  Deoptimization::reassign_fields_by_klass(payload_class, fr, reg_map, ov, 0, payload_instance(), true, 0, CHECK_NULL);\n-\n-  instanceOop vbox = ik->allocate_instance(THREAD);\n-  Handle vbox_h = Handle(THREAD, vbox);\n-\n-  fieldDescriptor fd;\n-  Symbol* payload_sig = VectorSupport::get_vector_payload_field_signature(elem_bt, num_elem);\n-  Klass* def = ik->find_field(vmSymbols::payload_name(), payload_sig, false, &fd);\n-  assert(def != NULL, \"\");\n-\n-  if (fd.is_inlined()) {\n-    InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(fd.index()));\n-    field_ik->write_inlined_field(vbox_h(), fd.offset(), payload_instance(), THREAD);\n-  } else {\n-    vbox_h()->obj_field_put(fd.offset(), payload_instance());\n-  }\n-  return vbox;\n-}\n-#endif \/\/ COMPILER2\n-\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":0,"deletions":248,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -40,11 +40,0 @@\n- private:\n-\n-#ifdef COMPILER2\n-  static Handle allocate_vector_payload_helper(InstanceKlass* ik, int num_elem, BasicType elem_bt, int larval, TRAPS);\n-  static Handle allocate_vector_payload(InstanceKlass* ik, int num_elem, BasicType elem_bt, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS);\n-  static InstanceKlass* get_vector_payload_klass(BasicType elem_bt, int num_elem);\n-  static Symbol* get_vector_payload_field_signature(BasicType elem_bt, int num_elem);\n-#endif \/\/ COMPILER2\n-\n-  static BasicType klass2bt(InstanceKlass* ik);\n-  static jint klass2length(InstanceKlass* ik);\n@@ -149,5 +138,0 @@\n-#ifdef COMPILER2\n-  static instanceOop allocate_vector(InstanceKlass* holder, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n-  static instanceOop allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n-#endif \/\/ COMPILER2\n-\n@@ -156,2 +140,0 @@\n-  static bool is_vector_mask(Klass* klass);\n-  static bool is_vector_shuffle(Klass* klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1278,9 +1278,0 @@\n-#ifdef COMPILER2\n-        if (EnableVectorSupport && VectorSupport::is_vector(ik)) {\n-          obj = VectorSupport::allocate_vector(ik, fr, reg_map, sv, THREAD);\n-        } else if (EnableVectorSupport && VectorSupport::is_vector_payload_mf(ik)) {\n-          obj = VectorSupport::allocate_vector_payload(ik, fr, reg_map, sv, THREAD);\n-        } else {\n-          obj = ik->allocate_instance(THREAD);\n-        }\n-#else\n@@ -1288,1 +1279,0 @@\n-#endif \/\/ COMPILER2\n@@ -1308,0 +1298,8 @@\n+    if (k->is_inline_klass()) {\n+      intptr_t is_larval = StackValue::create_stack_value(fr, reg_map, sv->is_larval())->get_int();\n+      jint larval = (jint)*((jint*)&is_larval);\n+      if (larval == 1) {\n+        obj->set_mark(obj->mark().enter_larval_state());\n+      }\n+    }\n+\n@@ -1738,16 +1736,1 @@\n-#ifdef COMPILER2\n-    if (EnableVectorSupport && (VectorSupport::is_vector(k) || VectorSupport::is_vector_payload_mf(k))) {\n-#ifndef PRODUCT\n-        if (PrintDeoptimizationDetails) {\n-          tty->print_cr(\"skip field reassignment for this vector - it should be assigned already\");\n-          if (Verbose) {\n-            Handle obj = sv->value();\n-            k->oop_print_on(obj(), tty);\n-          }\n-        }\n-#endif \/\/ !PRODUCT\n-        continue; \/\/ Such vector's value was already restored in VectorSupport::allocate_vector().\n-      \/\/ Else fall-through to do assignment for scalar-replaced boxed vector representation\n-      \/\/ which could be restored after vector object allocation.\n-    }\n-#endif \/* !COMPILER2 *\/\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"}]}