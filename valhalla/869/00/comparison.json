{"files":[{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * A restricted interface optionally implemented by value objects.\n+ *\n+ * A value object is an instance of a value class, lacking identity.\n+ *\n+ * Every object is either an *identity object* or a *value object*. Identity\n+ * objects have a unique identity determined for them at instance creation time and\n+ * preserved throughout their life.\n+ *\n+ * value objects do *not* have an identity. Instead, they simply aggregate a\n+ * set of immutable field values. The lack of identity enables certain performance\n+ * optimizations by Java Virtual Machine implementations.\n+ * The following operations have special behavior when applied to value\n+ * objects:\n+ *\n+ * - The `==` operator, and the default implementation of the `Object.equals`\n+ * method, compare the values of the operands' fields. Value objects\n+ * created at different points in a program may be `==`.\n+ *\n+ * - The `System.identityHashCode` method, and the default implementation of the\n+ * `Object.hashCode` method, generate a hash code from the hash codes of a\n+ * value object's fields.\n+ *\n+ * - The `synchronized` modifier and `synchronized` statement always fail when\n+ * applied to a value object.\n+ *\n+ * A value class with an `implicit` constructor may also declare that it tolerates\n+ * implicit creation of instances via non-atomic field and array updates.\n+ * This means that, in a race condition, new class instances may be accidentally\n+ * created by intermixing field values from other instances, without any code\n+ * execution or other additional cooperation from the value class. A value class\n+ * opts in to allowing this behavior by implementing this interface.\n+ *\n+ * @since Valhalla\n+ *\/\n+\n+public interface NonAtomic {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/NonAtomic.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -100,0 +100,6 @@\n+    \/**\n+     * The modifier {@code implicit}\n+     * @since 21\n+     *\/\n+    IMPLICIT,\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,5 +108,7 @@\n-    public static final int ACC_IDENTITY = 0x0020;\n-    public static final int ACC_VALUE    = 0x0040;\n-    public static final int ACC_BRIDGE   = 0x0040;\n-    public static final int ACC_VARARGS  = 0x0080;\n-    public static final int ACC_MODULE   = 0x8000;\n+    public static final int ACC_DEFAULT    = 0x0001;\n+    public static final int ACC_NON_ATOMIC = 0x0002;\n+    public static final int ACC_IDENTITY   = 0x0020;\n+    public static final int ACC_VALUE      = 0x0040;\n+    public static final int ACC_BRIDGE     = 0x0040;\n+    public static final int ACC_VARARGS    = 0x0080;\n+    public static final int ACC_MODULE     = 0x8000;\n@@ -422,0 +424,5 @@\n+    \/**\n+     * Flag to indicate that a value class constructor is implicit\n+     *\/\n+    public static final int IMPLICIT    = 1<<59; \/\/ MethodSymbols\n+\n@@ -444,1 +451,1 @@\n-        ConstructorFlags                  = AccessFlags,\n+        ConstructorFlags                  = AccessFlags | IMPLICIT,\n@@ -458,1 +465,1 @@\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS | IMPLICIT,\n@@ -485,0 +492,1 @@\n+            if (0 != (flags & IMPLICIT))        modifiers.add(Modifier.IMPLICIT);\n@@ -506,1 +514,0 @@\n-\n@@ -534,0 +541,1 @@\n+        IMPLICIT(Flags.IMPLICIT),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -241,1 +241,0 @@\n-        PRIMITIVE_CLASSES(JDK21, Fragments.FeaturePrimitiveClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -488,0 +488,6 @@\n+    \/** Is this symbol an implicit constructor?\n+     *\/\n+    public boolean isImplicitConstructor() {\n+        return isInitOrVNew() && ((flags() & IMPLICIT) != 0);\n+    }\n+\n@@ -1682,0 +1688,15 @@\n+\n+        public MethodSymbol getImplicitConstructor() {\n+            for (Symbol s : members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case MTH:\n+                        if (s.isInitOrVNew()) {\n+                            if (s.isImplicitConstructor()) {\n+                                return (MethodSymbol) s;\n+                            }\n+                        }\n+                }\n+            }\n+            return null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -248,0 +248,3 @@\n+    \/\/ for value objects\n+    public final Type nonAtomicType;\n+\n@@ -643,0 +646,3 @@\n+        \/\/ for value objects\n+        nonAtomicType = enterClass(\"java.lang.NonAtomic\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1165,0 +1165,8 @@\n+            if (tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -5374,0 +5382,5 @@\n+            if (c.type.isValueClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n@@ -5551,1 +5564,1 @@\n-                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n+                    chk.checkConstraintsOfValueClass((JCClassDecl) env.tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -761,1 +761,3 @@\n-    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+    void checkConstraintsOfValueClass(JCClassDecl tree, ClassSymbol c) {\n+        DiagnosticPosition pos = tree.pos();\n+        checkConstraintsOfValueClassesWithImplicitConst(tree, c);\n@@ -812,0 +814,22 @@\n+    void checkConstraintsOfValueClassesWithImplicitConst(JCClassDecl classDecl, ClassSymbol c) {\n+        JCMethodDecl implicitConstructor = TreeInfo.getImplicitConstructor(classDecl.defs);\n+        if (implicitConstructor != null) {\n+            Type encl = c.type.getEnclosingType();\n+            if (encl != null && encl.hasTag(CLASS)) {\n+                log.error(classDecl.pos(), Errors.ValueClassWithImplicitCannotBeInner(c));\n+            }\n+            if ((c.flags() & HASINITBLOCK) != 0) {\n+                log.error(classDecl.pos(), Errors.ValueClassWithImplicitDeclaresInitBlock(c));\n+            }\n+            for (Symbol s : c.members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case VAR:\n+                        if ((s.flags() & STATIC) == 0 & (s.flags() & HASINIT) != 0) {\n+                            log.error(classDecl.pos(), Errors.ValueClassWithImplicitInstanceFieldInitializer(c));\n+                        }\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1445,1 +1469,7 @@\n-                                ANNOTATION) ) {\n+                                ANNOTATION)\n+                && checkDisjoint(pos, flags,\n+                                IMPLICIT,\n+                                PRIVATE)\n+                && checkDisjoint(pos, flags,\n+                                IMPLICIT,\n+                                PROTECTED) ) {\n@@ -2443,0 +2473,1 @@\n+    \/\/ TODO, update this method once we have null restricted types\n@@ -2476,1 +2507,1 @@\n-            return (symbol.flags() & STATIC) == 0;\n+            return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2556,1 +2556,1 @@\n-                                } else {\n+                                } else if (!tree.sym.isImplicitConstructor()) { \/\/ implicit constructors are special, ignore them\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,2 @@\n-            int statsSize = tree.body.stats.size();\n+            \/\/ implicit constructors are empty bodied\n+            int statsSize = (tree.body == null) && ((tree.mods.flags & IMPLICIT) != 0) ? 0 : tree.body.stats.size();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1073,0 +1073,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,0 +135,4 @@\n+    \/** Switch: does this value class has an implicit constructor\n+     *\/\n+    public boolean hasImplicitConstructor;\n+\n@@ -1335,0 +1339,21 @@\n+            new AttributeReader(names.ImplicitCreation, V63, CLASS_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind == TYP) {\n+                        nextChar();\n+                        hasImplicitConstructor = true;\n+                    }\n+                }\n+            },\n+            new AttributeReader(names.NullRestricted, V63, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    \/\/ here we could put the nullness annotation into the field's type\n+                }\n+            },\n@@ -2344,0 +2369,4 @@\n+            if (hasImplicitConstructor && type.getParameterTypes().size() == 0) {\n+                \/\/ this has to be the implicit constructor\n+                flags |= IMPLICIT;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -381,0 +381,3 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeNullRestrictedIfNeeded(sym);\n+        }\n@@ -952,0 +955,24 @@\n+    \/** Write \"ImplicitCreation\" attribute.\n+     *\/\n+    int writeImplicitCreationIfNeeded(ClassSymbol csym) {\n+        if (csym.isValueClass() && csym.getImplicitConstructor() != null) {\n+            int alenIdx = writeAttr(names.ImplicitCreation);\n+            int flags = ACC_DEFAULT | (csym.isSubClass(syms.nonAtomicType.tsym, types) ? ACC_NON_ATOMIC : 0);\n+            databuf.appendChar(flags);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/** Write \"NullRestricted\" attribute.\n+     *\/\n+    int writeNullRestrictedIfNeeded(Symbol sym) {\n+        if (sym.kind == VAR && sym.owner.isValueClass() \/* && sym.type.isNonNullable() *\/) {\n+            int alenIdx = writeAttr(names.NullRestricted);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n@@ -1728,0 +1755,4 @@\n+        }\n+\n+        if (target.hasValueClasses()) {\n+            acount += writeImplicitCreationIfNeeded(c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -210,0 +210,6 @@\n+    \/** Does the target VM support value classes\n+     *\/\n+    public boolean hasValueClasses() {\n+        return compareTo(JDK1_19) >= 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3568,0 +3568,4 @@\n+                if (isImplicitModifier()) {\n+                    flag = Flags.IMPLICIT;\n+                    break;\n+                }\n@@ -3846,0 +3850,7 @@\n+        if (name == names.implicit) {\n+            if (allowValueClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n@@ -4962,0 +4973,19 @@\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean isImplicitModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.implicit) {\n+            boolean isImplicitModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case MONKEYS_AT:\n+                case STATIC: case FINAL: case ABSTRACT: case NATIVE:\n+                case SYNCHRONIZED: case STRICTFP: case DEFAULT: case IDENTIFIER:\n+                    isImplicitModifier = true;\n+                    break;\n+            }\n+            if (isImplicitModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -4091,0 +4091,14 @@\n+# 0: symbol\n+compiler.err.value.class.with.implicit.cannot.be.inner=\\\n+    The value class {0} declares an implicit constructor. It cannot be an inner class.\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.declares.init.block=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    It cannot declare one or more non-empty instance initializer blocks\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.instance.field.initializer=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    And it defines an instance field with an initializer. This is disallowed.\n+\n@@ -4105,0 +4119,3 @@\n+compiler.err.implicit.const.cant.have.body=\\\n+    implicit constructors cannot have a body\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -127,0 +127,6 @@\n+    public static JCMethodDecl getImplicitConstructor(List<JCTree> trees) {\n+        for (List<JCTree> l = trees; l.nonEmpty(); l = l.tail)\n+            if (isConstructor(l.head) && (((JCMethodDecl)l.head).mods.flags & IMPLICIT) != 0) return (JCMethodDecl) l.head;\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,0 +176,2 @@\n+    public final Name ImplicitCreation;\n+    public final Name NullRestricted;\n@@ -248,0 +250,3 @@\n+    \/\/ value classes\n+    public final Name implicit;\n+\n@@ -382,0 +387,2 @@\n+        ImplicitCreation = fromString(\"ImplicitCreation\");\n+        NullRestricted = fromString(\"NullRestricted\");\n@@ -446,0 +453,3 @@\n+\n+        \/\/value classes\n+        implicit = fromString(\"implicit\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -64,1 +64,4 @@\n-    public static enum Kind { Class, InnerClass, Field, Method}\n+    public static final int ACC_DEFAULT       = 0x0001; \/\/ ImplicitCreation attribute\n+    public static final int ACC_NON_ATOMIC    = 0x0002; \/\/ ImplicitCreation attribute\n+\n+    public static enum Kind { Class, InnerClass, Field, Method, ImplicitCreationAttr}\n@@ -160,0 +163,6 @@\n+    private static final int[] implicitCreationAttrFlags = { ACC_DEFAULT, ACC_NON_ATOMIC };\n+\n+    public Set<String> getImplicitCreationAttrFlags() {\n+        return getFlags(implicitCreationAttrFlags, Kind.ImplicitCreationAttr);\n+    }\n+\n@@ -224,1 +233,1 @@\n-            return \"ACC_PUBLIC\";\n+            return t == Kind.ImplicitCreationAttr ? \"ACC_DEFAULT\" : \"ACC_PUBLIC\";\n@@ -226,1 +235,1 @@\n-            return \"ACC_PRIVATE\";\n+            return t == Kind.ImplicitCreationAttr ? \"ACC_NON_ATOMIC\" : \"ACC_PRIVATE\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    public static final String ImplicitCreation         = \"ImplicitCreation\";\n@@ -63,0 +64,1 @@\n+    public static final String NullRestricted           = \"NullRestricted\";\n@@ -127,0 +129,1 @@\n+            standardAttributes.put(ImplicitCreation, ImplicitCreation_attribute.class);\n@@ -140,0 +143,1 @@\n+            standardAttributes.put(NullRestricted, NullRestricted_attribute.class);\n@@ -195,0 +199,1 @@\n+        R visitImplicitCreation(ImplicitCreation_attribute attr, P p);\n@@ -208,0 +213,1 @@\n+        R visitNullRestricted(NullRestricted_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -469,0 +469,6 @@\n+        @Override\n+        public Void visitImplicitCreation(ImplicitCreation_attribute attr, ClassOutputStream out) {\n+            out.writeShort(attr.flags);\n+            return null;\n+        }\n+\n@@ -535,0 +541,5 @@\n+        @Override\n+        public Void visitNullRestricted(NullRestricted_attribute attr, ClassOutputStream out) {\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+\n+public class ImplicitCreation_attribute extends Attribute {\n+\n+    public int flags;\n+\n+    ImplicitCreation_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        flags = cr.readUnsignedShort();\n+    }\n+\n+    public ImplicitCreation_attribute(int name_index, int flags) {\n+        super(name_index, 2);\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitImplicitCreation(this, data);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ImplicitCreation_attribute.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+public class NullRestricted_attribute extends Attribute {\n+    NullRestricted_attribute(ClassReader cr, int name_index, int length) {\n+        super(name_index, length);\n+    }\n+\n+    public NullRestricted_attribute(int name_index) {\n+        super(name_index, 0);\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitNullRestricted(this, data);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/NullRestricted_attribute.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.classfile.ClassWriter;\n@@ -49,0 +50,1 @@\n+import com.sun.tools.classfile.ImplicitCreation_attribute;\n@@ -63,0 +65,1 @@\n+import com.sun.tools.classfile.NullRestricted_attribute;\n@@ -318,0 +321,9 @@\n+    @Override\n+    public Void visitImplicitCreation(ImplicitCreation_attribute attr, Void ignore) {\n+        println(\"ImplicitCreation:\");\n+        indent(+1);\n+        AccessFlags flags = new AccessFlags(attr.flags);\n+        writeList(String.format(\"flags: (0x%04x) \", attr.flags), flags.getImplicitCreationAttrFlags(), \"\\n\");\n+        indent(-1);\n+        return null;\n+    }\n@@ -420,0 +432,6 @@\n+    @Override\n+    public Void visitNullRestricted(NullRestricted_attribute attr, Void ignore) {\n+        println(\"NullRestricted\");\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}