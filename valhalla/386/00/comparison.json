{"files":[{"patch":"@@ -344,0 +344,17 @@\n+    \/** Should this member be emitted in a reference projection class file ?\n+     *  All state related members i.e instance fields and factory methods\n+     *  get emitted in the value projection class file while behavior i.e\n+     *  methods get emitted into reference projection class file.\n+     *\/\n+    public boolean belongsInReferenceProjection() {\n+        return this.owner.kind == TYP &&\n+                this.owner.isReferenceProjection() ||\n+                    (this.owner.isPrimitiveClass()\n+                    && switch (kind) {\n+                        case VAR -> isStatic();\n+                        case MTH -> ((flags() & (HYPOTHETICAL | NATIVE)) == 0) &&\n+                                            (!isStatic() || !isPrimitiveFactory());\n+                        default -> false;\n+                    });\n+    }\n+\n@@ -480,1 +497,1 @@\n-    \/** Is this symbol a value factory?\n+    \/** Is this symbol a factory for a primitive class?\n@@ -482,1 +499,1 @@\n-    public boolean isValueFactory() {\n+    public boolean isPrimitiveFactory() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n@@ -2690,1 +2691,1 @@\n-                    readClassFileInternal(referenceProjection);\n+                    referenceProjection.complete();\n@@ -2694,0 +2695,14 @@\n+                    for (Symbol s : referenceProjection.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n+                        Symbol clone = null;\n+                        if (s.kind == MTH) {\n+                            MethodSymbol refMethod = (MethodSymbol)s;\n+                            MethodSymbol valMethod = refMethod.clone(c);\n+                            clone = valMethod;\n+                        } else if (s.kind == VAR) {\n+                            VarSymbol refVar = (VarSymbol)s;\n+                            VarSymbol valVar = refVar.clone(c);\n+                            clone = refVar;\n+                        }\n+                        c.members_field.enter(clone);\n+                        referenceProjection.members().remove(s);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1501,1 +1501,4 @@\n-    void writeFields(Scope s) {\n+    void writeFields(ClassSymbol c) {\n+\n+        Scope s = c.members();\n+\n@@ -1506,1 +1509,6 @@\n-            if (sym.kind == VAR) vars = vars.prepend((VarSymbol)sym);\n+            if (sym.kind == VAR) {\n+                if (c.isPrimitiveClass() && sym.belongsInReferenceProjection()) {\n+                    continue;\n+                }\n+                vars = vars.prepend((VarSymbol)sym);\n+            }\n@@ -1514,1 +1522,4 @@\n-    void writeMethods(Scope s) {\n+    void writeMethods(ClassSymbol c) {\n+\n+        Scope s = c.members();\n+\n@@ -1517,1 +1528,4 @@\n-            if (sym.kind == MTH && (sym.flags() & HYPOTHETICAL) == 0)\n+            if (sym.kind == MTH && (sym.flags() & HYPOTHETICAL) == 0) {\n+                if (c.isPrimitiveClass() && sym.belongsInReferenceProjection()) {\n+                    continue;\n+                }\n@@ -1519,0 +1533,1 @@\n+            }\n@@ -1532,0 +1547,1 @@\n+        ClassSymbol refProjection = c.isPrimitiveClass() ? getReferenceProjection(c) : null;\n@@ -1533,2 +1549,7 @@\n-        if (c.isPrimitiveClass()) {\n-            writeClassInternal(getReferenceProjection(c));\n+        if (refProjection != null) {\n+            try {\n+                poolWriter.switchPool();\n+                writeClassInternal(refProjection);\n+            } finally {\n+                poolWriter.switchPool();\n+            }\n@@ -1568,0 +1589,6 @@\n+\n+            \/* Sort state related members i.e fields and constructors into the value projection and\n+               behavioral members i.e methods into the reference projection. See that constructors\n+               have been morphed into static factory methods already. All _other_ static members are\n+               translated onto the reference projection.\n+            *\/\n@@ -1569,1 +1596,1 @@\n-            for (Symbol s : c.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n+            for (Symbol s : c.members().getSymbols(s->s.belongsInReferenceProjection(), NON_RECURSIVE)) {\n@@ -1668,16 +1695,21 @@\n-        boolean referenceProjection = c.isReferenceProjection();\n-        if (!referenceProjection) {\n-            for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {\n-                switch (sym.kind) {\n-                    case VAR:\n-                        fieldsCount++;\n-                        break;\n-                    case MTH:\n-                        if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n-                        break;\n-                    case TYP:\n-                        poolWriter.enterInner((ClassSymbol)sym);\n-                        break;\n-                    default:\n-                        Assert.error();\n-                }\n+        for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {\n+            switch (sym.kind) {\n+                case VAR:\n+                    if (c.isPrimitiveClass() && sym.belongsInReferenceProjection()) {\n+                        continue;\n+                    }\n+                    fieldsCount++;\n+                    break;\n+                case MTH:\n+                    if ((sym.flags() & HYPOTHETICAL) == 0) {\n+                        if (c.isPrimitiveClass() && sym.belongsInReferenceProjection()) {\n+                            continue;\n+                        }\n+                        methodsCount++;\n+                    }\n+                    break;\n+                case TYP:\n+                    poolWriter.enterInner((ClassSymbol)sym);\n+                    break;\n+                default:\n+                    Assert.error();\n@@ -1685,0 +1717,1 @@\n+        }\n@@ -1686,4 +1719,3 @@\n-            if (c.trans_local != null) {\n-                for (ClassSymbol local : c.trans_local) {\n-                    poolWriter.enterInner(local);\n-                }\n+        if (c.trans_local != null) {\n+            for (ClassSymbol local : c.trans_local) {\n+                poolWriter.enterInner(local);\n@@ -1694,2 +1726,1 @@\n-        if (!referenceProjection)\n-            writeFields(c.members());\n+        writeFields(c);\n@@ -1697,2 +1728,1 @@\n-        if (!referenceProjection)\n-            writeMethods(c.members());\n+        writeMethods(c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":61,"deletions":31,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -948,1 +948,9 @@\n-        genMethod(tree, localEnv, false);\n+\n+        try {\n+            if (tree.sym.belongsInReferenceProjection())\n+                poolWriter.switchPool();\n+            genMethod(tree, localEnv, false);\n+        } finally {\n+            if (tree.sym.belongsInReferenceProjection())\n+                poolWriter.switchPool();\n+        }\n@@ -1004,1 +1012,1 @@\n-                    } else if (env.enclMethod.sym.isValueFactory()) {\n+                    } else if (env.enclMethod.sym.isPrimitiveFactory()) {\n@@ -1070,1 +1078,1 @@\n-                Type selfType = meth.owner.type;\n+                Type selfType = meth.belongsInReferenceProjection() ? meth.owner.type.referenceProjection() : meth.owner.type;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,3 +88,0 @@\n-    \/** Pool helper **\/\n-    final WriteablePoolHelper pool;\n-\n@@ -94,0 +91,14 @@\n+\n+    \/* *****************************************************************************\n+     *\n+     * For Valhalla, where a single primitive class may result in two different class\n+     * files, one each for the projection, we manage the constant pool on a bipartite\n+     * basis. Toggling between the main pool and the alternate pool is achieved via\n+     * a call to com.sun.tools.javac.jvm.PoolWriter.switchPool()\n+     *\n+     * ******************************************************************************\n+     *\/\n+\n+    \/** Pool helper **\/\n+    WriteablePoolHelper pool, altPool;\n+\n@@ -95,1 +106,1 @@\n-    LinkedHashSet<ClassSymbol> innerClasses = new LinkedHashSet<>();\n+    LinkedHashSet<ClassSymbol> innerClasses = new LinkedHashSet<>(), altInnerClasses;\n@@ -98,1 +109,1 @@\n-    Map<BsmKey, Integer> bootstrapMethods = new LinkedHashMap<>();\n+    Map<BsmKey, Integer> bootstrapMethods = new LinkedHashMap<>(), altBootstrapMethods;\n@@ -408,1 +419,5 @@\n-                    poolbuf.appendChar(putClass((ClassSymbol)sym.owner));\n+                    if (sym.belongsInReferenceProjection()) {\n+                        poolbuf.appendChar(putClass(sym.owner.type.referenceProjection()));\n+                    } else {\n+                        poolbuf.appendChar(putClass((ClassSymbol)sym.owner));\n+                    }\n@@ -530,0 +545,25 @@\n+\n+    void switchPool() {\n+\n+        \/\/ Take a snap shot\n+        WriteablePoolHelper savedPool = pool;\n+        LinkedHashSet<ClassSymbol> savedInnerClasses = innerClasses;\n+        Map<BsmKey, Integer> savedBootstrapMethods = bootstrapMethods;\n+\n+        \/\/ Initialize alternarte pool state\n+        if (altPool == null) {\n+            altPool = new WriteablePoolHelper();\n+            altInnerClasses = new LinkedHashSet<>();\n+            altBootstrapMethods = new LinkedHashMap<>();\n+        }\n+\n+        \/\/ Switch\n+        pool = altPool;\n+        innerClasses = altInnerClasses;\n+        bootstrapMethods = altBootstrapMethods;\n+\n+        \/\/ Persists snap shot\n+        altPool = savedPool;\n+        altInnerClasses = savedInnerClasses;\n+        altBootstrapMethods = savedBootstrapMethods;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":46,"deletions":6,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -310,0 +310,17 @@\n+\n+        if (currentClass.sym.isPrimitiveClass() && currentMethod != null && !constructingValue()) {\n+            \/\/ Current method will be hosited into the reference projection. Transform the reference\n+            \/\/ to ident into ((C$val) this).x;\n+            if (isPrimitiveInstanceMemberAccess(ident.sym)) {\n+                JCExpression expr = make.This(currentClass.type).setType(currentClass.type.referenceProjection());\n+                expr = make.TypeCast(types.erasure(currentClass.type), expr);\n+                result = make.Select(expr, ident.sym);\n+                return;\n+            }\n+            \/\/ Retype this!\n+            if (ident.name == names._this) {\n+                ident.setType(ident.type.referenceProjection());\n+                result = make.TypeCast(types.erasure(currentClass.type), ident);\n+                return;\n+            }\n+        }\n@@ -388,0 +405,9 @@\n+    private boolean isPrimitiveInstanceMemberAccess(Symbol symbol) {\n+        return symbol != null\n+                && (symbol.name != names._this && symbol.name != names._super)\n+                && (symbol.kind == VAR || symbol.kind == MTH)\n+                && symbol.owner == currentClass.sym\n+                && !symbol.isStatic()\n+                && currentClass.sym.isPrimitiveClass();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-                                                \"BoxValCastTest$VT.class\").toString() };\n+                                                \"BoxValCastTest$VT$ref.class\").toString() };\n@@ -63,1 +63,1 @@\n-        \"checkcast     #7                  \/\/ class \\\"QBoxValCastTest$VT;\\\"\"\n+        \"checkcast     #1                  \/\/ class \\\"QBoxValCastTest$VT;\\\"\"\n@@ -87,1 +87,1 @@\n-        String [] splits = out.split(\"checkcast     #7\", -1);\n+        String [] splits = out.split(\"checkcast     #1\", -1);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/BoxValCastTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                                                \"ConstantPropagationTest$X.class\").toString() };\n+                                                \"ConstantPropagationTest$X$ref.class\").toString() };\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ConstantPropagationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-                                                \"ProjectedArrayDotClass$VT.class\").toString() };\n+                                                \"ProjectedArrayDotClass$VT$ref.class\").toString() };\n@@ -59,4 +59,4 @@\n-        \"         3: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT$ref;\\\"\",\n-        \"        11: ldc           #21                 \/\/ class \\\"[QProjectedArrayDotClass$VT;\\\"\",\n-        \"        19: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT$ref;\\\"\",\n-        \"        27: ldc           #21                 \/\/ class \\\"[QProjectedArrayDotClass$VT;\\\"\",\n+        \"         3: ldc           #7                  \/\/ class \\\"[LProjectedArrayDotClass$VT$ref;\\\"\",\n+        \"        11: ldc           #15                 \/\/ class \\\"[QProjectedArrayDotClass$VT;\\\"\",\n+        \"        19: ldc           #7                  \/\/ class \\\"[LProjectedArrayDotClass$VT$ref;\\\"\",\n+        \"        27: ldc           #15                 \/\/ class \\\"[QProjectedArrayDotClass$VT;\\\"\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ProjectedArrayDotClass.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -63,3 +63,0 @@\n-              \"  #27 = Utf8               (QQTypedValue;I)V\",\n-              \"  #21 = NameAndType        #22:#23        \/\/ \\\"<init>\\\":()QQTypedValue;\",\n-              \"  #25 = NameAndType        #26:#27        \/\/ foo:(QQTypedValue;I)V\",\n@@ -82,32 +79,0 @@\n-              \"  void foo(QTypedValue, int);\",\n-              \"    descriptor: (QQTypedValue;I)V\",\n-              \"    flags: (0x0000)\",\n-              \"    Code:\",\n-              \"      stack=3, locals=12, args_size=3\",\n-              \"         0: aload_0\",\n-              \"         1: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n-              \"         4: bipush        10\",\n-              \"         6: invokevirtual #24                 \/\/ Method foo:(QQTypedValue;I)V\",\n-              \"         9: iload_2\",\n-              \"        10: ifne          34\",\n-              \"        13: iconst_0\",\n-              \"        14: istore        8\",\n-              \"        16: dconst_0\",\n-              \"        17: dstore        9\",\n-              \"        19: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n-              \"        22: astore_3\",\n-              \"        23: iload         8\",\n-              \"        25: ifne          29\",\n-              \"        28: return\",\n-              \"        29: invokestatic  #20                 \/\/ Method \\\"<init>\\\":()QQTypedValue;\",\n-              \"        32: astore        11\",\n-              \"        34: return\",\n-              \"      StackMapTable: number_of_entries = 2\",\n-              \"        frame_type = 255 \/* full_frame *\/\",\n-              \"          offset_delta = 29\",\n-              \"          locals = [ class \\\"QQTypedValue;\\\", class \\\"QQTypedValue;\\\", int, class \\\"QQTypedValue;\\\", top, top, top, top, int, double ]\",\n-              \"          stack = []\",\n-              \"        frame_type = 255 \/* full_frame *\/\",\n-              \"          offset_delta = 4\",\n-              \"          locals = [ class \\\"QQTypedValue;\\\", class \\\"QQTypedValue;\\\", int ]\",\n-              \"          stack = []\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/QTypeTest.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                                                \"WithFieldOfExplicitSelector$X.class\").toString() };\n+                                                \"WithFieldOfExplicitSelector$X$ref.class\").toString() };\n@@ -66,11 +66,12 @@\n-         \"2: swap\",\n-         \"3: withfield     #7                  \/\/ Field i:I\",\n-         \"6: astore_3\",\n-         \"7: aload_2\",\n-         \"8: invokevirtual #11                 \/\/ Method java\/lang\/Integer.intValue:()I\",\n-        \"11: aload_3\",\n-        \"12: swap\",\n-        \"13: withfield     #7                  \/\/ Field i:I\",\n-        \"16: astore_3\",\n-        \"17: aload_3\",\n-        \"18: areturn\"\n+         \"2: checkcast     #1                  \/\/ class \\\"QWithFieldOfExplicitSelector$X;\\\"\",\n+         \"5: swap\",\n+         \"6: withfield     #3                  \/\/ Field WithFieldOfExplicitSelector$X.i:I\",\n+         \"9: astore_3\",\n+        \"10: aload_2\",\n+        \"11: invokevirtual #9                  \/\/ Method java\/lang\/Integer.intValue:()I\",\n+        \"14: aload_3\",\n+        \"15: swap\",\n+        \"16: withfield     #3                  \/\/ Field WithFieldOfExplicitSelector$X.i:I\",\n+        \"19: astore_3\",\n+        \"20: aload_3\",\n+        \"21: areturn\"\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/WithFieldOfExplicitSelector.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                                                \"WithFieldOfImplicitThis$X.class\").toString() };\n+                                                \"WithFieldOfImplicitThis$X$ref.class\").toString() };\n@@ -67,11 +67,15 @@\n-         \"4: aload_0\",\n-         \"5: iload_2\",\n-         \"6: withfield     #7                  \/\/ Field x:I\",\n-         \"9: astore_3\",\n-        \"10: aload_0\",\n-        \"11: aload_1\",\n-        \"12: invokevirtual #11                 \/\/ Method java\/lang\/Integer.intValue:()I\",\n-        \"15: withfield     #7                  \/\/ Field x:I\",\n-        \"18: astore_3\",\n-        \"19: aload_3\",\n-        \"20: areturn\"\n+         \"4: iload_2\",\n+         \"5: aload_0\",\n+         \"6: checkcast     #3                  \/\/ class \\\"QWithFieldOfImplicitThis$X;\\\"\",\n+         \"9: swap\",\n+        \"10: withfield     #5                  \/\/ Field WithFieldOfImplicitThis$X.x:I\",\n+        \"13: astore_3\",\n+        \"14: aload_1\",\n+        \"15: invokevirtual #9                  \/\/ Method java\/lang\/Integer.intValue:()I\",\n+        \"18: aload_0\",\n+        \"19: checkcast     #3                  \/\/ class \\\"QWithFieldOfImplicitThis$X;\\\"\",\n+        \"22: swap\",\n+        \"23: withfield     #5                  \/\/ Field WithFieldOfImplicitThis$X.x:I\",\n+        \"26: astore_3\",\n+        \"27: aload_3\",\n+        \"28: areturn\"\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/WithFieldOfImplicitThis.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"}]}