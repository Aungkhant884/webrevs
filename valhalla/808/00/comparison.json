{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -1516,0 +1517,1 @@\n+        var cffv = ClassFileFormatVersion.fromMajor(getClassFileVersion() & 0xffff);\n@@ -1519,1 +1521,2 @@\n-                                            location);\n+                                            location,\n+                                            cffv);\n@@ -4854,1 +4857,2 @@\n-    private int getClassFileVersion() {\n+    \/* package-private *\/\n+    int getClassFileVersion() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -2652,0 +2653,4 @@\n+\n+            public int classFileFormatVersion(Class<?> clazz) {\n+                return clazz.getClassFileVersion();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.misc.ValhallaFeatures;\n+\n@@ -188,0 +190,3 @@\n+     * For class file versions up to Valhalla or if Valhalla is not enabled,\n+     * {@code 0x0020} access flag bit is {@linkplain #SUPER SUPER access flag}; otherwise,\n+     * the {@code 0x0020} access flag bit is {@linkplain #IDENTITY IDENTITY access flag}.\n@@ -189,1 +194,9 @@\n-    SUPER(0x0000_0020, false, Location.SET_CLASS, null),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS_SUPER_VALHALLA,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+            @Override\n+            public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                return (cffv.compareTo(ClassFileFormatVersion.RELEASE_20) >= 0 &&\n+                        ValhallaFeatures.isEnabled()) ?\n+                        Location.SET_CLASS_SUPER_VALHALLA :\n+                        Location.SET_CLASS;}\n+        }),\n@@ -197,1 +210,9 @@\n-    IDENTITY(Modifier.IDENTITY, true, Location.SET_CLASS_INNER_CLASS, null),\n+    IDENTITY(Modifier.IDENTITY, true, Location.SET_CLASS_IDENTITY_VALHALLA,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+                @Override\n+                public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_20) >= 0 &&\n+                            ValhallaFeatures.isEnabled()) ?\n+                            Location.SET_CLASS_IDENTITY_VALHALLA :\n+                            Location.EMPTY_SET;}\n+            }),\n@@ -508,1 +529,0 @@\n-        int unmatchedFlags = mask;\n@@ -511,1 +531,1 @@\n-            if ((mask &  accessMask) != 0) {\n+            if ((mask & accessMask) != 0) {\n@@ -513,1 +533,4 @@\n-                unmatchedFlags = unmatchedFlags & ~accessMask;\n+                mask = mask & ~accessMask;\n+                if (mask == 0) {\n+                    break;      \/\/ no more mask bits\n+                }\n@@ -516,1 +539,1 @@\n-        if (unmatchedFlags != 0) {\n+        if (mask != 0) {\n@@ -518,1 +541,1 @@\n-                                               Integer.toHexString(unmatchedFlags) +\n+                                               Integer.toHexString(mask) +\n@@ -524,0 +547,41 @@\n+    \/**\n+     * {@return an unmodifiable set of access flags for the given mask value\n+     * appropriate for the location in question}\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @param cffv the class file format version\n+     * @throws IllegalArgumentException if the mask contains bit\n+     * positions not supported for the location in question\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location,\n+                                                    ClassFileFormatVersion cffv) {\n+        if (cffv == ClassFileFormatVersion.latest()) {\n+            \/\/ for the current version use the precomputed locations\n+            return maskToAccessFlags(mask, location);\n+        }\n+\n+        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n+        for (var accessFlag : AccessFlag.values()) {\n+            int accessMask = accessFlag.mask();\n+            if ((mask & accessMask) != 0) {\n+                var locations = accessFlag.locations(cffv);\n+                if (locations.contains(location)) {\n+                    result.add(accessFlag);\n+                    mask = mask & ~accessMask;\n+                    if (mask == 0) {\n+                        break;      \/\/ no more mask bits\n+                    }\n+                }\n+            }\n+        }\n+        if (mask != 0) {\n+            throw new IllegalArgumentException(\"Unmatched bit position 0x\" +\n+                                               Integer.toHexString(mask) +\n+                                               \" for location \" + location +\n+                                               \" for class file format version \" + cffv);\n+        }\n+        return Collections.unmodifiableSet(result);\n+    }\n+\n+\n@@ -610,0 +674,4 @@\n+        private static final Set<Location> SET_CLASS_SUPER_VALHALLA =\n+                ValhallaFeatures.isEnabled() ? EMPTY_SET : SET_CLASS_INNER_CLASS;\n+        private static final Set<Location> SET_CLASS_IDENTITY_VALHALLA =\n+                ValhallaFeatures.isEnabled() ? SET_CLASS_INNER_CLASS : EMPTY_SET;\n@@ -642,1 +710,1 @@\n-                                Set.of(PUBLIC, FINAL, SUPER, IDENTITY, VALUE,\n+                                Set.of(PUBLIC, FINAL, IDENTITY, VALUE,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":76,"deletions":8,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -224,0 +224,2 @@\n+        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n+        var cffv = ClassFileFormatVersion.fromMajor(major);\n@@ -225,1 +227,2 @@\n-                                            AccessFlag.Location.METHOD);\n+                                            AccessFlag.Location.METHOD,\n+                                            cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -225,1 +225,5 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD);\n+        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n+        var cffv = ClassFileFormatVersion.fromMajor(major);\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                AccessFlag.Location.FIELD,\n+                cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -574,0 +575,5 @@\n+    \/**\n+     * Returns the class file format version of the class.\n+     *\/\n+    int classFileFormatVersion(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER, IDENTITY]\")\n+@ExpectedClassFlags(\"[PUBLIC, FINAL, IDENTITY]\")\n@@ -266,1 +266,1 @@\n-@ExpectedClassFlags(\"[SUPER, IDENTITY, INTERFACE, ABSTRACT]\")\n+@ExpectedClassFlags(\"[IDENTITY, INTERFACE, ABSTRACT]\")\n@@ -272,1 +272,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, IDENTITY, ENUM]\")\n+@ExpectedClassFlags(\"[FINAL, IDENTITY, ENUM]\")\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * SUPER        invariant\n+ * SUPER        step\n@@ -90,1 +90,1 @@\n-            Set.of(SUPER, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n+            Set.of(SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n@@ -118,0 +118,4 @@\n+            new StepFunctionTC(SUPER,\n+                               Set.of(AccessFlag.Location.CLASS),\n+                               ClassFileFormatVersion.RELEASE_20),\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}