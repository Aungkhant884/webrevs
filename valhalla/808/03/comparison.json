{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -1494,0 +1495,1 @@\n+     * The {@code AccessFlags} may depend on the class file format version of the class.\n@@ -1523,4 +1525,8 @@\n-        return AccessFlag.maskToAccessFlags((location == AccessFlag.Location.CLASS) ?\n-                                            getClassAccessFlagsRaw() & (~0x800) :\n-                                            getModifiers() & (~0x800), \/\/ suppress unspecified bit\n-                                            location);\n+        int accessFlags = (location == AccessFlag.Location.CLASS) ?\n+                getClassAccessFlagsRaw() : getModifiers();\n+        var cffv = ClassFileFormatVersion.fromMajor(getClassFileVersion() & 0xffff);\n+        if (cffv.compareTo(ClassFileFormatVersion.latest()) >= 0) {\n+            \/\/ Ignore unspecified (0x800) access flag for current version\n+            accessFlags &= ~0x0800;\n+        }\n+        return AccessFlag.maskToAccessFlags(accessFlags, location, cffv);\n@@ -4862,1 +4868,2 @@\n-    private int getClassFileVersion() {\n+    \/* package-private *\/\n+    int getClassFileVersion() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -2676,0 +2677,4 @@\n+\n+            public int classFileFormatVersion(Class<?> clazz) {\n+                return clazz.getClassFileVersion();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.misc.ValhallaFeatures;\n+\n@@ -188,0 +190,3 @@\n+     * For class file versions up to Valhalla or if Valhalla is not enabled,\n+     * {@code 0x0020} access flag bit is {@linkplain #SUPER SUPER access flag}; otherwise,\n+     * the {@code 0x0020} access flag bit is {@linkplain #IDENTITY IDENTITY access flag}.\n@@ -189,1 +194,9 @@\n-    SUPER(0x0000_0020, false, Location.SET_CLASS, null),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS_SUPER_VALHALLA,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+            @Override\n+            public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                return (cffv.compareTo(ClassFileFormatVersion.RELEASE_21) >= 0 &&\n+                        ValhallaFeatures.isEnabled()) ?\n+                        Location.SET_CLASS_SUPER_VALHALLA :\n+                        Location.SET_CLASS;}\n+        }),\n@@ -197,1 +210,9 @@\n-    IDENTITY(Modifier.IDENTITY, true, Location.SET_CLASS_INNER_CLASS, null),\n+    IDENTITY(Modifier.IDENTITY, true, Location.SET_CLASS_IDENTITY_VALHALLA,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+                @Override\n+                public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_21) >= 0 &&\n+                            ValhallaFeatures.isEnabled()) ?\n+                            Location.SET_CLASS_IDENTITY_VALHALLA :\n+                            Location.EMPTY_SET;}\n+            }),\n@@ -262,0 +283,1 @@\n+\n@@ -504,1 +526,1 @@\n-     * positions not support for the location in question\n+     * positions not supported for the location in question\n@@ -508,1 +530,0 @@\n-        int unmatchedFlags = mask;\n@@ -511,1 +532,1 @@\n-            if ((mask &  accessMask) != 0) {\n+            if ((mask & accessMask) != 0) {\n@@ -513,1 +534,4 @@\n-                unmatchedFlags = unmatchedFlags & ~accessMask;\n+                mask = mask & ~accessMask;\n+                if (mask == 0) {\n+                    break;      \/\/ no more mask bits\n+                }\n@@ -516,1 +540,1 @@\n-        if (unmatchedFlags != 0) {\n+        if (mask != 0) {\n@@ -518,1 +542,1 @@\n-                                               Integer.toHexString(unmatchedFlags) +\n+                                               Integer.toHexString(mask) +\n@@ -524,0 +548,36 @@\n+    \/**\n+     * {@return an unmodifiable set of access flags for the given mask value\n+     * appropriate for the location in question}\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @param cffv the class file format version\n+     * @throws IllegalArgumentException if the mask contains bit\n+     * positions not supported for the location in question\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location,\n+                                                    ClassFileFormatVersion cffv) {\n+        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n+        for (var accessFlag : AccessFlag.values()) {\n+            int accessMask = accessFlag.mask();\n+            if ((mask & accessMask) != 0) {\n+                var locations = accessFlag.locations(cffv);\n+                if (locations.contains(location)) {\n+                    result.add(accessFlag);\n+                    mask = mask & ~accessMask;\n+                    if (mask == 0) {\n+                        break;      \/\/ no more mask bits\n+                    }\n+                }\n+            }\n+        }\n+        if (mask != 0) {\n+            throw new IllegalArgumentException(\"Unmatched bit position 0x\" +\n+                                               Integer.toHexString(mask) +\n+                                               \" for location \" + location +\n+                                               \" for class file format version \" + cffv);\n+        }\n+        return Collections.unmodifiableSet(result);\n+    }\n+\n+\n@@ -610,0 +670,4 @@\n+        private static final Set<Location> SET_CLASS_SUPER_VALHALLA =\n+                ValhallaFeatures.isEnabled() ? EMPTY_SET : SET_CLASS_INNER_CLASS;\n+        private static final Set<Location> SET_CLASS_IDENTITY_VALHALLA =\n+                ValhallaFeatures.isEnabled() ? SET_CLASS_INNER_CLASS : EMPTY_SET;\n@@ -642,1 +706,1 @@\n-                                Set.of(PUBLIC, FINAL, SUPER, IDENTITY, VALUE,\n+                                Set.of(PUBLIC, FINAL, IDENTITY, VALUE,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":73,"deletions":9,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+     * The {@code AccessFlags} may depend on the class file format version of the class.\n@@ -224,0 +225,2 @@\n+        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n+        var cffv = ClassFileFormatVersion.fromMajor(major);\n@@ -225,1 +228,2 @@\n-                                            AccessFlag.Location.METHOD);\n+                                            AccessFlag.Location.METHOD,\n+                                            cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -219,0 +219,2 @@\n+     * The {@code AccessFlags} may depend on the class file format version of the class.\n+     *\n@@ -225,1 +227,5 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD);\n+        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n+        var cffv = ClassFileFormatVersion.fromMajor(major);\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                AccessFlag.Location.FIELD,\n+                cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -586,0 +587,5 @@\n+    \/**\n+     * Returns the class file format version of the class.\n+     *\/\n+    int classFileFormatVersion(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER, IDENTITY]\")\n+@ExpectedClassFlags(\"[PUBLIC, FINAL, IDENTITY]\")\n@@ -257,1 +257,1 @@\n-@ExpectedClassFlags(\"[SUPER, IDENTITY, INTERFACE, ABSTRACT]\")\n+@ExpectedClassFlags(\"[IDENTITY, INTERFACE, ABSTRACT]\")\n@@ -263,1 +263,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, IDENTITY, ENUM]\")\n+@ExpectedClassFlags(\"[FINAL, IDENTITY, ENUM]\")\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8301720\n+ * @summary Test expected value of SUPER AccessFlag for pre-ValueClass .class file\n+ * @compile -source 20 -target 20 SuperAccessFlagTest.java\n+ * @run main SuperAccessFlagTest\n+ *\/\n+\n+\/\/ Note: cannot use --release 20 because the accessFlags() method is\n+\/\/ not found in release 20; therefore -source and -target are used instead.\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+\/*\n+ * Test expected value of ACC_SUPER access flag on an earlier release.\n+ *\/\n+@ExpectedClassFlags(\"[PUBLIC, SUPER]\")\n+public class SuperAccessFlagTest {\n+    public static void main(String... args) {\n+        checkClass(SuperAccessFlagTest.class);\n+    }\n+\n+    private static void checkClass(Class<?> clazz) {\n+        ExpectedClassFlags expected =\n+                clazz.getAnnotation(ExpectedClassFlags.class);\n+        if (expected != null) {\n+            String actual = clazz.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + clazz +\n+                        \" expected \" + expected.value() +\n+                        \" got \" + actual);\n+            }\n+        }\n+    }\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@ExpectedClassFlags(\"[INTERFACE, ABSTRACT, ANNOTATION]\")\n+@interface ExpectedClassFlags {\n+    String value();\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/SuperAccessFlagTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n- * SUPER        invariant\n+ * SUPER        step\n@@ -90,1 +90,1 @@\n-            Set.of(SUPER, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n+            Set.of(SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n@@ -118,0 +118,4 @@\n+            new StepFunctionTC(SUPER,\n+                               Set.of(AccessFlag.Location.CLASS),\n+                               ClassFileFormatVersion.RELEASE_21),\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}