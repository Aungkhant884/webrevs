{"files":[{"patch":"@@ -1629,1 +1629,0 @@\n-          elemtype->inline_klass() != NULL &&\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -326,0 +326,3 @@\n+  if (kit->gvn().type(base)->isa_aryptr()) {\n+    kit->C->set_flattened_accesses();\n+  }\n@@ -596,0 +599,3 @@\n+  if (kit->gvn().type(obj)->isa_aryptr()) {\n+    kit->C->set_flattened_accesses();\n+  }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-  Node* array_store_check();\n+  Node* array_store_check(Node*& adr, const Type*& elemtype);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-    C->set_flattened_accesses();\n@@ -234,1 +233,1 @@\n-    cast_val = array_store_check();\n+    cast_val = array_store_check(adr, elemtype);\n@@ -243,0 +242,1 @@\n+  assert(adr->as_AddP()->in(AddPNode::Base) == ary, \"inconsistent address base\");\n@@ -276,1 +276,0 @@\n-      C->set_flattened_accesses();\n@@ -544,1 +543,1 @@\n-      record_profile_for_speculation(ary, array_type, ProfileMaybeNull);\n+      ary = record_profile_for_speculation(ary, array_type, ProfileMaybeNull);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-Node* Parse::array_store_check() {\n+Node* Parse::array_store_check(Node*& adr, const Type*& elemtype) {\n@@ -161,1 +161,1 @@\n-  const TypeKlassPtr *tak = _gvn.type(array_klass)->is_klassptr();\n+  const TypeKlassPtr* tak = _gvn.type(array_klass)->is_klassptr();\n@@ -168,25 +168,1 @@\n-  if (MonomorphicArrayCheck\n-      && !tak->klass_is_exact()) {\n-      \/\/ Regarding the fourth condition in the if-statement from above:\n-      \/\/\n-      \/\/ If the compiler has determined that the type of array 'ary' (represented\n-      \/\/ by 'array_klass') is java\/lang\/Object, the compiler must not assume that\n-      \/\/ the array 'ary' is monomorphic.\n-      \/\/\n-      \/\/ If 'ary' were of type java\/lang\/Object, this arraystore would have to fail,\n-      \/\/ because it is not possible to perform a arraystore into an object that is not\n-      \/\/ a \"proper\" array.\n-      \/\/\n-      \/\/ Therefore, let's obtain at runtime the type of 'ary' and check if we can still\n-      \/\/ successfully perform the store.\n-      \/\/\n-      \/\/ The implementation reasons for the condition are the following:\n-      \/\/\n-      \/\/ java\/lang\/Object is the superclass of all arrays, but it is represented by the VM\n-      \/\/ as an InstanceKlass. The checks generated by gen_checkcast() (see below) expect\n-      \/\/ 'array_klass' to be ObjArrayKlass, which can result in invalid memory accesses.\n-      \/\/\n-      \/\/ See issue JDK-8057622 for details.\n-\n-    \/\/ (If no MDO at all, hope for the best, until a trap actually occurs.)\n-\n+  if (MonomorphicArrayCheck && !tak->klass_is_exact()) {\n@@ -194,1 +170,1 @@\n-    const TypeKlassPtr *extak = NULL;\n+    const TypeKlassPtr* extak = NULL;\n@@ -218,0 +194,18 @@\n+      \/\/ If the compiler has determined that the type of array 'ary' (represented\n+      \/\/ by 'array_klass') is java\/lang\/Object, the compiler must not assume that\n+      \/\/ the array 'ary' is monomorphic.\n+      \/\/\n+      \/\/ If 'ary' were of type java\/lang\/Object, this arraystore would have to fail,\n+      \/\/ because it is not possible to perform a arraystore into an object that is not\n+      \/\/ a \"proper\" array.\n+      \/\/\n+      \/\/ Therefore, let's obtain at runtime the type of 'ary' and check if we can still\n+      \/\/ successfully perform the store.\n+      \/\/\n+      \/\/ The implementation reasons for the condition are the following:\n+      \/\/\n+      \/\/ java\/lang\/Object is the superclass of all arrays, but it is represented by the VM\n+      \/\/ as an InstanceKlass. The checks generated by gen_checkcast() (see below) expect\n+      \/\/ 'array_klass' to be ObjArrayKlass, which can result in invalid memory accesses.\n+      \/\/\n+      \/\/ See issue JDK-8057622 for details.\n@@ -234,1 +228,2 @@\n-        replace_in_map(array_klass,con);\n+        replace_in_map(array_klass, con);\n+        array_klass = con;\n@@ -237,0 +232,6 @@\n+        ary = cast;\n+\n+        \/\/ Recompute element type and address\n+        const TypeAryPtr* arytype = _gvn.type(ary)->is_aryptr();\n+        elemtype = arytype->elem();\n+        adr = array_element_address(ary, idx, T_OBJECT, arytype->size(), control());\n@@ -243,2 +244,0 @@\n-        \/\/ Use cast value moving forward\n-        array_klass = con;\n@@ -262,2 +261,1 @@\n-  const Type* elemtype = _gvn.type(ary)->is_aryptr()->elem();\n-  if (elemtype->isa_inlinetype() != NULL || elemtype->is_inlinetypeptr()) {\n+  if (elemtype->isa_inlinetype() != NULL || (elemtype->is_inlinetypeptr() && !elemtype->maybe_null())) {\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":31,"deletions":33,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+    private static final boolean PREFER_CL_FLAGS = Boolean.parseBoolean(System.getProperty(\"PreferCommandLineFlags\", \"false\"));\n@@ -365,1 +366,4 @@\n-                String[] cmds = InputArguments.getVmInputArgs();\n+                String[] cmds = new String[0];\n+                if (!PREFER_CL_FLAGS) {\n+                    cmds = InputArguments.getVmInputArgs();\n+                }\n@@ -371,0 +375,4 @@\n+                if (PREFER_CL_FLAGS) {\n+                    \/\/ Prefer flags set via the command line over the ones set by the test scenarios\n+                    cmds = concat(cmds, InputArguments.getVmInputArgs());\n+                }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}