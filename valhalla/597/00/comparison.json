{"files":[{"patch":"@@ -423,0 +423,4 @@\n+    public boolean isValueClass() {\n+        return (flags() & VALUE_CLASS) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -244,0 +244,4 @@\n+    public boolean isValueClass() {\n+        return false;\n+    }\n+\n@@ -1327,0 +1331,5 @@\n+        @Override\n+        public boolean isValueClass() {\n+            return tsym != null && tsym.isValueClass();\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1016,0 +1016,4 @@\n+    public boolean isValueClass(Type t) {\n+        return t != null && t.isValueClass();\n+    }\n+\n@@ -2263,1 +2267,1 @@\n-            if (t.hasTag(CLASS) && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n+            if (t.hasTag(CLASS) && !t.isValueClass() && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1231,1 +1231,1 @@\n-                    } else if ((env.enclClass.sym.flags() & PRIMITIVE_CLASS) != 0 &&\n+                    } else if ((env.enclClass.sym.flags() & VALUE_CLASS) != 0 &&\n@@ -1234,3 +1234,3 @@\n-                        \/\/ primitive constructors are not allowed to call super directly,\n-                        \/\/ but tolerate compiler generated ones\n-                        log.error(tree.body.stats.head.pos(), Errors.CallToSuperNotAllowedInPrimitiveCtor);\n+                        \/\/ value constructors are not allowed to call super directly,\n+                        \/\/ but tolerate compiler generated ones, these are ignored during code generation\n+                        log.error(tree.body.stats.head.pos(), Errors.CallToSuperNotAllowedInValueCtor);\n@@ -5558,1 +5558,1 @@\n-                if ((c.flags() & (PRIMITIVE_CLASS | ABSTRACT)) == PRIMITIVE_CLASS) { \/\/ for non-intersection, concrete primitive classes.\n+                if ((c.flags() & (VALUE_CLASS | ABSTRACT)) == VALUE_CLASS) { \/\/ for non-intersection, concrete primitive\/value classes.\n@@ -5562,1 +5562,1 @@\n-                        chk.checkSuperConstraintsOfPrimitiveClass(env.tree.pos(), c);\n+                        chk.checkSuperConstraintsOfValueClass(env.tree.pos(), c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -751,1 +751,1 @@\n-    void checkSuperConstraintsOfPrimitiveClass(DiagnosticPosition pos, ClassSymbol c) {\n+    void checkSuperConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n@@ -758,1 +758,1 @@\n-                log.error(pos, Errors.ConcreteSupertypeForPrimitiveClass(c, st));\n+                log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n@@ -871,1 +871,1 @@\n-        if (t.isPrimitive() || t.isPrimitiveClass() || t.isReferenceProjection())\n+        if (t.isPrimitive() || t.isValueClass() || t.isReferenceProjection())\n@@ -1372,1 +1372,1 @@\n-                if (types.isPrimitiveClass(sym.owner.type) && (flags & STATIC) == 0) {\n+                if (types.isValueClass(sym.owner.type) && (flags & STATIC) == 0) {\n@@ -1402,0 +1402,1 @@\n+                \/\/ FIXME: We tolerate synchronized methods in value records\n@@ -1403,2 +1404,2 @@\n-                \/\/ instance methods of primitive classes do not have a monitor associated with their `this'\n-                mask = ((sym.owner.flags_field & PRIMITIVE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n+                \/\/ value objects do not have an associated monitor\/lock\n+                mask = ((sym.owner.flags_field & VALUE_CLASS) != 0 && (flags & Flags.STATIC) == 0) ?\n@@ -1442,2 +1443,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n@@ -1456,0 +1457,9 @@\n+\n+            \/\/ primitive classes are implicitly final value classes.\n+            if ((flags & PRIMITIVE_CLASS) != 0)\n+                implicit |= VALUE_CLASS | FINAL;\n+\n+            \/\/ value classes are implicitly final\n+            if ((flags & VALUE_CLASS) != 0)\n+                implicit |= FINAL;\n+\n@@ -1484,1 +1494,1 @@\n-                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS | VALUE_CLASS)\n@@ -2016,1 +2026,1 @@\n-        if (origin.isPrimitiveClass() && other.owner == syms.objectType.tsym && m.type.getParameterTypes().size() == 0) {\n+        if (origin.isValueClass() && other.owner == syms.objectType.tsym && m.type.getParameterTypes().size() == 0) {\n@@ -2019,1 +2029,1 @@\n-                        Errors.PrimitiveClassMayNotOverride(m.name));\n+                        Errors.ValueClassMayNotOverride(m.name));\n@@ -2753,2 +2763,2 @@\n-        if (c.isPrimitiveClass() && implementsIdentityObject) {\n-            log.error(pos, Errors.PrimitiveClassMustNotImplementIdentityObject(c));\n+        if (c.isValueClass() && implementsIdentityObject) {\n+            log.error(pos, Errors.ValueClassMustNotImplementIdentityObject(c));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1742,1 +1742,1 @@\n-        BANNED,      \/\/ primitive classes - Error\n+        BANNED,      \/\/ primitive\/value classes - Error\n@@ -2205,1 +2205,1 @@\n-                        if (types.isPrimitiveClass(tree.sym.owner.type))\n+                        if (types.isValueClass(tree.sym.owner.type))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2380,2 +2380,1 @@\n-                long badModifiers = (mods.flags & (Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS)) != 0 ? mods.flags & ~Flags.FINAL : mods.flags;\n-                log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));\n+                log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(mods.flags)));\n@@ -2460,2 +2459,1 @@\n-                badModifiers = (mods.flags & (Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS)) != 0 ? mods.flags & ~Flags.FINAL : mods.flags;\n-                log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));\n+                log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(mods.flags)));\n@@ -3396,10 +3394,0 @@\n-        \/\/ Force primitive classes to be automatically final.\n-        if ((flags & (Flags.PRIMITIVE_CLASS | Flags.ABSTRACT | Flags.INTERFACE | Flags.ENUM)) == Flags.PRIMITIVE_CLASS) {\n-            flags |= Flags.FINAL;\n-        }\n-\n-        \/\/ Force value classes to be automatically final.\n-        if ((flags & (Flags.VALUE_CLASS | Flags.ABSTRACT | Flags.INTERFACE | Flags.ENUM)) == Flags.VALUE_CLASS) {\n-            flags |= Flags.FINAL;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3926,2 +3926,2 @@\n-compiler.err.primitive.class.may.not.override=\\\n-    primitive classes may not override the method {0} from Object\n+compiler.err.value.class.may.not.override=\\\n+    value classes may not override the method {0} from Object\n@@ -3933,2 +3933,2 @@\n-compiler.err.primitive.class.may.not.extend=\\\n-    inappropriate super class declaration for a primitive class\n+compiler.err.value.class.may.not.extend=\\\n+    inappropriate super class declaration for a value class\n@@ -3943,1 +3943,1 @@\n-    primitive class instance should not be passed around before being fully initialized\n+    value class instance should not be passed around before being fully initialized\n@@ -3950,2 +3950,2 @@\n-compiler.err.primitive.class.must.not.implement.identity.object=\\\n-    The primitive class {0} attempts to implement the incompatible interface IdentityObject\n+compiler.err.value.class.must.not.implement.identity.object=\\\n+    The value class {0} attempts to implement the incompatible interface IdentityObject\n@@ -3966,2 +3966,2 @@\n-compiler.err.concrete.supertype.for.primitive.class=\\\n-    The concrete class {1} is not allowed to be a super class of the primitive class {0} either directly or indirectly\n+compiler.err.concrete.supertype.for.value.class=\\\n+    The concrete class {1} is not allowed to be a super class of the value class {0} either directly or indirectly\n@@ -3971,1 +3971,1 @@\n-    The method {0} in the super class {2} of the primitive class {1} is synchronized. This is disallowed\n+    The method {0} in the super class {2} of the value class {1} is synchronized. This is disallowed\n@@ -3975,1 +3975,1 @@\n-    The super class {2} of the primitive class {1} defines a constructor {0} that takes arguments. This is disallowed\n+    The super class {2} of the value class {1} defines a constructor {0} that takes arguments. This is disallowed\n@@ -3979,1 +3979,1 @@\n-    The super class {2} of the primitive class {1} defines an instance field {0}. This is disallowed\n+    The super class {2} of the value class {1} defines an instance field {0}. This is disallowed\n@@ -3983,1 +3983,1 @@\n-    The super class {2} of the primitive class {1} defines a nonempty no-arg constructor {0}. This is disallowed\n+    The super class {2} of the value class {1} defines a nonempty no-arg constructor {0}. This is disallowed\n@@ -3987,1 +3987,1 @@\n-    The super class {1} of the primitive class {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n+    The super class {1} of the value class {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n@@ -3991,1 +3991,1 @@\n-    The super class {1} of the primitive class {0} is an inner class. This is disallowed.\n+    The super class {1} of the value class {0} is an inner class. This is disallowed.\n@@ -3996,2 +3996,2 @@\n-compiler.err.call.to.super.not.allowed.in.primitive.ctor=\\\n-    call to super not allowed in primitive class constructor\n+compiler.err.call.to.super.not.allowed.in.value.ctor=\\\n+    call to super not allowed in value class constructor\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-compiler.err.primitive.class.may.not.extend\n+compiler.err.value.class.may.not.extend\n@@ -215,2 +215,2 @@\n-compiler.err.primitive.class.must.not.implement.identity.object\n-compiler.err.concrete.supertype.for.primitive.class\n+compiler.err.value.class.must.not.implement.identity.object\n+compiler.err.concrete.supertype.for.value.class\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.primitive.class.may.not.override\n+\/\/ key: compiler.err.value.class.may.not.override\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveClassMayNotOverride.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.call.to.super.not.allowed.in.primitive.ctor\n+\/\/ key: compiler.err.call.to.super.not.allowed.in.value.ctor\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SuperNotAllowedInPrimitiveCtor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-                public primitive record R(int i, @A long j, java.util.List<java.lang.String> l) {\n+                public primitive value record R(int i, @A long j, java.util.List<java.lang.String> l) {\n","filename":"test\/langtools\/tools\/javac\/records\/RecordReading.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-BinarySuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.primitive.class: BinarySuperclassConstraints.I0, SuperclassCollections.BadSuper\n+BinarySuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.value.class: BinarySuperclassConstraints.I0, SuperclassCollections.BadSuper\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/BinarySuperclassConstraints.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-CheckClone.java:20:22: compiler.err.primitive.class.may.not.override: clone\n+CheckClone.java:20:22: compiler.err.value.class.may.not.override: clone\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckClone.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckExtends.java:10:22: compiler.err.concrete.supertype.for.primitive.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n+CheckExtends.java:10:22: compiler.err.concrete.supertype.for.value.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckExtends.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckFinalize.java:10:20: compiler.err.primitive.class.may.not.override: finalize\n+CheckFinalize.java:10:20: compiler.err.value.class.may.not.override: finalize\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckFinalize.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-CheckObjectMethodsUsage.java:11:17: compiler.err.primitive.class.may.not.override: finalize\n-CheckObjectMethodsUsage.java:12:19: compiler.err.primitive.class.may.not.override: clone\n+CheckObjectMethodsUsage.java:11:17: compiler.err.value.class.may.not.override: finalize\n+CheckObjectMethodsUsage.java:12:19: compiler.err.value.class.may.not.override: clone\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckObjectMethodsUsage.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-IllegalByValueTest2.java:19:59: compiler.err.concrete.supertype.for.primitive.class: compiler.misc.anonymous.class: IllegalByValueTest2$1, IllegalByValueTest2\n+IllegalByValueTest2.java:19:59: compiler.err.concrete.supertype.for.value.class: compiler.misc.anonymous.class: IllegalByValueTest2$1, IllegalByValueTest2\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/IllegalByValueTest2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-              \"final primitive class QTypedValue\",\n-              \"  flags: (0x0830) ACC_FINAL, ACC_SUPER, ACC_PRIMITIVE\",\n+              \"final primitive value class QTypedValue\",\n+              \"  flags: (0x0930) ACC_FINAL, ACC_SUPER, ACC_PRIMITIVE, ACC_VALUE\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/QTypeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SuperCallInCtor.java:24:13: compiler.err.call.to.super.not.allowed.in.primitive.ctor\n+SuperCallInCtor.java:24:13: compiler.err.call.to.super.not.allowed.in.value.ctor\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SuperCallInCtor.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.primitive.class: SuperclassConstraints.I0, SuperclassConstraints.BadSuper\n+SuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.value.class: SuperclassConstraints.I0, SuperclassConstraints.BadSuper\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SuperclassConstraints.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-TopInterfaceNegativeTest.java:28:22: compiler.err.primitive.class.must.not.implement.identity.object: TopInterfaceNegativeTest.V1\n+TopInterfaceNegativeTest.java:28:22: compiler.err.value.class.must.not.implement.identity.object: TopInterfaceNegativeTest.V1\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TopInterfaceNegativeTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-ValueModifierTest.java:16:31: compiler.err.concrete.supertype.for.primitive.class: compiler.misc.anonymous.class: ValueModifierTest$3, Value\n+ValueModifierTest.java:16:31: compiler.err.concrete.supertype.for.value.class: compiler.misc.anonymous.class: ValueModifierTest$3, Value\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ValueModifierTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8279672\n+ * @summary Implement semantic checks for value classes\n+ * @compile\/fail\/ref=SemanticsViolationsTest.out -XDrawDiagnostics --should-stop=at=FLOW -XDdev SemanticsViolationsTest.java\n+ *\/\n+\n+public class SemanticsViolationsTest {\n+\n+    \/\/ A value class is implicitly final, so cannot be extended.\n+    value class Base {}\n+    class Subclass extends Base {} \/\/ Error: Base is implicitly final, cannot be extended.\n+\n+\n+    \/\/ The class may not be declared abstract.\n+    abstract value class AbsValue {}  \/\/ Error: value class cannot be abstract\n+    value interface ValueInterface {} \/\/ Error: interface cannot modified with value.\n+\n+    \/\/ All instance fields are implicitly final, so must be assigned exactly\n+    \/\/ once by constructors or initializers, and cannot be assigned outside\n+    \/\/ of a constructor or initializer.\n+    value class Point {\n+\n+        int x = 10;\n+        int y;\n+        int z;\n+\n+        Point (int x, int y, int z) {\n+            this.x = x; \/\/ Error, final field 'x' is already assigned to.\n+            this.y = y; \/\/ OK.\n+            \/\/ Error, final z is unassigned.\n+        }\n+        void foo(Point p) {\n+            this.y = p.y; \/\/ Error, y is final and can't be written outside of ctor.\n+        }\n+    }\n+\n+    \/\/ The class does not implement—directly or indirectly—IdentityObject.\n+    \/\/ This implies that the superclass is either Object or a stateless abstract class.\n+    value class IdentityValue implements IdentityObject { \/\/ Error, can't implement this\n+    }\n+    value class IdentityValue2 extends SemanticsViolationsTest { \/\/ Error, can't extend identity class\n+    }\n+    abstract static class AbstractWithState {\n+       int xx;\n+    }\n+    value class BrokenValue3 extends AbstractWithState { \/\/ Error, super class has state.\n+    }\n+    abstract static class AbstractWithoutState {\n+        static int ss;\n+    }\n+    value class GoodValue1 extends AbstractWithoutState {}\n+    value class GoodValue2 extends Object {} \/\/ allowed.\n+\n+    \/\/ No constructor makes a super constructor call. Instance creation will\n+    \/\/ occur without executing any superclass initialization code.\n+    value class BrokenValue4 {\n+        BrokenValue4() {\n+            super(); \/\/ Error, can't chain to super's ctor.\n+        }\n+    }\n+\n+    \/\/ No instance methods are declared synchronized.\n+    value class BrokenValue5 {\n+        synchronized void foo() {} \/\/ Error;\n+        synchronized static void soo() {} \/\/ OK.\n+        { synchronized(this) { \/* Error.*\/  } }\n+    }\n+\n+    \/\/ The class does not declare a finalize() method.\n+    value class BrokenValue6 {\n+        public void finalize() {} \/\/ Error\n+    }\n+\n+    \/\/ (Possibly) The constructor does not make use of this except to set\n+    \/\/ the fields in the constructor body, or perhaps after all fields are\n+    \/\/ definitely assigned.\n+    value class BrokenValue7 {\n+        int x;\n+        BrokenValue7() {\n+            foo(this); \/\/ Error.\n+            x = 10;\n+            foo(this); \/\/ Ok.\n+        }\n+        void foo(BrokenValue7 bv) {\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SemanticsViolationsTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+SemanticsViolationsTest.java:16:20: compiler.err.illegal.combination.of.modifiers: abstract, value\n+SemanticsViolationsTest.java:17:11: compiler.err.illegal.combination.of.modifiers: interface, value\n+SemanticsViolationsTest.java:12:28: compiler.err.cant.inherit.from.final: SemanticsViolationsTest.Base\n+SemanticsViolationsTest.java:65:27: compiler.err.mod.not.allowed.here: synchronized\n+SemanticsViolationsTest.java:29:17: compiler.err.cant.assign.val.to.final.var: x\n+SemanticsViolationsTest.java:34:17: compiler.err.cant.assign.val.to.final.var: y\n+SemanticsViolationsTest.java:40:11: compiler.err.value.class.must.not.implement.identity.object: SemanticsViolationsTest.IdentityValue\n+SemanticsViolationsTest.java:42:11: compiler.err.concrete.supertype.for.value.class: SemanticsViolationsTest.IdentityValue2, SemanticsViolationsTest\n+SemanticsViolationsTest.java:47:11: compiler.err.super.field.not.allowed: xx, SemanticsViolationsTest.BrokenValue3, SemanticsViolationsTest.AbstractWithState\n+SemanticsViolationsTest.java:59:13: compiler.err.call.to.super.not.allowed.in.value.ctor\n+SemanticsViolationsTest.java:67:11: compiler.err.type.found.req: SemanticsViolationsTest.BrokenValue5, (compiler.misc.type.req.identity)\n+SemanticsViolationsTest.java:72:21: compiler.err.value.class.may.not.override: finalize\n+SemanticsViolationsTest.java:32:9: compiler.err.var.might.not.have.been.initialized: z\n+SemanticsViolationsTest.java:81:17: compiler.err.this.exposed.prematurely\n+SemanticsViolationsTest.java:81:16: compiler.err.this.exposed.prematurely\n+15 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SemanticsViolationsTest.out","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -3,1 +3,2 @@\n-2 errors\n+ValueAnnotationTest.java:10:34: compiler.err.concrete.supertype.for.value.class: ValueAnnotationTest.Y, ValueAnnotationTest.X\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueAnnotationTest.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}