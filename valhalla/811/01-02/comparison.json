{"files":[{"patch":"@@ -1,21 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8209400 8215246\n- * @summary Allow anonymous classes to be primitive class types\n- * @compile\/fail\/ref=IllegalByValueTest2.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses IllegalByValueTest2.java\n- *\/\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Target;\n-import java.util.Comparator;\n-\n-public class IllegalByValueTest2 {\n-\n-    @Target(ElementType.TYPE_USE)\n-    @interface Annot {\n-    }\n-\n-    public static void main(String[] args) {\n-        new @Annot primitive @Annot IllegalByValueTest2() {};\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IllegalByValueTest2.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-IllegalByValueTest2.java:19:30: compiler.err.duplicate.annotation.missing.container: IllegalByValueTest2.Annot\n-IllegalByValueTest2.java:19:59: compiler.err.concrete.supertype.for.value.class: compiler.misc.anonymous.class: IllegalByValueTest2$1, IllegalByValueTest2\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IllegalByValueTest2.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check inlineness via __inline__ annotation\n- * @bug 8222745\n- * @compile\/fail\/ref=InlineAnnotationOnAnonymousClass.out -XDrawDiagnostics -XDenablePrimitiveClasses InlineAnnotationOnAnonymousClass.java\n- *\/\n-\n-class InlineAnnotationOnAnonymousClass {\n-    interface I {}\n-    primitive\n-    public static void main(String args []) {\n-        new primitive I() {\n-        };\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineAnnotationOnAnonymousClass.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-InlineAnnotationOnAnonymousClass.java:11:24: compiler.err.mod.not.allowed.here: primitive\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineAnnotationOnAnonymousClass.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check inlineness via __inline__ annotation\n- * @bug 8222745\n- * @compile\/fail\/ref=InlineAnnotationTest.out -XDrawDiagnostics -XDenablePrimitiveClasses InlineAnnotationTest.java\n- *\/\n-\n-primitive\n-class InlineAnnotationTest01 extends Object { \n-}\n-\n-primitive\n-class InlineAnnotationTest02 { \n-}\n-\n-primitive\n-class InlineAnnotationTest03  { \n-    int x = 10;\n-    InlineAnnotationTest03() {\n-        x = 20;\n-    }\n-}\n-\n-primitive\n-interface InlineAnnotationTest04 { \n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineAnnotationTest.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-InlineAnnotationTest.java:25:1: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-InlineAnnotationTest.java:20:9: compiler.err.cant.assign.val.to.final.var: x\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineAnnotationTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,18 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8230082\n- * @summary Javac should not allow inline type's fields to be volatile (as they are final)\n- * @compile\/fail\/ref=NoVolatileFields.out -XDrawDiagnostics -XDenablePrimitiveClasses NoVolatileFields.java\n- *\/\n-\n-public class NoVolatileFields {\n-\n-    static class Foo {\n-        volatile final int i = 0; \/\/ Error\n-    }\n-\n-    static primitive class Bar {\n-        volatile int i = 0; \/\/ Error\n-    }\n-}\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoVolatileFields.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-NoVolatileFields.java:11:28: compiler.err.illegal.combination.of.modifiers: final, volatile\n-NoVolatileFields.java:15:22: compiler.err.illegal.combination.of.modifiers: final, volatile\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoVolatileFields.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237072\n- * @summary Test various relationships between a value type and its reference projection.\n- * @compile\/fail\/ref=OverloadingPhaseTest.out -XDrawDiagnostics -XDenablePrimitiveClasses OverloadingPhaseTest.java\n- *\/\n-\n-public class OverloadingPhaseTest {\n-\n-    static primitive class V {\n-        int x = 0;\n-    }\n-\n-    static String roo(V.ref v, int i) {\n-        return \"Phase 1\";\n-    }\n-\n-    static String roo(V.ref v, Integer i) {\n-        return \"Phase 2\";\n-    }\n-\n-    public static void main(String args) {\n-        V o = new V();\n-        String result;\n-\n-        if (!(result = roo(o, 0)).equals(\"phase 2\"))\n-            throw new AssertionError(\"Broken: got \" + result);\n-        if (!(result = roo(o, Integer.valueOf(0))).equals(\"phase 2\"))\n-            throw new AssertionError(\"Broken: got \" + result);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-OverloadingPhaseTest.java:26:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V.ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V.ref,java.lang.Integer), OverloadingPhaseTest\n-OverloadingPhaseTest.java:28:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V.ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V.ref,java.lang.Integer), OverloadingPhaseTest\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -414,0 +414,213 @@\n+\n+    public void testDefaultOnUnknownClass() {\n+        assertFail(\"compiler.err.cant.resolve.location\",\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        Object o = Unknown.default;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.cant.resolve.location\",\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        Object o = Unknown1.Unknown2.default;\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testUncheckedDefaultWarning() {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            String[] testOptions = {\"-Xlint:all\", \"-XDenablePrimitiveClasses\"};\n+            setCompileOptions(testOptions);\n+            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    primitive class UncheckedDefault<E> {\n+                        void m() {\n+                            UncheckedDefault<String> foo = UncheckedDefault.default;\n+                        }\n+                    }\n+                    \"\"\");\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n+\n+    public void testRefProjection() {\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                primitive class PC {\n+                    void foo() {\n+                        PC x = null;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo() {\n+                        PC.ref x = null;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo(PC x) {\n+                        PC.ref xq = null;\n+                        xq = x;\n+                        xq = (PC.ref) x;\n+                        xq = (PC) x;\n+                        x = xq;\n+                        x = (PC.ref) xq;\n+                        x = (PC) xq;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                primitive class PC {\n+                    void foo() {\n+                        PC[] xa = new PC[] { null };\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo() {\n+                        PC.ref [] xqa = new PC.ref[] { null };\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo(PC[] xa) {\n+                        PC.ref[] xqa = xa;\n+                        xqa = (PC.ref[]) xa;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                primitive class PC {\n+                    void foo(PC[] xa, PC.ref[] xqa) {\n+                        xa = xqa;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo(PC[] xa, PC.ref[] xqa) {\n+                        xa = (PC[]) xqa;\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testSuperInvocation() {\n+        assertFail(\"compiler.err.call.to.super.not.allowed.in.value.ctor\",\n+                \"\"\"\n+                primitive class PC {\n+                    PC(String s) {\n+                        super();  \/\/ Error.\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testProjectionInstantiation() {\n+        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n+                \"\"\"\n+                primitive class PC {\n+                    void m() {\n+                        new PC.ref();\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n+                \"\"\"\n+                primitive class PC {\n+                    void m() {\n+                        new PC.val();\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                import java.util.function.Supplier;\n+                primitive class PC {\n+                    void m() {\n+                        foo(PC::new);\n+                    }\n+                    static void foo(Supplier<PC.ref> sx) {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n+                \"\"\"\n+                import java.util.function.Supplier;\n+                primitive class PC {\n+                    void m() {\n+                        foo(PC.ref::new);\n+                    }\n+                    static void foo(Supplier<PC.ref> sx) {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n+                \"\"\"\n+                import java.util.function.Supplier;\n+                primitive class PC {\n+                    void m() {\n+                        foo(PC.val::new);\n+                    }\n+                    static void foo(Supplier<PC.ref> sx) {}\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testOverloadResolution() {\n+        assertFail(\"compiler.err.ref.ambiguous\",\n+                \"\"\"\n+                class OverloadingPhaseTest {\n+                    static primitive class V {}\n+                    static String roo(V.ref v, int i) {\n+                        return \"\";\n+                    }\n+                    static String roo(V.ref v, Integer i) {\n+                        return \"\";\n+                    }\n+                    void m(V o) {\n+                        String result = roo(o, 0);\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.ref.ambiguous\",\n+                \"\"\"\n+                class OverloadingPhaseTest {\n+                    static primitive class V {}\n+                    static String roo(V.ref v, int i) {\n+                        return \"\";\n+                    }\n+                    static String roo(V.ref v, Integer i) {\n+                        return \"\";\n+                    }\n+                    void m(V o) {\n+                        String result = roo(o, Integer.valueOf(0));\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testNoVolatileFields() {\n+        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n+                \"\"\"\n+                primitive class Bar {\n+                    volatile int i = 0;\n+                }\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -1,22 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244561 8250997\n- * @summary Javac should not allow instantiation of V.ref or V.val\n- * @compile\/fail\/ref=ProjectionInstantiationTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ProjectionInstantiationTest.java\n- *\/\n-import java.util.function.Supplier;\n-\n-final primitive class ProjectionInstantiationTest {\n-    int x = 42;\n-    public static void main(String[] args) {\n-        new ProjectionInstantiationTest();\n-        new ProjectionInstantiationTest.ref();\n-        new ProjectionInstantiationTest.val();\n-        foo(ProjectionInstantiationTest::new);\n-        foo(ProjectionInstantiationTest.ref::new);\n-        foo(ProjectionInstantiationTest.val::new);\n-    }\n-    static void foo(Supplier<ProjectionInstantiationTest.ref> sx) {\n-        sx.get();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionInstantiationTest.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ProjectionInstantiationTest.java:13:9: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:14:9: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:16:40: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:17:40: compiler.err.projection.cant.be.instantiated\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionInstantiationTest.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8267835\n- * @summary  Javac tolerates vacuous chaining to super constructor from primitive class constructor\n- * @compile\/fail\/ref=SuperCallInCtor.out -XDrawDiagnostics -XDenablePrimitiveClasses SuperCallInCtor.java\n- *\/\n-\n-final class SuperCallInCtor {\n-\n-    primitive class P {\n-       \/\/ generated ctor with super() call is OK.\n-    }\n-\n-    primitive class Q {\n-        Q() {\n-            System.out.println(\"Construct Q\"); \/\/ Ok, no express super();\n-        }\n-\n-        Q(int x) {\n-            this();   \/\/ chaining with this is OK.\n-        }\n-\n-        Q(String s) {\n-            super();  \/\/ Error.\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperCallInCtor.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-SuperCallInCtor.java:24:13: compiler.err.call.to.super.not.allowed.in.value.ctor\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperCallInCtor.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8242900\n- * @summary Verify various constraints for an inline class's super types.\n- * @compile\/fail\/ref=SuperclassConstraints.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses SuperclassConstraints.java\n- *\/\n-\n-public class SuperclassConstraints {\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that super class cannot be concrete, including express jlO\n-    static class BadSuper {}\n-    primitive class I0 extends BadSuper {} \/\/ ERROR: concrete super class\n-    primitive class I1 extends Object {}   \/\/ OK: concrete jlO can be express-superclass\n-    primitive class I2 {} \/\/ OK\n-\n-    \/\/ Test that abstract class is allowed to be super including when extending jlO\n-    interface GoodSuperInterface {}\n-    static abstract class GoodSuper extends Object {}\n-    primitive class I3 extends GoodSuper implements GoodSuperInterface {} \/\/ jlO can be indirect super class\n-    static abstract class Integer extends Number {\n-        public double doubleValue() { return 0; }\n-        public float floatValue() { return 0; }\n-        public long longValue() { return 0; }\n-        public int intValue() { return 0; }\n-    }\n-    primitive class I4 extends Integer {}\n-    primitive class I5 extends Number {\n-        public double doubleValue() { return 0; }\n-        public float floatValue() { return 0; }\n-        public long longValue() { return 0; }\n-        public int intValue() { return 0; }\n-    }\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that super class cannot define instance fields.\n-    static abstract class SuperWithInstanceField {\n-        int x;\n-    }\n-    static abstract class SuperWithInstanceField_01 extends SuperWithInstanceField {}\n-\n-    primitive class I6 extends SuperWithInstanceField_01 {} \/\/ ERROR:\n-\n-    \/\/ Test that super class can define static fields.\n-    static abstract class SuperWithStaticField {\n-        static int x;\n-    }\n-    primitive class I7 extends SuperWithStaticField {} \/\/ OK.\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that no-arg constructor must be empty\n-    static abstract class SuperWithEmptyNoArgCtor {\n-        SuperWithEmptyNoArgCtor() {\n-            \/\/ Programmer supplied ctor but injected super call\n-        }\n-    }\n-    static abstract class SuperWithEmptyNoArgCtor_01 extends SuperWithEmptyNoArgCtor {\n-        SuperWithEmptyNoArgCtor_01() {\n-            super();  \/\/ programmer coded chaining no-arg constructor\n-        }\n-    }\n-    static abstract class SuperWithEmptyNoArgCtor_02 extends SuperWithEmptyNoArgCtor_01 {\n-        \/\/ Synthesized chaining no-arg constructor\n-    }\n-    primitive class I8 extends SuperWithEmptyNoArgCtor_02 {}\n-\n-    static abstract class SuperWithNonEmptyNoArgCtor {\n-        SuperWithNonEmptyNoArgCtor() {\n-            System.out.println(\"Non-Empty\");\n-        }\n-    }\n-    static abstract class SuperWithNonEmptyNoArgCtor_01 extends SuperWithNonEmptyNoArgCtor {}\n-    primitive class I9 extends SuperWithNonEmptyNoArgCtor_01 {} \/\/ ERROR:\n-\n-    \/\/ Test that there can be no other constructors.\n-    static abstract class SuperWithArgedCtor {\n-        SuperWithArgedCtor() {}\n-        SuperWithArgedCtor(String s) {\n-        }\n-    }\n-    static abstract class SuperWithArgedCtor_01 extends SuperWithArgedCtor {}\n-    primitive class I10 extends SuperWithArgedCtor_01 {} \/\/ ERROR:\n-\n-    \/\/ Test that instance initializers are not allowed in supers\n-    static abstract class SuperWithInstanceInit {\n-        {\n-            System.out.println(\"Disqualified from being super\");\n-        }\n-    }\n-    static abstract class SuperWithInstanceInit_01 extends SuperWithInstanceInit {\n-        {\n-            \/\/ Not disqualified since it is a meaningless empty block.\n-        }\n-    }\n-    primitive class I11 extends SuperWithInstanceInit_01 {} \/\/ ERROR:\n-\n-    \/\/ Test that synchronized methods are not allowed in supers.\n-    static abstract class SuperWithSynchronizedMethod {\n-        synchronized void foo() {}\n-    }\n-    static abstract class SuperWithSynchronizedMethod_1 extends SuperWithSynchronizedMethod {\n-    }\n-    primitive class I12 extends SuperWithSynchronizedMethod_1 {} \/\/ ERROR:\n-\n-    \/\/ No instance fields and no arged constructor also means inner classes cannot be supers\n-    abstract class InnerSuper {}\n-    primitive class I13 extends InnerSuper {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperclassConstraints.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-SuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.value.class: SuperclassConstraints.I0, SuperclassConstraints.BadSuper\n-SuperclassConstraints.java:44:15: compiler.err.instance.field.not.allowed: x, (compiler.misc.superclass.of.value.class: SuperclassConstraints.I6, SuperclassConstraints.SuperWithInstanceField)\n-SuperclassConstraints.java:76:15: compiler.err.abstract.value.class.no.arg.constructor.must.be.empty: SuperclassConstraints.SuperWithNonEmptyNoArgCtor(), (compiler.misc.superclass.of.value.class: SuperclassConstraints.I9, SuperclassConstraints.SuperWithNonEmptyNoArgCtor)\n-SuperclassConstraints.java:85:15: compiler.err.abstract.value.class.constructor.cannot.take.arguments: SuperclassConstraints.SuperWithArgedCtor(java.lang.String), (compiler.misc.superclass.of.value.class: SuperclassConstraints.I10, SuperclassConstraints.SuperWithArgedCtor)\n-SuperclassConstraints.java:98:15: compiler.err.abstract.value.class.declares.init.block: (compiler.misc.superclass.of.value.class: SuperclassConstraints.I11, SuperclassConstraints.SuperWithInstanceInit)\n-SuperclassConstraints.java:106:15: compiler.err.super.class.method.cannot.be.synchronized: foo(), SuperclassConstraints.I12, SuperclassConstraints.SuperWithSynchronizedMethod\n-SuperclassConstraints.java:110:15: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.superclass.of.value.class: SuperclassConstraints.I13, SuperclassConstraints.InnerSuper)\n-7 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperclassConstraints.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8222792\n- * @summary Javac should enforce the latest relationship rules between an inline type and its nullable projection\n- * @compile\/fail\/ref=TypeRelationsNegativeTest.out -XDrawDiagnostics -XDenablePrimitiveClasses TypeRelationsNegativeTest.java\n- *\/\n-\n-final primitive class TypeRelationsNegativeTest {\n-\n-    void foo() {\n-        TypeRelationsNegativeTest x = null; \/\/ error\n-        TypeRelationsNegativeTest.ref xq = null;\n-\n-        xq = x;\n-        xq = (TypeRelationsNegativeTest.ref) x;\n-        xq = (TypeRelationsNegativeTest) x;\n-        x = xq;\n-        x = (TypeRelationsNegativeTest.ref) xq;\n-        x = (TypeRelationsNegativeTest) xq;\n-\n-        TypeRelationsNegativeTest [] xa = new TypeRelationsNegativeTest[] { null }; \/\/ error\n-        TypeRelationsNegativeTest.ref [] xqa = new TypeRelationsNegativeTest.ref[] { null };\n-\n-        xqa = xa;\n-        xqa = (TypeRelationsNegativeTest.ref[]) xa;\n-        xa = xqa;\/\/ error\n-        xa = (TypeRelationsNegativeTest []) xqa;\n-    }\n-    int x = 10;\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsNegativeTest.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-TypeRelationsNegativeTest.java:11:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, TypeRelationsNegativeTest)\n-TypeRelationsNegativeTest.java:21:77: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, TypeRelationsNegativeTest)\n-TypeRelationsNegativeTest.java:26:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest.ref[], TypeRelationsNegativeTest[])\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsNegativeTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,20 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8210906\n- * @summary [lworld] default value creation should not impose raw types on users.\n- * @compile\/fail\/ref=UncheckedDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses UncheckedDefault.java\n- *\/\n-\n-public primitive class UncheckedDefault<E> {\n-    E value;\n-    UncheckedDefault(E value) { this.value = value; }\n-    public static void main(String [] args) {\n-        UncheckedDefault<String> foo = UncheckedDefault.default;\n-    }\n-\n-    public E makeDefault() {\n-        E e = E.default;\n-        return e;\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UncheckedDefault.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-UncheckedDefault.java:12:56: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedDefault, UncheckedDefault<java.lang.String>\n-- compiler.err.warnings.and.werror\n-1 error\n-1 warning\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UncheckedDefault.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8264216\n- * @summary [lworld] unknown.Class.default gives misleading compilation error\n- * @compile\/fail\/ref=UnknownTypeDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses UnknownTypeDefault.java\n- *\/\n-\n-public class UnknownTypeDefault {\n-\n-    public static void main(String [] args) {\n-        Object d1 = Y.default;\n-        Object d2 = y.Z.default;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnknownTypeDefault.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-UnknownTypeDefault.java:11:22: compiler.err.cant.resolve.location: kindname.class, Y, null, null, (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n-UnknownTypeDefault.java:12:24: compiler.err.cant.resolve.location: kindname.class, y.Z, null, null, (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnknownTypeDefault.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"}]}