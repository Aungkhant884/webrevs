{"files":[{"patch":"@@ -1,24 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8215507 8218040\n- * @summary javac should NOT forbid conversion from value array to Object[]\n- * @compile\/fail\/ref=CovariantArrayTest.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses CovariantArrayTest.java\n- *\/\n-public class CovariantArrayTest {\n-    static final primitive class V {\n-        public final int v1;\n-        private V () {v1 = 0;}\n-    }\n-\n-    public static void main(String args[]) {\n-        int [] ia = new int[1];\n-        Object oa[] = (Object[])ia;\n-        oa = ia;\n-\n-        V [] va = new V[1];\n-        Object oa2[] = (Object[])va;\n-        oa2 = va;\n-        va = oa2;\n-        va = (V []) oa2;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CovariantArrayTest.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-CovariantArrayTest.java:15:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int[], java.lang.Object[])\n-CovariantArrayTest.java:16:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int[], java.lang.Object[])\n-CovariantArrayTest.java:21:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], CovariantArrayTest.V[])\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CovariantArrayTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8197911\n- * @summary Test Javac's treatment of null assignment to primitive class instances\n- * @compile\/fail\/ref=FlattenableNegativeTest.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses FlattenableNegativeTest.java\n- *\/\n-\n-public class FlattenableNegativeTest {\n-    primitive final class V {\n-        final int x = 10;\n-        \n-        primitive final class X {\n-            final V v = null;  \/\/ Error: initialization illegal\n-            final V v2 = v;    \/\/ OK, null not constant propagated.\n-\n-            V foo(X x) {\n-                x.v = null;  \/\/ Error: illegal.\n-                return x.v;\n-            }\n-        }\n-        V foo(X x) {\n-            x.v = null; \/\/ illegal\n-            return x.v;\n-        }\n-\n-        class Y {\n-            V v;\n-            V [] va = { null }; \/\/ Illegal array initialization\n-            V [] va2 = new V[] { null }; \/\/ Illegal array initialization\n-            void foo(X x) {\n-                x.v = null; \/\/ illegal\n-                v = null; \/\/ illegal assignment.\n-                va[0] = null; \/\/ Illegal.\n-                va = new V[] { null }; \/\/ Illegal\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/FlattenableNegativeTest.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-FlattenableNegativeTest.java:13:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:17:18: compiler.err.cant.assign.val.to.final.var: v\n-FlattenableNegativeTest.java:17:23: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:22:14: compiler.err.cant.assign.val.to.final.var: v\n-FlattenableNegativeTest.java:22:19: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:28:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:29:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:31:18: compiler.err.cant.assign.val.to.final.var: v\n-FlattenableNegativeTest.java:31:23: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:32:21: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:33:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:34:32: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-12 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/FlattenableNegativeTest.out","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8217958\n- * @summary Trouble assigning\/casting to a value array type with parameterized element type\n- * @compile\/fail\/ref=GenericArrayTest.out -Xlint:all -Werror -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses GenericArrayTest.java\n- *\/\n-\n-public class GenericArrayTest {\n-\n-    public primitive class Value<T> {\n-\n-        T t = null;\n-\n-        void foo() {\n-            Value<T>[] v = new Value[1024];\n-            Value<GenericArrayTest>[] vx = new Value[1024];\n-            Value<String>[] vs = new Value[1024];\n-            v = (Value<T> []) new Value[1024];\n-            vx = (Value <GenericArrayTest> [])new Value[1024];\n-            vs = (Value <String> []) new Value[1024];\n-            vx = vs;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericArrayTest.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-GenericArrayTest.java:15:32: compiler.warn.raw.class.use: GenericArrayTest.Value, GenericArrayTest.Value<T>\n-GenericArrayTest.java:15:28: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), GenericArrayTest.Value[], GenericArrayTest.Value<T>[]\n-GenericArrayTest.java:16:48: compiler.warn.raw.class.use: GenericArrayTest.Value, GenericArrayTest.Value<T>\n-GenericArrayTest.java:16:44: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), GenericArrayTest.Value[], GenericArrayTest.Value<GenericArrayTest>[]\n-GenericArrayTest.java:17:38: compiler.warn.raw.class.use: GenericArrayTest.Value, GenericArrayTest.Value<T>\n-GenericArrayTest.java:17:34: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), GenericArrayTest.Value[], GenericArrayTest.Value<java.lang.String>[]\n-GenericArrayTest.java:18:35: compiler.warn.raw.class.use: GenericArrayTest.Value, GenericArrayTest.Value<T>\n-GenericArrayTest.java:18:31: compiler.warn.prob.found.req: (compiler.misc.unchecked.cast.to.type), GenericArrayTest.Value[], GenericArrayTest.Value<T>[]\n-GenericArrayTest.java:19:51: compiler.warn.raw.class.use: GenericArrayTest.Value, GenericArrayTest.Value<T>\n-GenericArrayTest.java:19:47: compiler.warn.prob.found.req: (compiler.misc.unchecked.cast.to.type), GenericArrayTest.Value[], GenericArrayTest.Value<GenericArrayTest>[]\n-GenericArrayTest.java:20:42: compiler.warn.raw.class.use: GenericArrayTest.Value, GenericArrayTest.Value<T>\n-GenericArrayTest.java:20:38: compiler.warn.prob.found.req: (compiler.misc.unchecked.cast.to.type), GenericArrayTest.Value[], GenericArrayTest.Value<java.lang.String>[]\n-GenericArrayTest.java:21:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericArrayTest.Value<java.lang.String>[], GenericArrayTest.Value<GenericArrayTest>[])\n-1 error\n-12 warnings\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericArrayTest.out","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237072\n- * @summary Test various relationships between a value type and its reference projection.\n- * @compile\/fail\/ref=GenericInlineTest.out -XDrawDiagnostics -XDenablePrimitiveClasses GenericInlineTest.java\n- *\/\n-\n-abstract class Low<T, U> {}\n-abstract class Mid<T, U> extends Low<U, T> {}\n-abstract class High<T, U> extends Mid<U, T> {}\n-\n-primitive\n-class GenericInlineTest<T, U> extends High<U, T> {\n-\n-    int x = 0;\n-\n-    void foo() {\n-\n-        GenericInlineTest<String, Integer> g = new GenericInlineTest<String, Integer>();\n-\n-        High<String, Integer> h1 = g; \/\/ error.\n-\n-        High<Integer, String> h2 = g; \/\/ Ok.\n-\n-        Mid<String, Integer> m1 = g; \/\/ Ok\n-\n-        Mid<Integer, String> m2 = g; \/\/ error.\n-\n-        Low<String, Integer> l1 = g; \/\/ error.\n-\n-        Low<Integer, String> l2 = g; \/\/ Ok.\n-\n-        g = l2; \/\/ error.\n-        g = (GenericInlineTest<String, Integer>) l2; \/\/ OK.\n-\n-        GenericInlineTest.ref<String, Integer> r1 = g; \/\/ ok.\n-        GenericInlineTest.ref<Integer, String> r2 = g; \/\/ error\n-\n-        g = r1; \/\/ ok.\n-        g = r2; \/\/ error.\n-        g = (GenericInlineTest<String, Integer>) r2; \/\/ still error.\n-\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericInlineTest.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-GenericInlineTest.java:21:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, High<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:27:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, Mid<java.lang.Integer,java.lang.String>)\n-GenericInlineTest.java:29:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, Low<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:33:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: Low<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:37:53: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, GenericInlineTest.ref<java.lang.Integer,java.lang.String>)\n-GenericInlineTest.java:40:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest.ref<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:41:50: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest.ref<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)\n-7 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericInlineTest.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8209400\n- * @summary Allow anonymous classes to be value types\n- * @compile\/fail\/ref=IllegalByValueTest.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses IllegalByValueTest.java\n- *\/\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Target;\n-import java.util.Comparator;\n-\n-public class IllegalByValueTest {\n-\n-    @Target(ElementType.TYPE_USE)\n-    @interface Annot {\n-    }\n-\n-    public static void main(String[] args) {\n-        \/\/ Error cases.\n-        new primitive @Annot primitive Comparable <String>() {};\n-        int [] ia = new primitive int[10];\n-        new primitive String(\"Hello\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IllegalByValueTest.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-IllegalByValueTest.java:20:30: compiler.err.repeated.modifier\n-IllegalByValueTest.java:21:35: compiler.err.mod.not.allowed.here: primitive\n-IllegalByValueTest.java:22:9: compiler.err.mod.not.allowed.here: primitive\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IllegalByValueTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8205910\n- * @summary Complain when `this' of a value class is leaked from constructor before all instance fields are definitely assigned.\n- * @compile\/fail\/ref=MiscThisLeak.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses MiscThisLeak.java\n- *\/\n-\n-public class MiscThisLeak {\n-    interface I {\n-        void foo();\n-    }\n-    primitive class V {\n-        class K {}\n-        int f;\n-        V() {\n-            I i = this::foo; \/\/ !OK.\n-            i = MiscThisLeak.this::foo; \/\/ OK.\n-            new K(); \/\/ !OK.\n-            this.new K(); \/\/ !OK.\n-            f = 10;\n-            i = this::foo;   \/\/ OK.\n-        }\n-        void foo() {\n-        }\n-    }\n-    void foo() {\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/MiscThisLeak.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-MiscThisLeak.java:16:19: compiler.err.this.exposed.prematurely\n-MiscThisLeak.java:18:13: compiler.err.this.exposed.prematurely\n-MiscThisLeak.java:19:13: compiler.err.this.exposed.prematurely\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/MiscThisLeak.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8267821\n- * @summary Javac's handling of `primitive' modifier is unlike the handling of other restricted identifiers\n- * @compile\/fail\/ref=PrimitiveAsTypeName.out --source 16 -XDrawDiagnostics PrimitiveAsTypeName.java\n- *\/\n-\n-public class PrimitiveAsTypeName {\n-    public class primitive {\n-        primitive x;\n-        primitive foo(int l) {}\n-        Object o = new primitive primitive() {};\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveAsTypeName.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-- compiler.warn.source.no.system.modules.path: 16\n-PrimitiveAsTypeName.java:12:24: compiler.err.primitive.classes.not.supported: 19\n-1 error\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveAsTypeName.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -334,0 +334,16 @@\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        int[] ia = new primitive int[10];\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        new primitive String(\"Hello\");\n+                    }\n+                }\n+                \"\"\");\n@@ -642,0 +658,508 @@\n+\n+    public void testGenericArray() {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            String[] testOptions = {\"-Xlint:all\", \"-XDenablePrimitiveClasses\"};\n+            setCompileOptions(testOptions);\n+            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        primitive class Value<T> {\n+                            T t = null;\n+                            void foo() {\n+                                Value<T>[] v = new Value[1];\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        primitive class Value<T> {\n+                            T t = null;\n+                            void foo() {\n+                                Value<Test>[] vx = new Value[1];\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        primitive class Value<T> {\n+                            T t = null;\n+                            void foo() {\n+                                Value<String>[] vs = new Value[1];\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        primitive class Value<T> {\n+                            T t = null;\n+                            void foo(Value<T>[] v) {\n+                                v = (Value<T> []) new Value[1];\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        primitive class Value<T> {\n+                            T t = null;\n+                            void foo(Value<Test>[] vx) {\n+                                vx = (Value<Test>[]) new Value[1];\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        primitive class Value<T> {\n+                            T t = null;\n+                            void foo(Value<String>[] vs) {\n+                                vs = (Value<String>[]) new Value[1];\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertFail(\"compiler.err.prob.found.req\",\n+                    \"\"\"\n+                    class Test {\n+                        primitive class Value<T> {\n+                            T t = null;\n+                            void foo(Value<Test>[] vx, Value<String>[] vs) {\n+                                vx = vs;\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n+\n+    public void testAdditionalGenericTests() {\n+        assertOK(\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo() {\n+                        GenericInlineTest<String, Integer> g = new GenericInlineTest<String, Integer>();\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, High<String, Integer> h1) {\n+                        h1 = g;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, High<Integer, String> h2) {\n+                        h2 = g;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, Mid<String, Integer> m1) {\n+                        m1 = g;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, Mid<Integer, String> m2) {\n+                        m2 = g;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, Low<String, Integer> l1) {\n+                        l1 = g;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, Low<Integer, String> l2) {\n+                        l2 = g;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, Low<Integer, String> l2) {\n+                        l2 = g;\n+                        g = l2;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, Low<Integer, String> l2) {\n+                        l2 = g;\n+                        g = (GenericInlineTest<String, Integer>) l2;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                        r1 = g;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                        r2 = g;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                        r1 = g;\n+                        g = r1;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                        r2 = g;\n+                        g = r2;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                abstract class Low<T, U> {}\n+                abstract class Mid<T, U> extends Low<U, T> {}\n+                abstract class High<T, U> extends Mid<U, T> {}\n+\n+                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                        r2 = g;\n+                        g = (GenericInlineTest<String, Integer>) r2;\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testValRefTokensNegative() {\n+        assertFail(\"compiler.err.cant.resolve.location\",\n+                \"\"\"\n+                class ValRefTokensNegativeTest {\n+                    ValRefTokensNegativeTest.ref aa = null;\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.cant.resolve.location\",\n+                \"\"\"\n+                class ValRefTokensNegativeTest {\n+                    static ValRefTokensNegativeTest.val bb = ValRefTokensNegativeTest.default;\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                class ValRefTokensNegativeTest {\n+                    EmptyValue empty = EmptyValue.default;\n+\n+                    static class ValRefTokensTestWrapper {\n+                        ValRefTokensNegativeTest val = ValRefTokensNegativeTest.default;\n+                        ValRefTokensNegativeTest ref = ValRefTokensNegativeTest.default;\n+                    }\n+\n+                    public EmptyValue test(int x) {\n+                        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n+                        return x == 0 ? w.val.empty : w.ref.empty;\n+                    }\n+\n+                    static class EmptyValue {\n+                        static int x = 42;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.cant.resolve.location\",\n+                \"\"\"\n+                class ValRefTokensNegativeTest {\n+                    int valx() {\n+                        return EmptyValue.val.x;\n+                    }\n+\n+                    static class EmptyValue {\n+                        static int x = 42;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.cant.resolve.location\",\n+                \"\"\"\n+                class ValRefTokensNegativeTest {\n+                    int refx() {\n+                        return EmptyValue.ref.x;\n+                    }\n+                    static class EmptyValue {\n+                        static int x = 42;\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testPrimitiveAsTypeName() {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            String[] testOptions = {\"--source\", \"16\"};\n+            setCompileOptions(testOptions);\n+            assertFail(\"compiler.err.primitive.classes.not.supported\",\n+                    \"\"\"\n+                    class primitive {\n+                        primitive x;\n+                        primitive foo(int l) {}\n+                        Object o = new primitive primitive() {};\n+                    }\n+                    \"\"\");\n+            setCompileOptions(previousOptions);\n+            assertFail(\"compiler.err.restricted.type.not.allowed\",\n+                    \"\"\"\n+                    class primitive {}\n+                    \"\"\");\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n+\n+    public void testMiscThisLeak() {\n+        assertFail(\"compiler.err.this.exposed.prematurely\",\n+                \"\"\"\n+                class MiscThisLeak {\n+                    interface I {\n+                        void foo();\n+                    }\n+                    primitive class V {\n+                        int f;\n+                        V() {\n+                            I i = this::foo;\n+                        }\n+\n+                        void foo() {}\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                class MiscThisLeak {\n+                    interface I {\n+                        void foo();\n+                    }\n+                    primitive class V {\n+                        int f;\n+                        V() {\n+                            I i = MiscThisLeak.this::foo;\n+                            f = 10;\n+                        }\n+\n+                        void foo() {}\n+                    }\n+                    void foo() {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.this.exposed.prematurely\",\n+                \"\"\"\n+                class MiscThisLeak {\n+                    interface I {\n+                        void foo();\n+                    }\n+                    primitive class V {\n+                        class K {}\n+                        int f;\n+                        V() {\n+                            new K();\n+                            f = 10;\n+                        }\n+\n+                        void foo() {}\n+                    }\n+                    void foo() {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.this.exposed.prematurely\",\n+                \"\"\"\n+                class MiscThisLeak {\n+                    interface I {\n+                        void foo();\n+                    }\n+                    primitive class V {\n+                        class K {}\n+                        int f;\n+                        V() {\n+                            this.new K();\n+                            f = 10;\n+                        }\n+\n+                        void foo() {}\n+                    }\n+                    void foo() {}\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                class MiscThisLeak {\n+                    interface I {\n+                        void foo();\n+                    }\n+                    primitive class V {\n+                        class K {}\n+                        int f;\n+                        V() {\n+                            f = 10;\n+                            I i = this::foo;\n+                        }\n+                        void foo() {}\n+                    }\n+                    void foo() {}\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testCovariantArrayTest() {\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                class CovariantArrayTest {\n+                    primitive class V {\n+                        public final int v1;\n+                        private V () { v1 = 0; }\n+                    }\n+                    void m(int[] ia, Object[] oa) {\n+                        oa = (Object[])ia;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                class CovariantArrayTest {\n+                    primitive class V {\n+                        public final int v1;\n+                        private V () { v1 = 0; }\n+                    }\n+                    void m(int[] ia, Object[] oa) {\n+                        oa = ia;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                class CovariantArrayTest {\n+                    primitive class V {\n+                        public final int v1;\n+                        private V () { v1 = 0; }\n+                    }\n+                    void m(int[] ia, Object[] oa) {\n+                        V[] va = new V[1];\n+                        Object[] oa2 = (Object[])va;\n+                        oa2 = va;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                class CovariantArrayTest {\n+                    primitive class V {\n+                        public final int v1;\n+                        private V () { v1 = 0; }\n+                    }\n+                    void m(int[] ia, Object[] oa) {\n+                        V[] va = new V[1];\n+                        Object[] oa2 = (Object[])va;\n+                        oa2 = va;\n+                        va = oa2;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                class CovariantArrayTest {\n+                    primitive class V {\n+                        public final int v1;\n+                        private V () { v1 = 0; }\n+                    }\n+                    void m(int[] ia, Object[] oa) {\n+                        V[] va = new V[1];\n+                        Object[] oa2 = (Object[])va;\n+                        oa2 = va;\n+                        va = (V[]) oa2;\n+                    }\n+                }\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":524,"deletions":0,"binary":false,"changes":524,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8264977\n- * @summary A primitive class field by name val confuses javac\n- * @compile\/fail\/ref=ValRefTokensNegativeTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ValRefTokensNegativeTest.java\n- *\/\n-\n-public class ValRefTokensNegativeTest  {\n-\n-    ValRefTokensNegativeTest.ref aa = null;\n-    static ValRefTokensNegativeTest.val bb = ValRefTokensNegativeTest.default;\n-\n-    EmptyValue empty = EmptyValue.default;\n-\n-    static class ValRefTokensTestWrapper {\n-       ValRefTokensNegativeTest val = ValRefTokensNegativeTest.default;\n-       ValRefTokensNegativeTest ref = ValRefTokensNegativeTest.default;\n-    }\n-\n-    public EmptyValue test139(int x) {\n-        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n-        return x == 0 ? w.val.empty : w.ref.empty;\n-    }\n-\n-    int valx() {\n-        return EmptyValue.val.x;\n-    }\n-\n-    int refx() {\n-        return EmptyValue.ref.x;\n-    }\n-\n-    static class EmptyValue {\n-        static int x = 42;\n-    }\n-\n-    public static void main(String [] args) {\n-        if (new ValRefTokensNegativeTest().valx() != new ValRefTokensNegativeTest().refx())\n-            throw new AssertionError(\"Broken\");\n-        if (new ValRefTokensNegativeTest().test139(0).x != new ValRefTokensNegativeTest().test139(1).x)\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValRefTokensNegativeTest.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ValRefTokensNegativeTest.java:10:29: compiler.err.cant.resolve.location: kindname.class, ref, , , (compiler.misc.location: kindname.class, ValRefTokensNegativeTest, null)\n-ValRefTokensNegativeTest.java:11:36: compiler.err.cant.resolve.location: kindname.class, val, , , (compiler.misc.location: kindname.class, ValRefTokensNegativeTest, null)\n-ValRefTokensNegativeTest.java:26:26: compiler.err.cant.resolve.location: kindname.variable, val, , , (compiler.misc.location: kindname.class, ValRefTokensNegativeTest.EmptyValue, null)\n-ValRefTokensNegativeTest.java:30:26: compiler.err.cant.resolve.location: kindname.variable, ref, , , (compiler.misc.location: kindname.class, ValRefTokensNegativeTest.EmptyValue, null)\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValRefTokensNegativeTest.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"}]}