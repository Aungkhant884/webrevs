{"files":[{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8221323\n- * @summary  Javac should support class literals for projection types.\n- * @modules java.base\/jdk.internal.value\n- * @compile\/fail\/ref=ClassLiteralTypingNegativeTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ClassLiteralTypingNegativeTest.java\n- *\/\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-public class ClassLiteralTypingNegativeTest {\n-\n-    public static primitive class Foo {\n-        final int value = 0;\n-\n-        public static void main(String[] args) {\n-            Class<? extends Foo.ref> cFooRef = PrimitiveClass.asValueType(Foo.class); \/\/ Error\n-            cFooRef = new Foo().getClass(); \/\/ OK.\n-            cFooRef = Foo.ref.class; \/\/ OK.\n-            cFooRef = Foo.val.class; \/\/ Error.\n-            Foo.val xv = new Foo();\n-            cFooRef = xv.getClass(); \/\/ OK.\n-            Foo.ref xr = new Foo();\n-            cFooRef = xr.getClass(); \/\/ OK.\n-        }\n-    }\n-\n-    interface I {}\n-\n-    public static primitive class Bar implements I {\n-        final int value = 0;\n-\n-        public static void main(String[] args) {\n-            Class<? extends Bar.ref> cBarRef = PrimitiveClass.asValueType(Bar.class); \/\/ Error\n-            cBarRef = new Bar().getClass(); \/\/ OK.\n-            cBarRef = Bar.ref.class; \/\/ OK.\n-            cBarRef = Bar.val.class; \/\/ Error.\n-            Bar.val xv = new Bar();\n-            cBarRef = xv.getClass(); \/\/ OK\n-            Bar.ref xr = new Bar();\n-            cBarRef = xr.getClass(); \/\/ OK.\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralTypingNegativeTest.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ClassLiteralTypingNegativeTest.java:17:74: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ?>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo.ref>)\n-ClassLiteralTypingNegativeTest.java:20:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo.ref>)\n-ClassLiteralTypingNegativeTest.java:34:74: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ?>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar.ref>)\n-ClassLiteralTypingNegativeTest.java:37:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar.ref>)\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralTypingNegativeTest.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244513\n- * @summary Test conditional expression typing involving inlines.\n- * @compile\/fail\/ref=ConditionalTypeTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ConditionalTypeTest.java\n- *\/\n-\n-final class ConditionalTypeTest {\n-    interface I {}\n-    static primitive class Node implements I {}\n-    static void foo(int i) {\n-        var ret1 = (i == 0) ? new XNodeWrapper() : new Node();\n-        ret1 = \"String cannot be assigned to I\";\n-        var ret2 = (i == 0) ? 10 : new XNodeWrapper();\n-        ret2 = \"String can be assigned to I\";\n-        var ret3 = (i == 0) ? new XNodeWrapper() : 10;\n-        ret3 = \"String can be assigned to Object\";\n-        var ret4 = (i == 0) ? new XNodeWrapper() : new ConditionalTypeTest();\n-        ret4 = \"String can be assigned to Object\";\n-        var ret5 = (i == 0) ? Integer.valueOf(10) : new ConditionalTypeTest();\n-        ret5 = \"String can be assigned to Object\";\n-\n-        var ret6 = (i == 0) ? new Node() : new Node();\n-        ret6 = \"String cannot be assigned to Node\";\n-\n-        var ret7 = (i == 0) ? (Node.ref) new Node() : (Node.ref) null;\n-        ret7 = \"String cannot be assigned to Node.ref\";\n-\n-        var ret8 = (i == 0) ? new Node() : (Node.ref) null;\n-        ret8 = \"String cannot be assigned to Node\";\n-\n-        var ret9 = (i == 0) ? (Node.ref) new Node() : new Node();\n-        ret9 = \"String cannot be assigned to Node\";\n-    }\n-    static primitive class XNodeWrapper implements I {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConditionalTypeTest.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-ConditionalTypeTest.java:13:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.I)\n-ConditionalTypeTest.java:24:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node)\n-ConditionalTypeTest.java:27:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node.ref)\n-ConditionalTypeTest.java:30:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node)\n-ConditionalTypeTest.java:33:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node)\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConditionalTypeTest.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244711\n- * @summary Javac should complain about an inline class with conflicting super interfaces.\n- * @compile\/fail\/ref=ConflictingSuperInterfaceTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ConflictingSuperInterfaceTest.java\n- *\/\n-\n-public class ConflictingSuperInterfaceTest {\n-\n-    interface I<T> {}\n-    static abstract class S implements I<String> {}\n-    primitive static class Foo extends S implements I<Integer> {\n-        String s = \"\";\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConflictingSuperInterfaceTest.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ConflictingSuperInterfaceTest.java:12:22: compiler.err.cant.inherit.diff.arg: ConflictingSuperInterfaceTest.I, java.lang.Integer, java.lang.String\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConflictingSuperInterfaceTest.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1166,0 +1166,103 @@\n+\n+    public void testConflictingSuperInterface() {\n+        assertFail(\"compiler.err.cant.inherit.diff.arg\",\n+                \"\"\"\n+                class ConflictingSuperInterfaceTest {\n+                    interface I<T> {}\n+                    static abstract class S implements I<String> {}\n+                    primitive static class Foo extends S implements I<Integer> {\n+                        String s = \"\";\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testClassLiteralTypingNegativeTest() {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            String[] testOptions = {\"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\", \"-XDenablePrimitiveClasses\"};\n+            setCompileOptions(testOptions);\n+            assertFail(\"compiler.err.prob.found.req\",\n+                    \"\"\"\n+                    import jdk.internal.value.PrimitiveClass;\n+                    class ClassLiteralTypingNegativeTest {\n+                        interface I {}\n+                        static primitive class Foo implements I {\n+                            final int value = 0;\n+                            void m() {\n+                                Class<? extends Foo.ref> cFooRef = PrimitiveClass.asValueType(Foo.class);\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import jdk.internal.value.PrimitiveClass;\n+                    class ClassLiteralTypingNegativeTest {\n+                        interface I {}\n+                        static primitive class Foo implements I {\n+                            final int value = 0;\n+                            void m() {\n+                                Class<? extends Foo.ref> cFooRef = new Foo().getClass();\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import jdk.internal.value.PrimitiveClass;\n+                    class ClassLiteralTypingNegativeTest {\n+                        interface I {}\n+                        static primitive class Foo implements I {\n+                            final int value = 0;\n+                            void m() {\n+                                Class<? extends Foo.ref> cFooRef = Foo.ref.class;\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertFail(\"compiler.err.prob.found.req\",\n+                    \"\"\"\n+                    import jdk.internal.value.PrimitiveClass;\n+                    class ClassLiteralTypingNegativeTest {\n+                        interface I {}\n+                        static primitive class Foo implements I {\n+                            final int value = 0;\n+                            void m() {\n+                                Class<? extends Foo.ref> cFooRef = Foo.val.class;\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import jdk.internal.value.PrimitiveClass;\n+                    class ClassLiteralTypingNegativeTest {\n+                        interface I {}\n+                        static primitive class Foo implements I {\n+                            final int value = 0;\n+                            void m() {\n+                                Foo.val xv = new Foo();\n+                                Class<? extends Foo.ref> cFooRef = xv.getClass();\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+            assertOK(\n+                    \"\"\"\n+                    import jdk.internal.value.PrimitiveClass;\n+                    class ClassLiteralTypingNegativeTest {\n+                        interface I {}\n+                        static primitive class Foo implements I {\n+                            final int value = 0;\n+                            void m() {\n+                                Foo.ref xr = new Foo();\n+                                Class<? extends Foo.ref> cFooRef = xr.getClass();\n+                            }\n+                        }\n+                    }\n+                    \"\"\");\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n-    ToolBox tb = new ToolBox();\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}