{"files":[{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8242900\n- * @summary Verify various constraints for an inline class's BINARY super types.\n- * @compile -XDrawDiagnostics -XDdev SuperclassCollections.java\n- * @compile\/fail\/ref=BinarySuperclassConstraints.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses BinarySuperclassConstraints.java\n- *\/\n-\n-public class BinarySuperclassConstraints {\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that super class cannot be concrete, including express jlO\n-    primitive class I0 extends SuperclassCollections.BadSuper {} \/\/ ERROR: concrete super class\n-\n-    \/\/ Test that abstract class is allowed to be super including when extending jlO\n-    primitive class I3 extends SuperclassCollections.GoodSuper implements SuperclassCollections.GoodSuperInterface {} \/\/ jlO can be indirect super class\n-    primitive class I4 extends SuperclassCollections.Integer {}\n-    primitive class I5 extends Number {\n-        public double doubleValue() { return 0; }\n-        public float floatValue() { return 0; }\n-        public long longValue() { return 0; }\n-        public int intValue() { return 0; }\n-    }\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that super class cannot define instance fields.\n-    primitive class I6 extends SuperclassCollections.SuperWithInstanceField_01 {} \/\/ ERROR:\n-\n-    primitive class I7 extends SuperclassCollections.SuperWithStaticField {} \/\/ OK.\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that no-arg constructor must be empty\n-    primitive class I8 extends SuperclassCollections.SuperWithEmptyNoArgCtor_02 {}\n-\n-    primitive class I9 extends SuperclassCollections.SuperWithNonEmptyNoArgCtor_01 {} \/\/ ERROR:\n-\n-    primitive class I10 extends SuperclassCollections.SuperWithArgedCtor_01 {} \/\/ ERROR:\n-\n-    primitive class I11 extends SuperclassCollections.SuperWithInstanceInit_01 {} \/\/ ERROR:\n-\n-    primitive class I12 extends SuperclassCollections.SuperWithSynchronizedMethod_1 {} \/\/ ERROR:\n-\n-    primitive class I13 extends SuperclassCollections.InnerSuper {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BinarySuperclassConstraints.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-BinarySuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.value.class: BinarySuperclassConstraints.I0, SuperclassCollections.BadSuper\n-BinarySuperclassConstraints.java:29:15: compiler.err.instance.field.not.allowed: x, (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I6, SuperclassCollections.SuperWithInstanceField)\n-BinarySuperclassConstraints.java:38:15: compiler.err.abstract.value.class.no.arg.constructor.must.be.empty: SuperclassCollections.SuperWithNonEmptyNoArgCtor(), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I9, SuperclassCollections.SuperWithNonEmptyNoArgCtor)\n-BinarySuperclassConstraints.java:40:15: compiler.err.abstract.value.class.constructor.cannot.take.arguments: SuperclassCollections.SuperWithArgedCtor(java.lang.String), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I10, SuperclassCollections.SuperWithArgedCtor)\n-BinarySuperclassConstraints.java:42:15: compiler.err.abstract.value.class.no.arg.constructor.must.be.empty: SuperclassCollections.SuperWithInstanceInit(), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I11, SuperclassCollections.SuperWithInstanceInit)\n-BinarySuperclassConstraints.java:44:15: compiler.err.super.class.method.cannot.be.synchronized: foo(), BinarySuperclassConstraints.I12, SuperclassCollections.SuperWithSynchronizedMethod\n-BinarySuperclassConstraints.java:46:15: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I13, SuperclassCollections.InnerSuper)\n-7 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BinarySuperclassConstraints.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/**\n- * @test \/nodynamiccopyright\/\n- * @bug 8244233\n- * @summary Nested types are not handled properly across projections\n- * @compile\/fail\/ref=DualPathInnerType.out -XDrawDiagnostics -XDenablePrimitiveClasses DualPathInnerType.java\n- *\/\n-\n-public primitive class DualPathInnerType  {\n-\n-    class Inner { }\n-\n-    static DualPathInnerType.Inner xi = new DualPathInnerType().new Inner();\n-    DualPathInnerType.ref.Inner xri = xi;\n-\n-    void f (DualPathInnerType.Inner xri) {}\n-    void f (DualPathInnerType.ref.Inner xri) {}\n-\n-    public static void main(String [] args) {\n-        new DualPathInnerType();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DualPathInnerType.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-DualPathInnerType.java:16:10: compiler.err.already.defined: kindname.method, f(DualPathInnerType.Inner), kindname.class, DualPathInnerType\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DualPathInnerType.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Test that final fields of value classes follow the same assignment rules as vanilla classes.\n- * @compile\/fail\/ref=FinalFieldTest.out --should-stop=at=FLOW -XDrawDiagnostics -XDenablePrimitiveClasses FinalFieldTest.java\n- *\/\n-\n-final primitive class Blah {\n-    final int x = 10;\n-    final int y;\n-    Blah() {\n-        x = 10;\n-        x = 10;\n-        y = 10;\n-        y = 10;\n-    }\n-    void foo() {\n-        x = 10;\n-        x = 10;\n-        y = 10;\n-        y = 10;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/FinalFieldTest.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-FinalFieldTest.java:11:9: compiler.err.cant.assign.val.to.final.var: x\n-FinalFieldTest.java:12:9: compiler.err.cant.assign.val.to.final.var: x\n-FinalFieldTest.java:17:9: compiler.err.cant.assign.val.to.final.var: x\n-FinalFieldTest.java:18:9: compiler.err.cant.assign.val.to.final.var: x\n-FinalFieldTest.java:19:9: compiler.err.cant.assign.val.to.final.var: y\n-FinalFieldTest.java:20:9: compiler.err.cant.assign.val.to.final.var: y\n-FinalFieldTest.java:14:9: compiler.err.var.might.already.be.assigned: y\n-7 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/FinalFieldTest.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8221545\n- * @summary Test Generics with ?\n- * @compile\/fail\/ref=GenericsWithQuestion.out -XDrawDiagnostics -XDenablePrimitiveClasses GenericsWithQuestion.java\n- *\/\n-\n-import java.util.HashMap;\n-\n-public class GenericsWithQuestion {\n-\n-    primitive class V {\n-        int x = 10;\n-    }\n-\n-    HashMap<V.ref, V.ref>good1;\n-    HashMap<V.ref, GenericsWithQuestion.V.ref>good2;\n-    HashMap<V, V>  bad1; \/\/ error;\n-    HashMap<V.ref, V> bad2; \/\/ error\n-    HashMap<V, V.ref> bad3; \/\/ error\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsWithQuestion.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-GenericsWithQuestion.java:18:13: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)\n-GenericsWithQuestion.java:18:16: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)\n-GenericsWithQuestion.java:19:20: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)\n-GenericsWithQuestion.java:20:13: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsWithQuestion.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8209400 8215246\n- * @summary Allow anonymous classes to be primitive class types\n- * @compile\/fail\/ref=IllegalByValueTest2.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses IllegalByValueTest2.java\n- *\/\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Target;\n-import java.util.Comparator;\n-\n-public class IllegalByValueTest2 {\n-\n-    @Target(ElementType.TYPE_USE)\n-    @interface Annot {\n-    }\n-\n-    public static void main(String[] args) {\n-        new @Annot primitive @Annot IllegalByValueTest2() {};\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IllegalByValueTest2.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-IllegalByValueTest2.java:19:30: compiler.err.duplicate.annotation.missing.container: IllegalByValueTest2.Annot\n-IllegalByValueTest2.java:19:59: compiler.err.concrete.supertype.for.value.class: compiler.misc.anonymous.class: IllegalByValueTest2$1, IllegalByValueTest2\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IllegalByValueTest2.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check inlineness via __inline__ annotation\n- * @bug 8222745\n- * @compile\/fail\/ref=InlineAnnotationOnAnonymousClass.out -XDrawDiagnostics -XDenablePrimitiveClasses InlineAnnotationOnAnonymousClass.java\n- *\/\n-\n-class InlineAnnotationOnAnonymousClass {\n-    interface I {}\n-    primitive\n-    public static void main(String args []) {\n-        new primitive I() {\n-        };\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineAnnotationOnAnonymousClass.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-InlineAnnotationOnAnonymousClass.java:11:24: compiler.err.mod.not.allowed.here: primitive\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineAnnotationOnAnonymousClass.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check inlineness via __inline__ annotation\n- * @bug 8222745\n- * @compile\/fail\/ref=InlineAnnotationTest.out -XDrawDiagnostics -XDenablePrimitiveClasses InlineAnnotationTest.java\n- *\/\n-\n-primitive\n-class InlineAnnotationTest01 extends Object { \n-}\n-\n-primitive\n-class InlineAnnotationTest02 { \n-}\n-\n-primitive\n-class InlineAnnotationTest03  { \n-    int x = 10;\n-    InlineAnnotationTest03() {\n-        x = 20;\n-    }\n-}\n-\n-primitive\n-interface InlineAnnotationTest04 { \n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineAnnotationTest.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-InlineAnnotationTest.java:25:1: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-InlineAnnotationTest.java:20:9: compiler.err.cant.assign.val.to.final.var: x\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineAnnotationTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,18 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8230082\n- * @summary Javac should not allow inline type's fields to be volatile (as they are final)\n- * @compile\/fail\/ref=NoVolatileFields.out -XDrawDiagnostics -XDenablePrimitiveClasses NoVolatileFields.java\n- *\/\n-\n-public class NoVolatileFields {\n-\n-    static class Foo {\n-        volatile final int i = 0; \/\/ Error\n-    }\n-\n-    static primitive class Bar {\n-        volatile int i = 0; \/\/ Error\n-    }\n-}\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoVolatileFields.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-NoVolatileFields.java:11:28: compiler.err.illegal.combination.of.modifiers: final, volatile\n-NoVolatileFields.java:15:22: compiler.err.illegal.combination.of.modifiers: final, volatile\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoVolatileFields.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237072\n- * @summary Test various relationships between a value type and its reference projection.\n- * @compile\/fail\/ref=OverloadingPhaseTest.out -XDrawDiagnostics -XDenablePrimitiveClasses OverloadingPhaseTest.java\n- *\/\n-\n-public class OverloadingPhaseTest {\n-\n-    static primitive class V {\n-        int x = 0;\n-    }\n-\n-    static String roo(V.ref v, int i) {\n-        return \"Phase 1\";\n-    }\n-\n-    static String roo(V.ref v, Integer i) {\n-        return \"Phase 2\";\n-    }\n-\n-    public static void main(String args) {\n-        V o = new V();\n-        String result;\n-\n-        if (!(result = roo(o, 0)).equals(\"phase 2\"))\n-            throw new AssertionError(\"Broken: got \" + result);\n-        if (!(result = roo(o, Integer.valueOf(0))).equals(\"phase 2\"))\n-            throw new AssertionError(\"Broken: got \" + result);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-OverloadingPhaseTest.java:26:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V.ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V.ref,java.lang.Integer), OverloadingPhaseTest\n-OverloadingPhaseTest.java:28:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V.ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V.ref,java.lang.Integer), OverloadingPhaseTest\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,642 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * PrimitiveClassesCompilationTests\n+ *\n+ * @test\n+ * @bug 8297207\n+ * @summary Negative compilation tests, and positive compilation (smoke) tests for Primitive Classes\n+ * @library \/lib\/combo \/tools\/lib\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.util\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ *     jdk.compiler\/com.sun.tools.javac.code\n+ *     jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run testng PrimitiveClassesCompilationTests\n+ *\/\n+\n+import java.io.File;\n+\n+import java.util.List;\n+\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.Code_attribute;\n+import com.sun.tools.classfile.ConstantPool;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n+import com.sun.tools.classfile.Field;\n+import com.sun.tools.classfile.Instruction;\n+import com.sun.tools.classfile.Method;\n+\n+import com.sun.tools.javac.code.Flags;\n+\n+import static org.testng.Assert.assertTrue;\n+import org.testng.annotations.Test;\n+\n+import tools.javac.combo.CompilationTestCase;\n+\n+import toolbox.ToolBox;\n+\n+@Test\n+public class PrimitiveClassesCompilationTests extends CompilationTestCase {\n+\n+    private static String[] DEFAULT_OPTIONS = {\"-XDenablePrimitiveClasses\"};\n+\n+    ToolBox tb = new ToolBox();\n+\n+    public PrimitiveClassesCompilationTests() {\n+        setDefaultFilename(\"PrimitiveClassTest.java\");\n+        setCompileOptions(DEFAULT_OPTIONS);\n+    }\n+\n+    public void testSupers() {\n+        assertOK(\n+                \"\"\"\n+                interface GoodSuperInterface {}\n+                abstract class GoodSuper extends Object {}\n+                primitive class PC extends GoodSuper implements GoodSuperInterface {}\n+                \"\"\");\n+\n+        assertOK(\n+                \"\"\"\n+                abstract class Integer extends Number {\n+                    public double doubleValue() { return 0; }\n+                    public float floatValue() { return 0; }\n+                    public long longValue() { return 0; }\n+                    public int intValue() { return 0; }\n+                }\n+                primitive class PC extends Integer {}\n+                \"\"\");\n+\n+        assertOK(\n+                \"\"\"\n+                primitive class PC extends Number {\n+                    public double doubleValue() { return 0; }\n+                    public float floatValue() { return 0; }\n+                    public long longValue() { return 0; }\n+                    public int intValue() { return 0; }\n+                }\n+                \"\"\");\n+\n+        assertOK(\n+                \"\"\"\n+                abstract class SuperWithStaticField {\n+                    static int x;\n+                }\n+                primitive class PC extends SuperWithStaticField {}\n+                \"\"\");\n+\n+        assertOK(\n+                \"\"\"\n+                abstract class SuperWithEmptyNoArgCtor {\n+                    public SuperWithEmptyNoArgCtor() {\n+                        \/\/ Programmer supplied ctor but injected super call\n+                    }\n+                }\n+                abstract class SuperWithEmptyNoArgCtor_01 extends SuperWithEmptyNoArgCtor {\n+                    public SuperWithEmptyNoArgCtor_01() {\n+                        super();  \/\/ programmer coded chaining no-arg constructor\n+                    }\n+                }\n+                abstract class SuperWithEmptyNoArgCtor_02 extends SuperWithEmptyNoArgCtor_01 {\n+                    \/\/ Synthesized chaining no-arg constructor\n+                }\n+                primitive class PC extends SuperWithEmptyNoArgCtor_02 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.concrete.supertype.for.value.class\",\n+                \"\"\"\n+                class BadSuper {}\n+                primitive class PC extends BadSuper {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.instance.field.not.allowed\",\n+                \"\"\"\n+                abstract class SuperWithInstanceField {\n+                    int x;\n+                }\n+                abstract class SuperWithInstanceField_01 extends SuperWithInstanceField {}\n+                primitive class PC extends SuperWithInstanceField_01 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.abstract.value.class.no.arg.constructor.must.be.empty\",\n+                \"\"\"\n+                abstract class SuperWithNonEmptyNoArgCtor {\n+                    public SuperWithNonEmptyNoArgCtor() {\n+                        System.out.println(\"Non-Empty\");\n+                    }\n+                }\n+                abstract class SuperWithNonEmptyNoArgCtor_01 extends SuperWithNonEmptyNoArgCtor {}\n+                primitive class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n+                \"\"\"\n+                abstract class SuperWithArgedCtor {\n+                    public SuperWithArgedCtor() {}\n+                    public SuperWithArgedCtor(String s) {\n+                    }\n+                }\n+                abstract class SuperWithArgedCtor_01 extends SuperWithArgedCtor {}\n+                primitive class PC extends SuperWithArgedCtor_01 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.abstract.value.class.declares.init.block\",\n+                \"\"\"\n+                abstract class SuperWithInstanceInit {\n+                    {\n+                        System.out.println(\"Disqualified from being super\");\n+                    }\n+                }\n+                abstract class SuperWithInstanceInit_01 extends SuperWithInstanceInit {\n+                    {\n+                        \/\/ Not disqualified since it is a meaningless empty block.\n+                    }\n+                }\n+                primitive class PC extends SuperWithInstanceInit_01 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.super.class.method.cannot.be.synchronized\",\n+                \"\"\"\n+                abstract class SuperWithSynchronizedMethod {\n+                    synchronized void foo() {}\n+                }\n+                abstract class SuperWithSynchronizedMethod_1 extends SuperWithSynchronizedMethod {}\n+                primitive class PC extends SuperWithSynchronizedMethod_1 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n+                \"\"\"\n+                class Outer {\n+                    abstract class InnerSuper {}\n+                }\n+                primitive class PC extends Outer.InnerSuper {}\n+                \"\"\");\n+    }\n+\n+    public void testFinalFields() {\n+        String[] sources = new String[] {\n+                \"\"\"\n+                primitive class Test {\n+                    final int x = 10;\n+                    Test() {\n+                        x = 10;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive class Test {\n+                    final int x = 10;\n+                    void foo() {\n+                        x = 10;\n+                    }\n+                }\n+                \"\"\"\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.cant.assign.val.to.final.var\", source);\n+        }\n+\n+        assertFail(\"compiler.err.var.might.already.be.assigned\",\n+                \"\"\"\n+                primitive class Test {\n+                    final int x;\n+                    Test() {\n+                        x = 10;\n+                        x = 10;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testWithFieldNeg() {\n+        String[] sources = new String[] {\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    primitive final class B {\n+                        final A a = A.default;\n+                        void foo(A a) {\n+                            a.x = 100;\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    static final int sx = 10;\n+                    primitive final class B {\n+                        final A a = A.default;\n+                        void foo(A a) {\n+                            a.sx = 100;\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    primitive final class B {\n+                        final A a = A.default;\n+                    }\n+                    void withfield(B b) {\n+                            b.a.x = 11;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo(A a) {\n+                        a.x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo(A a) {\n+                        (a).x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo(final A fa) {\n+                        fa.x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo() {\n+                        x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo() {\n+                        this.x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo() {\n+                        A.this.x = 100;\n+                    }\n+                }\n+                \"\"\",\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.cant.assign.val.to.final.var\", source);\n+        }\n+    }\n+\n+    public void testIllegalModifiers() {\n+        assertFail(\"compiler.err.illegal.combination.of.modifiers\", \"primitive interface I {}\");\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n+                \"\"\"\n+                class Test {\n+                    primitive public void m() {}\n+                }\n+                \"\"\");\n+        \/*\n+        \/\/ this test is passing, not sure if this is correct\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n+                \"\"\"\n+                class Test {\n+                    interface I {}\n+                    void m() {\n+                        new primitive I() {};\n+                    }\n+                }\n+                \"\"\");\n+        *\/\n+    }\n+\n+    public void testPrimitivesAsTypeParams() {\n+        String[] sources = new String[] {\n+                \"\"\"\n+                import java.util.ArrayList;\n+                primitive class ValueOverGenericsTest {\n+                    ArrayList<ValueOverGenericsTest> ax = null;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                import java.util.ArrayList;\n+                primitive class ValueOverGenericsTest {\n+                    void foo(ArrayList<? extends ValueOverGenericsTest> p) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                import java.util.ArrayList;\n+                primitive class ValueOverGenericsTest {\n+                    void foo() {\n+                        new <ValueOverGenericsTest> ArrayList<Object>();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                import java.util.ArrayList;\n+                primitive class ValueOverGenericsTest {\n+                    void foo() {\n+                        this.<ValueOverGenericsTest>foo();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                import java.util.ArrayList;\n+                primitive class ValueOverGenericsTest {\n+                    void foo() {\n+                        Object o = (ValueOverGenericsTest & Serializable) null;\n+                    }\n+                }\n+                \"\"\",\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.type.found.req\", source);\n+        }\n+    }\n+\n+    public void testLocalPrimitiveClasses() {\n+        assertFail(\"compiler.err.cant.inherit.from.final\",\n+                \"\"\"\n+                class ValueModifierTest {\n+                    interface Value {}\n+                    void goo() {\n+                        primitive class Value {}\n+                        new Value() {};\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.cant.inherit.from.final\",\n+                \"\"\"\n+                class ValueModifierTest {\n+                    interface Value {}\n+                    void goo() {\n+                        primitive class Value {}\n+                        new primitive Value() {};\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testDefaultOnUnknownClass() {\n+        assertFail(\"compiler.err.cant.resolve.location\",\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        Object o = Unknown.default;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.cant.resolve.location\",\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        Object o = Unknown1.Unknown2.default;\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testUncheckedDefaultWarning() {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            String[] testOptions = {\"-Xlint:all\", \"-XDenablePrimitiveClasses\"};\n+            setCompileOptions(testOptions);\n+            assertOKWithWarning(\"compiler.warn.prob.found.req\",\n+                    \"\"\"\n+                    primitive class UncheckedDefault<E> {\n+                        void m() {\n+                            UncheckedDefault<String> foo = UncheckedDefault.default;\n+                        }\n+                    }\n+                    \"\"\");\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n+\n+    public void testRefProjection() {\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                primitive class PC {\n+                    void foo() {\n+                        PC x = null;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo() {\n+                        PC.ref x = null;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo(PC x) {\n+                        PC.ref xq = null;\n+                        xq = x;\n+                        xq = (PC.ref) x;\n+                        xq = (PC) x;\n+                        x = xq;\n+                        x = (PC.ref) xq;\n+                        x = (PC) xq;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                primitive class PC {\n+                    void foo() {\n+                        PC[] xa = new PC[] { null };\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo() {\n+                        PC.ref [] xqa = new PC.ref[] { null };\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo(PC[] xa) {\n+                        PC.ref[] xqa = xa;\n+                        xqa = (PC.ref[]) xa;\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                primitive class PC {\n+                    void foo(PC[] xa, PC.ref[] xqa) {\n+                        xa = xqa;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                primitive class PC {\n+                    void foo(PC[] xa, PC.ref[] xqa) {\n+                        xa = (PC[]) xqa;\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testSuperInvocation() {\n+        assertFail(\"compiler.err.call.to.super.not.allowed.in.value.ctor\",\n+                \"\"\"\n+                primitive class PC {\n+                    PC(String s) {\n+                        super();  \/\/ Error.\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testProjectionInstantiation() {\n+        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n+                \"\"\"\n+                primitive class PC {\n+                    void m() {\n+                        new PC.ref();\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n+                \"\"\"\n+                primitive class PC {\n+                    void m() {\n+                        new PC.val();\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                import java.util.function.Supplier;\n+                primitive class PC {\n+                    void m() {\n+                        foo(PC::new);\n+                    }\n+                    static void foo(Supplier<PC.ref> sx) {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n+                \"\"\"\n+                import java.util.function.Supplier;\n+                primitive class PC {\n+                    void m() {\n+                        foo(PC.ref::new);\n+                    }\n+                    static void foo(Supplier<PC.ref> sx) {}\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n+                \"\"\"\n+                import java.util.function.Supplier;\n+                primitive class PC {\n+                    void m() {\n+                        foo(PC.val::new);\n+                    }\n+                    static void foo(Supplier<PC.ref> sx) {}\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testOverloadResolution() {\n+        assertFail(\"compiler.err.ref.ambiguous\",\n+                \"\"\"\n+                class OverloadingPhaseTest {\n+                    static primitive class V {}\n+                    static String roo(V.ref v, int i) {\n+                        return \"\";\n+                    }\n+                    static String roo(V.ref v, Integer i) {\n+                        return \"\";\n+                    }\n+                    void m(V o) {\n+                        String result = roo(o, 0);\n+                    }\n+                }\n+                \"\"\");\n+        assertFail(\"compiler.err.ref.ambiguous\",\n+                \"\"\"\n+                class OverloadingPhaseTest {\n+                    static primitive class V {}\n+                    static String roo(V.ref v, int i) {\n+                        return \"\";\n+                    }\n+                    static String roo(V.ref v, Integer i) {\n+                        return \"\";\n+                    }\n+                    void m(V o) {\n+                        String result = roo(o, Integer.valueOf(0));\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testNoVolatileFields() {\n+        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n+                \"\"\"\n+                primitive class Bar {\n+                    volatile int i = 0;\n+                }\n+                \"\"\");\n+    }\n+\n+    public void testDualPath() {\n+        assertFail(\"compiler.err.already.defined\",\n+                \"\"\"\n+                primitive class DualPathInnerType  {\n+                    class Inner { }\n+\n+                    static DualPathInnerType.Inner xi = new DualPathInnerType().new Inner();\n+                    DualPathInnerType.ref.Inner xri = xi;\n+\n+                    void f (DualPathInnerType.Inner xri) {}\n+                    void f (DualPathInnerType.ref.Inner xri) {}\n+                }\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":642,"deletions":0,"binary":false,"changes":642,"status":"added"},{"patch":"@@ -1,22 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8244561 8250997\n- * @summary Javac should not allow instantiation of V.ref or V.val\n- * @compile\/fail\/ref=ProjectionInstantiationTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ProjectionInstantiationTest.java\n- *\/\n-import java.util.function.Supplier;\n-\n-final primitive class ProjectionInstantiationTest {\n-    int x = 42;\n-    public static void main(String[] args) {\n-        new ProjectionInstantiationTest();\n-        new ProjectionInstantiationTest.ref();\n-        new ProjectionInstantiationTest.val();\n-        foo(ProjectionInstantiationTest::new);\n-        foo(ProjectionInstantiationTest.ref::new);\n-        foo(ProjectionInstantiationTest.val::new);\n-    }\n-    static void foo(Supplier<ProjectionInstantiationTest.ref> sx) {\n-        sx.get();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionInstantiationTest.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ProjectionInstantiationTest.java:13:9: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:14:9: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:16:40: compiler.err.projection.cant.be.instantiated\n-ProjectionInstantiationTest.java:17:40: compiler.err.projection.cant.be.instantiated\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionInstantiationTest.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8267835\n- * @summary  Javac tolerates vacuous chaining to super constructor from primitive class constructor\n- * @compile\/fail\/ref=SuperCallInCtor.out -XDrawDiagnostics -XDenablePrimitiveClasses SuperCallInCtor.java\n- *\/\n-\n-final class SuperCallInCtor {\n-\n-    primitive class P {\n-       \/\/ generated ctor with super() call is OK.\n-    }\n-\n-    primitive class Q {\n-        Q() {\n-            System.out.println(\"Construct Q\"); \/\/ Ok, no express super();\n-        }\n-\n-        Q(int x) {\n-            this();   \/\/ chaining with this is OK.\n-        }\n-\n-        Q(String s) {\n-            super();  \/\/ Error.\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperCallInCtor.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-SuperCallInCtor.java:24:13: compiler.err.call.to.super.not.allowed.in.value.ctor\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperCallInCtor.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class SuperclassCollections {\n-\n-    public static class BadSuper {}\n-\n-    public interface GoodSuperInterface {}\n-    public static abstract class GoodSuper extends Object {}\n-    public static abstract class Integer extends Number {\n-        public double doubleValue() { return 0; }\n-        public float floatValue() { return 0; }\n-        public long longValue() { return 0; }\n-        public int intValue() { return 0; }\n-    }\n-    public static abstract class SuperWithInstanceField {\n-        int x;\n-    }\n-    public static abstract class SuperWithInstanceField_01 extends SuperWithInstanceField {}\n-\n-    public static abstract class SuperWithStaticField {\n-        static int x;\n-    }\n-    public static abstract class SuperWithEmptyNoArgCtor {\n-        public SuperWithEmptyNoArgCtor() {\n-            \/\/ Programmer supplied ctor but injected super call\n-        }\n-    }\n-    public static abstract class SuperWithEmptyNoArgCtor_01 extends SuperWithEmptyNoArgCtor {\n-        public SuperWithEmptyNoArgCtor_01() {\n-            super();  \/\/ programmer coded chaining no-arg constructor\n-        }\n-    }\n-    public static abstract class SuperWithEmptyNoArgCtor_02 extends SuperWithEmptyNoArgCtor_01 {\n-        \/\/ Synthesized chaining no-arg constructor\n-    }\n-\n-    public static abstract class SuperWithNonEmptyNoArgCtor {\n-        public SuperWithNonEmptyNoArgCtor() {\n-            System.out.println(\"Non-Empty\");\n-        }\n-    }\n-    public static abstract class SuperWithNonEmptyNoArgCtor_01 extends SuperWithNonEmptyNoArgCtor {}\n-\n-    public static abstract class SuperWithArgedCtor {\n-        public SuperWithArgedCtor() {}\n-        public SuperWithArgedCtor(String s) {\n-        }\n-    }\n-    public static abstract class SuperWithArgedCtor_01 extends SuperWithArgedCtor {}\n-\n-    public static abstract class SuperWithInstanceInit {\n-        {\n-            System.out.println(\"Disqualified from being super\");\n-        }\n-    }\n-    public static abstract class SuperWithInstanceInit_01 extends SuperWithInstanceInit {\n-        {\n-            \/\/ Not disqualified since it is a meaningless empty block.\n-        }\n-    }\n-\n-    public static abstract class SuperWithSynchronizedMethod {\n-        synchronized void foo() {}\n-    }\n-    public static abstract class SuperWithSynchronizedMethod_1 extends SuperWithSynchronizedMethod {\n-    }\n-\n-    public abstract class InnerSuper {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperclassCollections.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8242900\n- * @summary Verify various constraints for an inline class's super types.\n- * @compile\/fail\/ref=SuperclassConstraints.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses SuperclassConstraints.java\n- *\/\n-\n-public class SuperclassConstraints {\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that super class cannot be concrete, including express jlO\n-    static class BadSuper {}\n-    primitive class I0 extends BadSuper {} \/\/ ERROR: concrete super class\n-    primitive class I1 extends Object {}   \/\/ OK: concrete jlO can be express-superclass\n-    primitive class I2 {} \/\/ OK\n-\n-    \/\/ Test that abstract class is allowed to be super including when extending jlO\n-    interface GoodSuperInterface {}\n-    static abstract class GoodSuper extends Object {}\n-    primitive class I3 extends GoodSuper implements GoodSuperInterface {} \/\/ jlO can be indirect super class\n-    static abstract class Integer extends Number {\n-        public double doubleValue() { return 0; }\n-        public float floatValue() { return 0; }\n-        public long longValue() { return 0; }\n-        public int intValue() { return 0; }\n-    }\n-    primitive class I4 extends Integer {}\n-    primitive class I5 extends Number {\n-        public double doubleValue() { return 0; }\n-        public float floatValue() { return 0; }\n-        public long longValue() { return 0; }\n-        public int intValue() { return 0; }\n-    }\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that super class cannot define instance fields.\n-    static abstract class SuperWithInstanceField {\n-        int x;\n-    }\n-    static abstract class SuperWithInstanceField_01 extends SuperWithInstanceField {}\n-\n-    primitive class I6 extends SuperWithInstanceField_01 {} \/\/ ERROR:\n-\n-    \/\/ Test that super class can define static fields.\n-    static abstract class SuperWithStaticField {\n-        static int x;\n-    }\n-    primitive class I7 extends SuperWithStaticField {} \/\/ OK.\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that no-arg constructor must be empty\n-    static abstract class SuperWithEmptyNoArgCtor {\n-        SuperWithEmptyNoArgCtor() {\n-            \/\/ Programmer supplied ctor but injected super call\n-        }\n-    }\n-    static abstract class SuperWithEmptyNoArgCtor_01 extends SuperWithEmptyNoArgCtor {\n-        SuperWithEmptyNoArgCtor_01() {\n-            super();  \/\/ programmer coded chaining no-arg constructor\n-        }\n-    }\n-    static abstract class SuperWithEmptyNoArgCtor_02 extends SuperWithEmptyNoArgCtor_01 {\n-        \/\/ Synthesized chaining no-arg constructor\n-    }\n-    primitive class I8 extends SuperWithEmptyNoArgCtor_02 {}\n-\n-    static abstract class SuperWithNonEmptyNoArgCtor {\n-        SuperWithNonEmptyNoArgCtor() {\n-            System.out.println(\"Non-Empty\");\n-        }\n-    }\n-    static abstract class SuperWithNonEmptyNoArgCtor_01 extends SuperWithNonEmptyNoArgCtor {}\n-    primitive class I9 extends SuperWithNonEmptyNoArgCtor_01 {} \/\/ ERROR:\n-\n-    \/\/ Test that there can be no other constructors.\n-    static abstract class SuperWithArgedCtor {\n-        SuperWithArgedCtor() {}\n-        SuperWithArgedCtor(String s) {\n-        }\n-    }\n-    static abstract class SuperWithArgedCtor_01 extends SuperWithArgedCtor {}\n-    primitive class I10 extends SuperWithArgedCtor_01 {} \/\/ ERROR:\n-\n-    \/\/ Test that instance initializers are not allowed in supers\n-    static abstract class SuperWithInstanceInit {\n-        {\n-            System.out.println(\"Disqualified from being super\");\n-        }\n-    }\n-    static abstract class SuperWithInstanceInit_01 extends SuperWithInstanceInit {\n-        {\n-            \/\/ Not disqualified since it is a meaningless empty block.\n-        }\n-    }\n-    primitive class I11 extends SuperWithInstanceInit_01 {} \/\/ ERROR:\n-\n-    \/\/ Test that synchronized methods are not allowed in supers.\n-    static abstract class SuperWithSynchronizedMethod {\n-        synchronized void foo() {}\n-    }\n-    static abstract class SuperWithSynchronizedMethod_1 extends SuperWithSynchronizedMethod {\n-    }\n-    primitive class I12 extends SuperWithSynchronizedMethod_1 {} \/\/ ERROR:\n-\n-    \/\/ No instance fields and no arged constructor also means inner classes cannot be supers\n-    abstract class InnerSuper {}\n-    primitive class I13 extends InnerSuper {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperclassConstraints.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-SuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.value.class: SuperclassConstraints.I0, SuperclassConstraints.BadSuper\n-SuperclassConstraints.java:44:15: compiler.err.instance.field.not.allowed: x, (compiler.misc.superclass.of.value.class: SuperclassConstraints.I6, SuperclassConstraints.SuperWithInstanceField)\n-SuperclassConstraints.java:76:15: compiler.err.abstract.value.class.no.arg.constructor.must.be.empty: SuperclassConstraints.SuperWithNonEmptyNoArgCtor(), (compiler.misc.superclass.of.value.class: SuperclassConstraints.I9, SuperclassConstraints.SuperWithNonEmptyNoArgCtor)\n-SuperclassConstraints.java:85:15: compiler.err.abstract.value.class.constructor.cannot.take.arguments: SuperclassConstraints.SuperWithArgedCtor(java.lang.String), (compiler.misc.superclass.of.value.class: SuperclassConstraints.I10, SuperclassConstraints.SuperWithArgedCtor)\n-SuperclassConstraints.java:98:15: compiler.err.abstract.value.class.declares.init.block: (compiler.misc.superclass.of.value.class: SuperclassConstraints.I11, SuperclassConstraints.SuperWithInstanceInit)\n-SuperclassConstraints.java:106:15: compiler.err.super.class.method.cannot.be.synchronized: foo(), SuperclassConstraints.I12, SuperclassConstraints.SuperWithSynchronizedMethod\n-SuperclassConstraints.java:110:15: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.superclass.of.value.class: SuperclassConstraints.I13, SuperclassConstraints.InnerSuper)\n-7 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperclassConstraints.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8222792\n- * @summary Javac should enforce the latest relationship rules between an inline type and its nullable projection\n- * @compile\/fail\/ref=TypeRelationsNegativeTest.out -XDrawDiagnostics -XDenablePrimitiveClasses TypeRelationsNegativeTest.java\n- *\/\n-\n-final primitive class TypeRelationsNegativeTest {\n-\n-    void foo() {\n-        TypeRelationsNegativeTest x = null; \/\/ error\n-        TypeRelationsNegativeTest.ref xq = null;\n-\n-        xq = x;\n-        xq = (TypeRelationsNegativeTest.ref) x;\n-        xq = (TypeRelationsNegativeTest) x;\n-        x = xq;\n-        x = (TypeRelationsNegativeTest.ref) xq;\n-        x = (TypeRelationsNegativeTest) xq;\n-\n-        TypeRelationsNegativeTest [] xa = new TypeRelationsNegativeTest[] { null }; \/\/ error\n-        TypeRelationsNegativeTest.ref [] xqa = new TypeRelationsNegativeTest.ref[] { null };\n-\n-        xqa = xa;\n-        xqa = (TypeRelationsNegativeTest.ref[]) xa;\n-        xa = xqa;\/\/ error\n-        xa = (TypeRelationsNegativeTest []) xqa;\n-    }\n-    int x = 10;\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsNegativeTest.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-TypeRelationsNegativeTest.java:11:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, TypeRelationsNegativeTest)\n-TypeRelationsNegativeTest.java:21:77: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, TypeRelationsNegativeTest)\n-TypeRelationsNegativeTest.java:26:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest.ref[], TypeRelationsNegativeTest[])\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsNegativeTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,20 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8210906\n- * @summary [lworld] default value creation should not impose raw types on users.\n- * @compile\/fail\/ref=UncheckedDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses UncheckedDefault.java\n- *\/\n-\n-public primitive class UncheckedDefault<E> {\n-    E value;\n-    UncheckedDefault(E value) { this.value = value; }\n-    public static void main(String [] args) {\n-        UncheckedDefault<String> foo = UncheckedDefault.default;\n-    }\n-\n-    public E makeDefault() {\n-        E e = E.default;\n-        return e;\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UncheckedDefault.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-UncheckedDefault.java:12:56: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedDefault, UncheckedDefault<java.lang.String>\n-- compiler.err.warnings.and.werror\n-1 error\n-1 warning\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UncheckedDefault.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8264216\n- * @summary [lworld] unknown.Class.default gives misleading compilation error\n- * @compile\/fail\/ref=UnknownTypeDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses UnknownTypeDefault.java\n- *\/\n-\n-public class UnknownTypeDefault {\n-\n-    public static void main(String [] args) {\n-        Object d1 = Y.default;\n-        Object d2 = y.Z.default;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnknownTypeDefault.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-UnknownTypeDefault.java:11:22: compiler.err.cant.resolve.location: kindname.class, Y, null, null, (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n-UnknownTypeDefault.java:12:24: compiler.err.cant.resolve.location: kindname.class, y.Z, null, null, (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnknownTypeDefault.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check valueness via __value__ annotation\n- * @bug 8221699\n- * @compile\/fail\/ref=ValueAnnotationOnAnonymousClass.out -XDrawDiagnostics -XDenablePrimitiveClasses ValueAnnotationOnAnonymousClass.java\n- *\/\n-\n-class ValueAnnotationOnAnonymousClass {\n-    interface I {}\n-    primitive\n-    public static void main(String args []) {\n-        new primitive I() {\n-        };\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAnnotationOnAnonymousClass.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-ValueAnnotationOnAnonymousClass.java:11:24: compiler.err.mod.not.allowed.here: primitive\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAnnotationOnAnonymousClass.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check valueness via __value__ annotation\n- * @bug 8221699\n- * @compile\/fail\/ref=ValueAnnotationTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ValueAnnotationTest.java\n- *\/\n-\n-primitive\n-class ValueAnnotationTest01 extends Object { \n-}\n-\n-primitive\n-class ValueAnnotationTest02 { \n-}\n-\n-primitive\n-class ValueAnnotationTest03  { \n-    int x = 10;\n-    ValueAnnotationTest03() {\n-        x = 20;\n-    }\n-}\n-\n-primitive\n-interface ValueAnnotationTest04 { \n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAnnotationTest.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-ValueAnnotationTest.java:25:1: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-ValueAnnotationTest.java:20:9: compiler.err.cant.assign.val.to.final.var: x\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAnnotationTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8211910 8215246\n- * @summary Reinstate support for local value classes.\n- * @compile\/fail\/ref=ValueModifierTest.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses ValueModifierTest.java\n- *\/\n-\n-public class ValueModifierTest {\n-    interface Value {}\n-    void foo() {\n-        new primitive Value() {};\n-    }\n-    void goo() {\n-        primitive class Value {}\n-        new Value() {};\n-        new primitive Value() {};\n-        new Value();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueModifierTest.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-ValueModifierTest.java:15:13: compiler.err.cant.inherit.from.final: Value\n-ValueModifierTest.java:15:21: compiler.err.identity.type.has.value.super.type: compiler.misc.anonymous.class: Value, Value\n-ValueModifierTest.java:16:23: compiler.err.cant.inherit.from.final: Value\n-ValueModifierTest.java:16:31: compiler.err.concrete.supertype.for.value.class: compiler.misc.anonymous.class: ValueModifierTest$3, Value\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueModifierTest.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Value types cannot parameterize generic types (except under experimental mode)\n- * @compile\/fail\/ref=ValueOverGenericsTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ValueOverGenericsTest.java\n- *\n- *\/\n-\n-import java.util.ArrayList;\n-import java.io.Serializable;\n-\n-primitive class ValueOverGenericsTest {\n-    int x = 10;\n-    ArrayList<ValueOverGenericsTest> ax = null;\n-    void foo(ArrayList<? extends ValueOverGenericsTest> p) {\n-        new <ValueOverGenericsTest> ArrayList<Object>();\n-        this.<ValueOverGenericsTest>foo(null);\n-        Object o = (ValueOverGenericsTest & Serializable) null;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueOverGenericsTest.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-ValueOverGenericsTest.java:13:15: compiler.err.type.found.req: ValueOverGenericsTest, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:14:24: compiler.err.type.found.req: ValueOverGenericsTest, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:15:14: compiler.err.type.found.req: ValueOverGenericsTest, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:16:15: compiler.err.type.found.req: ValueOverGenericsTest, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:17:21: compiler.err.type.found.req: ValueOverGenericsTest, (compiler.misc.type.req.ref)\n-ValueOverGenericsTest.java:17:59: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, ValueOverGenericsTest&java.io.Serializable)\n-6 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueOverGenericsTest.out","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check various withfield constrains\n- *\n- * @compile\/fail\/ref=WithFieldNegativeTests.out -XDrawDiagnostics -XDenablePrimitiveClasses WithFieldNegativeTests.java\n- *\/\n-\n-primitive final class A {\n-    final int x = 10;\n-    static final int sx = 10;\n-\n-    primitive final class B {\n-\n-        final A a = A.default;\n-\n-        void foo(A a) {\n-            a.x = 100;\n-            a.sx = 100;\n-        }\n-    }\n-\n-    void withfield(B b) {\n-            b.a.x = 11;\n-    }\n-\n-    void foo(A a, final A fa) {\n-        a.x = 100;\n-        (a).x = 100;\n-        fa.x = 100;\n-        x = 100;\n-        this.x = 100;\n-        A.this.x = 100;\n-    }\n-}\n-\n-class C {\n-    void foo(A a) {\n-        a.x = 100;\n-        a.sx = 100;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldNegativeTests.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-WithFieldNegativeTests.java:17:14: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:18:14: compiler.err.cant.assign.val.to.final.var: sx\n-WithFieldNegativeTests.java:23:16: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:27:10: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:28:12: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:29:11: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:30:9: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:31:13: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:32:15: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:38:10: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:39:10: compiler.err.cant.assign.val.to.final.var: sx\n-11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldNegativeTests.out","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"}]}