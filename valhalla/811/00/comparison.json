{"files":[{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8242900\n- * @summary Verify various constraints for an inline class's BINARY super types.\n- * @compile -XDrawDiagnostics -XDdev SuperclassCollections.java\n- * @compile\/fail\/ref=BinarySuperclassConstraints.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses BinarySuperclassConstraints.java\n- *\/\n-\n-public class BinarySuperclassConstraints {\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that super class cannot be concrete, including express jlO\n-    primitive class I0 extends SuperclassCollections.BadSuper {} \/\/ ERROR: concrete super class\n-\n-    \/\/ Test that abstract class is allowed to be super including when extending jlO\n-    primitive class I3 extends SuperclassCollections.GoodSuper implements SuperclassCollections.GoodSuperInterface {} \/\/ jlO can be indirect super class\n-    primitive class I4 extends SuperclassCollections.Integer {}\n-    primitive class I5 extends Number {\n-        public double doubleValue() { return 0; }\n-        public float floatValue() { return 0; }\n-        public long longValue() { return 0; }\n-        public int intValue() { return 0; }\n-    }\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that super class cannot define instance fields.\n-    primitive class I6 extends SuperclassCollections.SuperWithInstanceField_01 {} \/\/ ERROR:\n-\n-    primitive class I7 extends SuperclassCollections.SuperWithStaticField {} \/\/ OK.\n-\n-    \/\/ -------------------------------------------------------------\n-\n-    \/\/ Test that no-arg constructor must be empty\n-    primitive class I8 extends SuperclassCollections.SuperWithEmptyNoArgCtor_02 {}\n-\n-    primitive class I9 extends SuperclassCollections.SuperWithNonEmptyNoArgCtor_01 {} \/\/ ERROR:\n-\n-    primitive class I10 extends SuperclassCollections.SuperWithArgedCtor_01 {} \/\/ ERROR:\n-\n-    primitive class I11 extends SuperclassCollections.SuperWithInstanceInit_01 {} \/\/ ERROR:\n-\n-    primitive class I12 extends SuperclassCollections.SuperWithSynchronizedMethod_1 {} \/\/ ERROR:\n-\n-    primitive class I13 extends SuperclassCollections.InnerSuper {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BinarySuperclassConstraints.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-BinarySuperclassConstraints.java:14:15: compiler.err.concrete.supertype.for.value.class: BinarySuperclassConstraints.I0, SuperclassCollections.BadSuper\n-BinarySuperclassConstraints.java:29:15: compiler.err.instance.field.not.allowed: x, (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I6, SuperclassCollections.SuperWithInstanceField)\n-BinarySuperclassConstraints.java:38:15: compiler.err.abstract.value.class.no.arg.constructor.must.be.empty: SuperclassCollections.SuperWithNonEmptyNoArgCtor(), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I9, SuperclassCollections.SuperWithNonEmptyNoArgCtor)\n-BinarySuperclassConstraints.java:40:15: compiler.err.abstract.value.class.constructor.cannot.take.arguments: SuperclassCollections.SuperWithArgedCtor(java.lang.String), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I10, SuperclassCollections.SuperWithArgedCtor)\n-BinarySuperclassConstraints.java:42:15: compiler.err.abstract.value.class.no.arg.constructor.must.be.empty: SuperclassCollections.SuperWithInstanceInit(), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I11, SuperclassCollections.SuperWithInstanceInit)\n-BinarySuperclassConstraints.java:44:15: compiler.err.super.class.method.cannot.be.synchronized: foo(), BinarySuperclassConstraints.I12, SuperclassCollections.SuperWithSynchronizedMethod\n-BinarySuperclassConstraints.java:46:15: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I13, SuperclassCollections.InnerSuper)\n-7 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BinarySuperclassConstraints.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Test that final fields of value classes follow the same assignment rules as vanilla classes.\n- * @compile\/fail\/ref=FinalFieldTest.out --should-stop=at=FLOW -XDrawDiagnostics -XDenablePrimitiveClasses FinalFieldTest.java\n- *\/\n-\n-final primitive class Blah {\n-    final int x = 10;\n-    final int y;\n-    Blah() {\n-        x = 10;\n-        x = 10;\n-        y = 10;\n-        y = 10;\n-    }\n-    void foo() {\n-        x = 10;\n-        x = 10;\n-        y = 10;\n-        y = 10;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/FinalFieldTest.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-FinalFieldTest.java:11:9: compiler.err.cant.assign.val.to.final.var: x\n-FinalFieldTest.java:12:9: compiler.err.cant.assign.val.to.final.var: x\n-FinalFieldTest.java:17:9: compiler.err.cant.assign.val.to.final.var: x\n-FinalFieldTest.java:18:9: compiler.err.cant.assign.val.to.final.var: x\n-FinalFieldTest.java:19:9: compiler.err.cant.assign.val.to.final.var: y\n-FinalFieldTest.java:20:9: compiler.err.cant.assign.val.to.final.var: y\n-FinalFieldTest.java:14:9: compiler.err.var.might.already.be.assigned: y\n-7 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/FinalFieldTest.out","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * PrimitiveClassesCompilationTests\n+ *\n+ * @test\n+ * @bug 8297207\n+ * @summary Negative compilation tests, and positive compilation (smoke) tests for Primitive Classes\n+ * @library \/lib\/combo \/tools\/lib\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.util\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ *     jdk.compiler\/com.sun.tools.javac.code\n+ *     jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run testng PrimitiveClassesCompilationTests\n+ *\/\n+\n+import java.io.File;\n+\n+import java.util.List;\n+\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.Code_attribute;\n+import com.sun.tools.classfile.ConstantPool;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n+import com.sun.tools.classfile.Field;\n+import com.sun.tools.classfile.Instruction;\n+import com.sun.tools.classfile.Method;\n+\n+import com.sun.tools.javac.code.Flags;\n+\n+import static org.testng.Assert.assertTrue;\n+import org.testng.annotations.Test;\n+\n+import tools.javac.combo.CompilationTestCase;\n+\n+import toolbox.ToolBox;\n+\n+@Test\n+public class PrimitiveClassesCompilationTests extends CompilationTestCase {\n+\n+    private static String[] DEFAULT_OPTIONS = {\"-XDenablePrimitiveClasses\"};\n+\n+    ToolBox tb = new ToolBox();\n+\n+    public PrimitiveClassesCompilationTests() {\n+        setDefaultFilename(\"PrimitiveClassTest.java\");\n+        setCompileOptions(DEFAULT_OPTIONS);\n+    }\n+\n+    public void testSupers() {\n+        assertOK(\n+                \"\"\"\n+                interface GoodSuperInterface {}\n+                abstract class GoodSuper extends Object {}\n+                primitive class PC extends GoodSuper implements GoodSuperInterface {}\n+                \"\"\");\n+\n+        assertOK(\n+                \"\"\"\n+                abstract class Integer extends Number {\n+                    public double doubleValue() { return 0; }\n+                    public float floatValue() { return 0; }\n+                    public long longValue() { return 0; }\n+                    public int intValue() { return 0; }\n+                }\n+                primitive class PC extends Integer {}\n+                \"\"\");\n+\n+        assertOK(\n+                \"\"\"\n+                primitive class PC extends Number {\n+                    public double doubleValue() { return 0; }\n+                    public float floatValue() { return 0; }\n+                    public long longValue() { return 0; }\n+                    public int intValue() { return 0; }\n+                }\n+                \"\"\");\n+\n+        assertOK(\n+                \"\"\"\n+                abstract class SuperWithStaticField {\n+                    static int x;\n+                }\n+                primitive class PC extends SuperWithStaticField {}\n+                \"\"\");\n+\n+        assertOK(\n+                \"\"\"\n+                abstract class SuperWithEmptyNoArgCtor {\n+                    public SuperWithEmptyNoArgCtor() {\n+                        \/\/ Programmer supplied ctor but injected super call\n+                    }\n+                }\n+                abstract class SuperWithEmptyNoArgCtor_01 extends SuperWithEmptyNoArgCtor {\n+                    public SuperWithEmptyNoArgCtor_01() {\n+                        super();  \/\/ programmer coded chaining no-arg constructor\n+                    }\n+                }\n+                abstract class SuperWithEmptyNoArgCtor_02 extends SuperWithEmptyNoArgCtor_01 {\n+                    \/\/ Synthesized chaining no-arg constructor\n+                }\n+                primitive class PC extends SuperWithEmptyNoArgCtor_02 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.concrete.supertype.for.value.class\",\n+                \"\"\"\n+                class BadSuper {}\n+                primitive class PC extends BadSuper {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.instance.field.not.allowed\",\n+                \"\"\"\n+                abstract class SuperWithInstanceField {\n+                    int x;\n+                }\n+                abstract class SuperWithInstanceField_01 extends SuperWithInstanceField {}\n+                primitive class PC extends SuperWithInstanceField_01 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.abstract.value.class.no.arg.constructor.must.be.empty\",\n+                \"\"\"\n+                abstract class SuperWithNonEmptyNoArgCtor {\n+                    public SuperWithNonEmptyNoArgCtor() {\n+                        System.out.println(\"Non-Empty\");\n+                    }\n+                }\n+                abstract class SuperWithNonEmptyNoArgCtor_01 extends SuperWithNonEmptyNoArgCtor {}\n+                primitive class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n+                \"\"\"\n+                abstract class SuperWithArgedCtor {\n+                    public SuperWithArgedCtor() {}\n+                    public SuperWithArgedCtor(String s) {\n+                    }\n+                }\n+                abstract class SuperWithArgedCtor_01 extends SuperWithArgedCtor {}\n+                primitive class PC extends SuperWithArgedCtor_01 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.abstract.value.class.declares.init.block\",\n+                \"\"\"\n+                abstract class SuperWithInstanceInit {\n+                    {\n+                        System.out.println(\"Disqualified from being super\");\n+                    }\n+                }\n+                abstract class SuperWithInstanceInit_01 extends SuperWithInstanceInit {\n+                    {\n+                        \/\/ Not disqualified since it is a meaningless empty block.\n+                    }\n+                }\n+                primitive class PC extends SuperWithInstanceInit_01 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.super.class.method.cannot.be.synchronized\",\n+                \"\"\"\n+                abstract class SuperWithSynchronizedMethod {\n+                    synchronized void foo() {}\n+                }\n+                abstract class SuperWithSynchronizedMethod_1 extends SuperWithSynchronizedMethod {}\n+                primitive class PC extends SuperWithSynchronizedMethod_1 {}\n+                \"\"\");\n+\n+        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n+                \"\"\"\n+                class Outer {\n+                    abstract class InnerSuper {}\n+                }\n+                primitive class PC extends Outer.InnerSuper {}\n+                \"\"\");\n+    }\n+\n+    public void testFinalFields() {\n+        String[] sources = new String[] {\n+                \"\"\"\n+                primitive class Test {\n+                    final int x = 10;\n+                    Test() {\n+                        x = 10;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive class Test {\n+                    final int x = 10;\n+                    void foo() {\n+                        x = 10;\n+                    }\n+                }\n+                \"\"\"\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.cant.assign.val.to.final.var\", source);\n+        }\n+\n+        assertFail(\"compiler.err.var.might.already.be.assigned\",\n+                \"\"\"\n+                primitive class Test {\n+                    final int x;\n+                    Test() {\n+                        x = 10;\n+                        x = 10;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testWithFieldNeg() {\n+        String[] sources = new String[] {\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    primitive final class B {\n+                        final A a = A.default;\n+                        void foo(A a) {\n+                            a.x = 100;\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    static final int sx = 10;\n+                    primitive final class B {\n+                        final A a = A.default;\n+                        void foo(A a) {\n+                            a.sx = 100;\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    primitive final class B {\n+                        final A a = A.default;\n+                    }\n+                    void withfield(B b) {\n+                            b.a.x = 11;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo(A a) {\n+                        a.x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo(A a) {\n+                        (a).x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo(final A fa) {\n+                        fa.x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo() {\n+                        x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo() {\n+                        this.x = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                primitive final class A {\n+                    final int x = 10;\n+                    void foo() {\n+                        A.this.x = 100;\n+                    }\n+                }\n+                \"\"\",\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.cant.assign.val.to.final.var\", source);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class SuperclassCollections {\n-\n-    public static class BadSuper {}\n-\n-    public interface GoodSuperInterface {}\n-    public static abstract class GoodSuper extends Object {}\n-    public static abstract class Integer extends Number {\n-        public double doubleValue() { return 0; }\n-        public float floatValue() { return 0; }\n-        public long longValue() { return 0; }\n-        public int intValue() { return 0; }\n-    }\n-    public static abstract class SuperWithInstanceField {\n-        int x;\n-    }\n-    public static abstract class SuperWithInstanceField_01 extends SuperWithInstanceField {}\n-\n-    public static abstract class SuperWithStaticField {\n-        static int x;\n-    }\n-    public static abstract class SuperWithEmptyNoArgCtor {\n-        public SuperWithEmptyNoArgCtor() {\n-            \/\/ Programmer supplied ctor but injected super call\n-        }\n-    }\n-    public static abstract class SuperWithEmptyNoArgCtor_01 extends SuperWithEmptyNoArgCtor {\n-        public SuperWithEmptyNoArgCtor_01() {\n-            super();  \/\/ programmer coded chaining no-arg constructor\n-        }\n-    }\n-    public static abstract class SuperWithEmptyNoArgCtor_02 extends SuperWithEmptyNoArgCtor_01 {\n-        \/\/ Synthesized chaining no-arg constructor\n-    }\n-\n-    public static abstract class SuperWithNonEmptyNoArgCtor {\n-        public SuperWithNonEmptyNoArgCtor() {\n-            System.out.println(\"Non-Empty\");\n-        }\n-    }\n-    public static abstract class SuperWithNonEmptyNoArgCtor_01 extends SuperWithNonEmptyNoArgCtor {}\n-\n-    public static abstract class SuperWithArgedCtor {\n-        public SuperWithArgedCtor() {}\n-        public SuperWithArgedCtor(String s) {\n-        }\n-    }\n-    public static abstract class SuperWithArgedCtor_01 extends SuperWithArgedCtor {}\n-\n-    public static abstract class SuperWithInstanceInit {\n-        {\n-            System.out.println(\"Disqualified from being super\");\n-        }\n-    }\n-    public static abstract class SuperWithInstanceInit_01 extends SuperWithInstanceInit {\n-        {\n-            \/\/ Not disqualified since it is a meaningless empty block.\n-        }\n-    }\n-\n-    public static abstract class SuperWithSynchronizedMethod {\n-        synchronized void foo() {}\n-    }\n-    public static abstract class SuperWithSynchronizedMethod_1 extends SuperWithSynchronizedMethod {\n-    }\n-\n-    public abstract class InnerSuper {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperclassCollections.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check various withfield constrains\n- *\n- * @compile\/fail\/ref=WithFieldNegativeTests.out -XDrawDiagnostics -XDenablePrimitiveClasses WithFieldNegativeTests.java\n- *\/\n-\n-primitive final class A {\n-    final int x = 10;\n-    static final int sx = 10;\n-\n-    primitive final class B {\n-\n-        final A a = A.default;\n-\n-        void foo(A a) {\n-            a.x = 100;\n-            a.sx = 100;\n-        }\n-    }\n-\n-    void withfield(B b) {\n-            b.a.x = 11;\n-    }\n-\n-    void foo(A a, final A fa) {\n-        a.x = 100;\n-        (a).x = 100;\n-        fa.x = 100;\n-        x = 100;\n-        this.x = 100;\n-        A.this.x = 100;\n-    }\n-}\n-\n-class C {\n-    void foo(A a) {\n-        a.x = 100;\n-        a.sx = 100;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldNegativeTests.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-WithFieldNegativeTests.java:17:14: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:18:14: compiler.err.cant.assign.val.to.final.var: sx\n-WithFieldNegativeTests.java:23:16: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:27:10: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:28:12: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:29:11: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:30:9: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:31:13: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:32:15: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:38:10: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:39:10: compiler.err.cant.assign.val.to.final.var: sx\n-11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldNegativeTests.out","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"}]}