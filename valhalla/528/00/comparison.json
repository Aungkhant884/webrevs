{"files":[{"patch":"@@ -248,0 +248,1 @@\n+     * @param simpleName      the simple name of the record class\n@@ -253,2 +254,3 @@\n-                                            List<MethodHandle> getters,\n-                                            List<String> names) {\n+                                             String simpleName,\n+                                             List<MethodHandle> getters,\n+                                             List<String> names) {\n@@ -266,1 +268,1 @@\n-        sb.append(receiverClass.getSimpleName()).append(\"[\");\n+        sb.append(simpleName).append(\"[\");\n@@ -333,0 +335,2 @@\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(recordClass);\n@@ -334,1 +338,3 @@\n-        if (type instanceof MethodType)\n+        Class<?> receiverType = recordClass.isPrimitiveClass() ? recordClass.asValueType() : recordClass;\n+\n+        if (type instanceof MethodType) {\n@@ -336,1 +342,4 @@\n-        else {\n+            if (((MethodType) type).parameterType(0) != receiverType) {\n+                throw new IllegalArgumentException(\"Bad method type: \" + methodType);\n+            }\n+        } else {\n@@ -342,0 +351,5 @@\n+        for (MethodHandle getter : getterList) {\n+            if (getter.type().parameterType(0) != receiverType) {\n+                throw new IllegalArgumentException(\"Bad receiver type: \" + getter);\n+            }\n+        }\n@@ -344,1 +358,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(boolean.class, recordClass, Object.class)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(boolean.class, receiverType, Object.class)))\n@@ -346,1 +360,1 @@\n-                yield makeEquals(recordClass, getterList);\n+                yield makeEquals(receiverType, getterList);\n@@ -349,1 +363,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(int.class, recordClass)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(int.class, receiverType)))\n@@ -351,1 +365,1 @@\n-                yield makeHashCode(recordClass, getterList);\n+                yield makeHashCode(receiverType, getterList);\n@@ -354,1 +368,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(String.class, recordClass)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(String.class, receiverType)))\n@@ -359,1 +373,1 @@\n-                yield makeToString(recordClass, getterList, nameList);\n+                yield makeToString(receiverType, recordClass.getSimpleName(), getterList, nameList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":25,"deletions":11,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -163,0 +163,7 @@\n+\n+        assertThrows(IAE, () -> ObjectMethods.bootstrap(LOOKUP, \"toString\", methodType(String.class, this.getClass()), C.class, \"x;y\", C.ACCESSORS));\n+        assertThrows(IAE, () -> ObjectMethods.bootstrap(LOOKUP, \"toString\", C.TO_STRING_DESC, C.class, \"x;y\",\n+                     new MethodHandle[]{\n+                            MethodHandles.lookup().findGetter(C.class, \"x\", int.class),\n+                            MethodHandles.lookup().findGetter(this.getClass(), \"y\", int.class),\n+                     }));\n@@ -165,0 +172,3 @@\n+    \/\/ same field name and type as C::y\n+    private int y;\n+\n","filename":"test\/jdk\/java\/lang\/runtime\/ObjectMethodsTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+            { new PrimitiveRecord(40, \"forty\"), new PrimitiveRecord(40, \"forty\"), true},\n@@ -155,0 +156,6 @@\n+    @Test\n+    public void testPrimitiveRecordToString() {\n+        PrimitiveRecord o = new PrimitiveRecord(30, \"thirty\");\n+        assertEquals(o.toString(), \"PrimitiveRecord[i=30, name=thirty]\");\n+    }\n+\n@@ -260,0 +267,2 @@\n+\n+    static primitive record PrimitiveRecord(int i, String name) {}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ObjectMethods::bootstrap call via condy\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @run testng ObjectMethodsViaCondy\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup.ClassOption;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.TypeDescriptor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Type;\n+import org.testng.annotations.Test;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_FINAL;\n+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static jdk.internal.org.objectweb.asm.Opcodes.ALOAD;\n+import static jdk.internal.org.objectweb.asm.Opcodes.ARETURN;\n+import static jdk.internal.org.objectweb.asm.Opcodes.H_GETFIELD;\n+import static jdk.internal.org.objectweb.asm.Opcodes.H_INVOKESTATIC;\n+import static jdk.internal.org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static jdk.internal.org.objectweb.asm.Opcodes.RETURN;\n+import static jdk.internal.org.objectweb.asm.Opcodes.V18;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.assertFalse;\n+\n+public class ObjectMethodsViaCondy {\n+    public static primitive record PrimitiveRecord(int i, String name) {\n+        static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+        static final MethodType EQUALS_DESC = methodType(boolean.class, PrimitiveRecord.class.asValueType(), Object.class);\n+        static final MethodType HASHCODE_DESC = methodType(int.class, PrimitiveRecord.class.asValueType());\n+        static final MethodType TO_STRING_DESC = methodType(String.class, PrimitiveRecord.class.asValueType());\n+\n+        static final Handle[] ACCESSORS = accessors();\n+        static final String NAME_LIST = \"i;name\";\n+        private static Handle[] accessors() {\n+            try {\n+                return  new Handle[]{\n+                        new Handle(H_GETFIELD, Type.getInternalName(PrimitiveRecord.class), \"i\", \"I\", false),\n+                        new Handle(H_GETFIELD, Type.getInternalName(PrimitiveRecord.class), \"name\", String.class.descriptorString(), false)\n+                };\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        \/**\n+         * Returns the method handle for the given method for this PrimitiveRecord class.\n+         * This method defines a hidden class to invoke the ObjectMethods::bootstrap method\n+         * via condy.\n+         *\n+         * @param methodName   the name of the method to generate, which must be one of\n+         *                     {@code \"equals\"}, {@code \"hashCode\"}, or {@code \"toString\"}\n+         *\/\n+        static MethodHandle makeBootstrapMethod(String methodName) throws Throwable {\n+            ClassFileBuilder builder = new ClassFileBuilder(\"Test-\" + methodName);\n+            builder.bootstrapMethod(methodName, TO_STRING_DESC, PrimitiveRecord.class.asValueType(), NAME_LIST, ACCESSORS);\n+            byte[] bytes = builder.build();\n+            MethodHandles.Lookup lookup = LOOKUP.defineHiddenClass(bytes, true, ClassOption.NESTMATE);\n+            MethodType mtype = MethodType.methodType(Object.class);\n+            MethodHandle mh = lookup.findStatic(lookup.lookupClass(), \"bootstrap\", mtype);\n+            return (MethodHandle) mh.invoke();\n+        }\n+    }\n+\n+    @Test\n+    public void testToString() throws Throwable {\n+        MethodHandle handle = PrimitiveRecord.makeBootstrapMethod(\"toString\");\n+        assertEquals((String)handle.invokeExact(new PrimitiveRecord(10, \"ten\")), \"PrimitiveRecord[i=10, name=ten]\");\n+        assertEquals((String)handle.invokeExact(new PrimitiveRecord(40, \"forty\")), \"PrimitiveRecord[i=40, name=forty]\");\n+    }\n+\n+    @Test\n+    public void testToEquals() throws Throwable {\n+        MethodHandle handle = PrimitiveRecord.makeBootstrapMethod(\"equals\");\n+        assertTrue((boolean)handle.invoke(new PrimitiveRecord(10, \"ten\"), new PrimitiveRecord(10, \"ten\")));\n+        assertFalse((boolean)handle.invoke(new PrimitiveRecord(11, \"eleven\"), new PrimitiveRecord(10, \"ten\")));\n+    }\n+\n+    static class ClassFileBuilder {\n+        private static final String OBJECT_CLS = \"java\/lang\/Object\";\n+        private static final String OBJ_METHODS_CLS = \"java\/lang\/runtime\/ObjectMethods\";\n+        private static final String BSM_DESCR =\n+                MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class,\n+                                      TypeDescriptor.class, Class.class, String.class, MethodHandle[].class)\n+                          .descriptorString();\n+        private final ClassWriter cw;\n+        private final String classname;\n+\n+        \/**\n+         * A builder to generate a class file to access class data\n+         *\n+         * @param classname\n+         *\/\n+        ClassFileBuilder(String classname) {\n+            this.classname = classname;\n+            this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n+            cw.visit(V18, ACC_FINAL, classname, null, OBJECT_CLS, null);\n+            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+            mv.visitCode();\n+            mv.visitVarInsn(ALOAD, 0);\n+            mv.visitMethodInsn(INVOKESPECIAL, OBJECT_CLS, \"<init>\", \"()V\", false);\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+        }\n+\n+        byte[] build() {\n+            cw.visitEnd();\n+            byte[] bytes = cw.toByteArray();\n+            Path p = Paths.get(classname + \".class\");\n+            try (OutputStream os = Files.newOutputStream(p)) {\n+                os.write(bytes);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            return bytes;\n+        }\n+\n+        \/*\n+         * Generate the bootstrap method that invokes ObjectMethods::bootstrap via condy\n+         *\/\n+        void bootstrapMethod(String name, TypeDescriptor descriptor, Class<?> recordClass, String names, Handle[] getters) {\n+            MethodType mtype = MethodType.methodType(Object.class);\n+            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC|ACC_STATIC,\n+                    \"bootstrap\", mtype.descriptorString(), null, null);\n+            mv.visitCode();\n+            Handle bsm = new Handle(H_INVOKESTATIC, OBJ_METHODS_CLS, \"bootstrap\",\n+                                    BSM_DESCR, false);\n+            Object[] args = Stream.concat(Stream.of(Type.getType(recordClass), names), Arrays.stream(getters)).toArray();\n+            ConstantDynamic dynamic = new ConstantDynamic(name, MethodHandle.class.descriptorString(), bsm, args);\n+            mv.visitLdcInsn(dynamic);\n+            mv.visitInsn(ARETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethodsViaCondy.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}