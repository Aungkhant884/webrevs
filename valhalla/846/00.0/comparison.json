{"files":[{"patch":"@@ -245,1 +245,2 @@\n-        \"linux-aarch64\", \"linux-arm32\", \"linux-ppc64le\", \"linux-s390x\"\n+        \"linux-aarch64\", \"linux-arm32\", \"linux-ppc64le\", \"linux-s390x\",\n+        \"linux-riscv64\"\n@@ -252,1 +253,1 @@\n-        configure_args: concat(\"--enable-jtreg-failure-handler\",\n+        configure_args: concat(\n@@ -522,0 +523,11 @@\n+\n+        \"linux-riscv64\": {\n+            target_os: \"linux\",\n+            target_cpu: \"riscv64\",\n+            build_cpu: \"x64\",\n+            dependencies: [\"devkit\", \"gtest\", \"build_devkit\"],\n+            configure_args: [\n+                \"--openjdk-target=riscv64-linux-gnu\", \"--with-freetype=bundled\",\n+                \"--disable-warnings-as-errors\"\n+            ],\n+        },\n@@ -717,1 +729,4 @@\n-        }\n+        },\n+        \"linux-riscv64\": {\n+            platform: \"linux-riscv64\",\n+        },\n@@ -801,18 +816,0 @@\n-    \/\/ Define the reference implementation profiles. These are basically the same\n-    \/\/ as the open profiles, but upload artifacts to a different location.\n-    common.main_profile_names.forEach(function (name) {\n-        var riName = name + \"-ri\";\n-        var riDebugName = riName + common.debug_suffix;\n-        var openName = name + common.open_suffix;\n-        var openDebugName = openName + common.debug_suffix;\n-        profiles[riName] = clone(profiles[openName]);\n-        profiles[riDebugName] = clone(profiles[openDebugName]);\n-        \/\/ Rewrite all remote dirs to \"bundles\/openjdk\/BCL\/...\"\n-        for (artifactName in profiles[riName].artifacts) {\n-            var artifact = profiles[riName].artifacts[artifactName];\n-            artifact.remote = replaceAll(\n-                \"\\\/GPL\\\/\", \"\/BCL\/\",\n-                (artifact.remote != null ? artifact.remote : artifact.local));\n-        }\n-    });\n-\n@@ -998,0 +995,14 @@\n+    } else if (input.build_os == \"windows\") {\n+        \/\/ On windows, add the devkit debugger to the path in all the run-test profiles\n+        \/\/ to make them available to the jtreg failure handler.\n+        var archDir = \"x64\";\n+        if (input.build_arch == \"aarch64\") {\n+            archDir = \"arm64\"\n+        }\n+        windowsRunTestExtra = {\n+            environment_path: [\n+                input.get(\"devkit\", \"install_path\") + \"\/10\/Debuggers\/\" + archDir\n+            ]\n+        }\n+        profiles[\"run-test\"] = concatObjects(profiles[\"run-test\"], windowsRunTestExtra);\n+        profiles[\"run-test-prebuilt\"] = concatObjects(profiles[\"run-test-prebuilt\"], windowsRunTestExtra);\n@@ -1039,1 +1050,1 @@\n-        windows_x64: \"VS2022-17.1.0+1.0\",\n+        windows_x64: \"VS2022-17.1.0+1.1\",\n@@ -1043,1 +1054,2 @@\n-        linux_s390x: \"gcc8.2.0-Fedora27+1.0\"\n+        linux_s390x: \"gcc8.2.0-Fedora27+1.0\",\n+        linux_riscv64: \"gcc11.3.0-Fedora_rawhide_68692+1.1\"\n@@ -1223,1 +1235,1 @@\n-            revision: \"1.8.1\"\n+            revision: \"1.13.0+1.0\"\n","filename":"make\/conf\/jib-profiles.js","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1523,0 +1523,12 @@\n+ifeq ($(ASAN_ENABLED), true)\n+  # Any executable which launches the JVM and uses a custom launcher needs to explicitly link in the\n+  # default ASan options.\n+  BUILD_HOTSPOT_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+endif\n+\n+ifeq ($(LSAN_ENABLED), true)\n+  # Any executable which launches the JVM and uses a custom launcher needs to explicitly link in the\n+  # default LSan options.\n+  BUILD_HOTSPOT_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.c\n+endif\n+\n@@ -1538,0 +1550,1 @@\n+      EXTRA_FILES := $(BUILD_HOTSPOT_JTREG_EXTRA_FILES), \\\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2305,0 +2305,6 @@\n+    case Op_ExpandBits:\n+    case Op_CompressBits:\n+      if (!(UseSVE > 1 && VM_Version::supports_svebitperm())) {\n+        ret_value = false;\n+      }\n+      break;\n@@ -11221,1 +11227,0 @@\n-\n@@ -13037,0 +13042,1 @@\n+\n@@ -13108,1 +13114,0 @@\n-\n@@ -13822,0 +13827,317 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_le(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr le\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_ge(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr ge\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct bits_reverse_I(iRegINoSp dst, iRegIorL2I src)\n+%{\n+  match(Set dst (ReverseI src));\n+  ins_cost(INSN_COST);\n+  format %{ \"rbitw  $dst, $src\" %}\n+  ins_encode %{\n+    __ rbitw($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct bits_reverse_L(iRegLNoSp dst, iRegL src)\n+%{\n+  match(Set dst (ReverseL src));\n+  ins_cost(INSN_COST);\n+  format %{ \"rbit  $dst, $src\" %}\n+  ins_encode %{\n+    __ rbit($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n@@ -15849,3 +16171,1 @@\n-instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n+\/\/ Like compI_reg_reg or compI_reg_immI0 but without match rule and second zero parameter.\n@@ -15853,2 +16173,5 @@\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+instruct compI_reg_imm0(rFlagsReg cr, iRegI src)\n+%{\n+  effect(DEF cr, USE src);\n+  ins_cost(INSN_COST);\n+  format %{ \"cmpw $src, 0\" %}\n@@ -15857,4 +16180,1 @@\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::LT);\n+    __ cmpw($src$$Register, 0);\n@@ -15862,2 +16182,1 @@\n-\n-  ins_pipe(icond_reg_reg);\n+  ins_pipe(icmp_reg_imm);\n@@ -15866,1 +16185,1 @@\n-instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct minI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -15876,19 +16195,0 @@\n-\n-%}\n-\/\/ FROM HERE\n-\n-instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n-\n-  ins_encode %{\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::GT);\n-  %}\n-\n-  ins_pipe(icond_reg_reg);\n@@ -15897,1 +16197,1 @@\n-instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct maxI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -15901,0 +16201,1 @@\n+\n@@ -15908,0 +16209,1 @@\n+\n@@ -17148,0 +17450,151 @@\n+\/\/----------------------------- CompressBits\/ExpandBits ------------------------\n+\n+instruct compressBitsI_reg(iRegINoSp dst, iRegIorL2I src, iRegIorL2I mask,\n+                           vRegF tdst, vRegF tsrc, vRegF tmask) %{\n+  match(Set dst (CompressBits src mask));\n+  effect(TEMP tdst, TEMP tsrc, TEMP tmask);\n+  format %{ \"mov    $tsrc, $src\\n\\t\"\n+            \"mov    $tmask, $mask\\n\\t\"\n+            \"bext   $tdst, $tsrc, $tmask\\n\\t\"\n+            \"mov    $dst, $tdst\"\n+          %}\n+  ins_encode %{\n+    __ mov($tsrc$$FloatRegister, __ S, 0, $src$$Register);\n+    __ mov($tmask$$FloatRegister, __ S, 0, $mask$$Register);\n+    __ sve_bext($tdst$$FloatRegister, __ S, $tsrc$$FloatRegister, $tmask$$FloatRegister);\n+    __ mov($dst$$Register, $tdst$$FloatRegister, __ S, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compressBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+                           vRegF tdst, vRegF tsrc, vRegF tmask) %{\n+  match(Set dst (CompressBits (LoadI mem) mask));\n+  effect(TEMP tdst, TEMP tsrc, TEMP tmask);\n+  format %{ \"ldrs   $tsrc, $mem\\n\\t\"\n+            \"ldrs   $tmask, $mask\\n\\t\"\n+            \"bext   $tdst, $tsrc, $tmask\\n\\t\"\n+            \"mov    $dst, $tdst\"\n+          %}\n+  ins_encode %{\n+    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n+              as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n+    __ ldrs($tmask$$FloatRegister, $constantaddress($mask));\n+    __ sve_bext($tdst$$FloatRegister, __ S, $tsrc$$FloatRegister, $tmask$$FloatRegister);\n+    __ mov($dst$$Register, $tdst$$FloatRegister, __ S, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compressBitsL_reg(iRegLNoSp dst, iRegL src, iRegL mask,\n+                           vRegD tdst, vRegD tsrc, vRegD tmask) %{\n+  match(Set dst (CompressBits src mask));\n+  effect(TEMP tdst, TEMP tsrc, TEMP tmask);\n+  format %{ \"mov    $tsrc, $src\\n\\t\"\n+            \"mov    $tmask, $mask\\n\\t\"\n+            \"bext   $tdst, $tsrc, $tmask\\n\\t\"\n+            \"mov    $dst, $tdst\"\n+          %}\n+  ins_encode %{\n+    __ mov($tsrc$$FloatRegister, __ D, 0, $src$$Register);\n+    __ mov($tmask$$FloatRegister, __ D, 0, $mask$$Register);\n+    __ sve_bext($tdst$$FloatRegister, __ D, $tsrc$$FloatRegister, $tmask$$FloatRegister);\n+    __ mov($dst$$Register, $tdst$$FloatRegister, __ D, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compressBitsL_memcon(iRegLNoSp dst, memory8 mem, immL mask,\n+                           vRegF tdst, vRegF tsrc, vRegF tmask) %{\n+  match(Set dst (CompressBits (LoadL mem) mask));\n+  effect(TEMP tdst, TEMP tsrc, TEMP tmask);\n+  format %{ \"ldrd   $tsrc, $mem\\n\\t\"\n+            \"ldrd   $tmask, $mask\\n\\t\"\n+            \"bext   $tdst, $tsrc, $tmask\\n\\t\"\n+            \"mov    $dst, $tdst\"\n+          %}\n+  ins_encode %{\n+    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n+              as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);\n+    __ ldrd($tmask$$FloatRegister, $constantaddress($mask));\n+    __ sve_bext($tdst$$FloatRegister, __ D, $tsrc$$FloatRegister, $tmask$$FloatRegister);\n+    __ mov($dst$$Register, $tdst$$FloatRegister, __ D, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct expandBitsI_reg(iRegINoSp dst, iRegIorL2I src, iRegIorL2I mask,\n+                         vRegF tdst, vRegF tsrc, vRegF tmask) %{\n+  match(Set dst (ExpandBits src mask));\n+  effect(TEMP tdst, TEMP tsrc, TEMP tmask);\n+  format %{ \"mov    $tsrc, $src\\n\\t\"\n+            \"mov    $tmask, $mask\\n\\t\"\n+            \"bdep   $tdst, $tsrc, $tmask\\n\\t\"\n+            \"mov    $dst, $tdst\"\n+          %}\n+  ins_encode %{\n+    __ mov($tsrc$$FloatRegister, __ S, 0, $src$$Register);\n+    __ mov($tmask$$FloatRegister, __ S, 0, $mask$$Register);\n+    __ sve_bdep($tdst$$FloatRegister, __ S, $tsrc$$FloatRegister, $tmask$$FloatRegister);\n+    __ mov($dst$$Register, $tdst$$FloatRegister, __ S, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct expandBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+                         vRegF tdst, vRegF tsrc, vRegF tmask) %{\n+  match(Set dst (ExpandBits (LoadI mem) mask));\n+  effect(TEMP tdst, TEMP tsrc, TEMP tmask);\n+  format %{ \"ldrs   $tsrc, $mem\\n\\t\"\n+            \"ldrs   $tmask, $mask\\n\\t\"\n+            \"bdep   $tdst, $tsrc, $tmask\\n\\t\"\n+            \"mov    $dst, $tdst\"\n+          %}\n+  ins_encode %{\n+    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n+              as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n+    __ ldrs($tmask$$FloatRegister, $constantaddress($mask));\n+    __ sve_bdep($tdst$$FloatRegister, __ S, $tsrc$$FloatRegister, $tmask$$FloatRegister);\n+    __ mov($dst$$Register, $tdst$$FloatRegister, __ S, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct expandBitsL_reg(iRegLNoSp dst, iRegL src, iRegL mask,\n+                         vRegD tdst, vRegD tsrc, vRegD tmask) %{\n+  match(Set dst (ExpandBits src mask));\n+  effect(TEMP tdst, TEMP tsrc, TEMP tmask);\n+  format %{ \"mov    $tsrc, $src\\n\\t\"\n+            \"mov    $tmask, $mask\\n\\t\"\n+            \"bdep   $tdst, $tsrc, $tmask\\n\\t\"\n+            \"mov    $dst, $tdst\"\n+          %}\n+  ins_encode %{\n+    __ mov($tsrc$$FloatRegister, __ D, 0, $src$$Register);\n+    __ mov($tmask$$FloatRegister, __ D, 0, $mask$$Register);\n+    __ sve_bdep($tdst$$FloatRegister, __ D, $tsrc$$FloatRegister, $tmask$$FloatRegister);\n+    __ mov($dst$$Register, $tdst$$FloatRegister, __ D, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct expandBitsL_memcon(iRegINoSp dst, memory8 mem, immL mask,\n+                         vRegF tdst, vRegF tsrc, vRegF tmask) %{\n+  match(Set dst (ExpandBits (LoadL mem) mask));\n+  effect(TEMP tdst, TEMP tsrc, TEMP tmask);\n+  format %{ \"ldrd   $tsrc, $mem\\n\\t\"\n+            \"ldrd   $tmask, $mask\\n\\t\"\n+            \"bdep   $tdst, $tsrc, $tmask\\n\\t\"\n+            \"mov    $dst, $tdst\"\n+          %}\n+  ins_encode %{\n+    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n+              as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);\n+    __ ldrd($tmask$$FloatRegister, $constantaddress($mask));\n+    __ sve_bdep($tdst$$FloatRegister, __ D, $tsrc$$FloatRegister, $tmask$$FloatRegister);\n+    __ mov($dst$$Register, $tdst$$FloatRegister, __ D, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":487,"deletions":34,"binary":false,"changes":521,"status":"modified"},{"patch":"@@ -3437,1 +3437,2 @@\n-      assert_different_registers(obj, addr.base(), tmp, rscratch1, dst);\n+      assert_different_registers(obj, addr.base(), tmp, rscratch1);\n+      assert_different_registers(dst, addr.base(), tmp, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  ands(hdr, hdr, aligned_mask - os::vm_page_size());\n+  ands(hdr, hdr, aligned_mask - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,4 +71,0 @@\n-int C2_MacroAssembler::entry_barrier_stub_size() {\n-  return 4 * 6;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-  void emit_entry_barrier_stub(C2EntryBarrierStub* stub);\n-  static int entry_barrier_stub_size();\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -320,0 +320,8 @@\n+\/\/ locals\n+\n+void frame::interpreter_frame_set_locals(intptr_t* locs)  {\n+  assert(is_interpreted_frame(), \"interpreted frame expected\");\n+  \/\/ set relativized locals\n+  ptr_at_put(interpreter_frame_locals_offset, (intptr_t) (locs - fp()));\n+}\n+\n@@ -321,0 +329,1 @@\n+\n@@ -532,1 +541,1 @@\n-  address locals =  (address) *interpreter_frame_locals_addr();\n+  address locals =  (address)interpreter_frame_locals();\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,2 +263,3 @@\n-inline intptr_t** frame::interpreter_frame_locals_addr() const {\n-  return (intptr_t**)addr_at(interpreter_frame_locals_offset);\n+inline intptr_t* frame::interpreter_frame_locals() const {\n+  intptr_t n = *addr_at(interpreter_frame_locals_offset);\n+  return &fp()[n]; \/\/ return relativized locals\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,2 +155,2 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1);\n-  __ andr(obj, obj, ~JNIHandles::weak_tag_mask);\n+  STATIC_ASSERT(JNIHandles::tag_mask == 0b11);\n+  __ andr(obj, obj, ~JNIHandles::tag_mask);\n@@ -331,0 +331,16 @@\n+\n+void BarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if the oop is in the right area of memory\n+  __ mov(tmp2, (intptr_t) Universe::verify_oop_mask());\n+  __ andr(tmp1, obj, tmp2);\n+  __ mov(tmp2, (intptr_t) Universe::verify_oop_bits());\n+\n+  \/\/ Compare tmp1 and tmp2.  We don't use a compare\n+  \/\/ instruction here because the flags register is live.\n+  __ eor(tmp1, tmp1, tmp2);\n+  __ cbnz(tmp1, error);\n+\n+  \/\/ make sure klass is 'reasonable', which is not zero.\n+  __ load_klass(obj, obj); \/\/ get klass\n+  __ cbz(obj, error);      \/\/ if klass is NULL it is broken\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+  virtual void check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -910,1 +910,1 @@\n-    ands(swap_reg, swap_reg, (uint64_t)(7 - os::vm_page_size()));\n+    ands(swap_reg, swap_reg, (uint64_t)(7 - (int)os::vm_page_size()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,1 @@\n+    lea(rlocals, Address(rfp, rlocals, Address::lsl(3)));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -932,2 +932,1 @@\n-  address stub = start_a_stub(NativeInstruction::instruction_size\n-                   + NativeCallTrampolineStub::instruction_size);\n+  address stub = start_a_stub(max_trampoline_stub_size());\n@@ -965,0 +964,5 @@\n+int MacroAssembler::max_trampoline_stub_size() {\n+  \/\/ Max stub size: alignment nop, TrampolineStub.\n+  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+}\n+\n@@ -977,0 +981,5 @@\n+int MacroAssembler::static_call_stub_size() {\n+  \/\/ isb; movk; movz; movz; movk; movz; movz; br\n+  return 8 * NativeInstruction::instruction_size;\n+}\n+\n@@ -1107,0 +1116,1 @@\n+  InlineSkippedInstructionsCounter skipCounter(this);\n@@ -1729,2 +1739,2 @@\n-  ldrw(temp_reg, Address(klass, InstanceKlass::misc_status_offset()));\n-  andr(temp_reg, temp_reg, InstanceKlassMiscStatus::is_empty_inline_type_value());\n+  ldrw(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n+  andr(temp_reg, temp_reg, InstanceKlassFlags::is_empty_inline_type_value());\n@@ -2623,1 +2633,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -2625,0 +2637,7 @@\n+  tst(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  br(Assembler::NE, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  b(done);\n@@ -2626,2 +2645,3 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);\n-  tbz(value, 0, not_weak);    \/\/ Test for jweak tag.\n+  bind(tagged);\n+  STATIC_ASSERT(JNIHandles::TypeTag::weak_global == 0b1);\n+  tbnz(value, 0, weak_tagged);    \/\/ Test for weak tag.\n@@ -2629,3 +2649,2 @@\n-  \/\/ Resolve jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,\n-                 Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n@@ -2635,3 +2654,4 @@\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(weak_tagged);\n+  \/\/ Resolve jweak.\n+  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp1, tmp2);\n@@ -2639,0 +2659,24 @@\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    STATIC_ASSERT(JNIHandles::TypeTag::global == 0b10);\n+    Label valid_global_tag;\n+    tbnz(value, 1, valid_global_tag); \/\/ Test for global tag\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n+  verify_oop(value);\n+\n@@ -4861,1 +4905,1 @@\n-  mov(rscratch1, os::vm_page_size());\n+  mov(rscratch1, (int)os::vm_page_size());\n@@ -4863,1 +4907,1 @@\n-  lea(tmp, Address(tmp, -os::vm_page_size()));\n+  lea(tmp, Address(tmp, -(int)os::vm_page_size()));\n@@ -4874,1 +4918,1 @@\n-  for (int i = 0; i < (int)(StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size()) - 1; i++) {\n+  for (int i = 0; i < (int)(StackOverflow::stack_shadow_zone_size() \/ (int)os::vm_page_size()) - 1; i++) {\n@@ -4877,1 +4921,1 @@\n-    lea(tmp, Address(tmp, -os::vm_page_size()));\n+    lea(tmp, Address(tmp, -(int)os::vm_page_size()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":62,"deletions":18,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -589,0 +589,8 @@\n+  inline void get_nzcv(Register reg) {\n+    mrs(0b011, 0b0100, 0b0010, 0b000, reg);\n+  }\n+\n+  inline void set_nzcv(Register reg) {\n+    msr(0b011, 0b0100, 0b0010, 0b000, reg);\n+  }\n+\n@@ -669,0 +677,1 @@\n+  static int max_trampoline_stub_size();\n@@ -670,0 +679,1 @@\n+  static int static_call_stub_size();\n@@ -862,0 +872,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1523,0 +1523,9 @@\n+    \/\/ handle pending exception thrown by freeze\n+    __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+    Label ok;\n+    __ cbz(rscratch1, ok);\n+    __ leave();\n+    __ lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    __ br(rscratch1);\n+    __ bind(ok);\n+\n@@ -2087,1 +2096,1 @@\n-      __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());\n+      __ ands(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -589,23 +589,2 @@\n-#if INCLUDE_ZGC\n-    if (UseZGC) {\n-      \/\/ Check if mask is good.\n-      \/\/ verifies that ZAddressBadMask & r0 == 0\n-      __ ldr(c_rarg3, Address(rthread, ZThreadLocalData::address_bad_mask_offset()));\n-      __ andr(c_rarg2, r0, c_rarg3);\n-      __ cbnz(c_rarg2, error);\n-    }\n-#endif\n-\n-    \/\/ Check if the oop is in the right area of memory\n-    __ mov(c_rarg3, (intptr_t) Universe::verify_oop_mask());\n-    __ andr(c_rarg2, r0, c_rarg3);\n-    __ mov(c_rarg3, (intptr_t) Universe::verify_oop_bits());\n-\n-    \/\/ Compare c_rarg2 and c_rarg3.  We don't use a compare\n-    \/\/ instruction here because the flags register is live.\n-    __ eor(c_rarg2, c_rarg2, c_rarg3);\n-    __ cbnz(c_rarg2, error);\n-\n-    \/\/ make sure klass is 'reasonable', which is not zero.\n-    __ load_klass(r0, r0);  \/\/ get klass\n-    __ cbz(r0, error);      \/\/ if klass is NULL it is broken\n+    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs_asm->check_oop(_masm, r0, c_rarg2, c_rarg3, error);\n@@ -6952,6 +6931,1 @@\n-    Label null_jobject;\n-    __ cbz(r0, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, r0, Address(r0, 0), rscratch1, rscratch2);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -6972,1 +6946,1 @@\n-    int insts_size = 512;\n+    int insts_size = 1024;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":30,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -665,1 +665,1 @@\n-  const int page_size = os::vm_page_size();\n+  const size_t page_size = os::vm_page_size();\n@@ -821,5 +821,0 @@\n-  __ ldr(rcpool, Address(rmethod, Method::const_offset()));\n-  __ ldr(rcpool, Address(rcpool, ConstMethod::constants_offset()));\n-  __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset_in_bytes()));\n-  __ stp(rlocals, rcpool, Address(sp, 2 * wordSize));\n-\n@@ -830,0 +825,8 @@\n+  __ ldr(rcpool, Address(rmethod, Method::const_offset()));\n+  __ ldr(rcpool, Address(rcpool, ConstMethod::constants_offset()));\n+  __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset_in_bytes()));\n+  __ sub(rscratch1, rlocals, rfp);\n+  __ lsr(rscratch1, rscratch1, Interpreter::logStackElementSize);   \/\/ rscratch1 = rlocals - fp();\n+  \/\/ Store relativized rlocals, see frame::interpreter_frame_locals().\n+  __ stp(rscratch1, rcpool, Address(sp, 2 * wordSize));\n+\n@@ -1070,1 +1073,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -734,1 +734,4 @@\n-            __ verify_oop(from_reg->as_register(), FILE_AND_LINE);\n+            if (VerifyOops) {\n+              BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+              bs->check_oop(_masm, from_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+            }\n@@ -775,1 +778,4 @@\n-          __ verify_oop(from_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+          if (VerifyOops) {\n+            BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+            bs->check_oop(_masm, from_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+          }\n@@ -816,1 +822,4 @@\n-          __ verify_oop(to_reg->as_register(), FILE_AND_LINE);\n+          if (VerifyOops) {\n+            BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+            bs->check_oop(_masm, to_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+          }\n@@ -847,1 +856,4 @@\n-        __ verify_oop(to_reg->as_register(), FILE_AND_LINE);\n+        if (VerifyOops) {\n+          BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+          bs->check_oop(_masm, to_reg->as_register(), FILE_AND_LINE); \/\/ kills R0\n+        }\n@@ -3022,2 +3034,7 @@\n-      const Register Robj = data->as_register();\n-      assert_different_registers(Rptr, Rold, Robj);\n+      Register Robj = data->as_register();\n+      assert_different_registers(Rptr, Rold, Rtmp);\n+      assert_different_registers(Rptr, Robj, Rtmp);\n+      if (Robj == Rold) { \/\/ May happen with ZGC.\n+        __ mr(Rtmp, Robj);\n+        Robj = Rtmp;\n+      }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2173,1 +2173,1 @@\n-  ld(scratch, 0, R1_SP);\n+  ld_ptr(scratch, _abi0(callers_sp), R1_SP);   \/\/ Load frame pointer.\n@@ -2192,0 +2192,2 @@\n+    sldi(R18_locals, R18_locals, Interpreter::logStackElementSize);\n+    add(R18_locals, R18_locals, scratch);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  andptr(hdr, aligned_mask - os::vm_page_size());\n+  andptr(hdr, aligned_mask - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -586,0 +586,1 @@\n+    assert(cx1Reg == noreg, \"\");\n@@ -608,1 +609,1 @@\n-    load_klass(tmpReg, objReg, cx1Reg);\n+    load_klass(tmpReg, objReg, scrReg);\n@@ -644,1 +645,1 @@\n-    andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );\n+    andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - (int)os::vm_page_size())) );\n@@ -2815,2 +2816,2 @@\n-      andl(result, (os::vm_page_size()-1));\n-      cmpl(result, (os::vm_page_size()-16));\n+      andl(result, ((int)os::vm_page_size()-1));\n+      cmpl(result, ((int)os::vm_page_size()-16));\n@@ -2845,2 +2846,2 @@\n-    andl(result, (os::vm_page_size()-1));\n-    cmpl(result, (os::vm_page_size()-16));\n+    andl(result, ((int)os::vm_page_size()-1));\n+    cmpl(result, ((int)os::vm_page_size()-16));\n@@ -3234,0 +3235,189 @@\n+int C2_MacroAssembler::arrays_hashcode_elsize(BasicType eltype) {\n+  switch (eltype) {\n+  case T_BOOLEAN: return sizeof(jboolean);\n+  case T_BYTE:  return sizeof(jbyte);\n+  case T_SHORT: return sizeof(jshort);\n+  case T_CHAR:  return sizeof(jchar);\n+  case T_INT:   return sizeof(jint);\n+  default:\n+    ShouldNotReachHere();\n+    return -1;\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elload(Register dst, Address src, BasicType eltype) {\n+  switch (eltype) {\n+  \/\/ T_BOOLEAN used as surrogate for unsigned byte\n+  case T_BOOLEAN: movzbl(dst, src);   break;\n+  case T_BYTE:    movsbl(dst, src);   break;\n+  case T_SHORT:   movswl(dst, src);   break;\n+  case T_CHAR:    movzwl(dst, src);   break;\n+  case T_INT:     movl(dst, src);     break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype) {\n+  const int vlen = Assembler::AVX_256bit;\n+  switch (eltype) {\n+  case T_BOOLEAN: vector_unsigned_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_BYTE:      vector_signed_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_SHORT:     vector_signed_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_CHAR:    vector_unsigned_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_INT:\n+    \/\/ do nothing\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode(Register ary1, Register cnt1, Register result,\n+                                        Register index, Register tmp2, Register tmp3, XMMRegister vnext,\n+                                        XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                                        XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                                        XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                                        BasicType eltype) {\n+  ShortBranchVerifier sbv(this);\n+  assert(UseAVX >= 2, \"AVX2 intrinsics are required\");\n+  assert_different_registers(ary1, cnt1, result, index, tmp2, tmp3);\n+  assert_different_registers(vnext, vcoef0, vcoef1, vcoef2, vcoef3, vresult0, vresult1, vresult2, vresult3, vtmp0, vtmp1, vtmp2, vtmp3);\n+\n+  Label SHORT_UNROLLED_BEGIN, SHORT_UNROLLED_LOOP_BEGIN,\n+        SHORT_UNROLLED_LOOP_EXIT,\n+        UNROLLED_SCALAR_LOOP_BEGIN, UNROLLED_SCALAR_SKIP, UNROLLED_SCALAR_RESUME,\n+        UNROLLED_VECTOR_LOOP_BEGIN,\n+        END;\n+  switch (eltype) {\n+  case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode(unsigned byte) {\"); break;\n+  case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode(char) {\");          break;\n+  case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode(byte) {\");          break;\n+  case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode(short) {\");         break;\n+  case T_INT:     BLOCK_COMMENT(\"arrays_hashcode(int) {\");           break;\n+  default:        BLOCK_COMMENT(\"arrays_hashcode {\");                break;\n+  }\n+\n+  \/\/ For \"renaming\" for readibility of the code\n+  XMMRegister vcoef[] = { vcoef0, vcoef1, vcoef2, vcoef3 },\n+              vresult[] = { vresult0, vresult1, vresult2, vresult3 },\n+              vtmp[] = { vtmp0, vtmp1, vtmp2, vtmp3 };\n+\n+  const int elsize = arrays_hashcode_elsize(eltype);\n+\n+  \/*\n+    if (cnt1 >= 2) {\n+      if (cnt1 >= 32) {\n+        UNROLLED VECTOR LOOP\n+      }\n+      UNROLLED SCALAR LOOP\n+    }\n+    SINGLE SCALAR\n+   *\/\n+\n+  cmpl(cnt1, 32);\n+  jcc(Assembler::less, SHORT_UNROLLED_BEGIN);\n+\n+  \/\/ cnt1 >= 32 && generate_vectorized_loop\n+  xorl(index, index);\n+\n+  \/\/ vresult = IntVector.zero(I256);\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpxor(vresult[idx], vresult[idx]);\n+  }\n+  \/\/ vnext = IntVector.broadcast(I256, power_of_31_backwards[0]);\n+  Register bound = tmp2;\n+  Register next = tmp3;\n+  lea(tmp2, ExternalAddress(StubRoutines::x86::arrays_hashcode_powers_of_31() + (0 * sizeof(jint))));\n+  movl(next, Address(tmp2, 0));\n+  movdl(vnext, next);\n+  vpbroadcastd(vnext, vnext, Assembler::AVX_256bit);\n+\n+  \/\/ index = 0;\n+  \/\/ bound = cnt1 & ~(32 - 1);\n+  movl(bound, cnt1);\n+  andl(bound, ~(32 - 1));\n+  \/\/ for (; index < bound; index += 32) {\n+  bind(UNROLLED_VECTOR_LOOP_BEGIN);\n+  \/\/ result *= next;\n+  imull(result, next);\n+  \/\/ loop fission to upfront the cost of fetching from memory, OOO execution\n+  \/\/ can then hopefully do a better job of prefetching\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvload(vtmp[idx], Address(ary1, index, Address::times(elsize), 8 * idx * elsize), eltype);\n+  }\n+  \/\/ vresult = vresult * vnext + ary1[index+8*idx:index+8*idx+7];\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpmulld(vresult[idx], vresult[idx], vnext, Assembler::AVX_256bit);\n+    arrays_hashcode_elvcast(vtmp[idx], eltype);\n+    vpaddd(vresult[idx], vresult[idx], vtmp[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ index += 32;\n+  addl(index, 32);\n+  \/\/ index < bound;\n+  cmpl(index, bound);\n+  jcc(Assembler::less, UNROLLED_VECTOR_LOOP_BEGIN);\n+  \/\/ }\n+\n+  lea(ary1, Address(ary1, bound, Address::times(elsize)));\n+  subl(cnt1, bound);\n+  \/\/ release bound\n+\n+  \/\/ vresult *= IntVector.fromArray(I256, power_of_31_backwards, 1);\n+  for (int idx = 0; idx < 4; idx++) {\n+    lea(tmp2, ExternalAddress(StubRoutines::x86::arrays_hashcode_powers_of_31() + ((8 * idx + 1) * sizeof(jint))));\n+    arrays_hashcode_elvload(vcoef[idx], Address(tmp2, 0), T_INT);\n+    vpmulld(vresult[idx], vresult[idx], vcoef[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ result += vresult.reduceLanes(ADD);\n+  for (int idx = 0; idx < 4; idx++) {\n+    reduceI(Op_AddReductionVI, 256\/(sizeof(jint) * 8), result, result, vresult[idx], vtmp[(idx * 2 + 0) % 4], vtmp[(idx * 2 + 1) % 4]);\n+  }\n+\n+  \/\/ } else if (cnt1 < 32) {\n+\n+  bind(SHORT_UNROLLED_BEGIN);\n+  \/\/ int i = 1;\n+  movl(index, 1);\n+  cmpl(index, cnt1);\n+  jcc(Assembler::greaterEqual, SHORT_UNROLLED_LOOP_EXIT);\n+\n+  \/\/ for (; i < cnt1 ; i += 2) {\n+  bind(SHORT_UNROLLED_LOOP_BEGIN);\n+  movl(tmp3, 961);\n+  imull(result, tmp3);\n+  arrays_hashcode_elload(tmp2, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n+  movl(tmp3, tmp2);\n+  shll(tmp3, 5);\n+  subl(tmp3, tmp2);\n+  addl(result, tmp3);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize)), eltype);\n+  addl(result, tmp3);\n+  addl(index, 2);\n+  cmpl(index, cnt1);\n+  jccb(Assembler::less, SHORT_UNROLLED_LOOP_BEGIN);\n+\n+  \/\/ }\n+  \/\/ if (i >= cnt1) {\n+  bind(SHORT_UNROLLED_LOOP_EXIT);\n+  jccb(Assembler::greater, END);\n+  movl(tmp2, result);\n+  shll(result, 5);\n+  subl(result, tmp2);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n+  addl(result, tmp3);\n+  \/\/ }\n+  bind(END);\n+\n+  BLOCK_COMMENT(\"} \/\/ arrays_hashcode\");\n+\n+} \/\/ arrays_hashcode\n+\n@@ -4716,0 +4906,27 @@\n+void C2_MacroAssembler::vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                                           BasicType from_elem_bt, BasicType to_elem_bt) {\n+  switch (from_elem_bt) {\n+    case T_BYTE:\n+      switch (to_elem_bt) {\n+        case T_SHORT: vpmovsxbw(dst, src, vlen_enc); break;\n+        case T_INT:   vpmovsxbd(dst, src, vlen_enc); break;\n+        case T_LONG:  vpmovsxbq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_SHORT:\n+      switch (to_elem_bt) {\n+        case T_INT:  vpmovsxwd(dst, src, vlen_enc); break;\n+        case T_LONG: vpmovsxwq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_INT:\n+      assert(to_elem_bt == T_LONG, \"\");\n+      vpmovsxdq(dst, src, vlen_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":224,"deletions":7,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,0 @@\n-  void emit_entry_barrier_stub(C2EntryBarrierStub* stub);\n-  static int entry_barrier_stub_size();\n-\n@@ -296,0 +293,13 @@\n+  void arrays_hashcode(Register str1, Register cnt1, Register result,\n+                       Register tmp1, Register tmp2, Register tmp3, XMMRegister vnext,\n+                       XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                       XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                       XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                       BasicType eltype);\n+\n+  \/\/ helper functions for arrays_hashcode\n+  int arrays_hashcode_elsize(BasicType eltype);\n+  void arrays_hashcode_elload(Register dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype);\n+  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype);\n@@ -313,0 +323,3 @@\n+\n+  void vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                          BasicType from_elem_bt, BasicType to_elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,0 +314,8 @@\n+\/\/ locals\n+\n+void frame::interpreter_frame_set_locals(intptr_t* locs)  {\n+  assert(is_interpreted_frame(), \"interpreted frame expected\");\n+  \/\/ set relativized locals\n+  ptr_at_put(interpreter_frame_locals_offset, (intptr_t) (locs - fp()));\n+}\n+\n@@ -518,1 +526,1 @@\n-  address locals =  (address) *interpreter_frame_locals_addr();\n+  address locals =  (address)interpreter_frame_locals();\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+\/\/    [klass of method       ]                   = mirror()             mirror_offset\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,2 +251,3 @@\n-inline intptr_t** frame::interpreter_frame_locals_addr() const {\n-  return (intptr_t**)addr_at(interpreter_frame_locals_offset);\n+inline intptr_t* frame::interpreter_frame_locals() const {\n+  intptr_t n = *addr_at(interpreter_frame_locals_offset);\n+  return &fp()[n]; \/\/ return relativized locals\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,1 @@\n-  __ clear_jweak_tag(obj);\n+  __ clear_jobject_tag(obj);\n@@ -386,0 +386,15 @@\n+\n+void BarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if the oop is in the right area of memory\n+  __ movptr(tmp1, obj);\n+  __ movptr(tmp2, (intptr_t) Universe::verify_oop_mask());\n+  __ andptr(tmp1, tmp2);\n+  __ movptr(tmp2, (intptr_t) Universe::verify_oop_bits());\n+  __ cmpptr(tmp1, tmp2);\n+  __ jcc(Assembler::notZero, error);\n+\n+  \/\/ make sure klass is 'reasonable', which is not zero.\n+  __ load_klass(obj, obj, tmp1);  \/\/ get klass\n+  __ testptr(obj, obj);\n+  __ jcc(Assembler::zero, error); \/\/ if klass is NULL it is broken\n+}\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+\n+  virtual void check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"gc\/z\/zThreadLocalData.hpp\"\n@@ -701,0 +702,2 @@\n+#endif \/\/ COMPILER2\n+\n@@ -702,0 +705,1 @@\n+#define __ masm->\n@@ -703,1 +707,8 @@\n-#endif \/\/ COMPILER2\n+void ZBarrierSetAssembler::check_oop(MacroAssembler* masm, Register obj, Register tmp1, Register tmp2, Label& error) {\n+  \/\/ Check if metadata bits indicate a bad oop\n+  __ testptr(obj, Address(r15_thread, ZThreadLocalData::address_bad_mask_offset()));\n+  __ jcc(Assembler::notZero, error);\n+  BarrierSetAssembler::check_oop(masm, obj, tmp1, tmp2, error);\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1426,1 +1426,1 @@\n-    andptr(swap_reg, zero_bits - os::vm_page_size());\n+    andptr(swap_reg, zero_bits - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+    lea(_locals_register, Address(rbp, _locals_register, Address::times_ptr));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-#define BUFFER_SIZE 30*wordSize\n+#define BUFFER_SIZE 40*wordSize\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1282,3 +1282,3 @@\n-  movl(Address(tmp, (-os::vm_page_size())), size );\n-  subptr(tmp, os::vm_page_size());\n-  subl(size, os::vm_page_size());\n+  movl(Address(tmp, (-(int)os::vm_page_size())), size );\n+  subptr(tmp, (int)os::vm_page_size());\n+  subl(size, (int)os::vm_page_size());\n@@ -1293,1 +1293,1 @@\n-  for (int i = 1; i < ((int)StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size()); i++) {\n+  for (int i = 1; i < ((int)StackOverflow::stack_shadow_zone_size() \/ (int)os::vm_page_size()); i++) {\n@@ -1296,1 +1296,1 @@\n-    movptr(Address(tmp, (-i*os::vm_page_size())), size );\n+    movptr(Address(tmp, (-i*(int)os::vm_page_size())), size );\n@@ -2048,0 +2048,1 @@\n+  InlineSkippedInstructionsCounter skipCounter(this);\n@@ -2910,2 +2911,2 @@\n-  movl(temp_reg, Address(klass, InstanceKlass::misc_status_offset()));\n-  testl(temp_reg, InstanceKlassMiscStatus::is_empty_inline_type_value());\n+  movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n+  testl(temp_reg, InstanceKlassFlags::is_empty_inline_type_value());\n@@ -4026,3 +4027,3 @@\n-void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {\n-  const int32_t inverted_jweak_mask = ~static_cast<int32_t>(JNIHandles::weak_tag_mask);\n-  STATIC_ASSERT(inverted_jweak_mask == -2); \/\/ otherwise check this code\n+void MacroAssembler::clear_jobject_tag(Register possibly_non_local) {\n+  const int32_t inverted_mask = ~static_cast<int32_t>(JNIHandles::tag_mask);\n+  STATIC_ASSERT(inverted_mask == -4); \/\/ otherwise check this code\n@@ -4030,1 +4031,1 @@\n-  andptr(possibly_jweak, inverted_jweak_mask);\n+  andptr(possibly_non_local, inverted_mask);\n@@ -4037,1 +4038,1 @@\n-  Label done, not_weak;\n+  Label done, tagged, weak_tagged;\n@@ -4039,3 +4040,19 @@\n-  jcc(Assembler::zero, done);                \/\/ Use NULL as-is.\n-  testptr(value, JNIHandles::weak_tag_mask); \/\/ Test for jweak tag.\n-  jcc(Assembler::zero, not_weak);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  testptr(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  jcc(Assembler::notZero, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(tagged);\n+  testptr(value, JNIHandles::TypeTag::weak_global); \/\/ Test for weak tag.\n+  jcc(Assembler::notZero, weak_tagged);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(weak_tagged);\n@@ -4044,1 +4061,1 @@\n-                 value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp, thread);\n@@ -4046,4 +4063,25 @@\n-  jmp(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value,\n+                                            Register thread,\n+                                            Register tmp) {\n+  assert_different_registers(value, thread, tmp);\n+  Label done;\n+\n+  testptr(value, value);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    testptr(value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    jcc(Assembler::notZero, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n@@ -4051,0 +4089,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":59,"deletions":20,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -363,1 +363,1 @@\n-  void clear_jweak_tag(Register possibly_jweak);\n+  void clear_jobject_tag(Register possibly_non_local);\n@@ -365,0 +365,1 @@\n+  void resolve_global_jobject(Register value, Register thread, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1723,1 +1723,1 @@\n-      __ andptr(swap_reg, 3 - os::vm_page_size());\n+      __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1869,0 +1869,9 @@\n+\n+  \/\/ handle pending exception thrown by freeze\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  Label ok;\n+  __ jcc(Assembler::equal, ok);\n+  __ leave();\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+  __ bind(ok);\n+\n@@ -2450,1 +2459,1 @@\n-      __ andptr(swap_reg, 3 - os::vm_page_size());\n+      __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1114,20 +1114,2 @@\n-#if INCLUDE_ZGC\n-  if (UseZGC) {\n-    \/\/ Check if metadata bits indicate a bad oop\n-    __ testptr(rax, Address(r15_thread, ZThreadLocalData::address_bad_mask_offset()));\n-    __ jcc(Assembler::notZero, error);\n-  }\n-#endif\n-\n-  \/\/ Check if the oop is in the right area of memory\n-  __ movptr(c_rarg2, rax);\n-  __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_mask());\n-  __ andptr(c_rarg2, c_rarg3);\n-  __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_bits());\n-  __ cmpptr(c_rarg2, c_rarg3);\n-  __ jcc(Assembler::notZero, error);\n-\n-  \/\/ make sure klass is 'reasonable', which is not zero.\n-  __ load_klass(rax, rax, rscratch1);  \/\/ get klass\n-  __ testptr(rax, rax);\n-  __ jcc(Assembler::zero, error); \/\/ if klass is NULL it is broken\n+   BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+   bs_asm->check_oop(_masm, rax, c_rarg2, c_rarg3, error);\n@@ -1681,1 +1663,0 @@\n-  __ cmpl(length, 0);\n@@ -1724,2 +1705,1 @@\n-  if (VM_Version::supports_avx2()\n-      && VM_Version::supports_avx512vlbw()) {\n+  if (VM_Version::supports_avx2()) {\n@@ -1742,0 +1722,1 @@\n+    __ movdl(xmm8, rax);\n@@ -1743,1 +1724,1 @@\n-    __ evpbroadcastd(xmm8, rax, Assembler::AVX_256bit);\n+    __ vpbroadcastd(xmm8, xmm8, Assembler::AVX_256bit);\n@@ -1750,1 +1731,2 @@\n-    __ evpbroadcastd(xmm7, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm7, rax);\n+    __ vpbroadcastd(xmm7, xmm7, Assembler::AVX_256bit);\n@@ -1852,1 +1834,2 @@\n-    __ evpbroadcastd(xmm6, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm6, rax);\n+    __ vpbroadcastd(xmm6, xmm6, Assembler::AVX_256bit);\n@@ -1855,1 +1838,2 @@\n-    __ evpbroadcastd(xmm5, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm5, rax);\n+    __ vpbroadcastd(xmm5, xmm5, Assembler::AVX_256bit);\n@@ -1862,1 +1846,2 @@\n-    __ evpbroadcastd(xmm3, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm3, rax);\n+    __ vpbroadcastd(xmm3, xmm3, Assembler::AVX_256bit);\n@@ -1864,1 +1849,2 @@\n-    __ evpbroadcastd(xmm4, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm4, rax);\n+    __ vpbroadcastd(xmm4, xmm4, Assembler::AVX_256bit);\n@@ -2172,0 +2158,74 @@\n+address StubGenerator::base64_AVX2_decode_tables_addr() {\n+  __ align64();\n+  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_base64\");\n+  address start = __ pc();\n+\n+  assert(((unsigned long long)start & 0x3f) == 0,\n+         \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+  __ emit_data(0x2f2f2f2f, relocInfo::none, 0);\n+  __ emit_data(0x5f5f5f5f, relocInfo::none, 0);  \/\/ for URL\n+\n+  __ emit_data(0xffffffff, relocInfo::none, 0);\n+  __ emit_data(0xfcfcfcfc, relocInfo::none, 0);  \/\/ for URL\n+\n+  \/\/ Permute table\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000400000002, relocInfo::none);\n+  __ emit_data64(0x0000000600000005, relocInfo::none);\n+  __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+\n+  \/\/ Shuffle table\n+  __ emit_data64(0x090a040506000102, relocInfo::none);\n+  __ emit_data64(0xffffffff0c0d0e08, relocInfo::none);\n+  __ emit_data64(0x090a040506000102, relocInfo::none);\n+  __ emit_data64(0xffffffff0c0d0e08, relocInfo::none);\n+\n+  \/\/ merge table\n+  __ emit_data(0x01400140, relocInfo::none, 0);\n+\n+  \/\/ merge multiplier\n+  __ emit_data(0x00011000, relocInfo::none, 0);\n+\n+  return start;\n+}\n+\n+address StubGenerator::base64_AVX2_decode_LUT_tables_addr() {\n+  __ align64();\n+  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_URL_base64\");\n+  address start = __ pc();\n+\n+  assert(((unsigned long long)start & 0x3f) == 0,\n+         \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+  \/\/ lut_lo\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1a1b1b1b1a131111, relocInfo::none);\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1a1b1b1b1a131111, relocInfo::none);\n+\n+  \/\/ lut_roll\n+  __ emit_data64(0xb9b9bfbf04131000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0xb9b9bfbf04131000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+\n+  \/\/ lut_lo URL\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1b1b1a1b1b131111, relocInfo::none);\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1b1b1a1b1b131111, relocInfo::none);\n+\n+  \/\/ lut_roll URL\n+  __ emit_data64(0xb9b9bfbf0411e000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0xb9b9bfbf0411e000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+\n+  \/\/ lut_hi\n+  __ emit_data64(0x0804080402011010, relocInfo::none);\n+  __ emit_data64(0x1010101010101010, relocInfo::none);\n+  __ emit_data64(0x0804080402011010, relocInfo::none);\n+  __ emit_data64(0x1010101010101010, relocInfo::none);\n+\n+  return start;\n+}\n+\n@@ -2328,1 +2388,1 @@\n-  Label L_forceLoop, L_bottomLoop, L_checkMIME, L_exit_no_vzero;\n+  Label L_forceLoop, L_bottomLoop, L_checkMIME, L_exit_no_vzero, L_lastChunk;\n@@ -2338,2 +2398,2 @@\n-    __ cmpl(length, 128);     \/\/ 128-bytes is break-even for AVX-512\n-    __ jcc(Assembler::lessEqual, L_bruteForce);\n+    __ cmpl(length, 31);     \/\/ 32-bytes is break-even for AVX-512\n+    __ jcc(Assembler::lessEqual, L_lastChunk);\n@@ -2342,1 +2402,1 @@\n-    __ jcc(Assembler::notEqual, L_bruteForce);\n+    __ jcc(Assembler::notEqual, L_lastChunk);\n@@ -2593,0 +2653,83 @@\n+  if (VM_Version::supports_avx2()) {\n+    Label L_tailProc, L_topLoop, L_enterLoop;\n+\n+    __ cmpl(isMIME, 0);\n+    __ jcc(Assembler::notEqual, L_lastChunk);\n+\n+    \/\/ Check for buffer too small (for algorithm)\n+    __ subl(length, 0x2c);\n+    __ jcc(Assembler::less, L_tailProc);\n+\n+    __ shll(isURL, 2);\n+\n+    \/\/ Algorithm adapted from https:\/\/arxiv.org\/abs\/1704.00605, \"Faster Base64\n+    \/\/ Encoding and Decoding using AVX2 Instructions\".  URL modifications added.\n+\n+    \/\/ Set up constants\n+    __ lea(r13, ExternalAddress(StubRoutines::x86::base64_AVX2_decode_tables_addr()));\n+    __ vpbroadcastd(xmm4, Address(r13, isURL, Address::times_1), Assembler::AVX_256bit);  \/\/ 2F or 5F\n+    __ vpbroadcastd(xmm10, Address(r13, isURL, Address::times_1, 0x08), Assembler::AVX_256bit);  \/\/ -1 or -4\n+    __ vmovdqu(xmm12, Address(r13, 0x10));  \/\/ permute\n+    __ vmovdqu(xmm13, Address(r13, 0x30)); \/\/ shuffle\n+    __ vpbroadcastd(xmm7, Address(r13, 0x50), Assembler::AVX_256bit);  \/\/ merge\n+    __ vpbroadcastd(xmm6, Address(r13, 0x54), Assembler::AVX_256bit);  \/\/ merge mult\n+\n+    __ lea(r13, ExternalAddress(StubRoutines::x86::base64_AVX2_decode_LUT_tables_addr()));\n+    __ shll(isURL, 4);\n+    __ vmovdqu(xmm11, Address(r13, isURL, Address::times_1, 0x00));  \/\/ lut_lo\n+    __ vmovdqu(xmm8, Address(r13, isURL, Address::times_1, 0x20)); \/\/ lut_roll\n+    __ shrl(isURL, 6);  \/\/ restore isURL\n+    __ vmovdqu(xmm9, Address(r13, 0x80));  \/\/ lut_hi\n+    __ jmp(L_enterLoop);\n+\n+    __ align32();\n+    __ bind(L_topLoop);\n+    \/\/ Add in the offset value (roll) to get 6-bit out values\n+    __ vpaddb(xmm0, xmm0, xmm2, Assembler::AVX_256bit);\n+    \/\/ Merge and permute the output bits into appropriate output byte lanes\n+    __ vpmaddubsw(xmm0, xmm0, xmm7, Assembler::AVX_256bit);\n+    __ vpmaddwd(xmm0, xmm0, xmm6, Assembler::AVX_256bit);\n+    __ vpshufb(xmm0, xmm0, xmm13, Assembler::AVX_256bit);\n+    __ vpermd(xmm0, xmm12, xmm0, Assembler::AVX_256bit);\n+    \/\/ Store the output bytes\n+    __ vmovdqu(Address(dest, dp, Address::times_1, 0), xmm0);\n+    __ addptr(source, 0x20);\n+    __ addptr(dest, 0x18);\n+    __ subl(length, 0x20);\n+    __ jcc(Assembler::less, L_tailProc);\n+\n+    __ bind(L_enterLoop);\n+\n+    \/\/ Load in encoded string (32 bytes)\n+    __ vmovdqu(xmm2, Address(source, start_offset, Address::times_1, 0x0));\n+    \/\/ Extract the high nibble for indexing into the lut tables.  High 4 bits are don't care.\n+    __ vpsrld(xmm1, xmm2, 0x4, Assembler::AVX_256bit);\n+    __ vpand(xmm1, xmm4, xmm1, Assembler::AVX_256bit);\n+    \/\/ Extract the low nibble. 5F\/2F will isolate the low-order 4 bits.  High 4 bits are don't care.\n+    __ vpand(xmm3, xmm2, xmm4, Assembler::AVX_256bit);\n+    \/\/ Check for special-case (0x2F or 0x5F (URL))\n+    __ vpcmpeqb(xmm0, xmm4, xmm2, Assembler::AVX_256bit);\n+    \/\/ Get the bitset based on the low nibble.  vpshufb uses low-order 4 bits only.\n+    __ vpshufb(xmm3, xmm11, xmm3, Assembler::AVX_256bit);\n+    \/\/ Get the bit value of the high nibble\n+    __ vpshufb(xmm5, xmm9, xmm1, Assembler::AVX_256bit);\n+    \/\/ Make sure 2F \/ 5F shows as valid\n+    __ vpandn(xmm3, xmm0, xmm3, Assembler::AVX_256bit);\n+    \/\/ Make adjustment for roll index.  For non-URL, this is a no-op,\n+    \/\/ for URL, this adjusts by -4.  This is to properly index the\n+    \/\/ roll value for 2F \/ 5F.\n+    __ vpand(xmm0, xmm0, xmm10, Assembler::AVX_256bit);\n+    \/\/ If the and of the two is non-zero, we have an invalid input character\n+    __ vptest(xmm3, xmm5);\n+    \/\/ Extract the \"roll\" value - value to add to the input to get 6-bit out value\n+    __ vpaddb(xmm0, xmm0, xmm1, Assembler::AVX_256bit); \/\/ Handle 2F \/ 5F\n+    __ vpshufb(xmm0, xmm8, xmm0, Assembler::AVX_256bit);\n+    __ jcc(Assembler::equal, L_topLoop);  \/\/ Fall through on error\n+\n+    __ bind(L_tailProc);\n+\n+    __ addl(length, 0x2c);\n+\n+    __ vzeroupper();\n+  }\n+\n@@ -2623,0 +2766,2 @@\n+  __ bind(L_lastChunk);\n+\n@@ -2781,0 +2926,2 @@\n+  Label L_continue;\n+\n@@ -2784,0 +2931,5 @@\n+    Label L_doSmall;\n+\n+    __ cmpl(len, 384);\n+    __ jcc(Assembler::lessEqual, L_doSmall);\n+\n@@ -2786,1 +2938,5 @@\n-  } else {\n+\n+    __ jmp(L_continue);\n+\n+    __ bind(L_doSmall);\n+  }\n@@ -2788,2 +2944,2 @@\n-    __ push(y);\n-    __ push(z);\n+  __ push(y);\n+  __ push(z);\n@@ -2791,5 +2947,5 @@\n-    __ crc32c_ipl_alg2_alt2(crc, buf, len,\n-                            a, j, k,\n-                            l, y, z,\n-                            c_farg0, c_farg1, c_farg2,\n-                            is_pclmulqdq_supported);\n+  __ crc32c_ipl_alg2_alt2(crc, buf, len,\n+                          a, j, k,\n+                          l, y, z,\n+                          c_farg0, c_farg1, c_farg2,\n+                          is_pclmulqdq_supported);\n@@ -2797,2 +2953,2 @@\n-    __ pop(z);\n-    __ pop(y);\n+  __ pop(z);\n+  __ pop(y);\n@@ -2800,1 +2956,2 @@\n-  }\n+\n+  __ bind(L_continue);\n@@ -3525,1 +3682,1 @@\n-  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n@@ -3540,8 +3697,1 @@\n-  Label L_null_jobject;\n-  __ testptr(rax, rax);\n-  __ jcc(Assembler::zero, L_null_jobject);\n-\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->load_at(_masm, ACCESS_READ | IN_NATIVE, T_OBJECT, rax, Address(rax, 0), c_rarg0, r15_thread);\n-\n-  __ bind(L_null_jobject);\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n@@ -4017,3 +4167,1 @@\n-    if(VM_Version::supports_avx2() &&\n-       VM_Version::supports_avx512bw() &&\n-       VM_Version::supports_avx512vl()) {\n+    if(VM_Version::supports_avx2()) {\n@@ -4023,0 +4171,2 @@\n+      StubRoutines::x86::_avx2_decode_tables_base64 = base64_AVX2_decode_tables_addr();\n+      StubRoutines::x86::_avx2_decode_lut_tables_base64 = base64_AVX2_decode_LUT_tables_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":207,"deletions":57,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -444,0 +444,2 @@\n+  address base64_AVX2_decode_tables_addr();\n+  address base64_AVX2_decode_LUT_tables_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -489,1 +489,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n@@ -653,1 +653,6 @@\n-  __ push(rlocals); \/\/ set locals pointer\n+\n+  __ movptr(rax, rlocals);\n+  __ subptr(rax, rbp);\n+  __ shrptr(rax, Interpreter::logStackElementSize);  \/\/ rax = rlocals - fp();\n+  __ push(rax); \/\/ set relativized rlocals, see frame::interpreter_frame_locals()\n+\n@@ -736,1 +741,1 @@\n-  const int page_size = os::vm_page_size();\n+  const int page_size = (int)os::vm_page_size();\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -156,1 +156,4 @@\n-  __ store_heap_oop(dst, val, rdx, rbx, LP64_ONLY(r8) NOT_LP64(rsi), decorators);\n+  __ store_heap_oop(dst, val,\n+                    NOT_LP64(rdx) LP64_ONLY(rscratch2),\n+                    NOT_LP64(rbx) LP64_ONLY(r9),\n+                    NOT_LP64(rsi) LP64_ONLY(r8), decorators);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1143,1 +1143,1 @@\n-  if ((UseAVX > 2) && supports_avx512vl() && supports_avx512bw()) {\n+  if (UseAVX >= 2) {\n@@ -1698,0 +1698,7 @@\n+  if (UseAVX >= 2) {\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, true);\n+  } else if (UseVectorizedHashCodeIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic))\n+      warning(\"vectorizedHashCode intrinsics are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n+  }\n@@ -1705,0 +1712,6 @@\n+  if (UseVectorizedHashCodeIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic)) {\n+      warning(\"vectorizedHashCode intrinsic is not available in 32-bit VM\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDX int register\n@@ -311,1 +311,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDI int register\n@@ -12323,0 +12323,26 @@\n+instruct arrays_hashcode(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result, immU8 basic_type,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1) (Binary result basic_type)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL ary1, USE_KILL cnt1,\n+         USE basic_type, KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary1,$cnt1,$result,$basic_type -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -13592,1 +13618,1 @@\n-instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{\n+instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{\n@@ -13595,1 +13621,1 @@\n-  effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);\n+  effect(TEMP tmp, TEMP scr, USE_KILL box);\n@@ -13600,1 +13626,1 @@\n-                 $scr$$Register, $cx1$$Register, noreg, NULL, NULL, NULL, false, false);\n+                 $scr$$Register, noreg, noreg, NULL, NULL, NULL, false, false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -37,1 +37,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/zero\/vtableStubs_zero.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -608,2 +608,2 @@\n-  \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals use many memorys edges,\n-  \/\/ but writes none\n+  \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.(equals\/hashCode)\n+  \/\/ use many memorys edges, but writes none\n@@ -616,1 +616,2 @@\n-        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ))\n+        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"VectorizedHashCode\")==0 ))\n@@ -900,0 +901,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"VectorizedHashCode\")==0 ||\n@@ -908,1 +910,1 @@\n-        \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals\n+        \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.equals\n@@ -1304,1 +1306,1 @@\n-    fprintf(fp, \"char reg[128];  ra->dump_register(in(mach_constant_base_node_input()), reg);\\n\");\n+    fprintf(fp, \"char reg[128];  ra->dump_register(in(mach_constant_base_node_input()), reg, sizeof(reg));\\n\");\n@@ -2503,1 +2505,1 @@\n-    fprintf(fp,\"    ra->dump_register(node,reg_str);\\n\");\n+    fprintf(fp,\"    ra->dump_register(node,reg_str, sizeof(reg_str));\\n\");\n@@ -2511,1 +2513,1 @@\n-    fprintf(fp,\"    ra->dump_register(node,reg_str);\\n\");\n+    fprintf(fp,\"    ra->dump_register(node,reg_str, sizeof(reg_str));\\n\");\n@@ -2532,1 +2534,1 @@\n-    fprintf(fp,                                      \"),reg_str);\\n\");\n+    fprintf(fp,                                      \"),reg_str,sizeof(reg_str));\\n\");\n@@ -2542,1 +2544,1 @@\n-    fprintf(fp,                                       \"),reg_str);\\n\");\n+    fprintf(fp,                                       \"),reg_str,sizeof(reg_str));\\n\");\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,1 @@\n+  int         _skipped_instructions_size;\n@@ -124,0 +125,1 @@\n+    _skipped_instructions_size = 0;\n@@ -154,0 +156,1 @@\n+    _skipped_instructions_size = cs->_skipped_instructions_size;\n@@ -214,0 +217,4 @@\n+  void register_skipped(int size) {\n+    _skipped_instructions_size += size;\n+  }\n+\n@@ -406,1 +413,1 @@\n-  typedef ResizeableResourceHashtable<address, Offsets> SharedTrampolineRequests;\n+  typedef ResizeableResourceHashtable<address, Offsets, AnyObj::C_HEAP, mtCompiler> SharedTrampolineRequests;\n@@ -648,0 +655,2 @@\n+  int total_skipped_instructions_size() const;\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1926,1 +1926,1 @@\n-  if (GenerateRangeChecks && needs_range_check) {\n+  if (needs_range_check) {\n@@ -2324,1 +2324,1 @@\n-  if (GenerateRangeChecks && needs_range_check) {\n+  if (needs_range_check) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -54,1 +55,1 @@\n-ArchiveBuilder* ArchiveBuilder::_current = NULL;\n+ArchiveBuilder* ArchiveBuilder::_current = nullptr;\n@@ -98,1 +99,1 @@\n-  assert(*field_addr != NULL, \"should have checked\");\n+  assert(*field_addr != nullptr, \"should have checked\");\n@@ -144,3 +145,3 @@\n-  _current_dump_space(NULL),\n-  _buffer_bottom(NULL),\n-  _last_verified_top(NULL),\n+  _current_dump_space(nullptr),\n+  _buffer_bottom(nullptr),\n+  _last_verified_top(nullptr),\n@@ -149,6 +150,6 @@\n-  _requested_static_archive_bottom(NULL),\n-  _requested_static_archive_top(NULL),\n-  _requested_dynamic_archive_bottom(NULL),\n-  _requested_dynamic_archive_top(NULL),\n-  _mapped_static_archive_bottom(NULL),\n-  _mapped_static_archive_top(NULL),\n+  _requested_static_archive_bottom(nullptr),\n+  _requested_static_archive_top(nullptr),\n+  _requested_dynamic_archive_bottom(nullptr),\n+  _requested_dynamic_archive_top(nullptr),\n+  _mapped_static_archive_bottom(nullptr),\n+  _mapped_static_archive_top(nullptr),\n@@ -172,1 +173,1 @@\n-  assert(_current == NULL, \"must be\");\n+  assert(_current == nullptr, \"must be\");\n@@ -178,1 +179,1 @@\n-  _current = NULL;\n+  _current = nullptr;\n@@ -210,1 +211,1 @@\n-  if (ref->obj() == NULL) {\n+  if (ref->obj() == nullptr) {\n@@ -432,1 +433,1 @@\n-    if (ref->obj() != NULL) {\n+    if (ref->obj() != nullptr) {\n@@ -441,1 +442,1 @@\n-  if (src_obj == NULL) {\n+  if (src_obj == nullptr) {\n@@ -474,1 +475,1 @@\n-  assert(ref->obj() != NULL, \"should have checked\");\n+  assert(ref->obj() != nullptr, \"should have checked\");\n@@ -476,1 +477,1 @@\n-  if (enclosing_ref != NULL) {\n+  if (enclosing_ref != nullptr) {\n@@ -478,1 +479,1 @@\n-    if (src_info == NULL) {\n+    if (src_info == nullptr) {\n@@ -639,1 +640,1 @@\n-  if (archived_vtable != NULL) {\n+  if (archived_vtable != nullptr) {\n@@ -652,1 +653,1 @@\n-  assert(p != NULL, \"must be\");\n+  assert(p != nullptr, \"must be\");\n@@ -660,1 +661,1 @@\n-  assert(src_p != NULL && *src_p != NULL, \"must be\");\n+  assert(src_p != nullptr && *src_p != nullptr, \"must be\");\n@@ -844,3 +845,1 @@\n-\/\/ Update a Java object to point its Klass* to the address whene\n-\/\/ the class would be mapped at runtime.\n-void ArchiveBuilder::relocate_klass_ptr_of_oop(oop o) {\n+narrowKlass ArchiveBuilder::get_requested_narrow_klass(Klass* k) {\n@@ -848,1 +847,1 @@\n-  Klass* k = get_buffered_klass(o->klass());\n+  k = get_buffered_klass(k);\n@@ -850,2 +849,1 @@\n-  narrowKlass nk = CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n-  o->set_narrow_klass(nk);\n+  return CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n@@ -860,1 +858,1 @@\n-\/\/   [a] NULL:\n+\/\/   [a] nullptr:\n@@ -900,1 +898,1 @@\n-    if (*p == NULL) {\n+    if (*p == nullptr) {\n@@ -1076,3 +1074,2 @@\n-        oop archived_oop = cast_to_oop(start);\n-        oop original_oop = HeapShared::get_original_object(archived_oop);\n-        if (original_oop != NULL) {\n+        oop original_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n+        if (original_oop != nullptr) {\n@@ -1083,1 +1080,1 @@\n-        } else if (archived_oop == HeapShared::roots()) {\n+        } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n@@ -1088,1 +1085,1 @@\n-          byte_size = objArrayOopDesc::object_size(HeapShared::roots()->length()) * BytesPerWord;\n+          byte_size = ArchiveHeapWriter::heap_roots_word_size() * BytesPerWord;\n@@ -1105,1 +1102,1 @@\n-    return HeapShared::to_requested_address(p);\n+    return ArchiveHeapWriter::buffered_addr_to_requested_addr(p);\n@@ -1157,1 +1154,1 @@\n-    if (closed_heap_regions != NULL) {\n+    if (closed_heap_regions != nullptr) {\n@@ -1160,1 +1157,1 @@\n-    if (open_heap_regions != NULL) {\n+    if (open_heap_regions != nullptr) {\n@@ -1194,1 +1191,1 @@\n-  if (closed_heap_regions != NULL) {\n+  if (closed_heap_regions != nullptr) {\n@@ -1253,1 +1250,1 @@\n-  if (closed_heap_regions != NULL) {\n+  if (closed_heap_regions != nullptr) {\n@@ -1269,1 +1266,1 @@\n-  int arr_len = regions == NULL ? 0 : regions->length();\n+  int arr_len = regions == nullptr ? 0 : regions->length();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":39,"deletions":42,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-        _buffered_addr = NULL;\n+        _buffered_addr = nullptr;\n@@ -175,2 +175,2 @@\n-      assert(_buffered_addr == NULL, \"cannot be copied twice\");\n-      assert(addr != NULL, \"must be a valid copy\");\n+      assert(_buffered_addr == nullptr, \"cannot be copied twice\");\n+      assert(addr != nullptr, \"must be a valid copy\");\n@@ -432,1 +432,1 @@\n-    return (_current != NULL);\n+    return (_current != nullptr);\n@@ -437,1 +437,1 @@\n-    assert(_current != NULL, \"ArchiveBuilder must be active\");\n+    assert(_current != nullptr, \"ArchiveBuilder must be active\");\n@@ -453,1 +453,1 @@\n-  void relocate_klass_ptr_of_oop(oop o);\n+  narrowKlass get_requested_narrow_klass(Klass* k);\n@@ -457,1 +457,1 @@\n-    assert(klass != NULL && klass->is_klass(), \"must be\");\n+    assert(klass != nullptr && klass->is_klass(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,657 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveHeapWriter.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/compressedOops.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/objArrayOop.inline.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"oops\/typeArrayKlass.hpp\"\n+#include \"oops\/typeArrayOop.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n+#if INCLUDE_G1GC\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#endif\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+\n+GrowableArrayCHeap<u1, mtClassShared>* ArchiveHeapWriter::_buffer;\n+\n+\/\/ The following are offsets from buffer_bottom()\n+size_t ArchiveHeapWriter::_buffer_top;\n+size_t ArchiveHeapWriter::_open_bottom;\n+size_t ArchiveHeapWriter::_open_top;\n+size_t ArchiveHeapWriter::_closed_bottom;\n+size_t ArchiveHeapWriter::_closed_top;\n+size_t ArchiveHeapWriter::_heap_roots_bottom;\n+\n+size_t ArchiveHeapWriter::_heap_roots_word_size;\n+\n+address ArchiveHeapWriter::_requested_open_region_bottom;\n+address ArchiveHeapWriter::_requested_open_region_top;\n+address ArchiveHeapWriter::_requested_closed_region_bottom;\n+address ArchiveHeapWriter::_requested_closed_region_top;\n+\n+ResourceBitMap* ArchiveHeapWriter::_closed_oopmap;\n+ResourceBitMap* ArchiveHeapWriter::_open_oopmap;\n+\n+GrowableArrayCHeap<ArchiveHeapWriter::NativePointerInfo, mtClassShared>* ArchiveHeapWriter::_native_pointers;\n+GrowableArrayCHeap<oop, mtClassShared>* ArchiveHeapWriter::_source_objs;\n+\n+ArchiveHeapWriter::BufferOffsetToSourceObjectTable*\n+  ArchiveHeapWriter::_buffer_offset_to_source_obj_table = nullptr;\n+\n+void ArchiveHeapWriter::init() {\n+  if (HeapShared::can_write()) {\n+    Universe::heap()->collect(GCCause::_java_lang_system_gc);\n+\n+    _buffer_offset_to_source_obj_table = new BufferOffsetToSourceObjectTable();\n+\n+    _requested_open_region_bottom = nullptr;\n+    _requested_open_region_top = nullptr;\n+    _requested_closed_region_bottom = nullptr;\n+    _requested_closed_region_top = nullptr;\n+\n+    _native_pointers = new GrowableArrayCHeap<NativePointerInfo, mtClassShared>(2048);\n+    _source_objs = new GrowableArrayCHeap<oop, mtClassShared>(10000);\n+\n+    guarantee(UseG1GC, \"implementation limitation\");\n+    guarantee(MIN_GC_REGION_ALIGNMENT <= \/*G1*\/HeapRegion::min_region_size_in_words() * HeapWordSize, \"must be\");\n+  }\n+}\n+\n+void ArchiveHeapWriter::add_source_obj(oop src_obj) {\n+  _source_objs->append(src_obj);\n+}\n+\n+\/\/ For the time being, always support two regions (to be strictly compatible with existing G1\n+\/\/ mapping code. We might eventually use a single region (JDK-8298048).\n+void ArchiveHeapWriter::write(GrowableArrayCHeap<oop, mtClassShared>* roots,\n+                              GrowableArray<MemRegion>* closed_regions, GrowableArray<MemRegion>* open_regions,\n+                              GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n+                              GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps) {\n+  assert(HeapShared::can_write(), \"sanity\");\n+  allocate_buffer();\n+  copy_source_objs_to_buffer(roots);\n+  set_requested_address_for_regions(closed_regions, open_regions);\n+  relocate_embedded_oops(roots, closed_bitmaps, open_bitmaps);\n+}\n+\n+bool ArchiveHeapWriter::is_too_large_to_archive(oop o) {\n+  return is_too_large_to_archive(o->size());\n+}\n+\n+bool ArchiveHeapWriter::is_string_too_large_to_archive(oop string) {\n+  typeArrayOop value = java_lang_String::value_no_keepalive(string);\n+  return is_too_large_to_archive(value);\n+}\n+\n+bool ArchiveHeapWriter::is_too_large_to_archive(size_t size) {\n+  assert(size > 0, \"no zero-size object\");\n+  assert(size * HeapWordSize > size, \"no overflow\");\n+  static_assert(MIN_GC_REGION_ALIGNMENT > 0, \"must be positive\");\n+\n+  size_t byte_size = size * HeapWordSize;\n+  if (byte_size > size_t(MIN_GC_REGION_ALIGNMENT)) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ Various lookup functions between source_obj, buffered_obj and requested_obj\n+bool ArchiveHeapWriter::is_in_requested_regions(oop o) {\n+  assert(_requested_open_region_bottom != nullptr, \"do not call before this is initialized\");\n+  assert(_requested_closed_region_bottom != nullptr, \"do not call before this is initialized\");\n+\n+  address a = cast_from_oop<address>(o);\n+  return (_requested_open_region_bottom <= a && a < _requested_open_region_top) ||\n+         (_requested_closed_region_bottom <= a && a < _requested_closed_region_top);\n+}\n+\n+oop ArchiveHeapWriter::requested_obj_from_buffer_offset(size_t offset) {\n+  oop req_obj = cast_to_oop(_requested_open_region_bottom + offset);\n+  assert(is_in_requested_regions(req_obj), \"must be\");\n+  return req_obj;\n+}\n+\n+oop ArchiveHeapWriter::source_obj_to_requested_obj(oop src_obj) {\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n+  if (p != nullptr) {\n+    return requested_obj_from_buffer_offset(p->buffer_offset());\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+oop ArchiveHeapWriter::buffered_addr_to_source_obj(address buffered_addr) {\n+  oop* p = _buffer_offset_to_source_obj_table->get(buffered_address_to_offset(buffered_addr));\n+  if (p != nullptr) {\n+    return *p;\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+address ArchiveHeapWriter::buffered_addr_to_requested_addr(address buffered_addr) {\n+  return _requested_open_region_bottom + buffered_address_to_offset(buffered_addr);\n+}\n+\n+oop ArchiveHeapWriter::heap_roots_requested_address() {\n+  return requested_obj_from_buffer_offset(_heap_roots_bottom);\n+}\n+\n+address ArchiveHeapWriter::heap_region_requested_bottom(int heap_region_idx) {\n+  assert(_buffer != nullptr, \"must be initialized\");\n+  switch (heap_region_idx) {\n+  case MetaspaceShared::first_closed_heap_region:\n+    return _requested_closed_region_bottom;\n+  case MetaspaceShared::first_open_heap_region:\n+    return _requested_open_region_bottom;\n+  default:\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+}\n+\n+void ArchiveHeapWriter::allocate_buffer() {\n+  int initial_buffer_size = 100000;\n+  _buffer = new GrowableArrayCHeap<u1, mtClassShared>(initial_buffer_size);\n+  _open_bottom = _buffer_top = 0;\n+  ensure_buffer_space(1); \/\/ so that buffer_bottom() works\n+}\n+\n+void ArchiveHeapWriter::ensure_buffer_space(size_t min_bytes) {\n+  \/\/ We usually have very small heaps. If we get a huge one it's probably caused by a bug.\n+  guarantee(min_bytes <= max_jint, \"we dont support archiving more than 2G of objects\");\n+  _buffer->at_grow(to_array_index(min_bytes));\n+}\n+\n+void ArchiveHeapWriter::copy_roots_to_buffer(GrowableArrayCHeap<oop, mtClassShared>* roots) {\n+  Klass* k = Universe::objectArrayKlassObj(); \/\/ already relocated to point to archived klass\n+  int length = roots != nullptr ? roots->length() : 0;\n+  _heap_roots_word_size = objArrayOopDesc::object_size(length);\n+  size_t byte_size = _heap_roots_word_size * HeapWordSize;\n+  if (byte_size >= MIN_GC_REGION_ALIGNMENT) {\n+    log_error(cds, heap)(\"roots array is too large. Please reduce the number of classes\");\n+    vm_exit(1);\n+  }\n+\n+  maybe_fill_gc_region_gap(byte_size);\n+\n+  size_t new_top = _buffer_top + byte_size;\n+  ensure_buffer_space(new_top);\n+\n+  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_top);\n+  memset(mem, 0, byte_size);\n+  {\n+    \/\/ This is copied from MemAllocator::finish\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::release_set_klass(mem, k);\n+  }\n+  {\n+    \/\/ This is copied from ObjArrayAllocator::initialize\n+    arrayOopDesc::set_length(mem, length);\n+  }\n+\n+  objArrayOop arrayOop = objArrayOop(cast_to_oop(mem));\n+  for (int i = 0; i < length; i++) {\n+    \/\/ Do not use arrayOop->obj_at_put(i, o) as arrayOop is outside of the real heap!\n+    oop o = roots->at(i);\n+    if (UseCompressedOops) {\n+      * arrayOop->obj_at_addr<narrowOop>(i) = CompressedOops::encode(o);\n+    } else {\n+      * arrayOop->obj_at_addr<oop>(i) = o;\n+    }\n+  }\n+  log_info(cds)(\"archived obj roots[%d] = \" SIZE_FORMAT \" bytes, klass = %p, obj = %p\", length, byte_size, k, mem);\n+\n+  _heap_roots_bottom = _buffer_top;\n+  _buffer_top = new_top;\n+}\n+\n+void ArchiveHeapWriter::copy_source_objs_to_buffer(GrowableArrayCHeap<oop, mtClassShared>* roots) {\n+  copy_source_objs_to_buffer_by_region(\/*copy_open_region=*\/true);\n+  copy_roots_to_buffer(roots);\n+  _open_top = _buffer_top;\n+\n+  \/\/ Align the closed region to the next G1 region\n+  _buffer_top = _closed_bottom = align_up(_buffer_top, HeapRegion::GrainBytes);\n+  copy_source_objs_to_buffer_by_region(\/*copy_open_region=*\/false);\n+  _closed_top = _buffer_top;\n+\n+  log_info(cds, heap)(\"Size of open region   = \" SIZE_FORMAT \" bytes\", _open_top   - _open_bottom);\n+  log_info(cds, heap)(\"Size of closed region = \" SIZE_FORMAT \" bytes\", _closed_top - _closed_bottom);\n+}\n+\n+void ArchiveHeapWriter::copy_source_objs_to_buffer_by_region(bool copy_open_region) {\n+  for (int i = 0; i < _source_objs->length(); i++) {\n+    oop src_obj = _source_objs->at(i);\n+    HeapShared::CachedOopInfo* info = HeapShared::archived_object_cache()->get(src_obj);\n+    assert(info != nullptr, \"must be\");\n+    if (info->in_open_region() == copy_open_region) {\n+      \/\/ For region-based collectors such as G1, we need to make sure that we don't have\n+      \/\/ an object that can possible span across two regions.\n+      size_t buffer_offset = copy_one_source_obj_to_buffer(src_obj);\n+      info->set_buffer_offset(buffer_offset);\n+\n+      _buffer_offset_to_source_obj_table->put(buffer_offset, src_obj);\n+    }\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::filler_array_byte_size(int length) {\n+  size_t byte_size = objArrayOopDesc::object_size(length) * HeapWordSize;\n+  return byte_size;\n+}\n+\n+int ArchiveHeapWriter::filler_array_length(size_t fill_bytes) {\n+  assert(is_object_aligned(fill_bytes), \"must be\");\n+  size_t elemSize = (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop));\n+\n+  int initial_length = to_array_length(fill_bytes \/ elemSize);\n+  for (int length = initial_length; length >= 0; length --) {\n+    size_t array_byte_size = filler_array_byte_size(length);\n+    if (array_byte_size == fill_bytes) {\n+      return length;\n+    }\n+  }\n+\n+  ShouldNotReachHere();\n+  return -1;\n+}\n+\n+void ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n+  assert(UseCompressedClassPointers, \"Archived heap only supported for compressed klasses\");\n+  Klass* oak = Universe::objectArrayKlassObj(); \/\/ already relocated to point to archived klass\n+  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_top);\n+  memset(mem, 0, fill_bytes);\n+  oopDesc::set_mark(mem, markWord::prototype());\n+  narrowKlass nk = ArchiveBuilder::current()->get_requested_narrow_klass(oak);\n+  cast_to_oop(mem)->set_narrow_klass(nk);\n+  arrayOopDesc::set_length(mem, array_length);\n+}\n+\n+void ArchiveHeapWriter::maybe_fill_gc_region_gap(size_t required_byte_size) {\n+  \/\/ We fill only with arrays (so we don't need to use a single HeapWord filler if the\n+  \/\/ leftover space is smaller than a zero-sized array object). Therefore, we need to\n+  \/\/ make sure there's enough space of min_filler_byte_size in the current region after\n+  \/\/ required_byte_size has been allocated. If not, fill the remainder of the current\n+  \/\/ region.\n+  size_t min_filler_byte_size = filler_array_byte_size(0);\n+  size_t new_top = _buffer_top + required_byte_size + min_filler_byte_size;\n+\n+  const size_t cur_min_region_bottom = align_down(_buffer_top, MIN_GC_REGION_ALIGNMENT);\n+  const size_t next_min_region_bottom = align_down(new_top, MIN_GC_REGION_ALIGNMENT);\n+\n+  if (cur_min_region_bottom != next_min_region_bottom) {\n+    \/\/ Make sure that no objects span across MIN_GC_REGION_ALIGNMENT. This way\n+    \/\/ we can map the region in any region-based collector.\n+    assert(next_min_region_bottom > cur_min_region_bottom, \"must be\");\n+    assert(next_min_region_bottom - cur_min_region_bottom == MIN_GC_REGION_ALIGNMENT,\n+           \"no buffered object can be larger than %d bytes\",  MIN_GC_REGION_ALIGNMENT);\n+\n+    const size_t filler_end = next_min_region_bottom;\n+    const size_t fill_bytes = filler_end - _buffer_top;\n+    assert(fill_bytes > 0, \"must be\");\n+    ensure_buffer_space(filler_end);\n+\n+    int array_length = filler_array_length(fill_bytes);\n+    log_info(cds, heap)(\"Inserting filler obj array of %d elements (\" SIZE_FORMAT \" bytes total) @ buffer offset \" SIZE_FORMAT,\n+                        array_length, fill_bytes, _buffer_top);\n+    init_filler_array_at_buffer_top(array_length, fill_bytes);\n+\n+    _buffer_top = filler_end;\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::copy_one_source_obj_to_buffer(oop src_obj) {\n+  assert(!is_too_large_to_archive(src_obj), \"already checked\");\n+  size_t byte_size = src_obj->size() * HeapWordSize;\n+  assert(byte_size > 0, \"no zero-size objects\");\n+\n+  maybe_fill_gc_region_gap(byte_size);\n+\n+  size_t new_top = _buffer_top + byte_size;\n+  assert(new_top > _buffer_top, \"no wrap around\");\n+\n+  size_t cur_min_region_bottom = align_down(_buffer_top, MIN_GC_REGION_ALIGNMENT);\n+  size_t next_min_region_bottom = align_down(new_top, MIN_GC_REGION_ALIGNMENT);\n+  assert(cur_min_region_bottom == next_min_region_bottom, \"no object should cross minimal GC region boundaries\");\n+\n+  ensure_buffer_space(new_top);\n+\n+  address from = cast_from_oop<address>(src_obj);\n+  address to = offset_to_buffered_address<address>(_buffer_top);\n+  assert(is_object_aligned(_buffer_top), \"sanity\");\n+  assert(is_object_aligned(byte_size), \"sanity\");\n+  memcpy(to, from, byte_size);\n+\n+  size_t buffered_obj_offset = _buffer_top;\n+  _buffer_top = new_top;\n+\n+  return buffered_obj_offset;\n+}\n+\n+void ArchiveHeapWriter::set_requested_address_for_regions(GrowableArray<MemRegion>* closed_regions,\n+                                                          GrowableArray<MemRegion>* open_regions) {\n+  assert(closed_regions->length() == 0, \"must be\");\n+  assert(open_regions->length() == 0, \"must be\");\n+\n+  assert(UseG1GC, \"must be\");\n+  address heap_end = (address)G1CollectedHeap::heap()->reserved().end();\n+  log_info(cds, heap)(\"Heap end = %p\", heap_end);\n+\n+  size_t closed_region_byte_size = _closed_top - _closed_bottom;\n+  size_t open_region_byte_size = _open_top - _open_bottom;\n+  assert(closed_region_byte_size > 0, \"must archived at least one object for closed region!\");\n+  assert(open_region_byte_size > 0, \"must archived at least one object for open region!\");\n+\n+  \/\/ The following two asserts are ensured by copy_source_objs_to_buffer_by_region().\n+  assert(is_aligned(_closed_bottom, HeapRegion::GrainBytes), \"sanity\");\n+  assert(is_aligned(_open_bottom, HeapRegion::GrainBytes), \"sanity\");\n+\n+  _requested_closed_region_bottom = align_down(heap_end - closed_region_byte_size, HeapRegion::GrainBytes);\n+  _requested_open_region_bottom = _requested_closed_region_bottom - (_closed_bottom - _open_bottom);\n+\n+  assert(is_aligned(_requested_closed_region_bottom, HeapRegion::GrainBytes), \"sanity\");\n+  assert(is_aligned(_requested_open_region_bottom, HeapRegion::GrainBytes), \"sanity\");\n+\n+  _requested_open_region_top = _requested_open_region_bottom + (_open_top - _open_bottom);\n+  _requested_closed_region_top = _requested_closed_region_bottom + (_closed_top - _closed_bottom);\n+\n+  assert(_requested_open_region_top <= _requested_closed_region_bottom, \"no overlap\");\n+\n+  closed_regions->append(MemRegion(offset_to_buffered_address<HeapWord*>(_closed_bottom),\n+                                   offset_to_buffered_address<HeapWord*>(_closed_top)));\n+  open_regions->append(  MemRegion(offset_to_buffered_address<HeapWord*>(_open_bottom),\n+                                   offset_to_buffered_address<HeapWord*>(_open_top)));\n+}\n+\n+\/\/ Oop relocation\n+\n+template <typename T> T* ArchiveHeapWriter::requested_addr_to_buffered_addr(T* p) {\n+  assert(is_in_requested_regions(cast_to_oop(p)), \"must be\");\n+\n+  address addr = address(p);\n+  assert(addr >= _requested_open_region_bottom, \"must be\");\n+  size_t offset = addr - _requested_open_region_bottom;\n+  return offset_to_buffered_address<T*>(offset);\n+}\n+\n+template <typename T> oop ArchiveHeapWriter::load_source_oop_from_buffer(T* buffered_addr) {\n+  oop o = load_oop_from_buffer(buffered_addr);\n+  assert(!in_buffer(cast_from_oop<address>(o)), \"must point to source oop\");\n+  return o;\n+}\n+\n+template <typename T> void ArchiveHeapWriter::store_requested_oop_in_buffer(T* buffered_addr,\n+                                                                            oop request_oop) {\n+  assert(is_in_requested_regions(request_oop), \"must be\");\n+  store_oop_in_buffer(buffered_addr, request_oop);\n+}\n+\n+void ArchiveHeapWriter::store_oop_in_buffer(oop* buffered_addr, oop requested_obj) {\n+  \/\/ Make heap content deterministic. See comments inside HeapShared::to_requested_address.\n+  *buffered_addr = HeapShared::to_requested_address(requested_obj);\n+}\n+\n+void ArchiveHeapWriter::store_oop_in_buffer(narrowOop* buffered_addr, oop requested_obj) {\n+  \/\/ Note: HeapShared::to_requested_address() is not necessary because\n+  \/\/ the heap always starts at a deterministic address with UseCompressedOops==true.\n+  narrowOop val = CompressedOops::encode_not_null(requested_obj);\n+  *buffered_addr = val;\n+}\n+\n+oop ArchiveHeapWriter::load_oop_from_buffer(oop* buffered_addr) {\n+  return *buffered_addr;\n+}\n+\n+oop ArchiveHeapWriter::load_oop_from_buffer(narrowOop* buffered_addr) {\n+  return CompressedOops::decode(*buffered_addr);\n+}\n+\n+template <typename T> void ArchiveHeapWriter::relocate_field_in_buffer(T* field_addr_in_buffer) {\n+  oop source_referent = load_source_oop_from_buffer<T>(field_addr_in_buffer);\n+  if (!CompressedOops::is_null(source_referent)) {\n+    oop request_referent = source_obj_to_requested_obj(source_referent);\n+    store_requested_oop_in_buffer<T>(field_addr_in_buffer, request_referent);\n+    mark_oop_pointer<T>(field_addr_in_buffer);\n+  }\n+}\n+\n+template <typename T> void ArchiveHeapWriter::mark_oop_pointer(T* buffered_addr) {\n+  T* request_p = (T*)(buffered_addr_to_requested_addr((address)buffered_addr));\n+  ResourceBitMap* oopmap;\n+  address requested_region_bottom;\n+\n+  if (request_p >= (T*)_requested_closed_region_bottom) {\n+    assert(request_p < (T*)_requested_closed_region_top, \"sanity\");\n+    oopmap = _closed_oopmap;\n+    requested_region_bottom = _requested_closed_region_bottom;\n+  } else {\n+    assert(request_p >= (T*)_requested_open_region_bottom, \"sanity\");\n+    assert(request_p <  (T*)_requested_open_region_top, \"sanity\");\n+    oopmap = _open_oopmap;\n+    requested_region_bottom = _requested_open_region_bottom;\n+  }\n+\n+  \/\/ Mark the pointer in the oopmap\n+  T* region_bottom = (T*)requested_region_bottom;\n+  assert(request_p >= region_bottom, \"must be\");\n+  BitMap::idx_t idx = request_p - region_bottom;\n+  assert(idx < oopmap->size(), \"overflow\");\n+  oopmap->set_bit(idx);\n+}\n+\n+void ArchiveHeapWriter::update_header_for_requested_obj(oop requested_obj, oop src_obj,  Klass* src_klass) {\n+  assert(UseCompressedClassPointers, \"Archived heap only supported for compressed klasses\");\n+  narrowKlass nk = ArchiveBuilder::current()->get_requested_narrow_klass(src_klass);\n+  address buffered_addr = requested_addr_to_buffered_addr(cast_from_oop<address>(requested_obj));\n+\n+  oop fake_oop = cast_to_oop(buffered_addr);\n+  fake_oop->set_narrow_klass(nk);\n+\n+  \/\/ We need to retain the identity_hash, because it may have been used by some hashtables\n+  \/\/ in the shared heap. This also has the side effect of pre-initializing the\n+  \/\/ identity_hash for all shared objects, so they are less likely to be written\n+  \/\/ into during run time, increasing the potential of memory sharing.\n+  if (src_obj != nullptr && (!(EnableValhalla && src_obj->mark().is_inline_type()))) {\n+    int src_hash = src_obj->identity_hash();\n+    fake_oop->set_mark(src_klass->prototype_header().copy_set_hash(src_hash));\n+    assert(fake_oop->mark().is_unlocked(), \"sanity\");\n+\n+    DEBUG_ONLY(int archived_hash = fake_oop->identity_hash());\n+    assert(src_hash == archived_hash, \"Different hash codes: original %x, archived %x\", src_hash, archived_hash);\n+  }\n+}\n+\n+\/\/ Relocate an element in the buffered copy of HeapShared::roots()\n+template <typename T> void ArchiveHeapWriter::relocate_root_at(oop requested_roots, int index) {\n+  size_t offset = (size_t)((objArrayOop)requested_roots)->obj_at_offset<T>(index);\n+  relocate_field_in_buffer<T>((T*)(buffered_heap_roots_addr() + offset));\n+}\n+\n+class ArchiveHeapWriter::EmbeddedOopRelocator: public BasicOopIterateClosure {\n+  oop _src_obj;\n+  address _buffered_obj;\n+\n+public:\n+  EmbeddedOopRelocator(oop src_obj, address buffered_obj) :\n+    _src_obj(src_obj), _buffered_obj(buffered_obj) {}\n+\n+  void do_oop(narrowOop *p) { EmbeddedOopRelocator::do_oop_work(p); }\n+  void do_oop(      oop *p) { EmbeddedOopRelocator::do_oop_work(p); }\n+\n+private:\n+  template <class T> void do_oop_work(T *p) {\n+    size_t field_offset = pointer_delta(p, _src_obj, sizeof(char));\n+    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset));\n+  }\n+};\n+\n+\/\/ Update all oop fields embedded in the buffered objects\n+void ArchiveHeapWriter::relocate_embedded_oops(GrowableArrayCHeap<oop, mtClassShared>* roots,\n+                                               GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n+                                               GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps) {\n+  size_t oopmap_unit = (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop));\n+  size_t closed_region_byte_size = _closed_top - _closed_bottom;\n+  size_t open_region_byte_size   = _open_top   - _open_bottom;\n+  ResourceBitMap closed_oopmap(closed_region_byte_size \/ oopmap_unit);\n+  ResourceBitMap open_oopmap  (open_region_byte_size   \/ oopmap_unit);\n+\n+  _closed_oopmap = &closed_oopmap;\n+  _open_oopmap = &open_oopmap;\n+\n+  auto iterator = [&] (oop src_obj, HeapShared::CachedOopInfo& info) {\n+    oop requested_obj = requested_obj_from_buffer_offset(info.buffer_offset());\n+    update_header_for_requested_obj(requested_obj, src_obj, src_obj->klass());\n+\n+    address buffered_obj = offset_to_buffered_address<address>(info.buffer_offset());\n+    EmbeddedOopRelocator relocator(src_obj, buffered_obj);\n+\n+    src_obj->oop_iterate(&relocator);\n+  };\n+  HeapShared::archived_object_cache()->iterate_all(iterator);\n+\n+  \/\/ Relocate HeapShared::roots(), which is created in copy_roots_to_buffer() and\n+  \/\/ doesn't have a corresponding src_obj, so we can't use EmbeddedOopRelocator on it.\n+  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_bottom);\n+  update_header_for_requested_obj(requested_roots, nullptr, Universe::objectArrayKlassObj());\n+  int length = roots != nullptr ? roots->length() : 0;\n+  for (int i = 0; i < length; i++) {\n+    if (UseCompressedOops) {\n+      relocate_root_at<narrowOop>(requested_roots, i);\n+    } else {\n+      relocate_root_at<oop>(requested_roots, i);\n+    }\n+  }\n+\n+  closed_bitmaps->append(make_bitmap_info(&closed_oopmap, \/*is_open=*\/false, \/*is_oopmap=*\/true));\n+  open_bitmaps  ->append(make_bitmap_info(&open_oopmap,   \/*is_open=*\/false, \/*is_oopmap=*\/true));\n+\n+  closed_bitmaps->append(compute_ptrmap(\/*is_open=*\/false));\n+  open_bitmaps  ->append(compute_ptrmap(\/*is_open=*\/true));\n+\n+  _closed_oopmap = nullptr;\n+  _open_oopmap = nullptr;\n+}\n+\n+ArchiveHeapBitmapInfo ArchiveHeapWriter::make_bitmap_info(ResourceBitMap* bitmap, bool is_open,  bool is_oopmap) {\n+  size_t size_in_bits = bitmap->size();\n+  size_t size_in_bytes;\n+  uintptr_t* buffer;\n+\n+  if (size_in_bits > 0) {\n+    size_in_bytes = bitmap->size_in_bytes();\n+    buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n+    bitmap->write_to(buffer, size_in_bytes);\n+  } else {\n+    size_in_bytes = 0;\n+    buffer = nullptr;\n+  }\n+\n+  log_info(cds, heap)(\"%s @ \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for %s heap region\",\n+                      is_oopmap ? \"Oopmap\" : \"Ptrmap\",\n+                      p2i(buffer), size_in_bytes,\n+                      is_open? \"open\" : \"closed\");\n+\n+  ArchiveHeapBitmapInfo info;\n+  info._map = (address)buffer;\n+  info._size_in_bits = size_in_bits;\n+  info._size_in_bytes = size_in_bytes;\n+\n+  return info;\n+}\n+\n+void ArchiveHeapWriter::mark_native_pointer(oop src_obj, int field_offset) {\n+  Metadata* ptr = src_obj->metadata_field_acquire(field_offset);\n+  if (ptr != nullptr) {\n+    NativePointerInfo info;\n+    info._src_obj = src_obj;\n+    info._field_offset = field_offset;\n+    _native_pointers->append(info);\n+  }\n+}\n+\n+ArchiveHeapBitmapInfo ArchiveHeapWriter::compute_ptrmap(bool is_open) {\n+  int num_non_null_ptrs = 0;\n+  Metadata** bottom = (Metadata**) (is_open ? _requested_open_region_bottom: _requested_closed_region_bottom);\n+  Metadata** top = (Metadata**) (is_open ? _requested_open_region_top: _requested_closed_region_top); \/\/ exclusive\n+  ResourceBitMap ptrmap(top - bottom);\n+\n+  for (int i = 0; i < _native_pointers->length(); i++) {\n+    NativePointerInfo info = _native_pointers->at(i);\n+    oop src_obj = info._src_obj;\n+    int field_offset = info._field_offset;\n+    HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n+    if (p->in_open_region() == is_open) {\n+      \/\/ requested_field_addr = the address of this field in the requested space\n+      oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n+      Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n+      assert(bottom <= requested_field_addr && requested_field_addr < top, \"range check\");\n+\n+      \/\/ Mark this field in the bitmap\n+      BitMap::idx_t idx = requested_field_addr - bottom;\n+      ptrmap.set_bit(idx);\n+      num_non_null_ptrs ++;\n+\n+      \/\/ Set the native pointer to the requested address of the metadata (at runtime, the metadata will have\n+      \/\/ this address if the RO\/RW regions are mapped at the default location).\n+\n+      Metadata** buffered_field_addr = requested_addr_to_buffered_addr(requested_field_addr);\n+      Metadata* native_ptr = *buffered_field_addr;\n+      assert(native_ptr != nullptr, \"sanity\");\n+\n+      address buffered_native_ptr = ArchiveBuilder::current()->get_buffered_addr((address)native_ptr);\n+      address requested_native_ptr = ArchiveBuilder::current()->to_requested(buffered_native_ptr);\n+      *buffered_field_addr = (Metadata*)requested_native_ptr;\n+    }\n+  }\n+\n+  log_info(cds, heap)(\"compute_ptrmap: marked %d non-null native pointers for %s heap region\",\n+                      num_non_null_ptrs, is_open ? \"open\" : \"closed\");\n+\n+  if (num_non_null_ptrs == 0) {\n+    ResourceBitMap empty;\n+    return make_bitmap_info(&empty, is_open, \/*is_oopmap=*\/ false);\n+  } else {\n+    return make_bitmap_info(&ptrmap, is_open, \/*is_oopmap=*\/ false);\n+  }\n+}\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":657,"deletions":0,"binary":false,"changes":657,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-volatile Thread* ClassListParser::_parsing_thread = NULL;\n-ClassListParser* ClassListParser::_instance = NULL;\n+volatile Thread* ClassListParser::_parsing_thread = nullptr;\n+ClassListParser* ClassListParser::_instance = nullptr;\n@@ -61,1 +61,1 @@\n-  _file = NULL;\n+  _file = nullptr;\n@@ -70,1 +70,1 @@\n-  if (_file == NULL) {\n+  if (_file == nullptr) {\n@@ -81,1 +81,1 @@\n-  assert(_instance == NULL, \"must be singleton\");\n+  assert(_instance == nullptr, \"must be singleton\");\n@@ -91,1 +91,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -94,1 +94,1 @@\n-  Atomic::store(&_parsing_thread, (Thread*)NULL);\n+  Atomic::store(&_parsing_thread, (Thread*)nullptr);\n@@ -97,1 +97,1 @@\n-  _instance = NULL;\n+  _instance = nullptr;\n@@ -133,1 +133,1 @@\n-      if (message != NULL) {\n+      if (message != nullptr) {\n@@ -144,1 +144,1 @@\n-    assert(klass != NULL, \"sanity\");\n+    assert(klass != nullptr, \"sanity\");\n@@ -168,1 +168,1 @@\n-    if (fgets(_line, sizeof(_line), _file) == NULL) {\n+    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n@@ -210,1 +210,1 @@\n-  _source = NULL;\n+  _source = nullptr;\n@@ -219,1 +219,1 @@\n-  if ((_token = strchr(_line, ' ')) == NULL) {\n+  if ((_token = strchr(_line, ' ')) == nullptr) {\n@@ -245,1 +245,1 @@\n-      if (s == NULL) {\n+      if (s == nullptr) {\n@@ -287,1 +287,1 @@\n-  if ((ptr = strchr(_line, ' ')) == NULL) {\n+  if ((ptr = strchr(_line, ' ')) == nullptr) {\n@@ -448,1 +448,1 @@\n-  vm_exit_during_initialization(\"class list format error.\", NULL);\n+  vm_exit_during_initialization(\"class list format error.\", nullptr);\n@@ -551,1 +551,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -647,1 +647,1 @@\n-    assert(obj != NULL, \"jdk.internal.loader.BuiltinClassLoader::loadClass never returns null\");\n+    assert(obj != nullptr, \"jdk.internal.loader.BuiltinClassLoader::loadClass never returns null\");\n@@ -655,1 +655,1 @@\n-  assert(klass != NULL, \"exception should have been thrown\");\n+  assert(klass != nullptr, \"exception should have been thrown\");\n@@ -676,1 +676,1 @@\n-  return (_source != NULL);\n+  return (_source != nullptr);\n@@ -681,1 +681,1 @@\n-  if (klass_ptr == NULL) {\n+  if (klass_ptr == nullptr) {\n@@ -684,1 +684,1 @@\n-  assert(*klass_ptr != NULL, \"must be\");\n+  assert(*klass_ptr != nullptr, \"must be\");\n@@ -691,1 +691,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -705,1 +705,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -728,1 +728,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };\n+\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return nullptr}; };\n@@ -157,1 +157,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -220,1 +220,1 @@\n-CppVtableInfo** CppVtables::_index = NULL;\n+CppVtableInfo** CppVtables::_index = nullptr;\n@@ -285,1 +285,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -94,1 +95,1 @@\n-  vm_exit_during_initialization(\"Unable to use shared archive.\", NULL);\n+  vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n@@ -248,1 +249,1 @@\n-    assert(_current_info == NULL, \"must be singleton\"); \/\/ not thread safe\n+    assert(_current_info == nullptr, \"must be singleton\"); \/\/ not thread safe\n@@ -251,1 +252,1 @@\n-    assert(_dynamic_archive_info == NULL, \"must be singleton\"); \/\/ not thread safe\n+    assert(_dynamic_archive_info == nullptr, \"must be singleton\"); \/\/ not thread safe\n@@ -259,1 +260,1 @@\n-    _current_info = NULL;\n+    _current_info = nullptr;\n@@ -262,1 +263,1 @@\n-    _dynamic_archive_info = NULL;\n+    _dynamic_archive_info = nullptr;\n@@ -275,1 +276,1 @@\n-  assert(_header == NULL, \"Sanity check\");\n+  assert(_header == nullptr, \"Sanity check\");\n@@ -498,1 +499,1 @@\n-  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != NULL) {\n+  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != nullptr) {\n@@ -631,1 +632,1 @@\n-  assert(jrt != NULL,\n+  assert(jrt != nullptr,\n@@ -634,1 +635,1 @@\n-  if (_saved_shared_path_table_array != NULL) {\n+  if (_saved_shared_path_table_array != nullptr) {\n@@ -636,1 +637,1 @@\n-    _saved_shared_path_table_array = NULL;\n+    _saved_shared_path_table_array = nullptr;\n@@ -648,1 +649,1 @@\n-  assert(jrt != NULL,\n+  assert(jrt != nullptr,\n@@ -669,1 +670,1 @@\n-  while (cpe != NULL) {\n+  while (cpe != nullptr) {\n@@ -713,1 +714,1 @@\n-    ClassLoader::exit_with_path_failure(\"Cannot have non-empty directory in paths\", NULL);\n+    ClassLoader::exit_with_path_failure(\"Cannot have non-empty directory in paths\", nullptr);\n@@ -720,1 +721,1 @@\n-  if (_non_existent_class_paths == NULL) {\n+  if (_non_existent_class_paths == nullptr) {\n@@ -728,1 +729,1 @@\n-  if (_non_existent_class_paths != NULL) {\n+  if (_non_existent_class_paths != nullptr) {\n@@ -799,1 +800,1 @@\n-        if (value != NULL) {\n+        if (value != nullptr) {\n@@ -801,1 +802,1 @@\n-          if (strstr((char*)attr, \"-Digest\") != NULL) {\n+          if (strstr((char*)attr, \"-Digest\") != nullptr) {\n@@ -822,1 +823,1 @@\n-  if (manifest != NULL) {\n+  if (manifest != nullptr) {\n@@ -843,1 +844,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -860,1 +861,1 @@\n-  if (path == NULL) {\n+  if (path == nullptr) {\n@@ -865,1 +866,1 @@\n-  while (p != NULL) {\n+  while (p != nullptr) {\n@@ -868,1 +869,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -898,1 +899,1 @@\n-  while (cpe != NULL) {\n+  while (cpe != nullptr) {\n@@ -919,2 +920,2 @@\n-      if (canonical_path != NULL) {\n-        char* error_msg = NULL;\n+      if (canonical_path != nullptr) {\n+        char* error_msg = nullptr;\n@@ -922,1 +923,1 @@\n-        if (zip != NULL && error_msg == NULL) {\n+        if (zip != nullptr && error_msg == nullptr) {\n@@ -1009,1 +1010,1 @@\n-  if (dp_len == 0 && rp == NULL) {\n+  if (dp_len == 0 && rp == nullptr) {\n@@ -1011,1 +1012,1 @@\n-  } else if (dp_len == 0 && rp != NULL) {\n+  } else if (dp_len == 0 && rp != nullptr) {\n@@ -1022,1 +1023,1 @@\n-  } else if (dp_len > 0 && rp != NULL) {\n+  } else if (dp_len > 0 && rp != nullptr) {\n@@ -1054,1 +1055,1 @@\n-  assert(appcp != NULL, \"NULL app classpath\");\n+  assert(appcp != nullptr, \"null app classpath\");\n@@ -1179,1 +1180,1 @@\n-        if (_dynamic_archive_info != NULL && _dynamic_archive_info->_is_static) {\n+        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n@@ -1188,1 +1189,1 @@\n-        if (_dynamic_archive_info != NULL && _dynamic_archive_info->_is_static) {\n+        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n@@ -1214,1 +1215,1 @@\n-  if (_classpath_entries_for_jvmti != NULL) {\n+  if (_classpath_entries_for_jvmti != nullptr) {\n@@ -1279,1 +1280,1 @@\n-    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    assert(_archive_name != nullptr, \"Archive name is null\");\n@@ -1290,1 +1291,1 @@\n-    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    assert(_archive_name != nullptr, \"Archive name is null\");\n@@ -1428,1 +1429,1 @@\n-\/\/ true && (*base_archive_name) == NULL:\n+\/\/ true && (*base_archive_name) == nullptr:\n@@ -1430,1 +1431,1 @@\n-\/\/ true && (*base_archive_name) != NULL:\n+\/\/ true && (*base_archive_name) != nullptr:\n@@ -1435,1 +1436,1 @@\n-  *base_archive_name = NULL;\n+  *base_archive_name = nullptr;\n@@ -1639,1 +1640,1 @@\n-  _mapped_base = NULL;\n+  _mapped_base = nullptr;\n@@ -1701,1 +1702,1 @@\n-    requested_base = NULL; \/\/ always NULL for bm region\n+    requested_base = nullptr; \/\/ always null for bm region\n@@ -1704,1 +1705,1 @@\n-    requested_base = NULL;\n+    requested_base = nullptr;\n@@ -1706,0 +1707,2 @@\n+    assert(HeapShared::can_write(), \"sanity\");\n+#if INCLUDE_CDS_JAVA_HEAP\n@@ -1707,1 +1710,1 @@\n-    requested_base = base;\n+    requested_base = (char*)ArchiveHeapWriter::heap_region_requested_bottom(region);\n@@ -1709,1 +1712,1 @@\n-      mapping_offset = (size_t)((address)base - CompressedOops::base());\n+      mapping_offset = (size_t)((address)requested_base - CompressedOops::base());\n@@ -1716,0 +1719,1 @@\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n@@ -1734,1 +1738,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -1762,1 +1766,1 @@\n-  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n@@ -1771,1 +1775,1 @@\n-  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n@@ -1816,1 +1820,1 @@\n-  int arr_len = regions == NULL ? 0 : regions->length();\n+  int arr_len = regions == nullptr ? 0 : regions->length();\n@@ -1827,1 +1831,1 @@\n-    char* start = NULL;\n+    char* start = nullptr;\n@@ -1924,1 +1928,1 @@\n-  if (base == NULL) {\n+  if (base == nullptr) {\n@@ -1941,1 +1945,1 @@\n-  DEBUG_ONLY(FileMapRegion* last_region = NULL);\n+  DEBUG_ONLY(FileMapRegion* last_region = nullptr);\n@@ -1955,1 +1959,1 @@\n-    DEBUG_ONLY(if (last_region != NULL) {\n+    DEBUG_ONLY(if (last_region != nullptr) {\n@@ -2004,2 +2008,2 @@\n-  assert(r->mapped_base() == NULL, \"must be not mapped yet\");\n-  assert(requested_addr != NULL, \"must be specified\");\n+  assert(r->mapped_base() == nullptr, \"must be not mapped yet\");\n+  assert(requested_addr != nullptr, \"must be specified\");\n@@ -2058,1 +2062,1 @@\n-  if (r->mapped_base() != NULL) {\n+  if (r->mapped_base() != nullptr) {\n@@ -2062,1 +2066,1 @@\n-  char* requested_addr = NULL; \/\/ allow OS to pick any location\n+  char* requested_addr = nullptr; \/\/ allow OS to pick any location\n@@ -2065,1 +2069,1 @@\n-  if (bitmap_base == NULL) {\n+  if (bitmap_base == nullptr) {\n@@ -2067,1 +2071,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2075,1 +2079,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2093,1 +2097,1 @@\n-  if (bitmap_base == NULL) {\n+  if (bitmap_base == nullptr) {\n@@ -2154,2 +2158,2 @@\n-static MemRegion *closed_heap_regions = NULL;\n-static MemRegion *open_heap_regions = NULL;\n+static MemRegion *closed_heap_regions = nullptr;\n+static MemRegion *open_heap_regions = nullptr;\n@@ -2170,1 +2174,1 @@\n-  address end   = NULL;\n+  address end   = nullptr;\n@@ -2190,1 +2194,1 @@\n-  assert(end != NULL, \"must have at least one used heap region\");\n+  assert(end != nullptr, \"must have at least one used heap region\");\n@@ -2393,1 +2397,1 @@\n-    if (bitmap_base == NULL) {\n+    if (bitmap_base == nullptr) {\n@@ -2421,1 +2425,1 @@\n-    assert(closed_heap_regions == NULL &&\n+    assert(closed_heap_regions == nullptr &&\n@@ -2426,1 +2430,1 @@\n-    assert(open_heap_regions == NULL && num_open_heap_regions == 0, \"sanity\");\n+    assert(open_heap_regions == nullptr && num_open_heap_regions == 0, \"sanity\");\n@@ -2487,1 +2491,1 @@\n-    if (base == NULL || base != addr) {\n+    if (base == nullptr || base != addr) {\n@@ -2537,1 +2541,1 @@\n-  assert(bitmap_base != NULL, \"must have already been mapped\");\n+  assert(bitmap_base != nullptr, \"must have already been mapped\");\n@@ -2554,1 +2558,1 @@\n-  \/\/ Note that closed_heap_regions may be non-NULL even if no regions were found.\n+  \/\/ Note that closed_heap_regions may be non-null even if no regions were found.\n@@ -2556,1 +2560,1 @@\n-    assert(closed_heap_regions != NULL,\n+    assert(closed_heap_regions != nullptr,\n@@ -2569,1 +2573,1 @@\n-    assert(open_heap_regions != NULL, \"NULL open_heap_regions array with non-zero count\");\n+    assert(open_heap_regions != nullptr, \"Null open_heap_regions array with non-zero count\");\n@@ -2585,1 +2589,1 @@\n-    assert(regions != NULL, \"Null archive regions array with non-zero count\");\n+    assert(regions != nullptr, \"Null archive regions array with non-zero count\");\n@@ -2626,1 +2630,1 @@\n-  if (mapped_base != NULL) {\n+  if (mapped_base != nullptr) {\n@@ -2634,1 +2638,1 @@\n-    r->set_mapped_base(NULL);\n+    r->set_mapped_base(nullptr);\n@@ -2652,2 +2656,2 @@\n-FileMapInfo* FileMapInfo::_current_info = NULL;\n-FileMapInfo* FileMapInfo::_dynamic_archive_info = NULL;\n+FileMapInfo* FileMapInfo::_current_info = nullptr;\n+FileMapInfo* FileMapInfo::_dynamic_archive_info = nullptr;\n@@ -2657,1 +2661,1 @@\n-Array<u8>*      FileMapInfo::_saved_shared_path_table_array = NULL;\n+Array<u8>*      FileMapInfo::_saved_shared_path_table_array = nullptr;\n@@ -2660,1 +2664,1 @@\n-GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = NULL;\n+GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = nullptr;\n@@ -2753,1 +2757,1 @@\n-  if (prop != NULL) {\n+  if (prop != nullptr) {\n@@ -2829,24 +2833,1 @@\n-\/\/ Unmap mapped regions of shared space.\n-void FileMapInfo::stop_sharing_and_unmap(const char* msg) {\n-  MetaspaceShared::set_shared_metaspace_range(NULL, NULL, NULL);\n-\n-  FileMapInfo *map_info = FileMapInfo::current_info();\n-  if (map_info) {\n-    map_info->fail_continue(\"%s\", msg);\n-    for (int i = 0; i < MetaspaceShared::num_non_heap_regions; i++) {\n-      if (!HeapShared::is_heap_region(i)) {\n-        map_info->unmap_region(i);\n-      }\n-    }\n-    \/\/ Dealloc the archive heap regions only without unmapping. The regions are part\n-    \/\/ of the java heap. Unmapping of the heap regions are managed by GC.\n-    map_info->dealloc_heap_regions(open_heap_regions,\n-                                   num_open_heap_regions);\n-    map_info->dealloc_heap_regions(closed_heap_regions,\n-                                   num_closed_heap_regions);\n-  } else if (DumpSharedSpaces) {\n-    fail_stop(\"%s\", msg);\n-  }\n-}\n-\n-ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = NULL;\n+ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = nullptr;\n@@ -2862,1 +2843,1 @@\n-  if (ent == NULL) {\n+  if (ent == nullptr) {\n@@ -2871,1 +2852,1 @@\n-      THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+      THROW_MSG_(vmSymbols::java_io_IOException(), msg, nullptr);\n@@ -2874,1 +2855,1 @@\n-      if (ent == NULL) {\n+      if (ent == nullptr) {\n@@ -2877,1 +2858,1 @@\n-        THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+        THROW_MSG_(vmSymbols::java_io_IOException(), msg, nullptr);\n@@ -2882,1 +2863,1 @@\n-    if (_classpath_entries_for_jvmti[i] == NULL) {\n+    if (_classpath_entries_for_jvmti[i] == nullptr) {\n@@ -2900,1 +2881,1 @@\n-  assert(cpe != NULL, \"must be\");\n+  assert(cpe != nullptr, \"must be\");\n@@ -2908,1 +2889,1 @@\n-  assert(cfs != NULL, \"must be able to read the classfile data of shared classes for built-in loaders.\");\n+  assert(cfs != nullptr, \"must be able to read the classfile data of shared classes for built-in loaders.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":92,"deletions":111,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    return (_manifest == NULL) ? NULL : (const char*)_manifest->data();\n+    return (_manifest == nullptr) ? nullptr : (const char*)_manifest->data();\n@@ -95,1 +95,1 @@\n-    return (_manifest == NULL) ? 0 : _manifest->length();\n+    return (_manifest == nullptr) ? 0 : _manifest->length();\n@@ -119,1 +119,1 @@\n-  SharedPathTable() : _table(NULL), _size(0) {}\n+  SharedPathTable() : _table(nullptr), _size(0) {}\n@@ -130,1 +130,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -466,1 +466,1 @@\n-    NOT_CDS(return NULL;)\n+    NOT_CDS(return nullptr;)\n@@ -475,1 +475,1 @@\n-    NOT_CDS(return NULL;)\n+    NOT_CDS(return nullptr;)\n@@ -529,3 +529,0 @@\n-  \/\/ Stop CDS sharing and unmap CDS regions.\n-  static void stop_sharing_and_unmap(const char* msg);\n-\n@@ -598,1 +595,1 @@\n-  char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(NULL);\n+  char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(nullptr);\n@@ -601,2 +598,2 @@\n-  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(NULL);\n-  GrowableArray<const char*>* create_path_array(const char* path) NOT_CDS_RETURN_(NULL);\n+  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(nullptr);\n+  GrowableArray<const char*>* create_path_array(const char* path) NOT_CDS_RETURN_(nullptr);\n@@ -627,3 +624,3 @@\n-  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -80,0 +81,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -86,3 +88,0 @@\n-#if INCLUDE_G1GC\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#endif\n@@ -95,1 +94,1 @@\n-void* MetaspaceShared::_shared_metaspace_static_top = NULL;\n+void* MetaspaceShared::_shared_metaspace_static_top = nullptr;\n@@ -190,1 +189,1 @@\n-    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+    for (Klass* klass = cld->klasses(); klass != nullptr; klass = klass->next_link()) {\n@@ -211,1 +210,1 @@\n-  if (specified_base != NULL && aligned_base < specified_base) {\n+  if (specified_base != nullptr && aligned_base < specified_base) {\n@@ -228,1 +227,1 @@\n-  const char* err = NULL;\n+  const char* err = nullptr;\n@@ -287,1 +286,1 @@\n-        if (FileMapInfo::dynamic_info() == NULL) {\n+        if (FileMapInfo::dynamic_info() == nullptr) {\n@@ -299,2 +298,2 @@\n-static GrowableArrayCHeap<OopHandle, mtClassShared>* _extra_interned_strings = NULL;\n-static GrowableArrayCHeap<Symbol*, mtClassShared>* _extra_symbols = NULL;\n+static GrowableArrayCHeap<OopHandle, mtClassShared>* _extra_interned_strings = nullptr;\n+static GrowableArrayCHeap<Symbol*, mtClassShared>* _extra_symbols = nullptr;\n@@ -335,11 +334,5 @@\n-#if INCLUDE_G1GC\n-        if (UseG1GC) {\n-          typeArrayOop body = java_lang_String::value(str);\n-          const HeapRegion* hr = G1CollectedHeap::heap()->heap_region_containing(body);\n-          if (hr->is_humongous()) {\n-            \/\/ Don't keep it alive, so it will be GC'ed before we dump the strings, in order\n-            \/\/ to maximize free heap space and minimize fragmentation.\n-            log_warning(cds, heap)(\"[line %d] extra interned string ignored; size too large: %d\",\n-                                reader.last_line_no(), utf8_length);\n-            continue;\n-          }\n+#if INCLUDE_CDS_JAVA_HEAP\n+        if (ArchiveHeapWriter::is_string_too_large_to_archive(str)) {\n+          log_warning(cds, heap)(\"[line %d] extra interned string ignored; size too large: %d\",\n+                                 reader.last_line_no(), utf8_length);\n+          continue;\n@@ -347,2 +340,1 @@\n-#endif\n-        assert(str != NULL, \"must succeed\");\n+        assert(str != nullptr, \"must succeed\");\n@@ -351,0 +343,1 @@\n+#endif\n@@ -440,1 +433,1 @@\n-class VM_PopulateDumpSharedSpace : public VM_GC_Operation {\n+class VM_PopulateDumpSharedSpace : public VM_Operation {\n@@ -449,5 +442,0 @@\n-  void dump_heap_bitmaps() NOT_CDS_JAVA_HEAP_RETURN;\n-  void dump_heap_bitmaps(GrowableArray<MemRegion>* regions,\n-                         GrowableArray<ArchiveHeapBitmapInfo>* bitmaps);\n-  void dump_one_heap_bitmap(MemRegion region, GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n-                            ResourceBitMap bitmap, bool is_oopmap);\n@@ -462,6 +450,5 @@\n-  VM_PopulateDumpSharedSpace() :\n-    VM_GC_Operation(0 \/* total collections, ignored *\/, GCCause::_archive_time_gc),\n-    _closed_heap_regions(NULL),\n-    _open_heap_regions(NULL),\n-    _closed_heap_bitmaps(NULL),\n-    _open_heap_bitmaps(NULL) {}\n+  VM_PopulateDumpSharedSpace() : VM_Operation(),\n+    _closed_heap_regions(nullptr),\n+    _open_heap_regions(nullptr),\n+    _closed_heap_bitmaps(nullptr),\n+    _open_heap_bitmaps(nullptr) {}\n@@ -491,1 +478,1 @@\n-    if (_extra_symbols != NULL) {\n+    if (_extra_symbols != nullptr) {\n@@ -512,3 +499,0 @@\n-  \/\/ Write the bitmaps for patching the archive heap regions\n-  dump_heap_bitmaps();\n-\n@@ -519,2 +503,0 @@\n-  HeapShared::run_full_gc_in_vm_thread();\n-\n@@ -629,1 +611,1 @@\n-    \/\/ tolerate this. (Note that unregistered classes are loaded by the NULL\n+    \/\/ tolerate this. (Note that unregistered classes are loaded by the null\n@@ -667,1 +649,1 @@\n-      for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+      for (Klass* klass = cld->klasses(); klass != nullptr; klass = klass->next_link()) {\n@@ -745,1 +727,1 @@\n-    if (end != NULL) *end = '\\0';\n+    if (end != nullptr) *end = '\\0';\n@@ -770,1 +752,1 @@\n-  if (SharedClassListFile == NULL) {\n+  if (SharedClassListFile == nullptr) {\n@@ -824,3 +806,4 @@\n-    if (use_full_module_graph()) {\n-      HeapShared::reset_archived_object_states(CHECK);\n-    }\n+  ArchiveHeapWriter::init();\n+  if (use_full_module_graph()) {\n+    HeapShared::reset_archived_object_states(CHECK);\n+  }\n@@ -841,1 +824,1 @@\n-    if (ik->is_shared_unregistered_class() && ik->class_loader() == NULL) {\n+    if (ik->is_shared_unregistered_class() && ik->class_loader() == nullptr) {\n@@ -843,1 +826,1 @@\n-      \/\/ for non-system classes. Since we are using the NULL classloader\n+      \/\/ for non-system classes. Since we are using the null classloader\n@@ -888,1 +871,1 @@\n-  if (_extra_interned_strings != NULL) {\n+  if (_extra_interned_strings != nullptr) {\n@@ -899,1 +882,4 @@\n-  HeapShared::archive_objects(_closed_heap_regions, _open_heap_regions);\n+  _closed_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n+  _open_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n+  HeapShared::archive_objects(_closed_heap_regions, _open_heap_regions,\n+                              _closed_heap_bitmaps, _open_heap_bitmaps);\n@@ -903,50 +889,0 @@\n-\n-void VM_PopulateDumpSharedSpace::dump_heap_bitmaps() {\n-  if (HeapShared::can_write()) {\n-    _closed_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n-    dump_heap_bitmaps(_closed_heap_regions, _closed_heap_bitmaps);\n-\n-    _open_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n-    dump_heap_bitmaps(_open_heap_regions, _open_heap_bitmaps);\n-  }\n-}\n-\n-void VM_PopulateDumpSharedSpace::dump_heap_bitmaps(GrowableArray<MemRegion>* regions,\n-                                                   GrowableArray<ArchiveHeapBitmapInfo>* bitmaps) {\n-  for (int i = 0; i < regions->length(); i++) {\n-    MemRegion region = regions->at(i);\n-    ResourceBitMap oopmap = HeapShared::calculate_oopmap(region);\n-    ResourceBitMap ptrmap = HeapShared::calculate_ptrmap(region);\n-    dump_one_heap_bitmap(region, bitmaps, oopmap, true);\n-    dump_one_heap_bitmap(region, bitmaps, ptrmap, false);\n-  }\n-}\n-\n-void VM_PopulateDumpSharedSpace::dump_one_heap_bitmap(MemRegion region,\n-                                                      GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n-                                                      ResourceBitMap bitmap, bool is_oopmap) {\n-  size_t size_in_bits = bitmap.size();\n-  size_t size_in_bytes;\n-  uintptr_t* buffer;\n-\n-  if (size_in_bits > 0) {\n-    size_in_bytes = bitmap.size_in_bytes();\n-    buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n-    bitmap.write_to(buffer, size_in_bytes);\n-  } else {\n-    size_in_bytes = 0;\n-    buffer = NULL;\n-  }\n-\n-  log_info(cds, heap)(\"%s = \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for heap region \"\n-                      INTPTR_FORMAT \" (\" SIZE_FORMAT_W(8) \" bytes)\",\n-                      is_oopmap ? \"Oopmap\" : \"Ptrmap\",\n-                      p2i(buffer), size_in_bytes,\n-                      p2i(region.start()), region.byte_size());\n-\n-  ArchiveHeapBitmapInfo info;\n-  info._map = (address)buffer;\n-  info._size_in_bits = size_in_bits;\n-  info._size_in_bytes = size_in_bytes;\n-  bitmaps->append(info);\n-}\n@@ -975,1 +911,1 @@\n-  FileMapInfo* dynamic_mapinfo = NULL;\n+  FileMapInfo* dynamic_mapinfo = nullptr;\n@@ -977,1 +913,1 @@\n-  if (static_mapinfo != NULL) {\n+  if (static_mapinfo != nullptr) {\n@@ -992,1 +928,1 @@\n-    bool dynamic_mapped = (dynamic_mapinfo != NULL && dynamic_mapinfo->is_mapped());\n+    bool dynamic_mapped = (dynamic_mapinfo != nullptr && dynamic_mapinfo->is_mapped());\n@@ -995,0 +931,2 @@\n+    \/\/ Register CDS memory region with LSan.\n+    LSAN_REGISTER_ROOT_REGION(cds_base, cds_end - cds_base);\n@@ -1006,1 +944,1 @@\n-    set_shared_metaspace_range(NULL, NULL, NULL);\n+    set_shared_metaspace_range(nullptr, nullptr, nullptr);\n@@ -1020,1 +958,1 @@\n-  if (static_mapinfo != NULL && !static_mapinfo->is_mapped()) {\n+  if (static_mapinfo != nullptr && !static_mapinfo->is_mapped()) {\n@@ -1023,1 +961,1 @@\n-  if (dynamic_mapinfo != NULL && !dynamic_mapinfo->is_mapped()) {\n+  if (dynamic_mapinfo != nullptr && !dynamic_mapinfo->is_mapped()) {\n@@ -1030,1 +968,1 @@\n-  assert(static_archive != nullptr, \"SharedArchivePath is NULL\");\n+  assert(static_archive != nullptr, \"SharedArchivePath is nullptr\");\n@@ -1034,1 +972,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1041,1 +979,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1045,1 +983,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1051,1 +989,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1061,1 +999,1 @@\n-  if (use_requested_addr && static_mapinfo->requested_base_address() == NULL) {\n+  if (use_requested_addr && static_mapinfo->requested_base_address() == nullptr) {\n@@ -1079,1 +1017,1 @@\n-  if (dynamic_mapinfo != NULL) {\n+  if (dynamic_mapinfo != nullptr) {\n@@ -1093,1 +1031,1 @@\n-  if (mapped_base_address == NULL) {\n+  if (mapped_base_address == nullptr) {\n@@ -1168,1 +1106,1 @@\n-        assert(dynamic_mapinfo != NULL && !dynamic_mapinfo->is_mapped(), \"must have failed\");\n+        assert(dynamic_mapinfo != nullptr && !dynamic_mapinfo->is_mapped(), \"must have failed\");\n@@ -1273,1 +1211,1 @@\n-\/\/ - On error: NULL is returned and the spaces remain unreserved.\n+\/\/ - On error: null is returned and the spaces remain unreserved.\n@@ -1281,1 +1219,1 @@\n-  address const base_address = (address) (use_archive_base_addr ? static_mapinfo->requested_base_address() : NULL);\n+  address const base_address = (address) (use_archive_base_addr ? static_mapinfo->requested_base_address() : nullptr);\n@@ -1286,1 +1224,1 @@\n-  size_t archive_end_offset  = (dynamic_mapinfo == NULL) ? static_mapinfo->mapping_end_offset() : dynamic_mapinfo->mapping_end_offset();\n+  size_t archive_end_offset  = (dynamic_mapinfo == nullptr) ? static_mapinfo->mapping_end_offset() : dynamic_mapinfo->mapping_end_offset();\n@@ -1290,1 +1228,1 @@\n-  if (base_address != NULL) {\n+  if (base_address != nullptr) {\n@@ -1305,1 +1243,1 @@\n-      assert(base_address == NULL ||\n+      assert(base_address == nullptr ||\n@@ -1311,1 +1249,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1358,1 +1296,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1370,1 +1308,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1374,1 +1312,1 @@\n-    assert(base_address == NULL || (address)total_space_rs.base() == base_address,\n+    assert(base_address == nullptr || (address)total_space_rs.base() == base_address,\n@@ -1401,1 +1339,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1429,1 +1367,1 @@\n-  if (mapinfo == NULL) {\n+  if (mapinfo == nullptr) {\n@@ -1459,1 +1397,1 @@\n-  if (mapinfo != NULL) {\n+  if (mapinfo != nullptr) {\n@@ -1508,1 +1446,1 @@\n-  if (dynamic_mapinfo != NULL) {\n+  if (dynamic_mapinfo != nullptr) {\n@@ -1546,1 +1484,1 @@\n-    if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {\n+    if (FileMapInfo::current_info() == nullptr || _archive_loading_failed) {\n@@ -1566,1 +1504,1 @@\n-    if (FileMapInfo::dynamic_info() != NULL) {\n+    if (FileMapInfo::dynamic_info() != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":71,"deletions":133,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,1 @@\n-  for (BCEscapeAnalyzer* scope = this; scope != NULL; scope = scope->_parent) {\n+  for (BCEscapeAnalyzer* scope = this; scope != nullptr; scope = scope->_parent) {\n@@ -299,1 +299,1 @@\n-  ciMethod* inline_target = NULL;\n+  ciMethod* inline_target = nullptr;\n@@ -311,1 +311,1 @@\n-  if (inline_target != NULL && !is_recursive_call(inline_target)) {\n+  if (inline_target != nullptr && !is_recursive_call(inline_target)) {\n@@ -897,1 +897,1 @@\n-          ciSignature* declared_signature = NULL;\n+          ciSignature* declared_signature = nullptr;\n@@ -900,1 +900,1 @@\n-          assert(declared_signature != NULL, \"cannot be null\");\n+          assert(declared_signature != nullptr, \"cannot be null\");\n@@ -1127,2 +1127,2 @@\n-  GrowableArray<ciBlock *> worklist(arena, numblocks \/ 4, 0, NULL);\n-  GrowableArray<ciBlock *> successors(arena, 4, 0, NULL);\n+  GrowableArray<ciBlock *> worklist(arena, numblocks \/ 4, 0, nullptr);\n+  GrowableArray<ciBlock *> successors(arena, 4, 0, nullptr);\n@@ -1461,1 +1461,1 @@\n-    , _conservative(method == NULL || !EstimateArgEscape)\n+    , _conservative(method == nullptr || !EstimateArgEscape)\n@@ -1463,1 +1463,1 @@\n-    , _methodData(method ? method->method_data() : NULL)\n+    , _methodData(method ? method->method_data() : nullptr)\n@@ -1472,1 +1472,1 @@\n-    , _dependencies(_arena, 4, 0, NULL)\n+    , _dependencies(_arena, 4, 0, nullptr)\n@@ -1474,1 +1474,1 @@\n-    , _level(parent == NULL ? 0 : parent->level() + 1) {\n+    , _level(parent == nullptr ? 0 : parent->level() + 1) {\n@@ -1483,1 +1483,1 @@\n-    if (methodData() == NULL)\n+    if (methodData() == nullptr)\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-#define VM_CLASS_DEFN(name, ignore_s) ciInstanceKlass* ciEnv::_##name = NULL;\n+#define VM_CLASS_DEFN(name, ignore_s) ciInstanceKlass* ciEnv::_##name = nullptr;\n@@ -99,3 +99,3 @@\n-ciSymbol*        ciEnv::_unloaded_cisymbol = NULL;\n-ciInstanceKlass* ciEnv::_unloaded_ciinstance_klass = NULL;\n-ciObjArrayKlass* ciEnv::_unloaded_ciobjarrayklass = NULL;\n+ciSymbol*        ciEnv::_unloaded_cisymbol = nullptr;\n+ciInstanceKlass* ciEnv::_unloaded_ciinstance_klass = nullptr;\n+ciObjArrayKlass* ciEnv::_unloaded_ciobjarrayklass = nullptr;\n@@ -103,3 +103,3 @@\n-jobject ciEnv::_ArrayIndexOutOfBoundsException_handle = NULL;\n-jobject ciEnv::_ArrayStoreException_handle = NULL;\n-jobject ciEnv::_ClassCastException_handle = NULL;\n+jobject ciEnv::_ArrayIndexOutOfBoundsException_handle = nullptr;\n+jobject ciEnv::_ArrayStoreException_handle = nullptr;\n+jobject ciEnv::_ClassCastException_handle = nullptr;\n@@ -121,4 +121,4 @@\n-  _oop_recorder = NULL;\n-  _debug_info = NULL;\n-  _dependencies = NULL;\n-  _failure_reason = NULL;\n+  _oop_recorder = nullptr;\n+  _debug_info = nullptr;\n+  _dependencies = nullptr;\n+  _failure_reason = nullptr;\n@@ -128,1 +128,1 @@\n-  _compiler_data = NULL;\n+  _compiler_data = nullptr;\n@@ -134,2 +134,2 @@\n-  assert(task == NULL || thread->task() == task, \"sanity\");\n-  if (task != NULL) {\n+  assert(task == nullptr || thread->task() == task, \"sanity\");\n+  if (task != nullptr) {\n@@ -139,1 +139,1 @@\n-  _log = NULL;\n+  _log = nullptr;\n@@ -142,1 +142,1 @@\n-  _name_buffer = NULL;\n+  _name_buffer = nullptr;\n@@ -157,1 +157,1 @@\n-  assert(o != NULL, \"should have been initialized\");\n+  assert(o != nullptr, \"should have been initialized\");\n@@ -160,1 +160,1 @@\n-  assert(o != NULL, \"should have been initialized\");\n+  assert(o != nullptr, \"should have been initialized\");\n@@ -163,5 +163,5 @@\n-  _ArrayIndexOutOfBoundsException_instance = NULL;\n-  _ArrayStoreException_instance = NULL;\n-  _ClassCastException_instance = NULL;\n-  _the_null_string = NULL;\n-  _the_min_jint_string = NULL;\n+  _ArrayIndexOutOfBoundsException_instance = nullptr;\n+  _ArrayStoreException_instance = nullptr;\n+  _ClassCastException_instance = nullptr;\n+  _the_null_string = nullptr;\n+  _the_min_jint_string = nullptr;\n@@ -175,2 +175,2 @@\n-  _dyno_klasses = NULL;\n-  _dyno_locs = NULL;\n+  _dyno_klasses = nullptr;\n+  _dyno_locs = nullptr;\n@@ -246,1 +246,1 @@\n-  assert(current_thread->env() == NULL, \"must be\");\n+  assert(current_thread->env() == nullptr, \"must be\");\n@@ -250,4 +250,4 @@\n-  _oop_recorder = NULL;\n-  _debug_info = NULL;\n-  _dependencies = NULL;\n-  _failure_reason = NULL;\n+  _oop_recorder = nullptr;\n+  _debug_info = nullptr;\n+  _dependencies = nullptr;\n+  _failure_reason = nullptr;\n@@ -257,1 +257,1 @@\n-  _compiler_data = NULL;\n+  _compiler_data = nullptr;\n@@ -264,2 +264,2 @@\n-  _task = NULL;\n-  _log = NULL;\n+  _task = nullptr;\n+  _log = nullptr;\n@@ -268,1 +268,1 @@\n-  _name_buffer = NULL;\n+  _name_buffer = nullptr;\n@@ -282,7 +282,7 @@\n-  _NullPointerException_instance = NULL;\n-  _ArithmeticException_instance = NULL;\n-  _ArrayIndexOutOfBoundsException_instance = NULL;\n-  _ArrayStoreException_instance = NULL;\n-  _ClassCastException_instance = NULL;\n-  _the_null_string = NULL;\n-  _the_min_jint_string = NULL;\n+  _NullPointerException_instance = nullptr;\n+  _ArithmeticException_instance = nullptr;\n+  _ArrayIndexOutOfBoundsException_instance = nullptr;\n+  _ArrayStoreException_instance = nullptr;\n+  _ClassCastException_instance = nullptr;\n+  _the_null_string = nullptr;\n+  _the_min_jint_string = nullptr;\n@@ -296,2 +296,2 @@\n-  _dyno_klasses = NULL;\n-  _dyno_locs = NULL;\n+  _dyno_klasses = nullptr;\n+  _dyno_locs = nullptr;\n@@ -306,1 +306,1 @@\n-      current_thread->set_env(NULL);\n+      current_thread->set_env(nullptr);\n@@ -323,1 +323,1 @@\n-  return _task != NULL && _task->method()->is_old();\n+  return _task != nullptr && _task->method()->is_old();\n@@ -372,1 +372,1 @@\n-  if (handle == NULL) {\n+  if (handle == nullptr) {\n@@ -375,2 +375,2 @@\n-    jobject objh = NULL;\n-    if (ik != NULL) {\n+    jobject objh = nullptr;\n+    if (ik != nullptr) {\n@@ -388,1 +388,1 @@\n-  return obj == NULL? NULL: get_object(obj)->as_instance();\n+  return obj == nullptr? nullptr: get_object(obj)->as_instance();\n@@ -404,1 +404,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -409,1 +409,1 @@\n-  if (_ArrayIndexOutOfBoundsException_instance == NULL) {\n+  if (_ArrayIndexOutOfBoundsException_instance == nullptr) {\n@@ -417,1 +417,1 @@\n-  if (_ArrayStoreException_instance == NULL) {\n+  if (_ArrayStoreException_instance == nullptr) {\n@@ -425,1 +425,1 @@\n-  if (_ClassCastException_instance == NULL) {\n+  if (_ClassCastException_instance == nullptr) {\n@@ -434,1 +434,1 @@\n-  if (_the_null_string == NULL) {\n+  if (_the_null_string == nullptr) {\n@@ -442,1 +442,1 @@\n-  if (_the_min_jint_string == NULL) {\n+  if (_the_min_jint_string == nullptr) {\n@@ -463,1 +463,1 @@\n-  if (accessing_klass == NULL || !accessing_klass->is_loaded()) {\n+  if (accessing_klass == nullptr || !accessing_klass->is_loaded()) {\n@@ -507,2 +507,2 @@\n-  if (unloaded_klass != NULL) {\n-    if (require_local)  return NULL;\n+  if (unloaded_klass != nullptr) {\n+    if (require_local)  return nullptr;\n@@ -514,1 +514,1 @@\n-  if (accessing_klass != NULL) {\n+  if (accessing_klass != nullptr) {\n@@ -552,1 +552,1 @@\n-    if (elem_klass != NULL && elem_klass->is_loaded()) {\n+    if (elem_klass != nullptr && elem_klass->is_loaded()) {\n@@ -559,1 +559,1 @@\n-  if (found_klass == NULL && !cpool.is_null() && cpool->has_preresolution()) {\n+  if (found_klass == nullptr && !cpool.is_null() && cpool->has_preresolution()) {\n@@ -572,1 +572,1 @@\n-  if (found_klass != NULL) {\n+  if (found_klass != nullptr) {\n@@ -577,1 +577,1 @@\n-  if (require_local)  return NULL;\n+  if (require_local)  return nullptr;\n@@ -618,2 +618,2 @@\n-  Klass* klass = NULL;\n-  Symbol* klass_name = NULL;\n+  Klass* klass = nullptr;\n+  Symbol* klass_name = nullptr;\n@@ -627,1 +627,1 @@\n-    if (klass == NULL) {\n+    if (klass == nullptr) {\n@@ -632,1 +632,1 @@\n-  if (klass == NULL) {\n+  if (klass == nullptr) {\n@@ -642,1 +642,1 @@\n-               get_klass_by_name_impl(accessor, cpool, k->name(), true) == NULL) {\n+               get_klass_by_name_impl(accessor, cpool, k->name(), true) == nullptr) {\n@@ -656,1 +656,1 @@\n-  if (unloaded_klass != NULL) {\n+  if (unloaded_klass != nullptr) {\n@@ -723,1 +723,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -728,1 +728,1 @@\n-    return ciConstant(T_OBJECT, get_object(NULL));\n+    return ciConstant(T_OBJECT, get_object(nullptr));\n@@ -781,1 +781,1 @@\n-    return ciConstant(T_OBJECT, get_unloaded_klass_mirror(NULL));\n+    return ciConstant(T_OBJECT, get_unloaded_klass_mirror(nullptr));\n@@ -839,1 +839,1 @@\n-  if (cache == NULL) {\n+  if (cache == nullptr) {\n@@ -844,1 +844,1 @@\n-    if (field == NULL) {\n+    if (field == nullptr) {\n@@ -893,1 +893,1 @@\n-      return NULL; \/\/ silence compiler warnings\n+      return nullptr; \/\/ silence compiler warnings\n@@ -904,1 +904,1 @@\n-  assert(accessor != NULL, \"need origin of access\");\n+  assert(accessor != nullptr, \"need origin of access\");\n@@ -950,1 +950,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -964,1 +964,1 @@\n-      if (m != NULL &&\n+      if (m != nullptr &&\n@@ -968,1 +968,1 @@\n-        m = NULL;\n+        m = nullptr;\n@@ -970,2 +970,2 @@\n-      if (m != NULL && ReplayCompiles && !ciReplay::is_loaded(m)) {\n-        m = NULL;\n+      if (m != nullptr && ReplayCompiles && !ciReplay::is_loaded(m)) {\n+        m = nullptr;\n@@ -973,1 +973,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -1000,1 +1000,1 @@\n-  guarantee(method_holder != NULL, \"no method holder\");\n+  guarantee(method_holder != nullptr, \"no method holder\");\n@@ -1008,1 +1008,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1025,1 +1025,1 @@\n-    if (_name_buffer == NULL) {\n+    if (_name_buffer == nullptr) {\n@@ -1082,1 +1082,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -1087,1 +1087,1 @@\n-    if (method->get_method_counters(THREAD) == NULL) {\n+    if (method->get_method_counters(THREAD) == nullptr) {\n@@ -1126,1 +1126,1 @@\n-      if (log() != NULL) {\n+      if (log() != nullptr) {\n@@ -1139,1 +1139,1 @@\n-        (method()->method_data() != NULL) &&\n+        (method()->method_data() != nullptr) &&\n@@ -1153,1 +1153,1 @@\n-      if (mdo != NULL && _inc_decompile_count_on_failure) {\n+      if (mdo != nullptr && _inc_decompile_count_on_failure) {\n@@ -1180,1 +1180,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -1193,1 +1193,1 @@\n-          if (TraceMethodReplacement && old != NULL) {\n+          if (TraceMethodReplacement && old != nullptr) {\n@@ -1198,1 +1198,1 @@\n-          if (old != NULL) {\n+          if (old != nullptr) {\n@@ -1232,1 +1232,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -1248,1 +1248,1 @@\n-  return get_klass_by_name_impl(NULL, constantPoolHandle(), klass_name, false);\n+  return get_klass_by_name_impl(nullptr, constantPoolHandle(), klass_name, false);\n@@ -1254,1 +1254,1 @@\n-  if (task() == NULL)  return CompilationPolicy::highest_compile_level();\n+  if (task() == nullptr)  return CompilationPolicy::highest_compile_level();\n@@ -1261,1 +1261,1 @@\n-  if (task() == NULL)  return 0;\n+  if (task() == nullptr)  return 0;\n@@ -1280,1 +1280,1 @@\n-  if (_failure_reason == NULL) {\n+  if (_failure_reason == nullptr) {\n@@ -1301,1 +1301,1 @@\n-    if (log() != NULL) {\n+    if (log() != nullptr) {\n@@ -1312,1 +1312,1 @@\n-    _failure_reason = NULL;\n+    _failure_reason = nullptr;\n@@ -1388,1 +1388,1 @@\n-\/\/ Returns NULL if no location is found.\n+\/\/ Returns null if no location is found.\n@@ -1398,1 +1398,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1414,1 +1414,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -1432,1 +1432,1 @@\n-  if (vmtarget != NULL) {\n+  if (vmtarget != nullptr) {\n@@ -1457,1 +1457,1 @@\n-  if (names != NULL) {\n+  if (names != nullptr) {\n@@ -1466,1 +1466,1 @@\n-      if (function != NULL) {\n+      if (function != nullptr) {\n@@ -1469,1 +1469,1 @@\n-        if (member != NULL) {\n+        if (member != nullptr) {\n@@ -1475,1 +1475,1 @@\n-        if (mh != NULL) {\n+        if (mh != nullptr) {\n@@ -1481,1 +1481,1 @@\n-        if (invoker != NULL) {\n+        if (invoker != nullptr) {\n@@ -1511,1 +1511,1 @@\n-      if (arg != NULL) {\n+      if (arg != nullptr) {\n@@ -1530,1 +1530,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -1605,2 +1605,2 @@\n-  _dyno_klasses = new (arena()) GrowableArray<const InstanceKlass*>(arena(), 100, 0, NULL);\n-  _dyno_locs    = new (arena()) GrowableArray<const char *>(arena(), 100, 0, NULL);\n+  _dyno_klasses = new (arena()) GrowableArray<const InstanceKlass*>(arena(), 100, 0, nullptr);\n+  _dyno_locs    = new (arena()) GrowableArray<const char *>(arena(), 100, 0, nullptr);\n@@ -1661,1 +1661,1 @@\n-          if (mh != NULL) {\n+          if (mh != nullptr) {\n@@ -1675,1 +1675,1 @@\n-    if (ReplayReduce && compiler_data() != NULL) {\n+    if (ReplayReduce && compiler_data() != nullptr) {\n@@ -1686,1 +1686,1 @@\n-    if (compiler_data() != NULL) {\n+    if (compiler_data() != nullptr) {\n@@ -1756,1 +1756,1 @@\n-      if (replay_data_file != NULL) {\n+      if (replay_data_file != nullptr) {\n@@ -1774,1 +1774,1 @@\n-      if (inline_data_file != NULL) {\n+      if (inline_data_file != nullptr) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":118,"deletions":118,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-  \/\/ If require_local, result must be defined in that class loader, or NULL.\n+  \/\/ If require_local, result must be defined in that class loader, or null.\n@@ -175,1 +175,1 @@\n-    if (o == NULL) {\n+    if (o == nullptr) {\n@@ -183,1 +183,1 @@\n-    if (o == NULL) {\n+    if (o == nullptr) {\n@@ -185,1 +185,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -192,2 +192,2 @@\n-    if (o == NULL) {\n-      return NULL;\n+    if (o == nullptr) {\n+      return nullptr;\n@@ -204,1 +204,1 @@\n-    if (o == NULL) return NULL;\n+    if (o == nullptr) return nullptr;\n@@ -212,1 +212,1 @@\n-    if (o == NULL) return NULL;\n+    if (o == nullptr) return nullptr;\n@@ -216,1 +216,1 @@\n-    if (o == NULL) return NULL;\n+    if (o == nullptr) return nullptr;\n@@ -220,1 +220,1 @@\n-    if (o == NULL) return NULL;\n+    if (o == nullptr) return nullptr;\n@@ -224,1 +224,1 @@\n-    if (o == NULL) return NULL;\n+    if (o == nullptr) return nullptr;\n@@ -228,1 +228,1 @@\n-    if (o == NULL) return NULL;\n+    if (o == nullptr) return nullptr;\n@@ -232,1 +232,1 @@\n-    if (o == NULL) return NULL;\n+    if (o == nullptr) return nullptr;\n@@ -278,1 +278,1 @@\n-  \/\/ or return NULL if not.\n+  \/\/ or return null if not.\n@@ -328,1 +328,1 @@\n-  bool failing() { return _failure_reason != NULL; }\n+  bool failing() { return _failure_reason != nullptr; }\n@@ -343,1 +343,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -346,1 +346,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -403,1 +403,1 @@\n-    assert(_NullPointerException_instance != NULL, \"initialization problem\");\n+    assert(_NullPointerException_instance != nullptr, \"initialization problem\");\n@@ -407,1 +407,1 @@\n-    assert(_ArithmeticException_instance != NULL, \"initialization problem\");\n+    assert(_ArithmeticException_instance != nullptr, \"initialization problem\");\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-\/\/ To avoid vicious circularities, we initialize ciField::_type to NULL\n+\/\/ To avoid vicious circularities, we initialize ciField::_type to null\n@@ -74,1 +74,1 @@\n-  _original_holder(NULL), _is_flattened(false), _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n+  _original_holder(nullptr), _is_flattened(false), _known_to_link_with_put(nullptr), _known_to_link_with_get(nullptr) {\n@@ -161,1 +161,1 @@\n-  if (canonical_holder == NULL) {\n+  if (canonical_holder == nullptr) {\n@@ -197,1 +197,1 @@\n-    _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n+    _known_to_link_with_put(nullptr), _known_to_link_with_get(nullptr) {\n@@ -210,1 +210,1 @@\n-    _type = NULL;  \/\/ must call compute_type on first access\n+    _type = nullptr;  \/\/ must call compute_type on first access\n@@ -244,1 +244,1 @@\n-  _original_holder = (field->_original_holder != NULL) ? field->_original_holder : field->_holder;\n+  _original_holder = (field->_original_holder != nullptr) ? field->_original_holder : field->_holder;\n@@ -248,1 +248,1 @@\n-  if (holder == NULL)\n+  if (holder == nullptr)\n@@ -292,1 +292,1 @@\n-  assert(field_holder != NULL, \"null field_holder\");\n+  assert(field_holder != nullptr, \"null field_holder\");\n@@ -296,1 +296,1 @@\n-  _original_holder = NULL;\n+  _original_holder = nullptr;\n@@ -307,1 +307,1 @@\n-      assert(vmClasses::System_klass() != NULL, \"Check once per vm\");\n+      assert(vmClasses::System_klass() != nullptr, \"Check once per vm\");\n@@ -326,1 +326,1 @@\n-    assert(vmClasses::CallSite_klass() != NULL, \"should be already initialized\");\n+    assert(vmClasses::CallSite_klass() != nullptr, \"should be already initialized\");\n@@ -348,2 +348,1 @@\n-    VM_ENTRY_MARK;\n-    ciInstance* mirror = CURRENT_ENV->get_instance(_holder->get_Klass()->java_mirror());\n+    ciInstance* mirror = _holder->java_mirror();\n@@ -381,1 +380,1 @@\n-  ciKlass* accessing_klass = (_original_holder != NULL) ? _original_holder : _holder;\n+  ciKlass* accessing_klass = (_original_holder != nullptr) ? _original_holder : _holder;\n@@ -459,1 +458,1 @@\n-  if (callsite_klass == NULL)\n+  if (callsite_klass == nullptr)\n@@ -485,1 +484,1 @@\n-  if (_type != NULL)\n+  if (_type != nullptr)\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-  ciType* type() { return (_type == NULL) ? compute_type() : _type; }\n+  ciType* type() { return (_type == nullptr) ? compute_type() : _type; }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"ci\/ciNullObject.hpp\"\n@@ -45,3 +46,3 @@\n-  \/\/ Return NULL if it is not java.lang.Class.\n-  if (m == NULL || m->klass() != vmClasses::Class_klass()) {\n-    return NULL;\n+  \/\/ Return null if it is not java.lang.Class.\n+  if (m == nullptr || m->klass() != vmClasses::Class_klass()) {\n+    return nullptr;\n@@ -54,2 +55,2 @@\n-    assert(k != NULL, \"\");\n-    if (is_val_mirror != NULL) {\n+    assert(k != nullptr, \"\");\n+    if (is_val_mirror != nullptr) {\n@@ -65,0 +66,5 @@\n+  ciConstant value = check_constant_value_cache(offset, field_btype);\n+  if (value.is_valid()) {\n+    return value;\n+  }\n+  VM_ENTRY_MARK;\n@@ -66,1 +72,1 @@\n-  assert(obj != NULL, \"bad oop\");\n+  assert(obj != nullptr, \"bad oop\");\n@@ -68,8 +74,8 @@\n-    case T_BYTE:    return ciConstant(field_btype, obj->byte_field(offset));\n-    case T_CHAR:    return ciConstant(field_btype, obj->char_field(offset));\n-    case T_SHORT:   return ciConstant(field_btype, obj->short_field(offset));\n-    case T_BOOLEAN: return ciConstant(field_btype, obj->bool_field(offset));\n-    case T_INT:     return ciConstant(field_btype, obj->int_field(offset));\n-    case T_FLOAT:   return ciConstant(obj->float_field(offset));\n-    case T_DOUBLE:  return ciConstant(obj->double_field(offset));\n-    case T_LONG:    return ciConstant(obj->long_field(offset));\n+    case T_BYTE:    value = ciConstant(field_btype, obj->byte_field(offset)); break;\n+    case T_CHAR:    value = ciConstant(field_btype, obj->char_field(offset)); break;\n+    case T_SHORT:   value = ciConstant(field_btype, obj->short_field(offset)); break;\n+    case T_BOOLEAN: value = ciConstant(field_btype, obj->bool_field(offset)); break;\n+    case T_INT:     value = ciConstant(field_btype, obj->int_field(offset)); break;\n+    case T_FLOAT:   value = ciConstant(obj->float_field(offset)); break;\n+    case T_DOUBLE:  value = ciConstant(obj->double_field(offset)); break;\n+    case T_LONG:    value = ciConstant(obj->long_field(offset)); break;\n@@ -88,2 +94,2 @@\n-      if (o == NULL) {\n-        return ciConstant(field_btype, ciNullObject::make());\n+      if (o == nullptr) {\n+        value = ciConstant(field_btype, ciNullObject::make());\n@@ -91,1 +97,1 @@\n-        return ciConstant(field_btype, CURRENT_ENV->get_object(o));\n+        value = ciConstant(field_btype, CURRENT_ENV->get_object(o));\n@@ -93,0 +99,1 @@\n+      break;\n@@ -96,1 +103,2 @@\n-      return ciConstant();\n+  add_to_constant_value_cache(offset, value);\n+  return value;\n@@ -110,1 +118,1 @@\n-  GUARDED_VM_ENTRY(return field_value_impl(field->type()->basic_type(), field->offset());)\n+  return field_value_impl(field->type()->basic_type(), field->offset());\n@@ -120,1 +128,1 @@\n-  if (field == NULL)\n+  if (field == nullptr)\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  \/\/ Otherwise, return NULL.\n+  \/\/ Otherwise, return null.\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-  _nonstatic_fields = NULL; \/\/ initialized lazily by compute_nonstatic_fields:\n+  _nonstatic_fields = nullptr; \/\/ initialized lazily by compute_nonstatic_fields:\n@@ -74,2 +74,2 @@\n-  _implementor = NULL; \/\/ we will fill these lazily\n-  _transitive_interfaces = NULL;\n+  _implementor = nullptr; \/\/ we will fill these lazily\n+  _transitive_interfaces = nullptr;\n@@ -85,1 +85,1 @@\n-    \/\/ non-strong hidden classes alive (loader == NULL). Klass holder should\n+    \/\/ non-strong hidden classes alive (loader == nullptr). Klass holder should\n@@ -89,1 +89,1 @@\n-    assert(holder != NULL, \"holder of hidden class is the mirror which is never null\");\n+    assert(holder != nullptr, \"holder of hidden class is the mirror which is never null\");\n@@ -110,2 +110,2 @@\n-  _super  = NULL;\n-  _java_mirror = NULL;\n+  _super  = nullptr;\n+  _java_mirror = nullptr;\n@@ -120,1 +120,1 @@\n-  _field_cache = NULL;\n+  _field_cache = nullptr;\n@@ -132,1 +132,1 @@\n-  _nonstatic_fields = NULL;            \/\/ initialized lazily by compute_nonstatic_fields\n+  _nonstatic_fields = nullptr;         \/\/ initialized lazily by compute_nonstatic_fields\n@@ -139,3 +139,3 @@\n-  _super = NULL;\n-  _java_mirror = NULL;\n-  _field_cache = NULL;\n+  _super = nullptr;\n+  _java_mirror = nullptr;\n+  _field_cache = nullptr;\n@@ -161,1 +161,1 @@\n-    _has_subklass = ik->subklass() != NULL ? subklass_true : subklass_false;\n+    _has_subklass = ik->subklass() != nullptr ? subklass_true : subklass_false;\n@@ -198,1 +198,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -200,1 +200,1 @@\n-  if (_field_cache == NULL) {\n+  if (_field_cache == nullptr) {\n@@ -229,1 +229,1 @@\n-  if (field != NULL) {\n+  if (field != nullptr) {\n@@ -235,1 +235,1 @@\n-      if (super == NULL ||\n+      if (super == nullptr ||\n@@ -259,1 +259,1 @@\n-  return _loader == NULL;\n+  return _loader == nullptr;\n@@ -362,1 +362,1 @@\n-  if (_super == NULL && !is_java_lang_Object()) {\n+  if (_super == nullptr && !is_java_lang_Object()) {\n@@ -380,1 +380,1 @@\n-  if (_java_mirror == NULL) {\n+  if (_java_mirror == nullptr) {\n@@ -389,3 +389,3 @@\n-  if (!is_loaded())     return NULL; \/\/ No change if class is not loaded\n-  if (!is_abstract())   return NULL; \/\/ Only applies to abstract classes.\n-  if (!has_subklass())  return NULL; \/\/ Must have at least one subklass.\n+  if (!is_loaded())     return nullptr; \/\/ No change if class is not loaded\n+  if (!is_abstract())   return nullptr; \/\/ Only applies to abstract classes.\n+  if (!has_subklass())  return nullptr; \/\/ Must have at least one subklass.\n@@ -397,1 +397,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -407,1 +407,1 @@\n-  return Dependencies::find_finalizable_subclass(get_instanceKlass()) != NULL;\n+  return Dependencies::find_finalizable_subclass(get_instanceKlass()) != nullptr;\n@@ -430,1 +430,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -436,1 +436,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -443,1 +443,1 @@\n-  if (super() != NULL && super()->has_nonstatic_fields()) {\n+  if (super() != nullptr && super()->has_nonstatic_fields()) {\n@@ -445,1 +445,1 @@\n-    if (f != NULL) {\n+    if (f != nullptr) {\n@@ -462,1 +462,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -472,2 +472,2 @@\n-  if (def == NULL) {\n-    return NULL;\n+  if (def == nullptr) {\n+    return nullptr;\n@@ -490,1 +490,1 @@\n-  if (_nonstatic_fields != NULL)\n+  if (_nonstatic_fields != nullptr)\n@@ -495,1 +495,1 @@\n-    _nonstatic_fields = new (arena) GrowableArray<ciField*>(arena, 0, 0, NULL);\n+    _nonstatic_fields = new (arena) GrowableArray<ciField*>(arena, 0, 0, nullptr);\n@@ -501,2 +501,2 @@\n-  GrowableArray<ciField*>* super_fields = NULL;\n-  if (super != NULL && super->has_nonstatic_fields()) {\n+  GrowableArray<ciField*>* super_fields = nullptr;\n+  if (super != nullptr && super->has_nonstatic_fields()) {\n@@ -505,1 +505,1 @@\n-    assert(super_flen == 0 || super_fields != NULL, \"first get nof_fields\");\n+    assert(super_flen == 0 || super_fields != nullptr, \"first get nof_fields\");\n@@ -508,1 +508,1 @@\n-  GrowableArray<ciField*>* fields = NULL;\n+  GrowableArray<ciField*>* fields = nullptr;\n@@ -513,1 +513,1 @@\n-  if (fields == NULL) {\n+  if (fields == nullptr) {\n@@ -515,1 +515,1 @@\n-    if (super_fields != NULL) {\n+    if (super_fields != nullptr) {\n@@ -531,1 +531,1 @@\n-  GrowableArray<ciField*>* fields = NULL;\n+  GrowableArray<ciField*>* fields = nullptr;\n@@ -540,1 +540,1 @@\n-    return NULL;  \/\/ return nothing if none are locally declared\n+    return nullptr;  \/\/ return nothing if none are locally declared\n@@ -542,1 +542,1 @@\n-  if (super_fields != NULL) {\n+  if (super_fields != nullptr) {\n@@ -545,3 +545,2 @@\n-\n-  fields = new (arena) GrowableArray<ciField*>(arena, flen, 0, NULL);\n-  if (super_fields != NULL) {\n+  fields = new (arena) GrowableArray<ciField*>(arena, flen, 0, nullptr);\n+  if (super_fields != nullptr) {\n@@ -599,1 +598,1 @@\n-  if (super() != NULL && super()->has_injected_fields()) {\n+  if (super() != nullptr && super()->has_injected_fields()) {\n@@ -620,1 +619,1 @@\n-  if (loader_oop == NULL) {\n+  if (loader_oop == nullptr) {\n@@ -637,1 +636,1 @@\n-  if (m == NULL)  return NULL;\n+  if (m == nullptr)  return nullptr;\n@@ -664,1 +663,1 @@\n-  if (impl == NULL) {\n+  if (impl == nullptr) {\n@@ -672,1 +671,1 @@\n-      if (k != NULL) {\n+      if (k != nullptr) {\n@@ -778,1 +777,1 @@\n-      if (value == NULL) {\n+      if (value == nullptr) {\n@@ -784,1 +783,1 @@\n-          _out->print(\"\\\"%s\\\"\", (ascii_value != NULL) ? ascii_value : \"\");\n+          _out->print(\"\\\"%s\\\"\", (ascii_value != nullptr) ? ascii_value : \"\");\n@@ -812,1 +811,1 @@\n-      assert(k != NULL && !HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n+      assert(k != nullptr && !HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n@@ -837,1 +836,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -848,1 +847,1 @@\n-  if (_transitive_interfaces == NULL) {\n+  if (_transitive_interfaces == nullptr) {\n@@ -862,1 +861,1 @@\n-                                                                                                             0, NULL);\n+                                                                                                             0, nullptr);\n@@ -881,1 +880,1 @@\n-  while (sub != NULL) {\n+  while (sub != nullptr) {\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":58,"deletions":59,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  \/\/   NULL: no implementor.\n+  \/\/   null: no implementor.\n@@ -187,1 +187,1 @@\n-    if (impl == NULL) {\n+    if (impl == nullptr) {\n@@ -216,1 +216,1 @@\n-    if (_nonstatic_fields == NULL) {\n+    if (_nonstatic_fields == nullptr) {\n@@ -234,1 +234,1 @@\n-    assert(_nonstatic_fields != NULL, \"\");\n+    assert(_nonstatic_fields != nullptr, \"\");\n@@ -264,1 +264,1 @@\n-    return (impl != this ? impl : NULL);\n+    return (impl != this ? impl : nullptr);\n@@ -291,1 +291,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  assert(klass_name != NULL, \"wrong ciKlass constructor\");\n+  assert(klass_name != nullptr, \"wrong ciKlass constructor\");\n@@ -139,1 +139,1 @@\n-  return (super != NULL) ? CURRENT_THREAD_ENV->get_klass(super) : NULL;\n+  return (super != nullptr) ? CURRENT_THREAD_ENV->get_klass(super) : nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    assert(k != NULL, \"illegal use of unloaded klass\");\n+    assert(k != nullptr, \"illegal use of unloaded klass\");\n@@ -67,2 +67,2 @@\n-  virtual oop loader()             { return NULL; }\n-  virtual jobject loader_handle()  { return NULL; }\n+  virtual oop loader()             { return nullptr; }\n+  virtual jobject loader_handle()  { return nullptr; }\n@@ -70,2 +70,2 @@\n-  virtual oop protection_domain()             { return NULL; }\n-  virtual jobject protection_domain_handle()  { return NULL; }\n+  virtual oop protection_domain()             { return nullptr; }\n+  virtual jobject protection_domain_handle()  { return nullptr; }\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-  ciMetadata(): _metadata(NULL) {}\n+  ciMetadata(): _metadata(nullptr) {}\n@@ -48,1 +48,1 @@\n-  bool is_loaded() const { return _metadata != NULL || is_classless(); }\n+  bool is_loaded() const { return _metadata != nullptr || is_classless(); }\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-  assert(h_m() != NULL, \"no null method\");\n+  assert(h_m() != nullptr, \"no null method\");\n@@ -94,4 +94,4 @@\n-  _code               = NULL;\n-  _exception_handlers = NULL;\n-  _liveness           = NULL;\n-  _method_blocks = NULL;\n+  _code               = nullptr;\n+  _exception_handlers = nullptr;\n+  _liveness           = nullptr;\n+  _method_blocks = nullptr;\n@@ -99,2 +99,2 @@\n-  _flow               = NULL;\n-  _bcea               = NULL;\n+  _flow               = nullptr;\n+  _bcea               = nullptr;\n@@ -111,1 +111,1 @@\n-    if (Dependencies::check_evol_method(h_m()) != NULL) {\n+    if (Dependencies::check_evol_method(h_m()) != nullptr) {\n@@ -142,1 +142,1 @@\n-  _method_data = NULL;\n+  _method_data = nullptr;\n@@ -155,1 +155,1 @@\n-  _instructions_size = -1;\n+  _inline_instructions_size = -1;\n@@ -170,1 +170,1 @@\n-  ciMetadata((Metadata*)NULL),\n+  ciMetadata((Metadata*)nullptr),\n@@ -173,2 +173,2 @@\n-  _method_data(            NULL),\n-  _method_blocks(          NULL),\n+  _method_data(            nullptr),\n+  _method_blocks(          nullptr),\n@@ -176,1 +176,1 @@\n-  _instructions_size(-1),\n+  _inline_instructions_size(-1),\n@@ -179,1 +179,1 @@\n-  _liveness(               NULL)\n+  _liveness(               nullptr)\n@@ -182,2 +182,2 @@\n-  _flow(                   NULL),\n-  _bcea(                   NULL)\n+  _flow(                   nullptr),\n+  _bcea(                   nullptr)\n@@ -212,1 +212,1 @@\n-    for (; bp != NULL; bp = bp->next()) {\n+    for (; bp != nullptr; bp = bp->next()) {\n@@ -324,1 +324,1 @@\n-  if (_flow == NULL) {\n+  if (_flow == nullptr) {\n@@ -332,1 +332,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -349,1 +349,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -359,1 +359,1 @@\n-  if (_liveness == NULL) {\n+  if (_liveness == nullptr) {\n@@ -420,1 +420,1 @@\n-  if (_liveness == NULL) {\n+  if (_liveness == nullptr) {\n@@ -461,1 +461,1 @@\n-  if (method_data() != NULL && method_data()->is_mature()) {\n+  if (method_data() != nullptr && method_data()->is_mature()) {\n@@ -463,1 +463,1 @@\n-    if (data != NULL && data->is_CounterData()) {\n+    if (data != nullptr && data->is_CounterData()) {\n@@ -477,1 +477,1 @@\n-          if (receiver == NULL)  continue;\n+          if (receiver == nullptr)  continue;\n@@ -491,1 +491,1 @@\n-          if (receiver == NULL)  continue;\n+          if (receiver == nullptr)  continue;\n@@ -568,1 +568,1 @@\n- * @param [out]type       profiled type of argument, NULL if none\n+ * @param [out]type       profiled type of argument, null if none\n@@ -574,1 +574,1 @@\n-  if (MethodData::profile_parameters() && method_data() != NULL && method_data()->is_mature()) {\n+  if (MethodData::profile_parameters() && method_data() != nullptr && method_data()->is_mature()) {\n@@ -576,1 +576,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -606,1 +606,1 @@\n- * @param [out]type       profiled type of argument, NULL if none\n+ * @param [out]type       profiled type of argument, null if none\n@@ -612,1 +612,1 @@\n-  if (MethodData::profile_return() && method_data() != NULL && method_data()->is_mature()) {\n+  if (MethodData::profile_return() && method_data() != nullptr && method_data()->is_mature()) {\n@@ -614,1 +614,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -641,1 +641,1 @@\n- * @param [out]type       profiled type of parameter, NULL if none\n+ * @param [out]type       profiled type of parameter, null if none\n@@ -647,1 +647,1 @@\n-  if (MethodData::profile_parameters() && method_data() != NULL && method_data()->is_mature()) {\n+  if (MethodData::profile_parameters() && method_data() != nullptr && method_data()->is_mature()) {\n@@ -649,1 +649,1 @@\n-    if (parameters != NULL && i < parameters->number_of_parameters()) {\n+    if (parameters != nullptr && i < parameters->number_of_parameters()) {\n@@ -696,1 +696,1 @@\n-\/\/ for the call.  Return NULL if the call is not monomorphic in\n+\/\/ for the call.  Return null if the call is not monomorphic in\n@@ -709,1 +709,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -713,1 +713,1 @@\n-  if (root_m == NULL) {\n+  if (root_m == nullptr) {\n@@ -715,1 +715,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -730,1 +730,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -741,1 +741,1 @@\n-  if (!UseCHA)  return NULL;\n+  if (!UseCHA)  return nullptr;\n@@ -756,1 +756,1 @@\n-        return NULL; \/\/ not supported\n+        return nullptr; \/\/ not supported\n@@ -760,1 +760,1 @@\n-    assert(target() == NULL || !target()->is_abstract(), \"not allowed\");\n+    assert(target() == nullptr || !target()->is_abstract(), \"not allowed\");\n@@ -765,1 +765,1 @@\n-  if (TraceDependencies && target() != NULL && target() != root_m->get_Method()) {\n+  if (TraceDependencies && target() != nullptr && target() != root_m->get_Method()) {\n@@ -774,2 +774,2 @@\n-  if (target() == NULL) {\n-    return NULL;\n+  if (target() == nullptr) {\n+    return nullptr;\n@@ -785,1 +785,1 @@\n-    \/\/ to return NULL, even if the CHA encountered irrelevant\n+    \/\/ to return null, even if the CHA encountered irrelevant\n@@ -789,1 +789,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -820,1 +820,1 @@\n-\/\/ Return NULL if the call has no target or the target is abstract.\n+\/\/ Return null if the call has no target or the target is abstract.\n@@ -834,1 +834,1 @@\n-  Method* m = NULL;\n+  Method* m = nullptr;\n@@ -847,3 +847,3 @@\n-  if (m == NULL) {\n-    \/\/ Return NULL only if there was a problem with lookup (uninitialized class, etc.)\n-    return NULL;\n+  if (m == nullptr) {\n+    \/\/ Return null only if there was a problem with lookup (uninitialized class, etc.)\n+    return nullptr;\n@@ -859,1 +859,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -930,1 +930,1 @@\n-  if (count > 0 && method_data() != NULL) {\n+  if (count > 0 && method_data() != nullptr) {\n@@ -1029,1 +1029,1 @@\n-  if (h_m()->method_data() == NULL) {\n+  if (h_m()->method_data() == nullptr) {\n@@ -1035,1 +1035,1 @@\n-  if (h_m()->method_data() != NULL) {\n+  if (h_m()->method_data() != nullptr) {\n@@ -1047,1 +1047,1 @@\n-  if (_method_data == NULL || _method_data->is_empty()) {\n+  if (_method_data == nullptr || _method_data->is_empty()) {\n@@ -1061,1 +1061,1 @@\n-  if (_method_data != NULL) {\n+  if (_method_data != nullptr) {\n@@ -1069,1 +1069,1 @@\n-  if (h_m()->method_data() != NULL) {\n+  if (h_m()->method_data() != nullptr) {\n@@ -1082,1 +1082,1 @@\n-\/\/ NULL otherwise.\n+\/\/ null otherwise.\n@@ -1086,1 +1086,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1137,1 +1137,1 @@\n-  return instructions_size() > 0;\n+  return inline_instructions_size() > 0;\n@@ -1160,1 +1160,1 @@\n-\/\/ ciMethod::instructions_size\n+\/\/ ciMethod::inline_instructions_size\n@@ -1167,2 +1167,4 @@\n-int ciMethod::instructions_size() {\n-  if (_instructions_size == -1) {\n+\/\/ Also some instructions inside the code are excluded from inline\n+\/\/ heuristic (e.g. post call nop instructions; see InlineSkippedInstructionsCounter)\n+int ciMethod::inline_instructions_size() {\n+  if (_inline_instructions_size == -1) {\n@@ -1170,7 +1172,8 @@\n-                     CompiledMethod* code = get_Method()->code();\n-                     if (code != NULL && (code->comp_level() == CompLevel_full_optimization)) {\n-                       _instructions_size = code->insts_end() - code->verified_entry_point();\n-                     } else {\n-                       _instructions_size = 0;\n-                     }\n-                     );\n+      CompiledMethod* code = get_Method()->code();\n+      if (code != nullptr && (code->comp_level() == CompLevel_full_optimization)) {\n+        int isize = code->insts_end() - code->verified_entry_point() - code->skipped_instructions_size();\n+        _inline_instructions_size = isize > 0 ? isize : 0;\n+      } else {\n+        _inline_instructions_size = 0;\n+      }\n+    );\n@@ -1178,1 +1181,1 @@\n-  return _instructions_size;\n+  return _inline_instructions_size;\n@@ -1186,1 +1189,1 @@\n-    if (code != NULL) {\n+    if (code != nullptr) {\n@@ -1318,2 +1321,2 @@\n-  if (_bcea == NULL) {\n-    _bcea = new (CURRENT_ENV->arena()) BCEscapeAnalyzer(this, NULL);\n+  if (_bcea == nullptr) {\n+    _bcea = new (CURRENT_ENV->arena()) BCEscapeAnalyzer(this, nullptr);\n@@ -1324,1 +1327,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1329,1 +1332,1 @@\n-  if (_method_blocks == NULL) {\n+  if (_method_blocks == nullptr) {\n@@ -1361,2 +1364,2 @@\n-               mcs == NULL ? 0 : mcs->invocation_counter()->raw_counter(),\n-               mcs == NULL ? 0 : mcs->backedge_counter()->raw_counter(),\n+               mcs == nullptr ? 0 : mcs->invocation_counter()->raw_counter(),\n+               mcs == nullptr ? 0 : mcs->backedge_counter()->raw_counter(),\n@@ -1365,1 +1368,1 @@\n-               _instructions_size);\n+               _inline_instructions_size);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":87,"deletions":84,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  int _instructions_size;\n+  int _inline_instructions_size;\n@@ -179,1 +179,1 @@\n-    assert(m != NULL, \"illegal use of unloaded method\");\n+    assert(m != nullptr, \"illegal use of unloaded method\");\n@@ -184,1 +184,1 @@\n-  address code()                                 { if (_code == NULL) load_code(); return _code; }\n+  address code()                                 { if (_code == nullptr) load_code(); return _code; }\n@@ -218,1 +218,1 @@\n-    return Bytecodes::java_code_at(NULL, bcp);\n+    return Bytecodes::java_code_at(nullptr, bcp);\n@@ -222,1 +222,1 @@\n-    return Bytecodes::code_at(NULL, bcp);\n+    return Bytecodes::code_at(nullptr, bcp);\n@@ -290,1 +290,1 @@\n-    assert(declared_signature != NULL, \"cannot be null\");\n+    assert(declared_signature != nullptr, \"cannot be null\");\n@@ -295,1 +295,1 @@\n-  \/\/ for the call.  Return NULL if the call is not monomorphic in\n+  \/\/ for the call.  Return null if the call is not monomorphic in\n@@ -303,1 +303,1 @@\n-  \/\/ Return NULL if the call has no target or is abstract.\n+  \/\/ Return null if the call has no target or is abstract.\n@@ -322,1 +322,2 @@\n-  int instructions_size();\n+\n+  int inline_instructions_size();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  _data_size(0), _extra_data_size(0), _data(NULL),\n+  _data_size(0), _extra_data_size(0), _data(nullptr),\n@@ -54,1 +54,1 @@\n-  _parameters(NULL) {}\n+  _parameters(nullptr) {}\n@@ -73,1 +73,1 @@\n-    if (CURRENT_ENV->cached_metadata(m) == NULL) {\n+    if (CURRENT_ENV->cached_metadata(m) == nullptr) {\n@@ -172,1 +172,1 @@\n-  if (mdo == NULL) {\n+  if (mdo == nullptr) {\n@@ -239,1 +239,1 @@\n-  if (mdo->parameters_type_data() != NULL) {\n+  if (mdo->parameters_type_data() != nullptr) {\n@@ -276,1 +276,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -285,1 +285,1 @@\n-      set_receiver(row, NULL);\n+      set_receiver(row, nullptr);\n@@ -294,1 +294,1 @@\n-    if (klass != NULL && !klass->is_loader_alive()) {\n+    if (klass != nullptr && !klass->is_loader_alive()) {\n@@ -296,1 +296,1 @@\n-      TypeStackSlotEntries::set_type(i, TypeStackSlotEntries::with_status((Klass*)NULL, k));\n+      TypeStackSlotEntries::set_type(i, TypeStackSlotEntries::with_status((Klass*)nullptr, k));\n@@ -306,1 +306,1 @@\n-  if (klass != NULL && !klass->is_loader_alive()) {\n+  if (klass != nullptr && !klass->is_loader_alive()) {\n@@ -308,1 +308,1 @@\n-    set_type(SingleTypeEntry::with_status((Klass*)NULL, k));\n+    set_type(SingleTypeEntry::with_status((Klass*)nullptr, k));\n@@ -323,1 +323,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -334,1 +334,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -378,1 +378,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -393,1 +393,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -395,1 +395,1 @@\n-      return NULL; \/\/ ArgInfoData is after the trap data right before the parameter data.\n+      return nullptr; \/\/ ArgInfoData is after the trap data right before the parameter data.\n@@ -397,1 +397,1 @@\n-      if (m == NULL && dp->bci() == bci) {\n+      if (m == nullptr && dp->bci() == bci) {\n@@ -405,1 +405,1 @@\n-      if (m != NULL && data->method() == m && dp->bci() == bci) {\n+      if (m != nullptr && data->method() == m && dp->bci() == bci) {\n@@ -414,1 +414,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -417,1 +417,1 @@\n-\/\/ Translate a bci to its corresponding data, or NULL.\n+\/\/ Translate a bci to its corresponding data, or nullptr.\n@@ -419,2 +419,2 @@\n-  \/\/ If m is not NULL we look for a SpeculativeTrapData entry\n-  if (m == NULL) {\n+  \/\/ If m is not nullptr we look for a SpeculativeTrapData entry\n+  if (m == nullptr) {\n@@ -433,1 +433,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -436,1 +436,1 @@\n-  if (m != NULL && !two_free_slots) {\n+  if (m != nullptr && !two_free_slots) {\n@@ -440,1 +440,1 @@\n-    return bci_to_data(bci, NULL);\n+    return bci_to_data(bci, nullptr);\n@@ -442,1 +442,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -457,1 +457,1 @@\n-  } else if (data == NULL) {\n+  } else if (data == nullptr) {\n@@ -472,1 +472,1 @@\n-  if (data == NULL) {\n+  if (data == nullptr) {\n@@ -482,1 +482,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -485,1 +485,1 @@\n-    int arg_count = (aid == NULL) ? 0 : aid->number_of_args();\n+    int arg_count = (aid == nullptr) ? 0 : aid->number_of_args();\n@@ -497,1 +497,1 @@\n-  if ( mdo != NULL) {\n+  if ( mdo != nullptr) {\n@@ -512,1 +512,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -521,1 +521,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -529,1 +529,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -531,1 +531,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -545,1 +545,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -553,1 +553,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -555,1 +555,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -592,1 +592,1 @@\n-  if (aid == NULL)\n+  if (aid == nullptr)\n@@ -612,1 +612,1 @@\n-  if (aid == NULL)\n+  if (aid == nullptr)\n@@ -619,1 +619,1 @@\n-  return _parameters != NULL ? new ciParametersTypeData(_parameters) : NULL;\n+  return _parameters != nullptr ? new ciParametersTypeData(_parameters) : nullptr;\n@@ -643,1 +643,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -653,1 +653,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -694,1 +694,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -773,1 +773,1 @@\n-    if (parameters != NULL) {\n+    if (parameters != nullptr) {\n@@ -794,1 +794,1 @@\n-  if (parameters != NULL) {\n+  if (parameters != nullptr) {\n@@ -878,1 +878,1 @@\n-    if (receiver(row) != NULL)  entries++;\n+    if (receiver(row) != nullptr)  entries++;\n@@ -882,1 +882,1 @@\n-    if (receiver(row) != NULL) {\n+    if (receiver(row) != nullptr) {\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-    if (v != NULL) {\n+    if (v != nullptr) {\n@@ -75,1 +75,1 @@\n-    return with_status(NULL, k);\n+    return with_status(nullptr, k);\n@@ -83,1 +83,1 @@\n-      assert(res != NULL, \"invalid\");\n+      assert(res != nullptr, \"invalid\");\n@@ -86,1 +86,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -189,1 +189,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -206,1 +206,1 @@\n-    assert(recv == NULL || recv->is_klass(), \"wrong type\");\n+    assert(recv == nullptr || recv->is_klass(), \"wrong type\");\n@@ -216,1 +216,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -241,1 +241,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -298,1 +298,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -342,1 +342,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -361,1 +361,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -440,1 +440,1 @@\n-  \/\/ Area dedicated to parameters. NULL if no parameter profiling for this method.\n+  \/\/ Area dedicated to parameters. null if no parameter profiling for this method.\n@@ -443,1 +443,1 @@\n-    return _parameters == NULL ? 0 : parameters_type_data()->size_in_bytes();\n+    return _parameters == nullptr ? 0 : parameters_type_data()->size_in_bytes();\n@@ -446,1 +446,1 @@\n-  ciMethodData(MethodData* md = NULL);\n+  ciMethodData(MethodData* md = nullptr);\n@@ -480,1 +480,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -548,2 +548,2 @@\n-  bool is_valid(ciProfileData* current) { return current != NULL; }\n-  bool is_valid(DataLayout* current)    { return current != NULL; }\n+  bool is_valid(ciProfileData* current) { return current != nullptr; }\n+  bool is_valid(DataLayout* current)    { return current != nullptr; }\n@@ -555,3 +555,3 @@\n-  \/\/ Get the data at an arbitrary bci, or NULL if there is none. If m\n-  \/\/ is not NULL look for a SpeculativeTrapData if any first.\n-  ciProfileData* bci_to_data(int bci, ciMethod* m = NULL);\n+  \/\/ Get the data at an arbitrary bci, or null if there is none. If m\n+  \/\/ is not null look for a SpeculativeTrapData if any first.\n+  ciProfileData* bci_to_data(int bci, ciMethod* m = nullptr);\n@@ -577,1 +577,1 @@\n-    assert((m != NULL) == Deoptimization::reason_is_speculate(reason), \"inconsistent method\/reason\");\n+    assert((m != nullptr) == Deoptimization::reason_is_speculate(reason), \"inconsistent method\/reason\");\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    _element_klass = NULL;\n+    _element_klass = nullptr;\n@@ -76,1 +76,1 @@\n-    _element_klass = NULL;\n+    _element_klass = nullptr;\n@@ -86,2 +86,2 @@\n-  if (_element_klass == NULL) {\n-    assert(dimension() > 1, \"_element_klass should not be NULL\");\n+  if (_element_klass == nullptr) {\n+    assert(dimension() > 1, \"_element_klass should not be null\");\n@@ -183,1 +183,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -188,1 +188,1 @@\n-    if (ik->exact_klass() != NULL) {\n+    if (ik->exact_klass() != nullptr) {\n@@ -194,1 +194,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-GrowableArray<ciMetadata*>* ciObjectFactory::_shared_ci_metadata = NULL;\n+GrowableArray<ciMetadata*>* ciObjectFactory::_shared_ci_metadata = nullptr;\n@@ -87,6 +87,6 @@\n-                                   _ci_metadata(arena, expected_size, 0, NULL),\n-                                   _unloaded_methods(arena, 4, 0, NULL),\n-                                   _unloaded_klasses(arena, 8, 0, NULL),\n-                                   _unloaded_instances(arena, 4, 0, NULL),\n-                                   _return_addresses(arena, 8, 0, NULL),\n-                                   _symbols(arena, 100, 0, NULL),\n+                                   _ci_metadata(arena, expected_size, 0, nullptr),\n+                                   _unloaded_methods(arena, 4, 0, nullptr),\n+                                   _unloaded_klasses(arena, 8, 0, nullptr),\n+                                   _unloaded_instances(arena, 4, 0, nullptr),\n+                                   _return_addresses(arena, 8, 0, nullptr),\n+                                   _symbols(arena, 100, 0, nullptr),\n@@ -96,1 +96,1 @@\n-    _non_perm_bucket[i] = NULL;\n+    _non_perm_bucket[i] = nullptr;\n@@ -100,1 +100,1 @@\n-  if (_shared_ci_metadata != NULL) {\n+  if (_shared_ci_metadata != nullptr) {\n@@ -149,1 +149,1 @@\n-    if (type2name(t) != NULL && !is_reference_type(t) &&\n+    if (type2name(t) != nullptr && !is_reference_type(t) &&\n@@ -180,1 +180,1 @@\n-  ciEnv::_unloaded_ciinstance_klass = new (_arena) ciInstanceKlass(ciEnv::_unloaded_cisymbol, NULL, NULL);\n+  ciEnv::_unloaded_ciinstance_klass = new (_arena) ciInstanceKlass(ciEnv::_unloaded_cisymbol, nullptr, nullptr);\n@@ -242,1 +242,1 @@\n-  if (bucket != NULL) {\n+  if (bucket != nullptr) {\n@@ -278,1 +278,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -303,1 +303,1 @@\n-    Metadata* last = NULL;\n+    Metadata* last = nullptr;\n@@ -378,1 +378,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -418,1 +418,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -433,2 +433,2 @@\n-  assert(accessor != NULL, \"need origin of access\");\n-  ciSignature* that = NULL;\n+  assert(accessor != nullptr, \"need origin of access\");\n+  ciSignature* that = nullptr;\n@@ -446,1 +446,1 @@\n-        if (that == NULL)  that = new (arena()) ciSignature(accessor, constantPoolHandle(), signature);\n+        if (that == nullptr)  that = new (arena()) ciSignature(accessor, constantPoolHandle(), signature);\n@@ -477,3 +477,3 @@\n-  oop loader = NULL;\n-  oop domain = NULL;\n-  if (accessing_klass != NULL) {\n+  oop loader = nullptr;\n+  oop domain = nullptr;\n+  if (accessing_klass != nullptr) {\n@@ -494,1 +494,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -498,1 +498,1 @@\n-  ciKlass* new_klass = NULL;\n+  ciKlass* new_klass = nullptr;\n@@ -508,1 +508,1 @@\n-    ciKlass* element_klass = NULL;\n+    ciKlass* element_klass = nullptr;\n@@ -525,3 +525,3 @@\n-    jobject loader_handle = NULL;\n-    jobject domain_handle = NULL;\n-    if (accessing_klass != NULL) {\n+    jobject loader_handle = nullptr;\n+    jobject domain_handle = nullptr;\n+    if (accessing_klass != nullptr) {\n@@ -576,1 +576,1 @@\n-  assert(ciEnv::_Class_klass != NULL, \"\");\n+  assert(ciEnv::_Class_klass != nullptr, \"\");\n@@ -590,1 +590,1 @@\n-  assert(ciEnv::_MethodHandle_klass != NULL, \"\");\n+  assert(ciEnv::_MethodHandle_klass != nullptr, \"\");\n@@ -601,1 +601,1 @@\n-  assert(ciEnv::_MethodType_klass != NULL, \"\");\n+  assert(ciEnv::_MethodType_klass != nullptr, \"\");\n@@ -606,1 +606,1 @@\n-  assert(ciEnv::_Object_klass != NULL, \"\");\n+  assert(ciEnv::_Object_klass != nullptr, \"\");\n@@ -652,1 +652,1 @@\n-static ciObjectFactory::NonPermObject* emptyBucket = NULL;\n+static ciObjectFactory::NonPermObject* emptyBucket = nullptr;\n@@ -664,1 +664,1 @@\n-  for (NonPermObject* p; (p = (*bp)) != NULL; bp = &p->next()) {\n+  for (NonPermObject* p; (p = (*bp)) != nullptr; bp = &p->next()) {\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-    if (_stream == NULL) {\n+    if (_stream == nullptr) {\n@@ -154,2 +154,2 @@\n-    _ci_inline_records = NULL;\n-    _error_message = NULL;\n+    _ci_inline_records = nullptr;\n+    _error_message = nullptr;\n@@ -161,2 +161,2 @@\n-    _imethod = NULL;\n-    _iklass  = NULL;\n+    _imethod = nullptr;\n+    _iklass  = nullptr;\n@@ -171,1 +171,1 @@\n-    if (_stream != NULL) fclose(_stream);\n+    if (_stream != nullptr) fclose(_stream);\n@@ -187,1 +187,1 @@\n-    return _error_message != NULL || _thread->has_pending_exception();\n+    return _error_message != nullptr || _thread->has_pending_exception();\n@@ -191,1 +191,1 @@\n-    return !(_stream == NULL || had_error());\n+    return !(_stream == nullptr || had_error());\n@@ -250,1 +250,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -256,1 +256,1 @@\n-    if (had_error()) return NULL;\n+    if (had_error()) return nullptr;\n@@ -263,1 +263,1 @@\n-    if (had_error()) return NULL;\n+    if (had_error()) return nullptr;\n@@ -277,1 +277,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -286,1 +286,1 @@\n-    if (t == NULL) {\n+    if (t == nullptr) {\n@@ -303,1 +303,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -345,1 +345,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -360,1 +360,1 @@\n-    if (str != NULL) {\n+    if (str != nullptr) {\n@@ -364,1 +364,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -369,1 +369,1 @@\n-    if (terminator != NULL && strcmp(terminator, \";\") == 0) {\n+    if (terminator != nullptr && strcmp(terminator, \";\") == 0) {\n@@ -380,1 +380,1 @@\n-    oop obj = NULL;\n+    oop obj = nullptr;\n@@ -384,2 +384,2 @@\n-      if (m == NULL) {\n-        return NULL;\n+      if (m == nullptr) {\n+        return nullptr;\n@@ -397,1 +397,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -405,1 +405,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -410,1 +410,1 @@\n-      ConstantPoolCacheEntry* cp_cache_entry = NULL;\n+      ConstantPoolCacheEntry* cp_cache_entry = nullptr;\n@@ -427,1 +427,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -435,1 +435,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -438,1 +438,1 @@\n-        if (adapter == NULL) {\n+        if (adapter == nullptr) {\n@@ -440,1 +440,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -449,1 +449,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -455,1 +455,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -459,2 +459,2 @@\n-      if (k == NULL) {\n-        return NULL;\n+      if (k == nullptr) {\n+        return nullptr;\n@@ -469,1 +469,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -473,1 +473,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -478,1 +478,1 @@\n-    if (obj == NULL) {\n+    if (obj == nullptr) {\n@@ -480,1 +480,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -482,1 +482,1 @@\n-    Klass* k = NULL;\n+    Klass* k = nullptr;\n@@ -485,1 +485,1 @@\n-    char* field = NULL;\n+    char* field = nullptr;\n@@ -488,1 +488,1 @@\n-      if (field == NULL) {\n+      if (field == nullptr) {\n@@ -490,1 +490,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -498,2 +498,2 @@\n-        k = (vmtarget == NULL) ? NULL : vmtarget->method_holder();\n-        if (k == NULL) {\n+        k = (vmtarget == nullptr) ? nullptr : vmtarget->method_holder();\n+        if (k == nullptr) {\n@@ -501,1 +501,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -505,1 +505,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -511,1 +511,1 @@\n-      if (obj != NULL && obj->is_objArray()) {\n+      if (obj != nullptr && obj->is_objArray()) {\n@@ -516,1 +516,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -520,2 +520,2 @@\n-    } while (obj != NULL);\n-    if (obj == NULL) {\n+    } while (obj != nullptr);\n+    if (obj == nullptr) {\n@@ -523,1 +523,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -539,1 +539,1 @@\n-      if (k != NULL && !k->is_hidden()) {\n+      if (k != nullptr && !k->is_hidden()) {\n@@ -541,1 +541,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -547,3 +547,3 @@\n-    if (klass_name != NULL) {\n-      Klass* k = NULL;\n-      if (_iklass != NULL) {\n+    if (klass_name != nullptr) {\n+      Klass* k = nullptr;\n+      if (_iklass != nullptr) {\n@@ -561,1 +561,1 @@\n-          _error_message = NULL;\n+          _error_message = nullptr;\n@@ -563,1 +563,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -567,1 +567,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -579,1 +579,1 @@\n-    if (k == NULL) {\n+    if (k == nullptr) {\n@@ -581,1 +581,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -586,1 +586,1 @@\n-    if (m == NULL) {\n+    if (m == nullptr) {\n@@ -630,1 +630,1 @@\n-          _error_message = NULL;\n+          _error_message = nullptr;\n@@ -642,1 +642,1 @@\n-    if (cmd == NULL) {\n+    if (cmd == nullptr) {\n@@ -683,1 +683,1 @@\n-    char* msg = NULL;\n+    char* msg = nullptr;\n@@ -694,1 +694,1 @@\n-    if (msg != NULL) {\n+    if (msg != nullptr) {\n@@ -713,2 +713,2 @@\n-      if (cmd == NULL || strcmp(\"compile\", cmd) != 0) {\n-        return NULL;\n+      if (cmd == nullptr || strcmp(\"compile\", cmd) != 0) {\n+        return nullptr;\n@@ -720,1 +720,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -722,1 +722,1 @@\n-      if (_ci_inline_records != NULL && _ci_inline_records->length() > 0) {\n+      if (_ci_inline_records != nullptr && _ci_inline_records->length() > 0) {\n@@ -728,1 +728,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -740,1 +740,1 @@\n-    if (_imethod != NULL) {\n+    if (_imethod != nullptr) {\n@@ -782,1 +782,1 @@\n-    if (_imethod != NULL) {\n+    if (_imethod != nullptr) {\n@@ -800,1 +800,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -806,1 +806,1 @@\n-    replay_state = NULL;\n+    replay_state = nullptr;\n@@ -830,1 +830,1 @@\n-    assert(method->method_data() == NULL, \"Should only be initialized once\");\n+    assert(method->method_data() == nullptr, \"Should only be initialized once\");\n@@ -845,1 +845,1 @@\n-    if (rec->_orig_data == NULL) {\n+    if (rec->_orig_data == nullptr) {\n@@ -849,1 +849,1 @@\n-    if (rec->_data == NULL) {\n+    if (rec->_data == nullptr) {\n@@ -893,2 +893,2 @@\n-      if (!_protection_domain_initialized && k != NULL) {\n-        assert(_protection_domain() == NULL, \"must be uninitialized\");\n+      if (!_protection_domain_initialized && k != nullptr) {\n+        assert(_protection_domain() == nullptr, \"must be uninitialized\");\n@@ -904,1 +904,1 @@\n-    if (k == NULL) {\n+    if (k == nullptr) {\n@@ -908,1 +908,1 @@\n-    bool is_comment = comment != NULL && strcmp(comment, \"#\") == 0;\n+    bool is_comment = comment != nullptr && strcmp(comment, \"#\") == 0;\n@@ -930,1 +930,1 @@\n-    if (k == NULL) {\n+    if (k == nullptr) {\n@@ -1030,1 +1030,1 @@\n-      const char* string_value = bt != T_PRIMITIVE_OBJECT ? _replay->parse_escaped_string() : NULL;\n+      const char* string_value = bt != T_PRIMITIVE_OBJECT ? _replay->parse_escaped_string() : nullptr;\n@@ -1106,1 +1106,1 @@\n-      oop value = NULL;\n+      oop value = nullptr;\n@@ -1175,2 +1175,2 @@\n-    if (k == NULL || ReplaySuppressInitializers == 0 ||\n-        (ReplaySuppressInitializers == 2 && k->class_loader() == NULL)) {\n+    if (k == nullptr || ReplaySuppressInitializers == 0 ||\n+        (ReplaySuppressInitializers == 2 && k->class_loader() == nullptr)) {\n@@ -1287,1 +1287,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1309,1 +1309,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1335,1 +1335,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1353,1 +1353,1 @@\n-    if (_ci_inline_records != NULL) {\n+    if (_ci_inline_records != nullptr) {\n@@ -1356,1 +1356,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1361,1 +1361,1 @@\n-    if (records != NULL) {\n+    if (records != nullptr) {\n@@ -1376,1 +1376,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1384,1 +1384,1 @@\n-    _error_message = NULL;\n+    _error_message = nullptr;\n@@ -1447,1 +1447,1 @@\n-  return replay_state == NULL;\n+  return replay_state == nullptr;\n@@ -1453,1 +1453,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1461,1 +1461,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1469,1 +1469,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1474,1 +1474,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1530,1 +1530,1 @@\n-  if (rec == NULL) {\n+  if (rec == nullptr) {\n@@ -1550,1 +1550,1 @@\n-        if (k != NULL) {\n+        if (k != nullptr) {\n@@ -1580,1 +1580,1 @@\n-  return replay_state->find_ciMethodRecord(method->get_Method()) == NULL;\n+  return replay_state->find_ciMethodRecord(method->get_Method()) == nullptr;\n@@ -1584,1 +1584,1 @@\n-  if (data != NULL) {\n+  if (data != nullptr) {\n@@ -1589,1 +1589,1 @@\n-    if (record == NULL) {\n+    if (record == nullptr) {\n@@ -1594,1 +1594,1 @@\n-  } else if (replay_state != NULL) {\n+  } else if (replay_state != nullptr) {\n@@ -1598,1 +1598,1 @@\n-    if (record == NULL) {\n+    if (record == nullptr) {\n@@ -1608,1 +1608,1 @@\n-  if (data != NULL) {\n+  if (data != nullptr) {\n@@ -1612,2 +1612,2 @@\n-    return CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth) == NULL;\n-  } else if (replay_state != NULL) {\n+    return CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth) == nullptr;\n+  } else if (replay_state != nullptr) {\n@@ -1616,1 +1616,1 @@\n-    return replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth) == NULL;\n+    return replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth) == nullptr;\n@@ -1631,1 +1631,1 @@\n-  if (rec == NULL) {\n+  if (rec == nullptr) {\n@@ -1641,1 +1641,1 @@\n-    m->_instructions_size = -1;\n+    m->_inline_instructions_size = -1;\n@@ -1645,1 +1645,1 @@\n-    guarantee(mcs != NULL, \"method counters allocation failed\");\n+    guarantee(mcs != nullptr, \"method counters allocation failed\");\n@@ -1656,1 +1656,1 @@\n-  assert(rec != NULL, \"ciInstanceKlass must be whitelisted\");\n+  assert(rec != nullptr, \"ciInstanceKlass must be whitelisted\");\n@@ -1669,1 +1669,1 @@\n-  return rec != NULL;\n+  return rec != nullptr;\n@@ -1679,1 +1679,1 @@\n-  return rec == NULL;\n+  return rec == nullptr;\n@@ -1707,2 +1707,2 @@\n-  } while (ik != NULL);\n-  return NULL;\n+  } while (ik != nullptr);\n+  return nullptr;\n@@ -1713,2 +1713,2 @@\n-  if (fname == NULL) {\n-    return NULL;\n+  if (fname == nullptr) {\n+    return nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":120,"deletions":120,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  : _symbol(symbol), _accessing_klass(accessing_klass), _types(CURRENT_ENV->arena(), 8, 0, NULL) {\n+  : _symbol(symbol), _accessing_klass(accessing_klass), _types(CURRENT_ENV->arena(), 8, 0, nullptr) {\n@@ -45,1 +45,1 @@\n-  assert(accessing_klass != NULL, \"need origin of access\");\n+  assert(accessing_klass != nullptr, \"need origin of access\");\n@@ -53,1 +53,1 @@\n-    ciType* type = NULL;\n+    ciType* type = nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciSignature.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    reset_to_method(NULL);\n+    reset_to_method(nullptr);\n@@ -94,3 +94,3 @@\n-    if (m == NULL) {\n-      _holder = NULL;\n-      reset(NULL, 0);\n+    if (m == nullptr) {\n+      _holder = nullptr;\n+      reset(nullptr, 0);\n@@ -308,1 +308,1 @@\n-  ciSignatureStream(ciSignature* signature, ciKlass* holder = NULL) {\n+  ciSignatureStream(ciSignature* signature, ciKlass* holder = nullptr) {\n@@ -343,1 +343,1 @@\n-    if (_holder != NULL) {\n+    if (_holder != nullptr) {\n@@ -345,1 +345,1 @@\n-      _holder = NULL;\n+      _holder = nullptr;\n@@ -385,1 +385,1 @@\n-    _exception_klass = NULL;\n+    _exception_klass = nullptr;\n@@ -391,1 +391,1 @@\n-                           ciInstanceKlass* exception_klass = NULL,\n+                           ciInstanceKlass* exception_klass = nullptr,\n@@ -400,1 +400,1 @@\n-    _exception_klass = (exception_klass != NULL && exception_klass->is_loaded()\n+    _exception_klass = (exception_klass != nullptr && exception_klass->is_loaded()\n@@ -402,1 +402,1 @@\n-                          : NULL);\n+                          : nullptr);\n@@ -436,1 +436,1 @@\n-          } else if (_exception_klass == NULL || !handler->catch_klass()->is_loaded()) {\n+          } else if (_exception_klass == nullptr || !handler->catch_klass()->is_loaded()) {\n@@ -469,1 +469,1 @@\n-Bytecode::Bytecode(const ciBytecodeStream* stream, address bcp): _bcp(bcp != NULL ? bcp : stream->cur_bcp()), _code(Bytecodes::code_at(NULL, addr_at(0))) {}\n+Bytecode::Bytecode(const ciBytecodeStream* stream, address bcp): _bcp(bcp != nullptr ? bcp : stream->cur_bcp()), _code(Bytecodes::code_at(nullptr, addr_at(0))) {}\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  assert(_symbol != NULL, \"adding null symbol\");\n+  assert(_symbol != nullptr, \"adding null symbol\");\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-  assert(_basic_types[t] != NULL, \"domain check\");\n+  assert(_basic_types[t] != nullptr, \"domain check\");\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,2 @@\n-ciTypeFlow::JsrSet::JsrSet(Arena* arena, int default_len) : _set(arena, default_len, 0, NULL) {\n-  assert(arena != NULL, \"invariant\");\n+ciTypeFlow::JsrSet::JsrSet(Arena* arena, int default_len) : _set(arena, default_len, 0, nullptr) {\n+  assert(arena != nullptr, \"invariant\");\n@@ -66,1 +66,1 @@\n-ciTypeFlow::JsrSet::JsrSet(int default_len) : _set(default_len, 0, NULL) {}\n+ciTypeFlow::JsrSet::JsrSet(int default_len) : _set(default_len, 0, nullptr) {}\n@@ -171,1 +171,1 @@\n-  JsrRecord* temp = NULL;\n+  JsrRecord* temp = nullptr;\n@@ -391,1 +391,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -395,1 +395,1 @@\n-    if (non_osr_block == NULL) {\n+    if (non_osr_block == nullptr) {\n@@ -397,1 +397,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -583,1 +583,1 @@\n-  if (array_klass == NULL) {\n+  if (array_klass == nullptr) {\n@@ -715,1 +715,1 @@\n-  ciSignature* declared_signature = NULL;\n+  ciSignature* declared_signature = nullptr;\n@@ -717,1 +717,1 @@\n-  assert(declared_signature != NULL, \"cannot be null\");\n+  assert(declared_signature != nullptr, \"cannot be null\");\n@@ -721,1 +721,1 @@\n-      trap(str, NULL,\n+      trap(str, nullptr,\n@@ -774,1 +774,1 @@\n-          trap(str, NULL,\n+          trap(str, nullptr,\n@@ -801,1 +801,1 @@\n-    trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+    trap(str, nullptr, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n@@ -951,1 +951,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -953,1 +953,1 @@\n-    int kid = (klass == NULL)? -1: log->identify(klass);\n+    int kid = (klass == nullptr)? -1: log->identify(klass);\n@@ -1689,1 +1689,1 @@\n-  _succ = NULL;\n+  _succ = nullptr;\n@@ -1713,1 +1713,1 @@\n-                         ciTypeFlow::JsrSet* jsrs) : _predecessors(outer->arena(), 1, 0, NULL) {\n+                         ciTypeFlow::JsrSet* jsrs) : _predecessors(outer->arena(), 1, 0, nullptr) {\n@@ -1715,3 +1715,3 @@\n-  _exceptions = NULL;\n-  _exc_klasses = NULL;\n-  _successors = NULL;\n+  _exceptions = nullptr;\n+  _exc_klasses = nullptr;\n+  _successors = nullptr;\n@@ -1723,1 +1723,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -1745,3 +1745,4 @@\n-  _loop = NULL;\n-  _irreducible_entry = false;\n-  _rpo_next = NULL;\n+  _loop = nullptr;\n+  _irreducible_loop_head = false;\n+  _irreducible_loop_secondary_entry = false;\n+  _rpo_next = nullptr;\n@@ -1758,1 +1759,1 @@\n-  if (_successors == NULL) {\n+  if (_successors == nullptr) {\n@@ -1767,1 +1768,1 @@\n-    Block* block = NULL;\n+    Block* block = nullptr;\n@@ -1772,1 +1773,1 @@\n-        new (arena) GrowableArray<Block*>(arena, 1, 0, NULL);\n+        new (arena) GrowableArray<Block*>(arena, 1, 0, nullptr);\n@@ -1778,1 +1779,1 @@\n-        new (arena) GrowableArray<Block*>(arena, 1, 0, NULL);\n+        new (arena) GrowableArray<Block*>(arena, 1, 0, nullptr);\n@@ -1787,1 +1788,1 @@\n-      Block* target = NULL;\n+      Block* target = nullptr;\n@@ -1803,1 +1804,1 @@\n-          new (arena) GrowableArray<Block*>(arena, 2, 0, NULL);\n+          new (arena) GrowableArray<Block*>(arena, 2, 0, nullptr);\n@@ -1813,1 +1814,1 @@\n-          new (arena) GrowableArray<Block*>(arena, 1, 0, NULL);\n+          new (arena) GrowableArray<Block*>(arena, 1, 0, nullptr);\n@@ -1821,1 +1822,1 @@\n-          new (arena) GrowableArray<Block*>(arena, 1, 0, NULL);\n+          new (arena) GrowableArray<Block*>(arena, 1, 0, nullptr);\n@@ -1829,1 +1830,1 @@\n-          new (arena) GrowableArray<Block*>(arena, 1, 0, NULL);\n+          new (arena) GrowableArray<Block*>(arena, 1, 0, nullptr);\n@@ -1839,1 +1840,1 @@\n-          new (arena) GrowableArray<Block*>(arena, len+1, 0, NULL);\n+          new (arena) GrowableArray<Block*>(arena, len+1, 0, nullptr);\n@@ -1858,1 +1859,1 @@\n-          new (arena) GrowableArray<Block*>(arena, npairs+1, 0, NULL);\n+          new (arena) GrowableArray<Block*>(arena, npairs+1, 0, nullptr);\n@@ -1881,1 +1882,1 @@\n-          new (arena) GrowableArray<Block*>(arena, 1, 0, NULL);\n+          new (arena) GrowableArray<Block*>(arena, 1, 0, nullptr);\n@@ -1887,1 +1888,1 @@\n-          new (arena) GrowableArray<Block*>(arena, 1, 0, NULL);\n+          new (arena) GrowableArray<Block*>(arena, 1, 0, nullptr);\n@@ -1919,1 +1920,1 @@\n-  assert(_exceptions == NULL && _exc_klasses == NULL, \"repeat\");\n+  assert(_exceptions == nullptr && _exc_klasses == nullptr, \"repeat\");\n@@ -1935,1 +1936,1 @@\n-  _exceptions = new (arena) GrowableArray<Block*>(arena, exc_count, 0, NULL);\n+  _exceptions = new (arena) GrowableArray<Block*>(arena, exc_count, 0, nullptr);\n@@ -1937,1 +1938,1 @@\n-                                                             0, NULL);\n+                                                             0, nullptr);\n@@ -1942,1 +1943,1 @@\n-    ciInstanceKlass* klass = NULL;\n+    ciInstanceKlass* klass = nullptr;\n@@ -1967,0 +1968,34 @@\n+\/\/ Analogous to PhaseIdealLoop::is_in_irreducible_loop\n+bool ciTypeFlow::Block::is_in_irreducible_loop() const {\n+  if (!outer()->has_irreducible_entry()) {\n+    return false; \/\/ No irreducible loop in method.\n+  }\n+  Loop* lp = loop(); \/\/ Innermost loop containing block.\n+  if (lp == nullptr) {\n+    assert(!is_post_visited(), \"must have enclosing loop once post-visited\");\n+    return false; \/\/ Not yet processed, so we do not know, yet.\n+  }\n+  \/\/ Walk all the way up the loop-tree, search for an irreducible loop.\n+  do {\n+    if (lp->is_irreducible()) {\n+      return true; \/\/ We are in irreducible loop.\n+    }\n+    if (lp->head()->pre_order() == 0) {\n+      return false; \/\/ Found root loop, terminate.\n+    }\n+    lp = lp->parent();\n+  } while (lp != nullptr);\n+  \/\/ We have \"lp->parent() == nullptr\", which happens only for infinite loops,\n+  \/\/ where no parent is attached to the loop. We did not find any irreducible\n+  \/\/ loop from this block out to lp. Thus lp only has one entry, and no exit\n+  \/\/ (it is infinite and reducible). We can always rewrite an infinite loop\n+  \/\/ that is nested inside other loops:\n+  \/\/ while(condition) { infinite_loop; }\n+  \/\/ with an equivalent program where the infinite loop is an outermost loop\n+  \/\/ that is not nested in any loop:\n+  \/\/ while(condition) { break; } infinite_loop;\n+  \/\/ Thus, we can understand lp as an outermost loop, and can terminate and\n+  \/\/ conclude: this block is in no irreducible loop.\n+  return false;\n+}\n+\n@@ -2000,1 +2035,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2011,1 +2046,3 @@\n-  if (is_irreducible_entry()) st->print(\" irred\");\n+  if (is_in_irreducible_loop()) st->print(\" in_irred\");\n+  if (is_irreducible_loop_head()) st->print(\" irred_head\");\n+  if (is_irreducible_loop_secondary_entry()) st->print(\" irred_entry\");\n@@ -2027,1 +2064,1 @@\n-  if (loop() && loop()->parent() != NULL) {\n+  if (loop() && loop()->parent() != nullptr) {\n@@ -2034,1 +2071,1 @@\n-    } while (lp->parent() != NULL);\n+    } while (lp->parent() != nullptr);\n@@ -2038,1 +2075,1 @@\n-  if (_successors == NULL) {\n+  if (_successors == nullptr) {\n@@ -2062,1 +2099,1 @@\n-  if (_exceptions == NULL) {\n+  if (_exceptions == nullptr) {\n@@ -2112,1 +2149,1 @@\n-  _failure_reason = NULL;\n+  _failure_reason = nullptr;\n@@ -2114,1 +2151,1 @@\n-  _work_list = NULL;\n+  _work_list = nullptr;\n@@ -2119,1 +2156,1 @@\n-    _idx_to_blocklist[i] = NULL;\n+    _idx_to_blocklist[i] = nullptr;\n@@ -2121,2 +2158,2 @@\n-  _block_map = NULL;  \/\/ until all blocks are seen\n-  _jsr_records = NULL;\n+  _block_map = nullptr;  \/\/ until all blocks are seen\n+  _jsr_records = nullptr;\n@@ -2133,1 +2170,1 @@\n-  next_block->set_next(NULL);\n+  next_block->set_next(nullptr);\n@@ -2156,1 +2193,1 @@\n-  Block* prev = NULL;\n+  Block* prev = nullptr;\n@@ -2159,1 +2196,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -2165,1 +2202,1 @@\n-  if (prev == NULL) {\n+  if (prev == nullptr) {\n@@ -2195,1 +2232,1 @@\n-  assert(block == NULL? (option == no_create): block->is_backedge_copy() == (option == create_backedge_copy), \"create option consistent with result\");\n+  assert(block == nullptr? (option == no_create): block->is_backedge_copy() == (option == create_backedge_copy), \"create option consistent with result\");\n@@ -2198,1 +2235,1 @@\n-    if (block != NULL) {\n+    if (block != nullptr) {\n@@ -2217,1 +2254,1 @@\n-  if (_jsr_records == NULL) {\n+  if (_jsr_records == nullptr) {\n@@ -2221,1 +2258,1 @@\n-                                                           NULL);\n+                                                           nullptr);\n@@ -2223,1 +2260,1 @@\n-  JsrRecord* record = NULL;\n+  JsrRecord* record = nullptr;\n@@ -2354,2 +2391,2 @@\n-    for (ch = lp->child(); ch != NULL && ch->head() != head; ch = ch->sibling());\n-    if (ch != NULL)\n+    for (ch = lp->child(); ch != nullptr && ch->head() != head; ch = ch->sibling());\n+    if (ch != nullptr)\n@@ -2415,2 +2452,2 @@\n-  for (Loop* lp1 = lp->parent(); lp1 != NULL; lp1 = lp1->parent()) {\n-    for (Loop* lp2 = lp1; lp2 != NULL; lp2 = lp2->sibling()) {\n+  for (Loop* lp1 = lp->parent(); lp1 != nullptr; lp1 = lp1->parent()) {\n+    for (Loop* lp2 = lp1; lp2 != nullptr; lp2 = lp2->sibling()) {\n@@ -2427,2 +2464,2 @@\n-  for (Loop* lp1 = lp; lp1 != NULL && !done; lp1 = lp1->parent()) {\n-    for (Loop* lp2 = lp1; lp2 != NULL && !done; lp2 = lp2->sibling()) {\n+  for (Loop* lp1 = lp; lp1 != nullptr && !done; lp1 = lp1->parent()) {\n+    for (Loop* lp2 = lp1; lp2 != nullptr && !done; lp2 = lp2->sibling()) {\n@@ -2547,1 +2584,1 @@\n-  GrowableArray<Block*>* successors = NULL;\n+  GrowableArray<Block*>* successors = nullptr;\n@@ -2566,1 +2603,1 @@\n-    successors = block->successors(&str, NULL, NULL);\n+    successors = block->successors(&str, nullptr, nullptr);\n@@ -2586,1 +2623,1 @@\n-  if (_current->child() != NULL) {\n+  if (_current->child() != nullptr) {\n@@ -2588,1 +2625,1 @@\n-  } else if (_current->sibling() != NULL) {\n+  } else if (_current->sibling() != nullptr) {\n@@ -2591,1 +2628,1 @@\n-    while (_current != _root && _current->sibling() == NULL) {\n+    while (_current != _root && _current->sibling() == nullptr) {\n@@ -2595,1 +2632,1 @@\n-      _current = NULL;\n+      _current = nullptr;\n@@ -2598,1 +2635,1 @@\n-      assert(_current->sibling() != NULL, \"must be more to do\");\n+      assert(_current->sibling() != nullptr, \"must be more to do\");\n@@ -2622,1 +2659,1 @@\n-  if (data == NULL || !data->is_JumpData()) {\n+  if (data == nullptr || !data->is_JumpData()) {\n@@ -2721,1 +2758,1 @@\n-  Loop* prev = NULL;\n+  Loop* prev = nullptr;\n@@ -2723,1 +2760,1 @@\n-  while (lp != NULL) {\n+  while (lp != nullptr) {\n@@ -2726,1 +2763,1 @@\n-    while (current != NULL) {\n+    while (current != nullptr) {\n@@ -2739,1 +2776,1 @@\n-    if (prev != NULL) {\n+    if (prev != nullptr) {\n@@ -2756,1 +2793,1 @@\n-  Loop* innermost = NULL; \/\/ merge of loop tree branches over all successors\n+  Loop* innermost = nullptr; \/\/ merge of loop tree branches over all successors\n@@ -2759,1 +2796,1 @@\n-    Loop*  lp   = NULL;\n+    Loop*  lp   = nullptr;\n@@ -2767,1 +2804,1 @@\n-      if (succ->loop() == NULL)\n+      if (succ->loop() == nullptr)\n@@ -2775,1 +2812,1 @@\n-      while (lp != NULL && lp->head() == succ) {\n+      while (lp != nullptr && lp->head() == succ) {\n@@ -2778,1 +2815,1 @@\n-      if (lp == NULL) {\n+      if (lp == nullptr) {\n@@ -2795,1 +2832,1 @@\n-      if (plp == NULL) {\n+      if (plp == nullptr) {\n@@ -2804,1 +2841,1 @@\n-    innermost = innermost == NULL ? lp : innermost->sorted_merge(lp);\n+    innermost = innermost == nullptr ? lp : innermost->sorted_merge(lp);\n@@ -2808,1 +2845,1 @@\n-  if (innermost == NULL) {\n+  if (innermost == nullptr) {\n@@ -2817,1 +2854,1 @@\n-      for (dl = innermost; dl != NULL && dl != blk->loop(); dl = dl->parent());\n+      for (dl = innermost; dl != nullptr && dl != blk->loop(); dl = dl->parent());\n@@ -2843,1 +2880,1 @@\n-  assert(lp != NULL, \"\");\n+  assert(lp != nullptr, \"\");\n@@ -2862,1 +2899,1 @@\n-  for (Loop* lp = this->parent(); lp != NULL; lp = lp->parent())\n+  for (Loop* lp = this->parent(); lp != nullptr; lp = lp->parent())\n@@ -2879,1 +2916,1 @@\n-  for (Loop* ch = child(); ch != NULL; ch = ch->sibling())\n+  for (Loop* ch = child(); ch != nullptr; ch = ch->sibling())\n@@ -2908,1 +2945,1 @@\n-  _rpo_list = NULL;\n+  _rpo_list = nullptr;\n@@ -2986,1 +3023,1 @@\n-  if (loop_tree_root()->child() != NULL &&\n+  if (loop_tree_root()->child() != nullptr &&\n@@ -2994,2 +3031,2 @@\n-      loop_tree_root()->set_child(NULL);\n-      for (Block* blk = _rpo_list; blk != NULL;) {\n+      loop_tree_root()->set_child(nullptr);\n+      for (Block* blk = _rpo_list; blk != nullptr;) {\n@@ -3029,1 +3066,1 @@\n-  assert(_block_map == NULL, \"single initialization\");\n+  assert(_block_map == nullptr, \"single initialization\");\n@@ -3041,1 +3078,1 @@\n-  assert(blk == NULL, \"should be done\");\n+  assert(blk == nullptr, \"should be done\");\n@@ -3044,1 +3081,1 @@\n-    assert(_block_map[j] != NULL, \"must not drop any blocks\");\n+    assert(_block_map[j] != nullptr, \"must not drop any blocks\");\n@@ -3074,1 +3111,1 @@\n-  if (blocks == NULL) {\n+  if (blocks == nullptr) {\n@@ -3076,1 +3113,1 @@\n-    if (option == no_create)  return NULL;\n+    if (option == no_create)  return nullptr;\n@@ -3079,1 +3116,1 @@\n-    blocks = new (a) GrowableArray<Block*>(a, 4, 0, NULL);\n+    blocks = new (a) GrowableArray<Block*>(a, 4, 0, nullptr);\n@@ -3094,1 +3131,1 @@\n-  if (option == no_create)  return NULL;\n+  if (option == no_create)  return nullptr;\n@@ -3109,1 +3146,1 @@\n-  if (blocks == NULL) {\n+  if (blocks == nullptr) {\n@@ -3186,1 +3223,1 @@\n-    for (Block* blk = _rpo_list; blk != NULL; blk = blk->rpo_next()) {\n+    for (Block* blk = _rpo_list; blk != nullptr; blk = blk->rpo_next()) {\n@@ -3227,1 +3264,1 @@\n-  if (env()->log() != NULL) {\n+  if (env()->log() != nullptr) {\n@@ -3230,1 +3267,1 @@\n-  if (_failure_reason == NULL) {\n+  if (_failure_reason == nullptr) {\n@@ -3254,1 +3291,1 @@\n-  ciBlock* current = NULL;\n+  ciBlock* current = nullptr;\n@@ -3257,1 +3294,1 @@\n-    if (blk != NULL && blk != current) {\n+    if (blk != nullptr && blk != current) {\n@@ -3262,1 +3299,1 @@\n-      int num_blocks = (blocks == NULL) ? 0 : blocks->length();\n+      int num_blocks = (blocks == nullptr) ? 0 : blocks->length();\n@@ -3286,1 +3323,1 @@\n-  for (Block* blk = _rpo_list; blk != NULL; blk = blk->rpo_next()) {\n+  for (Block* blk = _rpo_list; blk != nullptr; blk = blk->rpo_next()) {\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":148,"deletions":111,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,1 +189,1 @@\n-      default:        ShouldNotReachHere(); return NULL;\n+      default:        ShouldNotReachHere(); return nullptr;\n@@ -336,1 +336,1 @@\n-    \/\/ null is popped from the stack, we return NULL.  Caller beware.\n+    \/\/ null is popped from the stack, we return null.  Caller beware.\n@@ -339,1 +339,1 @@\n-      if (array == null_type())  return NULL;\n+      if (array == null_type())  return nullptr;\n@@ -346,1 +346,1 @@\n-      if (array == null_type())  return NULL;\n+      if (array == null_type())  return nullptr;\n@@ -507,2 +507,2 @@\n-    SuccIter()                        : _pred(NULL), _index(-1), _succ(NULL) {}\n-    SuccIter(Block* pred)             : _pred(pred), _index(-1), _succ(NULL) { next(); }\n+    SuccIter()                        : _pred(nullptr), _index(-1), _succ(nullptr) {}\n+    SuccIter(Block* pred)             : _pred(pred), _index(-1), _succ(nullptr) { next(); }\n@@ -541,2 +541,5 @@\n-    \/\/ This block is entry to irreducible loop.\n-    bool                             _irreducible_entry;\n+    \/\/ This block is a loop head of an irreducible loop.\n+    bool                             _irreducible_loop_head;\n+\n+    \/\/ This block is a secondary entry to an irreducible loop (entry but not head).\n+    bool                             _irreducible_loop_secondary_entry;\n@@ -596,1 +599,1 @@\n-      while (lp->parent() != NULL) {\n+      while (lp->parent() != nullptr) {\n@@ -610,1 +613,1 @@\n-      assert(_successors != NULL, \"must be filled in\");\n+      assert(_successors != nullptr, \"must be filled in\");\n@@ -621,1 +624,1 @@\n-      if (_exceptions == NULL) {\n+      if (_exceptions == nullptr) {\n@@ -630,1 +633,1 @@\n-      if (_exc_klasses == NULL) {\n+      if (_exc_klasses == nullptr) {\n@@ -693,2 +696,5 @@\n-    void   set_irreducible_entry(bool c) { _irreducible_entry = c; }\n-    bool   is_irreducible_entry() const  { return _irreducible_entry; }\n+    bool   is_in_irreducible_loop() const;\n+    void   set_irreducible_loop_head()   { _irreducible_loop_head = true; }\n+    bool   is_irreducible_loop_head() const { return _irreducible_loop_head; }\n+    void   set_irreducible_loop_secondary_entry() { _irreducible_loop_secondary_entry = true; }\n+    bool   is_irreducible_loop_secondary_entry() const { return _irreducible_loop_secondary_entry; }\n@@ -703,1 +709,1 @@\n-      for (Loop* lp = loop(); lp != NULL && lp->head() == this; lp = lp->parent())\n+      for (Loop* lp = loop(); lp != nullptr && lp->head() == this; lp = lp->parent())\n@@ -729,1 +735,1 @@\n-      _parent(NULL), _sibling(NULL), _child(NULL),\n+      _parent(nullptr), _sibling(nullptr), _child(nullptr),\n@@ -761,1 +767,2 @@\n-      entry->set_irreducible_entry(true);\n+      head()->set_irreducible_loop_head();\n+      entry->set_irreducible_loop_secondary_entry();\n@@ -779,1 +786,1 @@\n-    bool done() { return _current == NULL; }  \/\/ Finished iterating?\n+    bool done() { return _current == nullptr; }  \/\/ Finished iterating?\n@@ -824,1 +831,1 @@\n-  \/\/ with jsrs, or NULL if there is none.\n+  \/\/ with jsrs, or null if there is none.\n@@ -828,1 +835,1 @@\n-  bool failing() { return env()->failing() || _failure_reason != NULL; }\n+  bool failing() { return env()->failing() || _failure_reason != nullptr; }\n@@ -837,1 +844,1 @@\n-  int have_block_count() const      { return _block_map != NULL; }\n+  int have_block_count() const      { return _block_map != nullptr; }\n@@ -861,1 +868,1 @@\n-  bool work_list_empty() { return _work_list == NULL; }\n+  bool work_list_empty() { return _work_list == nullptr; }\n@@ -887,1 +894,1 @@\n-  Loop* loop_tree_root()              { return _loop_tree_root; }\n+  Loop* loop_tree_root() const        { return _loop_tree_root; }\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":31,"deletions":24,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,2 +163,2 @@\n-  assert(stream != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n@@ -326,1 +326,1 @@\n-        assert(utf8_buffer != NULL, \"null utf8 buffer\");\n+        assert(utf8_buffer != nullptr, \"null utf8 buffer\");\n@@ -340,1 +340,1 @@\n-        if (result == NULL) {\n+        if (result == nullptr) {\n@@ -403,1 +403,1 @@\n-  assert(cp != NULL, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n@@ -407,1 +407,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -431,2 +431,2 @@\n-  assert(cp != NULL, \"invariant\");\n-  assert(stream != NULL, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n@@ -834,1 +834,1 @@\n-  assert(name != NULL, \"name in constant pool is NULL\");\n+  assert(name != nullptr, \"name in constant pool is null\");\n@@ -839,1 +839,1 @@\n-  while (entry != NULL) {\n+  while (entry != nullptr) {\n@@ -859,1 +859,1 @@\n-  assert(super_type != NULL,\"Method doesn't support null super type\");\n+  assert(super_type != nullptr,\"Method doesn't support null super type\");\n@@ -898,3 +898,3 @@\n-  assert(stream != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n-  assert(has_nonstatic_concrete_methods != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(has_nonstatic_concrete_methods != nullptr, \"invariant\");\n@@ -929,1 +929,1 @@\n-    const Symbol* name = NULL;\n+    const Symbol* name = nullptr;\n@@ -934,2 +934,2 @@\n-        \/\/ If no duplicates, add (name, NULL) in hashtable interface_names.\n-        if (!put_after_lookup(name, NULL, interface_names)) {\n+        \/\/ If no duplicates, add (name, nullptr) in hashtable interface_names.\n+        if (!put_after_lookup(name, nullptr, interface_names)) {\n@@ -1070,2 +1070,2 @@\n-    _field_annotations(NULL),\n-    _field_type_annotations(NULL) {}\n+    _field_annotations(nullptr),\n+    _field_type_annotations(nullptr) {}\n@@ -1103,1 +1103,1 @@\n-  assert(buffer != NULL, \"invariant\");\n+  assert(buffer != nullptr, \"invariant\");\n@@ -1117,1 +1117,1 @@\n-  assert(buffer != NULL, \"invariant\");\n+  assert(buffer != nullptr, \"invariant\");\n@@ -1170,4 +1170,4 @@\n-  assert(cp != NULL, \"invariant\");\n-  assert(buffer != NULL, \"invariant\");\n-  assert(coll != NULL, \"invariant\");\n-  assert(loader_data != NULL, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(coll != nullptr, \"invariant\");\n+  assert(loader_data != nullptr, \"invariant\");\n@@ -1204,2 +1204,2 @@\n-    if (aname == NULL)  break;  \/\/ invalid annotation name\n-    const Symbol* member = NULL;\n+    if (aname == nullptr)  break;  \/\/ invalid annotation name\n+    const Symbol* member = nullptr;\n@@ -1209,1 +1209,1 @@\n-      if (member == NULL)  break;  \/\/ invalid member name\n+      if (member == nullptr)  break;  \/\/ invalid member name\n@@ -1254,5 +1254,5 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(constantvalue_index_addr != NULL, \"invariant\");\n-  assert(is_synthetic_addr != NULL, \"invariant\");\n-  assert(generic_signature_index_addr != NULL, \"invariant\");\n-  assert(parsed_annotations != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(constantvalue_index_addr != nullptr, \"invariant\");\n+  assert(is_synthetic_addr != nullptr, \"invariant\");\n+  assert(generic_signature_index_addr != nullptr, \"invariant\");\n+  assert(parsed_annotations != nullptr, \"invariant\");\n@@ -1264,1 +1264,1 @@\n-  const u1* runtime_visible_annotations = NULL;\n+  const u1* runtime_visible_annotations = nullptr;\n@@ -1266,1 +1266,1 @@\n-  const u1* runtime_invisible_annotations = NULL;\n+  const u1* runtime_invisible_annotations = nullptr;\n@@ -1268,1 +1268,1 @@\n-  const u1* runtime_visible_type_annotations = NULL;\n+  const u1* runtime_visible_type_annotations = nullptr;\n@@ -1270,1 +1270,1 @@\n-  const u1* runtime_invisible_type_annotations = NULL;\n+  const u1* runtime_invisible_type_annotations = nullptr;\n@@ -1331,1 +1331,1 @@\n-        if (runtime_visible_annotations != NULL) {\n+        if (runtime_visible_annotations != nullptr) {\n@@ -1338,1 +1338,1 @@\n-        assert(runtime_visible_annotations != NULL, \"null visible annotations\");\n+        assert(runtime_visible_annotations != nullptr, \"null visible annotations\");\n@@ -1357,1 +1357,1 @@\n-          assert(runtime_invisible_annotations != NULL, \"null invisible annotations\");\n+          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n@@ -1361,1 +1361,1 @@\n-        if (runtime_visible_type_annotations != NULL) {\n+        if (runtime_visible_type_annotations != nullptr) {\n@@ -1368,1 +1368,1 @@\n-        assert(runtime_visible_type_annotations != NULL, \"null visible type annotations\");\n+        assert(runtime_visible_type_annotations != nullptr, \"null visible type annotations\");\n@@ -1381,1 +1381,1 @@\n-          assert(runtime_invisible_type_annotations != NULL, \"null invisible type annotations\");\n+          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n@@ -1515,4 +1515,4 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(fac != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n-  assert(java_fields_count_ptr != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(fac != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(java_fields_count_ptr != nullptr, \"invariant\");\n@@ -1520,3 +1520,3 @@\n-  assert(NULL == _fields, \"invariant\");\n-  assert(NULL == _fields_annotations, \"invariant\");\n-  assert(NULL == _fields_type_annotations, \"invariant\");\n+  assert(nullptr == _fields, \"invariant\");\n+  assert(nullptr == _fields_annotations, \"invariant\");\n+  assert(nullptr == _fields_type_annotations, \"invariant\");\n@@ -1611,2 +1611,2 @@\n-      if (parsed_annotations.field_annotations() != NULL) {\n-        if (_fields_annotations == NULL) {\n+      if (parsed_annotations.field_annotations() != nullptr) {\n+        if (_fields_annotations == nullptr) {\n@@ -1614,1 +1614,1 @@\n-                                             _loader_data, length, NULL,\n+                                             _loader_data, length, nullptr,\n@@ -1618,1 +1618,1 @@\n-        parsed_annotations.set_field_annotations(NULL);\n+        parsed_annotations.set_field_annotations(nullptr);\n@@ -1620,2 +1620,2 @@\n-      if (parsed_annotations.field_type_annotations() != NULL) {\n-        if (_fields_type_annotations == NULL) {\n+      if (parsed_annotations.field_type_annotations() != nullptr) {\n+        if (_fields_type_annotations == nullptr) {\n@@ -1625,1 +1625,1 @@\n-                                                         NULL,\n+                                                         nullptr,\n@@ -1629,1 +1629,1 @@\n-        parsed_annotations.set_field_type_annotations(NULL);\n+        parsed_annotations.set_field_type_annotations(nullptr);\n@@ -1727,1 +1727,1 @@\n-  assert(NULL == _fields, \"invariant\");\n+  assert(nullptr == _fields, \"invariant\");\n@@ -1756,2 +1756,2 @@\n-    const Symbol* name = NULL;\n-    const Symbol* sig = NULL;\n+    const Symbol* name = nullptr;\n+    const Symbol* sig = nullptr;\n@@ -1782,1 +1782,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -1785,1 +1785,1 @@\n-  assert(exception_table_start != NULL, \"null exception table\");\n+  assert(exception_table_start != nullptr, \"null exception table\");\n@@ -1834,1 +1834,1 @@\n-  if ((*write_stream) == NULL) {\n+  if ((*write_stream) == nullptr) {\n@@ -1923,1 +1923,1 @@\n-  assert(localvariable_table_start != NULL, \"null local variable table\");\n+  assert(localvariable_table_start != nullptr, \"null local variable table\");\n@@ -1941,1 +1941,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1947,1 +1947,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1980,2 +1980,1 @@\n-                                      bool need_verify,\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -1985,1 +1984,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1989,1 +1988,1 @@\n-  assert(stackmap_table_start != NULL, \"null stackmap table\");\n+  assert(stackmap_table_start != nullptr, \"null stackmap table\");\n@@ -1991,1 +1990,1 @@\n-  \/\/ check code_attribute_length first\n+  \/\/ check code_attribute_length\n@@ -1994,3 +1993,0 @@\n-  if (!need_verify && !DumpSharedSpaces) {\n-    return NULL;\n-  }\n@@ -2004,2 +2000,2 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(checked_exceptions_length != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(checked_exceptions_length != nullptr, \"invariant\");\n@@ -2012,1 +2008,1 @@\n-  assert(checked_exceptions_start != NULL, \"null checked exceptions\");\n+  assert(checked_exceptions_start != nullptr, \"null checked exceptions\");\n@@ -2041,2 +2037,2 @@\n-  assert(name != NULL, \"invariant\");\n-  assert(sig != NULL, \"invariant\");\n+  assert(name != nullptr, \"invariant\");\n+  assert(sig != nullptr, \"invariant\");\n@@ -2186,1 +2182,1 @@\n-  assert(ik != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n@@ -2262,1 +2258,1 @@\n-      if (entry == NULL) {\n+      if (entry == nullptr) {\n@@ -2327,1 +2323,1 @@\n-                             NULL,\n+                             nullptr,\n@@ -2359,3 +2355,3 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n-  assert(has_localvariable_table != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(has_localvariable_table != nullptr, \"invariant\");\n@@ -2394,1 +2390,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2455,1 +2451,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2466,1 +2462,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2478,1 +2474,1 @@\n-  const unsafe_u2* exception_table_start = NULL; \/\/ (potentially unaligned) pointer to array of u2 elements\n+  const unsafe_u2* exception_table_start = nullptr; \/\/ (potentially unaligned) pointer to array of u2 elements\n@@ -2481,2 +2477,2 @@\n-  const unsafe_u2* checked_exceptions_start = NULL; \/\/ (potentially unaligned) pointer to array of u2 elements\n-  CompressedLineNumberWriteStream* linenumber_table = NULL;\n+  const unsafe_u2* checked_exceptions_start = nullptr; \/\/ (potentially unaligned) pointer to array of u2 elements\n+  CompressedLineNumberWriteStream* linenumber_table = nullptr;\n@@ -2490,4 +2486,4 @@\n-  u2* localvariable_table_length = NULL;\n-  const unsafe_u2** localvariable_table_start = NULL; \/\/ (potentially unaligned) pointer to array of LVT attributes\n-  u2* localvariable_type_table_length = NULL;\n-  const unsafe_u2** localvariable_type_table_start = NULL; \/\/ (potentially unaligned) pointer to LVTT attributes\n+  u2* localvariable_table_length = nullptr;\n+  const unsafe_u2** localvariable_table_start = nullptr; \/\/ (potentially unaligned) pointer to array of LVT attributes\n+  u2* localvariable_type_table_length = nullptr;\n+  const unsafe_u2** localvariable_type_table_start = nullptr; \/\/ (potentially unaligned) pointer to LVTT attributes\n@@ -2495,1 +2491,1 @@\n-  const u1* method_parameters_data = NULL;\n+  const u1* method_parameters_data = nullptr;\n@@ -2501,1 +2497,1 @@\n-  const u1* stackmap_data = NULL;\n+  const u1* stackmap_data = nullptr;\n@@ -2505,1 +2501,1 @@\n-  const u1* runtime_visible_annotations = NULL;\n+  const u1* runtime_visible_annotations = nullptr;\n@@ -2507,1 +2503,1 @@\n-  const u1* runtime_invisible_annotations = NULL;\n+  const u1* runtime_invisible_annotations = nullptr;\n@@ -2509,1 +2505,1 @@\n-  const u1* runtime_visible_parameter_annotations = NULL;\n+  const u1* runtime_visible_parameter_annotations = nullptr;\n@@ -2511,1 +2507,1 @@\n-  const u1* runtime_invisible_parameter_annotations = NULL;\n+  const u1* runtime_invisible_parameter_annotations = nullptr;\n@@ -2513,1 +2509,1 @@\n-  const u1* runtime_visible_type_annotations = NULL;\n+  const u1* runtime_visible_type_annotations = nullptr;\n@@ -2515,1 +2511,1 @@\n-  const u1* runtime_invisible_type_annotations = NULL;\n+  const u1* runtime_invisible_type_annotations = nullptr;\n@@ -2520,1 +2516,1 @@\n-  const u1* annotation_default = NULL;\n+  const u1* annotation_default = nullptr;\n@@ -2546,1 +2542,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2565,1 +2561,1 @@\n-      assert(code_start != NULL, \"null code start\");\n+      assert(code_start != nullptr, \"null code start\");\n@@ -2679,1 +2675,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -2681,1 +2677,1 @@\n-          stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);\n+          stackmap_data = parse_stackmap_table(cfs, code_attribute_length, CHECK_NULL);\n@@ -2700,1 +2696,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2713,1 +2709,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2722,1 +2718,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2735,1 +2731,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2744,1 +2740,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2752,1 +2748,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2758,1 +2754,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2762,1 +2758,1 @@\n-        if (runtime_visible_annotations != NULL) {\n+        if (runtime_visible_annotations != nullptr) {\n@@ -2766,1 +2762,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2770,1 +2766,1 @@\n-        assert(runtime_visible_annotations != NULL, \"null visible annotations\");\n+        assert(runtime_visible_annotations != nullptr, \"null visible annotations\");\n@@ -2784,1 +2780,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2790,1 +2786,1 @@\n-          assert(runtime_invisible_annotations != NULL, \"null invisible annotations\");\n+          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n@@ -2794,1 +2790,1 @@\n-        if (runtime_visible_parameter_annotations != NULL) {\n+        if (runtime_visible_parameter_annotations != nullptr) {\n@@ -2798,1 +2794,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2802,1 +2798,1 @@\n-        assert(runtime_visible_parameter_annotations != NULL, \"null visible parameter annotations\");\n+        assert(runtime_visible_parameter_annotations != nullptr, \"null visible parameter annotations\");\n@@ -2809,1 +2805,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2815,1 +2811,1 @@\n-          assert(runtime_invisible_parameter_annotations != NULL,\n+          assert(runtime_invisible_parameter_annotations != nullptr,\n@@ -2820,1 +2816,1 @@\n-        if (annotation_default != NULL) {\n+        if (annotation_default != nullptr) {\n@@ -2824,1 +2820,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2828,1 +2824,1 @@\n-        assert(annotation_default != NULL, \"null annotation default\");\n+        assert(annotation_default != nullptr, \"null annotation default\");\n@@ -2831,1 +2827,1 @@\n-        if (runtime_visible_type_annotations != NULL) {\n+        if (runtime_visible_type_annotations != nullptr) {\n@@ -2835,1 +2831,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2839,1 +2835,1 @@\n-        assert(runtime_visible_type_annotations != NULL, \"null visible type annotations\");\n+        assert(runtime_visible_type_annotations != nullptr, \"null visible type annotations\");\n@@ -2847,1 +2843,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2854,1 +2850,1 @@\n-          assert(runtime_invisible_type_annotations != NULL, \"null invisible type annotations\");\n+          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n@@ -2867,1 +2863,1 @@\n-  if (linenumber_table != NULL) {\n+  if (linenumber_table != nullptr) {\n@@ -2918,1 +2914,1 @@\n-  if (stackmap_data != NULL) {\n+  if (stackmap_data != nullptr) {\n@@ -2929,1 +2925,1 @@\n-  if (linenumber_table != NULL) {\n+  if (linenumber_table != nullptr) {\n@@ -3029,4 +3025,4 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(has_localvariable_table != NULL, \"invariant\");\n-  assert(has_final_method != NULL, \"invariant\");\n-  assert(declares_nonstatic_concrete_methods != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(has_localvariable_table != nullptr, \"invariant\");\n+  assert(has_final_method != nullptr, \"invariant\");\n+  assert(declares_nonstatic_concrete_methods != nullptr, \"invariant\");\n@@ -3034,1 +3030,1 @@\n-  assert(NULL == _methods, \"invariant\");\n+  assert(nullptr == _methods, \"invariant\");\n@@ -3043,1 +3039,1 @@\n-                                                   NULL,\n+                                                   nullptr,\n@@ -3074,2 +3070,2 @@\n-      const Symbol* name = NULL;\n-      const Symbol* sig = NULL;\n+      const Symbol* name = nullptr;\n+      const Symbol* sig = nullptr;\n@@ -3115,1 +3111,1 @@\n-  intArray* method_ordering = NULL;\n+  intArray* method_ordering = nullptr;\n@@ -3134,1 +3130,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -3148,1 +3144,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -3162,1 +3158,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -3165,1 +3161,1 @@\n-  assert(sde_buffer != NULL, \"null sde buffer\");\n+  assert(sde_buffer != nullptr, \"null sde buffer\");\n@@ -3275,1 +3271,1 @@\n-  if (inner_classes_attribute_start != NULL) {\n+  if (inner_classes_attribute_start != nullptr) {\n@@ -3399,1 +3395,1 @@\n-  if (nest_members_attribute_start != NULL) {\n+  if (nest_members_attribute_start != nullptr) {\n@@ -3431,1 +3427,1 @@\n-  if (permitted_subclasses_attribute_start != NULL) {\n+  if (permitted_subclasses_attribute_start != nullptr) {\n@@ -3465,1 +3461,1 @@\n-  if (preload_attribute_start != NULL) {\n+  if (preload_attribute_start != nullptr) {\n@@ -3512,1 +3508,1 @@\n-  if (record_attribute_start != NULL) {\n+  if (record_attribute_start != nullptr) {\n@@ -3520,1 +3516,1 @@\n-    MetadataFactory::new_array<RecordComponent*>(_loader_data, components_count, NULL, CHECK_0);\n+    MetadataFactory::new_array<RecordComponent*>(_loader_data, components_count, nullptr, CHECK_0);\n@@ -3543,1 +3539,1 @@\n-    const u1* runtime_visible_annotations = NULL;\n+    const u1* runtime_visible_annotations = nullptr;\n@@ -3545,1 +3541,1 @@\n-    const u1* runtime_invisible_annotations = NULL;\n+    const u1* runtime_invisible_annotations = nullptr;\n@@ -3548,1 +3544,1 @@\n-    const u1* runtime_visible_type_annotations = NULL;\n+    const u1* runtime_visible_type_annotations = nullptr;\n@@ -3550,1 +3546,1 @@\n-    const u1* runtime_invisible_type_annotations = NULL;\n+    const u1* runtime_invisible_type_annotations = nullptr;\n@@ -3583,1 +3579,1 @@\n-        if (runtime_visible_annotations != NULL) {\n+        if (runtime_visible_annotations != nullptr) {\n@@ -3591,1 +3587,1 @@\n-        assert(runtime_visible_annotations != NULL, \"null record component visible annotation\");\n+        assert(runtime_visible_annotations != nullptr, \"null record component visible annotation\");\n@@ -3605,1 +3601,1 @@\n-          assert(runtime_invisible_annotations != NULL, \"null record component invisible annotation\");\n+          assert(runtime_invisible_annotations != nullptr, \"null record component invisible annotation\");\n@@ -3610,1 +3606,1 @@\n-        if (runtime_visible_type_annotations != NULL) {\n+        if (runtime_visible_type_annotations != nullptr) {\n@@ -3618,1 +3614,1 @@\n-        assert(runtime_visible_type_annotations != NULL, \"null record component visible type annotation\");\n+        assert(runtime_visible_type_annotations != nullptr, \"null record component visible type annotation\");\n@@ -3632,1 +3628,1 @@\n-          assert(runtime_invisible_type_annotations != NULL, \"null record component invisible type annotation\");\n+          assert(runtime_invisible_type_annotations != nullptr, \"null record component invisible type annotation\");\n@@ -3671,1 +3667,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -3685,2 +3681,2 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n@@ -3767,3 +3763,3 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n-  assert(parsed_annotations != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(parsed_annotations != nullptr, \"invariant\");\n@@ -3790,1 +3786,1 @@\n-  const u1* runtime_visible_annotations = NULL;\n+  const u1* runtime_visible_annotations = nullptr;\n@@ -3792,1 +3788,1 @@\n-  const u1* runtime_invisible_annotations = NULL;\n+  const u1* runtime_invisible_annotations = nullptr;\n@@ -3794,1 +3790,1 @@\n-  const u1* runtime_visible_type_annotations = NULL;\n+  const u1* runtime_visible_type_annotations = nullptr;\n@@ -3796,1 +3792,1 @@\n-  const u1* runtime_invisible_type_annotations = NULL;\n+  const u1* runtime_invisible_type_annotations = nullptr;\n@@ -3801,1 +3797,1 @@\n-  const u1* inner_classes_attribute_start = NULL;\n+  const u1* inner_classes_attribute_start = nullptr;\n@@ -3805,1 +3801,1 @@\n-  const u1* nest_members_attribute_start = NULL;\n+  const u1* nest_members_attribute_start = nullptr;\n@@ -3807,1 +3803,1 @@\n-  const u1* record_attribute_start = NULL;\n+  const u1* record_attribute_start = nullptr;\n@@ -3809,1 +3805,1 @@\n-  const u1* permitted_subclasses_attribute_start = NULL;\n+  const u1* permitted_subclasses_attribute_start = nullptr;\n@@ -3811,1 +3807,1 @@\n-  const u1* preload_attribute_start = NULL;\n+  const u1* preload_attribute_start = nullptr;\n@@ -3889,1 +3885,1 @@\n-        if (runtime_visible_annotations != NULL) {\n+        if (runtime_visible_annotations != nullptr) {\n@@ -3896,1 +3892,1 @@\n-        assert(runtime_visible_annotations != NULL, \"null visible annotations\");\n+        assert(runtime_visible_annotations != nullptr, \"null visible annotations\");\n@@ -3915,1 +3911,1 @@\n-          assert(runtime_invisible_annotations != NULL, \"null invisible annotations\");\n+          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n@@ -3953,1 +3949,1 @@\n-        if (runtime_visible_type_annotations != NULL) {\n+        if (runtime_visible_type_annotations != nullptr) {\n@@ -3960,1 +3956,1 @@\n-        assert(runtime_visible_type_annotations != NULL, \"null visible type annotations\");\n+        assert(runtime_visible_type_annotations != nullptr, \"null visible type annotations\");\n@@ -3974,1 +3970,1 @@\n-          assert(runtime_invisible_type_annotations != NULL, \"null invisible type annotations\");\n+          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n@@ -4147,1 +4143,1 @@\n-  assert(k != NULL, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n@@ -4157,1 +4153,1 @@\n-  if (_sde_buffer != NULL) {\n+  if (_sde_buffer != nullptr) {\n@@ -4165,4 +4161,4 @@\n-    if (_class_annotations == NULL &&\n-        _class_type_annotations == NULL &&\n-        _fields_annotations == NULL &&\n-        _fields_type_annotations == NULL) {\n+    if (_class_annotations == nullptr &&\n+        _class_type_annotations == nullptr &&\n+        _fields_annotations == nullptr &&\n+        _fields_type_annotations == nullptr) {\n@@ -4185,4 +4181,4 @@\n-    _class_annotations       = NULL;\n-    _class_type_annotations  = NULL;\n-    _fields_annotations      = NULL;\n-    _fields_type_annotations = NULL;\n+    _class_annotations       = nullptr;\n+    _class_type_annotations  = nullptr;\n+    _fields_annotations      = nullptr;\n+    _fields_type_annotations = nullptr;\n@@ -4195,1 +4191,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4225,3 +4221,3 @@\n-  AnnotationArray* annotations = NULL;\n-  if (runtime_visible_annotations != NULL ||\n-      runtime_invisible_annotations != NULL) {\n+  AnnotationArray* annotations = nullptr;\n+  if (runtime_visible_annotations != nullptr ||\n+      runtime_invisible_annotations != nullptr) {\n@@ -4232,1 +4228,1 @@\n-    if (runtime_visible_annotations != NULL) {\n+    if (runtime_visible_annotations != nullptr) {\n@@ -4237,1 +4233,1 @@\n-    if (runtime_invisible_annotations != NULL) {\n+    if (runtime_invisible_annotations != nullptr) {\n@@ -4251,2 +4247,2 @@\n-  assert(cp != NULL, \"invariant\");\n-  const InstanceKlass* super_klass = NULL;\n+  assert(cp != nullptr, \"invariant\");\n+  const InstanceKlass* super_klass = nullptr;\n@@ -4281,1 +4277,1 @@\n-    _nonstatic_oop_maps = NULL;\n+    _nonstatic_oop_maps = nullptr;\n@@ -4399,1 +4395,1 @@\n-  if (name == NULL || sig == NULL) {\n+  if (name == nullptr || sig == nullptr) {\n@@ -4413,1 +4409,1 @@\n-  assert(ik != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n@@ -4421,1 +4417,1 @@\n-        (super != NULL && super->has_finalizer())) {\n+        (super != nullptr && super->has_finalizer())) {\n@@ -4431,1 +4427,1 @@\n-      (m != NULL) && !m->is_empty_method()) {\n+      (m != nullptr) && !m->is_empty_method()) {\n@@ -4456,1 +4452,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -4470,1 +4466,1 @@\n-      if (constructor != NULL && constructor->is_vanilla_constructor()) {\n+      if (constructor != nullptr && constructor->is_vanilla_constructor()) {\n@@ -4483,1 +4479,1 @@\n-      || (ik->name() == vmSymbols::java_lang_Class() && ik->class_loader() == NULL)\n+      || (ik->name() == vmSymbols::java_lang_Class() && ik->class_loader() == nullptr)\n@@ -4514,2 +4510,2 @@\n-  assert(local_ifs != NULL, \"invariant\");\n-  assert(loader_data != NULL, \"invariant\");\n+  assert(local_ifs != nullptr, \"invariant\");\n+  assert(loader_data != nullptr, \"invariant\");\n@@ -4521,1 +4517,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -4549,1 +4545,1 @@\n-    if (super != NULL) {\n+    if (super != nullptr) {\n@@ -4569,1 +4565,1 @@\n-      assert(e != NULL, \"just checking\");\n+      assert(e != nullptr, \"just checking\");\n@@ -4577,1 +4573,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4580,1 +4576,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -4608,1 +4604,1 @@\n-      if (super_package != NULL &&\n+      if (super_package != nullptr &&\n@@ -4630,1 +4626,1 @@\n-      if (msg == NULL) {\n+      if (msg == nullptr) {\n@@ -4656,1 +4652,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4661,1 +4657,1 @@\n-    assert (k != NULL && k->is_interface(), \"invalid interface\");\n+    assert (k != nullptr && k->is_interface(), \"invalid interface\");\n@@ -4678,1 +4674,1 @@\n-      if (msg == NULL) {\n+      if (msg == nullptr) {\n@@ -4703,1 +4699,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4718,2 +4714,2 @@\n-      const Method* super_m = NULL;\n-      while (k != NULL) {\n+      const Method* super_m = nullptr;\n+      while (k != nullptr) {\n@@ -4724,1 +4720,1 @@\n-          if (super_m == NULL) {\n+          if (super_m == nullptr) {\n@@ -4762,1 +4758,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4791,1 +4787,1 @@\n-  const bool is_inner_class = name != NULL;\n+  const bool is_inner_class = name != nullptr;\n@@ -4848,1 +4844,1 @@\n-    if (name == NULL) { \/\/ Not an inner class\n+    if (name == nullptr) { \/\/ Not an inner class\n@@ -5146,1 +5142,1 @@\n-\/\/ Return NULL if no fieldname at all was found, or in the case of slash_ok\n+\/\/ Return null if no fieldname at all was found, or in the case of slash_ok\n@@ -5171,1 +5167,1 @@\n-          return NULL;  \/\/ Don't permit consecutive slashes\n+          return nullptr;  \/\/ Don't permit consecutive slashes\n@@ -5210,1 +5206,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -5216,1 +5212,1 @@\n-    return (not_first_ch) ? old_p : NULL;\n+    return (not_first_ch) ? old_p : nullptr;\n@@ -5218,1 +5214,1 @@\n-  return (not_first_ch && !last_is_slash) ? p : NULL;\n+  return (not_first_ch && !last_is_slash) ? p : nullptr;\n@@ -5225,1 +5221,1 @@\n-\/\/ Return NULL if no legal signature is found.\n+\/\/ Return null if no legal signature is found.\n@@ -5233,1 +5229,1 @@\n-    case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }\n+    case JVM_SIGNATURE_VOID: if (!void_ok) { return nullptr; }\n@@ -5250,1 +5246,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -5269,1 +5265,1 @@\n-        if (c != NULL) {\n+        if (c != nullptr) {\n@@ -5276,1 +5272,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -5281,1 +5277,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -5288,1 +5284,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -5296,1 +5292,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -5299,1 +5295,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -5315,1 +5311,1 @@\n-      legal = (p != NULL) && ((p - bytes) == (int)length);\n+      legal = (p != nullptr) && ((p - bytes) == (int)length);\n@@ -5319,1 +5315,1 @@\n-        legal = (p != NULL) && ((p - bytes) == (int)length);\n+        legal = (p != nullptr) && ((p - bytes) == (int)length);\n@@ -5335,1 +5331,1 @@\n-    assert(_class_name != NULL, \"invariant\");\n+    assert(_class_name != nullptr, \"invariant\");\n@@ -5358,1 +5354,1 @@\n-        legal = (p != NULL) && ((p - bytes) == (int)length);\n+        legal = (p != nullptr) && ((p - bytes) == (int)length);\n@@ -5368,1 +5364,1 @@\n-    assert(_class_name != NULL, \"invariant\");\n+    assert(_class_name != nullptr, \"invariant\");\n@@ -5383,1 +5379,1 @@\n-  assert(name != NULL, \"method name is null\");\n+  assert(name != nullptr, \"method name is null\");\n@@ -5399,1 +5395,1 @@\n-      legal = (p != NULL) && ((p - bytes) == (int)length);\n+      legal = (p != nullptr) && ((p - bytes) == (int)length);\n@@ -5408,1 +5404,1 @@\n-    assert(_class_name != NULL, \"invariant\");\n+    assert(_class_name != nullptr, \"invariant\");\n@@ -5433,1 +5429,1 @@\n-  if (p == NULL || (p - bytes) != (int)length) {\n+  if (p == nullptr || (p - bytes) != (int)length) {\n@@ -5487,1 +5483,1 @@\n-    while ((length > 0) && (nextp != NULL)) {\n+    while ((length > 0) && (nextp != nullptr)) {\n@@ -5512,1 +5508,1 @@\n-  assert(_field_info != NULL, \"invariant\");\n+  assert(_field_info != nullptr, \"invariant\");\n@@ -5517,1 +5513,1 @@\n-  assert(_field_info != NULL, \"invariant\");\n+  assert(_field_info != nullptr, \"invariant\");\n@@ -5522,1 +5518,1 @@\n-  assert(_field_info != NULL, \"invariant\");\n+  assert(_field_info != nullptr, \"invariant\");\n@@ -5528,2 +5524,2 @@\n-  assert(ik != NULL, \"invariant\");\n-  assert(methods != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n@@ -5624,1 +5620,1 @@\n-  if (_klass != NULL) {\n+  if (_klass != nullptr) {\n@@ -5645,1 +5641,1 @@\n-  assert(ik != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n@@ -5652,1 +5648,1 @@\n-  \/\/ including classes in the bootstrap (NULL) class loader.\n+  \/\/ including classes in the bootstrap (null) class loader.\n@@ -5659,1 +5655,1 @@\n-  assert(_field_info != NULL, \"invariant\");\n+  assert(_field_info != nullptr, \"invariant\");\n@@ -5683,1 +5679,1 @@\n-  assert(_fac != NULL, \"invariant\");\n+  assert(_fac != nullptr, \"invariant\");\n@@ -5691,1 +5687,1 @@\n-  if (cl_inst_info.dynamic_nest_host() != NULL) {\n+  if (cl_inst_info.dynamic_nest_host() != nullptr) {\n@@ -5696,9 +5692,9 @@\n-  assert(NULL == _cp, \"invariant\");\n-  assert(NULL == _fields, \"invariant\");\n-  assert(NULL == _methods, \"invariant\");\n-  assert(NULL == _inner_classes, \"invariant\");\n-  assert(NULL == _nest_members, \"invariant\");\n-  assert(NULL == _preload_classes, \"invariant\");\n-  assert(NULL == _combined_annotations, \"invariant\");\n-  assert(NULL == _record_components, \"invariant\");\n-  assert(NULL == _permitted_subclasses, \"invariant\");\n+  assert(nullptr == _cp, \"invariant\");\n+  assert(nullptr == _fields, \"invariant\");\n+  assert(nullptr == _methods, \"invariant\");\n+  assert(nullptr == _inner_classes, \"invariant\");\n+  assert(nullptr == _nest_members, \"invariant\");\n+  assert(nullptr == _preload_classes, \"invariant\");\n+  assert(nullptr == _combined_annotations, \"invariant\");\n+  assert(nullptr == _record_components, \"invariant\");\n+  assert(nullptr == _permitted_subclasses, \"invariant\");\n@@ -5751,1 +5747,1 @@\n-  ik->set_package(cld, NULL, CHECK);\n+  ik->set_package(cld, nullptr, CHECK);\n@@ -5754,1 +5750,1 @@\n-  assert(methods != NULL, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n@@ -5769,1 +5765,1 @@\n-      (_super_klass != NULL && _super_klass->has_miranda_methods())\n+      (_super_klass != nullptr && _super_klass->has_miranda_methods())\n@@ -5779,2 +5775,2 @@\n-  _transitive_interfaces = NULL;\n-  _local_interfaces = NULL;\n+  _transitive_interfaces = nullptr;\n+  _local_interfaces = nullptr;\n@@ -5793,1 +5789,1 @@\n-      ( _super_klass != NULL && _super_klass->has_contended_annotations())) {\n+      ( _super_klass != nullptr && _super_klass->has_contended_annotations())) {\n@@ -5816,1 +5812,1 @@\n-  assert(module_entry != NULL, \"module_entry should always be set\");\n+  assert(module_entry != nullptr, \"module_entry should always be set\");\n@@ -5830,1 +5826,1 @@\n-  assert(_all_mirandas != NULL, \"invariant\");\n+  assert(_all_mirandas != nullptr, \"invariant\");\n@@ -5893,1 +5889,1 @@\n-      if (ik->java_super() != NULL) {\n+      if (ik->java_super() != nullptr) {\n@@ -5900,1 +5896,1 @@\n-      if (local_interfaces != NULL) {\n+      if (local_interfaces != nullptr) {\n@@ -5916,1 +5912,1 @@\n-  set_klass_to_deallocate(NULL);\n+  set_klass_to_deallocate(nullptr);\n@@ -5953,1 +5949,1 @@\n-  _class_name(NULL),\n+  _class_name(nullptr),\n@@ -5959,5 +5955,5 @@\n-  _cp(NULL),\n-  _fields(NULL),\n-  _methods(NULL),\n-  _inner_classes(NULL),\n-  _nest_members(NULL),\n+  _cp(nullptr),\n+  _fields(nullptr),\n+  _methods(nullptr),\n+  _inner_classes(nullptr),\n+  _nest_members(nullptr),\n@@ -5965,19 +5961,19 @@\n-  _permitted_subclasses(NULL),\n-  _preload_classes(NULL),\n-  _record_components(NULL),\n-  _local_interfaces(NULL),\n-  _local_interface_indexes(NULL),\n-  _transitive_interfaces(NULL),\n-  _combined_annotations(NULL),\n-  _class_annotations(NULL),\n-  _class_type_annotations(NULL),\n-  _fields_annotations(NULL),\n-  _fields_type_annotations(NULL),\n-  _klass(NULL),\n-  _klass_to_deallocate(NULL),\n-  _parsed_annotations(NULL),\n-  _fac(NULL),\n-  _field_info(NULL),\n-  _inline_type_field_klasses(NULL),\n-  _method_ordering(NULL),\n-  _all_mirandas(NULL),\n+  _permitted_subclasses(nullptr),\n+  _preload_classes(nullptr),\n+  _record_components(nullptr),\n+  _local_interfaces(nullptr),\n+  _local_interface_indexes(nullptr),\n+  _transitive_interfaces(nullptr),\n+  _combined_annotations(nullptr),\n+  _class_annotations(nullptr),\n+  _class_type_annotations(nullptr),\n+  _fields_annotations(nullptr),\n+  _fields_type_annotations(nullptr),\n+  _klass(nullptr),\n+  _klass_to_deallocate(nullptr),\n+  _parsed_annotations(nullptr),\n+  _fac(nullptr),\n+  _field_info(nullptr),\n+  _inline_type_field_klasses(nullptr),\n+  _method_ordering(nullptr),\n+  _all_mirandas(nullptr),\n@@ -5993,1 +5989,1 @@\n-  _sde_buffer(NULL),\n+  _sde_buffer(nullptr),\n@@ -6021,1 +6017,1 @@\n-  _class_name = name != NULL ? name : vmSymbols::unknown_class_name();\n+  _class_name = name != nullptr ? name : vmSymbols::unknown_class_name();\n@@ -6024,3 +6020,3 @@\n-  assert(_loader_data != NULL, \"invariant\");\n-  assert(stream != NULL, \"invariant\");\n-  assert(_stream != NULL, \"invariant\");\n+  assert(_loader_data != nullptr, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(_stream != nullptr, \"invariant\");\n@@ -6028,1 +6024,1 @@\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -6059,11 +6055,11 @@\n-  _cp = NULL;\n-  _fields = NULL;\n-  _methods = NULL;\n-  _inner_classes = NULL;\n-  _nest_members = NULL;\n-  _permitted_subclasses = NULL;\n-  _preload_classes = NULL;\n-  _combined_annotations = NULL;\n-  _class_annotations = _class_type_annotations = NULL;\n-  _fields_annotations = _fields_type_annotations = NULL;\n-  _record_components = NULL;\n+  _cp = nullptr;\n+  _fields = nullptr;\n+  _methods = nullptr;\n+  _inner_classes = nullptr;\n+  _nest_members = nullptr;\n+  _permitted_subclasses = nullptr;\n+  _preload_classes = nullptr;\n+  _combined_annotations = nullptr;\n+  _class_annotations = _class_type_annotations = nullptr;\n+  _fields_annotations = _fields_type_annotations = nullptr;\n+  _record_components = nullptr;\n@@ -6076,1 +6072,1 @@\n-  if (_cp != NULL) {\n+  if (_cp != nullptr) {\n@@ -6079,1 +6075,1 @@\n-  if (_fields != NULL) {\n+  if (_fields != nullptr) {\n@@ -6083,1 +6079,1 @@\n-  if (_inline_type_field_klasses != NULL) {\n+  if (_inline_type_field_klasses != nullptr) {\n@@ -6087,1 +6083,1 @@\n-  if (_methods != NULL) {\n+  if (_methods != nullptr) {\n@@ -6093,1 +6089,1 @@\n-  if (_inner_classes != NULL && _inner_classes != Universe::the_empty_short_array()) {\n+  if (_inner_classes != nullptr && _inner_classes != Universe::the_empty_short_array()) {\n@@ -6097,1 +6093,1 @@\n-  if (_nest_members != NULL && _nest_members != Universe::the_empty_short_array()) {\n+  if (_nest_members != nullptr && _nest_members != Universe::the_empty_short_array()) {\n@@ -6101,1 +6097,1 @@\n-  if (_record_components != NULL) {\n+  if (_record_components != nullptr) {\n@@ -6105,1 +6101,1 @@\n-  if (_permitted_subclasses != NULL && _permitted_subclasses != Universe::the_empty_short_array()) {\n+  if (_permitted_subclasses != nullptr && _permitted_subclasses != Universe::the_empty_short_array()) {\n@@ -6109,1 +6105,1 @@\n-  if (_preload_classes != NULL && _preload_classes != Universe::the_empty_short_array()) {\n+  if (_preload_classes != nullptr && _preload_classes != Universe::the_empty_short_array()) {\n@@ -6117,1 +6113,1 @@\n-  if (_combined_annotations != NULL) {\n+  if (_combined_annotations != nullptr) {\n@@ -6124,1 +6120,1 @@\n-    \/\/ If the _combined_annotations pointer is non-NULL,\n+    \/\/ If the _combined_annotations pointer is non-null,\n@@ -6126,4 +6122,4 @@\n-    assert(_class_annotations       == NULL, \"Should have been cleared\");\n-    assert(_class_type_annotations  == NULL, \"Should have been cleared\");\n-    assert(_fields_annotations      == NULL, \"Should have been cleared\");\n-    assert(_fields_type_annotations == NULL, \"Should have been cleared\");\n+    assert(_class_annotations       == nullptr, \"Should have been cleared\");\n+    assert(_class_type_annotations  == nullptr, \"Should have been cleared\");\n+    assert(_fields_annotations      == nullptr, \"Should have been cleared\");\n+    assert(_fields_type_annotations == nullptr, \"Should have been cleared\");\n@@ -6140,2 +6136,2 @@\n-  _transitive_interfaces = NULL;\n-  _local_interfaces = NULL;\n+  _transitive_interfaces = nullptr;\n+  _local_interfaces = nullptr;\n@@ -6146,1 +6142,1 @@\n-  if (_klass_to_deallocate != NULL) {\n+  if (_klass_to_deallocate != nullptr) {\n@@ -6154,2 +6150,2 @@\n-  assert(stream != NULL, \"invariant\");\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -6224,1 +6220,1 @@\n-  assert(class_name_in_cp != NULL, \"class_name can't be null\");\n+  assert(class_name_in_cp != nullptr, \"class_name can't be null\");\n@@ -6228,1 +6224,1 @@\n-  verify_legal_class_modifiers(flags, NULL, is_java_lang_Object, CHECK);\n+  verify_legal_class_modifiers(flags, nullptr, is_java_lang_Object, CHECK);\n@@ -6277,1 +6273,1 @@\n-    assert(_class_name != NULL, \"Unexpected null _class_name\");\n+    assert(_class_name != nullptr, \"Unexpected null _class_name\");\n@@ -6315,1 +6311,1 @@\n-      if (stream->source() != NULL) {\n+      if (stream->source() != nullptr) {\n@@ -6348,1 +6344,1 @@\n-  assert(_fields != NULL, \"invariant\");\n+  assert(_fields != nullptr, \"invariant\");\n@@ -6360,1 +6356,1 @@\n-  assert(_methods != NULL, \"invariant\");\n+  assert(_methods != nullptr, \"invariant\");\n@@ -6370,1 +6366,1 @@\n-  assert(_inner_classes != NULL, \"invariant\");\n+  assert(_inner_classes != nullptr, \"invariant\");\n@@ -6410,1 +6406,1 @@\n-  assert(_class_name != NULL, \"Unexpected null _class_name\");\n+  assert(_class_name != nullptr, \"Unexpected null _class_name\");\n@@ -6427,1 +6423,1 @@\n-  assert(stream != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n@@ -6429,2 +6425,2 @@\n-  assert(cp != NULL, \"invariant\");\n-  assert(_loader_data != NULL, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(_loader_data != nullptr, \"invariant\");\n@@ -6438,1 +6434,1 @@\n-  if (_super_class_index > 0 && NULL == _super_klass) {\n+  if (_super_class_index > 0 && nullptr == _super_klass) {\n@@ -6461,1 +6457,1 @@\n-  if (_super_klass != NULL) {\n+  if (_super_klass != nullptr) {\n@@ -6487,3 +6483,3 @@\n-  int itfs_len = _local_interface_indexes == NULL ? 0 : _local_interface_indexes->length();\n-  _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, NULL, CHECK);\n-  if (_local_interface_indexes != NULL) {\n+  int itfs_len = _local_interface_indexes == nullptr ? 0 : _local_interface_indexes->length();\n+  _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n+  if (_local_interface_indexes != nullptr) {\n@@ -6535,1 +6531,1 @@\n-  assert(_local_interfaces != NULL, \"invariant\");\n+  assert(_local_interfaces != nullptr, \"invariant\");\n@@ -6544,1 +6540,1 @@\n-  assert(_transitive_interfaces != NULL, \"invariant\");\n+  assert(_transitive_interfaces != nullptr, \"invariant\");\n@@ -6567,2 +6563,2 @@\n-  assert(_fac != NULL, \"invariant\");\n-  assert(_parsed_annotations != NULL, \"invariant\");\n+  assert(_fac != nullptr, \"invariant\");\n+  assert(_parsed_annotations != nullptr, \"invariant\");\n@@ -6574,1 +6570,1 @@\n-                                                   NULL,\n+                                                   nullptr,\n@@ -6582,1 +6578,1 @@\n-        assert(klass != NULL, \"Sanity check\");\n+        assert(klass != nullptr, \"Sanity check\");\n@@ -6612,2 +6608,2 @@\n-  if (klass != NULL) {\n-    assert(NULL == _klass, \"leaking?\");\n+  if (klass != nullptr) {\n+    assert(nullptr == _klass, \"leaking?\");\n@@ -6623,2 +6619,2 @@\n-  if (klass != NULL) {\n-    assert(NULL == _klass_to_deallocate, \"leaking?\");\n+  if (klass != nullptr) {\n+    assert(nullptr == _klass_to_deallocate, \"leaking?\");\n@@ -6634,1 +6630,1 @@\n-  assert(_stream != NULL, \"invariant\");\n+  assert(_stream != nullptr, \"invariant\");\n@@ -6640,1 +6636,1 @@\n-  return _super_klass == NULL ? REF_NONE : _super_klass->reference_type();\n+  return _super_klass == nullptr ? REF_NONE : _super_klass->reference_type();\n@@ -6653,1 +6649,1 @@\n-  if (_super_klass == NULL) {\n+  if (_super_klass == nullptr) {\n@@ -6672,1 +6668,1 @@\n-  if (class_name != NULL) {\n+  if (class_name != nullptr) {\n@@ -6675,1 +6671,1 @@\n-    return strchr(name, JVM_SIGNATURE_DOT) == NULL;\n+    return strchr(name, JVM_SIGNATURE_DOT) == nullptr;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":377,"deletions":381,"binary":false,"changes":758,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-  \/\/ in which case these pointers have been set to NULL.\n+  \/\/ in which case these pointers have been set to null.\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-static canonicalize_fn_t CanonicalizeEntry  = NULL;\n+static canonicalize_fn_t CanonicalizeEntry  = nullptr;\n@@ -95,5 +95,5 @@\n-static ZipOpen_t         ZipOpen            = NULL;\n-static ZipClose_t        ZipClose           = NULL;\n-static FindEntry_t       FindEntry          = NULL;\n-static ReadEntry_t       ReadEntry          = NULL;\n-static Crc32_t           Crc32              = NULL;\n+static ZipOpen_t         ZipOpen            = nullptr;\n+static ZipClose_t        ZipClose           = nullptr;\n+static FindEntry_t       FindEntry          = nullptr;\n+static ReadEntry_t       ReadEntry          = nullptr;\n+static Crc32_t           Crc32              = nullptr;\n@@ -101,1 +101,1 @@\n-void*  ClassLoader::_zip_handle             = NULL;\n+void*  ClassLoader::_zip_handle             = nullptr;\n@@ -105,4 +105,4 @@\n-static JImageOpen_t                    JImageOpen             = NULL;\n-static JImageClose_t                   JImageClose            = NULL;\n-static JImageFindResource_t            JImageFindResource     = NULL;\n-static JImageGetResource_t             JImageGetResource      = NULL;\n+static JImageOpen_t                    JImageOpen             = nullptr;\n+static JImageClose_t                   JImageClose            = nullptr;\n+static JImageFindResource_t            JImageFindResource     = nullptr;\n+static JImageGetResource_t             JImageGetResource      = nullptr;\n@@ -111,1 +111,1 @@\n-static JImageFile*                     JImage_file            = NULL;\n+static JImageFile*                     JImage_file            = nullptr;\n@@ -115,29 +115,29 @@\n-PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;\n-PerfCounter*    ClassLoader::_perf_classes_inited = NULL;\n-PerfCounter*    ClassLoader::_perf_class_init_time = NULL;\n-PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_classes_verified = NULL;\n-PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;\n-PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_classes_linked = NULL;\n-PerfCounter*    ClassLoader::_perf_class_link_time = NULL;\n-PerfCounter*    ClassLoader::_perf_class_link_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = NULL;\n-PerfCounter*    ClassLoader::_perf_shared_classload_time = NULL;\n-PerfCounter*    ClassLoader::_perf_sys_classload_time = NULL;\n-PerfCounter*    ClassLoader::_perf_app_classload_time = NULL;\n-PerfCounter*    ClassLoader::_perf_app_classload_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_app_classload_count = NULL;\n-PerfCounter*    ClassLoader::_perf_define_appclasses = NULL;\n-PerfCounter*    ClassLoader::_perf_define_appclass_time = NULL;\n-PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;\n-PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;\n-PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;\n-\n-GrowableArray<ModuleClassPathList*>* ClassLoader::_patch_mod_entries = NULL;\n-GrowableArray<ModuleClassPathList*>* ClassLoader::_exploded_entries = NULL;\n-ClassPathEntry* ClassLoader::_jrt_entry = NULL;\n-\n-ClassPathEntry* volatile ClassLoader::_first_append_entry_list = NULL;\n-ClassPathEntry* volatile ClassLoader::_last_append_entry  = NULL;\n+PerfCounter*    ClassLoader::_perf_accumulated_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_classes_inited = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_init_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_init_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_classes_verified = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_verify_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_verify_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_classes_linked = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_link_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_link_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_shared_classload_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_sys_classload_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_app_classload_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_app_classload_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_app_classload_count = nullptr;\n+PerfCounter*    ClassLoader::_perf_define_appclasses = nullptr;\n+PerfCounter*    ClassLoader::_perf_define_appclass_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_define_appclass_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = nullptr;\n+PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = nullptr;\n+PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = nullptr;\n+\n+GrowableArray<ModuleClassPathList*>* ClassLoader::_patch_mod_entries = nullptr;\n+GrowableArray<ModuleClassPathList*>* ClassLoader::_exploded_entries = nullptr;\n+ClassPathEntry* ClassLoader::_jrt_entry = nullptr;\n+\n+ClassPathEntry* volatile ClassLoader::_first_append_entry_list = nullptr;\n+ClassPathEntry* volatile ClassLoader::_last_append_entry  = nullptr;\n@@ -145,4 +145,4 @@\n-ClassPathEntry* ClassLoader::_app_classpath_entries = NULL;\n-ClassPathEntry* ClassLoader::_last_app_classpath_entry = NULL;\n-ClassPathEntry* ClassLoader::_module_path_entries = NULL;\n-ClassPathEntry* ClassLoader::_last_module_path_entry = NULL;\n+ClassPathEntry* ClassLoader::_app_classpath_entries = nullptr;\n+ClassPathEntry* ClassLoader::_last_app_classpath_entry = nullptr;\n+ClassPathEntry* ClassLoader::_module_path_entries = nullptr;\n+ClassPathEntry* ClassLoader::_last_module_path_entry = nullptr;\n@@ -181,2 +181,2 @@\n-  if (name == NULL) {\n-    if (bad_class_name != NULL) {\n+  if (name == nullptr) {\n+    if (bad_class_name != nullptr) {\n@@ -185,1 +185,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -192,2 +192,2 @@\n-  if (end == NULL) {\n-    return NULL;\n+  if (end == nullptr) {\n+    return nullptr;\n@@ -206,1 +206,1 @@\n-      if (bad_class_name != NULL) {\n+      if (bad_class_name != nullptr) {\n@@ -209,1 +209,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -216,1 +216,1 @@\n-    if (bad_class_name != NULL) {\n+    if (bad_class_name != nullptr) {\n@@ -219,1 +219,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -227,2 +227,2 @@\n-  if (pkg_name == NULL) {\n-    return NULL;\n+  if (pkg_name == nullptr) {\n+    return nullptr;\n@@ -246,1 +246,1 @@\n-  assert((_dir != NULL) && (name != NULL), \"sanity\");\n+  assert((_dir != nullptr) && (name != nullptr), \"sanity\");\n@@ -281,1 +281,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -302,1 +302,1 @@\n-  if (entry == NULL) return NULL;\n+  if (entry == nullptr) return nullptr;\n@@ -316,1 +316,1 @@\n-      return NULL; \/\/ 32-bit integer overflow will occur.\n+      return nullptr; \/\/ 32-bit integer overflow will occur.\n@@ -321,1 +321,1 @@\n-  if (!(*ReadEntry)(_zip, entry, buffer, filename)) return NULL;\n+  if (!(*ReadEntry)(_zip, entry, buffer, filename)) return nullptr;\n@@ -333,2 +333,2 @@\n-  if (buffer == NULL) {\n-    return NULL;\n+  if (buffer == nullptr) {\n+    return nullptr;\n@@ -346,1 +346,1 @@\n-DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = NULL;)\n+DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = nullptr;)\n@@ -354,1 +354,1 @@\n-  assert(jimage() != NULL, \"should have been opened by ClassLoader::lookup_vm_options \"\n+  assert(jimage() != nullptr, \"should have been opened by ClassLoader::lookup_vm_options \"\n@@ -360,1 +360,1 @@\n-  if (jimage() != NULL) {\n+  if (jimage() != nullptr) {\n@@ -362,1 +362,1 @@\n-    JImage_file = NULL;\n+    JImage_file = nullptr;\n@@ -368,3 +368,3 @@\n-  guarantee(jimage != NULL, \"jimage file is null\");\n-  guarantee(name != NULL, \"jimage file name is null\");\n-  assert(_singleton == NULL, \"VM supports only one jimage\");\n+  guarantee(jimage != nullptr, \"jimage file is null\");\n+  guarantee(name != nullptr, \"jimage file name is null\");\n+  assert(_singleton == nullptr, \"VM supports only one jimage\");\n@@ -395,1 +395,1 @@\n-    if (pkg_name != NULL) {\n+    if (pkg_name != nullptr) {\n@@ -400,1 +400,1 @@\n-        if (package_entry != NULL) {\n+        if (package_entry != nullptr) {\n@@ -404,1 +404,1 @@\n-          assert(module != NULL, \"Boot classLoader package missing module\");\n+          assert(module != nullptr, \"Boot classLoader package missing module\");\n@@ -407,1 +407,1 @@\n-          if (module_name != NULL) {\n+          if (module_name != nullptr) {\n@@ -429,1 +429,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -455,2 +455,2 @@\n-  _module_first_entry = NULL;\n-  _module_last_entry = NULL;\n+  _module_first_entry = nullptr;\n+  _module_last_entry = nullptr;\n@@ -462,1 +462,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -470,2 +470,2 @@\n-  if (new_entry != NULL) {\n-    if (_module_last_entry == NULL) {\n+  if (new_entry != nullptr) {\n+    if (_module_last_entry == nullptr) {\n@@ -505,1 +505,1 @@\n-  assert(bootcp != NULL, \"Boot class path must not be NULL\");\n+  assert(bootcp != nullptr, \"Boot class path must not be nullptr\");\n@@ -530,1 +530,1 @@\n-  assert(entry != NULL, \"ClassPathEntry should not be NULL\");\n+  assert(entry != nullptr, \"ClassPathEntry should not be nullptr\");\n@@ -534,2 +534,2 @@\n-  if (_module_path_entries == NULL) {\n-    assert(_last_module_path_entry == NULL, \"Sanity\");\n+  if (_module_path_entries == nullptr) {\n+    assert(_last_module_path_entry == nullptr, \"Sanity\");\n@@ -553,1 +553,1 @@\n-  ClassPathEntry* new_entry = NULL;\n+  ClassPathEntry* new_entry = nullptr;\n@@ -556,1 +556,1 @@\n-  if (new_entry != NULL) {\n+  if (new_entry != nullptr) {\n@@ -583,1 +583,1 @@\n-    assert(module_sym != NULL, \"Failed to obtain Symbol for module name\");\n+    assert(module_sym != nullptr, \"Failed to obtain Symbol for module name\");\n@@ -597,1 +597,1 @@\n-        if (new_entry != NULL) {\n+        if (new_entry != nullptr) {\n@@ -605,1 +605,1 @@\n-    if (module_cpl->module_first_entry() != NULL) {\n+    if (module_cpl->module_first_entry() != nullptr) {\n@@ -614,1 +614,1 @@\n-  if (_patch_mod_entries != NULL && _patch_mod_entries->is_nonempty()) {\n+  if (_patch_mod_entries != nullptr && _patch_mod_entries->is_nonempty()) {\n@@ -635,1 +635,1 @@\n-      vm_exit_during_initialization(\"CDS is not supported in exploded JDK build\", NULL);\n+      vm_exit_during_initialization(\"CDS is not supported in exploded JDK build\", nullptr);\n@@ -652,1 +652,1 @@\n-        if (JImage_file != NULL) {\n+        if (JImage_file != nullptr) {\n@@ -655,1 +655,1 @@\n-          assert(canonical_path != NULL, \"canonical_path issue\");\n+          assert(canonical_path != nullptr, \"canonical_path issue\");\n@@ -658,2 +658,2 @@\n-          assert(_jrt_entry != NULL && _jrt_entry->is_modules_image(), \"No java runtime image present\");\n-          assert(_jrt_entry->jimage() != NULL, \"No java runtime image\");\n+          assert(_jrt_entry != nullptr && _jrt_entry->is_modules_image(), \"No java runtime image present\");\n+          assert(_jrt_entry->jimage() != nullptr, \"No java runtime image\");\n@@ -690,1 +690,1 @@\n-  assert(_exploded_entries != NULL, \"_exploded_entries was not initialized\");\n+  assert(_exploded_entries != nullptr, \"_exploded_entries was not initialized\");\n@@ -706,1 +706,1 @@\n-    if (new_entry != NULL) {\n+    if (new_entry != nullptr) {\n@@ -730,1 +730,1 @@\n-  ClassPathEntry* new_entry = NULL;\n+  ClassPathEntry* new_entry = nullptr;\n@@ -736,2 +736,2 @@\n-    if (canonical_path == NULL) {\n-      return NULL;\n+    if (canonical_path == nullptr) {\n+      return nullptr;\n@@ -739,1 +739,1 @@\n-    char* error_msg = NULL;\n+    char* error_msg = nullptr;\n@@ -741,1 +741,1 @@\n-    if (zip != NULL && error_msg == NULL) {\n+    if (zip != nullptr && error_msg == nullptr) {\n@@ -747,1 +747,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -760,1 +760,1 @@\n-\/\/ Create a class path zip entry for a given path (return NULL if not found\n+\/\/ Create a class path zip entry for a given path (return null if not found\n@@ -770,2 +770,2 @@\n-      if (canonical_path != NULL) {\n-        char* error_msg = NULL;\n+      if (canonical_path != nullptr) {\n+        char* error_msg = nullptr;\n@@ -773,1 +773,1 @@\n-        if (zip != NULL && error_msg == NULL) {\n+        if (zip != nullptr && error_msg == nullptr) {\n@@ -780,1 +780,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -785,1 +785,1 @@\n-  if (new_entry != NULL) {\n+  if (new_entry != nullptr) {\n@@ -787,1 +787,1 @@\n-    if (_last_append_entry == NULL) {\n+    if (_last_append_entry == nullptr) {\n@@ -789,1 +789,1 @@\n-      assert(first_append_entry() == NULL, \"boot loader's append class path entry list not empty\");\n+      assert(first_append_entry() == nullptr, \"boot loader's append class path entry list not empty\");\n@@ -809,1 +809,1 @@\n-  assert(entry != NULL, \"ClassPathEntry should not be NULL\");\n+  assert(entry != nullptr, \"ClassPathEntry should not be nullptr\");\n@@ -812,1 +812,1 @@\n-    while (e != NULL) {\n+    while (e != nullptr) {\n@@ -822,2 +822,2 @@\n-  if (_app_classpath_entries == NULL) {\n-    assert(_last_app_classpath_entry == NULL, \"Sanity\");\n+  if (_app_classpath_entries == nullptr) {\n+    assert(_last_app_classpath_entry == nullptr, \"Sanity\");\n@@ -845,1 +845,1 @@\n-    ClassPathEntry* new_entry = NULL;\n+    ClassPathEntry* new_entry = nullptr;\n@@ -847,1 +847,1 @@\n-    if (new_entry == NULL) {\n+    if (new_entry == nullptr) {\n@@ -872,1 +872,1 @@\n-    while (e != NULL) {\n+    while (e != nullptr) {\n@@ -875,1 +875,1 @@\n-      if (e != NULL) {\n+      if (e != nullptr) {\n@@ -888,1 +888,1 @@\n-  if (_patch_mod_entries != NULL) {\n+  if (_patch_mod_entries != nullptr) {\n@@ -898,1 +898,1 @@\n-    if (_exploded_entries != NULL) {\n+    if (_exploded_entries != nullptr) {\n@@ -905,1 +905,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -914,1 +914,1 @@\n-  if (func == NULL) {\n+  if (func == nullptr) {\n@@ -923,1 +923,1 @@\n-  assert(CanonicalizeEntry == NULL, \"should not load java library twice\");\n+  assert(CanonicalizeEntry == nullptr, \"should not load java library twice\");\n@@ -925,2 +925,2 @@\n-  if (javalib_handle == NULL) {\n-    vm_exit_during_initialization(\"Unable to load java library\", NULL);\n+  if (javalib_handle == nullptr) {\n+    vm_exit_during_initialization(\"Unable to load java library\", nullptr);\n@@ -929,1 +929,1 @@\n-  CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, \"JDK_Canonicalize\", NULL));\n+  CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, \"JDK_Canonicalize\", nullptr));\n@@ -941,1 +941,1 @@\n-  assert(ZipOpen == NULL, \"should not load zip library twice\");\n+  assert(ZipOpen == nullptr, \"should not load zip library twice\");\n@@ -947,1 +947,1 @@\n-  if (_zip_handle == NULL) {\n+  if (_zip_handle == nullptr) {\n@@ -959,1 +959,1 @@\n-  assert(JImageOpen == NULL, \"should not load jimage library twice\");\n+  assert(JImageOpen == nullptr, \"should not load jimage library twice\");\n@@ -962,1 +962,1 @@\n-  void* handle = NULL;\n+  void* handle = nullptr;\n@@ -966,1 +966,1 @@\n-  if (handle == NULL) {\n+  if (handle == nullptr) {\n@@ -983,1 +983,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -989,1 +989,1 @@\n-    \/\/ Return NULL if package does not exist or if no classes in that package\n+    \/\/ Return null if package does not exist or if no classes in that package\n@@ -991,1 +991,1 @@\n-    if (package != NULL && package->has_loaded_class()) {\n+    if (package != nullptr && package->has_loaded_class()) {\n@@ -993,1 +993,1 @@\n-      if (module->location() != NULL) {\n+      if (module->location() != nullptr) {\n@@ -1005,1 +1005,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1030,1 +1030,1 @@\n-  assert(class_name != NULL, \"invariant\");\n+  assert(class_name != nullptr, \"invariant\");\n@@ -1038,1 +1038,1 @@\n-                                             class_suffix_len); \/\/ includes term NULL\n+                                             class_suffix_len); \/\/ includes term null\n@@ -1061,1 +1061,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1070,1 +1070,1 @@\n-  ClassFileStream* stream = NULL;\n+  ClassFileStream* stream = nullptr;\n@@ -1076,1 +1076,1 @@\n-  ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry->module() : NULL;\n+  ModuleEntry* mod_entry = (pkg_entry != nullptr) ? pkg_entry->module() : nullptr;\n@@ -1085,1 +1085,1 @@\n-      mod_entry == NULL) {\n+      mod_entry == nullptr) {\n@@ -1090,2 +1090,2 @@\n-  ClassPathEntry* e = NULL;\n-  if (mod_entry != NULL && mod_entry->is_named()) {\n+  ClassPathEntry* e = nullptr;\n+  if (mod_entry != nullptr && mod_entry->is_named()) {\n@@ -1104,1 +1104,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -1108,1 +1108,1 @@\n-    if (NULL != stream) {\n+    if (nullptr != stream) {\n@@ -1116,1 +1116,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1121,1 +1121,1 @@\n-  assert(name != NULL, \"invariant\");\n+  assert(name != nullptr, \"invariant\");\n@@ -1132,1 +1132,1 @@\n-  assert(file_name != NULL, \"invariant\");\n+  assert(file_name != nullptr, \"invariant\");\n@@ -1135,1 +1135,1 @@\n-  ClassFileStream* stream = NULL;\n+  ClassFileStream* stream = nullptr;\n@@ -1137,1 +1137,1 @@\n-  ClassPathEntry* e = NULL;\n+  ClassPathEntry* e = nullptr;\n@@ -1156,1 +1156,1 @@\n-  if (_patch_mod_entries != NULL && !search_append_only) {\n+  if (_patch_mod_entries != nullptr && !search_append_only) {\n@@ -1172,1 +1172,1 @@\n-  if (!search_append_only && (NULL == stream)) {\n+  if (!search_append_only && (nullptr == stream)) {\n@@ -1178,1 +1178,1 @@\n-      assert(_exploded_entries != NULL, \"No exploded build entries present\");\n+      assert(_exploded_entries != nullptr, \"No exploded build entries present\");\n@@ -1184,1 +1184,1 @@\n-  if (search_append_only && (NULL == stream)) {\n+  if (search_append_only && (nullptr == stream)) {\n@@ -1192,1 +1192,1 @@\n-    while (e != NULL) {\n+    while (e != nullptr) {\n@@ -1194,1 +1194,1 @@\n-      if (NULL != stream) {\n+      if (nullptr != stream) {\n@@ -1202,2 +1202,2 @@\n-  if (NULL == stream) {\n-    return NULL;\n+  if (nullptr == stream) {\n+    return nullptr;\n@@ -1246,1 +1246,1 @@\n-  assert(stream != NULL, \"sanity\");\n+  assert(stream != nullptr, \"sanity\");\n@@ -1255,2 +1255,2 @@\n-  if (src == NULL) {\n-    if (loader == NULL) {\n+  if (src == nullptr) {\n+    if (loader == nullptr) {\n@@ -1275,1 +1275,1 @@\n-    assert(path != NULL, \"sanity\");\n+    assert(path != nullptr, \"sanity\");\n@@ -1280,1 +1280,1 @@\n-      assert(ent->name() != NULL, \"sanity\");\n+      assert(ent->name() != nullptr, \"sanity\");\n@@ -1287,1 +1287,1 @@\n-        \/\/ NULL pkg_entry and pkg_entry in an unnamed module implies the class\n+        \/\/ null pkg_entry and pkg_entry in an unnamed module implies the class\n@@ -1290,1 +1290,1 @@\n-        if ((pkg_entry == NULL) || (pkg_entry->in_unnamed_module())) {\n+        if ((pkg_entry == nullptr) || (pkg_entry->in_unnamed_module())) {\n@@ -1303,1 +1303,1 @@\n-              assert(loader == NULL, \"sanity\");\n+              assert(loader == nullptr, \"sanity\");\n@@ -1311,1 +1311,1 @@\n-          if ((pkg_entry != NULL) && !(pkg_entry->in_unnamed_module()) && (i > 0)) {\n+          if ((pkg_entry != nullptr) && !(pkg_entry->in_unnamed_module()) && (i > 0)) {\n@@ -1348,1 +1348,1 @@\n-  assert(file_name != NULL, \"invariant\");\n+  assert(file_name != nullptr, \"invariant\");\n@@ -1398,1 +1398,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1416,2 +1416,2 @@\n-  if (JImage_file == NULL) {\n-    return NULL;\n+  if (JImage_file == nullptr) {\n+    return nullptr;\n@@ -1426,2 +1426,2 @@\n-  assert(JImageOpen != NULL, \"jimage library should have been opened\");\n-  if (JImage_file == NULL) {\n+  assert(JImageOpen != nullptr, \"jimage library should have been opened\");\n+  if (JImage_file == nullptr) {\n@@ -1459,1 +1459,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -1517,1 +1517,1 @@\n-  if (Arguments::get_patch_mod_prefix() != NULL) {\n+  if (Arguments::get_patch_mod_prefix() != nullptr) {\n@@ -1535,1 +1535,1 @@\n-    assert(_exploded_entries == NULL, \"Should only get initialized once\");\n+    assert(_exploded_entries == nullptr, \"Should only get initialized once\");\n@@ -1543,1 +1543,1 @@\n-  assert(orig != NULL, \"bad arguments\");\n+  assert(orig != nullptr, \"bad arguments\");\n@@ -1551,1 +1551,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1565,1 +1565,1 @@\n-  if (null_cld_modules == NULL) {\n+  if (null_cld_modules == nullptr) {\n@@ -1571,1 +1571,1 @@\n-    if (ModuleEntryTable::javabase_moduleEntry() == NULL) {  \/\/ may have been inited by CDS.\n+    if (ModuleEntryTable::javabase_moduleEntry() == nullptr) {  \/\/ may have been inited by CDS.\n@@ -1573,2 +1573,2 @@\n-                               false, vmSymbols::java_base(), NULL, NULL, null_cld);\n-      if (jb_module == NULL) {\n+                               false, vmSymbols::java_base(), nullptr, nullptr, null_cld);\n+      if (jb_module == nullptr) {\n@@ -1587,1 +1587,1 @@\n-  if (_eventp != NULL) {\n+  if (_eventp != nullptr) {\n@@ -1602,1 +1602,1 @@\n-  if (_recursion_counters == NULL || (_recursion_counters[_event_type])++ == 0) {\n+  if (_recursion_counters == nullptr || (_recursion_counters[_event_type])++ == 0) {\n@@ -1625,1 +1625,1 @@\n-  if (_recursion_counters != NULL && --(_recursion_counters[_event_type]) > 0) return;\n+  if (_recursion_counters != nullptr && --(_recursion_counters[_event_type]) > 0) return;\n@@ -1630,1 +1630,1 @@\n-  if (_selftimep != NULL) {\n+  if (_selftimep != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":189,"deletions":189,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-\/\/ The bootstrap loader (represented by NULL) also has a ClassLoaderData,\n+\/\/ The bootstrap loader (represented by null) also has a ClassLoaderData,\n@@ -84,1 +84,1 @@\n-ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;\n+ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = nullptr;\n@@ -87,2 +87,2 @@\n-  assert(_the_null_class_loader_data == NULL, \"cannot initialize twice\");\n-  assert(ClassLoaderDataGraph::_head == NULL, \"cannot initialize twice\");\n+  assert(_the_null_class_loader_data == nullptr, \"cannot initialize twice\");\n+  assert(ClassLoaderDataGraph::_head == nullptr, \"cannot initialize twice\");\n@@ -114,1 +114,1 @@\n-  if (cl_name != NULL) {\n+  if (cl_name != nullptr) {\n@@ -117,1 +117,1 @@\n-    if (cl_instance_name != NULL && cl_instance_name[0] != '\\0') {\n+    if (cl_instance_name != nullptr && cl_instance_name[0] != '\\0') {\n@@ -131,1 +131,1 @@\n-                  (cl_name_and_id == NULL) ? _class_loader_klass->external_name() :\n+                  (cl_name_and_id == nullptr) ? _class_loader_klass->external_name() :\n@@ -133,1 +133,1 @@\n-  assert(cl_instance_name_and_id != NULL && cl_instance_name_and_id[0] != '\\0', \"class loader has no name and id\");\n+  assert(cl_instance_name_and_id != nullptr && cl_instance_name_and_id[0] != '\\0', \"class loader has no name and id\");\n@@ -138,1 +138,1 @@\n-  _metaspace(NULL),\n+  _metaspace(nullptr),\n@@ -148,5 +148,5 @@\n-  _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),\n-  _jmethod_ids(NULL),\n-  _deallocate_list(NULL),\n-  _next(NULL),\n-  _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {\n+  _klasses(nullptr), _packages(nullptr), _modules(nullptr), _unnamed_module(nullptr), _dictionary(nullptr),\n+  _jmethod_ids(nullptr),\n+  _deallocate_list(nullptr),\n+  _next(nullptr),\n+  _class_loader_klass(nullptr), _name(nullptr), _name_and_id(nullptr) {\n@@ -185,1 +185,1 @@\n-  while (c != NULL) {\n+  while (c != nullptr) {\n@@ -193,1 +193,1 @@\n-  if (_head == NULL || _head->_size == Chunk::CAPACITY) {\n+  if (_head == nullptr || _head->_size == Chunk::CAPACITY) {\n@@ -206,1 +206,1 @@\n-  while (chunk != NULL) {\n+  while (chunk != nullptr) {\n@@ -215,3 +215,1 @@\n-    if (c->_data[i] != NULL) {\n-      f->do_oop(&c->_data[i]);\n-    }\n+    f->do_oop(&c->_data[i]);\n@@ -223,1 +221,1 @@\n-  if (head != NULL) {\n+  if (head != nullptr) {\n@@ -226,1 +224,1 @@\n-    for (Chunk* c = head->_next; c != NULL; c = c->_next) {\n+    for (Chunk* c = head->_next; c != nullptr; c = c->_next) {\n@@ -240,1 +238,1 @@\n-    if (p != NULL && NativeAccess<AS_NO_KEEPALIVE>::oop_load(p) == _target) {\n+    if (p != nullptr && NativeAccess<AS_NO_KEEPALIVE>::oop_load(p) == _target) {\n@@ -264,1 +262,1 @@\n-  while (chunk != NULL) {\n+  while (chunk != nullptr) {\n@@ -340,1 +338,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -348,1 +346,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -356,1 +354,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -368,1 +366,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -387,1 +385,1 @@\n-    assert(m != NULL, \"NULL mirror\");\n+    assert(m != nullptr, \"nullptr mirror\");\n@@ -396,1 +394,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -416,1 +414,1 @@\n-  if (_unnamed_module != NULL) {\n+  if (_unnamed_module != nullptr) {\n@@ -419,1 +417,1 @@\n-  if (_modules != NULL) {\n+  if (_modules != nullptr) {\n@@ -426,1 +424,1 @@\n-  if (_packages != NULL) {\n+  if (_packages != nullptr) {\n@@ -432,1 +430,1 @@\n-  assert(k != NULL, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n@@ -514,1 +512,1 @@\n-  if (loader_or_mirror() != NULL) {\n+  if (loader_or_mirror() != nullptr) {\n@@ -528,2 +526,2 @@\n-  Klass* prev = NULL;\n-  for (Klass* k = _klasses; k != NULL; k = k->next_link()) {\n+  Klass* prev = nullptr;\n+  for (Klass* k = _klasses; k != nullptr; k = k->next_link()) {\n@@ -531,1 +529,1 @@\n-      if (prev == NULL) {\n+      if (prev == nullptr) {\n@@ -575,1 +573,1 @@\n-  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to NULL without\n+  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to null without\n@@ -583,1 +581,1 @@\n-  \/\/ being NULL after class unloading. Hence, it is unsafe to free the memory\n+  \/\/ being null after class unloading. Hence, it is unsafe to free the memory\n@@ -586,1 +584,1 @@\n-  if (_jmethod_ids != NULL) {\n+  if (_jmethod_ids != nullptr) {\n@@ -598,1 +596,1 @@\n-  if (modules == NULL) {\n+  if (modules == nullptr) {\n@@ -601,1 +599,1 @@\n-    if ((modules = _modules) == NULL) {\n+    if ((modules = _modules) == nullptr) {\n@@ -620,1 +618,1 @@\n-  if (_the_null_class_loader_data == NULL) {\n+  if (_the_null_class_loader_data == nullptr) {\n@@ -640,1 +638,1 @@\n-  if (!_holder.is_null()) {  \/\/ NULL class_loader\n+  if (!_holder.is_null()) {  \/\/ null class_loader\n@@ -643,1 +641,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -649,1 +647,1 @@\n-  if (!_holder.is_null()) {  \/\/ NULL class_loader\n+  if (!_holder.is_null()) {  \/\/ null class_loader\n@@ -652,1 +650,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -659,1 +657,1 @@\n-      || (_holder.peek() != NULL);  \/\/ and not cleaned by the GC weak handle processing.\n+      || (_holder.peek() != nullptr);  \/\/ and not cleaned by the GC weak handle processing.\n@@ -697,1 +695,1 @@\n-  if (_packages != NULL) {\n+  if (_packages != nullptr) {\n@@ -700,1 +698,1 @@\n-    _packages = NULL;\n+    _packages = nullptr;\n@@ -704,1 +702,1 @@\n-  if (_modules != NULL) {\n+  if (_modules != nullptr) {\n@@ -707,1 +705,1 @@\n-    _modules = NULL;\n+    _modules = nullptr;\n@@ -711,1 +709,1 @@\n-  if (_dictionary != NULL) {\n+  if (_dictionary != nullptr) {\n@@ -714,1 +712,1 @@\n-    _dictionary = NULL;\n+    _dictionary = nullptr;\n@@ -717,1 +715,1 @@\n-  if (_unnamed_module != NULL) {\n+  if (_unnamed_module != nullptr) {\n@@ -719,1 +717,1 @@\n-    _unnamed_module = NULL;\n+    _unnamed_module = nullptr;\n@@ -724,2 +722,2 @@\n-  if (m != NULL) {\n-    _metaspace = NULL;\n+  if (m != nullptr) {\n+    _metaspace = nullptr;\n@@ -733,1 +731,1 @@\n-  if (_deallocate_list != NULL) {\n+  if (_deallocate_list != nullptr) {\n@@ -738,1 +736,1 @@\n-  if (_name != NULL) {\n+  if (_name != nullptr) {\n@@ -741,1 +739,1 @@\n-  if (_name_and_id != NULL) {\n+  if (_name_and_id != nullptr) {\n@@ -784,1 +782,1 @@\n-  if (metaspace == NULL) {\n+  if (metaspace == nullptr) {\n@@ -787,1 +785,1 @@\n-    if ((metaspace = _metaspace) == NULL) {\n+    if ((metaspace = _metaspace) == nullptr) {\n@@ -789,1 +787,1 @@\n-        assert (class_loader() == NULL, \"Must be\");\n+        assert (class_loader() == nullptr, \"Must be\");\n@@ -814,1 +812,1 @@\n-  if (ptr != NULL) {\n+  if (ptr != nullptr) {\n@@ -816,1 +814,1 @@\n-    NativeAccess<>::oop_store(ptr, oop(NULL));\n+    NativeAccess<>::oop_store(ptr, oop(nullptr));\n@@ -822,1 +820,1 @@\n-  if (dest.resolve() != NULL) {\n+  if (dest.resolve() != nullptr) {\n@@ -836,1 +834,1 @@\n-    if (_deallocate_list == NULL) {\n+    if (_deallocate_list == nullptr) {\n@@ -852,1 +850,1 @@\n-  if (_deallocate_list == NULL) {\n+  if (_deallocate_list == nullptr) {\n@@ -895,1 +893,1 @@\n-  if (_deallocate_list == NULL) {\n+  if (_deallocate_list == nullptr) {\n@@ -921,1 +919,1 @@\n-   if (_class_loader_klass == NULL) {\n+   if (_class_loader_klass == nullptr) {\n@@ -923,1 +921,1 @@\n-   } else if (_name != NULL) {\n+   } else if (_name != nullptr) {\n@@ -936,1 +934,1 @@\n-  if (_class_loader_klass == NULL) {\n+  if (_class_loader_klass == nullptr) {\n@@ -938,1 +936,1 @@\n-  } else if (_name_and_id != NULL) {\n+  } else if (_name_and_id != nullptr) {\n@@ -947,1 +945,1 @@\n-  if (!is_unloading() && class_loader() != NULL) {\n+  if (!is_unloading() && class_loader() != nullptr) {\n@@ -1019,1 +1017,1 @@\n-  if (_jmethod_ids != NULL) {\n+  if (_jmethod_ids != nullptr) {\n@@ -1053,1 +1051,1 @@\n-  guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), \"must be\");\n+  guarantee(cl != nullptr || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), \"must be\");\n@@ -1057,1 +1055,1 @@\n-  if (metaspace_or_null() != NULL) {\n+  if (metaspace_or_null() != nullptr) {\n@@ -1062,1 +1060,1 @@\n-  for (Klass* k = _klasses; k != NULL; k = k->next_link()) {\n+  for (Klass* k = _klasses; k != nullptr; k = k->next_link()) {\n@@ -1068,1 +1066,1 @@\n-  if (_modules != NULL) {\n+  if (_modules != nullptr) {\n@@ -1088,1 +1086,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":80,"deletions":82,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    ChunkedHandleList() : _head(NULL) {}\n+    ChunkedHandleList() : _head(nullptr) {}\n@@ -146,1 +146,1 @@\n-  \/\/ These method IDs are created for the class loader and set to NULL when the\n+  \/\/ These method IDs are created for the class loader and set to null when the\n@@ -258,1 +258,1 @@\n-  \/\/ The Metaspace is created lazily so may be NULL.  This\n+  \/\/ The Metaspace is created lazily so may be null.  This\n@@ -304,1 +304,1 @@\n-  bool modules_defined() { return (_modules != NULL); }\n+  bool modules_defined() { return (_modules != nullptr); }\n@@ -318,1 +318,1 @@\n-  \/\/ Returns Klass* of associated class loader, or NULL if associated loader is 'bootstrap'.\n+  \/\/ Returns Klass* of associated class loader, or null if associated loader is 'bootstrap'.\n@@ -326,1 +326,1 @@\n-  \/\/ Returns the explicitly specified class loader name or NULL.\n+  \/\/ Returns the explicitly specified class loader name or null.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,3 @@\n-  _next_block(NULL),\n-  _prev_block(NULL),\n-  _inline_klass(NULL),\n+  _next_block(nullptr),\n+  _prev_block(nullptr),\n+  _inline_klass(nullptr),\n@@ -57,3 +57,3 @@\n- _next_block(NULL),\n- _prev_block(NULL),\n- _inline_klass(NULL),\n+ _next_block(nullptr),\n+ _prev_block(nullptr),\n+ _inline_klass(nullptr),\n@@ -81,4 +81,4 @@\n-  _next(NULL),\n-  _small_primitive_fields(NULL),\n-  _big_primitive_fields(NULL),\n-  _oop_fields(NULL),\n+  _next(nullptr),\n+  _small_primitive_fields(nullptr),\n+  _big_primitive_fields(nullptr),\n+  _oop_fields(nullptr),\n@@ -101,1 +101,1 @@\n-  if (_oop_fields == NULL) {\n+  if (_oop_fields == nullptr) {\n@@ -119,1 +119,1 @@\n-  if (_small_primitive_fields != NULL) {\n+  if (_small_primitive_fields != nullptr) {\n@@ -122,1 +122,1 @@\n-  if (_big_primitive_fields != NULL) {\n+  if (_big_primitive_fields != nullptr) {\n@@ -128,1 +128,1 @@\n-  if (_small_primitive_fields == NULL) {\n+  if (_small_primitive_fields == nullptr) {\n@@ -135,1 +135,1 @@\n-  if (_big_primitive_fields == NULL) {\n+  if (_big_primitive_fields == nullptr) {\n@@ -144,1 +144,1 @@\n-  _blocks(NULL),\n+  _blocks(nullptr),\n@@ -164,1 +164,1 @@\n-  if (super_klass == NULL) {\n+  if (super_klass == nullptr) {\n@@ -184,1 +184,1 @@\n-  while (block != NULL\n+  while (block != nullptr\n@@ -199,2 +199,2 @@\n-  if (list == NULL) return;\n-  if (start == NULL) start = this->_start;\n+  if (list == nullptr) return;\n+  if (start == nullptr) start = this->_start;\n@@ -206,2 +206,2 @@\n-    LayoutRawBlock* cursor = NULL;\n-    LayoutRawBlock* candidate = NULL;\n+    LayoutRawBlock* cursor = nullptr;\n+    LayoutRawBlock* candidate = nullptr;\n@@ -223,1 +223,1 @@\n-      assert(cursor != NULL, \"Sanity check\");\n+      assert(cursor != nullptr, \"Sanity check\");\n@@ -228,1 +228,1 @@\n-          if (candidate == NULL || cursor->size() < candidate->size()) {\n+          if (candidate == nullptr || cursor->size() < candidate->size()) {\n@@ -234,1 +234,1 @@\n-      if (candidate == NULL) {\n+      if (candidate == nullptr) {\n@@ -238,1 +238,1 @@\n-      assert(candidate != NULL, \"Candidate must not be null\");\n+      assert(candidate != nullptr, \"Candidate must not be null\");\n@@ -248,1 +248,1 @@\n-  assert(block != NULL, \"Sanity check\");\n+  assert(block != nullptr, \"Sanity check\");\n@@ -250,1 +250,1 @@\n-  if (start == NULL) {\n+  if (start == nullptr) {\n@@ -254,1 +254,1 @@\n-  while (slot != NULL) {\n+  while (slot != nullptr) {\n@@ -280,2 +280,2 @@\n-  if (list == NULL) return;\n-  if (start == NULL) {\n+  if (list == nullptr) return;\n+  if (start == nullptr) {\n@@ -291,1 +291,1 @@\n-  LayoutRawBlock* candidate = NULL;\n+  LayoutRawBlock* candidate = nullptr;\n@@ -304,1 +304,1 @@\n-    assert(candidate != NULL, \"Candidate must not be null\");\n+    assert(candidate != nullptr, \"Candidate must not be null\");\n@@ -334,1 +334,1 @@\n-  while (ik != NULL) {\n+  while (ik != nullptr) {\n@@ -354,1 +354,1 @@\n-    ik = ik->super() == NULL ? NULL : InstanceKlass::cast(ik->super());\n+    ik = ik->super() == nullptr ? nullptr : InstanceKlass::cast(ik->super());\n@@ -377,1 +377,1 @@\n-  assert(_blocks != NULL, \"Sanity check\");\n+  assert(_blocks != nullptr, \"Sanity check\");\n@@ -381,1 +381,1 @@\n-  while (b->next_block() != NULL) {\n+  while (b->next_block() != nullptr) {\n@@ -393,1 +393,1 @@\n-  assert(b->next_block() == NULL, \"Invariant at this point\");\n+  assert(b->next_block() == nullptr, \"Invariant at this point\");\n@@ -437,1 +437,1 @@\n-  if (block->prev_block() != NULL) {\n+  if (block->prev_block() != nullptr) {\n@@ -447,1 +447,1 @@\n-  assert(block != NULL, \"Sanity check\");\n+  assert(block != nullptr, \"Sanity check\");\n@@ -451,2 +451,2 @@\n-    if (_blocks != NULL) {\n-      _blocks->set_prev_block(NULL);\n+    if (_blocks != nullptr) {\n+      _blocks->set_prev_block(nullptr);\n@@ -455,1 +455,1 @@\n-    assert(block->prev_block() != NULL, \"_prev should be set for non-head blocks\");\n+    assert(block->prev_block() != nullptr, \"_prev should be set for non-head blocks\");\n@@ -500,1 +500,1 @@\n-      assert(super != NULL, \"super klass must be provided to retrieve inherited fields info\");\n+      assert(super != nullptr, \"super klass must be provided to retrieve inherited fields info\");\n@@ -503,1 +503,1 @@\n-      while (!found && ik != NULL) {\n+      while (!found && ik != nullptr) {\n@@ -547,1 +547,1 @@\n-  _root_group(NULL),\n+  _root_group(nullptr),\n@@ -549,3 +549,3 @@\n-  _static_fields(NULL),\n-  _layout(NULL),\n-  _static_layout(NULL),\n+  _static_fields(nullptr),\n+  _layout(nullptr),\n+  _static_layout(nullptr),\n@@ -567,1 +567,1 @@\n-  FieldGroup* fg = NULL;\n+  FieldGroup* fg = nullptr;\n@@ -581,1 +581,1 @@\n-  if (super_klass != NULL) {\n+  if (super_klass != nullptr) {\n@@ -598,1 +598,1 @@\n-    FieldGroup* group = NULL;\n+    FieldGroup* group = nullptr;\n@@ -616,1 +616,1 @@\n-    assert(group != NULL, \"invariant\");\n+    assert(group != nullptr, \"invariant\");\n@@ -646,1 +646,1 @@\n-        assert(klass != NULL, \"Sanity check\");\n+        assert(klass != nullptr, \"Sanity check\");\n@@ -699,1 +699,1 @@\n-    FieldGroup* group = NULL;\n+    FieldGroup* group = nullptr;\n@@ -708,1 +708,1 @@\n-    assert(group != NULL, \"invariant\");\n+    assert(group != nullptr, \"invariant\");\n@@ -744,1 +744,1 @@\n-        assert(klass != NULL, \"Sanity check\");\n+        assert(klass != nullptr, \"Sanity check\");\n@@ -871,1 +871,1 @@\n-   if (first_field != NULL) {\n+   if (first_field != nullptr) {\n@@ -901,1 +901,1 @@\n-  if (list != NULL) {\n+  if (list != nullptr) {\n@@ -906,1 +906,1 @@\n-        assert(vk != NULL, \"Should have been initialized\");\n+        assert(vk != nullptr, \"Should have been initialized\");\n@@ -916,1 +916,1 @@\n-  if (group->oop_fields() != NULL) {\n+  if (group->oop_fields() != nullptr) {\n@@ -928,1 +928,1 @@\n-  int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass->nonstatic_oop_map_count();\n+  int super_oop_map_count = (_super_klass == nullptr) ? 0 :_super_klass->nonstatic_oop_map_count();\n@@ -941,1 +941,1 @@\n-        assert(cg->oop_fields() != NULL && cg->oop_fields()->at(0) != NULL, \"oop_count > 0 but no oop fields found\");\n+        assert(cg->oop_fields() != nullptr && cg->oop_fields()->at(0) != nullptr, \"oop_count > 0 but no oop fields found\");\n@@ -982,1 +982,1 @@\n-    _static_layout->print(tty, true, NULL);\n+    _static_layout->print(tty, true, nullptr);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-    assert(_inline_klass != NULL, \"Must be initialized\");\n+    assert(_inline_klass != nullptr, \"Must be initialized\");\n@@ -205,3 +205,3 @@\n-  void add(GrowableArray<LayoutRawBlock*>* list, LayoutRawBlock* start = NULL);\n-  void add_field_at_offset(LayoutRawBlock* blocks, int offset, LayoutRawBlock* start = NULL);\n-  void add_contiguously(GrowableArray<LayoutRawBlock*>* list, LayoutRawBlock* start = NULL);\n+  void add(GrowableArray<LayoutRawBlock*>* list, LayoutRawBlock* start = nullptr);\n+  void add_field_at_offset(LayoutRawBlock* blocks, int offset, LayoutRawBlock* start = nullptr);\n+  void add_contiguously(GrowableArray<LayoutRawBlock*>* list, LayoutRawBlock* start = nullptr);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -149,1 +149,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -160,1 +160,1 @@\n-  if (ik == NULL) {\n+  if (ik == nullptr) {\n@@ -186,1 +186,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -254,1 +254,1 @@\n-      assert(mirror != NULL, \"String must have mirror already\");\n+      assert(mirror != nullptr, \"String must have mirror already\");\n@@ -323,1 +323,1 @@\n-  if (utf8_str == NULL) {\n+  if (utf8_str == nullptr) {\n@@ -405,1 +405,1 @@\n-  assert(str != NULL, \"bad arguments\");\n+  assert(str != nullptr, \"bad arguments\");\n@@ -408,1 +408,1 @@\n-  static to_java_string_fn_t _to_java_string_fn = NULL;\n+  static to_java_string_fn_t _to_java_string_fn = nullptr;\n@@ -410,1 +410,1 @@\n-  if (_to_java_string_fn == NULL) {\n+  if (_to_java_string_fn == nullptr) {\n@@ -414,1 +414,1 @@\n-    if (_to_java_string_fn == NULL) {\n+    if (_to_java_string_fn == nullptr) {\n@@ -419,1 +419,1 @@\n-    if (_to_java_string_fn == NULL) {\n+    if (_to_java_string_fn == nullptr) {\n@@ -424,1 +424,1 @@\n-  jstring js = NULL;\n+  jstring js = nullptr;\n@@ -441,1 +441,1 @@\n-  static to_platform_string_fn_t _to_platform_string_fn = NULL;\n+  static to_platform_string_fn_t _to_platform_string_fn = nullptr;\n@@ -443,1 +443,1 @@\n-  if (_to_platform_string_fn == NULL) {\n+  if (_to_platform_string_fn == nullptr) {\n@@ -446,1 +446,1 @@\n-    if (_to_platform_string_fn == NULL) {\n+    if (_to_platform_string_fn == nullptr) {\n@@ -476,1 +476,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -488,1 +488,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -553,1 +553,1 @@\n-  if (length == 0) return NULL;\n+  if (length == 0) return nullptr;\n@@ -578,1 +578,1 @@\n-    jchar* base = (length == 0) ? NULL : value->char_at_addr(0);\n+    jchar* base = (length == 0) ? nullptr : value->char_at_addr(0);\n@@ -583,1 +583,1 @@\n-    jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte* position = (length == 0) ? nullptr : value->byte_at_addr(0);\n@@ -595,1 +595,1 @@\n-    jchar* base = (length == 0) ? NULL : value->char_at_addr(0);\n+    jchar* base = (length == 0) ? nullptr : value->char_at_addr(0);\n@@ -599,1 +599,1 @@\n-    jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte* position = (length == 0) ? nullptr : value->byte_at_addr(0);\n@@ -634,1 +634,1 @@\n-    jchar* position = (length == 0) ? NULL : value->char_at_addr(0);\n+    jchar* position = (length == 0) ? nullptr : value->char_at_addr(0);\n@@ -637,1 +637,1 @@\n-    jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte* position = (length == 0) ? nullptr : value->byte_at_addr(0);\n@@ -649,1 +649,1 @@\n-    jchar *position = (len == 0) ? NULL : value->char_at_addr(0);\n+    jchar *position = (len == 0) ? nullptr : value->char_at_addr(0);\n@@ -656,1 +656,1 @@\n-    jbyte *position = (len == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte *position = (len == 0) ? nullptr : value->byte_at_addr(0);\n@@ -671,1 +671,1 @@\n-    jchar* position = (length == 0) ? NULL : value->char_at_addr(0);\n+    jchar* position = (length == 0) ? nullptr : value->char_at_addr(0);\n@@ -674,1 +674,1 @@\n-    jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte* position = (length == 0) ? nullptr : value->byte_at_addr(0);\n@@ -757,1 +757,1 @@\n-  if (value == NULL) {\n+  if (value == nullptr) {\n@@ -760,1 +760,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"nullptr\");\n@@ -794,2 +794,2 @@\n-GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = NULL;\n-GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = NULL;\n+GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = nullptr;\n+GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = nullptr;\n@@ -813,12 +813,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-static void initialize_static_string_field_for_dump(fieldDescriptor* fd, Handle mirror) {\n-  DEBUG_ONLY(assert_valid_static_string_field(fd);)\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(HeapShared::is_archived_object_during_dumptime(mirror()), \"must be\");\n-  \/\/ Archive the String field and update the pointer.\n-  oop s = mirror()->obj_field(fd->offset());\n-  oop archived_s = StringTable::create_archived_string(s);\n-  mirror()->obj_field_put(fd->offset(), archived_s);\n-}\n-#endif\n-\n@@ -871,13 +859,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-static void initialize_static_field_for_dump(fieldDescriptor* fd, Handle mirror) {\n-  assert(mirror.not_null() && fd->is_static(), \"just checking\");\n-  if (fd->has_initial_value()) {\n-    if (fd->field_type() != T_OBJECT) {\n-      initialize_static_primitive_field(fd, mirror);\n-    } else {\n-      initialize_static_string_field_for_dump(fd, mirror);\n-    }\n-  }\n-}\n-#endif\n-\n@@ -933,1 +908,1 @@\n-    \/\/ During startup, the module may be NULL only if java.base has not been defined yet.\n+    \/\/ During startup, the module may be null only if java.base has not been defined yet.\n@@ -935,1 +910,1 @@\n-    \/\/ for java.base is known. But note that since we captured the NULL module another\n+    \/\/ for java.base is known. But note that since we captured the null module another\n@@ -943,1 +918,1 @@\n-        assert(k->java_mirror() != NULL, \"Class's mirror is null\");\n+        assert(k->java_mirror() != nullptr, \"Class's mirror is null\");\n@@ -945,1 +920,1 @@\n-        assert(fixup_module_field_list() != NULL, \"fixup_module_field_list not initialized\");\n+        assert(fixup_module_field_list() != nullptr, \"fixup_module_field_list not initialized\");\n@@ -955,1 +930,1 @@\n-      assert(javabase_entry != NULL && javabase_entry->module() != NULL,\n+      assert(javabase_entry != nullptr && javabase_entry->module() != nullptr,\n@@ -980,0 +955,69 @@\n+void java_lang_Class::allocate_mirror(Klass* k, bool is_scratch, Handle protection_domain, Handle classData,\n+                                      Handle& mirror, Handle& comp_mirror, TRAPS) {\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK);\n+  mirror = Handle(THREAD, mirror_oop);\n+\n+  \/\/ Setup indirection from mirror->klass\n+  set_klass(mirror(), k);\n+\n+  InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror->klass());\n+  assert(oop_size(mirror()) == mk->instance_size(k), \"should have been set\");\n+\n+  set_static_oop_field_count(mirror(), mk->compute_static_oop_field_count(mirror()));\n+\n+  \/\/ It might also have a component mirror.  This mirror must already exist.\n+  if (k->is_array_klass()) {\n+    if (k->is_flatArray_klass()) {\n+      Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)->element_klass();\n+      assert(element_klass->is_inline_klass(), \"Must be inline type component\");\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(element_klass));\n+      } else {\n+        InlineKlass* vk = InlineKlass::cast(element_klass);\n+        comp_mirror = Handle(THREAD, vk->val_mirror());\n+      }\n+    } else if (k->is_typeArray_klass()) {\n+      BasicType type = TypeArrayKlass::cast(k)->element_type();\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(type));\n+      } else {\n+        comp_mirror = Handle(THREAD, Universe::java_mirror(type));\n+      }\n+    } else {\n+      assert(k->is_objArray_klass(), \"Must be\");\n+      Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n+      assert(element_klass != nullptr, \"Must have an element klass\");\n+      oop comp_oop = element_klass->java_mirror();\n+      if (element_klass->is_inline_klass()) {\n+        InlineKlass* ik = InlineKlass::cast(element_klass);\n+        comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+      }\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(element_klass));\n+      } else {\n+        comp_mirror = Handle(THREAD, comp_oop);\n+      }\n+    }\n+    assert(comp_mirror() != nullptr, \"must have a mirror\");\n+\n+    \/\/ Two-way link between the array klass and its component mirror:\n+    \/\/ (array_klass) k -> mirror -> component_mirror -> array_klass -> k\n+    set_component_mirror(mirror(), comp_mirror());\n+    \/\/ See below for ordering dependencies between field array_klass in component mirror\n+    \/\/ and java_mirror in this klass.\n+  } else {\n+    assert(k->is_instance_klass(), \"Must be\");\n+\n+    initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ If any of the fields throws an exception like OOM remove the klass field\n+      \/\/ from the mirror so GC doesn't follow it after the klass has been deallocated.\n+      \/\/ This mirror looks like a primitive type, which logically it is because it\n+      \/\/ it represents no class.\n+      set_klass(mirror(), nullptr);\n+      return;\n+    }\n+  }\n+}\n+\n@@ -983,2 +1027,2 @@\n-  assert(k != NULL, \"Use create_basic_type_mirror for primitive types\");\n-  assert(k->java_mirror() == NULL, \"should only assign mirror once\");\n+  assert(k != nullptr, \"Use create_basic_type_mirror for primitive types\");\n+  assert(k->java_mirror() == nullptr, \"should only assign mirror once\");\n@@ -995,3 +1039,1 @@\n-    \/\/ Allocate mirror (java.lang.Class instance)\n-    oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK);\n-    Handle mirror(THREAD, mirror_oop);\n+    Handle mirror;\n@@ -1000,49 +1042,1 @@\n-    \/\/ Setup indirection from mirror->klass\n-    set_klass(mirror(), k);\n-\n-    InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror->klass());\n-    assert(oop_size(mirror()) == mk->instance_size(k), \"should have been set\");\n-\n-    set_static_oop_field_count(mirror(), mk->compute_static_oop_field_count(mirror()));\n-\n-    \/\/ It might also have a component mirror.  This mirror must already exist.\n-    if (k->is_array_klass()) {\n-      if (k->is_flatArray_klass()) {\n-        Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)->element_klass();\n-        assert(element_klass->is_inline_klass(), \"Must be inline type component\");\n-        InlineKlass* vk = InlineKlass::cast(element_klass);\n-        comp_mirror = Handle(THREAD, vk->val_mirror());\n-      } else if (k->is_typeArray_klass()) {\n-        BasicType type = TypeArrayKlass::cast(k)->element_type();\n-        comp_mirror = Handle(THREAD, Universe::java_mirror(type));\n-      } else {\n-        assert(k->is_objArray_klass(), \"Must be\");\n-        Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n-        assert(element_klass != NULL, \"Must have an element klass\");\n-        oop comp_oop = element_klass->java_mirror();\n-        if (element_klass->is_inline_klass()) {\n-          InlineKlass* ik = InlineKlass::cast(element_klass);\n-          comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n-        }\n-        comp_mirror = Handle(THREAD, comp_oop);\n-      }\n-      assert(comp_mirror() != NULL, \"must have a mirror\");\n-\n-      \/\/ Two-way link between the array klass and its component mirror:\n-      \/\/ (array_klass) k -> mirror -> component_mirror -> array_klass -> k\n-      set_component_mirror(mirror(), comp_mirror());\n-      \/\/ See below for ordering dependencies between field array_klass in component mirror\n-      \/\/ and java_mirror in this klass.\n-    } else {\n-      assert(k->is_instance_klass(), \"Must be\");\n-\n-      initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        \/\/ If any of the fields throws an exception like OOM remove the klass field\n-        \/\/ from the mirror so GC doesn't follow it after the klass has been deallocated.\n-        \/\/ This mirror looks like a primitive type, which logically it is because it\n-        \/\/ it represents no class.\n-        set_klass(mirror(), NULL);\n-        return;\n-      }\n-    }\n+    allocate_mirror(k, \/*is_scratch=*\/false, protection_domain, classData, mirror, comp_mirror, CHECK);\n@@ -1062,1 +1056,1 @@\n-    if (comp_mirror() != NULL) {\n+    if (comp_mirror() != nullptr) {\n@@ -1073,0 +1067,3 @@\n+    if (DumpSharedSpaces) {\n+      create_scratch_mirror(k, CHECK);\n+    }\n@@ -1074,1 +1071,1 @@\n-    assert(fixup_mirror_list() != NULL, \"fixup_mirror_list not initialized\");\n+    assert(fixup_mirror_list() != nullptr, \"fixup_mirror_list not initialized\");\n@@ -1099,87 +1096,4 @@\n-\/\/ Clears mirror fields. Static final fields with initial values are reloaded\n-\/\/ from constant pool. The object identity hash is in the object header and is\n-\/\/ not affected.\n-class ResetMirrorField: public FieldClosure {\n- private:\n-  Handle _m;\n-\n- public:\n-  ResetMirrorField(Handle mirror) : _m(mirror) {}\n-\n-  void do_field(fieldDescriptor* fd) {\n-    assert(DumpSharedSpaces, \"dump time only\");\n-    assert(_m.not_null(), \"Mirror cannot be NULL\");\n-\n-    if (fd->is_static() && fd->has_initial_value()) {\n-      initialize_static_field_for_dump(fd, _m);\n-      return;\n-    }\n-\n-    BasicType ft = fd->field_type();\n-    switch (ft) {\n-      case T_BYTE:\n-        _m()->byte_field_put(fd->offset(), 0);\n-        break;\n-      case T_CHAR:\n-        _m()->char_field_put(fd->offset(), 0);\n-        break;\n-      case T_DOUBLE:\n-        _m()->double_field_put(fd->offset(), 0);\n-        break;\n-      case T_FLOAT:\n-        _m()->float_field_put(fd->offset(), 0);\n-        break;\n-      case T_INT:\n-        _m()->int_field_put(fd->offset(), 0);\n-        break;\n-      case T_LONG:\n-        _m()->long_field_put(fd->offset(), 0);\n-        break;\n-      case T_SHORT:\n-        _m()->short_field_put(fd->offset(), 0);\n-        break;\n-      case T_BOOLEAN:\n-        _m()->bool_field_put(fd->offset(), false);\n-        break;\n-      case T_PRIMITIVE_OBJECT:\n-      case T_ARRAY:\n-      case T_OBJECT: {\n-        \/\/ It might be useful to cache the String field, but\n-        \/\/ for now just clear out any reference field\n-        oop o = _m()->obj_field(fd->offset());\n-        _m()->obj_field_put(fd->offset(), NULL);\n-        break;\n-      }\n-      default:\n-        ShouldNotReachHere();\n-        break;\n-     }\n-  }\n-};\n-\n-void java_lang_Class::archive_basic_type_mirrors() {\n-  assert(HeapShared::can_write(), \"must be\");\n-\n-  for (int t = T_BOOLEAN; t < T_VOID+1; t++) {\n-    BasicType bt = (BasicType)t;\n-    if (!is_reference_type(bt)) {\n-      oop m = Universe::java_mirror(bt);\n-      assert(m != NULL, \"sanity\");\n-      \/\/ Update the field at _array_klass_offset to point to the relocated array klass.\n-      oop archived_m = HeapShared::archive_object(m);\n-      assert(archived_m != NULL, \"sanity\");\n-\n-      \/\/ Clear the fields. Just to be safe\n-      Klass *k = m->klass();\n-      Handle archived_mirror_h(Thread::current(), archived_m);\n-      ResetMirrorField reset(archived_mirror_h);\n-      InstanceKlass::cast(k)->do_nonstatic_fields(&reset);\n-\n-      log_trace(cds, heap, mirror)(\n-        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-        type2name(bt), p2i(m), p2i(archived_m));\n-\n-      Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(archived_m));\n-    }\n-  }\n-}\n+\/\/ The \"scratch mirror\" stores the states of the mirror object that can be\n+\/\/ decided at dump time (such as the initial values of the static fields, the\n+\/\/ component mirror, etc). At runtime, more information is added to it by\n+\/\/ java_lang_Class::restore_archived_mirror().\n@@ -1187,2 +1101,2 @@\n-\/\/ After the mirror object is successfully archived, the archived\n-\/\/ klass is set with _has_archived_raw_mirror flag.\n+\/\/ Essentially, \/*dumptime*\/create_scratch_mirror() + \/*runtime*\/restore_archived_mirror()\n+\/\/ produces the same result as \/*runtime*\/create_mirror().\n@@ -1190,46 +1104,9 @@\n-\/\/ The _has_archived_raw_mirror flag is cleared at runtime when the\n-\/\/ archived mirror is restored. If archived java heap data cannot\n-\/\/ be used at runtime, new mirror object is created for the shared\n-\/\/ class. The _has_archived_raw_mirror is cleared also during the process.\n-oop java_lang_Class::archive_mirror(Klass* k) {\n-  assert(HeapShared::can_write(), \"must be\");\n-\n-  \/\/ Mirror is already archived\n-  if (k->has_archived_mirror_index()) {\n-    assert(k->archived_java_mirror() != NULL, \"no archived mirror\");\n-    return k->archived_java_mirror();\n-  }\n-\n-  \/\/ No mirror\n-  oop mirror = k->java_mirror();\n-  if (mirror == NULL) {\n-    return NULL;\n-  }\n-\n-  if (k->is_instance_klass()) {\n-    InstanceKlass *ik = InstanceKlass::cast(k);\n-    assert(ik->signers() == NULL, \"class with signer should have been excluded\");\n-\n-    if (!(ik->is_shared_boot_class() || ik->is_shared_platform_class() ||\n-          ik->is_shared_app_class())) {\n-      \/\/ Archiving mirror for classes from non-builtin loaders is not\n-      \/\/ supported.\n-      return NULL;\n-    }\n-  }\n-\n-  if (k->is_inline_klass()) {\n-    \/\/ Inline types have a primary mirror and a secondary mirror. Don't handle this for now. TODO:CDS\n-    k->clear_java_mirror_handle();\n-    return NULL;\n-  }\n-\n-  \/\/ Now start archiving the mirror object\n-  oop archived_mirror = HeapShared::archive_object(mirror);\n-  if (archived_mirror == NULL) {\n-    return NULL;\n-  }\n-\n-  archived_mirror = process_archived_mirror(k, mirror, archived_mirror);\n-  if (archived_mirror == NULL) {\n-    return NULL;\n+\/\/ Note: we archive the \"scratch mirror\" instead of k->java_mirror(), because the\n+\/\/ latter may contain dumptime-specific information that cannot be archived\n+\/\/ (e.g., ClassLoaderData*, or static fields that are modified by Java code execution).\n+void java_lang_Class::create_scratch_mirror(Klass* k, TRAPS) {\n+  if (k->class_loader() != nullptr &&\n+      k->class_loader() != SystemDictionary::java_platform_loader() &&\n+      k->class_loader() != SystemDictionary::java_system_loader()) {\n+    \/\/ We only archive the mirrors of classes loaded by the built-in loaders\n+    return;\n@@ -1238,42 +1115,4 @@\n-  k->set_archived_java_mirror(archived_mirror);\n-\n-  ResourceMark rm;\n-  log_trace(cds, heap, mirror)(\n-    \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-    k->external_name(), p2i(mirror), p2i(archived_mirror));\n-\n-  return archived_mirror;\n-}\n-\n-\/\/ The process is based on create_mirror().\n-oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,\n-                                             oop archived_mirror) {\n-  \/\/ Clear nonstatic fields in archived mirror. Some of the fields will be set\n-  \/\/ to archived metadata and objects below.\n-  Klass *c = archived_mirror->klass();\n-  Handle archived_mirror_h(Thread::current(), archived_mirror);\n-  ResetMirrorField reset(archived_mirror_h);\n-  InstanceKlass::cast(c)->do_nonstatic_fields(&reset);\n-\n-  if (k->is_array_klass()) {\n-    oop archived_comp_mirror;\n-    if (k->is_typeArray_klass()) {\n-      \/\/ The primitive type mirrors are already archived. Get the archived mirror.\n-      oop comp_mirror = component_mirror(mirror);\n-      archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);\n-      assert(archived_comp_mirror != NULL, \"Must be\");\n-    } else {\n-      assert(k->is_objArray_klass(), \"Must be\");\n-      Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n-      assert(element_klass != NULL, \"Must have an element klass\");\n-      archived_comp_mirror = archive_mirror(element_klass);\n-      if (archived_comp_mirror == NULL) {\n-        return NULL;\n-      }\n-    }\n-    set_component_mirror(archived_mirror, archived_comp_mirror);\n-  } else {\n-    assert(k->is_instance_klass(), \"Must be\");\n-\n-    \/\/ Reset local static fields in the mirror\n-    InstanceKlass::cast(k)->do_local_static_fields(&reset);\n+  Handle protection_domain, classData; \/\/ set to null. Will be reinitialized at runtime\n+  Handle mirror;\n+  Handle comp_mirror;\n+  allocate_mirror(k, \/*is_scratch=*\/true, protection_domain, classData, mirror, comp_mirror, CHECK);\n@@ -1281,3 +1120,2 @@\n-    set_protection_domain(archived_mirror, NULL);\n-    set_signers(archived_mirror, NULL);\n-    set_source_file(archived_mirror, NULL);\n+  if (comp_mirror() != nullptr) {\n+    release_set_array_klass(comp_mirror(), k);\n@@ -1286,5 +1124,1 @@\n-  \/\/ clear class loader and mirror_module_field\n-  set_class_loader(archived_mirror, NULL);\n-  set_module(archived_mirror, NULL);\n-\n-  return archived_mirror;\n+  HeapShared::set_scratch_java_mirror(k, mirror());\n@@ -1302,1 +1136,1 @@\n-    assert(fixup_mirror_list() != NULL, \"fixup_mirror_list not initialized\");\n+    assert(fixup_mirror_list() != nullptr, \"fixup_mirror_list not initialized\");\n@@ -1308,1 +1142,1 @@\n-  assert(m != NULL, \"must have stored non-null archived mirror\");\n+  assert(m != nullptr, \"must have stored non-null archived mirror\");\n@@ -1449,1 +1283,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -1469,1 +1303,1 @@\n-  oop java_class = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(NULL, CHECK_NULL);\n+  oop java_class = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(nullptr, CHECK_NULL);\n@@ -1472,1 +1306,1 @@\n-    assert(aklass != NULL, \"correct bootstrap\");\n+    assert(aklass != nullptr, \"correct bootstrap\");\n@@ -1490,1 +1324,1 @@\n-  Symbol* name = NULL;\n+  Symbol* name = nullptr;\n@@ -1501,1 +1335,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -1550,1 +1384,1 @@\n-  const char* name = NULL;\n+  const char* name = nullptr;\n@@ -1556,1 +1390,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -1564,1 +1398,1 @@\n-  assert(k == NULL || k->is_klass() && k->is_array_klass(), \"should be array klass\");\n+  assert(k == nullptr || k->is_klass() && k->is_array_klass(), \"should be array klass\");\n@@ -1579,1 +1413,1 @@\n-  if (ak != NULL) {\n+  if (ak != nullptr) {\n@@ -1592,2 +1426,2 @@\n-    if (reference_klass != NULL)\n-      (*reference_klass) = NULL;\n+    if (reference_klass != nullptr)\n+      (*reference_klass) = nullptr;\n@@ -1596,1 +1430,1 @@\n-    if (reference_klass != NULL)\n+    if (reference_klass != nullptr)\n@@ -1605,1 +1439,1 @@\n-  assert(mirror != NULL && mirror->is_a(vmClasses::Class_klass()), \"must be a Class\");\n+  assert(mirror != nullptr && mirror->is_a(vmClasses::Class_klass()), \"must be a Class\");\n@@ -1759,0 +1593,2 @@\n+int java_lang_Thread::_jvmti_VTMS_transition_disable_count_offset;\n+int java_lang_Thread::_jvmti_is_in_VTMS_transition_offset;\n@@ -1809,0 +1645,25 @@\n+int java_lang_Thread::VTMS_transition_disable_count(oop java_thread) {\n+  return java_thread->int_field(_jvmti_VTMS_transition_disable_count_offset);\n+}\n+\n+void java_lang_Thread::inc_VTMS_transition_disable_count(oop java_thread) {\n+  assert(JvmtiVTMSTransition_lock->owned_by_self(), \"Must be locked\");\n+  int val = VTMS_transition_disable_count(java_thread);\n+  java_thread->int_field_put(_jvmti_VTMS_transition_disable_count_offset, val + 1);\n+}\n+\n+void java_lang_Thread::dec_VTMS_transition_disable_count(oop java_thread) {\n+  assert(JvmtiVTMSTransition_lock->owned_by_self(), \"Must be locked\");\n+  int val = VTMS_transition_disable_count(java_thread);\n+  assert(val > 0, \"VTMS_transition_disable_count should never be negative\");\n+  java_thread->int_field_put(_jvmti_VTMS_transition_disable_count_offset, val - 1);\n+}\n+\n+bool java_lang_Thread::is_in_VTMS_transition(oop java_thread) {\n+  return java_thread->bool_field_volatile(_jvmti_is_in_VTMS_transition_offset);\n+}\n+\n+void java_lang_Thread::set_is_in_VTMS_transition(oop java_thread, bool val) {\n+  java_thread->bool_field_put_volatile(_jvmti_is_in_VTMS_transition_offset, val);\n+}\n+\n@@ -1810,2 +1671,2 @@\n-  assert(java_thread != NULL, \"need a java_lang_Thread pointer here\");\n-  java_thread->obj_field_put(_scopedValueBindings_offset, NULL);\n+  assert(java_thread != nullptr, \"need a java_lang_Thread pointer here\");\n+  java_thread->obj_field_put(_scopedValueBindings_offset, nullptr);\n@@ -1849,1 +1710,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1856,1 +1717,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1863,1 +1724,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1870,1 +1731,1 @@\n-  return (thr != NULL);\n+  return (thr != nullptr);\n@@ -1876,1 +1737,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1883,1 +1744,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1898,1 +1759,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1905,1 +1766,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1917,1 +1778,1 @@\n-  if (holder == NULL) {\n+  if (holder == nullptr) {\n@@ -1938,2 +1799,2 @@\n-    if (carrier_thread == NULL) {\n-      return NULL;\n+    if (carrier_thread == nullptr) {\n+      return nullptr;\n@@ -1945,2 +1806,2 @@\n-  if (thread == NULL) {\n-    return NULL;\n+  if (thread == nullptr) {\n+    return nullptr;\n@@ -1994,1 +1855,1 @@\n-        carrier = (thread->vthread_continuation() != NULL);\n+        carrier = (thread->vthread_continuation() != nullptr);\n@@ -2034,1 +1895,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2039,1 +1900,1 @@\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n+  assert(k != nullptr, \"must be loaded in 1.4+\");\n@@ -2058,1 +1919,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -2088,1 +1949,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -2091,1 +1952,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2155,1 +2016,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -2274,1 +2135,1 @@\n-\/\/ Return Symbol for detailed_message or NULL\n+\/\/ Return Symbol for detailed_message or null\n@@ -2278,1 +2139,1 @@\n-  if (detailed_message != NULL) {\n+  if (detailed_message != nullptr) {\n@@ -2281,1 +2142,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2294,1 +2155,1 @@\n-  set_stacktrace(throwable, NULL);\n+  set_stacktrace(throwable, nullptr);\n@@ -2301,1 +2162,1 @@\n-  assert(k != NULL, \"just checking\");\n+  assert(k != nullptr, \"just checking\");\n@@ -2304,1 +2165,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -2314,1 +2175,1 @@\n-  return method != NULL && (method->constants()->version() == version);\n+  return method != nullptr && (method->constants()->version() == version);\n@@ -2351,1 +2212,1 @@\n-    assert(methods != NULL, \"method array should be initialized in backtrace\");\n+    assert(methods != nullptr, \"method array should be initialized in backtrace\");\n@@ -2356,1 +2217,1 @@\n-    assert(bcis != NULL, \"bci array should be initialized in backtrace\");\n+    assert(bcis != nullptr, \"bci array should be initialized in backtrace\");\n@@ -2361,1 +2222,1 @@\n-    assert(mirrors != NULL, \"mirror array should be initialized in backtrace\");\n+    assert(mirrors != nullptr, \"mirror array should be initialized in backtrace\");\n@@ -2366,1 +2227,1 @@\n-    assert(names != NULL, \"names array should be initialized in backtrace\");\n+    assert(names != nullptr, \"names array should be initialized in backtrace\");\n@@ -2371,1 +2232,1 @@\n-    return hidden != NULL;\n+    return hidden != nullptr;\n@@ -2377,1 +2238,1 @@\n-  BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {\n+  BacktraceBuilder(TRAPS): _head(nullptr), _methods(nullptr), _bcis(nullptr), _mirrors(nullptr), _names(nullptr), _has_hidden_top_frame(false) {\n@@ -2426,1 +2287,1 @@\n-    new_head->obj_at_put(trace_hidden_offset, NULL);\n+    new_head->obj_at_put(trace_hidden_offset, nullptr);\n@@ -2462,1 +2323,1 @@\n-    assert(method->method_holder()->java_mirror() != NULL, \"never push null for mirror\");\n+    assert(method->method_holder()->java_mirror() != nullptr, \"never push null for mirror\");\n@@ -2475,1 +2336,1 @@\n-      assert(_methods != NULL, \"we need a legal oop\");\n+      assert(_methods != nullptr, \"we need a legal oop\");\n@@ -2535,1 +2396,1 @@\n-    return _result.not_null() && _mirrors->obj_at(_index) != NULL;\n+    return _result.not_null() && _mirrors->obj_at(_index) != nullptr;\n@@ -2553,1 +2414,1 @@\n-  char* source_file_name = NULL;\n+  char* source_file_name = nullptr;\n@@ -2555,1 +2416,1 @@\n-  if (source != NULL) {\n+  if (source != nullptr) {\n@@ -2560,1 +2421,1 @@\n-  char *module_name = NULL, *module_version = NULL;\n+  char *module_name = nullptr, *module_version = nullptr;\n@@ -2565,1 +2426,1 @@\n-    if (module->version() != NULL) {\n+    if (module->version() != nullptr) {\n@@ -2579,2 +2440,2 @@\n-  if (module_name != NULL) {\n-    if (module_version != NULL) {\n+  if (module_name != nullptr) {\n+    if (module_version != nullptr) {\n@@ -2587,1 +2448,1 @@\n-  \/\/ The method can be NULL if the requested class version is gone\n+  \/\/ The method can be null if the requested class version is gone\n@@ -2596,1 +2457,1 @@\n-      if (source_file_name != NULL && (line_number != -1)) {\n+      if (source_file_name != nullptr && (line_number != -1)) {\n@@ -2599,1 +2460,1 @@\n-      } else if (source_file_name != NULL) {\n+      } else if (source_file_name != nullptr) {\n@@ -2607,1 +2468,1 @@\n-      if (WizardMode && nm != NULL) {\n+      if (WizardMode && nm != nullptr) {\n@@ -2692,1 +2553,1 @@\n-  set_backtrace(throwable(), NULL);\n+  set_backtrace(throwable(), nullptr);\n@@ -2705,1 +2566,1 @@\n-    if (max_depth >= 1 && method() != NULL) {\n+    if (max_depth >= 1 && method() != nullptr) {\n@@ -2729,1 +2590,1 @@\n-  CompiledMethod* nm = NULL;\n+  CompiledMethod* nm = nullptr;\n@@ -2736,1 +2597,1 @@\n-    Method* method = NULL;\n+    Method* method = nullptr;\n@@ -2770,1 +2631,1 @@\n-        \/\/ HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL\n+        \/\/ HMMM QQQ might be nice to have frame return nm as null if cb is non-null\n@@ -2773,1 +2634,1 @@\n-        if (cb == NULL || !cb->is_compiled()) {\n+        if (cb == nullptr || !cb->is_compiled()) {\n@@ -2777,1 +2638,1 @@\n-        assert(nm->method() != NULL, \"must be\");\n+        assert(nm->method() != nullptr, \"must be\");\n@@ -2910,1 +2771,1 @@\n-  assert(java_lang_Throwable::unassigned_stacktrace() != NULL, \"not initialized\");\n+  assert(java_lang_Throwable::unassigned_stacktrace() != nullptr, \"not initialized\");\n@@ -2975,1 +2836,1 @@\n-  if (message == NULL) {\n+  if (message == nullptr) {\n@@ -2992,1 +2853,1 @@\n-  set_backtrace(h_cause(), NULL);\n+  set_backtrace(h_cause(), nullptr);\n@@ -3006,1 +2867,1 @@\n-  if (hidden != NULL) {\n+  if (hidden != nullptr) {\n@@ -3014,1 +2875,1 @@\n-  assert(holder != NULL, \"first element should be non-null\");\n+  assert(holder != nullptr, \"first element should be non-null\");\n@@ -3018,1 +2879,1 @@\n-  if (m == NULL || !version_matches(m, bte._version)) {\n+  if (m == nullptr || !version_matches(m, bte._version)) {\n@@ -3030,1 +2891,1 @@\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n+  assert(k != nullptr, \"must be loaded in 1.4+\");\n@@ -3057,1 +2918,1 @@\n-  if (loader != NULL) {\n+  if (loader != nullptr) {\n@@ -3059,1 +2920,1 @@\n-    if (loader_name != NULL)\n+    if (loader_name != nullptr)\n@@ -3073,1 +2934,1 @@\n-    if (module->version() != NULL) {\n+    if (module->version() != nullptr) {\n@@ -3076,1 +2937,1 @@\n-      module_version = NULL;\n+      module_version = nullptr;\n@@ -3081,1 +2942,1 @@\n-  if (method() == NULL || !version_matches(method(), version)) {\n+  if (method() == nullptr || !version_matches(method(), version)) {\n@@ -3083,1 +2944,1 @@\n-    java_lang_StackTraceElement::set_fileName(element(), NULL);\n+    java_lang_StackTraceElement::set_fileName(element(), nullptr);\n@@ -3107,1 +2968,1 @@\n-  if (source != NULL) {\n+  if (source != nullptr) {\n@@ -3110,1 +2971,1 @@\n-    if (source_file == NULL) {\n+    if (source_file == nullptr) {\n@@ -3116,2 +2977,2 @@\n-    if (source_file != NULL) {\n-      source_file = NULL;\n+    if (source_file != nullptr) {\n+      source_file = nullptr;\n@@ -3130,1 +2991,1 @@\n-  filename = NULL;\n+  filename = nullptr;\n@@ -3190,1 +3051,1 @@\n-  oop contScope = cont_h() != NULL ? jdk_internal_vm_Continuation::scope(cont_h()) : (oop)NULL;\n+  oop contScope = cont_h() != nullptr ? jdk_internal_vm_Continuation::scope(cont_h()) : (oop)nullptr;\n@@ -3573,1 +3434,1 @@\n-  assert(ik != NULL, \"must be loaded\");\n+  assert(ik != nullptr, \"must be loaded\");\n@@ -3590,1 +3451,1 @@\n-  Method* accessor_method = NULL;\n+  Method* accessor_method = nullptr;\n@@ -3601,1 +3462,1 @@\n-  if (accessor_method != NULL) {\n+  if (accessor_method != nullptr) {\n@@ -3606,1 +3467,1 @@\n-    java_lang_reflect_RecordComponent::set_accessor(element(), NULL);\n+    java_lang_reflect_RecordComponent::set_accessor(element(), nullptr);\n@@ -3615,1 +3476,1 @@\n-    java_lang_reflect_RecordComponent::set_signature(element(), NULL);\n+    java_lang_reflect_RecordComponent::set_signature(element(), nullptr);\n@@ -3756,1 +3617,1 @@\n-  assert(module != NULL, \"module can't be null\");\n+  assert(module != nullptr, \"module can't be null\");\n@@ -3765,1 +3626,1 @@\n-  if (module_entry == NULL) {\n+  if (module_entry == nullptr) {\n@@ -3778,1 +3639,1 @@\n-  assert(module != NULL, \"module can't be null\");\n+  assert(module != nullptr, \"module can't be null\");\n@@ -3860,1 +3721,1 @@\n-  assert(obj != NULL, \"sanity\");\n+  assert(obj != nullptr, \"sanity\");\n@@ -3897,1 +3758,1 @@\n-  if (k == NULL)  return NULL;\n+  if (k == nullptr)  return nullptr;\n@@ -3908,1 +3769,1 @@\n-  if (box == NULL)  return NULL;\n+  if (box == nullptr)  return nullptr;\n@@ -3935,1 +3796,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -3942,1 +3803,1 @@\n-  if (box == NULL)  return T_ILLEGAL;\n+  if (box == nullptr)  return T_ILLEGAL;\n@@ -4075,1 +3936,1 @@\n-  oop member_name = NULL;\n+  oop member_name = nullptr;\n@@ -4149,1 +4010,1 @@\n-  assert(k != NULL, \"jdk mismatch\");\n+  assert(k != nullptr, \"jdk mismatch\");\n@@ -4164,1 +4025,1 @@\n-  assert (k != NULL, \"jdk mismatch\");\n+  assert (k != nullptr, \"jdk mismatch\");\n@@ -4175,1 +4036,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4186,1 +4047,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4226,1 +4087,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4280,1 +4141,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4318,1 +4179,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4405,1 +4266,1 @@\n-  return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);\n+  return method == nullptr ? nullptr : java_lang_invoke_ResolvedMethodName::vmtarget(method);\n@@ -4452,1 +4313,1 @@\n-  if (resolved_method != NULL) {\n+  if (resolved_method != nullptr) {\n@@ -4515,1 +4376,1 @@\n-  if (pts != NULL) {\n+  if (pts != nullptr) {\n@@ -4520,1 +4381,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"null\");\n@@ -4524,1 +4385,1 @@\n-  if (rt != NULL) {\n+  if (rt != nullptr) {\n@@ -4527,1 +4388,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"null\");\n@@ -4715,1 +4576,1 @@\n-  assert(loader != NULL, \"loader must not be NULL\");\n+  assert(loader != nullptr, \"loader must not be null\");\n@@ -4721,1 +4582,1 @@\n-  assert(loader != NULL, \"loader must not be NULL\");\n+  assert(loader != nullptr, \"loader must not be null\");\n@@ -4727,1 +4588,1 @@\n-  assert(loader != NULL, \"loader must not be NULL\");\n+  assert(loader != nullptr, \"loader must not be null\");\n@@ -4783,1 +4644,1 @@\n-  assert(cl == NULL || is_instance(cl), \"cl argument must be oop\");\n+  assert(cl == nullptr || is_instance(cl), \"cl argument must be oop\");\n@@ -4793,1 +4654,1 @@\n-  } while (acl != NULL);\n+  } while (acl != nullptr);\n@@ -4798,1 +4659,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4807,1 +4668,1 @@\n-  return (class_loader->obj_field(_parallelCapable_offset) != NULL);\n+  return (class_loader->obj_field(_parallelCapable_offset) != nullptr);\n@@ -4815,1 +4676,1 @@\n-  while(cl != NULL) {\n+  while(cl != nullptr) {\n@@ -4825,1 +4686,1 @@\n-  if (loader != NULL) {\n+  if (loader != nullptr) {\n@@ -4828,1 +4689,1 @@\n-    return (delegating_cl_class != NULL && loader->is_a(delegating_cl_class));\n+    return (delegating_cl_class != nullptr && loader->is_a(delegating_cl_class));\n@@ -4889,1 +4750,1 @@\n-  return base->obj_field(_static_security_offset) != NULL;\n+  return base->obj_field(_static_security_offset) != nullptr;\n@@ -4911,1 +4772,1 @@\n-    _page_size = os::vm_page_size();\n+    _page_size = (int)os::vm_page_size();\n@@ -4919,1 +4780,1 @@\n-    assert(mirror != NULL, \"UnsafeConstants must have mirror already\");\n+    assert(mirror != nullptr, \"UnsafeConstants must have mirror already\");\n@@ -5100,1 +4961,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -5113,1 +4974,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -5143,1 +5004,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -5173,1 +5034,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -5203,1 +5064,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -5233,1 +5094,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -5268,1 +5129,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":302,"deletions":441,"binary":false,"changes":743,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,0 +258,2 @@\n+  static void allocate_mirror(Klass* k, bool is_scratch, Handle protection_domain, Handle classData,\n+                              Handle& mirror, Handle& comp_mirror, TRAPS); \/\/ returns mirror and comp_mirror\n@@ -266,4 +268,1 @@\n-  static void archive_basic_type_mirrors() NOT_CDS_JAVA_HEAP_RETURN;\n-  static oop  archive_mirror(Klass* k) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror)\n-                                      NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static void create_scratch_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -279,1 +278,1 @@\n-  static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);\n+  static BasicType as_BasicType(oop java_class, Klass** reference_klass = nullptr);\n@@ -351,0 +350,2 @@\n+  macro(java_lang_Thread, jvmti_VTMS_transition_disable_count, int_signature, false) \\\n+  macro(java_lang_Thread, jvmti_is_in_VTMS_transition, bool_signature, false) \\\n@@ -364,0 +365,2 @@\n+  static int _jvmti_VTMS_transition_disable_count_offset;\n+  static int _jvmti_is_in_VTMS_transition_offset;\n@@ -413,0 +416,5 @@\n+  static int  VTMS_transition_disable_count(oop java_thread);\n+  static void inc_VTMS_transition_disable_count(oop java_thread);\n+  static void dec_VTMS_transition_disable_count(oop java_thread);\n+  static bool is_in_VTMS_transition(oop java_thread);\n+  static void set_is_in_VTMS_transition(oop java_thread, bool val);\n@@ -928,1 +936,1 @@\n-  \/\/ Allocation. Returns a boxed value, or NULL for invalid type.\n+  \/\/ Allocation. Returns a boxed value, or null for invalid type.\n@@ -1089,1 +1097,1 @@\n-    return vmClasses::LambdaForm_klass() != NULL &&\n+    return vmClasses::LambdaForm_klass() != nullptr &&\n@@ -1119,1 +1127,1 @@\n-    return vmClasses::NativeEntryPoint_klass() != NULL &&\n+    return vmClasses::NativeEntryPoint_klass() != nullptr &&\n@@ -1157,1 +1165,1 @@\n-    return vmClasses::ABIDescriptor_klass() != NULL &&\n+    return vmClasses::ABIDescriptor_klass() != nullptr &&\n@@ -1185,1 +1193,1 @@\n-    return vmClasses::VMStorage_klass() != NULL &&\n+    return vmClasses::VMStorage_klass() != nullptr &&\n@@ -1209,1 +1217,1 @@\n-    return vmClasses::CallConv_klass() != NULL &&\n+    return vmClasses::CallConv_klass() != nullptr &&\n@@ -1311,3 +1319,0 @@\n-    \/\/ The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:\n-    MN_SEARCH_SUPERCLASSES   = 0x00100000, \/\/ walk super classes\n-    MN_SEARCH_INTERFACES     = 0x00200000, \/\/ walk implemented interfaces\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-  if (value == NULL) {\n+  if (value == nullptr) {\n@@ -130,1 +130,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::String_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::String_klass();\n@@ -251,1 +251,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -259,1 +259,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -263,1 +263,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -267,1 +267,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::MemberName_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::MemberName_klass();\n@@ -271,1 +271,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::ResolvedMethodName_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::ResolvedMethodName_klass();\n@@ -275,1 +275,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::MethodType_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::MethodType_klass();\n@@ -279,1 +279,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -283,1 +283,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::Class_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::Class_klass();\n@@ -290,1 +290,1 @@\n-  assert(k == NULL || k->is_klass(), \"type check\");\n+  assert(k == nullptr || k->is_klass(), \"type check\");\n@@ -297,1 +297,1 @@\n-  bool is_primitive = (java_class->metadata_field(_klass_offset) == NULL);\n+  bool is_primitive = (java_class->metadata_field(_klass_offset) == nullptr);\n@@ -302,1 +302,1 @@\n-    assert(k == NULL || is_java_primitive(ArrayKlass::cast(k)->element_type()),\n+    assert(k == nullptr || is_java_primitive(ArrayKlass::cast(k)->element_type()),\n@@ -336,1 +336,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -340,1 +340,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::Module_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::Module_klass();\n@@ -394,1 +394,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,2 @@\n-       _stnext = NULL;\n-       _stprev = NULL;\n+       _stnext = nullptr;\n+       _stprev = nullptr;\n@@ -86,1 +86,1 @@\n-    while (seen != NULL) {\n+    while (seen != nullptr) {\n@@ -95,1 +95,1 @@\n-  SeenThread* queuehead = NULL;\n+  SeenThread* queuehead = nullptr;\n@@ -143,1 +143,1 @@\n-  assert(action != PlaceholderTable::LOAD_INSTANCE || !EnableWaitForParallelLoad || seen == NULL,\n+  assert(action != PlaceholderTable::LOAD_INSTANCE || !EnableWaitForParallelLoad || seen == nullptr,\n@@ -146,1 +146,1 @@\n-  if (seen == NULL) {\n+  if (seen == nullptr) {\n@@ -151,1 +151,1 @@\n-  while ((next = seen->next()) != NULL) {\n+  while ((next = seen->next()) != nullptr) {\n@@ -181,1 +181,1 @@\n-  SeenThread* prev = NULL;\n+  SeenThread* prev = nullptr;\n@@ -198,1 +198,1 @@\n-  return (actionToQueue(action) == NULL);\n+  return (actionToQueue(action) == nullptr);\n@@ -202,1 +202,5 @@\n-\/\/ Placeholder methods\n+void PlaceholderEntry::set_supername(Symbol* supername) {\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  assert(_supername == nullptr || _supername->refcount() > 1, \"must be referenced also by the loader\");\n+  _supername = supername;\n+}\n@@ -211,1 +215,1 @@\n-  assert(class_name != NULL, \"adding NULL obj\");\n+  assert(class_name != nullptr, \"adding nullptr obj\");\n@@ -267,1 +271,1 @@\n-  assert(action != LOAD_SUPER || supername != NULL, \"must have a super class name\");\n+  assert(action != LOAD_SUPER || supername != nullptr, \"must have a super class name\");\n@@ -269,1 +273,1 @@\n-  if (probe == NULL) {\n+  if (probe == nullptr) {\n@@ -284,1 +288,0 @@\n-\/\/ placeholder existence now for loading superclass\/superinterface\n@@ -295,1 +298,0 @@\n-\/\/ Ignores the case where entry is not found\n@@ -301,10 +303,11 @@\n-  if (probe != NULL) {\n-    log(name, probe, \"find_and_remove\", action);\n-    probe->remove_seen_thread(thread, action);\n-    \/\/ If no other threads using this entry, and this thread is not using this entry for other states\n-    if ((probe->superThreadQ() == NULL) && (probe->loadInstanceThreadQ() == NULL)\n-        && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)\n-        && (probe->inlineTypeFieldQ() == NULL)) {\n-      probe->clear_supername();\n-      remove_entry(name, loader_data);\n-    }\n+  assert(probe != nullptr, \"must find an entry\");\n+  log(name, probe, \"find_and_remove\", action);\n+  probe->remove_seen_thread(thread, action);\n+  if (probe->superThreadQ() == nullptr) {\n+    probe->set_supername(nullptr);\n+  }\n+  \/\/ If no other threads using this entry, and this thread is not using this entry for other states\n+  if ((probe->superThreadQ() == nullptr) && (probe->loadInstanceThreadQ() == nullptr)\n+      && (probe->defineThreadQ() == nullptr) && (probe->definer() == nullptr)\n+      && (probe->inlineTypeFieldQ() == nullptr)) {\n+    remove_entry(name, loader_data);\n@@ -321,1 +324,1 @@\n-  if (supername() != NULL) {\n+  if (supername() != nullptr) {\n@@ -325,1 +328,1 @@\n-  if (definer() != NULL) {\n+  if (definer() != nullptr) {\n@@ -329,1 +332,1 @@\n-  if (instance_klass() != NULL) {\n+  if (instance_klass() != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":32,"deletions":29,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"oops\/symbolHandle.hpp\"\n+\n@@ -31,1 +33,0 @@\n-class Symbol;\n@@ -85,1 +86,1 @@\n-  Symbol*           _supername;\n+  SymbolHandle      _supername;\n@@ -104,0 +105,8 @@\n+  SeenThread*        superThreadQ()        const { return _superThreadQ; }\n+  void               set_superThreadQ(SeenThread* SeenThread) { _superThreadQ = SeenThread; }\n+\n+  SeenThread*        loadInstanceThreadQ() const { return _loadInstanceThreadQ; }\n+  void               set_loadInstanceThreadQ(SeenThread* SeenThread) { _loadInstanceThreadQ = SeenThread; }\n+\n+  SeenThread*        defineThreadQ()       const { return _defineThreadQ; }\n+  void               set_defineThreadQ(SeenThread* SeenThread) { _defineThreadQ = SeenThread; }\n@@ -106,1 +115,1 @@\n-     _supername(nullptr), _definer(nullptr), _instanceKlass(nullptr),\n+     _definer(nullptr), _instanceKlass(nullptr),\n@@ -111,11 +120,1 @@\n-  void               set_supername(Symbol* supername) {\n-    if (supername != _supername) {\n-      Symbol::maybe_decrement_refcount(_supername);\n-      _supername = supername;\n-      Symbol::maybe_increment_refcount(_supername);\n-    }\n-  }\n-  void               clear_supername() {\n-    Symbol::maybe_decrement_refcount(_supername);\n-    _supername = nullptr;\n-  }\n+  void               set_supername(Symbol* supername);\n@@ -129,9 +128,0 @@\n-  SeenThread*        superThreadQ()        const { return _superThreadQ; }\n-  void               set_superThreadQ(SeenThread* SeenThread) { _superThreadQ = SeenThread; }\n-\n-  SeenThread*        loadInstanceThreadQ() const { return _loadInstanceThreadQ; }\n-  void               set_loadInstanceThreadQ(SeenThread* SeenThread) { _loadInstanceThreadQ = SeenThread; }\n-\n-  SeenThread*        defineThreadQ()       const { return _defineThreadQ; }\n-  void               set_defineThreadQ(SeenThread* SeenThread) { _defineThreadQ = SeenThread; }\n-\n@@ -142,1 +132,1 @@\n-     return (_superThreadQ != NULL);\n+     return (_superThreadQ != nullptr);\n@@ -146,1 +136,1 @@\n-    return (_loadInstanceThreadQ != NULL);\n+    return (_loadInstanceThreadQ != nullptr);\n@@ -150,1 +140,1 @@\n-    return (_defineThreadQ != NULL);\n+    return (_defineThreadQ != nullptr);\n@@ -154,1 +144,1 @@\n-    return (_inlineTypeFieldQ != NULL);\n+    return (_inlineTypeFieldQ != nullptr);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":18,"deletions":28,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-  if (locals == NULL) return -1;\n+  if (locals == nullptr) return -1;\n@@ -205,1 +205,1 @@\n-    if (flags != NULL) {\n+    if (flags != nullptr) {\n@@ -228,1 +228,1 @@\n-  VerificationType* locals = NULL;\n+  VerificationType* locals = nullptr;\n@@ -245,2 +245,2 @@\n-      max_locals, max_stack, locals, NULL, _verifier);\n-    if (first && locals != NULL) {\n+      max_locals, max_stack, locals, nullptr, _verifier);\n+    if (first && locals != nullptr) {\n@@ -267,1 +267,1 @@\n-    stack[0] = parse_verification_type(NULL, CHECK_VERIFY_(_verifier, NULL));\n+    stack[0] = parse_verification_type(nullptr, CHECK_VERIFY_(_verifier, nullptr));\n@@ -273,1 +273,1 @@\n-      stack_size, max_stack, CHECK_VERIFY_(_verifier, NULL));\n+      stack_size, max_stack, CHECK_VERIFY_(_verifier, nullptr));\n@@ -277,1 +277,1 @@\n-    if (first && locals != NULL) {\n+    if (first && locals != nullptr) {\n@@ -288,1 +288,1 @@\n-      \"reserved frame type\", CHECK_VERIFY_(_verifier, NULL));\n+      \"reserved frame type\", CHECK_VERIFY_(_verifier, nullptr));\n@@ -307,1 +307,1 @@\n-    stack[0] = parse_verification_type(NULL, CHECK_VERIFY_(_verifier, NULL));\n+    stack[0] = parse_verification_type(nullptr, CHECK_VERIFY_(_verifier, nullptr));\n@@ -313,1 +313,1 @@\n-      stack_size, max_stack, CHECK_VERIFY_(_verifier, NULL));\n+      stack_size, max_stack, CHECK_VERIFY_(_verifier, nullptr));\n@@ -317,1 +317,1 @@\n-    if (first && locals != NULL) {\n+    if (first && locals != nullptr) {\n@@ -333,1 +333,1 @@\n-        new_length, max_locals, CHECK_VERIFY_(_verifier, NULL));\n+        new_length, max_locals, CHECK_VERIFY_(_verifier, nullptr));\n@@ -350,1 +350,1 @@\n-        locals = NULL;\n+        locals = nullptr;\n@@ -357,2 +357,2 @@\n-      locals, NULL, _verifier);\n-    if (first && locals != NULL) {\n+      locals, nullptr, _verifier);\n+    if (first && locals != nullptr) {\n@@ -383,1 +383,1 @@\n-      real_length, max_locals, CHECK_VERIFY_(_verifier, NULL));\n+      real_length, max_locals, CHECK_VERIFY_(_verifier, nullptr));\n@@ -391,1 +391,1 @@\n-      max_stack, locals, NULL, _verifier);\n+      max_stack, locals, nullptr, _verifier);\n@@ -414,1 +414,1 @@\n-      real_locals_size, max_locals, CHECK_VERIFY_(_verifier, NULL));\n+      real_locals_size, max_locals, CHECK_VERIFY_(_verifier, nullptr));\n@@ -417,1 +417,1 @@\n-    VerificationType* stack = NULL;\n+    VerificationType* stack = nullptr;\n@@ -423,1 +423,1 @@\n-      stack[real_stack_size] = parse_verification_type(NULL, CHECK_NULL);\n+      stack[real_stack_size] = parse_verification_type(nullptr, CHECK_NULL);\n@@ -431,1 +431,1 @@\n-      real_stack_size, max_stack, CHECK_VERIFY_(_verifier, NULL));\n+      real_stack_size, max_stack, CHECK_VERIFY_(_verifier, nullptr));\n@@ -444,2 +444,2 @@\n-    \"reserved frame type\", CHECK_VERIFY_(pre_frame->verifier(), NULL));\n-  return NULL;\n+    \"reserved frame type\", CHECK_VERIFY_(pre_frame->verifier(), nullptr));\n+  return nullptr;\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,1 @@\n-    return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :\n+    return (class_loader() == nullptr) ? ClassLoaderData::the_null_class_loader_data() :\n@@ -233,1 +233,1 @@\n-  if (class_loader == NULL) {\n+  if (class_loader == nullptr) {\n@@ -242,1 +242,1 @@\n-  if (class_loader == NULL) {\n+  if (class_loader == nullptr) {\n@@ -249,1 +249,1 @@\n-  \/\/ If class_loader is NULL or parallelCapable, the JVM doesn't acquire a lock while loading.\n+  \/\/ If class_loader is null or parallelCapable, the JVM doesn't acquire a lock while loading.\n@@ -261,1 +261,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -271,1 +271,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -307,1 +307,1 @@\n-  \/\/ If the class is not found, ie, caller has checked that klass is NULL, throw the appropriate\n+  \/\/ If the class is not found, ie, caller has checked that klass is null, throw the appropriate\n@@ -323,1 +323,1 @@\n-  if (HAS_PENDING_EXCEPTION || klass == NULL) {\n+  if (HAS_PENDING_EXCEPTION || klass == nullptr) {\n@@ -335,1 +335,1 @@\n-    assert(class_name != NULL && !Signature::is_array(class_name), \"must be\");\n+    assert(class_name != nullptr && !Signature::is_array(class_name), \"must be\");\n@@ -358,1 +358,1 @@\n-  Klass* k = NULL;\n+  Klass* k = nullptr;\n@@ -366,1 +366,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -421,1 +421,1 @@\n-  assert(super_name != NULL, \"null superclass for resolving\");\n+  assert(super_name != nullptr, \"null superclass for resolving\");\n@@ -451,2 +451,2 @@\n-    if (klassk != NULL && is_superclass &&\n-        ((quicksuperk = klassk->java_super()) != NULL) &&\n+    if (klassk != nullptr && is_superclass &&\n+        ((quicksuperk = klassk->java_super()) != nullptr) &&\n@@ -494,1 +494,1 @@\n-  if (HAS_PENDING_EXCEPTION || superk == NULL) {\n+  if (HAS_PENDING_EXCEPTION || superk == nullptr) {\n@@ -515,1 +515,1 @@\n-    if (oldprobe != NULL &&\n+    if (oldprobe != nullptr &&\n@@ -521,1 +521,1 @@\n-                                   PlaceholderTable::PRIMITIVE_OBJECT_FIELD, NULL, THREAD);\n+                                   PlaceholderTable::PRIMITIVE_OBJECT_FIELD, nullptr, THREAD);\n@@ -525,1 +525,1 @@\n-  Klass* klass = NULL;\n+  Klass* klass = nullptr;\n@@ -574,1 +574,1 @@\n-  assert(lockObject() != NULL, \"lockObject must be non-NULL\");\n+  assert(lockObject() != nullptr, \"lockObject must be non-null\");\n@@ -624,3 +624,4 @@\n-  if (oldprobe != NULL) {\n-    \/\/ only need check_seen_thread once, not on each loop\n-    \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n+  if (oldprobe != nullptr) {\n+    \/\/ -Xcomp calls load_signature_classes which might result in loading\n+    \/\/ a class that's already in the process of loading, so we detect CCE here also.\n+    \/\/ Only need check_seen_thread once, not on each loop\n@@ -630,1 +631,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -634,1 +635,1 @@\n-      while (oldprobe != NULL &&\n+      while (oldprobe != nullptr &&\n@@ -655,1 +656,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -660,1 +661,1 @@\n-        if (check != NULL) {\n+        if (check != nullptr) {\n@@ -669,1 +670,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -673,2 +674,2 @@\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n+  assert(event != nullptr, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n@@ -685,1 +686,1 @@\n-\/\/ This can return NULL, an exception or an InstanceKlass.\n+\/\/ This can return null, an exception or an InstanceKlass.\n@@ -691,2 +692,2 @@\n-  assert(name != NULL && !Signature::is_array(name) &&\n-         !Signature::has_envelope(name), \"invalid class name: %s\", name == NULL ? \"NULL\" : name->as_C_string());\n+  assert(name != nullptr && !Signature::is_array(name) &&\n+         !Signature::has_envelope(name), \"invalid class name: %s\", name == nullptr ? \"nullptr\" : name->as_C_string());\n@@ -709,1 +710,1 @@\n-  if (probe != NULL) return probe;\n+  if (probe != nullptr) return probe;\n@@ -724,2 +725,2 @@\n-  InstanceKlass* loaded_class = NULL;\n-  Symbol* superclassname = NULL;\n+  InstanceKlass* loaded_class = nullptr;\n+  SymbolHandle superclassname; \/\/ Keep alive while loading in parallel thread.\n@@ -736,1 +737,1 @@\n-    if (check != NULL) {\n+    if (check != nullptr) {\n@@ -741,1 +742,1 @@\n-      if (placeholder != NULL && placeholder->super_load_in_progress()) {\n+      if (placeholder != nullptr && placeholder->super_load_in_progress()) {\n@@ -744,1 +745,1 @@\n-         assert(superclassname != NULL, \"superclass has to have a name\");\n+         assert(superclassname != nullptr, \"superclass has to have a name\");\n@@ -759,1 +760,1 @@\n-  if (loaded_class == NULL) {\n+  if (loaded_class == nullptr) {\n@@ -791,1 +792,1 @@\n-      if (!throw_circularity_error && loaded_class == NULL) {\n+      if (!throw_circularity_error && loaded_class == nullptr) {\n@@ -793,1 +794,1 @@\n-        if (check != NULL) {\n+        if (check != nullptr) {\n@@ -800,1 +801,1 @@\n-                                                                      NULL,\n+                                                                      nullptr,\n@@ -819,1 +820,1 @@\n-    if (loaded_class == NULL) {\n+    if (loaded_class == nullptr) {\n@@ -834,2 +835,2 @@\n-  if (HAS_PENDING_EXCEPTION || loaded_class == NULL) {\n-    return NULL;\n+  if (HAS_PENDING_EXCEPTION || loaded_class == nullptr) {\n+    return nullptr;\n@@ -846,1 +847,1 @@\n-  if (protection_domain() != NULL) {\n+  if (protection_domain() != nullptr) {\n@@ -877,1 +878,1 @@\n-  if (loader_data == NULL) {\n+  if (loader_data == nullptr) {\n@@ -880,1 +881,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -888,1 +889,1 @@\n-\/\/ return NULL in case of error.\n+\/\/ return null in case of error.\n@@ -893,2 +894,2 @@\n-  Klass* k = NULL;\n-  assert(class_name != NULL, \"class name must be non NULL\");\n+  Klass* k = nullptr;\n+  assert(class_name != nullptr, \"class name must be non nullptr\");\n@@ -908,1 +909,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -941,1 +942,1 @@\n-  assert(st != NULL, \"invariant\");\n+  assert(st != nullptr, \"invariant\");\n@@ -950,1 +951,1 @@\n-  assert(k != NULL, \"no klass created\");\n+  assert(k != nullptr, \"no klass created\");\n@@ -980,1 +981,1 @@\n-\/\/ Note: class_name can be NULL. In that case we do not know the name of\n+\/\/ Note: class_name can be null. In that case we do not know the name of\n@@ -983,1 +984,1 @@\n-\/\/ not return NULL without a pending exception.\n+\/\/ not return null without a pending exception.\n@@ -1004,1 +1005,1 @@\n- InstanceKlass* k = NULL;\n+ InstanceKlass* k = nullptr;\n@@ -1016,1 +1017,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -1020,1 +1021,1 @@\n-  assert(k != NULL, \"no klass created\");\n+  assert(k != nullptr, \"no klass created\");\n@@ -1022,1 +1023,1 @@\n-  assert(class_name == NULL || class_name == h_name, \"name mismatch\");\n+  assert(class_name == nullptr || class_name == h_name, \"name mismatch\");\n@@ -1035,1 +1036,1 @@\n-      assert(k != NULL, \"Must have an instance klass here!\");\n+      assert(k != nullptr, \"Must have an instance klass here!\");\n@@ -1037,1 +1038,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1072,1 +1073,1 @@\n-    if (class_loader() != NULL) {\n+    if (class_loader() != nullptr) {\n@@ -1113,1 +1114,1 @@\n-    assert(scp_entry != NULL, \"must be\");\n+    assert(scp_entry != nullptr, \"must be\");\n@@ -1124,1 +1125,1 @@\n-  if (pkg_entry == NULL) {\n+  if (pkg_entry == nullptr) {\n@@ -1128,1 +1129,1 @@\n-    if (pkg_name != NULL) {\n+    if (pkg_name != nullptr) {\n@@ -1133,2 +1134,2 @@\n-  ModuleEntry* mod_entry = (pkg_entry == NULL) ? NULL : pkg_entry->module();\n-  bool should_be_in_named_module = (mod_entry != NULL && mod_entry->is_named());\n+  ModuleEntry* mod_entry = (pkg_entry == nullptr) ? nullptr : pkg_entry->module();\n+  bool should_be_in_named_module = (mod_entry != nullptr && mod_entry->is_named());\n@@ -1171,2 +1172,2 @@\n-  \/\/ + Don't check if loader data is NULL, ie. the super_type isn't fully loaded.\n-  if (!super_type->is_shared_unregistered_class() && super_type->class_loader_data() != NULL) {\n+  \/\/ + Don't check if loader data is null, ie. the super_type isn't fully loaded.\n+  if (!super_type->is_shared_unregistered_class() && super_type->class_loader_data() != nullptr) {\n@@ -1201,1 +1202,1 @@\n-  if (ik->super() != NULL &&\n+  if (ik->super() != nullptr &&\n@@ -1230,1 +1231,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1235,1 +1236,1 @@\n-  InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, CHECK_NULL);\n+  InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, nullptr, pkg_entry, CHECK_NULL);\n@@ -1237,1 +1238,1 @@\n-  if (loaded_ik != NULL) {\n+  if (loaded_ik != nullptr) {\n@@ -1257,1 +1258,1 @@\n-  assert(ik != NULL, \"sanity\");\n+  assert(ik != nullptr, \"sanity\");\n@@ -1262,1 +1263,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1266,1 +1267,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1280,1 +1281,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -1287,1 +1288,1 @@\n-  InstanceKlass* new_ik = NULL;\n+  InstanceKlass* new_ik = nullptr;\n@@ -1294,1 +1295,1 @@\n-  if (new_ik != NULL) {\n+  if (new_ik != nullptr) {\n@@ -1327,1 +1328,1 @@\n-  ik->print_class_load_logging(loader_data, NULL, NULL);\n+  ik->print_class_load_logging(loader_data, nullptr, nullptr);\n@@ -1346,1 +1347,1 @@\n-    PackageEntry* pkg_entry = NULL;\n+    PackageEntry* pkg_entry = nullptr;\n@@ -1351,1 +1352,1 @@\n-    if (pkg_name != NULL) {\n+    if (pkg_name != nullptr) {\n@@ -1363,1 +1364,1 @@\n-      if (pkg_entry == NULL || pkg_entry->in_unnamed_module()) {\n+      if (pkg_entry == nullptr || pkg_entry->in_unnamed_module()) {\n@@ -1372,1 +1373,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1379,1 +1380,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1385,1 +1386,1 @@\n-      if (pkg_name == NULL || pkg_entry == NULL || pkg_entry->in_unnamed_module()) {\n+      if (pkg_name == nullptr || pkg_entry == nullptr || pkg_entry->in_unnamed_module()) {\n@@ -1394,1 +1395,1 @@\n-           return NULL;\n+           return nullptr;\n@@ -1407,1 +1408,1 @@\n-    InstanceKlass* k = NULL;\n+    InstanceKlass* k = nullptr;\n@@ -1414,1 +1415,1 @@\n-      if (ik != NULL && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n+      if (ik != nullptr && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n@@ -1416,1 +1417,1 @@\n-        k = load_shared_class(ik, class_loader, Handle(), NULL,  pkg_entry, CHECK_NULL);\n+        k = load_shared_class(ik, class_loader, Handle(), nullptr,  pkg_entry, CHECK_NULL);\n@@ -1421,1 +1422,1 @@\n-    if (k == NULL) {\n+    if (k == nullptr) {\n@@ -1428,1 +1429,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -1470,1 +1471,1 @@\n-    if ((obj != NULL) && !(java_lang_Class::is_primitive(obj))) {\n+    if ((obj != nullptr) && !(java_lang_Class::is_primitive(obj))) {\n@@ -1479,2 +1480,2 @@\n-    \/\/ Class is not found or has the wrong name, return NULL\n-    return NULL;\n+    \/\/ Class is not found or has the wrong name, return null\n+    return nullptr;\n@@ -1492,1 +1493,1 @@\n-  if (loaded_class != NULL &&\n+  if (loaded_class != nullptr &&\n@@ -1559,1 +1560,1 @@\n-  if (k->class_loader() != NULL) {\n+  if (k->class_loader() != nullptr) {\n@@ -1619,1 +1620,1 @@\n-      if (check != NULL) {\n+      if (check != nullptr) {\n@@ -1626,1 +1627,1 @@\n-                                                             PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n+                                                             PlaceholderTable::DEFINE_CLASS, nullptr, THREAD);\n@@ -1631,1 +1632,1 @@\n-    while (probe->definer() != NULL) {\n+    while (probe->definer() != nullptr) {\n@@ -1637,1 +1638,1 @@\n-    if (is_parallelDefine(class_loader) && (probe->instance_klass() != NULL)) {\n+    if (is_parallelDefine(class_loader) && (probe->instance_klass() != nullptr)) {\n@@ -1643,1 +1644,1 @@\n-      assert(check != NULL, \"definer missed recording success\");\n+      assert(check != nullptr, \"definer missed recording success\");\n@@ -1658,1 +1659,1 @@\n-    assert(probe != NULL, \"DEFINE_CLASS placeholder lost?\");\n+    assert(probe != nullptr, \"DEFINE_CLASS placeholder lost?\");\n@@ -1662,1 +1663,1 @@\n-    probe->set_definer(NULL);\n+    probe->set_definer(nullptr);\n@@ -1667,1 +1668,1 @@\n-  return HAS_PENDING_EXCEPTION ? NULL : k;\n+  return HAS_PENDING_EXCEPTION ? nullptr : k;\n@@ -1678,1 +1679,1 @@\n-    assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n+    assert(defined_k != nullptr, \"Should have a klass if there's no exception\");\n@@ -1681,1 +1682,1 @@\n-    assert(defined_k == NULL, \"Should not have a klass if there's an exception\");\n+    assert(defined_k == nullptr, \"Should not have a klass if there's an exception\");\n@@ -1694,1 +1695,1 @@\n-  assert(k != NULL, \"just checking\");\n+  assert(k != nullptr, \"just checking\");\n@@ -1729,1 +1730,1 @@\n-      MutexLocker ml2(is_concurrent ? Module_lock : NULL);\n+      MutexLocker ml2(is_concurrent ? Module_lock : nullptr);\n@@ -1732,1 +1733,1 @@\n-      MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);\n+      MutexLocker ml1(is_concurrent ? SystemDictionary_lock : nullptr);\n@@ -1755,1 +1756,1 @@\n-    MutexLocker ml(is_concurrent ? ClassInitError_lock : NULL);\n+    MutexLocker ml(is_concurrent ? ClassInitError_lock : nullptr);\n@@ -1819,1 +1820,1 @@\n-    if (check != NULL) {\n+    if (check != nullptr) {\n@@ -1841,1 +1842,1 @@\n-        if (existing_klass != NULL && existing_klass->class_loader_data() != loader_data) {\n+        if (existing_klass != nullptr && existing_klass->class_loader_data() != loader_data) {\n@@ -1874,1 +1875,1 @@\n-  if (sd_check == NULL) {\n+  if (sd_check == nullptr) {\n@@ -1892,1 +1893,1 @@\n-  if (klass != NULL)\n+  if (klass != nullptr)\n@@ -1911,1 +1912,1 @@\n-    if (klass != NULL) {\n+    if (klass != nullptr) {\n@@ -1934,1 +1935,1 @@\n-  Symbol* constraint_name = NULL;\n+  Symbol* constraint_name = nullptr;\n@@ -1964,1 +1965,1 @@\n-    if (Arguments::is_dumping_archive() && klass_being_linked != NULL &&\n+    if (Arguments::is_dumping_archive() && klass_being_linked != nullptr &&\n@@ -1986,1 +1987,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -1997,1 +1998,1 @@\n-\/\/ Lookup resolution error table. Returns error if found, otherwise NULL.\n+\/\/ Lookup resolution error table. Returns error if found, otherwise null.\n@@ -2004,1 +2005,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -2010,1 +2011,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2026,1 +2027,1 @@\n-    if (entry != NULL && entry->nest_host_error() == NULL) {\n+    if (entry != nullptr && entry->nest_host_error() == nullptr) {\n@@ -2043,1 +2044,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -2046,1 +2047,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2099,1 +2100,1 @@\n-\/\/ NULL if no constraint failed.  No exception except OOME is thrown.\n+\/\/ null if no constraint failed.  No exception except OOME is thrown.\n@@ -2107,1 +2108,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2121,1 +2122,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2178,1 +2179,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -2186,1 +2187,1 @@\n-        if (appendix != NULL) { ls.print(\"appendix = \"); appendix->print_on(&ls); }\n+        if (appendix != nullptr) { ls.print(\"appendix = \"); appendix->print_on(&ls); }\n@@ -2217,1 +2218,1 @@\n-  assert(appendix_box->obj_at(0) == NULL, \"\");\n+  assert(appendix_box->obj_at(0) == nullptr, \"\");\n@@ -2220,1 +2221,1 @@\n-  if (accessing_klass == NULL || method_type.is_null()) {\n+  if (accessing_klass == nullptr || method_type.is_null()) {\n@@ -2272,1 +2273,1 @@\n-  assert(accessing_klass == NULL || (class_loader.is_null() && protection_domain.is_null()),\n+  assert(accessing_klass == nullptr || (class_loader.is_null() && protection_domain.is_null()),\n@@ -2278,1 +2279,1 @@\n-  if (accessing_klass != NULL) {\n+  if (accessing_klass != nullptr) {\n@@ -2284,1 +2285,1 @@\n-  if (mirror_oop == NULL) {\n+  if (mirror_oop == nullptr) {\n@@ -2289,1 +2290,1 @@\n-  if (accessing_klass != NULL) {\n+  if (accessing_klass != nullptr) {\n@@ -2292,1 +2293,1 @@\n-    if (sel_klass != NULL) {\n+    if (sel_klass != nullptr) {\n@@ -2324,1 +2325,1 @@\n-  if (accessing_klass != NULL) {\n+  if (accessing_klass != nullptr) {\n@@ -2335,1 +2336,1 @@\n-    oop mirror = NULL;\n+    oop mirror = nullptr;\n@@ -2340,1 +2341,1 @@\n-      if (mirror == NULL || (ss.is_reference() && !is_always_visible_class(mirror))) {\n+      if (mirror == nullptr || (ss.is_reference() && !is_always_visible_class(mirror))) {\n@@ -2350,1 +2351,1 @@\n-    assert(mirror != NULL, \"%s\", ss.as_symbol()->as_C_string());\n+    assert(mirror != nullptr, \"%s\", ss.as_symbol()->as_C_string());\n@@ -2357,1 +2358,1 @@\n-    if (!java_lang_Class::is_primitive(mirror) && accessing_klass != NULL) {\n+    if (!java_lang_Class::is_primitive(mirror) && accessing_klass != nullptr) {\n@@ -2359,1 +2360,1 @@\n-      mirror = NULL;  \/\/ safety\n+      mirror = nullptr;  \/\/ safety\n@@ -2381,1 +2382,1 @@\n-    assert(method_type != NULL, \"unexpected null\");\n+    assert(method_type != nullptr, \"unexpected null\");\n@@ -2402,1 +2403,1 @@\n-    if (accessing_klass != NULL) {\n+    if (accessing_klass != nullptr) {\n@@ -2423,1 +2424,1 @@\n-  if (caller == NULL) {\n+  if (caller == nullptr) {\n@@ -2474,1 +2475,1 @@\n-  if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {\n+  if (bootstrap_specifier.caller() == nullptr || bootstrap_specifier.type_arg().is_null()) {\n@@ -2483,1 +2484,1 @@\n-    assert(appendix_box->obj_at(0) == NULL, \"\");\n+    assert(appendix_box->obj_at(0) == nullptr, \"\");\n@@ -2525,1 +2526,1 @@\n-  assert(m != NULL, \"Unexpected NULL Method*\");\n+  assert(m != nullptr, \"Unexpected nullptr Method*\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":152,"deletions":151,"binary":false,"changes":303,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-\/\/ represented as NULL.\n+\/\/ represented as null.\n@@ -99,1 +99,1 @@\n-  \/\/ Loads the class if needed. If not found NULL is returned.\n+  \/\/ Loads the class if needed. If not found null is returned.\n@@ -149,1 +149,1 @@\n-  \/\/ Lookup an already loaded class. If not found NULL is returned.\n+  \/\/ Lookup an already loaded class. If not found null is returned.\n@@ -155,1 +155,1 @@\n-  \/\/ If not found NULL is returned.\n+  \/\/ If not found null is returned.\n@@ -165,1 +165,1 @@\n-  \/\/ Return NULL if the class is not found.\n+  \/\/ Return null if the class is not found.\n@@ -283,1 +283,1 @@\n-                                   Symbol* message, Symbol* cause = NULL, Symbol* cause_msg = NULL);\n+                                   Symbol* message, Symbol* cause = nullptr, Symbol* cause_msg = nullptr);\n@@ -364,1 +364,1 @@\n-  static bool is_boot_class_loader(oop class_loader) { return class_loader == NULL; }\n+  static bool is_boot_class_loader(oop class_loader) { return class_loader == nullptr; }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -272,1 +272,1 @@\n-        if (name() != NULL) {\n+        if (name() != nullptr) {\n@@ -275,1 +275,1 @@\n-          st->print_cr(\"NULL\");\n+          st->print_cr(\"null\");\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;\n+static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = nullptr;\n@@ -79,1 +79,1 @@\n-  if (_verify_byte_codes_fn != NULL)\n+  if (_verify_byte_codes_fn != nullptr)\n@@ -84,1 +84,1 @@\n-  if (_verify_byte_codes_fn != NULL)\n+  if (_verify_byte_codes_fn != nullptr)\n@@ -91,1 +91,1 @@\n-    return NULL; \/\/ Caller will throw VerifyError\n+    return nullptr; \/\/ Caller will throw VerifyError\n@@ -94,2 +94,2 @@\n-  if (lib_handle == NULL)\n-    return NULL; \/\/ Caller will throw VerifyError\n+  if (lib_handle == nullptr)\n+    return nullptr; \/\/ Caller will throw VerifyError\n@@ -98,2 +98,2 @@\n-  if (fn == NULL)\n-    return NULL; \/\/ Caller will throw VerifyError\n+  if (fn == nullptr)\n+    return nullptr; \/\/ Caller will throw VerifyError\n@@ -108,1 +108,1 @@\n-  return (class_loader == NULL || !should_verify_class) ?\n+  return (class_loader == nullptr || !should_verify_class) ?\n@@ -123,1 +123,1 @@\n-  assert(verify_class != NULL, \"Unexpected null verify_class\");\n+  assert(verify_class != nullptr, \"Unexpected null verify_class\");\n@@ -126,1 +126,1 @@\n-  const char* source_file = (s != NULL ? s->as_C_string() : NULL);\n+  const char* source_file = (s != nullptr ? s->as_C_string() : nullptr);\n@@ -130,1 +130,1 @@\n-  if (source_file != NULL) {\n+  if (source_file != nullptr) {\n@@ -139,1 +139,1 @@\n-  if (pending_exception != NULL) {\n+  if (pending_exception != nullptr) {\n@@ -142,1 +142,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -150,1 +150,1 @@\n-  } else if (exception_name != NULL) {\n+  } else if (exception_name != nullptr) {\n@@ -169,1 +169,1 @@\n-  if (klass->java_mirror() != NULL) {\n+  if (klass->java_mirror() != nullptr) {\n@@ -190,1 +190,1 @@\n-  Symbol* exception_name = NULL;\n+  Symbol* exception_name = nullptr;\n@@ -192,2 +192,2 @@\n-  char* message_buffer = NULL;\n-  char* exception_message = NULL;\n+  char* message_buffer = nullptr;\n+  char* exception_message = nullptr;\n@@ -220,1 +220,1 @@\n-    if (exception_name != NULL) {\n+    if (exception_name != nullptr) {\n@@ -243,1 +243,1 @@\n-  } else if (exception_name == NULL) {\n+  } else if (exception_name == nullptr) {\n@@ -252,1 +252,1 @@\n-    while (kls != NULL) {\n+    while (kls != nullptr) {\n@@ -262,1 +262,1 @@\n-    if (message_buffer != NULL) {\n+    if (message_buffer != nullptr) {\n@@ -265,1 +265,1 @@\n-    assert(exception_message != NULL, \"\");\n+    assert(exception_message != nullptr, \"\");\n@@ -274,1 +274,1 @@\n-  bool is_reflect = refl_magic_klass != NULL && klass->is_subtype_of(refl_magic_klass);\n+  bool is_reflect = refl_magic_klass != nullptr && klass->is_subtype_of(refl_magic_klass);\n@@ -309,1 +309,1 @@\n-  if (verify_func == NULL) {\n+  if (verify_func == nullptr) {\n@@ -337,1 +337,1 @@\n-    return NULL; \/\/ verified.\n+    return nullptr; \/\/ verified.\n@@ -339,1 +339,1 @@\n-    THROW_MSG_(vmSymbols::java_lang_OutOfMemoryError(), message, NULL);\n+    THROW_MSG_(vmSymbols::java_lang_OutOfMemoryError(), message, nullptr);\n@@ -344,1 +344,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -352,1 +352,1 @@\n-  assert(frame != NULL, \"Must have a frame\");\n+  assert(frame != nullptr, \"Must have a frame\");\n@@ -357,1 +357,1 @@\n-  assert(frame != NULL, \"Must have a frame\");\n+  assert(frame != nullptr, \"Must have a frame\");\n@@ -362,1 +362,1 @@\n-  assert(frame != NULL, \"Must have a frame\");\n+  assert(frame != nullptr, \"Must have a frame\");\n@@ -367,1 +367,1 @@\n-  assert(frame != NULL, \"Must have a frame\");\n+  assert(frame != nullptr, \"Must have a frame\");\n@@ -372,1 +372,1 @@\n-  return TypeOrigin(BAD_INDEX, index, NULL, VerificationType::bogus_type());\n+  return TypeOrigin(BAD_INDEX, index, nullptr, VerificationType::bogus_type());\n@@ -375,1 +375,1 @@\n-  return TypeOrigin(CONST_POOL, index, NULL, vt);\n+  return TypeOrigin(CONST_POOL, index, nullptr, vt);\n@@ -378,1 +378,1 @@\n-  return TypeOrigin(SIG, 0, NULL, vt);\n+  return TypeOrigin(SIG, 0, nullptr, vt);\n@@ -381,1 +381,1 @@\n-  return TypeOrigin(IMPLICIT, 0, NULL, t);\n+  return TypeOrigin(IMPLICIT, 0, nullptr, t);\n@@ -389,1 +389,1 @@\n-  if (_frame != NULL) {\n+  if (_frame != nullptr) {\n@@ -426,1 +426,1 @@\n-  if (_frame != NULL) {\n+  if (_frame != nullptr) {\n@@ -518,1 +518,1 @@\n-  if (_bci != -1 && method != NULL) {\n+  if (_bci != -1 && method != nullptr) {\n@@ -540,1 +540,1 @@\n-  if (_type.is_valid() && _type.frame() != NULL) {\n+  if (_type.is_valid() && _type.frame() != nullptr) {\n@@ -545,1 +545,1 @@\n-  if (_expected.is_valid() && _expected.frame() != NULL) {\n+  if (_expected.is_valid() && _expected.frame() != nullptr) {\n@@ -553,1 +553,1 @@\n-  if (method != NULL) {\n+  if (method != nullptr) {\n@@ -562,1 +562,1 @@\n-  if (method != NULL) {\n+  if (method != nullptr) {\n@@ -577,1 +577,1 @@\n-  if (method != NULL && method->has_stackmap_table()) {\n+  if (method != nullptr && method->has_stackmap_table()) {\n@@ -612,2 +612,2 @@\n-    : _thread(current), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),\n-      _message(NULL), _klass(klass) {\n+    : _thread(current), _previous_symbol(nullptr), _symbols(nullptr), _exception_type(nullptr),\n+      _message(nullptr), _klass(klass) {\n@@ -619,1 +619,1 @@\n-  if (_symbols != NULL) {\n+  if (_symbols != nullptr) {\n@@ -1896,1 +1896,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2078,1 +2078,1 @@\n-  guarantee(cp->cache() == NULL, \"not rewritten yet\");\n+  guarantee(cp->cache() == nullptr, \"not rewritten yet\");\n@@ -2117,1 +2117,1 @@\n-  Exceptions::debug_check_abort(exception_name, NULL);\n+  Exceptions::debug_check_abort(exception_name, nullptr);\n@@ -2148,1 +2148,1 @@\n-  if (kls != NULL) {\n+  if (kls != nullptr) {\n@@ -2172,1 +2172,1 @@\n-    if (m != NULL && m->is_protected()) {\n+    if (m != nullptr && m->is_protected()) {\n@@ -2179,1 +2179,1 @@\n-    if (member_klass != NULL && fd.is_protected()) {\n+    if (member_klass != nullptr && fd.is_protected()) {\n@@ -2335,1 +2335,1 @@\n-  NOT_PRODUCT(aligned_bcp = NULL);  \/\/ no longer valid at this point\n+  NOT_PRODUCT(aligned_bcp = nullptr);  \/\/ no longer valid at this point\n@@ -2341,1 +2341,1 @@\n-  while (super != NULL) {\n+  while (super != nullptr) {\n@@ -2790,1 +2790,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -2827,1 +2827,1 @@\n-  if (local_interfaces != NULL) {\n+  if (local_interfaces != nullptr) {\n@@ -2830,1 +2830,1 @@\n-      assert (k != NULL && k->is_interface(), \"invalid interface\");\n+      assert (k != nullptr && k->is_interface(), \"invalid interface\");\n@@ -2895,1 +2895,1 @@\n-  if (mth_sig_verif_types_ptr != NULL) {\n+  if (mth_sig_verif_types_ptr != nullptr) {\n@@ -2898,1 +2898,1 @@\n-    assert(mth_sig_verif_types != NULL, \"Unexpected NULL sig_as_verification_types value\");\n+    assert(mth_sig_verif_types != nullptr, \"Unexpected null sig_as_verification_types value\");\n@@ -2974,1 +2974,1 @@\n-  assert(sig_verif_types != NULL, \"Missing signature's array of verification types\");\n+  assert(sig_verif_types != nullptr, \"Missing signature's array of verification types\");\n@@ -2998,1 +2998,1 @@\n-          assert(cp->cache() == NULL, \"not rewritten yet\");\n+          assert(cp->cache() == nullptr, \"not rewritten yet\");\n@@ -3064,1 +3064,1 @@\n-    NULL, NULL, NULL, NULL, \"[Z\", \"[C\", \"[F\", \"[D\", \"[B\", \"[S\", \"[I\", \"[J\",\n+    nullptr, nullptr, nullptr, nullptr, \"[Z\", \"[C\", \"[F\", \"[D\", \"[B\", \"[S\", \"[I\", \"[J\",\n@@ -3222,1 +3222,1 @@\n-  if (_previous_symbol != NULL && _previous_symbol->equals(name, length)) {\n+  if (_previous_symbol != nullptr && _previous_symbol->equals(name, length)) {\n@@ -3227,2 +3227,2 @@\n-    if (_symbols == NULL) {\n-      _symbols = new GrowableArray<Symbol*>(50, 0, NULL);\n+    if (_symbols == nullptr) {\n+      _symbols = new GrowableArray<Symbol*>(50, 0, nullptr);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":68,"deletions":68,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-  TypeOrigin() : _origin(NONE), _index(0), _frame(NULL) {}\n+  TypeOrigin() : _origin(NONE), _index(0), _frame(nullptr) {}\n@@ -429,1 +429,1 @@\n-  bool has_error() const { return result() != NULL; }\n+  bool has_error() const { return result() != nullptr; }\n@@ -473,2 +473,2 @@\n-      if (_symbols == NULL) {\n-        _symbols = new GrowableArray<Symbol*>(50, 0, NULL);\n+      if (_symbols == nullptr) {\n+        _symbols = new GrowableArray<Symbol*>(50, 0, nullptr);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,0 +224,1 @@\n+    case vmIntrinsics::_vectorizedHashCode:\n@@ -538,0 +539,3 @@\n+  case vmIntrinsics::_vectorizedHashCode:\n+    if (!UseVectorizedHashCodeIntrinsic) return true;\n+    break;\n@@ -627,1 +631,1 @@\n-  if (nt[as_int(_none)] == NULL) {\n+  if (nt[as_int(_none)] == nullptr) {\n@@ -639,1 +643,1 @@\n-  if (nt[as_int(_none)] == NULL) {\n+  if (nt[as_int(_none)] == nullptr) {\n@@ -662,1 +666,1 @@\n-    for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != NULL; ++iter) {\n+    for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != nullptr; ++iter) {\n@@ -671,1 +675,1 @@\n-    for (ControlIntrinsicIter iter(DisableIntrinsic, true\/*disable_all*\/); *iter != NULL; ++iter) {\n+    for (ControlIntrinsicIter iter(DisableIntrinsic, true\/*disable_all*\/); *iter != nullptr; ++iter) {\n@@ -775,1 +779,1 @@\n-  if (kptr != NULL)  kname = kptr + 1;\n+  if (kptr != nullptr)  kname = kptr + 1;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,0 +359,4 @@\n+  do_intrinsic(_vectorizedHashCode,       jdk_internal_util_ArraysSupport, vectorizedHashCode_name,  vectorizedHashCode_signature, F_S)   \\\n+   do_name(     vectorizedHashCode_name,                         \"vectorizedHashCode\")                                  \\\n+   do_signature(vectorizedHashCode_signature,                    \"(Ljava\/lang\/Object;IIII)I\")                           \\\n+                                                                                                                        \\\n@@ -1226,0 +1230,10 @@\n+  do_intrinsic(_IndexPartiallyInUpperRange, jdk_internal_vm_vector_VectorSupport, index_partially_in_upper_range_name, index_partially_in_upper_range_sig, F_S)\\\n+    do_signature(index_partially_in_upper_range_sig, \"(Ljava\/lang\/Class;\"                                                                                      \\\n+                                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                                     \"I\"                                                                                                       \\\n+                                                     \"J\"                                                                                                       \\\n+                                                     \"J\"                                                                                                       \\\n+                                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$IndexPartiallyInUpperRangeOperation;)\"                             \\\n+                                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\")                                                      \\\n+    do_name(index_partially_in_upper_range_name, \"indexPartiallyInUpperRange\")                                                                                 \\\n+                                                                                                                               \\\n@@ -1334,1 +1348,1 @@\n-  LAST_COMPILER_INLINE = _IndexVector,\n+  LAST_COMPILER_INLINE = _IndexPartiallyInUpperRange,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -525,0 +525,2 @@\n+  template(jvmti_VTMS_transition_disable_count_name,  \"jvmti_VTMS_transition_disable_count\")      \\\n+  template(jvmti_is_in_VTMS_transition_name,          \"jvmti_is_in_VTMS_transition\")              \\\n@@ -885,1 +887,1 @@\n-    assert(_type_signatures[t] != NULL, \"domain check\");\n+    assert(_type_signatures[t] != nullptr, \"domain check\");\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-  : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, NULL, false \/* caller_must_gc_arguments *\/)\n+  : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, nullptr, false \/* caller_must_gc_arguments *\/)\n@@ -165,1 +165,1 @@\n-  assert(blob != NULL, \"caller must check for NULL\");\n+  assert(blob != nullptr, \"caller must check for nullptr\");\n@@ -178,1 +178,1 @@\n-  _oop_maps = NULL;\n+  _oop_maps = nullptr;\n@@ -186,1 +186,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -189,1 +189,1 @@\n-    _oop_maps = NULL;\n+    _oop_maps = nullptr;\n@@ -198,1 +198,1 @@\n-  if (stub != NULL && (PrintStubCode ||\n+  if (stub != nullptr && (PrintStubCode ||\n@@ -210,1 +210,1 @@\n-      if ((stub->oop_maps() != NULL) && AbstractDisassembler::show_structs()) {\n+      if ((stub->oop_maps() != nullptr) && AbstractDisassembler::show_structs()) {\n@@ -233,1 +233,1 @@\n-  assert(_oop_maps != NULL, \"nope\");\n+  assert(_oop_maps != nullptr, \"nope\");\n@@ -253,1 +253,1 @@\n-  BufferBlob* blob = NULL;\n+  BufferBlob* blob = nullptr;\n@@ -258,1 +258,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -271,1 +271,1 @@\n-  : RuntimeBlob(name, cb, header_size, size, CodeOffsets::frame_never_safe, 0, NULL)\n+  : RuntimeBlob(name, cb, header_size, size, CodeOffsets::frame_never_safe, 0, nullptr)\n@@ -277,1 +277,1 @@\n-  BufferBlob* blob = NULL;\n+  BufferBlob* blob = nullptr;\n@@ -279,1 +279,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -316,1 +316,1 @@\n-  AdapterBlob* blob = NULL;\n+  AdapterBlob* blob = nullptr;\n@@ -345,1 +345,1 @@\n-  VtableBlob* blob = NULL;\n+  VtableBlob* blob = nullptr;\n@@ -350,1 +350,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -363,1 +363,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -380,1 +380,1 @@\n-  MethodHandlesAdapterBlob* blob = NULL;\n+  MethodHandlesAdapterBlob* blob = nullptr;\n@@ -388,1 +388,1 @@\n-    if (blob == NULL) {\n+    if (blob == nullptr) {\n@@ -411,1 +411,1 @@\n-  BufferedInlineTypeBlob* blob = NULL;\n+  BufferedInlineTypeBlob* blob = nullptr;\n@@ -446,1 +446,1 @@\n-  RuntimeStub* stub = NULL;\n+  RuntimeStub* stub = nullptr;\n@@ -505,1 +505,1 @@\n-  DeoptimizationBlob* blob = NULL;\n+  DeoptimizationBlob* blob = nullptr;\n@@ -544,1 +544,1 @@\n-  UncommonTrapBlob* blob = NULL;\n+  UncommonTrapBlob* blob = nullptr;\n@@ -580,1 +580,1 @@\n-  ExceptionBlob* blob = NULL;\n+  ExceptionBlob* blob = nullptr;\n@@ -615,1 +615,1 @@\n-  SafepointBlob* blob = NULL;\n+  SafepointBlob* blob = nullptr;\n@@ -647,1 +647,1 @@\n-    if (i != NULL) {\n+    if (i != nullptr) {\n@@ -664,1 +664,1 @@\n-    if (d != NULL) {\n+    if (d != nullptr) {\n@@ -680,1 +680,1 @@\n-    if (v != NULL) {\n+    if (v != nullptr) {\n@@ -807,1 +807,1 @@\n-  assert(blob != nullptr, \"caller must check for NULL\");\n+  assert(blob != nullptr, \"caller must check for nullptr\");\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,1 @@\n-  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }\n+  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : nullptr; }\n@@ -171,1 +171,1 @@\n-  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }\n+  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : nullptr; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -72,1 +73,1 @@\n-  assert(cb != NULL && cb->is_compiled(), \"must be compiled\");\n+  assert(cb != nullptr && cb->is_compiled(), \"must be compiled\");\n@@ -88,1 +89,1 @@\n-    assert(data != NULL || Universe::non_oop_word() == NULL,\n+    assert(data != nullptr || Universe::non_oop_word() == nullptr,\n@@ -90,1 +91,1 @@\n-    return (data == (void*)Universe::non_oop_word()) ? NULL : data;\n+    return (data == (void*)Universe::non_oop_word()) ? nullptr : data;\n@@ -98,1 +99,1 @@\n-  assert(entry_point != NULL, \"must set legal entry point\");\n+  assert(entry_point != nullptr, \"must set legal entry point\");\n@@ -100,2 +101,2 @@\n-  assert (!is_optimized() || cache == NULL, \"an optimized virtual call does not have a cached metadata\");\n-  assert (cache == NULL || cache != (Metadata*)badOopVal, \"invalid metadata\");\n+  assert (!is_optimized() || cache == nullptr, \"an optimized virtual call does not have a cached metadata\");\n+  assert (cache == nullptr || cache != (Metadata*)badOopVal, \"invalid metadata\");\n@@ -132,1 +133,1 @@\n-    assert(cb != NULL && cb->is_compiled(), \"must be compiled\");\n+    assert(cb != nullptr && cb->is_compiled(), \"must be compiled\");\n@@ -140,1 +141,1 @@\n-    assert(cache == NULL, \"must be null\");\n+    assert(cache == nullptr, \"must be null\");\n@@ -144,1 +145,1 @@\n-  if (cache == NULL)  cache = Universe::non_oop_word();\n+  if (cache == nullptr)  cache = Universe::non_oop_word();\n@@ -151,1 +152,1 @@\n-  internal_set_ic_destination(stub->code_begin(), true, NULL, false);\n+  internal_set_ic_destination(stub->code_begin(), true, nullptr, false);\n@@ -205,1 +206,1 @@\n-    _value = NULL;\n+    _value = nullptr;\n@@ -215,2 +216,2 @@\n-  assert(ic_call != NULL, \"ic_call address must be set\");\n-  assert(cm != NULL, \"must pass compiled method\");\n+  assert(ic_call != nullptr, \"ic_call address must be set\");\n+  assert(cm != nullptr, \"must pass compiled method\");\n@@ -235,2 +236,2 @@\n-  assert(ic_call != NULL, \"ic_call address must be set\");\n-  assert(nm != NULL, \"must pass compiled method\");\n+  assert(ic_call != nullptr, \"ic_call address must be set\");\n+  assert(nm != nullptr, \"must pass compiled method\");\n@@ -258,1 +259,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -275,0 +276,3 @@\n+    \/\/ LSan appears unable to follow malloc-based memory consistently when embedded as an immediate\n+    \/\/ in generated machine code. So we have to ignore it.\n+    LSAN_IGNORE_OBJECT(holder);\n@@ -281,1 +285,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -284,1 +288,1 @@\n-    if (!InlineCacheBuffer::create_transition_stub(this, NULL, entry)) {\n+    if (!InlineCacheBuffer::create_transition_stub(this, nullptr, entry)) {\n@@ -292,1 +296,1 @@\n-    assert(call_info->selected_method() != NULL, \"Unexpected null selected method\");\n+    assert(call_info->selected_method() != nullptr, \"Unexpected null selected method\");\n@@ -314,1 +318,1 @@\n-  return VtableStubs::entry_point(ic_destination()) != NULL;\n+  return VtableStubs::entry_point(ic_destination()) != nullptr;\n@@ -321,1 +325,1 @@\n-  bool is_monomorphic = (cb != NULL && cb->is_compiled());\n+  bool is_monomorphic = (cb != nullptr && cb->is_compiled());\n@@ -324,1 +328,1 @@\n-  \/\/ for calling directly to vep without using the inline cache (i.e., cached_value == NULL).\n+  \/\/ for calling directly to vep without using the inline cache (i.e., cached_value == nullptr).\n@@ -333,1 +337,1 @@\n-         (cached_metadata() != NULL && cached_metadata()->is_klass()), \"sanity check\");\n+         (cached_metadata() != nullptr && cached_metadata()->is_klass()), \"sanity check\");\n@@ -346,2 +350,2 @@\n-    is_call_to_interpreted = (cb != NULL && cb->is_adapter_blob());\n-    assert(!is_call_to_interpreted || (is_icholder_call() && cached_icholder() != NULL), \"sanity check\");\n+    is_call_to_interpreted = (cb != nullptr && cb->is_adapter_blob());\n+    assert(!is_call_to_interpreted || (is_icholder_call() && cached_icholder() != nullptr), \"sanity check\");\n@@ -378,1 +382,1 @@\n-      set_ic_destination_and_value(entry, (void*)NULL);\n+      set_ic_destination_and_value(entry, (void*)nullptr);\n@@ -382,1 +386,1 @@\n-    if (!InlineCacheBuffer::create_transition_stub(this, NULL, entry)) {\n+    if (!InlineCacheBuffer::create_transition_stub(this, nullptr, entry)) {\n@@ -401,1 +405,1 @@\n-  assert(!is_clean || is_optimized() || cached_value() == NULL, \"sanity check\");\n+  assert(!is_clean || is_optimized() || cached_value() == nullptr, \"sanity check\");\n@@ -428,1 +432,1 @@\n-      assert(info.cached_metadata() != NULL && info.cached_metadata()->is_method(), \"sanity check\");\n+      assert(info.cached_metadata() != nullptr && info.cached_metadata()->is_method(), \"sanity check\");\n@@ -445,0 +449,3 @@\n+      \/\/ LSan appears unable to follow malloc-based memory consistently when embedded as an\n+      \/\/ immediate in generated machine code. So we have to ignore it.\n+      LSAN_IGNORE_OBJECT(holder);\n@@ -452,1 +459,1 @@\n-    bool static_bound = info.is_optimized() || (info.cached_metadata() == NULL);\n+    bool static_bound = info.is_optimized() || (info.cached_metadata() == nullptr);\n@@ -455,1 +462,1 @@\n-    assert (cb != NULL && cb->is_compiled(), \"must be compiled!\");\n+    assert (cb != nullptr && cb->is_compiled(), \"must be compiled!\");\n@@ -477,1 +484,1 @@\n-      assert(info.cached_metadata() == NULL || info.cached_metadata()->is_klass(), \"must be\");\n+      assert(info.cached_metadata() == nullptr || info.cached_metadata()->is_klass(), \"must be\");\n@@ -480,1 +487,1 @@\n-        (info.cached_metadata() != NULL) ? ((Klass*)info.cached_metadata())->print_value_string() : \"NULL\",\n+        (info.cached_metadata() != nullptr) ? ((Klass*)info.cached_metadata())->print_value_string() : \"nullptr\",\n@@ -510,2 +517,2 @@\n-  address entry = NULL;\n-  if (method_code != NULL && method_code->is_in_use() && !method_code->is_unloading()) {\n+  address entry = nullptr;\n+  if (method_code != nullptr && method_code->is_in_use() && !method_code->is_unloading()) {\n@@ -536,1 +543,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -538,1 +545,1 @@\n-    info.set_compiled_entry(entry, is_optimized ? NULL : receiver_klass, is_optimized);\n+    info.set_compiled_entry(entry, is_optimized ? nullptr : receiver_klass, is_optimized);\n@@ -546,1 +553,1 @@\n-      assert(method_code == NULL || method_code->is_compiled(), \"must be compiled\");\n+      assert(method_code == nullptr || method_code->is_compiled(), \"must be compiled\");\n@@ -558,1 +565,1 @@\n-  if (cb != NULL && cb->is_adapter_blob()) {\n+  if (cb != nullptr && cb->is_adapter_blob()) {\n@@ -562,1 +569,1 @@\n-  if (cb != NULL && cb->is_vtable_blob()) {\n+  if (cb != nullptr && cb->is_vtable_blob()) {\n@@ -564,1 +571,1 @@\n-    return (s != NULL) && s->is_itable_stub();\n+    return (s != nullptr) && s->is_itable_stub();\n@@ -641,1 +648,1 @@\n-  if (m_code != NULL && m_code->is_in_use() && !m_code->is_unloading()) {\n+  if (m_code != nullptr && m_code->is_in_use() && !m_code->is_unloading()) {\n@@ -672,1 +679,1 @@\n-  RelocIterator iter((nmethod*)NULL, instruction);\n+  RelocIterator iter((nmethod*)nullptr, instruction);\n@@ -689,1 +696,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -717,1 +724,1 @@\n-             p2i(instruction_address()), is_call_to_interpreted() ? \"interpreted \" : \"\", p2i(ic_destination()), p2i(is_optimized() ? NULL : cached_value()));\n+             p2i(instruction_address()), is_call_to_interpreted() ? \"interpreted \" : \"\", p2i(ic_destination()), p2i(is_optimized() ? nullptr : cached_value()));\n@@ -740,1 +747,1 @@\n-  assert(old_method == NULL || old_method == callee() ||\n+  assert(old_method == nullptr || old_method == callee() ||\n@@ -748,1 +755,1 @@\n-         || old_method == NULL || !old_method->method_holder()->is_loader_alive() \/\/ may have a race due to class unloading.\n+         || old_method == nullptr || !old_method->method_holder()->is_loader_alive() \/\/ may have a race due to class unloading.\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":55,"deletions":48,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-    assert(_cached_value != NULL, \"must be non-NULL\");\n+    assert(_cached_value != nullptr, \"must be non-nullptr\");\n@@ -129,1 +129,1 @@\n-  CompiledICInfo(): _entry(NULL), _cached_value(NULL), _is_icholder(false),\n+  CompiledICInfo(): _entry(nullptr), _cached_value(nullptr), _is_icholder(false),\n@@ -189,1 +189,1 @@\n-    internal_set_ic_destination(entry_point, false, NULL, false);\n+    internal_set_ic_destination(entry_point, false, nullptr, false);\n@@ -341,1 +341,1 @@\n-  static address emit_to_interp_stub(CodeBuffer &cbuf, address mark = NULL);\n+  static address emit_to_interp_stub(CodeBuffer &cbuf, address mark = nullptr);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    _gc_data(NULL)\n+    _gc_data(nullptr)\n@@ -71,1 +71,1 @@\n-    _gc_data(NULL)\n+    _gc_data(nullptr)\n@@ -78,4 +78,4 @@\n-    _scopes_data_begin          = NULL;\n-    _deopt_handler_begin        = NULL;\n-    _deopt_mh_handler_begin     = NULL;\n-    _exception_cache            = NULL;\n+    _scopes_data_begin          = nullptr;\n+    _deopt_handler_begin        = nullptr;\n+    _deopt_mh_handler_begin     = nullptr;\n+    _exception_cache            = nullptr;\n@@ -92,1 +92,1 @@\n-  if (pd == NULL)\n+  if (pd == nullptr)\n@@ -111,1 +111,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -118,1 +118,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock,\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n@@ -133,2 +133,2 @@\n-  assert(new_entry != NULL,\"Must be non null\");\n-  assert(new_entry->next() == NULL, \"Must be null\");\n+  assert(new_entry != nullptr,\"Must be non null\");\n+  assert(new_entry->next() == nullptr, \"Must be null\");\n@@ -138,1 +138,1 @@\n-    if (ec != NULL) {\n+    if (ec != nullptr) {\n@@ -154,1 +154,1 @@\n-      if (ec != NULL) {\n+      if (ec != nullptr) {\n@@ -180,1 +180,1 @@\n-  ExceptionCache* prev = NULL;\n+  ExceptionCache* prev = nullptr;\n@@ -183,1 +183,1 @@\n-  while (curr != NULL) {\n+  while (curr != nullptr) {\n@@ -187,1 +187,1 @@\n-      if (prev == NULL) {\n+      if (prev == nullptr) {\n@@ -192,1 +192,1 @@\n-          prev = NULL;\n+          prev = nullptr;\n@@ -220,1 +220,1 @@\n-  while (ec != NULL) {\n+  while (ec != nullptr) {\n@@ -222,1 +222,1 @@\n-    if ((ret_val = ec->match(exception,pc)) != NULL) {\n+    if ((ret_val = ec->match(exception,pc)) != nullptr) {\n@@ -227,1 +227,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -240,1 +240,1 @@\n-  if (target_entry == NULL || !target_entry->add_address_and_handler(pc,handler)) {\n+  if (target_entry == nullptr || !target_entry->add_address_and_handler(pc,handler)) {\n@@ -251,1 +251,1 @@\n-  while (ec != NULL) {\n+  while (ec != nullptr) {\n@@ -257,1 +257,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -284,1 +284,1 @@\n-  RelocIterator iter(this, NULL, NULL);\n+  RelocIterator iter(this, nullptr, nullptr);\n@@ -298,1 +298,1 @@\n-  guarantee(pd != NULL, \"scope must be present\");\n+  guarantee(pd != nullptr, \"scope must be present\");\n@@ -304,1 +304,1 @@\n-  guarantee(pd != NULL, \"scope must be present\");\n+  guarantee(pd != nullptr, \"scope must be present\");\n@@ -325,1 +325,1 @@\n-  \/\/ assert(BarrierSet::barrier_set()->barrier_set_nmethod() == NULL, \"Not safe oop scan\");\n+  \/\/ assert(BarrierSet::barrier_set()->barrier_set_nmethod() == nullptr, \"Not safe oop scan\");\n@@ -351,1 +351,1 @@\n-        assert(ic->cached_icholder() != NULL, \"must be non-NULL\");\n+        assert(ic->cached_icholder() != nullptr, \"must be non-nullptr\");\n@@ -363,1 +363,1 @@\n-  if (method() == NULL) {\n+  if (method() == nullptr) {\n@@ -381,1 +381,1 @@\n-    if (callee != NULL) {\n+    if (callee != nullptr) {\n@@ -426,1 +426,1 @@\n-  return NULL; \/\/ not found\n+  return nullptr; \/\/ not found\n@@ -434,1 +434,1 @@\n-  return NULL; \/\/ not a call\n+  return nullptr; \/\/ not a call\n@@ -463,1 +463,1 @@\n-    Klass* klass = NULL;\n+    Klass* klass = nullptr;\n@@ -494,1 +494,1 @@\n-    if (ic_metdata != NULL) {\n+    if (ic_metdata != nullptr) {\n@@ -523,2 +523,2 @@\n-  CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n-  if (nm != NULL) {\n+  CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+  if (nm != nullptr) {\n@@ -575,1 +575,1 @@\n-  if (bs_nm != NULL) {\n+  if (bs_nm != nullptr) {\n@@ -581,1 +581,1 @@\n-    if (nm != NULL && bs_nm->is_armed(nm)) {\n+    if (nm != nullptr && bs_nm->is_armed(nm)) {\n@@ -669,1 +669,1 @@\n-      if (md != NULL && md->is_method()) {\n+      if (md != nullptr && md->is_method()) {\n@@ -672,1 +672,1 @@\n-          Atomic::store(r->metadata_addr(), (Method*)NULL);\n+          Atomic::store(r->metadata_addr(), (Method*)nullptr);\n@@ -700,1 +700,1 @@\n-    assert(cb != NULL && cb == this, \"\");\n+    assert(cb != nullptr && cb == this, \"\");\n@@ -711,1 +711,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  PcDescCache() { debug_only(_pc_descs[0] = NULL); }\n+  PcDescCache() { debug_only(_pc_descs[0] = nullptr); }\n@@ -133,1 +133,1 @@\n-    if (desc != NULL && desc->pc_offset() == pc - base_address) {\n+    if (desc != nullptr && desc->pc_offset() == pc - base_address) {\n@@ -237,2 +237,2 @@\n-  bool is_native_method() const { return _method != NULL && _method->is_native(); }\n-  bool is_java_method() const { return _method != NULL && !_method->is_native(); }\n+  bool is_native_method() const { return _method != nullptr && _method->is_native(); }\n+  bool is_java_method() const { return _method != nullptr && !_method->is_native(); }\n@@ -297,0 +297,2 @@\n+  virtual int skipped_instructions_size() const = 0;\n+\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -71,1 +71,1 @@\n-  assert(_obj_pool != NULL, \"object pool does not exist\");\n+  assert(_obj_pool != nullptr, \"object pool does not exist\");\n@@ -85,1 +85,1 @@\n-  assert(_obj_pool != NULL, \"object pool does not exist\");\n+  assert(_obj_pool != nullptr, \"object pool does not exist\");\n@@ -93,1 +93,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -104,1 +104,1 @@\n-  ScopeValue* result = NULL;\n+  ScopeValue* result = nullptr;\n@@ -253,1 +253,1 @@\n-    assert(JNIHandles::resolve(value()) == NULL ||\n+    assert(JNIHandles::resolve(value()) == nullptr ||\n@@ -274,1 +274,1 @@\n-  assert(_value() == NULL ||\n+  assert(_value() == nullptr ||\n@@ -283,1 +283,1 @@\n-  if (value()() != NULL) {\n+  if (value()() != nullptr) {\n@@ -286,1 +286,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"nullptr\");\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = NULL)\n+  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = nullptr)\n@@ -143,2 +143,2 @@\n-     , _klass(NULL)\n-     , _is_init(NULL)\n+     , _klass(nullptr)\n+     , _is_init(nullptr)\n@@ -309,1 +309,1 @@\n-  DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray<ScopeValue*>* obj_pool = NULL) :\n+  DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray<ScopeValue*>* obj_pool = nullptr) :\n@@ -320,1 +320,1 @@\n-    assert(o == NULL || o->is_metadata(), \"meta data only\");\n+    assert(o == nullptr || o->is_metadata(), \"meta data only\");\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -140,1 +140,1 @@\n-  _next_chunk = _next_chunk_limit = NULL;\n+  _next_chunk = _next_chunk_limit = nullptr;\n@@ -199,1 +199,1 @@\n-  if (monitors == NULL || monitors->is_empty()) return DebugInformationRecorder::serialized_null;\n+  if (monitors == nullptr || monitors->is_empty()) return DebugInformationRecorder::serialized_null;\n@@ -220,1 +220,1 @@\n-  if (values == NULL || values->is_empty()) return DebugInformationRecorder::serialized_null;\n+  if (values == nullptr || values->is_empty()) return DebugInformationRecorder::serialized_null;\n@@ -320,1 +320,1 @@\n-  if (method != NULL) {\n+  if (method != nullptr) {\n@@ -325,1 +325,1 @@\n-    method_enc = NULL;\n+    method_enc = nullptr;\n@@ -330,1 +330,1 @@\n-  assert(method == NULL ||\n+  assert(method == nullptr ||\n@@ -357,1 +357,1 @@\n-  if (objects != NULL) {\n+  if (objects != nullptr) {\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,3 +113,3 @@\n-                      DebugToken* locals      = NULL,\n-                      DebugToken* expressions = NULL,\n-                      DebugToken* monitors    = NULL);\n+                      DebugToken* locals      = nullptr,\n+                      DebugToken* expressions = nullptr,\n+                      DebugToken* monitors    = nullptr);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  DEBUG_ONLY(_deps[end_marker] = NULL);\n+  DEBUG_ONLY(_deps[end_marker] = nullptr);\n@@ -74,1 +74,1 @@\n-  _content_bytes = NULL;\n+  _content_bytes = nullptr;\n@@ -142,1 +142,1 @@\n-  DEBUG_ONLY(_dep_values[end_marker] = NULL);\n+  DEBUG_ONLY(_dep_values[end_marker] = nullptr);\n@@ -146,1 +146,1 @@\n-  _content_bytes = NULL;\n+  _content_bytes = nullptr;\n@@ -484,1 +484,1 @@\n-    return NULL;  \/\/ let NULL be NULL\n+    return nullptr;  \/\/ let nullptr be nullptr\n@@ -496,1 +496,1 @@\n-    return NULL;  \/\/ let NULL be NULL\n+    return nullptr;  \/\/ let nullptr be nullptr\n@@ -633,1 +633,1 @@\n-    if (witness != NULL) {\n+    if (witness != nullptr) {\n@@ -636,1 +636,1 @@\n-        if (failure_detail != NULL && klass_violations == 0) {\n+        if (failure_detail != nullptr && klass_violations == 0) {\n@@ -646,1 +646,1 @@\n-      if (xtty == NULL) {\n+      if (xtty == nullptr) {\n@@ -660,1 +660,1 @@\n-  if (log() == NULL)  return;\n+  if (log() == nullptr)  return;\n@@ -687,1 +687,1 @@\n-  if (log == NULL) {\n+  if (log == nullptr) {\n@@ -710,1 +710,1 @@\n-  if (log == NULL) {\n+  if (log == nullptr) {\n@@ -723,1 +723,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -742,1 +742,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -753,1 +753,1 @@\n-  if (xtty == NULL) {\n+  if (xtty == nullptr) {\n@@ -760,1 +760,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -789,1 +789,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -801,1 +801,1 @@\n-                (witness == NULL)? \"Dependency\": \"Failed dependency\",\n+                (witness == nullptr)? \"Dependency\": \"Failed dependency\",\n@@ -816,1 +816,1 @@\n-      put_star = !Dependencies::is_concrete_method((Method*)arg.metadata_value(), NULL);\n+      put_star = !Dependencies::is_concrete_method((Method*)arg.metadata_value(), nullptr);\n@@ -835,1 +835,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -844,1 +844,1 @@\n-  if (_deps == NULL && xtty == NULL)  return;  \/\/ fast cutout for runtime\n+  if (_deps == nullptr && xtty == nullptr)  return;  \/\/ fast cutout for runtime\n@@ -856,2 +856,2 @@\n-  if (_deps != NULL && _deps->log() != NULL) {\n-    if (ciEnv::current() != NULL) {\n+  if (_deps != nullptr && _deps->log() != nullptr) {\n+    if (ciEnv::current() != nullptr) {\n@@ -883,1 +883,1 @@\n-    if (_code != NULL) {\n+    if (_code != nullptr) {\n@@ -900,1 +900,1 @@\n-  assert((_code!=NULL) + (_deps!=NULL) == 1, \"one or t'other\");\n+  assert((_code!=nullptr) + (_deps!=nullptr) == 1, \"one or t'other\");\n@@ -906,1 +906,1 @@\n-  if (_bytes.position() == 0 && _code != NULL\n+  if (_bytes.position() == 0 && _code != nullptr\n@@ -937,2 +937,2 @@\n-  Metadata* o = NULL;\n-  if (_code != NULL) {\n+  Metadata* o = nullptr;\n+  if (_code != nullptr) {\n@@ -947,1 +947,1 @@\n-  return (_code != NULL)\n+  return (_code != nullptr)\n@@ -955,1 +955,1 @@\n-  if (result == NULL) { \/\/ Explicit context argument can be compressed\n+  if (result == nullptr) { \/\/ Explicit context argument can be compressed\n@@ -962,1 +962,1 @@\n-  assert(result == NULL || result->is_klass() || result->is_method(), \"must be\");\n+  assert(result == nullptr || result->is_klass() || result->is_method(), \"must be\");\n@@ -991,1 +991,1 @@\n-      assert(k != NULL && k->is_klass(), \"type check\");\n+      assert(k != nullptr && k->is_klass(), \"type check\");\n@@ -1002,1 +1002,1 @@\n-      assert(k != NULL, \"type check\");\n+      assert(k != nullptr, \"type check\");\n@@ -1009,1 +1009,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1061,1 +1061,1 @@\n-      _participants[i] = NULL;\n+      _participants[i] = nullptr;\n@@ -1063,1 +1063,1 @@\n-    if (participant != NULL) {\n+    if (participant != nullptr) {\n@@ -1112,1 +1112,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1129,1 +1129,1 @@\n-  Klass* find_witness(InstanceKlass* context_type, KlassDepChange* changes = NULL);\n+  Klass* find_witness(InstanceKlass* context_type, KlassDepChange* changes = nullptr);\n@@ -1135,3 +1135,3 @@\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_calls_count = NULL;\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_steps_count = NULL;\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_in_calls_count       = NULL;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_calls_count = nullptr;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_steps_count = nullptr;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_in_calls_count       = nullptr;\n@@ -1158,1 +1158,1 @@\n-  assert(changes == NULL || changes->involves_context(context_type), \"irrelevant dependency\");\n+  assert(changes == nullptr || changes->involves_context(context_type), \"irrelevant dependency\");\n@@ -1166,1 +1166,1 @@\n-      return NULL; \/\/ no implementors\n+      return nullptr; \/\/ no implementors\n@@ -1182,1 +1182,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -1204,1 +1204,1 @@\n-  ConcreteSubtypeFinder(Klass* participant = NULL) : AbstractClassHierarchyWalker(participant) {}\n+  ConcreteSubtypeFinder(Klass* participant = nullptr) : AbstractClassHierarchyWalker(participant) {}\n@@ -1225,1 +1225,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1232,1 +1232,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1247,1 +1247,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1267,2 +1267,2 @@\n-  ConcreteMethodFinder(Method* m, Klass* participant = NULL) : AbstractClassHierarchyWalker(participant) {\n-    assert(m != NULL && m->is_method(), \"sanity\");\n+  ConcreteMethodFinder(Method* m, Klass* participant = nullptr) : AbstractClassHierarchyWalker(participant) {\n+    assert(m != nullptr && m->is_method(), \"sanity\");\n@@ -1273,1 +1273,1 @@\n-      _found_methods[i] = NULL;\n+      _found_methods[i] = nullptr;\n@@ -1277,1 +1277,1 @@\n-  \/\/ Note:  If n==num_participants, returns NULL.\n+  \/\/ Note:  If n==num_participants, returns nullptr.\n@@ -1281,2 +1281,2 @@\n-    assert(n == num_participants() || fm != NULL, \"proper usage\");\n-    if (fm != NULL && fm->method_holder() != participant(n)) {\n+    assert(n == num_participants() || fm != nullptr, \"proper usage\");\n+    if (fm != nullptr && fm->method_holder() != participant(n)) {\n@@ -1287,1 +1287,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1294,1 +1294,1 @@\n-    _found_methods[num_participants()] = NULL;\n+    _found_methods[num_participants()] = nullptr;\n@@ -1325,1 +1325,1 @@\n-      if (!ik->is_interface() && m != NULL && m->is_abstract()) {\n+      if (!ik->is_interface() && m != nullptr && m->is_abstract()) {\n@@ -1335,1 +1335,1 @@\n-        if (w != NULL) {\n+        if (w != nullptr) {\n@@ -1347,1 +1347,1 @@\n-      if (default_methods != NULL) {\n+      if (default_methods != nullptr) {\n@@ -1349,1 +1349,1 @@\n-        if (Dependencies::is_concrete_method(dm, NULL)) {\n+        if (Dependencies::is_concrete_method(dm, nullptr)) {\n@@ -1374,1 +1374,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1384,1 +1384,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -1387,1 +1387,1 @@\n-      for (InstanceKlass* super = k->java_super(); super != NULL; super = super->java_super()) {\n+      for (InstanceKlass* super = k->java_super(); super != nullptr; super = super->java_super()) {\n@@ -1389,1 +1389,1 @@\n-        if (m != NULL) { \/\/ inherited method found\n+        if (m != nullptr) { \/\/ inherited method found\n@@ -1413,1 +1413,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1455,1 +1455,1 @@\n-      _found_methods[i] = NULL;\n+      _found_methods[i] = nullptr;\n@@ -1457,1 +1457,1 @@\n-    if (participant != NULL) {\n+    if (participant != nullptr) {\n@@ -1475,1 +1475,1 @@\n-  LinkedConcreteMethodFinder(InstanceKlass* resolved_klass, Method* resolved_method, Method* uniqm = NULL) : AbstractClassHierarchyWalker(NULL) {\n+  LinkedConcreteMethodFinder(InstanceKlass* resolved_klass, Method* resolved_method, Method* uniqm = nullptr) : AbstractClassHierarchyWalker(nullptr) {\n@@ -1490,1 +1490,1 @@\n-  \/\/ Note:  If n==num_participants, returns NULL.\n+  \/\/ Note:  If n==num_participants, returns nullptr.\n@@ -1493,1 +1493,1 @@\n-    assert(participant(n) != NULL || n == num_participants(), \"proper usage\");\n+    assert(participant(n) != nullptr || n == num_participants(), \"proper usage\");\n@@ -1506,1 +1506,1 @@\n-  return NULL; \/\/ No witness found.  The dependency remains unbroken.\n+  return nullptr; \/\/ No witness found.  The dependency remains unbroken.\n@@ -1519,1 +1519,1 @@\n-  return NULL; \/\/ No witness found. The dependency remains unbroken.\n+  return nullptr; \/\/ No witness found. The dependency remains unbroken.\n@@ -1539,1 +1539,1 @@\n-  Method* selected_method = NULL;\n+  Method* selected_method = nullptr;\n@@ -1549,1 +1549,1 @@\n-  return selected_method; \/\/ NULL when corresponding slot is empty (AbstractMethodError case)\n+  return selected_method; \/\/ nullptr when corresponding slot is empty (AbstractMethodError case)\n@@ -1600,1 +1600,1 @@\n-  if (lm == NULL && ctxk->is_instance_klass()) {\n+  if (lm == nullptr && ctxk->is_instance_klass()) {\n@@ -1609,1 +1609,1 @@\n-  if (lm != NULL) {\n+  if (lm != nullptr) {\n@@ -1636,1 +1636,1 @@\n-  if (lm != NULL) {\n+  if (lm != nullptr) {\n@@ -1653,2 +1653,2 @@\n-  \/\/ NULL is not a concrete method.\n-  if (m == NULL) {\n+  \/\/ nullptr is not a concrete method.\n+  if (m == nullptr) {\n@@ -1666,1 +1666,1 @@\n-  if (m->is_overpass() && k != NULL) {\n+  if (m->is_overpass() && k != nullptr) {\n@@ -1669,1 +1669,1 @@\n-  \/\/ Note \"true\" is conservative answer: overpass clause is false if k == NULL,\n+  \/\/ Note \"true\" is conservative answer: overpass clause is false if k == nullptr,\n@@ -1681,1 +1681,1 @@\n-  return NULL; \/\/ not found\n+  return nullptr; \/\/ not found\n@@ -1709,1 +1709,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1724,1 +1724,1 @@\n-  if (sub != NULL) {\n+  if (sub != nullptr) {\n@@ -1730,1 +1730,1 @@\n-    assert(impl != NULL, \"must be set\");\n+    assert(impl != nullptr, \"must be set\");\n@@ -1733,1 +1733,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1750,1 +1750,1 @@\n-\/\/ Find the unique concrete proper subtype of ctxk, or NULL if there\n+\/\/ Find the unique concrete proper subtype of ctxk, or nullptr if there\n@@ -1754,1 +1754,1 @@\n-\/\/ That is, return CC1 for CX > CC1 > CC2, but NULL for CX > { CC1, CC2 }.\n+\/\/ That is, return CC1 for CX > CC1 > CC2, but nullptr for CX > { CC1, CC2 }.\n@@ -1759,1 +1759,1 @@\n-  if (wit != NULL)  return NULL;   \/\/ Too many witnesses.\n+  if (wit != nullptr)  return nullptr;   \/\/ Too many witnesses.\n@@ -1761,1 +1761,1 @@\n-  if (conck == NULL) {\n+  if (conck == nullptr) {\n@@ -1770,1 +1770,1 @@\n-        guarantee(NULL == (void *)\n+        guarantee(nullptr == (void *)\n@@ -1794,1 +1794,1 @@\n-  if (uniqm == NULL) {\n+  if (uniqm == nullptr) {\n@@ -1814,1 +1814,1 @@\n-\/\/ If a class (or interface) has a unique concrete method uniqm, return NULL.\n+\/\/ If a class (or interface) has a unique concrete method uniqm, return nullptr.\n@@ -1821,1 +1821,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -1824,1 +1824,1 @@\n-  if (!Dependencies::is_concrete_root_method(uniqm, ctxk) || changes != NULL) {\n+  if (!Dependencies::is_concrete_root_method(uniqm, ctxk) || changes != nullptr) {\n@@ -1826,1 +1826,1 @@\n-    if (conck != NULL) {\n+    if (conck != nullptr) {\n@@ -1831,1 +1831,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1839,1 +1839,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1850,2 +1850,2 @@\n-  if (m != NULL) {\n-    if (changes != NULL) {\n+  if (m != nullptr) {\n+    if (changes != nullptr) {\n@@ -1862,1 +1862,1 @@\n-      if (conck != NULL) {\n+      if (conck != nullptr) {\n@@ -1870,1 +1870,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1876,2 +1876,2 @@\n-  assert(base_m != NULL, \"base method should be non null\");\n-  if (sub_m == NULL) {\n+  assert(base_m != nullptr, \"base method should be non null\");\n+  if (sub_m == nullptr) {\n@@ -1899,1 +1899,1 @@\n-  \/\/ Return NULL if m is marked old; must have been a redefined method.\n+  \/\/ Return nullptr if m is marked old; must have been a redefined method.\n@@ -1901,1 +1901,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1904,1 +1904,1 @@\n-    return NULL; \/\/ not supported\n+    return nullptr; \/\/ not supported\n@@ -1910,3 +1910,3 @@\n-  if (wit != NULL)  return NULL;  \/\/ Too many witnesses.\n-  Method* fm = wf.found_method(0);  \/\/ Will be NULL if num_parts == 0.\n-  if (participant != NULL) {\n+  if (wit != nullptr)  return nullptr;  \/\/ Too many witnesses.\n+  Method* fm = wf.found_method(0);  \/\/ Will be nullptr if num_parts == 0.\n+  if (participant != nullptr) {\n@@ -1915,2 +1915,2 @@\n-  if (!Dependencies::is_concrete_method(fm, NULL)) {\n-    fm = NULL; \/\/ ignore abstract methods\n+  if (!Dependencies::is_concrete_method(fm, nullptr)) {\n+    fm = nullptr; \/\/ ignore abstract methods\n@@ -1919,1 +1919,1 @@\n-    if (fm == NULL) {\n+    if (fm == nullptr) {\n@@ -1925,1 +1925,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1927,1 +1927,1 @@\n-  } else if (Dependencies::find_witness_AME(ctxk, fm) != NULL) {\n+  } else if (Dependencies::find_witness_AME(ctxk, fm) != nullptr) {\n@@ -1929,1 +1929,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1932,1 +1932,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1937,2 +1937,2 @@\n-  if (VerifyDependencies && fm != NULL) {\n-    guarantee(NULL == (void *)check_unique_concrete_method(ctxk, fm),\n+  if (VerifyDependencies && fm != nullptr) {\n+    guarantee(nullptr == (void *)check_unique_concrete_method(ctxk, fm),\n@@ -1945,1 +1945,1 @@\n-\/\/ If a class (or interface) has a unique concrete method uniqm, return NULL.\n+\/\/ If a class (or interface) has a unique concrete method uniqm, return nullptr.\n@@ -1961,1 +1961,1 @@\n-    return NULL; \/\/ no vtable index available\n+    return nullptr; \/\/ no vtable index available\n@@ -1975,1 +1975,1 @@\n-  \/\/ Return NULL if m is marked old; must have been a redefined method.\n+  \/\/ Return nullptr if m is marked old; must have been a redefined method.\n@@ -1977,1 +1977,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1988,2 +1988,2 @@\n-  if (wit != NULL) {\n-    return NULL;  \/\/ Too many witnesses.\n+  if (wit != nullptr) {\n+    return nullptr;  \/\/ Too many witnesses.\n@@ -1991,4 +1991,4 @@\n-  \/\/ p == NULL when no participants are found (wf.num_participants() == 0).\n-  \/\/ fm == NULL case has 2 meanings:\n-  \/\/  * when p == NULL: no method found;\n-  \/\/  * when p != NULL: AbstractMethodError-throwing method found.\n+  \/\/ p == nullptr when no participants are found (wf.num_participants() == 0).\n+  \/\/ fm == nullptr case has 2 meanings:\n+  \/\/  * when p == nullptr: no method found;\n+  \/\/  * when p != nullptr: AbstractMethodError-throwing method found.\n@@ -1998,2 +1998,2 @@\n-  assert(fm == NULL || p != NULL, \"no participant\");\n-  \/\/ Normalize all error-throwing cases to NULL.\n+  assert(fm == nullptr || p != nullptr, \"no participant\");\n+  \/\/ Normalize all error-throwing cases to nullptr.\n@@ -2003,1 +2003,1 @@\n-    fm = NULL; \/\/ error-throwing method\n+    fm = nullptr; \/\/ error-throwing method\n@@ -2006,1 +2006,1 @@\n-    if (p == NULL) {\n+    if (p == nullptr) {\n@@ -2008,1 +2008,1 @@\n-      assert(fm == NULL, \"sanity\");\n+      assert(fm == nullptr, \"sanity\");\n@@ -2014,2 +2014,2 @@\n-  if (VerifyDependencies && fm != NULL) {\n-    guarantee(NULL == check_unique_concrete_method(ctxk, fm, resolved_klass, resolved_method),\n+  if (VerifyDependencies && fm != nullptr) {\n+    guarantee(nullptr == check_unique_concrete_method(ctxk, fm, resolved_klass, resolved_method),\n@@ -2019,1 +2019,1 @@\n-  assert(fm == NULL || !fm->is_abstract(), \"sanity\");\n+  assert(fm == nullptr || !fm->is_abstract(), \"sanity\");\n@@ -2024,1 +2024,1 @@\n-  Klass*  uniqp = NULL;\n+  Klass*  uniqp = nullptr;\n@@ -2026,1 +2026,1 @@\n-  assert(uniqm == NULL || uniqm == fm ||\n+  assert(uniqm == nullptr || uniqm == fm ||\n@@ -2029,1 +2029,1 @@\n-         (fm == NULL && uniqm != NULL && uniqp != NULL && !InstanceKlass::cast(uniqp)->is_linked()),\n+         (fm == nullptr && uniqm != nullptr && uniqp != nullptr && !InstanceKlass::cast(uniqp)->is_linked()),\n@@ -2037,1 +2037,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -2044,2 +2044,2 @@\n-  assert(call_site != NULL, \"sanity\");\n-  assert(method_handle != NULL, \"sanity\");\n+  assert(call_site != nullptr, \"sanity\");\n+  assert(method_handle != nullptr, \"sanity\");\n@@ -2048,1 +2048,1 @@\n-  if (changes == NULL) {\n+  if (changes == nullptr) {\n@@ -2059,1 +2059,1 @@\n-  return NULL;  \/\/ assertion still valid\n+  return nullptr;  \/\/ assertion still valid\n@@ -2063,1 +2063,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -2076,1 +2076,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2100,1 +2100,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2112,1 +2112,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2118,1 +2118,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2129,1 +2129,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -2136,1 +2136,1 @@\n-    Klass* witness = check_new_klass_dependency(NULL);\n+    Klass* witness = check_new_klass_dependency(nullptr);\n@@ -2138,1 +2138,1 @@\n-    assert(witness != NULL || check_klass_init_dependency(NULL) == NULL, \"missed dependency\");\n+    assert(witness != nullptr || check_klass_init_dependency(nullptr) == nullptr, \"missed dependency\");\n@@ -2147,1 +2147,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2153,1 +2153,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2171,1 +2171,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2207,2 +2207,2 @@\n-  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) NULL);\n-  _change_type = (type == NULL ? NO_CHANGE : Start_Klass);\n+  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) nullptr);\n+  _change_type = (type == nullptr ? NO_CHANGE : Start_Klass);\n@@ -2210,1 +2210,1 @@\n-  _ti_base = NULL;\n+  _ti_base = nullptr;\n@@ -2229,1 +2229,1 @@\n-      if (_klass != NULL) {\n+      if (_klass != nullptr) {\n@@ -2234,1 +2234,1 @@\n-    _ti_limit = (_ti_base == NULL) ? 0 : _ti_base->length();\n+    _ti_limit = (_ti_base == nullptr) ? 0 : _ti_base->length();\n@@ -2274,1 +2274,1 @@\n-  if (k == NULL || !k->is_instance_klass()) {\n+  if (k == nullptr || !k->is_instance_klass()) {\n@@ -2301,1 +2301,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":164,"deletions":164,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    if (m != NULL) {                                                      \\\n+    if (m != nullptr) {                                                   \\\n@@ -271,1 +271,1 @@\n-  assert(pc != NULL, \"Must be non null\");\n+  assert(pc != nullptr, \"Must be non null\");\n@@ -273,1 +273,1 @@\n-  assert(handler != NULL, \"Must be non null\");\n+  assert(handler != nullptr, \"Must be non null\");\n@@ -277,2 +277,2 @@\n-  _next = NULL;\n-  _purge_list_next = NULL;\n+  _next = nullptr;\n+  _purge_list_next = nullptr;\n@@ -285,1 +285,1 @@\n-  assert(pc != NULL,\"Must be non null\");\n+  assert(pc != nullptr,\"Must be non null\");\n@@ -291,1 +291,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -311,1 +311,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -349,2 +349,2 @@\n-  if (initial_pc_desc == NULL) {\n-    _pc_descs[0] = NULL; \/\/ native method; no PcDescs at all\n+  if (initial_pc_desc == nullptr) {\n+    _pc_descs[0] = nullptr; \/\/ native method; no PcDescs at all\n@@ -376,1 +376,1 @@\n-  if (res == NULL) return NULL;  \/\/ native method; no PcDescs at all\n+  if (res == nullptr) return nullptr;  \/\/ native method; no PcDescs at all\n@@ -393,1 +393,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -432,1 +432,1 @@\n-  if (method() != NULL && is_native_method()) {\n+  if (method() != nullptr && is_native_method()) {\n@@ -438,1 +438,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -447,2 +447,2 @@\n-  _oops_do_mark_link       = NULL;\n-  _osr_link                = NULL;\n+  _oops_do_mark_link       = nullptr;\n+  _osr_link                = nullptr;\n@@ -502,1 +502,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -525,1 +525,1 @@\n-    NOT_PRODUCT(if (nm != NULL) native_nmethod_stats.note_native_nmethod(nm));\n+    NOT_PRODUCT(if (nm != nullptr) native_nmethod_stats.note_native_nmethod(nm));\n@@ -528,1 +528,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -562,1 +562,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -595,1 +595,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -617,1 +617,1 @@\n-          if (klass == NULL) {\n+          if (klass == nullptr) {\n@@ -624,1 +624,1 @@\n-      NOT_PRODUCT(if (nm != NULL)  note_java_nmethod(nm));\n+      NOT_PRODUCT(if (nm != nullptr)  note_java_nmethod(nm));\n@@ -628,1 +628,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -649,1 +649,1 @@\n-  _unlinked_next(NULL),\n+  _unlinked_next(nullptr),\n@@ -680,0 +680,1 @@\n+    _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n@@ -696,3 +697,3 @@\n-    _osr_entry_point         = NULL;\n-    _exception_cache         = NULL;\n-    _pc_desc_container.reset_to(NULL);\n+    _osr_entry_point         = nullptr;\n+    _exception_cache         = nullptr;\n+    _pc_desc_container.reset_to(nullptr);\n@@ -724,1 +725,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -738,1 +739,1 @@\n-        if (oop_maps != NULL) {\n+        if (oop_maps != nullptr) {\n@@ -756,1 +757,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -798,1 +799,1 @@\n-  _unlinked_next(NULL),\n+  _unlinked_next(nullptr),\n@@ -822,0 +823,1 @@\n+    _skipped_instructions_size      = code_buffer->total_skipped_instructions_size();\n@@ -834,1 +836,1 @@\n-        _deopt_handler_begin = NULL;\n+        _deopt_handler_begin = nullptr;\n@@ -839,1 +841,1 @@\n-        _deopt_mh_handler_begin = NULL;\n+        _deopt_mh_handler_begin = nullptr;\n@@ -853,1 +855,1 @@\n-        _deopt_mh_handler_begin  = NULL;\n+        _deopt_mh_handler_begin  = nullptr;\n@@ -883,1 +885,1 @@\n-    _exception_cache         = NULL;\n+    _exception_cache         = nullptr;\n@@ -926,1 +928,1 @@\n-  if (nm_kind != NULL)  log->print(\" compile_kind='%s'\", nm_kind);\n+  if (nm_kind != nullptr)  log->print(\" compile_kind='%s'\", nm_kind);\n@@ -932,1 +934,1 @@\n-  if (jvmci_nmethod_data() != NULL) {\n+  if (jvmci_nmethod_data() != nullptr) {\n@@ -934,1 +936,1 @@\n-    if (jvmci_name != NULL) {\n+    if (jvmci_name != nullptr) {\n@@ -951,1 +953,1 @@\n-  if (LogCompilation && xtty != NULL) {\n+  if (LogCompilation && xtty != nullptr) {\n@@ -981,1 +983,1 @@\n-  if (st != NULL) {\n+  if (st != nullptr) {\n@@ -1001,1 +1003,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -1031,1 +1033,1 @@\n-      if (oop_maps() != NULL) {\n+      if (oop_maps() != nullptr) {\n@@ -1073,1 +1075,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -1081,1 +1083,1 @@\n-  if (handle == NULL ||\n+  if (handle == nullptr ||\n@@ -1105,1 +1107,1 @@\n-  fix_oop_relocations(NULL, NULL, \/*initialize_immediates=*\/ true);\n+  fix_oop_relocations(nullptr, nullptr, \/*initialize_immediates=*\/ true);\n@@ -1125,1 +1127,2 @@\n-        initialize_immediate_oop(dest, cast_from_oop<jobject>(*dest));\n+        jobject obj = *reinterpret_cast<jobject*>(dest);\n+        initialize_immediate_oop(dest, obj);\n@@ -1172,1 +1175,1 @@\n-  assert(method() == NULL || can_be_deoptimized(), \"\");\n+  assert(method() == nullptr || can_be_deoptimized(), \"\");\n@@ -1187,1 +1190,1 @@\n-        if (nop != NULL) {\n+        if (nop != nullptr) {\n@@ -1198,1 +1201,1 @@\n-        if (nop != NULL) {\n+        if (nop != nullptr) {\n@@ -1225,1 +1228,1 @@\n-        assert(cb != NULL, \"destination not in CodeBlob?\");\n+        assert(cb != nullptr, \"destination not in CodeBlob?\");\n@@ -1227,1 +1230,1 @@\n-        if( nm != NULL ) {\n+        if( nm != nullptr ) {\n@@ -1238,1 +1241,1 @@\n-        assert(cb != NULL, \"destination not in CodeBlob?\");\n+        assert(cb != nullptr, \"destination not in CodeBlob?\");\n@@ -1240,1 +1243,1 @@\n-        if( nm != NULL ) {\n+        if( nm != nullptr ) {\n@@ -1268,1 +1271,1 @@\n-  if (m == NULL)  return;\n+  if (m == nullptr)  return;\n@@ -1270,1 +1273,1 @@\n-  if (mdo == NULL)  return;\n+  if (mdo == nullptr)  return;\n@@ -1290,1 +1293,1 @@\n-  if (method() != NULL) {\n+  if (method() != nullptr) {\n@@ -1297,1 +1300,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -1314,1 +1317,1 @@\n-  if (method() != NULL) {\n+  if (method() != nullptr) {\n@@ -1340,1 +1343,1 @@\n-    MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n@@ -1388,1 +1391,1 @@\n-  if (nmethod_data != NULL) {\n+  if (nmethod_data != nullptr) {\n@@ -1394,1 +1397,1 @@\n-  if (is_osr_method() && method() != NULL) {\n+  if (is_osr_method() && method() != nullptr) {\n@@ -1406,1 +1409,1 @@\n-  if (_unlinked_next != NULL) {\n+  if (_unlinked_next != nullptr) {\n@@ -1429,1 +1432,1 @@\n-  if (nmethod_data != NULL) {\n+  if (nmethod_data != nullptr) {\n@@ -1457,1 +1460,1 @@\n-  while(ec != NULL) {\n+  while(ec != nullptr) {\n@@ -1472,1 +1475,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1479,1 +1482,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1498,1 +1501,1 @@\n-        if (klass == NULL) {\n+        if (klass == nullptr) {\n@@ -1518,1 +1521,1 @@\n-  if (CompilationLog::log() != NULL) {\n+  if (CompilationLog::log() != nullptr) {\n@@ -1552,1 +1555,1 @@\n-    if (state == NULL) {\n+    if (state == nullptr) {\n@@ -1565,1 +1568,1 @@\n-  assert(_method != NULL, \"just checking\");\n+  assert(_method != nullptr, \"just checking\");\n@@ -1594,1 +1597,1 @@\n-        if (r->metadata_is_immediate() && r->metadata_value() != NULL) {\n+        if (r->metadata_is_immediate() && r->metadata_value() != nullptr) {\n@@ -1608,1 +1611,1 @@\n-          if (ic_oop != NULL) {\n+          if (ic_oop != nullptr) {\n@@ -1618,1 +1621,1 @@\n-    if (*p == Universe::non_oop_word() || *p == NULL)  continue;  \/\/ skip non-oops\n+    if (*p == Universe::non_oop_word() || *p == nullptr)  continue;  \/\/ skip non-oops\n@@ -1624,1 +1627,1 @@\n-  if (_method != NULL) f->do_metadata(_method);\n+  if (_method != nullptr) f->do_metadata(_method);\n@@ -1751,1 +1754,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n@@ -1770,1 +1773,1 @@\n-        if (r->oop_is_immediate() && r->oop_value() != NULL) {\n+        if (r->oop_is_immediate() && r->oop_value() != nullptr) {\n@@ -1812,1 +1815,1 @@\n-    assert(result == NULL, \"adding to global list as weak done must always succeed.\");\n+    assert(result == nullptr, \"adding to global list as weak done must always succeed.\");\n@@ -1821,1 +1824,1 @@\n-  if ((_oops_do_mark_link == NULL) &&\n+  if ((_oops_do_mark_link == nullptr) &&\n@@ -1836,2 +1839,2 @@\n-  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, mark_link(NULL, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n-  if (old_next == NULL) {\n+  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, mark_link(nullptr, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n+  if (old_next == nullptr) {\n@@ -1875,1 +1878,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1881,1 +1884,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1892,1 +1895,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1911,1 +1914,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1928,1 +1931,1 @@\n-  if (next_raw == NULL) {\n+  if (next_raw == nullptr) {\n@@ -1961,1 +1964,1 @@\n-  assert(_oops_do_mark_nmethods == NULL, \"must be empty\");\n+  assert(_oops_do_mark_nmethods == nullptr, \"must be empty\");\n@@ -1968,2 +1971,2 @@\n-  _oops_do_mark_nmethods = NULL;\n-  if (next != NULL) {\n+  _oops_do_mark_nmethods = nullptr;\n+  if (next != nullptr) {\n@@ -1974,1 +1977,1 @@\n-      cur->_oops_do_mark_link = NULL;\n+      cur->_oops_do_mark_link = nullptr;\n@@ -2017,1 +2020,1 @@\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != NULL), \"must have deopt mh handler\");\n+  assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != nullptr), \"must have deopt mh handler\");\n@@ -2048,1 +2051,1 @@\n-  PcDesc* res = NULL;\n+  PcDesc* res = nullptr;\n@@ -2052,1 +2055,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -2068,1 +2071,1 @@\n-    return NULL;  \/\/ PC is wildly out of range\n+    return nullptr;  \/\/ PC is wildly out of range\n@@ -2075,1 +2078,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -2087,1 +2090,1 @@\n-  if (lower >= upper)  return NULL;  \/\/ native method; no PcDescs at all\n+  if (lower >= upper)  return nullptr;  \/\/ native method; no PcDescs at all\n@@ -2140,2 +2143,2 @@\n-    assert(NULL == linear_search(search, pc_offset, approximate), \"search ok\");\n-    return NULL;\n+    assert(nullptr == linear_search(search, pc_offset, approximate), \"search ok\");\n+    return nullptr;\n@@ -2174,1 +2177,1 @@\n-          if (deps.check_dependency() != NULL) {\n+          if (deps.check_dependency() != nullptr) {\n@@ -2197,1 +2200,1 @@\n-    if (deps.spot_check_dependency_at(changes) != NULL) {\n+    if (deps.spot_check_dependency_at(changes) != nullptr) {\n@@ -2293,1 +2296,1 @@\n-        assert(pc_desc_at(code_begin() + exec_offset) != NULL, \"missing PcDesc\");\n+        assert(pc_desc_at(code_begin() + exec_offset) != nullptr, \"missing PcDesc\");\n@@ -2313,1 +2316,1 @@\n-  assert(_oops_do_mark_link == NULL, \"_oops_do_mark_link for %s should be NULL but is \" PTR_FORMAT,\n+  assert(_oops_do_mark_link == nullptr, \"_oops_do_mark_link for %s should be nullptr but is \" PTR_FORMAT,\n@@ -2338,1 +2341,1 @@\n-  assert(pd != NULL, \"PcDesc must exist\");\n+  assert(pd != nullptr, \"PcDesc must exist\");\n@@ -2352,1 +2355,1 @@\n-    address stub = NULL;\n+    address stub = nullptr;\n@@ -2376,1 +2379,1 @@\n-    assert(stub == NULL || stub_contains(stub), \"static call stub outside stub section\");\n+    assert(stub == nullptr || stub_contains(stub), \"static call stub outside stub section\");\n@@ -2404,1 +2407,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -2489,1 +2492,1 @@\n-    if (ctxk != NULL) {\n+    if (ctxk != nullptr) {\n@@ -2514,2 +2517,2 @@\n-      if (*p == NULL) {\n-        st->print_cr(\"NULL-oop\");\n+      if (*p == nullptr) {\n+        st->print_cr(\"nullptr-oop\");\n@@ -2557,1 +2560,1 @@\n-      while (sd != NULL) {\n+      while (sd != nullptr) {\n@@ -2602,1 +2605,1 @@\n-    value = NULL;\n+    value = nullptr;\n@@ -2619,1 +2622,1 @@\n-      tty->print(\"NULL-oop\");\n+      tty->print(\"nullptr-oop\");\n@@ -2653,2 +2656,2 @@\n-      } else if (m == NULL) {\n-        tty->print(\"NULL-oop\");\n+      } else if (m == nullptr) {\n+        tty->print(\"nullptr-oop\");\n@@ -2783,1 +2786,1 @@\n-  if ((start == NULL) || (end == NULL)) {\n+  if ((start == nullptr) || (end == nullptr)) {\n@@ -2796,1 +2799,1 @@\n-    const char* header = NULL;\n+    const char* header = nullptr;\n@@ -2800,1 +2803,1 @@\n-      while ((p < end) && (header == NULL)) {\n+      while ((p < end) && (header == nullptr)) {\n@@ -2809,2 +2812,2 @@\n-        header = NULL;\n-      } else if (header != NULL) {\n+        header = nullptr;\n+      } else if (header != nullptr) {\n@@ -2813,1 +2816,1 @@\n-        header = NULL;\n+        header = nullptr;\n@@ -2830,1 +2833,1 @@\n-    while ((p < end) && (p != NULL)) {\n+    while ((p < end) && (p != nullptr)) {\n@@ -2910,1 +2913,1 @@\n-          if (obj == NULL) st.print(\"NULL\");\n+          if (obj == nullptr) st.print(\"nullptr\");\n@@ -2920,1 +2923,1 @@\n-          if (obj == NULL) st.print(\"NULL\");\n+          if (obj == nullptr) st.print(\"nullptr\");\n@@ -2932,1 +2935,1 @@\n-          if (cb != NULL) {\n+          if (cb != nullptr) {\n@@ -2953,1 +2956,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2964,1 +2967,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2975,1 +2978,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2994,1 +2997,1 @@\n-  return have_one ? \"other\" : NULL;\n+  return have_one ? \"other\" : nullptr;\n@@ -3000,1 +3003,1 @@\n-  if (p != NULL && p->real_pc(this) <= end) {\n+  if (p != nullptr && p->real_pc(this) <= end) {\n@@ -3003,1 +3006,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3007,1 +3010,1 @@\n-  const char* label = NULL;\n+  const char* label = nullptr;\n@@ -3019,1 +3022,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_begin != NULL &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_deopt_handler_begin != nullptr &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n@@ -3044,1 +3047,1 @@\n-      if (label != NULL) {\n+      if (label != nullptr) {\n@@ -3052,1 +3055,1 @@\n-  if (m == NULL || is_osr_method()) {\n+  if (m == nullptr || is_osr_method()) {\n@@ -3155,1 +3158,1 @@\n-  if (sd != NULL) return true;\n+  if (sd != nullptr) return true;\n@@ -3159,1 +3162,1 @@\n-  if (str != NULL) return true;\n+  if (str != nullptr) return true;\n@@ -3190,1 +3193,1 @@\n-  if (oms != NULL) {\n+  if (oms != nullptr) {\n@@ -3219,1 +3222,1 @@\n-  if (sd != NULL) {\n+  if (sd != nullptr) {\n@@ -3234,2 +3237,2 @@\n-      if (sd->method() == NULL) {\n-        st->print(\"method is NULL\");\n+      if (sd->method() == nullptr) {\n+        st->print(\"method is nullptr\");\n@@ -3249,1 +3252,1 @@\n-            if (invoke.name() != NULL)\n+            if (invoke.name() != nullptr)\n@@ -3262,1 +3265,1 @@\n-            if (field.name() != NULL)\n+            if (field.name() != nullptr)\n@@ -3275,1 +3278,1 @@\n-    for (;sd != NULL; sd = sd->sender()) {\n+    for (;sd != nullptr; sd = sd->sender()) {\n@@ -3281,2 +3284,2 @@\n-      if (sd->method() == NULL) {\n-        st->print(\"method is NULL\");\n+      if (sd->method() == nullptr) {\n+        st->print(\"method is nullptr\");\n@@ -3300,2 +3303,2 @@\n-  if (str != NULL) {\n-    if (sd != NULL) st->cr();\n+  if (str != nullptr) {\n+    if (sd != nullptr) st->cr();\n@@ -3347,1 +3350,1 @@\n-    assert(db != NULL && !db->is_adapter_blob(), \"must use stub!\");\n+    assert(db != nullptr && !db->is_adapter_blob(), \"must use stub!\");\n@@ -3383,1 +3386,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3401,1 +3404,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -3429,1 +3432,1 @@\n-  if (xtty != NULL)  xtty->head(\"statistics type='nmethod'\");\n+  if (xtty != nullptr)  xtty->head(\"statistics type='nmethod'\");\n@@ -3446,1 +3449,1 @@\n-  if (xtty != NULL)  xtty->tail(\"statistics\");\n+  if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -3455,1 +3458,1 @@\n-    guarantee(jvmci_nmethod_data() != NULL, \"failed speculation in nmethod without failed speculation list\");\n+    guarantee(jvmci_nmethod_data() != nullptr, \"failed speculation in nmethod without failed speculation list\");\n@@ -3462,1 +3465,1 @@\n-  if (jvmci_nmethod_data() != NULL) {\n+  if (jvmci_nmethod_data() != nullptr) {\n@@ -3465,1 +3468,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":159,"deletions":156,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-  \/\/   _oops_do_mark_link == NULL: the nmethod has not been visited at all yet, i.e.\n+  \/\/   _oops_do_mark_link == nullptr: the nmethod has not been visited at all yet, i.e.\n@@ -177,1 +177,1 @@\n-  \/\/ Attempt N|WR -> X|WD transition. Returns NULL if successful, X otherwise.\n+  \/\/ Attempt N|WR -> X|WD transition. Returns nullptr if successful, X otherwise.\n@@ -267,0 +267,2 @@\n+  int _skipped_instructions_size;\n+\n@@ -348,1 +350,1 @@\n-                              , char* speculations = NULL,\n+                              , char* speculations = nullptr,\n@@ -351,2 +353,2 @@\n-                              const char* nmethod_mirror_name = NULL,\n-                              FailedSpeculation** failed_speculations = NULL\n+                              const char* nmethod_mirror_name = nullptr,\n+                              FailedSpeculation** failed_speculations = nullptr\n@@ -385,1 +387,1 @@\n-  address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : NULL; }\n+  address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : nullptr; }\n@@ -400,0 +402,3 @@\n+\n+  int skipped_instructions_size () const          { return           _skipped_instructions_size             ; }\n+\n@@ -496,1 +501,1 @@\n-  Metadata*     metadata_at(int index) const      { return index == 0 ? NULL: *metadata_addr_at(index); }\n+  Metadata*     metadata_at(int index) const      { return index == 0 ? nullptr: *metadata_addr_at(index); }\n@@ -513,1 +518,1 @@\n-  void fix_oop_relocations()                           { fix_oop_relocations(NULL, NULL, false); }\n+  void fix_oop_relocations()                           { fix_oop_relocations(nullptr, nullptr, false); }\n@@ -547,1 +552,1 @@\n-  \/\/ This returns a non-NULL value iff this nmethod was\n+  \/\/ This returns a non-nullptr value iff this nmethod was\n@@ -550,1 +555,1 @@\n-    return jvmci_data_size() == 0 ? NULL : (JVMCINMethodData*) jvmci_data_begin();\n+    return jvmci_data_size() == 0 ? nullptr : (JVMCINMethodData*) jvmci_data_begin();\n@@ -606,1 +611,1 @@\n-  void post_compiled_method_load_event(JvmtiThreadState* state = NULL);\n+  void post_compiled_method_load_event(JvmtiThreadState* state = nullptr);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -110,1 +110,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -125,1 +125,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -160,1 +160,1 @@\n-  if (is_top()) return NULL;\n+  if (is_top()) return nullptr;\n@@ -183,1 +183,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -188,1 +188,1 @@\n-  if (pd != NULL) {\n+  if (pd != nullptr) {\n@@ -206,1 +206,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -217,1 +217,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -228,1 +228,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -239,1 +239,1 @@\n-  if (NOT_JVMCI(DoEscapeAnalysis &&) is_top() && _objects != NULL) {\n+  if (NOT_JVMCI(DoEscapeAnalysis &&) is_top() && _objects != nullptr) {\n@@ -262,1 +262,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    assert(pc_desc != NULL, \"Must be able to find matching PcDesc\");\n+    assert(pc_desc != nullptr, \"Must be able to find matching PcDesc\");\n@@ -86,1 +86,1 @@\n-  \/\/ Stack walking, returns NULL if this is the outer most scope.\n+  \/\/ Stack walking, returns nullptr if this is the outer most scope.\n@@ -94,1 +94,1 @@\n-  \/\/ Tells whether sender() returns NULL\n+  \/\/ Tells whether sender() returns nullptr\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-address VtableStub::_chunk             = NULL;\n-address VtableStub::_chunk_end         = NULL;\n+address VtableStub::_chunk             = nullptr;\n+address VtableStub::_chunk_end         = nullptr;\n@@ -62,1 +62,1 @@\n-  if (_chunk == NULL || _chunk + real_size > _chunk_end) {\n+  if (_chunk == nullptr || _chunk + real_size > _chunk_end) {\n@@ -68,2 +68,2 @@\n-    if (blob == NULL) {\n-      return NULL;\n+    if (blob == nullptr) {\n+      return nullptr;\n@@ -135,1 +135,1 @@\n-      _table[i] = NULL;\n+      _table[i] = nullptr;\n@@ -219,1 +219,1 @@\n-    if (s == NULL) {\n+    if (s == nullptr) {\n@@ -227,2 +227,2 @@\n-      if (s == NULL) {\n-        return NULL;\n+      if (s == nullptr) {\n+        return nullptr;\n@@ -285,2 +285,2 @@\n-  for (s = _table[hash]; s != NULL && s != stub; s = s->next()) {}\n-  return (s == stub) ? s : NULL;\n+  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n+  return (s == stub) ? s : nullptr;\n@@ -292,1 +292,1 @@\n-  return stub_containing(pc) != NULL;\n+  return stub_containing(pc) != nullptr;\n@@ -301,1 +301,1 @@\n-    for (VtableStub* s = _table[i]; s != NULL; s = s->next()) {\n+    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n@@ -305,1 +305,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -314,1 +314,1 @@\n-        for (VtableStub* s = _table[i]; s != NULL; s = s->next()) {\n+        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-  static VtableStub* stub_containing(address pc);                    \/\/ stub containing pc or NULL\n+  static VtableStub* stub_containing(address pc);                    \/\/ stub containing pc or nullptr\n@@ -136,1 +136,1 @@\n-        : _next(NULL), _index(index), _ame_offset(-1), _npe_offset(-1),\n+        : _next(nullptr), _index(index), _ame_offset(-1), _npe_offset(-1),\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,2 +135,2 @@\n-jobject* CompileBroker::_compiler1_objects = NULL;\n-jobject* CompileBroker::_compiler2_objects = NULL;\n+jobject* CompileBroker::_compiler1_objects = nullptr;\n+jobject* CompileBroker::_compiler2_objects = nullptr;\n@@ -138,2 +138,2 @@\n-CompileLog** CompileBroker::_compiler1_logs = NULL;\n-CompileLog** CompileBroker::_compiler2_logs = NULL;\n+CompileLog** CompileBroker::_compiler1_logs = nullptr;\n+CompileLog** CompileBroker::_compiler2_logs = nullptr;\n@@ -147,22 +147,22 @@\n-PerfCounter* CompileBroker::_perf_total_compilation = NULL;\n-PerfCounter* CompileBroker::_perf_osr_compilation = NULL;\n-PerfCounter* CompileBroker::_perf_standard_compilation = NULL;\n-\n-PerfCounter* CompileBroker::_perf_total_bailout_count = NULL;\n-PerfCounter* CompileBroker::_perf_total_invalidated_count = NULL;\n-PerfCounter* CompileBroker::_perf_total_compile_count = NULL;\n-PerfCounter* CompileBroker::_perf_total_osr_compile_count = NULL;\n-PerfCounter* CompileBroker::_perf_total_standard_compile_count = NULL;\n-\n-PerfCounter* CompileBroker::_perf_sum_osr_bytes_compiled = NULL;\n-PerfCounter* CompileBroker::_perf_sum_standard_bytes_compiled = NULL;\n-PerfCounter* CompileBroker::_perf_sum_nmethod_size = NULL;\n-PerfCounter* CompileBroker::_perf_sum_nmethod_code_size = NULL;\n-\n-PerfStringVariable* CompileBroker::_perf_last_method = NULL;\n-PerfStringVariable* CompileBroker::_perf_last_failed_method = NULL;\n-PerfStringVariable* CompileBroker::_perf_last_invalidated_method = NULL;\n-PerfVariable*       CompileBroker::_perf_last_compile_type = NULL;\n-PerfVariable*       CompileBroker::_perf_last_compile_size = NULL;\n-PerfVariable*       CompileBroker::_perf_last_failed_type = NULL;\n-PerfVariable*       CompileBroker::_perf_last_invalidated_type = NULL;\n+PerfCounter* CompileBroker::_perf_total_compilation = nullptr;\n+PerfCounter* CompileBroker::_perf_osr_compilation = nullptr;\n+PerfCounter* CompileBroker::_perf_standard_compilation = nullptr;\n+\n+PerfCounter* CompileBroker::_perf_total_bailout_count = nullptr;\n+PerfCounter* CompileBroker::_perf_total_invalidated_count = nullptr;\n+PerfCounter* CompileBroker::_perf_total_compile_count = nullptr;\n+PerfCounter* CompileBroker::_perf_total_osr_compile_count = nullptr;\n+PerfCounter* CompileBroker::_perf_total_standard_compile_count = nullptr;\n+\n+PerfCounter* CompileBroker::_perf_sum_osr_bytes_compiled = nullptr;\n+PerfCounter* CompileBroker::_perf_sum_standard_bytes_compiled = nullptr;\n+PerfCounter* CompileBroker::_perf_sum_nmethod_size = nullptr;\n+PerfCounter* CompileBroker::_perf_sum_nmethod_code_size = nullptr;\n+\n+PerfStringVariable* CompileBroker::_perf_last_method = nullptr;\n+PerfStringVariable* CompileBroker::_perf_last_failed_method = nullptr;\n+PerfStringVariable* CompileBroker::_perf_last_invalidated_method = nullptr;\n+PerfVariable*       CompileBroker::_perf_last_compile_type = nullptr;\n+PerfVariable*       CompileBroker::_perf_last_compile_size = nullptr;\n+PerfVariable*       CompileBroker::_perf_last_failed_type = nullptr;\n+PerfVariable*       CompileBroker::_perf_last_invalidated_type = nullptr;\n@@ -194,2 +194,2 @@\n-CompileQueue* CompileBroker::_c2_compile_queue     = NULL;\n-CompileQueue* CompileBroker::_c1_compile_queue     = NULL;\n+CompileQueue* CompileBroker::_c2_compile_queue     = nullptr;\n+CompileQueue* CompileBroker::_c1_compile_queue     = nullptr;\n@@ -219,1 +219,1 @@\n-  if (log != NULL && !task->is_unloaded())  task->log_task_start(log);\n+  if (log != nullptr && !task->is_unloaded())  task->log_task_start(log);\n@@ -226,3 +226,3 @@\n-  if (log != NULL && !task->is_unloaded())  task->log_task_done(log);\n-  thread->set_task(NULL);\n-  thread->set_env(NULL);\n+  if (log != nullptr && !task->is_unloaded())  task->log_task_done(log);\n+  thread->set_task(nullptr);\n+  thread->set_env(nullptr);\n@@ -240,1 +240,1 @@\n-        task->set_blocking_jvmci_compile_state(NULL);\n+        task->set_blocking_jvmci_compile_state(nullptr);\n@@ -302,1 +302,1 @@\n-        _compiler2_objects[compiler_count - 1] = NULL;\n+        _compiler2_objects[compiler_count - 1] = nullptr;\n@@ -317,2 +317,2 @@\n-  task->set_next(NULL);\n-  task->set_prev(NULL);\n+  task->set_next(nullptr);\n+  task->set_prev(nullptr);\n@@ -320,1 +320,1 @@\n-  if (_last == NULL) {\n+  if (_last == nullptr) {\n@@ -322,1 +322,1 @@\n-    assert(_first == NULL, \"queue is empty\");\n+    assert(_first == nullptr, \"queue is empty\");\n@@ -327,1 +327,1 @@\n-    assert(_last->next() == NULL, \"not last\");\n+    assert(_last->next() == nullptr, \"not last\");\n@@ -341,1 +341,1 @@\n-  if (LogCompilation && xtty != NULL) {\n+  if (LogCompilation && xtty != nullptr) {\n@@ -360,1 +360,1 @@\n-  while (next != NULL) {\n+  while (next != nullptr) {\n@@ -371,2 +371,2 @@\n-  _first = NULL;\n-  _last = NULL;\n+  _first = nullptr;\n+  _last = nullptr;\n@@ -388,1 +388,1 @@\n-  \/\/ If _first is NULL we have no more compile jobs. There are two reasons for\n+  \/\/ If _first is nullptr we have no more compile jobs. There are two reasons for\n@@ -393,1 +393,1 @@\n-  while (_first == NULL) {\n+  while (_first == nullptr) {\n@@ -396,1 +396,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -416,1 +416,1 @@\n-    if (UseDynamicNumberOfCompilerThreads && _first == NULL) {\n+    if (UseDynamicNumberOfCompilerThreads && _first == nullptr) {\n@@ -418,1 +418,1 @@\n-      if (CompileBroker::can_remove(CompilerThread::current(), false)) return NULL;\n+      if (CompileBroker::can_remove(CompilerThread::current(), false)) return nullptr;\n@@ -423,1 +423,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -430,1 +430,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -435,1 +435,1 @@\n-  if (task != NULL) {\n+  if (task != nullptr) {\n@@ -452,1 +452,1 @@\n-  if (_first_stale != NULL) {\n+  if (_first_stale != nullptr) {\n@@ -458,1 +458,1 @@\n-    _first_stale = NULL;\n+    _first_stale = nullptr;\n@@ -461,1 +461,1 @@\n-      for (CompileTask* task = head; task != NULL; ) {\n+      for (CompileTask* task = head; task != nullptr; ) {\n@@ -473,1 +473,1 @@\n-  if (task->prev() != NULL) {\n+  if (task->prev() != nullptr) {\n@@ -481,1 +481,1 @@\n-  if (task->next() != NULL) {\n+  if (task->next() != nullptr) {\n@@ -497,1 +497,1 @@\n-  task->set_prev(NULL);\n+  task->set_prev(nullptr);\n@@ -505,1 +505,1 @@\n-  while (task != NULL) {\n+  while (task != nullptr) {\n@@ -515,1 +515,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -526,1 +526,1 @@\n-  if (_c1_compile_queue != NULL) {\n+  if (_c1_compile_queue != nullptr) {\n@@ -529,1 +529,1 @@\n-  if (_c2_compile_queue != NULL) {\n+  if (_c2_compile_queue != nullptr) {\n@@ -538,1 +538,1 @@\n-  if (task == NULL) {\n+  if (task == nullptr) {\n@@ -541,2 +541,2 @@\n-    while (task != NULL) {\n-      task->print(st, NULL, true, true);\n+    while (task != nullptr) {\n+      task->print(st, nullptr, true, true);\n@@ -835,1 +835,1 @@\n-  JavaThread* new_thread = NULL;\n+  JavaThread* new_thread = nullptr;\n@@ -839,1 +839,1 @@\n-      assert(comp != NULL, \"Compiler instance missing.\");\n+      assert(comp != nullptr, \"Compiler instance missing.\");\n@@ -864,1 +864,1 @@\n-  if (new_thread != NULL && new_thread->osthread() != NULL) {\n+  if (new_thread != nullptr && new_thread->osthread() != nullptr) {\n@@ -895,1 +895,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -930,1 +930,1 @@\n-    jobject thread_handle = NULL;\n+    jobject thread_handle = nullptr;\n@@ -940,1 +940,1 @@\n-    _compiler2_logs[i] = NULL;\n+    _compiler2_logs[i] = nullptr;\n@@ -944,1 +944,1 @@\n-      assert(ct != NULL, \"should have been handled for initial thread\");\n+      assert(ct != nullptr, \"should have been handled for initial thread\");\n@@ -961,1 +961,1 @@\n-    _compiler1_logs[i] = NULL;\n+    _compiler1_logs[i] = nullptr;\n@@ -965,1 +965,1 @@\n-      assert(ct != NULL, \"should have been handled for initial thread\");\n+      assert(ct != nullptr, \"should have been handled for initial thread\");\n@@ -987,1 +987,1 @@\n-      make_thread(deoptimizer_t, thread_handle, NULL, NULL, THREAD);\n+      make_thread(deoptimizer_t, thread_handle, nullptr, nullptr, THREAD);\n@@ -1003,1 +1003,1 @@\n-  if (_c2_compile_queue != NULL) {\n+  if (_c2_compile_queue != nullptr) {\n@@ -1040,1 +1040,1 @@\n-        assert(compiler2_object(i) == NULL, \"Old one must be released!\");\n+        assert(compiler2_object(i) == nullptr, \"Old one must be released!\");\n@@ -1045,1 +1045,1 @@\n-      if (ct == NULL) break;\n+      if (ct == nullptr) break;\n@@ -1057,1 +1057,1 @@\n-  if (_c1_compile_queue != NULL) {\n+  if (_c1_compile_queue != nullptr) {\n@@ -1066,1 +1066,1 @@\n-      if (ct == NULL) break;\n+      if (ct == nullptr) break;\n@@ -1090,1 +1090,1 @@\n-  if (_c2_compile_queue != NULL) {\n+  if (_c2_compile_queue != nullptr) {\n@@ -1093,1 +1093,1 @@\n-  if (_c1_compile_queue != NULL) {\n+  if (_c1_compile_queue != nullptr) {\n@@ -1170,1 +1170,1 @@\n-  CompileTask* task     = NULL;\n+  CompileTask* task     = nullptr;\n@@ -1292,1 +1292,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1296,1 +1296,1 @@\n-  assert(comp != NULL, \"Ensure we have a compiler\");\n+  assert(comp != nullptr, \"Ensure we have a compiler\");\n@@ -1322,2 +1322,2 @@\n-  if (comp == NULL || compilation_is_prohibited(method, osr_bci, comp_level, directive->ExcludeOption)) {\n-    return NULL;\n+  if (comp == nullptr || compilation_is_prohibited(method, osr_bci, comp_level, directive->ExcludeOption)) {\n+    return nullptr;\n@@ -1328,1 +1328,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1335,1 +1335,1 @@\n-    if (method_code != NULL && method_code->is_nmethod()) {\n+    if (method_code != nullptr && method_code->is_nmethod()) {\n@@ -1341,1 +1341,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1347,2 +1347,2 @@\n-    if (nm != NULL) return nm;\n-    if (method->is_not_osr_compilable(comp_level)) return NULL;\n+    if (nm != nullptr) return nm;\n+    if (method->is_not_osr_compilable(comp_level)) return nullptr;\n@@ -1373,1 +1373,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1380,1 +1380,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1412,1 +1412,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1423,1 +1423,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1429,1 +1429,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1439,1 +1439,1 @@\n-    if (code == NULL) {\n+    if (code == nullptr) {\n@@ -1462,1 +1462,1 @@\n-      return (result != NULL);\n+      return (result != nullptr);\n@@ -1469,1 +1469,1 @@\n-      if (result == NULL) return false;\n+      if (result == nullptr) return false;\n@@ -1498,1 +1498,1 @@\n-  if (is_native && (!CICompileNatives || comp == NULL)) {\n+  if (is_native && (!CICompileNatives || comp == nullptr)) {\n@@ -1505,1 +1505,1 @@\n-  if (is_osr && (!CICompileOSR || comp == NULL)) {\n+  if (is_osr && (!CICompileOSR || comp == nullptr)) {\n@@ -1625,1 +1625,1 @@\n-    if (jvmci_compile_state != NULL) {\n+    if (jvmci_compile_state != nullptr) {\n@@ -1715,1 +1715,1 @@\n-  guarantee(comp != NULL, \"Compiler object must exist\");\n+  guarantee(comp != nullptr, \"Compiler object must exist\");\n@@ -1720,1 +1720,1 @@\n-    ciEnv ci_env((CompileTask*)NULL);\n+    ciEnv ci_env((CompileTask*)nullptr);\n@@ -1742,1 +1742,1 @@\n-  if (comp->is_c1() && (thread->get_buffer_blob() == NULL)) {\n+  if (comp->is_c1() && (thread->get_buffer_blob() == nullptr)) {\n@@ -1757,1 +1757,1 @@\n-  if (thread->get_buffer_blob() != NULL) {\n+  if (thread->get_buffer_blob() != nullptr) {\n@@ -1773,1 +1773,1 @@\n-    if (_c1_compile_queue != NULL) {\n+    if (_c1_compile_queue != nullptr) {\n@@ -1777,1 +1777,1 @@\n-    if (_c2_compile_queue != NULL) {\n+    if (_c2_compile_queue != nullptr) {\n@@ -1795,1 +1795,1 @@\n-  if (!LogCompilation) return NULL;\n+  if (!LogCompilation) return nullptr;\n@@ -1800,1 +1800,1 @@\n-  assert(compiler_objects != NULL, \"must be initialized at this point\");\n+  assert(compiler_objects != nullptr, \"must be initialized at this point\");\n@@ -1802,1 +1802,1 @@\n-  assert(logs != NULL, \"must be initialized at this point\");\n+  assert(logs != nullptr, \"must be initialized at this point\");\n@@ -1822,1 +1822,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1857,1 +1857,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1883,1 +1883,1 @@\n-    if (task == NULL) {\n+    if (task == nullptr) {\n@@ -1897,1 +1897,1 @@\n-          if (thread->get_buffer_blob() != NULL) {\n+          if (thread->get_buffer_blob() != nullptr) {\n@@ -1945,1 +1945,1 @@\n-    FILE* fp = NULL;\n+    FILE* fp = nullptr;\n@@ -1948,2 +1948,2 @@\n-      const char* dir = (try_temp_dir ? os::get_temp_directory() : NULL);\n-      if (dir == NULL) {\n+      const char* dir = (try_temp_dir ? os::get_temp_directory() : nullptr);\n+      if (dir == nullptr) {\n@@ -1959,1 +1959,1 @@\n-      if (fp != NULL) {\n+      if (fp != nullptr) {\n@@ -1964,1 +1964,1 @@\n-        if (log == NULL) {\n+        if (log == nullptr) {\n@@ -1970,1 +1970,1 @@\n-        if (xtty != NULL) {\n+        if (xtty != nullptr) {\n@@ -1984,1 +1984,1 @@\n-  if (CompilationLog::log() != NULL) {\n+  if (CompilationLog::log() != nullptr) {\n@@ -2048,1 +2048,1 @@\n-    if (eol == NULL) {\n+    if (eol == nullptr) {\n@@ -2073,1 +2073,1 @@\n-  assert(task != NULL, \"invariant\");\n+  assert(task != nullptr, \"invariant\");\n@@ -2086,2 +2086,2 @@\n-CompilerDirectives* DirectivesStack::_top = NULL;\n-CompilerDirectives* DirectivesStack::_bottom = NULL;\n+CompilerDirectives* DirectivesStack::_top = nullptr;\n+CompilerDirectives* DirectivesStack::_bottom = nullptr;\n@@ -2107,1 +2107,1 @@\n-  if (CompilationLog::log() != NULL) {\n+  if (CompilationLog::log() != nullptr) {\n@@ -2115,1 +2115,1 @@\n-  bool should_log = (thread->log() != NULL);\n+  bool should_log = (thread->log() != nullptr);\n@@ -2145,1 +2145,1 @@\n-  const char* failure_reason = NULL;\n+  const char* failure_reason = nullptr;\n@@ -2147,1 +2147,1 @@\n-  const char* retry_message = NULL;\n+  const char* retry_message = nullptr;\n@@ -2150,1 +2150,1 @@\n-  if (UseJVMCICompiler && comp != NULL && comp->is_jvmci()) {\n+  if (UseJVMCICompiler && comp != nullptr && comp->is_jvmci()) {\n@@ -2156,1 +2156,1 @@\n-    JVMCIRuntime *runtime = NULL;\n+    JVMCIRuntime *runtime = nullptr;\n@@ -2182,1 +2182,1 @@\n-          assert(failure_reason != NULL, \"must specify failure_reason\");\n+          assert(failure_reason != nullptr, \"must specify failure_reason\");\n@@ -2187,1 +2187,1 @@\n-      handle_compile_error(thread, task, NULL, compilable, failure_reason);\n+      handle_compile_error(thread, task, nullptr, compilable, failure_reason);\n@@ -2228,1 +2228,1 @@\n-    if (comp == NULL) {\n+    if (comp == nullptr) {\n@@ -2275,1 +2275,1 @@\n-  if (failure_reason != NULL) {\n+  if (failure_reason != nullptr) {\n@@ -2277,1 +2277,1 @@\n-    if (CompilationLog::log() != NULL) {\n+    if (CompilationLog::log() != nullptr) {\n@@ -2281,1 +2281,1 @@\n-      FormatBufferResource msg = retry_message != NULL ?\n+      FormatBufferResource msg = retry_message != nullptr ?\n@@ -2347,1 +2347,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -2561,1 +2561,1 @@\n-  if (comp == NULL) {\n+  if (comp == nullptr) {\n@@ -2569,1 +2569,1 @@\n-  return _perf_total_compilation != NULL ? _perf_total_compilation->get_value() : 0;\n+  return _perf_total_compilation != nullptr ? _perf_total_compilation->get_value() : 0;\n@@ -2590,1 +2590,1 @@\n-      if (comp != NULL) {\n+      if (comp != nullptr) {\n@@ -2648,1 +2648,1 @@\n-  if (comp != NULL) {\n+  if (comp != nullptr) {\n@@ -2653,1 +2653,1 @@\n-  if (comp != NULL) {\n+  if (comp != nullptr) {\n@@ -2685,1 +2685,1 @@\n-  if (out == NULL) out = tty;\n+  if (out == nullptr) out = tty;\n@@ -2723,1 +2723,1 @@\n-  if (out == NULL) {\n+  if (out == nullptr) {\n@@ -2769,4 +2769,4 @@\n-  Mutex*   global_lock_1   = allFun ? (should_take_Compile_lock   ? Compile_lock   : NULL) : NULL;\n-  Monitor* global_lock_2   = allFun ? (should_take_CodeCache_lock ? CodeCache_lock : NULL) : NULL;\n-  Mutex*   function_lock_1 = allFun ? NULL : (should_take_Compile_lock   ? Compile_lock    : NULL);\n-  Monitor* function_lock_2 = allFun ? NULL : (should_take_CodeCache_lock ? CodeCache_lock  : NULL);\n+  Mutex*   global_lock_1   = allFun ? (should_take_Compile_lock   ? Compile_lock   : nullptr) : nullptr;\n+  Monitor* global_lock_2   = allFun ? (should_take_CodeCache_lock ? CodeCache_lock : nullptr) : nullptr;\n+  Mutex*   function_lock_1 = allFun ? nullptr : (should_take_Compile_lock   ? Compile_lock    : nullptr);\n+  Monitor* function_lock_2 = allFun ? nullptr : (should_take_CodeCache_lock ? CodeCache_lock  : nullptr);\n@@ -2776,1 +2776,1 @@\n-  if ((global_lock_1 != NULL) || (global_lock_2 != NULL)) {\n+  if ((global_lock_1 != nullptr) || (global_lock_2 != nullptr)) {\n@@ -2785,1 +2785,1 @@\n-    if ((function_lock_1 != NULL) || (function_lock_1 != NULL)) {\n+    if ((function_lock_1 != nullptr) || (function_lock_2 != nullptr)) {\n@@ -2791,1 +2791,1 @@\n-    if ((function_lock_1 != NULL) || (function_lock_1 != NULL)) {\n+    if ((function_lock_1 != nullptr) || (function_lock_2 != nullptr)) {\n@@ -2812,1 +2812,1 @@\n-  if ((global_lock_1 != NULL) || (global_lock_2 != NULL)) {\n+  if ((global_lock_1 != nullptr) || (global_lock_2 != nullptr)) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":155,"deletions":155,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-  _block_map = new (arena()) GrowableArray<BasicBlock*>(arena(), method_len, method_len, NULL);\n+  _block_map = new (arena()) GrowableArray<BasicBlock*>(arena(), method_len, method_len, nullptr);\n@@ -135,1 +135,1 @@\n-        assert( next != NULL, \"must be a block immediately following this one.\");\n+        assert( next != nullptr, \"must be a block immediately following this one.\");\n@@ -146,1 +146,1 @@\n-    assert (current_block != NULL, \"we must have a current block\");\n+    assert (current_block != nullptr, \"we must have a current block\");\n@@ -167,1 +167,1 @@\n-          assert(dest != NULL, \"must be a block immediately following this one.\");\n+          assert(dest != nullptr, \"must be a block immediately following this one.\");\n@@ -171,1 +171,1 @@\n-        assert(dest != NULL, \"branch destination must start a block.\");\n+        assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -176,1 +176,1 @@\n-        assert(dest != NULL, \"branch destination must start a block.\");\n+        assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -181,1 +181,1 @@\n-        assert(dest != NULL, \"branch destination must start a block.\");\n+        assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -191,1 +191,1 @@\n-          assert(dest != NULL, \"branch destination must start a block.\");\n+          assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -195,1 +195,1 @@\n-            assert(dest != NULL, \"branch destination must start a block.\");\n+            assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -208,1 +208,1 @@\n-          assert(dest != NULL, \"branch destination must start a block.\");\n+          assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -213,1 +213,1 @@\n-            assert(dest != NULL, \"branch destination must start a block.\");\n+            assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -223,1 +223,1 @@\n-          assert(dest != NULL, \"branch destination must start a block.\");\n+          assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -226,1 +226,1 @@\n-          assert(jsrExit != NULL, \"jsr return bci must start a block.\");\n+          assert(jsrExit != nullptr, \"jsr return bci must start a block.\");\n@@ -233,1 +233,1 @@\n-          assert(dest != NULL, \"branch destination must start a block.\");\n+          assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -236,1 +236,1 @@\n-          assert(jsrExit != NULL, \"jsr return bci must start a block.\");\n+          assert(jsrExit != nullptr, \"jsr return bci must start a block.\");\n@@ -328,1 +328,1 @@\n-  _work_list = NULL;\n+  _work_list = nullptr;\n@@ -337,1 +337,1 @@\n-  while ((block = work_list_get()) != NULL) {\n+  while ((block = work_list_get()) != nullptr) {\n@@ -352,1 +352,1 @@\n-  if (block != NULL) {\n+  if (block != nullptr) {\n@@ -377,1 +377,1 @@\n-    while (block == NULL && t > 0) {\n+    while (block == nullptr && t > 0) {\n@@ -380,1 +380,1 @@\n-    guarantee(block != NULL, \"invalid bytecode index; must be instruction index\");\n+    guarantee(block != nullptr, \"invalid bytecode index; must be instruction index\");\n@@ -414,1 +414,1 @@\n-    new (analyzer->arena()) GrowableArray<MethodLiveness::BasicBlock*>(analyzer->arena(), 5, 0, NULL);\n+    new (analyzer->arena()) GrowableArray<MethodLiveness::BasicBlock*>(analyzer->arena(), 5, 0, nullptr);\n@@ -416,1 +416,1 @@\n-    new (analyzer->arena()) GrowableArray<MethodLiveness::BasicBlock*>(analyzer->arena(), 5, 0, NULL);\n+    new (analyzer->arena()) GrowableArray<MethodLiveness::BasicBlock*>(analyzer->arena(), 5, 0, nullptr);\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,3 +75,3 @@\n-    _class_name(NULL)\n-  , _method_name(NULL)\n-  , _signature(NULL)\n+    _class_name(nullptr)\n+  , _method_name(nullptr)\n+  , _signature(nullptr)\n@@ -83,1 +83,1 @@\n-  if (_class_name != NULL) {\n+  if (_class_name != nullptr) {\n@@ -86,1 +86,1 @@\n-  if (_method_name != NULL) {\n+  if (_method_name != nullptr) {\n@@ -89,1 +89,1 @@\n-  if (_signature != NULL) {\n+  if (_signature != nullptr) {\n@@ -106,1 +106,1 @@\n-  bool have_colon = (colon != NULL);\n+  bool have_colon = (colon != nullptr);\n@@ -117,1 +117,1 @@\n-    if (pos != NULL) {\n+    if (pos != nullptr) {\n@@ -133,1 +133,1 @@\n-    if (pos != NULL) {\n+    if (pos != nullptr) {\n@@ -213,1 +213,1 @@\n-    return strstr(candidate_string, match_string) != NULL;\n+    return strstr(candidate_string, match_string) != nullptr;\n@@ -241,1 +241,1 @@\n-  if (strstr(name, \"*\") != NULL) {\n+  if (strstr(name, \"*\") != nullptr) {\n@@ -267,1 +267,1 @@\n-  assert(error_msg == NULL, \"Dont call here with error_msg already set\");\n+  assert(error_msg == nullptr, \"Dont call here with error_msg already set\");\n@@ -270,1 +270,1 @@\n-    assert(error_msg != NULL, \"Message must be set if parsing failed\");\n+    assert(error_msg != nullptr, \"Message must be set if parsing failed\");\n@@ -291,1 +291,1 @@\n-        strstr(line + bytes_read, method_name) == NULL) {\n+        strstr(line + bytes_read, method_name) == nullptr) {\n@@ -297,2 +297,2 @@\n-    if ((strchr(class_name, JVM_SIGNATURE_SPECIAL) != NULL) ||\n-        (strchr(class_name, JVM_SIGNATURE_ENDSPECIAL) != NULL)) {\n+    if ((strchr(class_name, JVM_SIGNATURE_SPECIAL) != nullptr) ||\n+        (strchr(class_name, JVM_SIGNATURE_ENDSPECIAL) != nullptr)) {\n@@ -303,2 +303,2 @@\n-    if ((strchr(method_name, JVM_SIGNATURE_SPECIAL) != NULL) ||\n-        (strchr(method_name, JVM_SIGNATURE_ENDSPECIAL) != NULL)) {\n+    if ((strchr(method_name, JVM_SIGNATURE_SPECIAL) != nullptr) ||\n+        (strchr(method_name, JVM_SIGNATURE_ENDSPECIAL) != nullptr)) {\n@@ -314,1 +314,1 @@\n-      assert(error_msg != NULL, \"Must have been set by check_mode()\");\n+      assert(error_msg != nullptr, \"Must have been set by check_mode()\");\n@@ -319,1 +319,1 @@\n-    Symbol* signature = NULL;\n+    Symbol* signature = nullptr;\n@@ -332,1 +332,1 @@\n-        if (strchr(sig, '*') != NULL) {\n+        if (strchr(sig, '*') != nullptr) {\n@@ -357,1 +357,1 @@\n-      ((this->signature() == NULL) || match(signature, this->signature(), Prefix))) {\n+      ((this->signature() == nullptr) || match(signature, this->signature(), Prefix))) {\n@@ -381,1 +381,1 @@\n-  if (signature() != NULL) {\n+  if (signature() != nullptr) {\n@@ -387,1 +387,1 @@\n-  assert(error_msg == NULL, \"Don't call here with error_msg already set\");\n+  assert(error_msg == nullptr, \"Don't call here with error_msg already set\");\n@@ -390,1 +390,1 @@\n-  if (error_msg != NULL) {\n+  if (error_msg != nullptr) {\n@@ -392,1 +392,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -401,1 +401,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -408,1 +408,1 @@\n-  for (BasicMatcher* current = this; current != NULL; current = current->next()) {\n+  for (BasicMatcher* current = this; current != nullptr; current = current->next()) {\n@@ -426,1 +426,1 @@\n-  assert(error_msg == NULL, \"Dont call here with error_msg already set\");\n+  assert(error_msg == nullptr, \"Dont call here with error_msg already set\");\n@@ -429,1 +429,1 @@\n-  if (error_msg != NULL) {\n+  if (error_msg != nullptr) {\n@@ -431,1 +431,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -437,1 +437,1 @@\n-  for (InlineMatcher* current = this; current != NULL; current = current->next()) {\n+  for (InlineMatcher* current = this; current != nullptr; current = current->next()) {\n@@ -457,1 +457,1 @@\n-     return NULL;\n+     return nullptr;\n@@ -461,1 +461,1 @@\n-   assert(error_msg == NULL, \"error_msg must not be set yet\");\n+   assert(error_msg == nullptr, \"error_msg must not be set yet\");\n@@ -463,3 +463,3 @@\n-   if (im == NULL) {\n-     assert(error_msg != NULL, \"Must have error message\");\n-     return NULL;\n+   if (im == nullptr) {\n+     assert(error_msg != nullptr, \"Must have error message\");\n+     return nullptr;\n@@ -477,1 +477,1 @@\n-   if(_class_name != NULL) {\n+   if(_class_name != nullptr) {\n@@ -481,1 +481,1 @@\n-   if (_method_name != NULL) {\n+   if (_method_name != nullptr) {\n@@ -485,1 +485,1 @@\n-   if (_signature != NULL) {\n+   if (_signature != nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n-static inline derived_pointer to_derived_pointer(oop obj) {\n-  return static_cast<derived_pointer>(cast_from_oop<intptr_t>(obj));\n+static inline derived_pointer to_derived_pointer(intptr_t obj) {\n+  return static_cast<derived_pointer>(obj);\n@@ -418,1 +418,1 @@\n-    derived_pointer derived_base = to_derived_pointer(*base);\n+  derived_pointer derived_base = to_derived_pointer(*reinterpret_cast<intptr_t*>(base));\n@@ -447,1 +447,1 @@\n-  assert(derived_oop_fn != NULL, \"sanity\");\n+  assert(derived_oop_fn != nullptr, \"sanity\");\n@@ -510,1 +510,1 @@\n-  assert(cb != NULL, \"no codeblob\");\n+  assert(cb != nullptr, \"no codeblob\");\n@@ -512,1 +512,1 @@\n-  assert( reg_map->_update_for_id == NULL || fr->is_older(reg_map->_update_for_id),\n+  assert( reg_map->_update_for_id == nullptr || fr->is_older(reg_map->_update_for_id),\n@@ -529,1 +529,1 @@\n-  assert(cb == NULL || cb->is_compiled_by_c1() || cb->is_compiled_by_jvmci() || !cb->is_runtime_stub() ||\n+  assert(cb == nullptr || cb->is_compiled_by_c1() || cb->is_compiled_by_jvmci() || !cb->is_runtime_stub() ||\n@@ -540,1 +540,1 @@\n-  assert(cb != NULL, \"no codeblob\");\n+  assert(cb != nullptr, \"no codeblob\");\n@@ -542,1 +542,1 @@\n-  assert(map != NULL, \"no ptr map found\");\n+  assert(map != nullptr, \"no ptr map found\");\n@@ -576,1 +576,1 @@\n-  if (reg_map != NULL) {\n+  if (reg_map != nullptr) {\n@@ -644,1 +644,1 @@\n-  const ImmutableOopMap* last = NULL;\n+  const ImmutableOopMap* last = nullptr;\n@@ -708,1 +708,1 @@\n-  ImmutableOopMapPair* last  = NULL;\n+  ImmutableOopMapPair* last  = nullptr;\n@@ -718,1 +718,1 @@\n-  guarantee(last != NULL, \"last may not be null\");\n+  guarantee(last != nullptr, \"last may not be null\");\n@@ -751,1 +751,1 @@\n-ImmutableOopMapBuilder::ImmutableOopMapBuilder(const OopMapSet* set) : _set(set), _empty(NULL), _last(NULL), _empty_offset(-1), _last_offset(-1), _offset(0), _required(-1), _new_set(NULL) {\n+ImmutableOopMapBuilder::ImmutableOopMapBuilder(const OopMapSet* set) : _set(set), _empty(nullptr), _last(nullptr), _empty_offset(-1), _last_offset(-1), _offset(0), _required(-1), _new_set(nullptr) {\n@@ -820,1 +820,1 @@\n-    ImmutableOopMapPair* pair = NULL;\n+    ImmutableOopMapPair* pair = nullptr;\n@@ -889,1 +889,1 @@\n-    _location(location), _offset(offset), _next(NULL) {}\n+    _location(location), _offset(offset), _next(nullptr) {}\n@@ -899,1 +899,1 @@\n-DerivedPointerTable::Entry::List* DerivedPointerTable::Entry::_list = NULL;\n+DerivedPointerTable::Entry::List* DerivedPointerTable::Entry::_list = nullptr;\n@@ -903,1 +903,1 @@\n-  return Entry::_list == NULL || Entry::_list->empty();\n+  return Entry::_list == nullptr || Entry::_list->empty();\n@@ -912,1 +912,1 @@\n-  if (Entry::_list == NULL) {\n+  if (Entry::_list == nullptr) {\n@@ -925,1 +925,1 @@\n-  assert(Entry::_list != NULL, \"list must exist\");\n+  assert(Entry::_list != nullptr, \"list must exist\");\n@@ -927,1 +927,1 @@\n-  intptr_t offset = *derived_loc - to_derived_pointer(*base_loc);\n+  intptr_t offset = *derived_loc - to_derived_pointer(*reinterpret_cast<intptr_t*>(base_loc));\n@@ -947,1 +947,1 @@\n-  assert(Entry::_list != NULL, \"list must exist\");\n+  assert(Entry::_list != nullptr, \"list must exist\");\n@@ -949,1 +949,1 @@\n-  while (entries != NULL) {\n+  while (entries != nullptr) {\n@@ -958,1 +958,1 @@\n-    derived_pointer derived_base = to_derived_pointer(base);\n+    derived_pointer derived_base = to_derived_pointer(cast_from_oop<intptr_t>(base));\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,2 @@\n-PSOldGen*               ParCompactionManager::_old_gen = NULL;\n-ParCompactionManager**  ParCompactionManager::_manager_array = NULL;\n+PSOldGen*               ParCompactionManager::_old_gen = nullptr;\n+ParCompactionManager**  ParCompactionManager::_manager_array = nullptr;\n@@ -46,3 +46,3 @@\n-ParCompactionManager::OopTaskQueueSet*      ParCompactionManager::_oop_task_queues = NULL;\n-ParCompactionManager::ObjArrayTaskQueueSet* ParCompactionManager::_objarray_task_queues = NULL;\n-ParCompactionManager::RegionTaskQueueSet*   ParCompactionManager::_region_task_queues = NULL;\n+ParCompactionManager::OopTaskQueueSet*      ParCompactionManager::_oop_task_queues = nullptr;\n+ParCompactionManager::ObjArrayTaskQueueSet* ParCompactionManager::_objarray_task_queues = nullptr;\n+ParCompactionManager::RegionTaskQueueSet*   ParCompactionManager::_region_task_queues = nullptr;\n@@ -50,4 +50,4 @@\n-ObjectStartArray*    ParCompactionManager::_start_array = NULL;\n-ParMarkBitMap*       ParCompactionManager::_mark_bitmap = NULL;\n-GrowableArray<size_t >* ParCompactionManager::_shadow_region_array = NULL;\n-Monitor*                ParCompactionManager::_shadow_region_monitor = NULL;\n+ObjectStartArray*    ParCompactionManager::_start_array = nullptr;\n+ParMarkBitMap*       ParCompactionManager::_mark_bitmap = nullptr;\n+GrowableArray<size_t >* ParCompactionManager::_shadow_region_array = nullptr;\n+Monitor*                ParCompactionManager::_shadow_region_monitor = nullptr;\n@@ -68,1 +68,1 @@\n-  assert(ParallelScavengeHeap::heap() != NULL,\n+  assert(ParallelScavengeHeap::heap() != nullptr,\n@@ -75,1 +75,1 @@\n-  assert(_manager_array == NULL, \"Attempt to initialize twice\");\n+  assert(_manager_array == nullptr, \"Attempt to initialize twice\");\n@@ -85,1 +85,1 @@\n-    oop_task_queues()->register_queue(i, _manager_array[i]->marking_stack());\n+    oop_task_queues()->register_queue(i, _manager_array[i]->oop_stack());\n@@ -115,1 +115,1 @@\n-  assert(_manager_array != NULL, \"Sanity\");\n+  assert(_manager_array != nullptr, \"Sanity\");\n@@ -121,2 +121,2 @@\n-  while (marking_stack()->pop_overflow(obj)) {\n-    if (!marking_stack()->try_push_to_taskqueue(obj)) {\n+  while (oop_stack()->pop_overflow(obj)) {\n+    if (!oop_stack()->try_push_to_taskqueue(obj)) {\n@@ -126,1 +126,1 @@\n-  while (marking_stack()->pop_local(obj)) {\n+  while (oop_stack()->pop_local(obj)) {\n@@ -174,1 +174,1 @@\n-    assert(addr != NULL, \"expected a deferred object\");\n+    assert(addr != nullptr, \"expected a deferred object\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-ReferenceProcessor* PSParallelCompact::_ref_processor = NULL;\n+ReferenceProcessor* PSParallelCompact::_ref_processor = nullptr;\n@@ -155,1 +155,1 @@\n-  assert(destination != NULL, \"invalid destination argument\");\n+  assert(destination != nullptr, \"invalid destination argument\");\n@@ -162,2 +162,2 @@\n-  assert(_dest_region_addr == NULL, \"should have been cleared\");\n-  assert(_first_src_addr == NULL, \"should have been cleared\");\n+  assert(_dest_region_addr == nullptr, \"should have been cleared\");\n+  assert(_first_src_addr == nullptr, \"should have been cleared\");\n@@ -196,1 +196,1 @@\n-  _destination = NULL;\n+  _destination = nullptr;\n@@ -198,2 +198,2 @@\n-  _dest_region_addr = NULL;\n-  _first_src_addr = NULL;\n+  _dest_region_addr = nullptr;\n+  _first_src_addr = nullptr;\n@@ -208,1 +208,1 @@\n-  assert(_destination == NULL, \"not clear\");\n+  assert(_destination == nullptr, \"not clear\");\n@@ -210,2 +210,2 @@\n-  assert(_dest_region_addr == NULL, \"not clear\");\n-  assert(_first_src_addr == NULL, \"not clear\");\n+  assert(_dest_region_addr == nullptr, \"not clear\");\n+  assert(_first_src_addr == nullptr, \"not clear\");\n@@ -418,3 +418,3 @@\n-  _region_start(NULL),\n-  DEBUG_ONLY(_region_end(NULL) COMMA)\n-  _region_vspace(NULL),\n+  _region_start(nullptr),\n+  DEBUG_ONLY(_region_end(nullptr) COMMA)\n+  _region_vspace(nullptr),\n@@ -422,1 +422,1 @@\n-  _region_data(NULL),\n+  _region_data(nullptr),\n@@ -424,2 +424,2 @@\n-  _block_vspace(NULL),\n-  _block_data(NULL),\n+  _block_vspace(nullptr),\n+  _block_data(nullptr),\n@@ -449,1 +449,1 @@\n-  const size_t rs_align = page_sz == (size_t) os::vm_page_size() ? 0 :\n+  const size_t rs_align = page_sz == os::vm_page_size() ? 0 :\n@@ -696,1 +696,1 @@\n-  HeapWord* const source_next_val = source_next == NULL ? NULL : *source_next;\n+  HeapWord* const source_next_val = source_next == nullptr ? nullptr : *source_next;\n@@ -717,1 +717,1 @@\n-        assert(source_next != NULL, \"source_next is NULL when splitting\");\n+        assert(source_next != nullptr, \"source_next is null when splitting\");\n@@ -779,1 +779,1 @@\n-  assert(addr != NULL, \"Should detect NULL oop earlier\");\n+  assert(addr != nullptr, \"Should detect null oop earlier\");\n@@ -841,2 +841,1 @@\n-unsigned int        PSParallelCompact::_total_invocations = 0;\n-CollectorCounters*  PSParallelCompact::_counters = NULL;\n+CollectorCounters*  PSParallelCompact::_counters = nullptr;\n@@ -967,4 +966,0 @@\n-  CodeCache::arm_all_nmethods();\n-\n-  \/\/ We need to track unique mark sweep invocations as well.\n-  _total_invocations++;\n@@ -1074,2 +1069,3 @@\n-  assert(total_invocations() >= _maximum_compaction_gc_num, \"sanity\");\n-  const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;\n+  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n+  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n+  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n@@ -1078,1 +1074,1 @@\n-    _maximum_compaction_gc_num = total_invocations();\n+    _maximum_compaction_gc_num = total_invocations;\n@@ -1259,1 +1255,1 @@\n-    assert(dest != NULL, \"sanity\");\n+    assert(dest != nullptr, \"sanity\");\n@@ -1289,1 +1285,1 @@\n-    assert(dest != NULL, \"sanity\");\n+    assert(dest != nullptr, \"sanity\");\n@@ -1314,4 +1310,4 @@\n-  assert(cp != NULL, \"sanity\");\n-  assert(bottom != NULL, \"sanity\");\n-  assert(top != NULL, \"sanity\");\n-  assert(new_top != NULL, \"sanity\");\n+  assert(cp != nullptr, \"sanity\");\n+  assert(bottom != nullptr, \"sanity\");\n+  assert(top != nullptr, \"sanity\");\n+  assert(new_top != nullptr, \"sanity\");\n@@ -1373,2 +1369,3 @@\n-  assert(total_invocations() >= _maximum_compaction_gc_num, \"sanity\");\n-  const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;\n+  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n+  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n+  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n@@ -1376,1 +1373,1 @@\n-    total_invocations() == HeapFirstMaximumCompactionCount;\n+    total_invocations == HeapFirstMaximumCompactionCount;\n@@ -1378,1 +1375,1 @@\n-    _maximum_compaction_gc_num = total_invocations();\n+    _maximum_compaction_gc_num = total_invocations;\n@@ -1429,1 +1426,1 @@\n-                                          space->bottom(), space->top(), NULL,\n+                                          space->bottom(), space->top(), nullptr,\n@@ -1498,1 +1495,1 @@\n-    assert(start_array(id) != NULL, \"sanity\");\n+    assert(start_array(id) != nullptr, \"sanity\");\n@@ -1538,1 +1535,1 @@\n-                              dense_prefix_end, space->top(), NULL,\n+                              dense_prefix_end, space->top(), nullptr,\n@@ -1632,1 +1629,1 @@\n-                                          NULL,\n+                                          nullptr,\n@@ -1641,1 +1638,1 @@\n-      HeapWord* next_src_addr = NULL;\n+      HeapWord* next_src_addr = nullptr;\n@@ -1648,1 +1645,1 @@\n-      assert(next_src_addr != NULL, \"sanity\");\n+      assert(next_src_addr != nullptr, \"sanity\");\n@@ -1660,1 +1657,1 @@\n-                                     NULL,\n+                                     nullptr,\n@@ -1710,1 +1707,1 @@\n-  assert(ref_processor() != NULL, \"Sanity\");\n+  assert(ref_processor() != nullptr, \"Sanity\");\n@@ -1751,1 +1748,1 @@\n-    GCTraceTime(Info, gc) tm(\"Pause Full\", NULL, gc_cause, true);\n+    GCTraceTime(Info, gc) tm(\"Pause Full\", nullptr, gc_cause, true);\n@@ -1943,1 +1940,1 @@\n-    oop obj = NULL;\n+    oop obj = nullptr;\n@@ -1980,1 +1977,1 @@\n-    Threads::possibly_parallel_threads_do(true \/*parallel *\/, &closure);\n+    Threads::possibly_parallel_threads_do(true \/* is_par *\/, &closure);\n@@ -2228,1 +2225,1 @@\n-  explicit TaskQueue(uint size) : _counter(0), _size(size), _insert_index(0), _backing_array(NULL) {\n+  explicit TaskQueue(uint size) : _counter(0), _size(size), _insert_index(0), _backing_array(nullptr) {\n@@ -2607,1 +2604,1 @@\n-  if (start_array != NULL) {\n+  if (start_array != nullptr) {\n@@ -3101,1 +3098,1 @@\n-  assert(destination() != NULL, \"sanity\");\n+  assert(destination() != nullptr, \"sanity\");\n@@ -3113,1 +3110,1 @@\n-  if (_start_array != NULL) {\n+  if (_start_array != nullptr) {\n@@ -3124,1 +3121,1 @@\n-  assert(oopDesc::is_oop_or_null(moved_oop), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(moved_oop));\n+  assert(oopDesc::is_oop_or_null(moved_oop), \"Expected an oop or null at \" PTR_FORMAT, p2i(moved_oop));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":53,"deletions":56,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,5 +47,5 @@\n-PaddedEnd<PSPromotionManager>* PSPromotionManager::_manager_array = NULL;\n-PSPromotionManager::PSScannerTasksQueueSet* PSPromotionManager::_stack_array_depth = NULL;\n-PreservedMarksSet*             PSPromotionManager::_preserved_marks_set = NULL;\n-PSOldGen*                      PSPromotionManager::_old_gen = NULL;\n-MutableSpace*                  PSPromotionManager::_young_space = NULL;\n+PaddedEnd<PSPromotionManager>* PSPromotionManager::_manager_array = nullptr;\n+PSPromotionManager::PSScannerTasksQueueSet* PSPromotionManager::_stack_array_depth = nullptr;\n+PreservedMarksSet*             PSPromotionManager::_preserved_marks_set = nullptr;\n+PSOldGen*                      PSPromotionManager::_old_gen = nullptr;\n+MutableSpace*                  PSPromotionManager::_young_space = nullptr;\n@@ -63,1 +63,1 @@\n-  assert(_manager_array == NULL, \"Attempt to initialize twice\");\n+  assert(_manager_array == nullptr, \"Attempt to initialize twice\");\n@@ -75,1 +75,1 @@\n-  assert(_preserved_marks_set == NULL, \"Attempt to initialize twice\");\n+  assert(_preserved_marks_set == nullptr, \"Attempt to initialize twice\");\n@@ -94,1 +94,1 @@\n-  assert(_manager_array != NULL, \"Sanity\");\n+  assert(_manager_array != nullptr, \"Sanity\");\n@@ -99,1 +99,1 @@\n-  assert(_manager_array != NULL, \"Sanity\");\n+  assert(_manager_array != nullptr, \"Sanity\");\n@@ -197,1 +197,1 @@\n-  _preserved_marks = NULL;\n+  _preserved_marks = nullptr;\n@@ -222,1 +222,1 @@\n-  assert(_preserved_marks == NULL, \"do not set it twice\");\n+  assert(_preserved_marks == nullptr, \"do not set it twice\");\n@@ -231,1 +231,2 @@\n-  totally_drain = totally_drain || (_target_stack_size == 0);\n+  const uint threshold = totally_drain ? 0\n+                                       : _target_stack_size;\n@@ -240,9 +241,1 @@\n-      process_popped_location_depth(task);\n-    }\n-\n-    if (totally_drain) {\n-      while (tq->pop_local(task)) {\n-        process_popped_location_depth(task);\n-      }\n-    } else {\n-      while (tq->size() > _target_stack_size && tq->pop_local(task)) {\n+      if (!tq->try_push_to_taskqueue(task)) {\n@@ -252,1 +245,5 @@\n-  } while ((totally_drain && !tq->taskqueue_empty()) || !tq->overflow_empty());\n+\n+    while (tq->pop_local(task, threshold)) {\n+      process_popped_location_depth(task);\n+    }\n+  } while (!tq->overflow_empty());\n@@ -335,1 +332,1 @@\n-  if (obj->forward_to_atomic(obj, obj_mark) == NULL) {\n+  if (obj->forward_to_atomic(obj, obj_mark) == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-BarrierSet* BarrierSet::_barrier_set = NULL;\n+BarrierSet* BarrierSet::_barrier_set = nullptr;\n@@ -41,1 +41,1 @@\n-  assert(_barrier_set == NULL, \"Already initialized\");\n+  assert(_barrier_set == nullptr, \"Already initialized\");\n@@ -86,1 +86,1 @@\n-  if (barrier_set_nmethod != NULL) {\n+  if (barrier_set_nmethod != nullptr) {\n@@ -97,1 +97,1 @@\n-  if (barrier_set_stack_chunk != NULL) {\n+  if (barrier_set_stack_chunk != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-    return NOT_ZERO(new BarrierSetAssemblerT()) ZERO_ONLY(NULL);\n+    return NOT_ZERO(new BarrierSetAssemblerT()) ZERO_ONLY(nullptr);\n@@ -115,1 +115,1 @@\n-    return COMPILER1_PRESENT(new BarrierSetC1T()) NOT_COMPILER1(NULL);\n+    return COMPILER1_PRESENT(new BarrierSetC1T()) NOT_COMPILER1(nullptr);\n@@ -120,1 +120,1 @@\n-    return COMPILER2_PRESENT(new BarrierSetC2T()) NOT_COMPILER2(NULL);\n+    return COMPILER2_PRESENT(new BarrierSetC2T()) NOT_COMPILER2(nullptr);\n@@ -157,1 +157,1 @@\n-    assert(_barrier_set_assembler != NULL, \"should be set\");\n+    assert(_barrier_set_assembler != nullptr, \"should be set\");\n@@ -162,1 +162,1 @@\n-    assert(_barrier_set_c1 != NULL, \"should be set\");\n+    assert(_barrier_set_c1 != nullptr, \"should be set\");\n@@ -167,1 +167,1 @@\n-    assert(_barrier_set_c2 != NULL, \"should be set\");\n+    assert(_barrier_set_c2 != nullptr, \"should be set\");\n@@ -176,1 +176,1 @@\n-    assert(_barrier_set_stack_chunk != NULL, \"should be set\");\n+    assert(_barrier_set_stack_chunk != nullptr, \"should be set\");\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    Raw::oop_arraycopy(NULL, 0, src, NULL, 0, dst, length);\n+    Raw::oop_arraycopy(nullptr, 0, src, nullptr, 0, dst, length);\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  return _ctl == NULL ? _kit->control() : _ctl;\n+  return _ctl == nullptr ? _kit->control() : _ctl;\n@@ -92,3 +92,0 @@\n-  bool in_native = (decorators & IN_NATIVE) != 0;\n-  assert(!in_native || (unsafe && !access.is_oop()), \"not supported yet\");\n-\n@@ -109,1 +106,2 @@\n-                                 access.addr().type(), mo, requires_atomic_access, unaligned, mismatched, unsafe);\n+                                 access.addr().type(), mo, requires_atomic_access, unaligned,\n+                                 mismatched, unsafe, access.barrier_data());\n@@ -127,0 +125,1 @@\n+    st->set_barrier_data(access.barrier_data());\n@@ -151,2 +150,0 @@\n-  bool in_native = (decorators & IN_NATIVE) != 0;\n-\n@@ -160,1 +157,1 @@\n-    Node* control = control_dependent ? parse_access.control() : NULL;\n+    Node* control = control_dependent ? parse_access.control() : nullptr;\n@@ -177,1 +174,1 @@\n-    Node* control = control_dependent ? opt_access.ctl() : NULL;\n+    Node* control = control_dependent ? opt_access.ctl() : nullptr;\n@@ -196,2 +193,2 @@\n-    _access(access), _leading_membar(NULL) {\n-    GraphKit* kit = NULL;\n+    _access(access), _leading_membar(nullptr) {\n+    GraphKit* kit = nullptr;\n@@ -212,1 +209,1 @@\n-      assert(kit != NULL, \"unsupported at optimization time\");\n+      assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -231,1 +228,1 @@\n-        assert(kit != NULL, \"unsupported at optimization time\");\n+        assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -241,1 +238,1 @@\n-        assert(kit != NULL, \"unsupported at optimization time\");\n+        assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -247,1 +244,1 @@\n-      assert(kit != NULL, \"unsupported at optimization time\");\n+      assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -260,1 +257,1 @@\n-    GraphKit* kit = NULL;\n+    GraphKit* kit = nullptr;\n@@ -281,1 +278,1 @@\n-      assert(kit != NULL, \"unsupported at optimization time\");\n+      assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -285,1 +282,1 @@\n-        if (_leading_membar != NULL) {\n+        if (_leading_membar != nullptr) {\n@@ -292,1 +289,1 @@\n-        assert(kit != NULL, \"unsupported at optimization time\");\n+        assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -295,1 +292,1 @@\n-        if (_leading_membar != NULL) {\n+        if (_leading_membar != nullptr) {\n@@ -301,1 +298,1 @@\n-        assert(kit != NULL, \"unsupported at optimization time\");\n+        assert(kit != nullptr, \"unsupported at optimization time\");\n@@ -303,1 +300,1 @@\n-        assert(_leading_membar == NULL || support_IRIW_for_not_multiple_copy_atomic_cpu, \"no leading membar expected\");\n+        assert(_leading_membar == nullptr || support_IRIW_for_not_multiple_copy_atomic_cpu, \"no leading membar expected\");\n@@ -400,1 +397,1 @@\n-  assert(load_store != NULL, \"must pin atomic op\");\n+  assert(load_store != nullptr, \"must pin atomic op\");\n@@ -419,1 +416,1 @@\n-  Node* load_store = NULL;\n+  Node* load_store = nullptr;\n@@ -477,1 +474,1 @@\n-  Node* load_store = NULL;\n+  Node* load_store = nullptr;\n@@ -552,1 +549,1 @@\n-  Node* load_store = NULL;\n+  Node* load_store = nullptr;\n@@ -599,1 +596,1 @@\n-  Node* load_store = NULL;\n+  Node* load_store = nullptr;\n@@ -779,1 +776,1 @@\n-  address     copyfunc_addr = phase->basictype2arraycopy(T_LONG, NULL, NULL, true, copyfunc_name, true);\n+  address     copyfunc_addr = phase->basictype2arraycopy(T_LONG, nullptr, nullptr, true, copyfunc_name, true);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":26,"deletions":29,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    _raw_access(NULL),\n+    _raw_access(nullptr),\n@@ -180,1 +180,1 @@\n-    _memory(NULL),\n+    _memory(nullptr),\n@@ -249,1 +249,1 @@\n-  virtual Node* ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const { return NULL; }\n+  virtual Node* ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const { return nullptr; }\n@@ -277,1 +277,1 @@\n-  virtual void* create_barrier_state(Arena* comp_arena) const { return NULL; }\n+  virtual void* create_barrier_state(Arena* comp_arena) const { return nullptr; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-   if (card_table_base != NULL) {\n+   if (card_table_base != nullptr) {\n@@ -61,2 +61,2 @@\n-  \/\/ No store check needed if we're storing a NULL.\n-  if (val != NULL && val->is_Con()) {\n+  \/\/ No store check needed if we're storing a null.\n+  if (val != nullptr && val->is_Con()) {\n@@ -86,1 +86,1 @@\n-  assert(adr != NULL, \"\");\n+  assert(adr != nullptr, \"\");\n@@ -139,2 +139,2 @@\n-    Node* no_particular_value = NULL;\n-    Node* no_particular_field = NULL;\n+    Node* no_particular_value = nullptr;\n+    Node* no_particular_field = nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-    assert(heap != NULL, \"Uninitialized heap\");\n+    assert(heap != nullptr, \"Uninitialized heap\");\n@@ -281,1 +281,1 @@\n-  DEBUG_ONLY(bool is_in_or_null(const void* p) const { return p == NULL || is_in(p); })\n+  DEBUG_ONLY(bool is_in_or_null(const void* p) const { return p == nullptr || is_in(p); })\n@@ -418,1 +418,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -494,1 +494,1 @@\n-  \/\/ method returns NULL, cleanup tasks are done serially in the VMThread. See\n+  \/\/ method returns null, cleanup tasks are done serially in the VMThread. See\n@@ -502,1 +502,1 @@\n-  virtual WorkerThreads* safepoint_workers() { return NULL; }\n+  virtual WorkerThreads* safepoint_workers() { return nullptr; }\n@@ -505,5 +505,5 @@\n-  \/\/ and Release*Critical() family of functions. If supported, the GC\n-  \/\/ must guarantee that pinned objects never move.\n-  virtual bool supports_object_pinning() const;\n-  virtual oop pin_object(JavaThread* thread, oop obj);\n-  virtual void unpin_object(JavaThread* thread, oop obj);\n+  \/\/ and Release*Critical() family of functions. The GC must guarantee\n+  \/\/ that pinned objects never move and don't get reclaimed as garbage.\n+  \/\/ These functions are potentially safepointing.\n+  virtual void pin_object(JavaThread* thread, oop obj) = 0;\n+  virtual void unpin_object(JavaThread* thread, oop obj) = 0;\n@@ -517,1 +517,1 @@\n-  virtual HeapWord* allocate_loaded_archive_space(size_t size) { return NULL; }\n+  virtual HeapWord* allocate_loaded_archive_space(size_t size) { return nullptr; }\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-    *obj_ptr = NULL;\n+    *obj_ptr = nullptr;\n@@ -121,1 +121,1 @@\n-  if (obj() != NULL) {\n+  if (obj() != nullptr) {\n@@ -243,1 +243,1 @@\n-    if (klass != NULL && klass->name() != NULL) {\n+    if (klass != nullptr && klass->name() != nullptr) {\n@@ -259,1 +259,1 @@\n-  if (mem == NULL) {\n+  if (mem == nullptr) {\n@@ -275,1 +275,1 @@\n-  if (mem != NULL) {\n+  if (mem != nullptr) {\n@@ -288,1 +288,1 @@\n-  HeapWord* mem = NULL;\n+  HeapWord* mem = nullptr;\n@@ -299,1 +299,1 @@\n-    if (mem != NULL) {\n+    if (mem != nullptr) {\n@@ -308,1 +308,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -318,1 +318,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -325,1 +325,1 @@\n-  if (mem == NULL) {\n+  if (mem == nullptr) {\n@@ -330,1 +330,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -362,1 +362,1 @@\n-    if (mem != NULL) {\n+    if (mem != nullptr) {\n@@ -374,1 +374,1 @@\n-    if (mem != NULL) {\n+    if (mem != nullptr) {\n@@ -383,1 +383,1 @@\n-  oop obj = NULL;\n+  oop obj = nullptr;\n@@ -387,1 +387,1 @@\n-    if (mem != NULL) {\n+    if (mem != nullptr) {\n@@ -391,2 +391,2 @@\n-      \/\/ so reset it to NULL if mem is NULL.\n-      obj = NULL;\n+      \/\/ so reset it to null if mem is null.\n+      obj = nullptr;\n@@ -399,1 +399,1 @@\n-  assert(mem != NULL, \"cannot initialize NULL object\");\n+  assert(mem != nullptr, \"cannot initialize null object\");\n@@ -407,1 +407,1 @@\n-  assert(mem != NULL, \"NULL object pointer\");\n+  assert(mem != nullptr, \"null object pointer\");\n@@ -410,1 +410,1 @@\n-  \/\/ object zeroing are visible before setting the klass non-NULL, for\n+  \/\/ object zeroing are visible before setting the klass non-null, for\n@@ -438,1 +438,1 @@\n-  \/\/ non-NULL klass field indicates that the object is parsable by\n+  \/\/ non-null klass field indicates that the object is parsable by\n@@ -450,1 +450,1 @@\n-  \/\/ non-NULL _klass field indicates that the object is parsable by\n+  \/\/ non-null _klass field indicates that the object is parsable by\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-                 NULL \/* barrier_set_nmethod *\/,\n-                 NULL \/* barrier_set_stack_chunk *\/,\n+                 nullptr \/* barrier_set_nmethod *\/,\n+                 nullptr \/* barrier_set_stack_chunk *\/,\n@@ -52,1 +52,1 @@\n-  inline void write_ref_field_post(T *addr, oop new_value) {}\n+  inline void write_ref_field_post(T *addr) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  bs->template write_ref_field_post<decorators>(addr, value);\n+  bs->template write_ref_field_post<decorators>(addr);\n@@ -78,1 +78,1 @@\n-    bs->template write_ref_field_post<decorators>(addr, new_value);\n+    bs->template write_ref_field_post<decorators>(addr);\n@@ -90,1 +90,1 @@\n-  bs->template write_ref_field_post<decorators>(addr, new_value);\n+  bs->template write_ref_field_post<decorators>(addr);\n@@ -121,1 +121,1 @@\n-    Raw::oop_arraycopy(NULL, 0, src_raw, NULL, 0, dst_raw, length);\n+    Raw::oop_arraycopy(nullptr, 0, src_raw, nullptr, 0, dst_raw, length);\n@@ -124,1 +124,1 @@\n-    assert(dst_obj != NULL, \"better have an actual oop\");\n+    assert(dst_obj != nullptr, \"better have an actual oop\");\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-  : _iu_barriers(new (comp_arena) GrowableArray<ShenandoahIUBarrierNode*>(comp_arena, 8,  0, NULL)),\n-    _load_reference_barriers(new (comp_arena) GrowableArray<ShenandoahLoadReferenceBarrierNode*>(comp_arena, 8,  0, NULL)) {\n+  : _iu_barriers(new (comp_arena) GrowableArray<ShenandoahIUBarrierNode*>(comp_arena, 8,  0, nullptr)),\n+    _load_reference_barriers(new (comp_arena) GrowableArray<ShenandoahLoadReferenceBarrierNode*>(comp_arena, 8,  0, nullptr)) {\n@@ -110,1 +110,1 @@\n-  if (alloc == NULL) {\n+  if (alloc == nullptr) {\n@@ -126,1 +126,1 @@\n-      if (st_base == NULL) {\n+      if (st_base == nullptr) {\n@@ -166,1 +166,1 @@\n-        \/\/ Check that the initialization is storing NULL so that no previous store\n+        \/\/ Check that the initialization is storing null so that no previous store\n@@ -171,1 +171,1 @@\n-        if (captured_store == NULL || captured_store == st_init->zero_memory()) {\n+        if (captured_store == nullptr || captured_store == st_init->zero_memory()) {\n@@ -202,4 +202,3 @@\n-    assert(obj != NULL, \"must have a base\");\n-    assert(adr != NULL, \"where are loading from?\");\n-    assert(pre_val == NULL, \"loaded already?\");\n-    assert(val_type != NULL, \"need a type\");\n+    assert(adr != nullptr, \"where are loading from?\");\n+    assert(pre_val == nullptr, \"loaded already?\");\n+    assert(val_type != nullptr, \"need a type\");\n@@ -214,1 +213,1 @@\n-    assert(pre_val != NULL, \"must be loaded already\");\n+    assert(pre_val != nullptr, \"must be loaded already\");\n@@ -259,1 +258,1 @@\n-    \/\/ if (pre_val != NULL)\n+    \/\/ if (pre_val != nullptr)\n@@ -281,1 +280,1 @@\n-    } __ end_if();  \/\/ (pre_val != NULL)\n+    } __ end_if();  \/\/ (pre_val != nullptr)\n@@ -287,1 +286,1 @@\n-  if (ShenandoahSATBBarrier && adr != NULL) {\n+  if (ShenandoahSATBBarrier && adr != nullptr) {\n@@ -374,1 +373,1 @@\n-  if (otype != NULL && otype->is_con() &&\n+  if (otype != nullptr && otype->is_con() &&\n@@ -382,1 +381,1 @@\n-  if (btype != NULL) {\n+  if (btype != nullptr) {\n@@ -389,1 +388,1 @@\n-    if (itype != NULL) {\n+    if (itype != nullptr) {\n@@ -428,1 +427,1 @@\n-      \/\/ is_instof == 0 if base_oop == NULL\n+      \/\/ is_instof == 0 if base_oop == nullptr\n@@ -436,1 +435,1 @@\n-                               NULL \/* obj *\/, NULL \/* adr *\/, max_juint \/* alias_idx *\/, NULL \/* val *\/, NULL \/* val_type *\/,\n+                               nullptr \/* obj *\/, nullptr \/* adr *\/, max_juint \/* alias_idx *\/, nullptr \/* val *\/, nullptr \/* val_type *\/,\n@@ -502,4 +501,1 @@\n-  bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n-  bool on_heap = (decorators & IN_HEAP) != 0;\n-\n-  if (!access.is_oop() || (!on_heap && !anonymous)) {\n+  if (!access.is_oop()) {\n@@ -519,1 +515,1 @@\n-                                 static_cast<const TypeOopPtr*>(val.type()), NULL \/* pre_val *\/, access.type());\n+                                 static_cast<const TypeOopPtr*>(val.type()), nullptr \/* pre_val *\/, access.type());\n@@ -546,1 +542,1 @@\n-    load = new ShenandoahLoadReferenceBarrierNode(NULL, load, decorators);\n+    load = new ShenandoahLoadReferenceBarrierNode(nullptr, load, decorators);\n@@ -586,1 +582,1 @@\n-                             NULL \/* obj *\/, NULL \/* adr *\/, max_juint \/* alias_idx *\/, NULL \/* val *\/, NULL \/* val_type *\/,\n+                             nullptr \/* obj *\/, nullptr \/* adr *\/, max_juint \/* alias_idx *\/, nullptr \/* val *\/, nullptr \/* val_type *\/,\n@@ -607,1 +603,1 @@\n-                                 NULL, NULL, max_juint, NULL, NULL,\n+                                 nullptr, nullptr, max_juint, nullptr, nullptr,\n@@ -614,1 +610,1 @@\n-    Node* load_store = NULL;\n+    Node* load_store = nullptr;\n@@ -643,1 +639,1 @@\n-    load_store = kit->gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, load_store, access.decorators()));\n+    load_store = kit->gvn().transform(new ShenandoahLoadReferenceBarrierNode(nullptr, load_store, access.decorators()));\n@@ -655,1 +651,1 @@\n-                                 NULL, NULL, max_juint, NULL, NULL,\n+                                 nullptr, nullptr, max_juint, nullptr, nullptr,\n@@ -661,1 +657,1 @@\n-    Node* load_store = NULL;\n+    Node* load_store = nullptr;\n@@ -711,1 +707,1 @@\n-    result = kit->gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, result, access.decorators()));\n+    result = kit->gvn().transform(new ShenandoahLoadReferenceBarrierNode(nullptr, result, access.decorators()));\n@@ -713,1 +709,1 @@\n-                                 NULL, NULL, max_juint, NULL, NULL,\n+                                 nullptr, nullptr, max_juint, nullptr, nullptr,\n@@ -731,1 +727,1 @@\n-  if (call->_name == NULL) {\n+  if (call->_name == nullptr) {\n@@ -741,1 +737,1 @@\n-  if (c == NULL) {\n+  if (c == nullptr) {\n@@ -790,1 +786,1 @@\n-  if (src_type->isa_instptr() != NULL) {\n+  if (src_type->isa_instptr() != nullptr) {\n@@ -839,1 +835,1 @@\n-    const TypePtr* gc_state_adr_type = NULL; \/\/ debug-mode-only argument\n+    const TypePtr* gc_state_adr_type = nullptr; \/\/ debug-mode-only argument\n@@ -880,1 +876,1 @@\n-                                 phase->basictype2arraycopy(T_LONG, NULL, NULL, true, name, true),\n+                                 phase->basictype2arraycopy(T_LONG, nullptr, nullptr, true, name, true),\n@@ -995,1 +991,1 @@\n-      if (x == NULL || x == compile->top()) continue;\n+      if (x == nullptr || x == compile->top()) continue;\n@@ -1035,1 +1031,1 @@\n-                assert(load_ctrl != NULL && if_ctrl == load_ctrl, \"controls must match\");\n+                assert(load_ctrl != nullptr && if_ctrl == load_ctrl, \"controls must match\");\n@@ -1064,1 +1060,1 @@\n-    \/\/ If one input is NULL, then step over the strong LRB barriers on the other input\n+    \/\/ If one input is null, then step over the strong LRB barriers on the other input\n@@ -1088,1 +1084,1 @@\n-             n->in(0) != NULL &&\n+             n->in(0) != nullptr &&\n@@ -1098,1 +1094,1 @@\n-      if (dist < 0) return NULL;\n+      if (dist < 0) return nullptr;\n@@ -1103,1 +1099,1 @@\n-      if (!dom) return NULL;\n+      if (!dom) return nullptr;\n@@ -1108,1 +1104,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1114,1 +1110,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1212,1 +1208,1 @@\n-      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);\n+      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, adr, nullptr);\n@@ -1221,1 +1217,1 @@\n-      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), NULL);\n+      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), nullptr);\n@@ -1224,1 +1220,1 @@\n-      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(ShenandoahLoadReferenceBarrierNode::ValueIn), NULL);\n+      conn_graph->add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(ShenandoahLoadReferenceBarrierNode::ValueIn), nullptr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":45,"deletions":49,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-      if (trace) {tty->print_cr(\"NULL\");}\n+      if (trace) {tty->print_cr(\"null\");}\n@@ -268,1 +268,1 @@\n-  if (n1 != NULL) {\n+  if (n1 != nullptr) {\n@@ -271,1 +271,1 @@\n-  if (n2 != NULL) {\n+  if (n2 != nullptr) {\n@@ -465,1 +465,1 @@\n-        Node* dest = NULL;\n+        Node* dest = nullptr;\n@@ -568,0 +568,2 @@\n+        Op_VectorizedHashCode,\n+        { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },\n@@ -598,1 +600,1 @@\n-          if (n->in(j) != NULL && n->in(j)->bottom_type()->make_ptr() &&\n+          if (n->in(j) != nullptr && n->in(j)->bottom_type()->make_ptr() &&\n@@ -609,1 +611,1 @@\n-          if (n->in(j) != NULL && n->in(j)->bottom_type()->make_ptr() &&\n+          if (n->in(j) != nullptr && n->in(j)->bottom_type()->make_ptr() &&\n@@ -619,1 +621,1 @@\n-      if (verify_no_useless_barrier && sfpt->jvms() != NULL) {\n+      if (verify_no_useless_barrier && sfpt->jvms() != nullptr) {\n@@ -668,1 +670,1 @@\n-        if (m->in(i) != NULL && phase->ctrl_or_self(m->in(i)) == c) {\n+        if (m->in(i) != nullptr && phase->ctrl_or_self(m->in(i)) == c) {\n@@ -685,1 +687,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -707,1 +709,1 @@\n-  Node* iffproj = NULL;\n+  Node* iffproj = nullptr;\n@@ -744,1 +746,1 @@\n-        if (c->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none) != NULL) {\n+        if (c->as_Proj()->is_uncommon_trap_if_pattern(Deoptimization::Reason_none) != nullptr) {\n@@ -750,1 +752,1 @@\n-          if (iffproj == NULL) {\n+          if (iffproj == nullptr) {\n@@ -779,1 +781,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -791,1 +793,1 @@\n-  Node* mem = NULL;\n+  Node* mem = nullptr;\n@@ -795,1 +797,1 @@\n-      for (DUIterator_Fast imax, i = c->fast_outs(imax); i < imax && mem == NULL; i++) {\n+      for (DUIterator_Fast imax, i = c->fast_outs(imax); i < imax && mem == nullptr; i++) {\n@@ -804,1 +806,1 @@\n-      if (c->is_Call() && c->as_Call()->adr_type() != NULL) {\n+      if (c->is_Call() && c->as_Call()->adr_type() != nullptr) {\n@@ -806,1 +808,1 @@\n-        if (projs->fallthrough_memproj != NULL) {\n+        if (projs->fallthrough_memproj != nullptr) {\n@@ -808,1 +810,1 @@\n-            if (projs->catchall_memproj == NULL) {\n+            if (projs->catchall_memproj == nullptr) {\n@@ -821,1 +823,1 @@\n-          if (proj != NULL &&\n+          if (proj != nullptr &&\n@@ -833,1 +835,1 @@\n-              assert(mem == NULL, \"only one proj\");\n+              assert(mem == nullptr, \"only one proj\");\n@@ -837,1 +839,1 @@\n-        assert(!c->is_Call() || c->as_Call()->adr_type() != NULL || mem == NULL, \"no mem projection expected\");\n+        assert(!c->is_Call() || c->as_Call()->adr_type() != nullptr || mem == nullptr, \"no mem projection expected\");\n@@ -841,1 +843,1 @@\n-  } while (mem == NULL);\n+  } while (mem == nullptr);\n@@ -874,1 +876,1 @@\n-                                        DEBUG_ONLY(phase->C->get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),\n+                                        DEBUG_ONLY(phase->C->get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(nullptr),\n@@ -940,1 +942,1 @@\n-                                       DEBUG_ONLY(phase->C->get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),\n+                                       DEBUG_ONLY(phase->C->get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(nullptr),\n@@ -971,2 +973,2 @@\n-  address calladdr = NULL;\n-  const char* name = NULL;\n+  address calladdr = nullptr;\n+  const char* name = nullptr;\n@@ -1041,1 +1043,1 @@\n-      if (in != NULL && phase->has_ctrl(in) && phase->get_ctrl(in) == ctrl) {\n+      if (in != nullptr && phase->has_ctrl(in) && phase->get_ctrl(in) == ctrl) {\n@@ -1076,1 +1078,1 @@\n-  Node* region = NULL;\n+  Node* region = nullptr;\n@@ -1083,1 +1085,1 @@\n-  assert(region != NULL, \"\");\n+  assert(region != nullptr, \"\");\n@@ -1125,2 +1127,2 @@\n-    CallStaticJavaNode* unc = NULL;\n-    Node* unc_ctrl = NULL;\n+    CallStaticJavaNode* unc = nullptr;\n+    Node* unc_ctrl = nullptr;\n@@ -1132,1 +1134,1 @@\n-          u->in(0) != NULL &&\n+          u->in(0) != nullptr &&\n@@ -1153,1 +1155,1 @@\n-          assert(branch == NULL || branch == NodeSentinel, \"was not looking for a branch\");\n+          assert(branch == nullptr || branch == NodeSentinel, \"was not looking for a branch\");\n@@ -1184,1 +1186,1 @@\n-            if (in != NULL) {\n+            if (in != nullptr) {\n@@ -1335,1 +1337,1 @@\n-    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);\n+    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, nullptr);\n@@ -1339,2 +1341,2 @@\n-    Node* heap_stable_ctrl = NULL;\n-    Node* null_ctrl = NULL;\n+    Node* heap_stable_ctrl = nullptr;\n+    Node* null_ctrl = nullptr;\n@@ -1343,1 +1345,1 @@\n-    assert(val->bottom_type()->make_oopptr()->const_oop() == NULL, \"expect non-constant\");\n+    assert(val->bottom_type()->make_oopptr()->const_oop() == nullptr, \"expect non-constant\");\n@@ -1361,1 +1363,1 @@\n-    \/\/ Test for in-cset, unless it's a native-LRB. Native LRBs need to return NULL\n+    \/\/ Test for in-cset, unless it's a native-LRB. Native LRBs need to return null\n@@ -1364,1 +1366,1 @@\n-    Node* not_cset_ctrl = NULL;\n+    Node* not_cset_ctrl = nullptr;\n@@ -1368,1 +1370,1 @@\n-    if (not_cset_ctrl != NULL) {\n+    if (not_cset_ctrl != nullptr) {\n@@ -1380,1 +1382,1 @@\n-    Node* result_mem = NULL;\n+    Node* result_mem = nullptr;\n@@ -1467,3 +1469,3 @@\n-    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);\n-    Node* heap_stable_ctrl = NULL;\n-    Node* null_ctrl = NULL;\n+    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, nullptr);\n+    Node* heap_stable_ctrl = nullptr;\n+    Node* null_ctrl = nullptr;\n@@ -1486,1 +1488,1 @@\n-    Node* reg2_ctrl = NULL;\n+    Node* reg2_ctrl = nullptr;\n@@ -1488,1 +1490,1 @@\n-    if (null_ctrl != NULL) {\n+    if (null_ctrl != nullptr) {\n@@ -1516,1 +1518,1 @@\n-    if (reg2_ctrl == NULL) reg2_ctrl = queue_full_iff;\n+    if (reg2_ctrl == nullptr) reg2_ctrl = queue_full_iff;\n@@ -1596,1 +1598,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1623,3 +1625,3 @@\n-      if (t != NULL && f == NULL) return t;\n-      if (t == NULL && f != NULL) return f;\n-      if (t != NULL && t == f)    return t;\n+      if (t != nullptr && f == nullptr) return t;\n+      if (t == nullptr && f != nullptr) return f;\n+      if (t != nullptr && t == f)    return t;\n@@ -1630,1 +1632,1 @@\n-      Node* addr = NULL;\n+      Node* addr = nullptr;\n@@ -1633,1 +1635,1 @@\n-        if (addr == NULL) {\n+        if (addr == nullptr) {\n@@ -1675,1 +1677,1 @@\n-    Node* mem_ctrl = NULL;\n+    Node* mem_ctrl = nullptr;\n@@ -1769,1 +1771,1 @@\n-  IfNode* unswitch_iff = NULL;\n+  IfNode* unswitch_iff = nullptr;\n@@ -1844,1 +1846,1 @@\n-          loop->_child == NULL &&\n+          loop->_child == nullptr &&\n@@ -1851,1 +1853,1 @@\n-          if (iff != NULL) {\n+          if (iff != nullptr) {\n@@ -1878,1 +1880,1 @@\n-ShenandoahIUBarrierNode::ShenandoahIUBarrierNode(Node* val) : Node(NULL, val) {\n+ShenandoahIUBarrierNode::ShenandoahIUBarrierNode(Node* val) : Node(nullptr, val) {\n@@ -1883,1 +1885,1 @@\n-  if (in(1) == NULL || in(1)->is_top()) {\n+  if (in(1) == nullptr || in(1)->is_top()) {\n@@ -1894,1 +1896,1 @@\n-  if (in(1) == NULL) {\n+  if (in(1) == nullptr) {\n@@ -1908,1 +1910,1 @@\n-  if (n == NULL ||\n+  if (n == nullptr ||\n@@ -1912,1 +1914,1 @@\n-      (n->bottom_type()->make_oopptr() != NULL && n->bottom_type()->make_oopptr()->const_oop() != NULL)) {\n+      (n->bottom_type()->make_oopptr() != nullptr && n->bottom_type()->make_oopptr()->const_oop() != nullptr)) {\n@@ -1924,1 +1926,1 @@\n-    if (n == NULL) {\n+    if (n == nullptr) {\n@@ -1928,1 +1930,1 @@\n-    } else if (n->bottom_type()->make_oopptr() != NULL && n->bottom_type()->make_oopptr()->const_oop() != NULL) {\n+    } else if (n->bottom_type()->make_oopptr() != nullptr && n->bottom_type()->make_oopptr()->const_oop() != nullptr) {\n@@ -1941,1 +1943,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1954,1 +1956,1 @@\n-    if (igvn == NULL) {\n+    if (igvn == nullptr) {\n@@ -1966,1 +1968,1 @@\n-            if (m != NULL) {\n+            if (m != nullptr) {\n@@ -1977,1 +1979,1 @@\n-        Node* orig_n = NULL;\n+        Node* orig_n = nullptr;\n@@ -2002,1 +2004,1 @@\n-    if (in != NULL && in->Opcode() == Op_Halt && in->in(0)->is_Proj() && in->in(0)->in(0)->is_NeverBranch()) {\n+    if (in != nullptr && in->Opcode() == Op_Halt && in->in(0)->is_Proj() && in->in(0)->in(0)->is_NeverBranch()) {\n@@ -2023,1 +2025,1 @@\n-      Node* mem = NULL;\n+      Node* mem = nullptr;\n@@ -2064,1 +2066,1 @@\n-      if (mem == NULL) {\n+      if (mem == nullptr) {\n@@ -2117,1 +2119,1 @@\n-      if (_memory_nodes[c->_idx] != NULL) {\n+      if (_memory_nodes[c->_idx] != nullptr) {\n@@ -2148,1 +2150,1 @@\n-        Node* unique = NULL;\n+        Node* unique = nullptr;\n@@ -2151,2 +2153,2 @@\n-          assert(m != NULL || (c->is_Loop() && j == LoopNode::LoopBackControl && iteration == 1) || _phase->C->has_irreducible_loop() || has_never_branch(_phase->C->root()), \"expect memory state\");\n-          if (m != NULL) {\n+          assert(m != nullptr || (c->is_Loop() && j == LoopNode::LoopBackControl && iteration == 1) || _phase->C->has_irreducible_loop() || has_never_branch(_phase->C->root()), \"expect memory state\");\n+          if (m != nullptr) {\n@@ -2156,1 +2158,1 @@\n-            } else if (unique == NULL) {\n+            } else if (unique == nullptr) {\n@@ -2165,1 +2167,1 @@\n-        assert(unique != NULL, \"empty phi???\");\n+        assert(unique != nullptr, \"empty phi???\");\n@@ -2167,1 +2169,1 @@\n-          if (prev_region != NULL && prev_region->is_Phi() && prev_region->in(0) == c) {\n+          if (prev_region != nullptr && prev_region->is_Phi() && prev_region->in(0) == c) {\n@@ -2172,2 +2174,2 @@\n-          Node* phi = NULL;\n-          if (prev_region != NULL && prev_region->is_Phi() && prev_region->in(0) == c && prev_region->_idx >= last) {\n+          Node* phi = nullptr;\n+          if (prev_region != nullptr && prev_region->is_Phi() && prev_region->in(0) == c && prev_region->_idx >= last) {\n@@ -2177,1 +2179,1 @@\n-              assert(m != NULL, \"expect memory state\");\n+              assert(m != nullptr, \"expect memory state\");\n@@ -2181,1 +2183,1 @@\n-            for (DUIterator_Fast jmax, j = c->fast_outs(jmax); j < jmax && phi == NULL; j++) {\n+            for (DUIterator_Fast jmax, j = c->fast_outs(jmax); j < jmax && phi == nullptr; j++) {\n@@ -2186,1 +2188,1 @@\n-                for (uint k = 1; k < c->req() && phi != NULL; k++) {\n+                for (uint k = 1; k < c->req() && phi != nullptr; k++) {\n@@ -2188,1 +2190,1 @@\n-                  assert(m != NULL, \"expect memory state\");\n+                  assert(m != nullptr, \"expect memory state\");\n@@ -2199,1 +2201,1 @@\n-                assert(m != NULL, \"expect memory state\");\n+                assert(m != nullptr, \"expect memory state\");\n@@ -2204,1 +2206,1 @@\n-          if (phi != NULL) {\n+          if (phi != nullptr) {\n@@ -2217,1 +2219,1 @@\n-      } else if (prev_mem == NULL || prev_mem->is_Phi() || ctrl_or_self(prev_mem) != c) {\n+      } else if (prev_mem == nullptr || prev_mem->is_Phi() || ctrl_or_self(prev_mem) != c) {\n@@ -2219,1 +2221,1 @@\n-        assert(m != NULL || c->Opcode() == Op_Halt, \"expect memory state\");\n+        assert(m != nullptr || c->Opcode() == Op_Halt, \"expect memory state\");\n@@ -2243,2 +2245,2 @@\n-      assert(n != NULL || c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n-      if (n != NULL && n->is_Phi() && n->_idx >= last && n->in(0) == c) {\n+      assert(n != nullptr || c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n+      if (n != nullptr && n->is_Phi() && n->_idx >= last && n->in(0) == c) {\n@@ -2253,1 +2255,1 @@\n-      assert(n != NULL || c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n+      assert(n != nullptr || c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n@@ -2272,1 +2274,1 @@\n-  Node* mem = NULL;\n+  Node* mem = nullptr;\n@@ -2276,1 +2278,1 @@\n-  Node* phi_mem = NULL;\n+  Node* phi_mem = nullptr;\n@@ -2281,1 +2283,1 @@\n-        assert(phi_mem == NULL || phi_mem->adr_type() == TypePtr::BOTTOM, \"\");\n+        assert(phi_mem == nullptr || phi_mem->adr_type() == TypePtr::BOTTOM, \"\");\n@@ -2284,2 +2286,2 @@\n-        assert(phi_mem == NULL || _phase->C->get_alias_index(phi_mem->adr_type()) == _alias, \"\");\n-        if (phi_mem == NULL) {\n+        assert(phi_mem == nullptr || _phase->C->get_alias_index(phi_mem->adr_type()) == _alias, \"\");\n+        if (phi_mem == nullptr) {\n@@ -2291,1 +2293,1 @@\n-  if (phi_mem == NULL) {\n+  if (phi_mem == nullptr) {\n@@ -2314,1 +2316,1 @@\n-              assert(mem == NULL || mem == m, \"several memory states\");\n+              assert(mem == nullptr || mem == m, \"several memory states\");\n@@ -2325,1 +2327,1 @@\n-    assert(mem != NULL, \"should have found safepoint\");\n+    assert(mem != nullptr, \"should have found safepoint\");\n@@ -2334,1 +2336,1 @@\n-  if (n->is_Proj() && n->in(0) != NULL && n->in(0)->is_Call()) {\n+  if (n->is_Proj() && n->in(0) != nullptr && n->in(0)->is_Call()) {\n@@ -2338,1 +2340,1 @@\n-    if (projs->catchall_memproj != NULL) {\n+    if (projs->catchall_memproj != nullptr) {\n@@ -2360,1 +2362,1 @@\n-  return m != NULL && get_ctrl(m) == c;\n+  return m != nullptr && get_ctrl(m) == c;\n@@ -2364,1 +2366,1 @@\n-  assert(n == NULL || _phase->ctrl_or_self(n) == ctrl, \"\");\n+  assert(n == nullptr || _phase->ctrl_or_self(n) == ctrl, \"\");\n@@ -2383,1 +2385,1 @@\n-         (!c->is_CatchProj() || mem == NULL || c->in(0)->in(0)->in(0) != get_ctrl(mem))) {\n+         (!c->is_CatchProj() || mem == nullptr || c->in(0)->in(0)->in(0) != get_ctrl(mem))) {\n@@ -2387,1 +2389,1 @@\n-  if (n != NULL && mem_is_valid(mem, c)) {\n+  if (n != nullptr && mem_is_valid(mem, c)) {\n@@ -2399,1 +2401,1 @@\n-               (!c->is_CatchProj() || mem == NULL || c->in(0)->in(0)->in(0) != get_ctrl(mem)));\n+               (!c->is_CatchProj() || mem == nullptr || c->in(0)->in(0)->in(0) != get_ctrl(mem)));\n@@ -2425,1 +2427,1 @@\n-    Node* prev = NULL;\n+    Node* prev = nullptr;\n@@ -2438,1 +2440,1 @@\n-    assert(prev != NULL, \"\");\n+    assert(prev != nullptr, \"\");\n@@ -2461,1 +2463,1 @@\n-            DEBUG_ONLY(if (trace && m != NULL) { tty->print(\"ZZZ mem\"); m->dump(); });\n+            DEBUG_ONLY(if (trace && m != nullptr) { tty->print(\"ZZZ mem\"); m->dump(); });\n@@ -2481,1 +2483,1 @@\n-                    Node* next = NULL;\n+                    Node* next = nullptr;\n@@ -2528,1 +2530,1 @@\n-        Node* m = find_mem(r->in(j), NULL);\n+        Node* m = find_mem(r->in(j), nullptr);\n@@ -2535,1 +2537,1 @@\n-  MergeMemNode* mm = NULL;\n+  MergeMemNode* mm = nullptr;\n@@ -2567,1 +2569,1 @@\n-          MergeMemNode* newmm = NULL;\n+          MergeMemNode* newmm = nullptr;\n@@ -2577,1 +2579,1 @@\n-                  Node* m = find_mem(region->in(k), NULL);\n+                  Node* m = find_mem(region->in(k), nullptr);\n@@ -2612,1 +2614,1 @@\n-              Node* m = find_mem(region->in(j), NULL);\n+              Node* m = find_mem(region->in(j), nullptr);\n@@ -2630,2 +2632,2 @@\n-                 u->adr_type() == NULL) {\n-        assert(u->adr_type() != NULL ||\n+                 u->adr_type() == nullptr) {\n+        assert(u->adr_type() != nullptr ||\n@@ -2687,1 +2689,1 @@\n-  MergeMemNode* newmm = NULL;\n+  MergeMemNode* newmm = nullptr;\n@@ -2747,1 +2749,1 @@\n-  MergeMemNode* mm = NULL;\n+  MergeMemNode* mm = nullptr;\n@@ -2755,1 +2757,1 @@\n-          MergeMemNode* newmm = NULL;\n+          MergeMemNode* newmm = nullptr;\n@@ -2765,1 +2767,1 @@\n-                    if (newmm == NULL) {\n+                    if (newmm == nullptr) {\n@@ -2781,1 +2783,1 @@\n-                if (newmm == NULL) {\n+                if (newmm == nullptr) {\n@@ -2801,1 +2803,1 @@\n-                if (mm == NULL) {\n+                if (mm == nullptr) {\n@@ -2816,2 +2818,2 @@\n-                 u->adr_type() == NULL) {\n-        assert(u->adr_type() != NULL ||\n+                 u->adr_type() == nullptr) {\n+        assert(u->adr_type() != nullptr ||\n@@ -2825,1 +2827,1 @@\n-          if (mm == NULL) {\n+          if (mm == nullptr) {\n@@ -2870,1 +2872,1 @@\n-  if (in(ValueIn) == NULL || in(ValueIn)->is_top()) {\n+  if (in(ValueIn) == nullptr || in(ValueIn)->is_top()) {\n@@ -2915,1 +2917,1 @@\n-  if (n == NULL) return false;\n+  if (n == nullptr) return false;\n@@ -2938,1 +2940,1 @@\n-  if (type->make_oopptr() && type->make_oopptr()->const_oop() != NULL) {\n+  if (type->make_oopptr() && type->make_oopptr()->const_oop() != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":132,"deletions":130,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -71,1 +71,1 @@\n-  if (load_addr != NULL && fwd != obj) {\n+  if (load_addr != nullptr && fwd != obj) {\n@@ -84,2 +84,2 @@\n-      _heap->in_collection_set(obj)) { \/\/ Subsumes NULL-check\n-    assert(obj != NULL, \"cset check must have subsumed NULL-check\");\n+      _heap->in_collection_set(obj)) { \/\/ Subsumes null-check\n+    assert(obj != nullptr, \"cset check must have subsumed null-check\");\n@@ -99,2 +99,2 @@\n-  if (obj == NULL) {\n-    return NULL;\n+  if (obj == nullptr) {\n+    return nullptr;\n@@ -107,1 +107,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -114,1 +114,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -126,1 +126,1 @@\n-  if (ShenandoahSelfFixing && load_addr != NULL && fwd != obj) {\n+  if (ShenandoahSelfFixing && load_addr != nullptr && fwd != obj) {\n@@ -135,1 +135,1 @@\n-  assert(obj != NULL, \"checked by caller\");\n+  assert(obj != nullptr, \"checked by caller\");\n@@ -162,1 +162,1 @@\n-  if (value != NULL && ShenandoahSATBBarrier && _heap->is_concurrent_mark_in_progress()) {\n+  if (value != nullptr && ShenandoahSATBBarrier && _heap->is_concurrent_mark_in_progress()) {\n@@ -168,1 +168,1 @@\n-  if (ShenandoahIUBarrier && obj != NULL && _heap->is_concurrent_mark_in_progress()) {\n+  if (ShenandoahIUBarrier && obj != nullptr && _heap->is_concurrent_mark_in_progress()) {\n@@ -245,2 +245,2 @@\n-  shenandoah_assert_marked_if(NULL, value, !CompressedOops::is_null(value) && ShenandoahHeap::heap()->is_evacuation_in_progress());\n-  shenandoah_assert_not_in_cset_if(addr, value, value != NULL && !ShenandoahHeap::heap()->cancelled_gc());\n+  shenandoah_assert_marked_if(nullptr, value, !CompressedOops::is_null(value) && ShenandoahHeap::heap()->is_evacuation_in_progress());\n+  shenandoah_assert_not_in_cset_if(addr, value, value != nullptr && !ShenandoahHeap::heap()->cancelled_gc());\n@@ -263,1 +263,1 @@\n-  shenandoah_assert_not_forwarded_except  (addr, value, value == NULL || ShenandoahHeap::heap()->cancelled_gc() || !ShenandoahHeap::heap()->is_concurrent_mark_in_progress());\n+  shenandoah_assert_not_forwarded_except  (addr, value, value == nullptr || ShenandoahHeap::heap()->cancelled_gc() || !ShenandoahHeap::heap()->is_concurrent_mark_in_progress());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  assert(lock != NULL, \"Must be\");\n+  assert(lock != nullptr, \"Must be\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,2 +171,2 @@\n-  static address deopt_entry(TosState state, int length) { ShouldNotReachHere(); return NULL; }\n-  static address return_entry(TosState state, int length, Bytecodes::Code code) { ShouldNotReachHere(); return NULL; }\n+  static address deopt_entry(TosState state, int length) { ShouldNotReachHere(); return nullptr; }\n+  static address return_entry(TosState state, int length, Bytecodes::Code code) { ShouldNotReachHere(); return nullptr; }\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    assert(method != NULL, \"this form requires a valid Method*\");\n+    assert(method != nullptr, \"this form requires a valid Method*\");\n@@ -62,1 +62,1 @@\n-  inline Bytecode(const ciBytecodeStream* stream, address bcp = NULL);\n+  inline Bytecode(const ciBytecodeStream* stream, address bcp = nullptr);\n@@ -337,1 +337,1 @@\n-    assert(_method != NULL, \"must supply method\");\n+    assert(_method != nullptr, \"must supply method\");\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,2 +204,2 @@\n-  if (value == NULL) {\n-    st->print_cr(\" NULL\");\n+  if (value == nullptr) {\n+    st->print_cr(\" null\");\n@@ -259,1 +259,1 @@\n-  if (cache == NULL) {\n+  if (cache == nullptr) {\n@@ -506,1 +506,1 @@\n-        if (str == NULL || is_reference_type(atype)) {\n+        if (str == nullptr || is_reference_type(atype)) {\n@@ -654,1 +654,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -656,1 +656,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,1 @@\n-                        bool inner_expr = false, const char *prefix = NULL);\n+                        bool inner_expr = false, const char *prefix = nullptr);\n@@ -472,1 +472,1 @@\n-    _stacks->push(NULL);\n+    _stacks->push(nullptr);\n@@ -484,1 +484,1 @@\n-      if (_stacks->at(index) == NULL) {\n+      if (_stacks->at(index) == nullptr) {\n@@ -502,1 +502,1 @@\n-      if ((bci == i) && (_stacks->at(i) != NULL)) {\n+      if ((bci == i) && (_stacks->at(i) != nullptr)) {\n@@ -515,1 +515,1 @@\n-  if (_stacks != NULL) {\n+  if (_stacks != nullptr) {\n@@ -525,1 +525,1 @@\n-  if (_stacks->at(bci) != NULL) {\n+  if (_stacks->at(bci) != nullptr) {\n@@ -545,1 +545,1 @@\n-  if (_stacks->at(bci) == NULL) {\n+  if (_stacks->at(bci) == nullptr) {\n@@ -1070,1 +1070,1 @@\n-    if (_stacks->at(bci + len) == NULL) {\n+    if (_stacks->at(bci + len) == nullptr) {\n@@ -1078,1 +1078,1 @@\n-    if (_stacks->at(dest_bci) == NULL) {\n+    if (_stacks->at(dest_bci) == nullptr) {\n@@ -1086,1 +1086,1 @@\n-    if (_stacks->at(dests.at(i)) == NULL) {\n+    if (_stacks->at(dests.at(i)) == nullptr) {\n@@ -1212,1 +1212,1 @@\n-  if (_stacks->at(bci) == NULL) {\n+  if (_stacks->at(bci) == nullptr) {\n@@ -1240,1 +1240,1 @@\n-      prefix != NULL &&\n+      prefix != nullptr &&\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-  assert(method != NULL, \"must have the method for breakpoint conversion\");\n+  assert(method != nullptr, \"must have the method for breakpoint conversion\");\n@@ -83,1 +83,1 @@\n-    if (end != NULL && bcp + 1 >= end) {\n+    if (end != nullptr && bcp + 1 >= end) {\n@@ -89,1 +89,1 @@\n-      if (end != NULL && aligned_bcp + 3*jintSize >= end) {\n+      if (end != nullptr && aligned_bcp + 3*jintSize >= end) {\n@@ -104,1 +104,1 @@\n-      if (end != NULL && aligned_bcp + 2*jintSize >= end) {\n+      if (end != nullptr && aligned_bcp + 2*jintSize >= end) {\n@@ -148,3 +148,3 @@\n-  assert(wide_format == NULL || format != NULL, \"short form must exist if there's a wide form\");\n-  int len  = (format      != NULL ? (int) strlen(format)      : 0);\n-  int wlen = (wide_format != NULL ? (int) strlen(wide_format) : 0);\n+  assert(wide_format == nullptr || format != nullptr, \"short form must exist if there's a wide form\");\n+  int len  = (format      != nullptr ? (int) strlen(format)      : 0);\n+  int wlen = (wide_format != nullptr ? (int) strlen(wide_format) : 0);\n@@ -161,2 +161,2 @@\n-  assert(is_defined(code)      == (format != NULL),      \"\");\n-  assert(wide_is_defined(code) == (wide_format != NULL), \"\");\n+  assert(is_defined(code)      == (format != nullptr),      \"\");\n+  assert(wide_is_defined(code) == (wide_format != nullptr), \"\");\n@@ -187,1 +187,1 @@\n-  if (format == NULL)  return 0;  \/\/ not even more_flags\n+  if (format == nullptr)  return 0;  \/\/ not even more_flags\n@@ -266,1 +266,1 @@\n-  \/\/ Note 1: NULL for the format string means the bytecode doesn't exist\n+  \/\/ Note 1: nullptr for the format string means the bytecode doesn't exist\n@@ -274,205 +274,205 @@\n-  def(_nop                 , \"nop\"                 , \"b\"    , NULL    , T_VOID   ,  0, false);\n-  def(_aconst_null         , \"aconst_null\"         , \"b\"    , NULL    , T_OBJECT ,  1, false);\n-  def(_iconst_m1           , \"iconst_m1\"           , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iconst_0            , \"iconst_0\"            , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iconst_1            , \"iconst_1\"            , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iconst_2            , \"iconst_2\"            , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iconst_3            , \"iconst_3\"            , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iconst_4            , \"iconst_4\"            , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iconst_5            , \"iconst_5\"            , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_lconst_0            , \"lconst_0\"            , \"b\"    , NULL    , T_LONG   ,  2, false);\n-  def(_lconst_1            , \"lconst_1\"            , \"b\"    , NULL    , T_LONG   ,  2, false);\n-  def(_fconst_0            , \"fconst_0\"            , \"b\"    , NULL    , T_FLOAT  ,  1, false);\n-  def(_fconst_1            , \"fconst_1\"            , \"b\"    , NULL    , T_FLOAT  ,  1, false);\n-  def(_fconst_2            , \"fconst_2\"            , \"b\"    , NULL    , T_FLOAT  ,  1, false);\n-  def(_dconst_0            , \"dconst_0\"            , \"b\"    , NULL    , T_DOUBLE ,  2, false);\n-  def(_dconst_1            , \"dconst_1\"            , \"b\"    , NULL    , T_DOUBLE ,  2, false);\n-  def(_bipush              , \"bipush\"              , \"bc\"   , NULL    , T_INT    ,  1, false);\n-  def(_sipush              , \"sipush\"              , \"bcc\"  , NULL    , T_INT    ,  1, false);\n-  def(_ldc                 , \"ldc\"                 , \"bk\"   , NULL    , T_ILLEGAL,  1, true );\n-  def(_ldc_w               , \"ldc_w\"               , \"bkk\"  , NULL    , T_ILLEGAL,  1, true );\n-  def(_ldc2_w              , \"ldc2_w\"              , \"bkk\"  , NULL    , T_ILLEGAL,  2, true );\n-  def(_iload               , \"iload\"               , \"bi\"   , \"wbii\"  , T_INT    ,  1, false);\n-  def(_lload               , \"lload\"               , \"bi\"   , \"wbii\"  , T_LONG   ,  2, false);\n-  def(_fload               , \"fload\"               , \"bi\"   , \"wbii\"  , T_FLOAT  ,  1, false);\n-  def(_dload               , \"dload\"               , \"bi\"   , \"wbii\"  , T_DOUBLE ,  2, false);\n-  def(_aload               , \"aload\"               , \"bi\"   , \"wbii\"  , T_OBJECT ,  1, false);\n-  def(_iload_0             , \"iload_0\"             , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iload_1             , \"iload_1\"             , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iload_2             , \"iload_2\"             , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_iload_3             , \"iload_3\"             , \"b\"    , NULL    , T_INT    ,  1, false);\n-  def(_lload_0             , \"lload_0\"             , \"b\"    , NULL    , T_LONG   ,  2, false);\n-  def(_lload_1             , \"lload_1\"             , \"b\"    , NULL    , T_LONG   ,  2, false);\n-  def(_lload_2             , \"lload_2\"             , \"b\"    , NULL    , T_LONG   ,  2, false);\n-  def(_lload_3             , \"lload_3\"             , \"b\"    , NULL    , T_LONG   ,  2, false);\n-  def(_fload_0             , \"fload_0\"             , \"b\"    , NULL    , T_FLOAT  ,  1, false);\n-  def(_fload_1             , \"fload_1\"             , \"b\"    , NULL    , T_FLOAT  ,  1, false);\n-  def(_fload_2             , \"fload_2\"             , \"b\"    , NULL    , T_FLOAT  ,  1, false);\n-  def(_fload_3             , \"fload_3\"             , \"b\"    , NULL    , T_FLOAT  ,  1, false);\n-  def(_dload_0             , \"dload_0\"             , \"b\"    , NULL    , T_DOUBLE ,  2, false);\n-  def(_dload_1             , \"dload_1\"             , \"b\"    , NULL    , T_DOUBLE ,  2, false);\n-  def(_dload_2             , \"dload_2\"             , \"b\"    , NULL    , T_DOUBLE ,  2, false);\n-  def(_dload_3             , \"dload_3\"             , \"b\"    , NULL    , T_DOUBLE ,  2, false);\n-  def(_aload_0             , \"aload_0\"             , \"b\"    , NULL    , T_OBJECT ,  1, true ); \/\/ rewriting in interpreter\n-  def(_aload_1             , \"aload_1\"             , \"b\"    , NULL    , T_OBJECT ,  1, false);\n-  def(_aload_2             , \"aload_2\"             , \"b\"    , NULL    , T_OBJECT ,  1, false);\n-  def(_aload_3             , \"aload_3\"             , \"b\"    , NULL    , T_OBJECT ,  1, false);\n-  def(_iaload              , \"iaload\"              , \"b\"    , NULL    , T_INT    , -1, true );\n-  def(_laload              , \"laload\"              , \"b\"    , NULL    , T_LONG   ,  0, true );\n-  def(_faload              , \"faload\"              , \"b\"    , NULL    , T_FLOAT  , -1, true );\n-  def(_daload              , \"daload\"              , \"b\"    , NULL    , T_DOUBLE ,  0, true );\n-  def(_aaload              , \"aaload\"              , \"b\"    , NULL    , T_OBJECT , -1, true );\n-  def(_baload              , \"baload\"              , \"b\"    , NULL    , T_INT    , -1, true );\n-  def(_caload              , \"caload\"              , \"b\"    , NULL    , T_INT    , -1, true );\n-  def(_saload              , \"saload\"              , \"b\"    , NULL    , T_INT    , -1, true );\n-  def(_istore              , \"istore\"              , \"bi\"   , \"wbii\"  , T_VOID   , -1, false);\n-  def(_lstore              , \"lstore\"              , \"bi\"   , \"wbii\"  , T_VOID   , -2, false);\n-  def(_fstore              , \"fstore\"              , \"bi\"   , \"wbii\"  , T_VOID   , -1, false);\n-  def(_dstore              , \"dstore\"              , \"bi\"   , \"wbii\"  , T_VOID   , -2, false);\n-  def(_astore              , \"astore\"              , \"bi\"   , \"wbii\"  , T_VOID   , -1, false);\n-  def(_istore_0            , \"istore_0\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_istore_1            , \"istore_1\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_istore_2            , \"istore_2\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_istore_3            , \"istore_3\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_lstore_0            , \"lstore_0\"            , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_lstore_1            , \"lstore_1\"            , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_lstore_2            , \"lstore_2\"            , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_lstore_3            , \"lstore_3\"            , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_fstore_0            , \"fstore_0\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_fstore_1            , \"fstore_1\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_fstore_2            , \"fstore_2\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_fstore_3            , \"fstore_3\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_dstore_0            , \"dstore_0\"            , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_dstore_1            , \"dstore_1\"            , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_dstore_2            , \"dstore_2\"            , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_dstore_3            , \"dstore_3\"            , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_astore_0            , \"astore_0\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_astore_1            , \"astore_1\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_astore_2            , \"astore_2\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_astore_3            , \"astore_3\"            , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_iastore             , \"iastore\"             , \"b\"    , NULL    , T_VOID   , -3, true );\n-  def(_lastore             , \"lastore\"             , \"b\"    , NULL    , T_VOID   , -4, true );\n-  def(_fastore             , \"fastore\"             , \"b\"    , NULL    , T_VOID   , -3, true );\n-  def(_dastore             , \"dastore\"             , \"b\"    , NULL    , T_VOID   , -4, true );\n-  def(_aastore             , \"aastore\"             , \"b\"    , NULL    , T_VOID   , -3, true );\n-  def(_bastore             , \"bastore\"             , \"b\"    , NULL    , T_VOID   , -3, true );\n-  def(_castore             , \"castore\"             , \"b\"    , NULL    , T_VOID   , -3, true );\n-  def(_sastore             , \"sastore\"             , \"b\"    , NULL    , T_VOID   , -3, true );\n-  def(_pop                 , \"pop\"                 , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_pop2                , \"pop2\"                , \"b\"    , NULL    , T_VOID   , -2, false);\n-  def(_dup                 , \"dup\"                 , \"b\"    , NULL    , T_VOID   ,  1, false);\n-  def(_dup_x1              , \"dup_x1\"              , \"b\"    , NULL    , T_VOID   ,  1, false);\n-  def(_dup_x2              , \"dup_x2\"              , \"b\"    , NULL    , T_VOID   ,  1, false);\n-  def(_dup2                , \"dup2\"                , \"b\"    , NULL    , T_VOID   ,  2, false);\n-  def(_dup2_x1             , \"dup2_x1\"             , \"b\"    , NULL    , T_VOID   ,  2, false);\n-  def(_dup2_x2             , \"dup2_x2\"             , \"b\"    , NULL    , T_VOID   ,  2, false);\n-  def(_swap                , \"swap\"                , \"b\"    , NULL    , T_VOID   ,  0, false);\n-  def(_iadd                , \"iadd\"                , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_ladd                , \"ladd\"                , \"b\"    , NULL    , T_LONG   , -2, false);\n-  def(_fadd                , \"fadd\"                , \"b\"    , NULL    , T_FLOAT  , -1, false);\n-  def(_dadd                , \"dadd\"                , \"b\"    , NULL    , T_DOUBLE , -2, false);\n-  def(_isub                , \"isub\"                , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_lsub                , \"lsub\"                , \"b\"    , NULL    , T_LONG   , -2, false);\n-  def(_fsub                , \"fsub\"                , \"b\"    , NULL    , T_FLOAT  , -1, false);\n-  def(_dsub                , \"dsub\"                , \"b\"    , NULL    , T_DOUBLE , -2, false);\n-  def(_imul                , \"imul\"                , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_lmul                , \"lmul\"                , \"b\"    , NULL    , T_LONG   , -2, false);\n-  def(_fmul                , \"fmul\"                , \"b\"    , NULL    , T_FLOAT  , -1, false);\n-  def(_dmul                , \"dmul\"                , \"b\"    , NULL    , T_DOUBLE , -2, false);\n-  def(_idiv                , \"idiv\"                , \"b\"    , NULL    , T_INT    , -1, true );\n-  def(_ldiv                , \"ldiv\"                , \"b\"    , NULL    , T_LONG   , -2, true );\n-  def(_fdiv                , \"fdiv\"                , \"b\"    , NULL    , T_FLOAT  , -1, false);\n-  def(_ddiv                , \"ddiv\"                , \"b\"    , NULL    , T_DOUBLE , -2, false);\n-  def(_irem                , \"irem\"                , \"b\"    , NULL    , T_INT    , -1, true );\n-  def(_lrem                , \"lrem\"                , \"b\"    , NULL    , T_LONG   , -2, true );\n-  def(_frem                , \"frem\"                , \"b\"    , NULL    , T_FLOAT  , -1, false);\n-  def(_drem                , \"drem\"                , \"b\"    , NULL    , T_DOUBLE , -2, false);\n-  def(_ineg                , \"ineg\"                , \"b\"    , NULL    , T_INT    ,  0, false);\n-  def(_lneg                , \"lneg\"                , \"b\"    , NULL    , T_LONG   ,  0, false);\n-  def(_fneg                , \"fneg\"                , \"b\"    , NULL    , T_FLOAT  ,  0, false);\n-  def(_dneg                , \"dneg\"                , \"b\"    , NULL    , T_DOUBLE ,  0, false);\n-  def(_ishl                , \"ishl\"                , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_lshl                , \"lshl\"                , \"b\"    , NULL    , T_LONG   , -1, false);\n-  def(_ishr                , \"ishr\"                , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_lshr                , \"lshr\"                , \"b\"    , NULL    , T_LONG   , -1, false);\n-  def(_iushr               , \"iushr\"               , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_lushr               , \"lushr\"               , \"b\"    , NULL    , T_LONG   , -1, false);\n-  def(_iand                , \"iand\"                , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_land                , \"land\"                , \"b\"    , NULL    , T_LONG   , -2, false);\n-  def(_ior                 , \"ior\"                 , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_lor                 , \"lor\"                 , \"b\"    , NULL    , T_LONG   , -2, false);\n-  def(_ixor                , \"ixor\"                , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_lxor                , \"lxor\"                , \"b\"    , NULL    , T_LONG   , -2, false);\n-  def(_iinc                , \"iinc\"                , \"bic\"  , \"wbiicc\", T_VOID   ,  0, false);\n-  def(_i2l                 , \"i2l\"                 , \"b\"    , NULL    , T_LONG   ,  1, false);\n-  def(_i2f                 , \"i2f\"                 , \"b\"    , NULL    , T_FLOAT  ,  0, false);\n-  def(_i2d                 , \"i2d\"                 , \"b\"    , NULL    , T_DOUBLE ,  1, false);\n-  def(_l2i                 , \"l2i\"                 , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_l2f                 , \"l2f\"                 , \"b\"    , NULL    , T_FLOAT  , -1, false);\n-  def(_l2d                 , \"l2d\"                 , \"b\"    , NULL    , T_DOUBLE ,  0, false);\n-  def(_f2i                 , \"f2i\"                 , \"b\"    , NULL    , T_INT    ,  0, false);\n-  def(_f2l                 , \"f2l\"                 , \"b\"    , NULL    , T_LONG   ,  1, false);\n-  def(_f2d                 , \"f2d\"                 , \"b\"    , NULL    , T_DOUBLE ,  1, false);\n-  def(_d2i                 , \"d2i\"                 , \"b\"    , NULL    , T_INT    , -1, false);\n-  def(_d2l                 , \"d2l\"                 , \"b\"    , NULL    , T_LONG   ,  0, false);\n-  def(_d2f                 , \"d2f\"                 , \"b\"    , NULL    , T_FLOAT  , -1, false);\n-  def(_i2b                 , \"i2b\"                 , \"b\"    , NULL    , T_BYTE   ,  0, false);\n-  def(_i2c                 , \"i2c\"                 , \"b\"    , NULL    , T_CHAR   ,  0, false);\n-  def(_i2s                 , \"i2s\"                 , \"b\"    , NULL    , T_SHORT  ,  0, false);\n-  def(_lcmp                , \"lcmp\"                , \"b\"    , NULL    , T_VOID   , -3, false);\n-  def(_fcmpl               , \"fcmpl\"               , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_fcmpg               , \"fcmpg\"               , \"b\"    , NULL    , T_VOID   , -1, false);\n-  def(_dcmpl               , \"dcmpl\"               , \"b\"    , NULL    , T_VOID   , -3, false);\n-  def(_dcmpg               , \"dcmpg\"               , \"b\"    , NULL    , T_VOID   , -3, false);\n-  def(_ifeq                , \"ifeq\"                , \"boo\"  , NULL    , T_VOID   , -1, false);\n-  def(_ifne                , \"ifne\"                , \"boo\"  , NULL    , T_VOID   , -1, false);\n-  def(_iflt                , \"iflt\"                , \"boo\"  , NULL    , T_VOID   , -1, false);\n-  def(_ifge                , \"ifge\"                , \"boo\"  , NULL    , T_VOID   , -1, false);\n-  def(_ifgt                , \"ifgt\"                , \"boo\"  , NULL    , T_VOID   , -1, false);\n-  def(_ifle                , \"ifle\"                , \"boo\"  , NULL    , T_VOID   , -1, false);\n-  def(_if_icmpeq           , \"if_icmpeq\"           , \"boo\"  , NULL    , T_VOID   , -2, false);\n-  def(_if_icmpne           , \"if_icmpne\"           , \"boo\"  , NULL    , T_VOID   , -2, false);\n-  def(_if_icmplt           , \"if_icmplt\"           , \"boo\"  , NULL    , T_VOID   , -2, false);\n-  def(_if_icmpge           , \"if_icmpge\"           , \"boo\"  , NULL    , T_VOID   , -2, false);\n-  def(_if_icmpgt           , \"if_icmpgt\"           , \"boo\"  , NULL    , T_VOID   , -2, false);\n-  def(_if_icmple           , \"if_icmple\"           , \"boo\"  , NULL    , T_VOID   , -2, false);\n-  def(_if_acmpeq           , \"if_acmpeq\"           , \"boo\"  , NULL    , T_VOID   , -2, false);\n-  def(_if_acmpne           , \"if_acmpne\"           , \"boo\"  , NULL    , T_VOID   , -2, false);\n-  def(_goto                , \"goto\"                , \"boo\"  , NULL    , T_VOID   ,  0, false);\n-  def(_jsr                 , \"jsr\"                 , \"boo\"  , NULL    , T_INT    ,  0, false);\n-  def(_ret                 , \"ret\"                 , \"bi\"   , \"wbii\"  , T_VOID   ,  0, false);\n-  def(_tableswitch         , \"tableswitch\"         , \"\"     , NULL    , T_VOID   , -1, false); \/\/ may have backward branches\n-  def(_lookupswitch        , \"lookupswitch\"        , \"\"     , NULL    , T_VOID   , -1, false); \/\/ rewriting in interpreter\n-  def(_ireturn             , \"ireturn\"             , \"b\"    , NULL    , T_INT    , -1, true);\n-  def(_lreturn             , \"lreturn\"             , \"b\"    , NULL    , T_LONG   , -2, true);\n-  def(_freturn             , \"freturn\"             , \"b\"    , NULL    , T_FLOAT  , -1, true);\n-  def(_dreturn             , \"dreturn\"             , \"b\"    , NULL    , T_DOUBLE , -2, true);\n-  def(_areturn             , \"areturn\"             , \"b\"    , NULL    , T_OBJECT , -1, true);\n-  def(_return              , \"return\"              , \"b\"    , NULL    , T_VOID   ,  0, true);\n-  def(_getstatic           , \"getstatic\"           , \"bJJ\"  , NULL    , T_ILLEGAL,  1, true );\n-  def(_putstatic           , \"putstatic\"           , \"bJJ\"  , NULL    , T_ILLEGAL, -1, true );\n-  def(_getfield            , \"getfield\"            , \"bJJ\"  , NULL    , T_ILLEGAL,  0, true );\n-  def(_putfield            , \"putfield\"            , \"bJJ\"  , NULL    , T_ILLEGAL, -2, true );\n-  def(_invokevirtual       , \"invokevirtual\"       , \"bJJ\"  , NULL    , T_ILLEGAL, -1, true);\n-  def(_invokespecial       , \"invokespecial\"       , \"bJJ\"  , NULL    , T_ILLEGAL, -1, true);\n-  def(_invokestatic        , \"invokestatic\"        , \"bJJ\"  , NULL    , T_ILLEGAL,  0, true);\n-  def(_invokeinterface     , \"invokeinterface\"     , \"bJJ__\", NULL    , T_ILLEGAL, -1, true);\n-  def(_invokedynamic       , \"invokedynamic\"       , \"bJJJJ\", NULL    , T_ILLEGAL,  0, true );\n-  def(_new                 , \"new\"                 , \"bkk\"  , NULL    , T_OBJECT ,  1, true );\n-  def(_newarray            , \"newarray\"            , \"bc\"   , NULL    , T_OBJECT ,  0, true );\n-  def(_anewarray           , \"anewarray\"           , \"bkk\"  , NULL    , T_OBJECT ,  0, true );\n-  def(_arraylength         , \"arraylength\"         , \"b\"    , NULL    , T_INT    ,  0, true );\n-  def(_athrow              , \"athrow\"              , \"b\"    , NULL    , T_VOID   , -1, true );\n-  def(_checkcast           , \"checkcast\"           , \"bkk\"  , NULL    , T_OBJECT ,  0, true );\n-  def(_instanceof          , \"instanceof\"          , \"bkk\"  , NULL    , T_INT    ,  0, true );\n-  def(_monitorenter        , \"monitorenter\"        , \"b\"    , NULL    , T_VOID   , -1, true );\n-  def(_monitorexit         , \"monitorexit\"         , \"b\"    , NULL    , T_VOID   , -1, true );\n-  def(_wide                , \"wide\"                , \"\"     , NULL    , T_VOID   ,  0, false);\n-  def(_multianewarray      , \"multianewarray\"      , \"bkkc\" , NULL    , T_OBJECT ,  1, true );\n-  def(_ifnull              , \"ifnull\"              , \"boo\"  , NULL    , T_VOID   , -1, false);\n-  def(_ifnonnull           , \"ifnonnull\"           , \"boo\"  , NULL    , T_VOID   , -1, false);\n-  def(_goto_w              , \"goto_w\"              , \"boooo\", NULL    , T_VOID   ,  0, false);\n-  def(_jsr_w               , \"jsr_w\"               , \"boooo\", NULL    , T_INT    ,  0, false);\n-  def(_breakpoint          , \"breakpoint\"          , \"\"     , NULL    , T_VOID   ,  0, true);\n-  def(_aconst_init        , \"aconst_init\"        , \"bkk\"  , NULL    , T_OBJECT ,  1, true);\n-  def(_withfield           , \"withfield\"           , \"bJJ\"  , NULL    , T_OBJECT , -1, true );\n+  def(_nop                 , \"nop\"                 , \"b\"    , nullptr    , T_VOID   ,  0, false);\n+  def(_aconst_null         , \"aconst_null\"         , \"b\"    , nullptr    , T_OBJECT ,  1, false);\n+  def(_iconst_m1           , \"iconst_m1\"           , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iconst_0            , \"iconst_0\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iconst_1            , \"iconst_1\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iconst_2            , \"iconst_2\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iconst_3            , \"iconst_3\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iconst_4            , \"iconst_4\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iconst_5            , \"iconst_5\"            , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_lconst_0            , \"lconst_0\"            , \"b\"    , nullptr    , T_LONG   ,  2, false);\n+  def(_lconst_1            , \"lconst_1\"            , \"b\"    , nullptr    , T_LONG   ,  2, false);\n+  def(_fconst_0            , \"fconst_0\"            , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n+  def(_fconst_1            , \"fconst_1\"            , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n+  def(_fconst_2            , \"fconst_2\"            , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n+  def(_dconst_0            , \"dconst_0\"            , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n+  def(_dconst_1            , \"dconst_1\"            , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n+  def(_bipush              , \"bipush\"              , \"bc\"   , nullptr    , T_INT    ,  1, false);\n+  def(_sipush              , \"sipush\"              , \"bcc\"  , nullptr    , T_INT    ,  1, false);\n+  def(_ldc                 , \"ldc\"                 , \"bk\"   , nullptr    , T_ILLEGAL,  1, true );\n+  def(_ldc_w               , \"ldc_w\"               , \"bkk\"  , nullptr    , T_ILLEGAL,  1, true );\n+  def(_ldc2_w              , \"ldc2_w\"              , \"bkk\"  , nullptr    , T_ILLEGAL,  2, true );\n+  def(_iload               , \"iload\"               , \"bi\"   , \"wbii\"     , T_INT    ,  1, false);\n+  def(_lload               , \"lload\"               , \"bi\"   , \"wbii\"     , T_LONG   ,  2, false);\n+  def(_fload               , \"fload\"               , \"bi\"   , \"wbii\"     , T_FLOAT  ,  1, false);\n+  def(_dload               , \"dload\"               , \"bi\"   , \"wbii\"     , T_DOUBLE ,  2, false);\n+  def(_aload               , \"aload\"               , \"bi\"   , \"wbii\"     , T_OBJECT ,  1, false);\n+  def(_iload_0             , \"iload_0\"             , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iload_1             , \"iload_1\"             , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iload_2             , \"iload_2\"             , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_iload_3             , \"iload_3\"             , \"b\"    , nullptr    , T_INT    ,  1, false);\n+  def(_lload_0             , \"lload_0\"             , \"b\"    , nullptr    , T_LONG   ,  2, false);\n+  def(_lload_1             , \"lload_1\"             , \"b\"    , nullptr    , T_LONG   ,  2, false);\n+  def(_lload_2             , \"lload_2\"             , \"b\"    , nullptr    , T_LONG   ,  2, false);\n+  def(_lload_3             , \"lload_3\"             , \"b\"    , nullptr    , T_LONG   ,  2, false);\n+  def(_fload_0             , \"fload_0\"             , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n+  def(_fload_1             , \"fload_1\"             , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n+  def(_fload_2             , \"fload_2\"             , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n+  def(_fload_3             , \"fload_3\"             , \"b\"    , nullptr    , T_FLOAT  ,  1, false);\n+  def(_dload_0             , \"dload_0\"             , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n+  def(_dload_1             , \"dload_1\"             , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n+  def(_dload_2             , \"dload_2\"             , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n+  def(_dload_3             , \"dload_3\"             , \"b\"    , nullptr    , T_DOUBLE ,  2, false);\n+  def(_aload_0             , \"aload_0\"             , \"b\"    , nullptr    , T_OBJECT ,  1, true ); \/\/ rewriting in interpreter\n+  def(_aload_1             , \"aload_1\"             , \"b\"    , nullptr    , T_OBJECT ,  1, false);\n+  def(_aload_2             , \"aload_2\"             , \"b\"    , nullptr    , T_OBJECT ,  1, false);\n+  def(_aload_3             , \"aload_3\"             , \"b\"    , nullptr    , T_OBJECT ,  1, false);\n+  def(_iaload              , \"iaload\"              , \"b\"    , nullptr    , T_INT    , -1, true );\n+  def(_laload              , \"laload\"              , \"b\"    , nullptr    , T_LONG   ,  0, true );\n+  def(_faload              , \"faload\"              , \"b\"    , nullptr    , T_FLOAT  , -1, true );\n+  def(_daload              , \"daload\"              , \"b\"    , nullptr    , T_DOUBLE ,  0, true );\n+  def(_aaload              , \"aaload\"              , \"b\"    , nullptr    , T_OBJECT , -1, true );\n+  def(_baload              , \"baload\"              , \"b\"    , nullptr    , T_INT    , -1, true );\n+  def(_caload              , \"caload\"              , \"b\"    , nullptr    , T_INT    , -1, true );\n+  def(_saload              , \"saload\"              , \"b\"    , nullptr    , T_INT    , -1, true );\n+  def(_istore              , \"istore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -1, false);\n+  def(_lstore              , \"lstore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -2, false);\n+  def(_fstore              , \"fstore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -1, false);\n+  def(_dstore              , \"dstore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -2, false);\n+  def(_astore              , \"astore\"              , \"bi\"   , \"wbii\"     , T_VOID   , -1, false);\n+  def(_istore_0            , \"istore_0\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_istore_1            , \"istore_1\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_istore_2            , \"istore_2\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_istore_3            , \"istore_3\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_lstore_0            , \"lstore_0\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_lstore_1            , \"lstore_1\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_lstore_2            , \"lstore_2\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_lstore_3            , \"lstore_3\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_fstore_0            , \"fstore_0\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_fstore_1            , \"fstore_1\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_fstore_2            , \"fstore_2\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_fstore_3            , \"fstore_3\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_dstore_0            , \"dstore_0\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_dstore_1            , \"dstore_1\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_dstore_2            , \"dstore_2\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_dstore_3            , \"dstore_3\"            , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_astore_0            , \"astore_0\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_astore_1            , \"astore_1\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_astore_2            , \"astore_2\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_astore_3            , \"astore_3\"            , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_iastore             , \"iastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n+  def(_lastore             , \"lastore\"             , \"b\"    , nullptr    , T_VOID   , -4, true );\n+  def(_fastore             , \"fastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n+  def(_dastore             , \"dastore\"             , \"b\"    , nullptr    , T_VOID   , -4, true );\n+  def(_aastore             , \"aastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n+  def(_bastore             , \"bastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n+  def(_castore             , \"castore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n+  def(_sastore             , \"sastore\"             , \"b\"    , nullptr    , T_VOID   , -3, true );\n+  def(_pop                 , \"pop\"                 , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_pop2                , \"pop2\"                , \"b\"    , nullptr    , T_VOID   , -2, false);\n+  def(_dup                 , \"dup\"                 , \"b\"    , nullptr    , T_VOID   ,  1, false);\n+  def(_dup_x1              , \"dup_x1\"              , \"b\"    , nullptr    , T_VOID   ,  1, false);\n+  def(_dup_x2              , \"dup_x2\"              , \"b\"    , nullptr    , T_VOID   ,  1, false);\n+  def(_dup2                , \"dup2\"                , \"b\"    , nullptr    , T_VOID   ,  2, false);\n+  def(_dup2_x1             , \"dup2_x1\"             , \"b\"    , nullptr    , T_VOID   ,  2, false);\n+  def(_dup2_x2             , \"dup2_x2\"             , \"b\"    , nullptr    , T_VOID   ,  2, false);\n+  def(_swap                , \"swap\"                , \"b\"    , nullptr    , T_VOID   ,  0, false);\n+  def(_iadd                , \"iadd\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_ladd                , \"ladd\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n+  def(_fadd                , \"fadd\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n+  def(_dadd                , \"dadd\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n+  def(_isub                , \"isub\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_lsub                , \"lsub\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n+  def(_fsub                , \"fsub\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n+  def(_dsub                , \"dsub\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n+  def(_imul                , \"imul\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_lmul                , \"lmul\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n+  def(_fmul                , \"fmul\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n+  def(_dmul                , \"dmul\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n+  def(_idiv                , \"idiv\"                , \"b\"    , nullptr    , T_INT    , -1, true );\n+  def(_ldiv                , \"ldiv\"                , \"b\"    , nullptr    , T_LONG   , -2, true );\n+  def(_fdiv                , \"fdiv\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n+  def(_ddiv                , \"ddiv\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n+  def(_irem                , \"irem\"                , \"b\"    , nullptr    , T_INT    , -1, true );\n+  def(_lrem                , \"lrem\"                , \"b\"    , nullptr    , T_LONG   , -2, true );\n+  def(_frem                , \"frem\"                , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n+  def(_drem                , \"drem\"                , \"b\"    , nullptr    , T_DOUBLE , -2, false);\n+  def(_ineg                , \"ineg\"                , \"b\"    , nullptr    , T_INT    ,  0, false);\n+  def(_lneg                , \"lneg\"                , \"b\"    , nullptr    , T_LONG   ,  0, false);\n+  def(_fneg                , \"fneg\"                , \"b\"    , nullptr    , T_FLOAT  ,  0, false);\n+  def(_dneg                , \"dneg\"                , \"b\"    , nullptr    , T_DOUBLE ,  0, false);\n+  def(_ishl                , \"ishl\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_lshl                , \"lshl\"                , \"b\"    , nullptr    , T_LONG   , -1, false);\n+  def(_ishr                , \"ishr\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_lshr                , \"lshr\"                , \"b\"    , nullptr    , T_LONG   , -1, false);\n+  def(_iushr               , \"iushr\"               , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_lushr               , \"lushr\"               , \"b\"    , nullptr    , T_LONG   , -1, false);\n+  def(_iand                , \"iand\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_land                , \"land\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n+  def(_ior                 , \"ior\"                 , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_lor                 , \"lor\"                 , \"b\"    , nullptr    , T_LONG   , -2, false);\n+  def(_ixor                , \"ixor\"                , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_lxor                , \"lxor\"                , \"b\"    , nullptr    , T_LONG   , -2, false);\n+  def(_iinc                , \"iinc\"                , \"bic\"  , \"wbiicc\",    T_VOID   ,  0, false);\n+  def(_i2l                 , \"i2l\"                 , \"b\"    , nullptr    , T_LONG   ,  1, false);\n+  def(_i2f                 , \"i2f\"                 , \"b\"    , nullptr    , T_FLOAT  ,  0, false);\n+  def(_i2d                 , \"i2d\"                 , \"b\"    , nullptr    , T_DOUBLE ,  1, false);\n+  def(_l2i                 , \"l2i\"                 , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_l2f                 , \"l2f\"                 , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n+  def(_l2d                 , \"l2d\"                 , \"b\"    , nullptr    , T_DOUBLE ,  0, false);\n+  def(_f2i                 , \"f2i\"                 , \"b\"    , nullptr    , T_INT    ,  0, false);\n+  def(_f2l                 , \"f2l\"                 , \"b\"    , nullptr    , T_LONG   ,  1, false);\n+  def(_f2d                 , \"f2d\"                 , \"b\"    , nullptr    , T_DOUBLE ,  1, false);\n+  def(_d2i                 , \"d2i\"                 , \"b\"    , nullptr    , T_INT    , -1, false);\n+  def(_d2l                 , \"d2l\"                 , \"b\"    , nullptr    , T_LONG   ,  0, false);\n+  def(_d2f                 , \"d2f\"                 , \"b\"    , nullptr    , T_FLOAT  , -1, false);\n+  def(_i2b                 , \"i2b\"                 , \"b\"    , nullptr    , T_BYTE   ,  0, false);\n+  def(_i2c                 , \"i2c\"                 , \"b\"    , nullptr    , T_CHAR   ,  0, false);\n+  def(_i2s                 , \"i2s\"                 , \"b\"    , nullptr    , T_SHORT  ,  0, false);\n+  def(_lcmp                , \"lcmp\"                , \"b\"    , nullptr    , T_VOID   , -3, false);\n+  def(_fcmpl               , \"fcmpl\"               , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_fcmpg               , \"fcmpg\"               , \"b\"    , nullptr    , T_VOID   , -1, false);\n+  def(_dcmpl               , \"dcmpl\"               , \"b\"    , nullptr    , T_VOID   , -3, false);\n+  def(_dcmpg               , \"dcmpg\"               , \"b\"    , nullptr    , T_VOID   , -3, false);\n+  def(_ifeq                , \"ifeq\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n+  def(_ifne                , \"ifne\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n+  def(_iflt                , \"iflt\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n+  def(_ifge                , \"ifge\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n+  def(_ifgt                , \"ifgt\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n+  def(_ifle                , \"ifle\"                , \"boo\"  , nullptr    , T_VOID   , -1, false);\n+  def(_if_icmpeq           , \"if_icmpeq\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n+  def(_if_icmpne           , \"if_icmpne\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n+  def(_if_icmplt           , \"if_icmplt\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n+  def(_if_icmpge           , \"if_icmpge\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n+  def(_if_icmpgt           , \"if_icmpgt\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n+  def(_if_icmple           , \"if_icmple\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n+  def(_if_acmpeq           , \"if_acmpeq\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n+  def(_if_acmpne           , \"if_acmpne\"           , \"boo\"  , nullptr    , T_VOID   , -2, false);\n+  def(_goto                , \"goto\"                , \"boo\"  , nullptr    , T_VOID   ,  0, false);\n+  def(_jsr                 , \"jsr\"                 , \"boo\"  , nullptr    , T_INT    ,  0, false);\n+  def(_ret                 , \"ret\"                 , \"bi\"   , \"wbii\"     , T_VOID   ,  0, false);\n+  def(_tableswitch         , \"tableswitch\"         , \"\"     , nullptr    , T_VOID   , -1, false); \/\/ may have backward branches\n+  def(_lookupswitch        , \"lookupswitch\"        , \"\"     , nullptr    , T_VOID   , -1, false); \/\/ rewriting in interpreter\n+  def(_ireturn             , \"ireturn\"             , \"b\"    , nullptr    , T_INT    , -1, true);\n+  def(_lreturn             , \"lreturn\"             , \"b\"    , nullptr    , T_LONG   , -2, true);\n+  def(_freturn             , \"freturn\"             , \"b\"    , nullptr    , T_FLOAT  , -1, true);\n+  def(_dreturn             , \"dreturn\"             , \"b\"    , nullptr    , T_DOUBLE , -2, true);\n+  def(_areturn             , \"areturn\"             , \"b\"    , nullptr    , T_OBJECT , -1, true);\n+  def(_return              , \"return\"              , \"b\"    , nullptr    , T_VOID   ,  0, true);\n+  def(_getstatic           , \"getstatic\"           , \"bJJ\"  , nullptr    , T_ILLEGAL,  1, true );\n+  def(_putstatic           , \"putstatic\"           , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true );\n+  def(_getfield            , \"getfield\"            , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true );\n+  def(_putfield            , \"putfield\"            , \"bJJ\"  , nullptr    , T_ILLEGAL, -2, true );\n+  def(_invokevirtual       , \"invokevirtual\"       , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true);\n+  def(_invokespecial       , \"invokespecial\"       , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true);\n+  def(_invokestatic        , \"invokestatic\"        , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true);\n+  def(_invokeinterface     , \"invokeinterface\"     , \"bJJ__\", nullptr    , T_ILLEGAL, -1, true);\n+  def(_invokedynamic       , \"invokedynamic\"       , \"bJJJJ\", nullptr    , T_ILLEGAL,  0, true );\n+  def(_new                 , \"new\"                 , \"bkk\"  , nullptr    , T_OBJECT ,  1, true );\n+  def(_newarray            , \"newarray\"            , \"bc\"   , nullptr    , T_OBJECT ,  0, true );\n+  def(_anewarray           , \"anewarray\"           , \"bkk\"  , nullptr    , T_OBJECT ,  0, true );\n+  def(_arraylength         , \"arraylength\"         , \"b\"    , nullptr    , T_INT    ,  0, true );\n+  def(_athrow              , \"athrow\"              , \"b\"    , nullptr    , T_VOID   , -1, true );\n+  def(_checkcast           , \"checkcast\"           , \"bkk\"  , nullptr    , T_OBJECT ,  0, true );\n+  def(_instanceof          , \"instanceof\"          , \"bkk\"  , nullptr    , T_INT    ,  0, true );\n+  def(_monitorenter        , \"monitorenter\"        , \"b\"    , nullptr    , T_VOID   , -1, true );\n+  def(_monitorexit         , \"monitorexit\"         , \"b\"    , nullptr    , T_VOID   , -1, true );\n+  def(_wide                , \"wide\"                , \"\"     , nullptr    , T_VOID   ,  0, false);\n+  def(_multianewarray      , \"multianewarray\"      , \"bkkc\" , nullptr    , T_OBJECT ,  1, true );\n+  def(_ifnull              , \"ifnull\"              , \"boo\"  , nullptr    , T_VOID   , -1, false);\n+  def(_ifnonnull           , \"ifnonnull\"           , \"boo\"  , nullptr    , T_VOID   , -1, false);\n+  def(_goto_w              , \"goto_w\"              , \"boooo\", nullptr    , T_VOID   ,  0, false);\n+  def(_jsr_w               , \"jsr_w\"               , \"boooo\", nullptr    , T_INT    ,  0, false);\n+  def(_breakpoint          , \"breakpoint\"          , \"\"     , nullptr    , T_VOID   ,  0, true);\n+  def(_aconst_init         , \"aconst_ init\"        , \"bkk\"  , nullptr    , T_OBJECT ,  1, true);\n+  def(_withfield           , \"withfield\"           , \"bJJ\"  , nullptr    , T_OBJECT , -1, true);\n@@ -483,29 +483,29 @@\n-  def(_fast_agetfield      , \"fast_agetfield\"      , \"bJJ\"  , NULL    , T_OBJECT ,  0, true , _getfield       );\n-  def(_fast_qgetfield      , \"fast_qgetfield\"      , \"bJJ\"  , NULL    , T_OBJECT ,  0, true , _getfield       );\n-  def(_fast_bgetfield      , \"fast_bgetfield\"      , \"bJJ\"  , NULL    , T_INT    ,  0, true , _getfield       );\n-  def(_fast_cgetfield      , \"fast_cgetfield\"      , \"bJJ\"  , NULL    , T_CHAR   ,  0, true , _getfield       );\n-  def(_fast_dgetfield      , \"fast_dgetfield\"      , \"bJJ\"  , NULL    , T_DOUBLE ,  0, true , _getfield       );\n-  def(_fast_fgetfield      , \"fast_fgetfield\"      , \"bJJ\"  , NULL    , T_FLOAT  ,  0, true , _getfield       );\n-  def(_fast_igetfield      , \"fast_igetfield\"      , \"bJJ\"  , NULL    , T_INT    ,  0, true , _getfield       );\n-  def(_fast_lgetfield      , \"fast_lgetfield\"      , \"bJJ\"  , NULL    , T_LONG   ,  0, true , _getfield       );\n-  def(_fast_sgetfield      , \"fast_sgetfield\"      , \"bJJ\"  , NULL    , T_SHORT  ,  0, true , _getfield       );\n-\n-  def(_fast_aputfield      , \"fast_aputfield\"      , \"bJJ\"  , NULL    , T_OBJECT ,  0, true , _putfield       );\n-  def(_fast_qputfield      , \"fast_qputfield\"      , \"bJJ\"  , NULL    , T_OBJECT ,  0, true , _putfield       );\n-  def(_fast_bputfield      , \"fast_bputfield\"      , \"bJJ\"  , NULL    , T_INT    ,  0, true , _putfield       );\n-  def(_fast_zputfield      , \"fast_zputfield\"      , \"bJJ\"  , NULL    , T_INT    ,  0, true , _putfield       );\n-  def(_fast_cputfield      , \"fast_cputfield\"      , \"bJJ\"  , NULL    , T_CHAR   ,  0, true , _putfield       );\n-  def(_fast_dputfield      , \"fast_dputfield\"      , \"bJJ\"  , NULL    , T_DOUBLE ,  0, true , _putfield       );\n-  def(_fast_fputfield      , \"fast_fputfield\"      , \"bJJ\"  , NULL    , T_FLOAT  ,  0, true , _putfield       );\n-  def(_fast_iputfield      , \"fast_iputfield\"      , \"bJJ\"  , NULL    , T_INT    ,  0, true , _putfield       );\n-  def(_fast_lputfield      , \"fast_lputfield\"      , \"bJJ\"  , NULL    , T_LONG   ,  0, true , _putfield       );\n-  def(_fast_sputfield      , \"fast_sputfield\"      , \"bJJ\"  , NULL    , T_SHORT  ,  0, true , _putfield       );\n-\n-  def(_fast_aload_0        , \"fast_aload_0\"        , \"b\"    , NULL    , T_OBJECT ,  1, true , _aload_0        );\n-  def(_fast_iaccess_0      , \"fast_iaccess_0\"      , \"b_JJ\" , NULL    , T_INT    ,  1, true , _aload_0        );\n-  def(_fast_aaccess_0      , \"fast_aaccess_0\"      , \"b_JJ\" , NULL    , T_OBJECT ,  1, true , _aload_0        );\n-  def(_fast_faccess_0      , \"fast_faccess_0\"      , \"b_JJ\" , NULL    , T_OBJECT ,  1, true , _aload_0        );\n-\n-  def(_fast_iload          , \"fast_iload\"          , \"bi\"   , NULL    , T_INT    ,  1, false, _iload);\n-  def(_fast_iload2         , \"fast_iload2\"         , \"bi_i\" , NULL    , T_INT    ,  2, false, _iload);\n-  def(_fast_icaload        , \"fast_icaload\"        , \"bi_\"  , NULL    , T_INT    ,  0, false, _iload);\n+  def(_fast_agetfield      , \"fast_agetfield\"      , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _getfield       );\n+  def(_fast_qgetfield      , \"fast_qgetfield\"      , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _getfield       );\n+  def(_fast_bgetfield      , \"fast_bgetfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _getfield       );\n+  def(_fast_cgetfield      , \"fast_cgetfield\"      , \"bJJ\"  , nullptr    , T_CHAR   ,  0, true , _getfield       );\n+  def(_fast_dgetfield      , \"fast_dgetfield\"      , \"bJJ\"  , nullptr    , T_DOUBLE ,  0, true , _getfield       );\n+  def(_fast_fgetfield      , \"fast_fgetfield\"      , \"bJJ\"  , nullptr    , T_FLOAT  ,  0, true , _getfield       );\n+  def(_fast_igetfield      , \"fast_igetfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _getfield       );\n+  def(_fast_lgetfield      , \"fast_lgetfield\"      , \"bJJ\"  , nullptr    , T_LONG   ,  0, true , _getfield       );\n+  def(_fast_sgetfield      , \"fast_sgetfield\"      , \"bJJ\"  , nullptr    , T_SHORT  ,  0, true , _getfield       );\n+\n+  def(_fast_aputfield      , \"fast_aputfield\"      , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _putfield       );\n+  def(_fast_qputfield      , \"fast_qputfield\"      , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _putfield       );\n+  def(_fast_bputfield      , \"fast_bputfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield       );\n+  def(_fast_zputfield      , \"fast_zputfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield       );\n+  def(_fast_cputfield      , \"fast_cputfield\"      , \"bJJ\"  , nullptr    , T_CHAR   ,  0, true , _putfield       );\n+  def(_fast_dputfield      , \"fast_dputfield\"      , \"bJJ\"  , nullptr    , T_DOUBLE ,  0, true , _putfield       );\n+  def(_fast_fputfield      , \"fast_fputfield\"      , \"bJJ\"  , nullptr    , T_FLOAT  ,  0, true , _putfield       );\n+  def(_fast_iputfield      , \"fast_iputfield\"      , \"bJJ\"  , nullptr    , T_INT    ,  0, true , _putfield       );\n+  def(_fast_lputfield      , \"fast_lputfield\"      , \"bJJ\"  , nullptr    , T_LONG   ,  0, true , _putfield       );\n+  def(_fast_sputfield      , \"fast_sputfield\"      , \"bJJ\"  , nullptr    , T_SHORT  ,  0, true , _putfield       );\n+\n+  def(_fast_aload_0        , \"fast_aload_0\"        , \"b\"    , nullptr    , T_OBJECT ,  1, true , _aload_0        );\n+  def(_fast_iaccess_0      , \"fast_iaccess_0\"      , \"b_JJ\" , nullptr    , T_INT    ,  1, true , _aload_0        );\n+  def(_fast_aaccess_0      , \"fast_aaccess_0\"      , \"b_JJ\" , nullptr    , T_OBJECT ,  1, true , _aload_0        );\n+  def(_fast_faccess_0      , \"fast_faccess_0\"      , \"b_JJ\" , nullptr    , T_OBJECT ,  1, true , _aload_0        );\n+\n+  def(_fast_iload          , \"fast_iload\"          , \"bi\"   , nullptr    , T_INT    ,  1, false, _iload);\n+  def(_fast_iload2         , \"fast_iload2\"         , \"bi_i\" , nullptr    , T_INT    ,  2, false, _iload);\n+  def(_fast_icaload        , \"fast_icaload\"        , \"bi_\"  , nullptr    , T_INT    ,  0, false, _iload);\n@@ -514,1 +514,1 @@\n-  def(_fast_invokevfinal   , \"fast_invokevfinal\"   , \"bJJ\"  , NULL    , T_ILLEGAL, -1, true, _invokevirtual   );\n+  def(_fast_invokevfinal   , \"fast_invokevfinal\"   , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true, _invokevirtual   );\n@@ -516,2 +516,2 @@\n-  def(_fast_linearswitch   , \"fast_linearswitch\"   , \"\"     , NULL    , T_VOID   , -1, false, _lookupswitch   );\n-  def(_fast_binaryswitch   , \"fast_binaryswitch\"   , \"\"     , NULL    , T_VOID   , -1, false, _lookupswitch   );\n+  def(_fast_linearswitch   , \"fast_linearswitch\"   , \"\"     , nullptr    , T_VOID   , -1, false, _lookupswitch   );\n+  def(_fast_binaryswitch   , \"fast_binaryswitch\"   , \"\"     , nullptr    , T_VOID   , -1, false, _lookupswitch   );\n@@ -519,1 +519,1 @@\n-  def(_return_register_finalizer , \"return_register_finalizer\" , \"b\"    , NULL    , T_VOID   ,  0, true, _return);\n+  def(_return_register_finalizer , \"return_register_finalizer\" , \"b\"     , nullptr    , T_VOID   ,  0, true, _return);\n@@ -521,1 +521,1 @@\n-  def(_invokehandle        , \"invokehandle\"        , \"bJJ\"  , NULL    , T_ILLEGAL, -1, true, _invokevirtual   );\n+  def(_invokehandle        , \"invokehandle\"        , \"bJJ\"  , nullptr    , T_ILLEGAL, -1, true, _invokevirtual   );\n@@ -523,2 +523,2 @@\n-  def(_fast_aldc           , \"fast_aldc\"           , \"bj\"   , NULL    , T_OBJECT,   1, true,  _ldc   );\n-  def(_fast_aldc_w         , \"fast_aldc_w\"         , \"bJJ\"  , NULL    , T_OBJECT,   1, true,  _ldc_w );\n+  def(_fast_aldc           , \"fast_aldc\"           , \"bj\"   , nullptr    , T_OBJECT,   1, true,  _ldc   );\n+  def(_fast_aldc_w         , \"fast_aldc_w\"         , \"bJJ\"  , nullptr    , T_OBJECT,   1, true,  _ldc_w );\n@@ -526,2 +526,2 @@\n-  def(_nofast_getfield     , \"nofast_getfield\"     , \"bJJ\"  , NULL    , T_ILLEGAL,  0, true,  _getfield       );\n-  def(_nofast_putfield     , \"nofast_putfield\"     , \"bJJ\"  , NULL    , T_ILLEGAL, -2, true , _putfield       );\n+  def(_nofast_getfield     , \"nofast_getfield\"     , \"bJJ\"  , nullptr    , T_ILLEGAL,  0, true,  _getfield       );\n+  def(_nofast_putfield     , \"nofast_putfield\"     , \"bJJ\"  , nullptr    , T_ILLEGAL, -2, true , _putfield       );\n@@ -529,2 +529,2 @@\n-  def(_nofast_aload_0      , \"nofast_aload_0\"      , \"b\"    , NULL    , T_OBJECT,   1, true , _aload_0        );\n-  def(_nofast_iload        , \"nofast_iload\"        , \"bi\"   , NULL    , T_INT,      1, false, _iload          );\n+  def(_nofast_aload_0      , \"nofast_aload_0\"      , \"b\"    , nullptr    , T_OBJECT,   1, true , _aload_0        );\n+  def(_nofast_iload        , \"nofast_iload\"        , \"bi\"   , nullptr    , T_INT,      1, false, _iload          );\n@@ -532,1 +532,1 @@\n-  def(_shouldnotreachhere  , \"_shouldnotreachhere\" , \"b\"    , NULL    , T_VOID   ,  0, false);\n+  def(_shouldnotreachhere  , \"_shouldnotreachhere\" , \"b\"    , nullptr    , T_VOID   ,  0, false);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":258,"deletions":258,"binary":false,"changes":516,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,1 @@\n-  \/\/ NULL since in that case the bcp and Method* are unrelated\n+  \/\/ null since in that case the bcp and Method* are unrelated\n@@ -377,1 +377,1 @@\n-    assert(method == NULL || check_method(method, bcp), \"bcp must point into method\");\n+    assert(method == nullptr || check_method(method, bcp), \"bcp must point into method\");\n@@ -379,1 +379,1 @@\n-    assert(code != _breakpoint || method != NULL, \"need Method* to decode breakpoint\");\n+    assert(code != _breakpoint || method != nullptr, \"need Method* to decode breakpoint\");\n@@ -413,2 +413,2 @@\n-  static int         special_length_at(Bytecodes::Code code, address bcp, address end = NULL);\n-  static int         raw_special_length_at(address bcp, address end = NULL);\n+  static int         special_length_at(Bytecodes::Code code, address bcp, address end = nullptr);\n+  static int         raw_special_length_at(address bcp, address end = nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-    \/\/ That is why we must check both ProfileInterpreter and mdo != NULL.\n+    \/\/ That is why we must check both ProfileInterpreter and mdo != nullptr.\n@@ -144,1 +144,1 @@\n-    if (mdo != NULL) {\n+    if (mdo != nullptr) {\n@@ -194,1 +194,1 @@\n-  assert(result != NULL || is_fast_aldc, \"null result only valid for fast_aldc\");\n+  assert(result != nullptr || is_fast_aldc, \"null result only valid for fast_aldc\");\n@@ -205,1 +205,1 @@\n-      oop roop = (result == NULL ? Universe::the_null_sentinel() : result);\n+      oop roop = (result == nullptr ? Universe::the_null_sentinel() : result);\n@@ -275,1 +275,1 @@\n-  oop obj = NULL;\n+  oop obj = nullptr;\n@@ -281,1 +281,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -287,1 +287,1 @@\n-  oop ref = NULL;\n+  oop ref = nullptr;\n@@ -366,1 +366,1 @@\n-              if (ref_h() == NULL) {\n+              if (ref_h() == nullptr) {\n@@ -405,1 +405,1 @@\n-    if (field_k == NULL) {\n+    if (field_k == nullptr) {\n@@ -410,1 +410,1 @@\n-      assert(field_k != NULL, \"Should have been loaded or an exception thrown above\");\n+      assert(field_k != nullptr, \"Should have been loaded or an exception thrown above\");\n@@ -427,1 +427,1 @@\n-    if (NULL == message) {\n+    if (nullptr == message) {\n@@ -479,1 +479,1 @@\n-  assert(val != NULL, \"can't store null into flat array\");\n+  assert(val != nullptr, \"can't store null into flat array\");\n@@ -568,1 +568,1 @@\n-    if (trap_mdo == NULL) {\n+    if (trap_mdo == nullptr) {\n@@ -581,1 +581,1 @@\n-    if (trap_mdo != NULL) {\n+    if (trap_mdo != nullptr) {\n@@ -757,1 +757,1 @@\n-    assert(h_exception.not_null(), \"NULL exceptions should be handled by athrow\");\n+    assert(h_exception.not_null(), \"null exceptions should be handled by athrow\");\n@@ -800,1 +800,1 @@\n-  if (EnableJVMCI && h_method->method_data() != NULL) {\n+  if (EnableJVMCI && h_method->method_data() != nullptr) {\n@@ -802,2 +802,2 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, NULL);\n-    if (pdata != NULL && pdata->is_BitData()) {\n+    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    if (pdata != nullptr && pdata->is_BitData()) {\n@@ -816,2 +816,2 @@\n-  address continuation = NULL;\n-  address handler_pc = NULL;\n+  address continuation = nullptr;\n+  address handler_pc = nullptr;\n@@ -841,1 +841,1 @@\n-    JvmtiExport::notice_unwind_due_to_exception(current, h_method(), handler_pc, h_exception(), (handler_pc != NULL));\n+    JvmtiExport::notice_unwind_due_to_exception(current, h_method(), handler_pc, h_exception(), (handler_pc != nullptr));\n@@ -868,1 +868,1 @@\n-  assert(missingMethod != NULL, \"sanity\");\n+  assert(missingMethod != nullptr, \"sanity\");\n@@ -898,2 +898,2 @@\n-               recvKlass ? recvKlass->external_name() : \"NULL\",\n-               interfaceKlass ? interfaceKlass->external_name() : \"NULL\");\n+               recvKlass ? recvKlass->external_name() : \"nullptr\",\n+               interfaceKlass ? interfaceKlass->external_name() : \"nullptr\");\n@@ -1006,1 +1006,1 @@\n-         \"must be NULL or an object\");\n+         \"must be null or an object\");\n@@ -1009,1 +1009,1 @@\n-         \"must be NULL or an object\");\n+         \"must be null or an object\");\n@@ -1030,1 +1030,1 @@\n-  elem->set_obj(NULL);\n+  elem->set_obj(nullptr);\n@@ -1047,2 +1047,2 @@\n-  assert(exception() != NULL, \"vm result should be set\");\n-  current->set_vm_result(NULL); \/\/ clear vm result before continuing (may cause memory leaks and assert failures)\n+  assert(exception() != nullptr, \"vm result should be set\");\n+  current->set_vm_result(nullptr); \/\/ clear vm result before continuing (may cause memory leaks and assert failures)\n@@ -1072,1 +1072,1 @@\n-  Handle receiver(current, NULL);\n+  Handle receiver(current, nullptr);\n@@ -1258,2 +1258,2 @@\n-  assert(branch_bcp != NULL || nm == NULL, \"always returns null for non OSR requests\");\n-  if (branch_bcp != NULL && nm != NULL) {\n+  assert(branch_bcp != nullptr || nm == nullptr, \"always returns null for non OSR requests\");\n+  if (branch_bcp != nullptr && nm != nullptr) {\n@@ -1270,1 +1270,1 @@\n-    if (nm != NULL && bs_nm != NULL) {\n+    if (nm != nullptr && bs_nm != nullptr) {\n@@ -1273,1 +1273,1 @@\n-        nm = NULL;\n+        nm = nullptr;\n@@ -1277,1 +1277,1 @@\n-  if (nm != NULL && current->is_interp_only_mode()) {\n+  if (nm != nullptr && current->is_interp_only_mode()) {\n@@ -1283,1 +1283,1 @@\n-    nm = NULL;\n+    nm = nullptr;\n@@ -1287,1 +1287,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -1305,2 +1305,2 @@\n-  const int branch_bci = branch_bcp != NULL ? method->bci_from(branch_bcp) : InvocationEntryBci;\n-  const int bci = branch_bcp != NULL ? method->bci_from(last_frame.bcp()) : InvocationEntryBci;\n+  const int branch_bci = branch_bcp != nullptr ? method->bci_from(branch_bcp) : InvocationEntryBci;\n+  const int bci = branch_bcp != nullptr ? method->bci_from(last_frame.bcp()) : InvocationEntryBci;\n@@ -1308,1 +1308,1 @@\n-  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, NULL, CHECK_NULL);\n+  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, nullptr, CHECK_NULL);\n@@ -1311,1 +1311,1 @@\n-  if (osr_nm != NULL && bs_nm != NULL) {\n+  if (osr_nm != nullptr && bs_nm != nullptr) {\n@@ -1313,1 +1313,1 @@\n-      osr_nm = NULL;\n+      osr_nm = nullptr;\n@@ -1323,1 +1323,1 @@\n-  if (mdo == NULL)  return 0;\n+  if (mdo == nullptr)  return 0;\n@@ -1332,1 +1332,1 @@\n-  assert(mdo != NULL, \"must not be null\");\n+  assert(mdo != nullptr, \"must not be null\");\n@@ -1370,1 +1370,1 @@\n-  guarantee(data != NULL, \"profile data must be valid\");\n+  guarantee(data != nullptr, \"profile data must be valid\");\n@@ -1428,1 +1428,1 @@\n-  bool is_static = (obj == NULL);\n+  bool is_static = (obj == nullptr);\n@@ -1474,1 +1474,1 @@\n-  bool is_static = (obj == NULL);\n+  bool is_static = (obj == nullptr);\n@@ -1540,2 +1540,2 @@\n-  if (handler_blob == NULL) {\n-    return NULL;\n+  if (handler_blob == nullptr) {\n+    return nullptr;\n@@ -1550,1 +1550,1 @@\n-  if (_fingerprints != NULL) {\n+  if (_fingerprints != nullptr) {\n@@ -1553,1 +1553,1 @@\n-  if (set_handler_blob() == NULL) {\n+  if (set_handler_blob() == nullptr) {\n@@ -1572,1 +1572,1 @@\n-  if (handler != NULL) {\n+  if (handler != nullptr) {\n@@ -1582,1 +1582,1 @@\n-  if (method->signature_handler() == NULL) {\n+  if (method->signature_handler() == nullptr) {\n@@ -1605,1 +1605,1 @@\n-        if (handler == NULL) {\n+        if (handler == nullptr) {\n@@ -1668,1 +1668,1 @@\n-    if (_handlers != NULL) {\n+    if (_handlers != nullptr) {\n@@ -1712,5 +1712,5 @@\n-BufferBlob*              SignatureHandlerLibrary::_handler_blob = NULL;\n-address                  SignatureHandlerLibrary::_handler      = NULL;\n-GrowableArray<uint64_t>* SignatureHandlerLibrary::_fingerprints = NULL;\n-GrowableArray<address>*  SignatureHandlerLibrary::_handlers     = NULL;\n-address                  SignatureHandlerLibrary::_buffer       = NULL;\n+BufferBlob*              SignatureHandlerLibrary::_handler_blob = nullptr;\n+address                  SignatureHandlerLibrary::_handler      = nullptr;\n+GrowableArray<uint64_t>* SignatureHandlerLibrary::_fingerprints = nullptr;\n+GrowableArray<address>*  SignatureHandlerLibrary::_handlers     = nullptr;\n+address                  SignatureHandlerLibrary::_buffer       = nullptr;\n@@ -1779,1 +1779,1 @@\n-    current->set_vm_result(NULL);\n+    current->set_vm_result(nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  if (resolved_klass == NULL) { \/\/ 2nd argument defaults to holder of 1st\n+  if (resolved_klass == nullptr) { \/\/ 2nd argument defaults to holder of 1st\n@@ -187,1 +187,1 @@\n-  assert(_resolved_method() != NULL, \"Should already have a Method*\");\n+  assert(_resolved_method() != nullptr, \"Should already have a Method*\");\n@@ -270,1 +270,1 @@\n-                _current_klass == NULL ? \"(none)\" : _current_klass->name()->as_C_string(),\n+                _current_klass == nullptr ? \"(none)\" : _current_klass->name()->as_C_string(),\n@@ -298,1 +298,1 @@\n-    if (msg == NULL) {\n+    if (msg == nullptr) {\n@@ -348,1 +348,1 @@\n-      result != NULL &&\n+      result != nullptr &&\n@@ -352,1 +352,1 @@\n-    result = NULL;\n+    result = nullptr;\n@@ -357,1 +357,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -361,1 +361,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -363,1 +363,1 @@\n-    if (default_methods != NULL) {\n+    if (default_methods != nullptr) {\n@@ -368,1 +368,1 @@\n-  if (checkpolymorphism && result != NULL) {\n+  if (checkpolymorphism && result != nullptr) {\n@@ -372,1 +372,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -386,1 +386,1 @@\n-  while (result != NULL && result->is_static() && result->method_holder()->super() != NULL) {\n+  while (result != nullptr && result->is_static() && result->method_holder()->super() != nullptr) {\n@@ -396,1 +396,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -398,1 +398,1 @@\n-    if (default_methods != NULL) {\n+    if (default_methods != nullptr) {\n@@ -400,1 +400,1 @@\n-      assert(result == NULL || !result->is_static(), \"static defaults not allowed\");\n+      assert(result == nullptr || !result->is_static(), \"static defaults not allowed\");\n@@ -449,1 +449,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -462,1 +462,1 @@\n-               && appendix_result_or_null != NULL) {\n+               && appendix_result_or_null != nullptr) {\n@@ -468,1 +468,1 @@\n-        if (natives == NULL || InstanceKlass::cast(natives)->is_not_initialized()) {\n+        if (natives == nullptr || InstanceKlass::cast(natives)->is_not_initialized()) {\n@@ -491,1 +491,1 @@\n-      if (result != NULL) {\n+      if (result != nullptr) {\n@@ -511,1 +511,1 @@\n-        assert(appendix_result_or_null != NULL, \"\");\n+        assert(appendix_result_or_null != nullptr, \"\");\n@@ -517,1 +517,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -527,1 +527,1 @@\n-  if (nest_host_error_1 != NULL || nest_host_error_2 != NULL) {\n+  if (nest_host_error_1 != nullptr || nest_host_error_2 != nullptr) {\n@@ -529,3 +529,3 @@\n-              (nest_host_error_1 != NULL) ? nest_host_error_1 : \"\",\n-              (nest_host_error_1 != NULL && nest_host_error_2 != NULL) ? \", \" : \"\",\n-              (nest_host_error_2 != NULL) ? nest_host_error_2 : \"\");\n+              (nest_host_error_1 != nullptr) ? nest_host_error_1 : \"\",\n+              (nest_host_error_1 != nullptr && nest_host_error_2 != nullptr) ? \", \" : \"\",\n+              (nest_host_error_2 != nullptr) ? nest_host_error_2 : \"\");\n@@ -560,1 +560,1 @@\n-\/\/  assert(extra_arg_result_or_null != NULL, \"must be able to return extra argument\");\n+\/\/  assert(extra_arg_result_or_null != nullptr, \"must be able to return extra argument\");\n@@ -634,1 +634,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -660,1 +660,1 @@\n-                                              \/*klass_being_linked*\/ NULL, \/\/ We are not linking class\n+                                              \/*klass_being_linked*\/ nullptr, \/\/ We are not linking class\n@@ -663,1 +663,1 @@\n-  if (failed_type_symbol != NULL) {\n+  if (failed_type_symbol != nullptr) {\n@@ -666,1 +666,1 @@\n-    assert(current_loader_data != NULL, \"current class has no class loader data\");\n+    assert(current_loader_data != nullptr, \"current class has no class loader data\");\n@@ -669,1 +669,1 @@\n-    assert(target_loader_data != NULL, \"resolved method's class has no class loader data\");\n+    assert(target_loader_data != nullptr, \"resolved method's class has no class loader data\");\n@@ -697,1 +697,1 @@\n-                                              \/*klass_being_linked*\/ NULL, \/\/ We are not linking class\n+                                              \/*klass_being_linked*\/ nullptr, \/\/ We are not linking class\n@@ -700,1 +700,1 @@\n-  if (failed_type_symbol != NULL) {\n+  if (failed_type_symbol != nullptr) {\n@@ -756,1 +756,1 @@\n-      Method* method = lookup_polymorphic_method(link_info, (Handle*)NULL, THREAD);\n+      Method* method = lookup_polymorphic_method(link_info, (Handle*)nullptr, THREAD);\n@@ -773,1 +773,1 @@\n-                     ss.as_string(), nested_exception, NULL);\n+                     ss.as_string(), nested_exception, nullptr);\n@@ -779,1 +779,1 @@\n-    assert(current_klass != NULL , \"current_klass should not be null\");\n+    assert(current_klass != nullptr , \"current_klass should not be null\");\n@@ -816,1 +816,1 @@\n-            (klass == NULL ? \"<NULL>\" : klass->internal_name()),\n+            (klass == nullptr ? \"<nullptr>\" : klass->internal_name()),\n@@ -876,1 +876,1 @@\n-    assert(current_klass != NULL , \"current_klass should not be null\");\n+    assert(current_klass != nullptr , \"current_klass should not be null\");\n@@ -993,1 +993,1 @@\n-  if (sel_klass == NULL) {\n+  if (sel_klass == nullptr) {\n@@ -1045,1 +1045,1 @@\n-        assert(m != NULL, \"information about the current method must be available for 'put' bytecodes\");\n+        assert(m != nullptr, \"information about the current method must be available for 'put' bytecodes\");\n@@ -1076,1 +1076,1 @@\n-  if (link_info.check_loader_constraints() && (sel_klass != current_klass) && (current_klass != NULL)) {\n+  if (link_info.check_loader_constraints() && (sel_klass != current_klass) && (current_klass != nullptr)) {\n@@ -1116,1 +1116,1 @@\n-      && resolved_method->from_interpreted_entry() == NULL) { \/\/ does a load_acquire\n+      && resolved_method->from_interpreted_entry() == nullptr) { \/\/ does a load_acquire\n@@ -1170,1 +1170,1 @@\n-  Method* resolved_method = NULL;\n+  Method* resolved_method = nullptr;\n@@ -1194,1 +1194,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1200,1 +1200,1 @@\n-  if (current_klass != NULL && resolved_klass->is_interface()) {\n+  if (current_klass != nullptr && resolved_klass->is_interface()) {\n@@ -1365,1 +1365,1 @@\n-             (current_klass == NULL ? \"<null>\" : current_klass->internal_name()));\n+             (current_klass == nullptr ? \"<null>\" : current_klass->internal_name()));\n@@ -1575,1 +1575,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1587,1 +1587,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1601,1 +1601,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1614,1 +1614,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1638,1 +1638,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1649,1 +1649,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1719,1 +1719,1 @@\n-  Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv->klass();\n+  Klass* recvrKlass = recv.is_null() ? (Klass*)nullptr : recv->klass();\n@@ -1726,1 +1726,1 @@\n-  Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv->klass();\n+  Klass* recvrKlass = recv.is_null() ? (Klass*)nullptr : recv->klass();\n@@ -1780,1 +1780,1 @@\n-      assert(current_klass != NULL , \"current_klass should not be null\");\n+      assert(current_klass != nullptr , \"current_klass should not be null\");\n@@ -1886,1 +1886,1 @@\n-  if (recv_klass != NULL) {\n+  if (recv_klass != nullptr) {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-    throw_abstract_method_error(resolved_method, methodHandle(), NULL, CHECK);\n+    throw_abstract_method_error(resolved_method, methodHandle(), nullptr, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    _next = NULL;\n+    _next = nullptr;\n@@ -193,2 +193,2 @@\n-  bool result = _method == NULL;\n-  assert(_method != NULL || (_bci == 0 &&\n+  bool result = _method == nullptr;\n+  assert(_method != nullptr || (_bci == 0 &&\n@@ -201,1 +201,1 @@\n-  _method    = NULL;\n+  _method    = nullptr;\n@@ -446,1 +446,1 @@\n-OopMapCacheEntry* volatile OopMapCache::_old_entries = NULL;\n+OopMapCacheEntry* volatile OopMapCache::_old_entries = nullptr;\n@@ -450,1 +450,1 @@\n-  for(int i = 0; i < _size; i++) _array[i] = NULL;\n+  for(int i = 0; i < _size; i++) _array[i] = nullptr;\n@@ -455,1 +455,1 @@\n-  assert(_array != NULL, \"sanity check\");\n+  assert(_array != nullptr, \"sanity check\");\n@@ -473,2 +473,2 @@\n-    if (entry != NULL) {\n-      _array[i] = NULL;  \/\/ no barrier, only called in OopMapCache destructor\n+    if (entry != nullptr) {\n+      _array[i] = nullptr;  \/\/ no barrier, only called in OopMapCache destructor\n@@ -485,1 +485,1 @@\n-    if (entry != NULL && !entry->is_empty() && entry->method()->is_old()) {\n+    if (entry != nullptr && !entry->is_empty() && entry->method()->is_old()) {\n@@ -494,1 +494,1 @@\n-      _array[i] = NULL;\n+      _array[i] = nullptr;\n@@ -509,1 +509,1 @@\n-  OopMapCacheEntry* entry = NULL;\n+  OopMapCacheEntry* entry = nullptr;\n@@ -522,1 +522,1 @@\n-    if (entry != NULL && !entry->is_empty() && entry->match(method, bci)) {\n+    if (entry != nullptr && !entry->is_empty() && entry->match(method, bci)) {\n@@ -543,0 +543,1 @@\n+    tmp->flush();\n@@ -550,2 +551,2 @@\n-    if (entry == NULL) {\n-      if (put_at(probe + i, tmp, NULL)) {\n+    if (entry == nullptr) {\n+      if (put_at(probe + i, tmp, nullptr)) {\n@@ -593,2 +594,2 @@\n-  _old_entries = NULL;\n-  while (entry != NULL) {\n+  _old_entries = nullptr;\n+  while (entry != nullptr) {\n@@ -613,0 +614,1 @@\n+  tmp->flush();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-    _pool->set_cache(NULL);  \/\/ so the verifier isn't confused\n+    _pool->set_cache(nullptr);  \/\/ so the verifier isn't confused\n@@ -459,1 +459,1 @@\n-            if (klass->find_field(field_name, field_sig, &fd) != NULL) {\n+            if (klass->find_field(field_name, field_sig, &fd) != nullptr) {\n@@ -533,1 +533,1 @@\n-  assert(_pool->cache() == NULL, \"constant pool cache must not be set yet\");\n+  assert(_pool->cache() == nullptr, \"constant pool cache must not be set yet\");\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-  _unimplemented_bytecode    = NULL;\n-  _illegal_bytecode_sequence = NULL;\n+  _unimplemented_bytecode    = nullptr;\n+  _illegal_bytecode_sequence = nullptr;\n@@ -175,1 +175,1 @@\n-    Interpreter::_throw_NullPointerException_entry           = generate_exception_handler(\"java\/lang\/NullPointerException\", NULL);\n+    Interpreter::_throw_NullPointerException_entry           = generate_exception_handler(\"java\/lang\/NullPointerException\", nullptr);\n@@ -251,1 +251,1 @@\n-    vmassert(return_continuation != NULL, \"return entry not generated yet\");\n+    vmassert(return_continuation != nullptr, \"return entry not generated yet\");\n@@ -299,2 +299,2 @@\n-  assert(_unimplemented_bytecode    != NULL, \"should have been generated before\");\n-  assert(_illegal_bytecode_sequence != NULL, \"should have been generated before\");\n+  assert(_unimplemented_bytecode    != nullptr, \"should have been generated before\");\n+  assert(_illegal_bytecode_sequence != nullptr, \"should have been generated before\");\n@@ -402,1 +402,1 @@\n-  address entry_point = NULL;\n+  address entry_point = nullptr;\n@@ -473,1 +473,1 @@\n-    if (entry_point == NULL) {\n+    if (entry_point == nullptr) {\n@@ -478,1 +478,1 @@\n-    if (entry_point == NULL) {\n+    if (entry_point == nullptr) {\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  bool      is_valid() const                     { return _gen != NULL; }\n+  bool      is_valid() const                     { return _gen != nullptr; }\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (mtJVMCI) ConstantOopWriteValue(NULL);\n+ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (mtJVMCI) ConstantOopWriteValue(nullptr);\n@@ -255,1 +255,1 @@\n-    if (SharedRuntime::polling_page_vectors_safepoint_handler_blob() == NULL) {\n+    if (SharedRuntime::polling_page_vectors_safepoint_handler_blob() == nullptr) {\n@@ -380,1 +380,1 @@\n-    JVMCI_THROW_MSG_(InternalError, \"Constant was unexpectedly NULL\", Handle());\n+    JVMCI_THROW_MSG_(InternalError, \"Constant was unexpectedly null\", Handle());\n@@ -388,1 +388,1 @@\n-  second = NULL;\n+  second = nullptr;\n@@ -487,1 +487,1 @@\n-    ScopeValue* cur_second = NULL;\n+    ScopeValue* cur_second = nullptr;\n@@ -509,1 +509,1 @@\n-    if (isLongArray && cur_second == NULL) {\n+    if (isLongArray && cur_second == nullptr) {\n@@ -515,1 +515,1 @@\n-    if (isByteArray && cur_second != NULL && (type == T_DOUBLE || type == T_LONG)) {\n+    if (isByteArray && cur_second != nullptr && (type == T_DOUBLE || type == T_LONG)) {\n@@ -518,1 +518,1 @@\n-      cur_second = NULL;\n+      cur_second = nullptr;\n@@ -521,1 +521,1 @@\n-    if (cur_second != NULL) {\n+    if (cur_second != nullptr) {\n@@ -524,1 +524,1 @@\n-    assert(value != NULL, \"missing value\");\n+    assert(value != nullptr, \"missing value\");\n@@ -576,1 +576,1 @@\n-    ScopeValue* second = NULL;\n+    ScopeValue* second = nullptr;\n@@ -578,1 +578,1 @@\n-    assert(second == NULL, \"monitor cannot occupy two stack slots\");\n+    assert(second == nullptr, \"monitor cannot occupy two stack slots\");\n@@ -592,1 +592,1 @@\n-  CompilerThread* compilerThread = thread->is_Compiler_thread() ? CompilerThread::cast(thread) : NULL;\n+  CompilerThread* compilerThread = thread->is_Compiler_thread() ? CompilerThread::cast(thread) : nullptr;\n@@ -594,1 +594,1 @@\n-  _dependencies = new Dependencies(&_arena, _oop_recorder, compilerThread != NULL ? compilerThread->log() : NULL);\n+  _dependencies = new Dependencies(&_arena, _oop_recorder, compilerThread != nullptr ? compilerThread->log() : nullptr);\n@@ -717,1 +717,1 @@\n-    if (compile_state != NULL) {\n+    if (compile_state != nullptr) {\n@@ -731,1 +731,1 @@\n-    nmethod* nm = NULL; \/\/ nm is an out parameter of register_method\n+    nmethod* nm = nullptr; \/\/ nm is an out parameter of register_method\n@@ -757,1 +757,1 @@\n-      if (compile_state == NULL) {\n+      if (compile_state == nullptr) {\n@@ -766,1 +766,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -864,1 +864,1 @@\n-  if (buffer.blob() == NULL) {\n+  if (buffer.blob() == nullptr) {\n@@ -1020,1 +1020,1 @@\n-  GrowableArray<ScopeValue*> *objects = new GrowableArray<ScopeValue*>(length, length, NULL);\n+  GrowableArray<ScopeValue*> *objects = new GrowableArray<ScopeValue*>(length, length, nullptr);\n@@ -1079,3 +1079,3 @@\n-      DebugToken* locals_token = NULL;\n-      DebugToken* stack_token = NULL;\n-      DebugToken* monitors_token = NULL;\n+      DebugToken* locals_token = nullptr;\n+      DebugToken* stack_token = nullptr;\n+      DebugToken* monitors_token = nullptr;\n@@ -1104,1 +1104,1 @@\n-      _debug_recorder->describe_scope(pc_offset, method, NULL, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n+      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-JVMCICompiler* JVMCICompiler::_instance = NULL;\n+JVMCICompiler* JVMCICompiler::_instance = nullptr;\n@@ -43,1 +43,1 @@\n-  assert(_instance == NULL, \"only one instance allowed\");\n+  assert(_instance == nullptr, \"only one instance allowed\");\n@@ -51,1 +51,1 @@\n-  if (_instance == NULL && require_non_null) {\n+  if (_instance == nullptr && require_non_null) {\n@@ -133,1 +133,1 @@\n-    if (runtime != NULL) {\n+    if (runtime != nullptr) {\n@@ -138,1 +138,1 @@\n-      JVMCIEnv* ignored_env = NULL;\n+      JVMCIEnv* ignored_env = nullptr;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  if (klass != NULL) {\n+  if (klass != nullptr) {\n@@ -80,1 +80,1 @@\n-  if (klass != NULL) {\n+  if (klass != nullptr) {\n@@ -128,1 +128,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -130,1 +130,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -140,1 +140,1 @@\n-  if (thread == NULL) {                                  \\\n+  if (thread == nullptr) {                                  \\\n@@ -151,1 +151,1 @@\n-  if (thread == NULL) {                                  \\\n+  if (thread == nullptr) {                                  \\\n@@ -159,1 +159,1 @@\n-#define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)\n+#define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, nullptr)\n@@ -202,1 +202,1 @@\n-  if (flag == NULL) {\n+  if (flag == nullptr) {\n@@ -332,1 +332,1 @@\n-  oop mirror = NULL;\n+  oop mirror = nullptr;\n@@ -350,1 +350,1 @@\n-  Method* method = NULL;\n+  Method* method = nullptr;\n@@ -362,1 +362,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -371,1 +371,1 @@\n-  ConstantPool* cp = NULL;\n+  ConstantPool* cp = nullptr;\n@@ -422,1 +422,1 @@\n-  assert (klass == NULL || klass->is_klass(), \"invalid read\");\n+  assert (klass == nullptr || klass->is_klass(), \"invalid read\");\n@@ -837,1 +837,1 @@\n-      \/\/ Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.\n+      \/\/ Signature polymorphic methods are already resolved, JVMCI just returns null in this case.\n@@ -866,1 +866,1 @@\n-    \/\/ Return NULL if there was a problem with lookup (uninitialized class, etc.)\n+    \/\/ Return null if there was a problem with lookup (uninitialized class, etc.)\n@@ -940,1 +940,1 @@\n-  CodeBlob* cb = NULL;\n+  CodeBlob* cb = nullptr;\n@@ -980,1 +980,1 @@\n-    assert(cb == NULL, \"should be\");\n+    assert(cb == nullptr, \"should be\");\n@@ -1009,1 +1009,1 @@\n-  if (installedCode == NULL) {\n+  if (installedCode == nullptr) {\n@@ -1015,2 +1015,2 @@\n-  if (cb == NULL) {\n-    return NULL;\n+  if (cb == nullptr) {\n+    return nullptr;\n@@ -1030,1 +1030,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1054,1 +1054,1 @@\n-  if (nm == NULL || !nm->is_in_use()) {\n+  if (nm == nullptr || !nm->is_in_use()) {\n@@ -1067,1 +1067,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1097,1 +1097,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1137,1 +1137,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -1143,1 +1143,1 @@\n-  if (code != NULL) {\n+  if (code != nullptr) {\n@@ -1148,1 +1148,1 @@\n-  if (method_data == NULL) {\n+  if (method_data == nullptr) {\n@@ -1197,1 +1197,1 @@\n-  return mdo != NULL && mdo->is_mature();\n+  return mdo != nullptr && mdo->is_mature();\n@@ -1202,1 +1202,1 @@\n-  return method->lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;\n+  return method->lookup_osr_nmethod_for(entry_bci, comp_level, true) != nullptr;\n@@ -1224,1 +1224,1 @@\n-    Method* resolved_method = NULL;\n+    Method* resolved_method = nullptr;\n@@ -1240,1 +1240,1 @@\n-  if (resolved_methods == NULL) {\n+  if (resolved_methods == nullptr) {\n@@ -1244,1 +1244,1 @@\n-  assert(method != NULL, \"method should not be NULL\");\n+  assert(method != nullptr, \"method should not be null\");\n@@ -1262,1 +1262,1 @@\n-  Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver->klass();\n+  Klass* recvrKlass = receiver.is_null() ? (Klass*)nullptr : receiver->klass();\n@@ -1295,1 +1295,1 @@\n- * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or NULL if none.\n+ * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or null if none.\n@@ -1298,1 +1298,1 @@\n-  GrowableArray<ScopeValue*>* unallocated = NULL;\n+  GrowableArray<ScopeValue*>* unallocated = nullptr;\n@@ -1302,1 +1302,1 @@\n-      if (unallocated == NULL) {\n+      if (unallocated == nullptr) {\n@@ -1314,1 +1314,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1325,1 +1325,1 @@\n-  GrowableArray<Method*>* resolved_methods = NULL;\n+  GrowableArray<Method*>* resolved_methods = nullptr;\n@@ -1332,1 +1332,1 @@\n-    compiledVFrame* prev_cvf = NULL;\n+    compiledVFrame* prev_cvf = nullptr;\n@@ -1340,1 +1340,1 @@\n-      if (methods == NULL || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n+      if (methods == nullptr || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n@@ -1346,1 +1346,1 @@\n-        if (prev_cvf != NULL && prev_cvf->frame_pointer()->id() == frame_id) {\n+        if (prev_cvf != nullptr && prev_cvf->frame_pointer()->id() == frame_id) {\n@@ -1353,1 +1353,1 @@\n-        StackValueCollection* locals = NULL;\n+        StackValueCollection* locals = nullptr;\n@@ -1361,1 +1361,1 @@\n-          if (scope != NULL && scope->objects() != NULL) {\n+          if (scope != nullptr && scope->objects() != nullptr) {\n@@ -1364,1 +1364,1 @@\n-            GrowableArray<ScopeValue*>* objects = NULL;\n+            GrowableArray<ScopeValue*>* objects = nullptr;\n@@ -1372,1 +1372,1 @@\n-            if (objects != NULL) {\n+            if (objects != nullptr) {\n@@ -1437,1 +1437,1 @@\n-        if (result.get_oop() != NULL) {\n+        if (result.get_oop() != nullptr) {\n@@ -1442,2 +1442,2 @@\n-          if (resolved_methods != NULL && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n-            resolved_methods = NULL;\n+          if (resolved_methods != nullptr && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n+            resolved_methods = nullptr;\n@@ -1449,1 +1449,1 @@\n-          prev_cvf = NULL;\n+          prev_cvf = nullptr;\n@@ -1458,1 +1458,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1506,1 +1506,1 @@\n-      vmassert(cp_cache_entry->appendix_if_resolved(cp) == NULL, \"!\");\n+      vmassert(cp_cache_entry->appendix_if_resolved(cp) == nullptr, \"!\");\n@@ -1598,1 +1598,1 @@\n-  assert (virtualFrames->at(last_frame_number)->scope() != NULL,\"invalid scope\");\n+  assert (virtualFrames->at(last_frame_number)->scope() != nullptr,\"invalid scope\");\n@@ -1601,1 +1601,1 @@\n-  if (objects == NULL) {\n+  if (objects == nullptr) {\n@@ -1614,1 +1614,1 @@\n-    if (locals != NULL) {\n+    if (locals != nullptr) {\n@@ -1627,1 +1627,1 @@\n-    if (expressions != NULL) {\n+    if (expressions != nullptr) {\n@@ -1640,1 +1640,1 @@\n-    if (monitors != NULL) {\n+    if (monitors != nullptr) {\n@@ -1648,1 +1648,1 @@\n-  JVMCIENV->set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);\n+  JVMCIENV->set_HotSpotStackFrameReference_localIsVirtual(hs_frame, nullptr);\n@@ -1739,1 +1739,1 @@\n-  if (component_klass != NULL) {\n+  if (component_klass != nullptr) {\n@@ -1772,1 +1772,1 @@\n-  if (bytecode_frame_handle == NULL) {\n+  if (bytecode_frame_handle == nullptr) {\n@@ -1831,1 +1831,1 @@\n-  return (StringTable::lookup(name, len) != NULL);\n+  return (StringTable::lookup(name, len) != nullptr);\n@@ -1836,1 +1836,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -1843,1 +1843,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1850,1 +1850,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -1856,1 +1856,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1861,2 +1861,2 @@\n-  Klass* box_klass = NULL;\n-  Symbol* box_signature = NULL;\n+  Klass* box_klass = nullptr;\n+  Symbol* box_signature = nullptr;\n@@ -2059,1 +2059,1 @@\n-  \/\/ asConstant will throw an NPE if a constant contains NULL\n+  \/\/ asConstant will throw an NPE if a constant contains null\n@@ -2076,1 +2076,1 @@\n-  if (object == NULL || klass == nullptr) {\n+  if (object == nullptr || klass == nullptr) {\n@@ -2105,1 +2105,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -2120,1 +2120,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2125,1 +2125,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -2136,1 +2136,1 @@\n-  if (x == NULL || y == NULL) {\n+  if (x == nullptr || y == nullptr) {\n@@ -2154,1 +2154,1 @@\n-  if (x == NULL) {\n+  if (x == nullptr) {\n@@ -2166,1 +2166,1 @@\n-  if (x == NULL) {\n+  if (x == nullptr) {\n@@ -2174,1 +2174,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2201,1 +2201,1 @@\n-  return NULL;;\n+  return nullptr;;\n@@ -2241,1 +2241,1 @@\n-    if (sl_handle == NULL) {\n+    if (sl_handle == nullptr) {\n@@ -2246,1 +2246,1 @@\n-  if (mirror == NULL) {\n+  if (mirror == nullptr) {\n@@ -2250,1 +2250,1 @@\n-  if (klass == NULL || !klass->is_instance_klass()) {\n+  if (klass == nullptr || !klass->is_instance_klass()) {\n@@ -2267,1 +2267,1 @@\n-      guarantee(pure_name != NULL, \"Illegal native method name encountered\");\n+      guarantee(pure_name != nullptr, \"Illegal native method name encountered\");\n@@ -2274,1 +2274,1 @@\n-      if (entry == NULL) {\n+      if (entry == nullptr) {\n@@ -2278,1 +2278,1 @@\n-        guarantee(long_name != NULL, \"Illegal native method name encountered\");\n+        guarantee(long_name != nullptr, \"Illegal native method name encountered\");\n@@ -2285,1 +2285,1 @@\n-        if (entry == NULL) {\n+        if (entry == nullptr) {\n@@ -2330,1 +2330,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -2489,1 +2489,1 @@\n-  if (obj_handle == NULL) {\n+  if (obj_handle == nullptr) {\n@@ -2516,1 +2516,1 @@\n-      if (nm != NULL) {\n+      if (nm != nullptr) {\n@@ -2518,1 +2518,1 @@\n-        if (data != NULL) {\n+        if (data != nullptr) {\n@@ -2522,1 +2522,1 @@\n-          if (nmethod_mirror != NULL) {\n+          if (nmethod_mirror != nullptr) {\n@@ -2535,1 +2535,1 @@\n-      const char* cstring = name_string.is_null() ? NULL : thisEnv->as_utf8_string(name_string);\n+      const char* cstring = name_string.is_null() ? nullptr : thisEnv->as_utf8_string(name_string);\n@@ -2541,1 +2541,1 @@\n-      } else if (nm == NULL) {\n+      } else if (nm == nullptr) {\n@@ -2549,1 +2549,1 @@\n-          if (data == NULL) {\n+          if (data == nullptr) {\n@@ -2552,1 +2552,1 @@\n-          if (data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) != NULL) {\n+          if (data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) != nullptr) {\n@@ -2577,1 +2577,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2596,2 +2596,2 @@\n-  if (cb == NULL) {\n-    return NULL;\n+  if (cb == nullptr) {\n+    return nullptr;\n@@ -2646,1 +2646,1 @@\n-  for (FailedSpeculation* fs = head; fs != NULL; fs = fs->next()) {\n+  for (FailedSpeculation* fs = head; fs != nullptr; fs = fs->next()) {\n@@ -2650,2 +2650,2 @@\n-  JVMCIObjectArray current_array = NULL;\n-  if (current != NULL) {\n+  JVMCIObjectArray current_array = nullptr;\n+  if (current != nullptr) {\n@@ -2662,1 +2662,1 @@\n-    assert(fs != NULL, \"npe\");\n+    assert(fs != nullptr, \"npe\");\n@@ -2678,1 +2678,1 @@\n-  if (method_data == NULL) {\n+  if (method_data == nullptr) {\n@@ -2695,1 +2695,1 @@\n-  return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);\n+  return FailedSpeculation::add_failed_speculation(nullptr, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":102,"deletions":102,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    static int vm_page_size;\n+    static size_t vm_page_size;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  static_field(CompilerToVM::Data,             vm_page_size,                           int)                                          \\\n+  static_field(CompilerToVM::Data,             vm_page_size,                           size_t)                                       \\\n@@ -161,3 +161,3 @@\n-  nonstatic_field(InstanceKlass,               _init_state,                                   InstanceKlass::ClassState)             \\\n-  nonstatic_field(InstanceKlass,               _init_thread,                                  Thread*)                               \\\n-  nonstatic_field(InstanceKlass,               _misc_status._flags,                           u4)                                    \\\n+  volatile_nonstatic_field(InstanceKlass,      _init_state,                                   InstanceKlass::ClassState)             \\\n+  volatile_nonstatic_field(InstanceKlass,      _init_thread,                                  JavaThread*)                           \\\n+  nonstatic_field(InstanceKlass,               _misc_flags._flags,                            u4)                                    \\\n@@ -273,2 +273,0 @@\n-  static_field(os,                             _polling_page,                                 address)                               \\\n-                                                                                                                                     \\\n@@ -658,2 +656,2 @@\n-  declare_constant(InstanceKlassMiscStatus::_misc_has_nonstatic_concrete_methods)   \\\n-  declare_constant(InstanceKlassMiscStatus::_misc_declares_nonstatic_concrete_methods) \\\n+  declare_constant(InstanceKlassFlags::_misc_has_nonstatic_concrete_methods)   \\\n+  declare_constant(InstanceKlassFlags::_misc_declares_nonstatic_concrete_methods) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  if (_subclasses != NULL) {\n+  if (_subclasses != nullptr) {\n@@ -56,1 +56,1 @@\n-  if (_subclasses == NULL) {\n+  if (_subclasses == nullptr) {\n@@ -86,1 +86,1 @@\n-  if (_klass->name() != NULL) {\n+  if (_klass->name() != nullptr) {\n@@ -113,2 +113,2 @@\n-                 module->version() != NULL ? \"@\" : \"\",\n-                 module->version() != NULL ? module->version()->as_C_string() : \"\");\n+                 module->version() != nullptr ? \"@\" : \"\",\n+                 module->version() != nullptr ? module->version()->as_C_string() : \"\");\n@@ -125,2 +125,2 @@\n-  if (k->java_mirror_no_keepalive() == NULL) {\n-    return NULL;\n+  if (k->java_mirror_no_keepalive() == nullptr) {\n+    return nullptr;\n@@ -130,1 +130,1 @@\n-  while (elt != NULL) {\n+  while (elt != nullptr) {\n@@ -138,1 +138,1 @@\n-  if (elt != NULL) {\n+  if (elt != nullptr) {\n@@ -146,1 +146,1 @@\n-  while (elt != NULL) {\n+  while (elt != nullptr) {\n@@ -154,2 +154,2 @@\n-  _list = NULL;\n-  while (elt != NULL) {\n+  _list = nullptr;\n+  while (elt != nullptr) {\n@@ -180,1 +180,1 @@\n-  if (_buckets != NULL) {\n+  if (_buckets != nullptr) {\n@@ -192,1 +192,1 @@\n-  if (_buckets != NULL) {\n+  if (_buckets != nullptr) {\n@@ -197,1 +197,1 @@\n-    _buckets = NULL;\n+    _buckets = nullptr;\n@@ -207,1 +207,1 @@\n-  assert(_buckets != NULL, \"Allocation failure should have been caught\");\n+  assert(_buckets != nullptr, \"Allocation failure should have been caught\");\n@@ -212,1 +212,1 @@\n-  assert(e == NULL || k == e->klass(), \"must be equal\");\n+  assert(e == nullptr || k == e->klass(), \"must be equal\");\n@@ -221,1 +221,1 @@\n-  \/\/ elt may be NULL if it's a new klass for which we\n+  \/\/ elt may be null if it's a new klass for which we\n@@ -223,1 +223,1 @@\n-  if (elt != NULL) {\n+  if (elt != nullptr) {\n@@ -234,1 +234,1 @@\n-  assert(_buckets != NULL, \"Allocation failure should have been caught\");\n+  assert(_buckets != nullptr, \"Allocation failure should have been caught\");\n@@ -249,1 +249,1 @@\n-  \/\/ elt may be NULL if it's a new klass for which we\n+  \/\/ elt may be null if it's a new klass for which we\n@@ -251,1 +251,1 @@\n-  if (elt != NULL) {\n+  if (elt != nullptr) {\n@@ -355,1 +355,1 @@\n-    if (super != NULL) {\n+    if (super != nullptr) {\n@@ -357,1 +357,1 @@\n-      assert(super_cie != NULL, \"could not lookup superclass\");\n+      assert(super_cie != nullptr, \"could not lookup superclass\");\n@@ -365,1 +365,1 @@\n-    if (classname == NULL) {\n+    if (classname == nullptr) {\n@@ -380,1 +380,1 @@\n-  assert(jlo_cie != NULL, \"could not lookup java.lang.Object\");\n+  assert(jlo_cie != nullptr, \"could not lookup java.lang.Object\");\n@@ -390,1 +390,1 @@\n-      if (curr_cie->subclasses() != NULL) {\n+      if (curr_cie->subclasses() != nullptr) {\n@@ -410,1 +410,1 @@\n-  while (super != NULL) {\n+  while (super != nullptr) {\n@@ -422,1 +422,1 @@\n-    if (print_subclasses && curr_cie->subclasses() != NULL) {\n+    if (print_subclasses && curr_cie->subclasses() != nullptr) {\n@@ -446,1 +446,1 @@\n-  if (loader_oop == NULL) {\n+  if (loader_oop == nullptr) {\n@@ -467,1 +467,1 @@\n-  while (super != NULL) {\n+  while (super != nullptr) {\n@@ -668,1 +668,1 @@\n-    return _filter == NULL || _filter->do_object_b(obj);\n+    return _filter == nullptr || _filter->do_object_b(obj);\n@@ -709,1 +709,1 @@\n-    if (workers != NULL) {\n+    if (workers != nullptr) {\n@@ -739,1 +739,1 @@\n-    uintx missed_count = populate_table(&cit, NULL, parallel_thread_num);\n+    uintx missed_count = populate_table(&cit, nullptr, parallel_thread_num);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-    _do_print(false), _subclasses(NULL)\n+    _do_print(false), _subclasses(nullptr)\n@@ -100,1 +100,1 @@\n-  void initialize() { _list = NULL; }\n+  void initialize() { _list = nullptr; }\n@@ -126,1 +126,1 @@\n-  bool allocation_failed() { return _buckets == NULL; }\n+  bool allocation_failed() { return _buckets == nullptr; }\n@@ -209,1 +209,1 @@\n-  uintx populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL, uint parallel_thread_num = 1) NOT_SERVICES_RETURN_(0);\n+  uintx populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = nullptr, uint parallel_thread_num = 1) NOT_SERVICES_RETURN_(0);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-  OopIterateClosure() : _ref_discoverer(NULL) { }\n+  OopIterateClosure() : _ref_discoverer(nullptr) { }\n@@ -119,1 +119,1 @@\n-  BasicOopIterateClosure(ReferenceDiscoverer* rd = NULL) : OopIterateClosure(rd) {}\n+  BasicOopIterateClosure(ReferenceDiscoverer* rd = nullptr) : OopIterateClosure(rd) {}\n@@ -186,1 +186,1 @@\n-  ClaimMetadataVisitingOopIterateClosure(int claim, ReferenceDiscoverer* rd = NULL) :\n+  ClaimMetadataVisitingOopIterateClosure(int claim, ReferenceDiscoverer* rd = nullptr) :\n@@ -202,1 +202,1 @@\n-  MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd = NULL);\n+  MetadataVisitingOopIterateClosure(ReferenceDiscoverer* rd = nullptr);\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-    Ref(Writability w) : _writability(w), _keep_after_pushing(false), _next(NULL), _user_data(NULL) {}\n+    Ref(Writability w) : _writability(w), _keep_after_pushing(false), _next(nullptr), _user_data(nullptr) {}\n@@ -169,1 +169,1 @@\n-    virtual bool not_null()                const { return dereference() != NULL; }\n+    virtual bool not_null()                const { return dereference() != nullptr; }\n@@ -196,1 +196,1 @@\n-    virtual bool not_null()                const { return dereference() != NULL;  }\n+    virtual bool not_null()                const { return dereference() != nullptr;  }\n@@ -274,1 +274,1 @@\n-  MetaspaceClosure(): _pending_refs(NULL), _nest_level(0), _enclosing_ref(NULL) {}\n+  MetaspaceClosure(): _pending_refs(nullptr), _nest_level(0), _enclosing_ref(nullptr) {}\n@@ -290,1 +290,1 @@\n-  \/\/ when do_pending_ref(r) is called, and will return NULL when do_ref(r) is called.\n+  \/\/ when do_pending_ref(r) is called, and will return null when do_ref(r) is called.\n@@ -352,1 +352,1 @@\n-    Hashtable<bool, mtInternal>* h  = NULL;\n+    Hashtable<bool, mtInternal>* h  = nullptr;\n@@ -355,1 +355,1 @@\n-    Array<Hashtable<bool, mtInternal>*>* a6 = NULL;\n+    Array<Hashtable<bool, mtInternal>*>* a6 = nullptr;\n@@ -358,1 +358,1 @@\n-    Array<int*>* a7 = NULL;\n+    Array<int*>* a7 = nullptr;\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-  assert(Universe::objectArrayKlassObj() != NULL, \"Too early?\");\n+  assert(Universe::objectArrayKlassObj() != nullptr, \"Too early?\");\n@@ -86,1 +86,1 @@\n-  int length = utf8_str == NULL ? 0 : UTF8::unicode_length(utf8_str);\n+  int length = utf8_str == nullptr ? 0 : UTF8::unicode_length(utf8_str);\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -88,3 +89,3 @@\n-Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL \/*, NULL...*\/ };\n-Klass* Universe::_objectArrayKlassObj                 = NULL;\n-Klass* Universe::_fillerArrayKlassObj                 = NULL;\n+Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { nullptr \/*, nullptr...*\/ };\n+Klass* Universe::_objectArrayKlassObj                 = nullptr;\n+Klass* Universe::_fillerArrayKlassObj                 = nullptr;\n@@ -131,8 +132,8 @@\n-Array<Klass*>* Universe::_the_array_interfaces_array = NULL;\n-LatestMethodCache* Universe::_finalizer_register_cache = NULL;\n-LatestMethodCache* Universe::_loader_addClass_cache    = NULL;\n-LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;\n-LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;\n-LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;\n-LatestMethodCache* Universe::_is_substitutable_cache  = NULL;\n-LatestMethodCache* Universe::_value_object_hash_code_cache = NULL;\n+Array<Klass*>* Universe::_the_array_interfaces_array = nullptr;\n+LatestMethodCache* Universe::_finalizer_register_cache = nullptr;\n+LatestMethodCache* Universe::_loader_addClass_cache    = nullptr;\n+LatestMethodCache* Universe::_throw_illegal_access_error_cache = nullptr;\n+LatestMethodCache* Universe::_throw_no_such_method_error_cache = nullptr;\n+LatestMethodCache* Universe::_do_stack_walk_cache     = nullptr;\n+LatestMethodCache* Universe::_is_substitutable_cache  = nullptr;\n+LatestMethodCache* Universe::_value_object_hash_code_cache = nullptr;\n@@ -142,5 +143,5 @@\n-Array<int>* Universe::_the_empty_int_array            = NULL;\n-Array<u2>* Universe::_the_empty_short_array           = NULL;\n-Array<Klass*>* Universe::_the_empty_klass_array     = NULL;\n-Array<InstanceKlass*>* Universe::_the_empty_instance_klass_array  = NULL;\n-Array<Method*>* Universe::_the_empty_method_array   = NULL;\n+Array<int>* Universe::_the_empty_int_array            = nullptr;\n+Array<u2>* Universe::_the_empty_short_array           = nullptr;\n+Array<Klass*>* Universe::_the_empty_klass_array     = nullptr;\n+Array<InstanceKlass*>* Universe::_the_empty_instance_klass_array  = nullptr;\n+Array<Method*>* Universe::_the_empty_method_array   = nullptr;\n@@ -164,2 +165,2 @@\n-OopStorage*     Universe::_vm_weak = NULL;\n-OopStorage*     Universe::_vm_global = NULL;\n+OopStorage*     Universe::_vm_weak = nullptr;\n+OopStorage*     Universe::_vm_global = nullptr;\n@@ -167,1 +168,1 @@\n-CollectedHeap*  Universe::_collectedHeap = NULL;\n+CollectedHeap*  Universe::_collectedHeap = nullptr;\n@@ -255,1 +256,1 @@\n-        assert(mirror_oop != NULL, \"must be\");\n+        assert(mirror_oop != nullptr, \"must be\");\n@@ -310,1 +311,1 @@\n-      InstanceKlass::cast(k)->restore_unshareable_info(loader_data, Handle(), NULL, CHECK);\n+      InstanceKlass::cast(k)->restore_unshareable_info(loader_data, Handle(), nullptr, CHECK);\n@@ -317,1 +318,1 @@\n-    k->initialize_supers(ok, NULL, CHECK);\n+    k->initialize_supers(ok, nullptr, CHECK);\n@@ -346,1 +347,1 @@\n-        _the_array_interfaces_array     = MetadataFactory::new_array<Klass*>(null_cld, 2, NULL, CHECK);\n+        _the_array_interfaces_array     = MetadataFactory::new_array<Klass*>(null_cld, 2, nullptr, CHECK);\n@@ -403,1 +404,1 @@\n-  _reference_pending_list = OopHandle(vm_global(), NULL);\n+  _reference_pending_list = OopHandle(vm_global(), nullptr);\n@@ -465,1 +466,1 @@\n-        _basic_type_mirrors[T_INT].resolve() != NULL) {\n+        _basic_type_mirrors[T_INT].resolve() != nullptr) {\n@@ -472,1 +473,1 @@\n-          assert(m != NULL, \"archived mirrors should not be NULL\");\n+          assert(m != nullptr, \"archived mirrors should not be nullptr\");\n@@ -476,1 +477,1 @@\n-      \/\/ _basic_type_mirrors[T_INT], etc, are NULL if archived heap is not mapped.\n+      \/\/ _basic_type_mirrors[T_INT], etc, are null if archived heap is not mapped.\n@@ -488,0 +489,3 @@\n+    if (DumpSharedSpaces) {\n+      HeapShared::init_scratch_objects(CHECK);\n+    }\n@@ -511,1 +515,1 @@\n-  java_lang_Class::set_fixup_mirror_list(NULL);\n+  java_lang_Class::set_fixup_mirror_list(nullptr);\n@@ -530,1 +534,1 @@\n-  _reference_pending_list.replace(NULL);\n+  _reference_pending_list.replace(nullptr);\n@@ -535,1 +539,1 @@\n-  return _reference_pending_list.peek() != NULL;\n+  return _reference_pending_list.peek() != nullptr;\n@@ -654,1 +658,1 @@\n-    \/\/ get the error object at the slot and set set it to NULL so that the\n+    \/\/ get the error object at the slot and set set it to null so that the\n@@ -657,2 +661,2 @@\n-    assert(exc() != NULL, \"slot has been used already\");\n-    preallocated_out_of_memory_errors()->obj_at_put(next, NULL);\n+    assert(exc() != nullptr, \"slot has been used already\");\n+    preallocated_out_of_memory_errors()->obj_at_put(next, nullptr);\n@@ -662,1 +666,1 @@\n-    assert(msg != NULL, \"no message\");\n+    assert(msg != nullptr, \"no message\");\n@@ -758,1 +762,5 @@\n-  CompiledICProtectionBehaviour::set_current(new DefaultICProtectionBehaviour());\n+  DefaultICProtectionBehaviour* protection_behavior = new DefaultICProtectionBehaviour();\n+  \/\/ Ignore leak of DefaultICProtectionBehaviour. It is overriden by some GC implementations and the\n+  \/\/ pointer is leaked once.\n+  LSAN_IGNORE_OBJECT(protection_behavior);\n+  CompiledICProtectionBehaviour::set_current(protection_behavior);\n@@ -847,1 +855,1 @@\n-  assert(_collectedHeap == NULL, \"Heap already created\");\n+  assert(_collectedHeap == nullptr, \"Heap already created\");\n@@ -889,1 +897,1 @@\n-    if (AllocateHeapAt != NULL) {\n+    if (AllocateHeapAt != nullptr) {\n@@ -935,1 +943,1 @@\n-  Method* m = NULL;\n+  Method* m = nullptr;\n@@ -938,1 +946,1 @@\n-      ((m = ik->find_method(name, signature)) == NULL) ||\n+      ((m = ik->find_method(name, signature)) == nullptr) ||\n@@ -1100,1 +1108,1 @@\n-  while (token != NULL) {\n+  while (token != nullptr) {\n@@ -1128,1 +1136,1 @@\n-    token = strtok_r(NULL, delimiter, &save_ptr);\n+    token = strtok_r(nullptr, delimiter, &save_ptr);\n@@ -1268,1 +1276,1 @@\n-    assert(_klass != NULL, \"just checking\");\n+    assert(_klass != nullptr, \"just checking\");\n@@ -1278,1 +1286,1 @@\n-  if (klass() == NULL) return NULL;\n+  if (klass() == nullptr) return nullptr;\n@@ -1281,1 +1289,1 @@\n-  assert(m != NULL, \"sanity check\");\n+  assert(m != nullptr, \"sanity check\");\n@@ -1290,1 +1298,1 @@\n-  if (fullgc_alot_dummy_array != NULL) {\n+  if (fullgc_alot_dummy_array != nullptr) {\n@@ -1294,1 +1302,1 @@\n-      _fullgc_alot_dummy_array = OopHandle(); \/\/ NULL out OopStorage pointer.\n+      _fullgc_alot_dummy_array = OopHandle(); \/\/ null out OopStorage pointer.\n@@ -1299,1 +1307,1 @@\n-    fullgc_alot_dummy_array->obj_at_put(_fullgc_alot_dummy_next++, NULL);\n+    fullgc_alot_dummy_array->obj_at_put(_fullgc_alot_dummy_next++, nullptr);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":56,"deletions":48,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,2 @@\n-  LatestMethodCache()   { _klass = NULL; _method_idnum = -1; }\n-  ~LatestMethodCache()  { _klass = NULL; _method_idnum = -1; }\n+  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n+  ~LatestMethodCache()  { _klass = nullptr; _method_idnum = -1; }\n@@ -191,1 +191,1 @@\n-    assert(m != NULL, \"mirror not initialized\");\n+    assert(m != nullptr, \"mirror not initialized\");\n@@ -232,1 +232,1 @@\n-    assert(_typeArrayKlassObjs[t] != NULL, \"domain check\");\n+    assert(_typeArrayKlassObjs[t] != nullptr, \"domain check\");\n@@ -331,1 +331,1 @@\n-  DEBUG_ONLY(static bool is_in_heap_or_null(const void* p) { return p == NULL || is_in_heap(p); })\n+  DEBUG_ONLY(static bool is_in_heap_or_null(const void* p) { return p == nullptr || is_in_heap(p); })\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -329,1 +329,1 @@\n-                       NULL, 0, dst,\n+                       nullptr, 0, dst,\n@@ -337,1 +337,1 @@\n-    AccessT::arraycopy(NULL, 0, src,\n+    AccessT::arraycopy(nullptr, 0, src,\n@@ -352,2 +352,2 @@\n-    AccessT::oop_arraycopy(NULL, 0, src,\n-                           NULL, 0, dst,\n+    AccessT::oop_arraycopy(nullptr, 0, src,\n+                           nullptr, 0, dst,\n","filename":"src\/hotspot\/share\/oops\/access.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,1 @@\n-      assert(bs != NULL, \"GC barriers invoked before BarrierSet is set\");\n+      assert(bs != nullptr, \"GC barriers invoked before BarrierSet is set\");\n@@ -233,1 +233,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -243,1 +243,1 @@\n-      assert(bs != NULL, \"GC barriers invoked before BarrierSet is set\");\n+      assert(bs != nullptr, \"GC barriers invoked before BarrierSet is set\");\n@@ -256,1 +256,1 @@\n-        return NULL;\n+        return nullptr;\n","filename":"src\/hotspot\/share\/oops\/access.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,4 +30,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n-#include \"metaprogramming\/integralConstant.hpp\"\n-#include \"metaprogramming\/isPointer.hpp\"\n-#include \"metaprogramming\/isSame.hpp\"\n@@ -49,1 +45,1 @@\n-  typedef typename Conditional<needs_oop_compress, narrowOop, oop>::type type;\n+  using type = std::conditional_t<needs_oop_compress, narrowOop, oop>;\n@@ -57,1 +53,1 @@\n-  typedef typename Conditional<needs_oop_compress, narrowOop, oop>::type type;\n+  using type = std::conditional_t<needs_oop_compress, narrowOop, oop>;\n@@ -76,1 +72,1 @@\n-  struct MustConvertCompressedOop: public IntegralConstant<bool,\n+  struct MustConvertCompressedOop: public std::integral_constant<bool,\n@@ -78,2 +74,2 @@\n-    IsSame<typename HeapOopType<decorators>::type, narrowOop>::value &&\n-    IsSame<T, oop>::value> {};\n+    std::is_same<typename HeapOopType<decorators>::type, narrowOop>::value &&\n+    std::is_same<T, oop>::value> {};\n@@ -85,3 +81,3 @@\n-    typedef typename Conditional<\n-      HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n-      typename HeapOopType<decorators>::type, T>::type type;\n+    using type = std::conditional_t<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n+                                    typename HeapOopType<decorators>::type,\n+                                    T>;\n@@ -101,1 +97,1 @@\n-  struct PossiblyLockedAccess: public IntegralConstant<bool, false> {};\n+  struct PossiblyLockedAccess: public std::false_type {};\n@@ -103,1 +99,1 @@\n-  struct PossiblyLockedAccess: public IntegralConstant<bool, (sizeof(T) > 4)> {};\n+  struct PossiblyLockedAccess: public std::integral_constant<bool, (sizeof(T) > 4)> {};\n@@ -661,1 +657,1 @@\n-    struct CanHardwireRaw: public IntegralConstant<\n+    struct CanHardwireRaw: public std::integral_constant<\n@@ -1141,1 +1137,1 @@\n-                   (IsPointer<T>::value || std::is_integral<T>::value) ||\n+                   (std::is_pointer<T>::value || std::is_integral<T>::value) ||\n@@ -1174,3 +1170,3 @@\n-    typedef typename Conditional<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n-                                 typename OopOrNarrowOop<T>::type,\n-                                 std::decay_t<T>>::type DecayedT;\n+    using DecayedT = std::conditional_t<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n+                                        typename OopOrNarrowOop<T>::type,\n+                                        std::decay_t<T>>;\n@@ -1188,3 +1184,3 @@\n-    typedef typename Conditional<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n-                                 typename OopOrNarrowOop<T>::type,\n-                                 std::decay_t<T>>::type DecayedT;\n+    using DecayedT = std::conditional_t<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n+                                        typename OopOrNarrowOop<T>::type,\n+                                        std::decay_t<T>>;\n@@ -1261,1 +1257,1 @@\n-                   (IsSame<T, void>::value || std::is_integral<T>::value) ||\n+                   (std::is_same<T, void>::value || std::is_integral<T>::value) ||\n@@ -1288,1 +1284,1 @@\n-    OopLoadProxy(P* addr) : _addr(addr) {}\n+    explicit OopLoadProxy(P* addr) : _addr(addr) {}\n@@ -1307,0 +1303,8 @@\n+\n+    inline bool operator ==(std::nullptr_t) const {\n+      return load<decorators | INTERNAL_VALUE_IS_OOP, P, oop>(_addr) == nullptr;\n+    }\n+\n+    inline bool operator !=(std::nullptr_t) const {\n+      return load<decorators | INTERNAL_VALUE_IS_OOP, P, oop>(_addr) != nullptr;\n+    }\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":28,"deletions":24,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include <type_traits>\n+\n@@ -255,1 +257,1 @@\n-  template<typename T> struct IsHeapWordSized: public IntegralConstant<bool, sizeof(T) == HeapWordSize> { };\n+  template<typename T> struct IsHeapWordSized: public std::integral_constant<bool, sizeof(T) == HeapWordSize> { };\n@@ -338,1 +340,1 @@\n-template<> struct RawAccessBarrierArrayCopy::IsHeapWordSized<void>: public IntegralConstant<bool, false> { };\n+template<> struct RawAccessBarrierArrayCopy::IsHeapWordSized<void>: public std::false_type { };\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"metaprogramming\/integralConstant.hpp\"\n@@ -33,0 +32,2 @@\n+#include <type_traits>\n+\n@@ -44,1 +45,1 @@\n-struct HasDecorator: public IntegralConstant<bool, (decorators & decorator) != 0> {};\n+struct HasDecorator: public std::integral_constant<bool, (decorators & decorator) != 0> {};\n","filename":"src\/hotspot\/share\/oops\/accessDecorators.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  if (super() == NULL)  return NULL;  \/\/ bootstrap case\n+  if (super() == nullptr)  return nullptr;  \/\/ bootstrap case\n@@ -66,1 +66,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -91,2 +91,2 @@\n-  _higher_dimension(NULL),\n-  _lower_dimension(NULL) {\n+  _higher_dimension(nullptr),\n+  _lower_dimension(nullptr) {\n@@ -97,1 +97,1 @@\n-  set_super(Universe::is_bootstrapping() ? NULL : vmClasses::Object_klass());\n+  set_super(Universe::is_bootstrapping() ? nullptr : vmClasses::Object_klass());\n@@ -105,1 +105,1 @@\n-  Symbol* name = NULL;\n+  Symbol* name = nullptr;\n@@ -130,1 +130,1 @@\n-  k->initialize_supers(super_klass, NULL, CHECK);\n+  k->initialize_supers(super_klass, nullptr, CHECK);\n@@ -136,1 +136,1 @@\n-  assert((module_entry != NULL) || ((module_entry == NULL) && !ModuleEntryTable::javabase_defined()),\n+  assert((module_entry != nullptr) || ((module_entry == nullptr) && !ModuleEntryTable::javabase_defined()),\n@@ -138,1 +138,1 @@\n-  oop module = (module_entry != NULL) ? module_entry->module() : (oop)NULL;\n+  oop module = (module_entry != nullptr) ? module_entry->module() : (oop)nullptr;\n@@ -146,1 +146,1 @@\n-  assert(transitive_interfaces == NULL, \"sanity\");\n+  assert(transitive_interfaces == nullptr, \"sanity\");\n@@ -149,1 +149,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -159,1 +159,1 @@\n-  \/\/ initialization to NULL not necessary, area already cleared\n+  \/\/ initialization to null not necessary, area already cleared\n@@ -191,1 +191,1 @@\n-  if (_higher_dimension != NULL) {\n+  if (_higher_dimension != nullptr) {\n@@ -199,1 +199,1 @@\n-  if (_higher_dimension != NULL) {\n+  if (_higher_dimension != nullptr) {\n@@ -210,1 +210,1 @@\n-  if (_higher_dimension != NULL) {\n+  if (_higher_dimension != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,2 @@\n-    if (obj != NULL) {\n-      assert(raw == NULL, \"either raw or in-heap\");\n+    if (obj != nullptr) {\n+      assert(raw == nullptr, \"either raw or in-heap\");\n@@ -104,1 +104,1 @@\n-      assert(raw != NULL, \"either raw or in-heap\");\n+      assert(raw != nullptr, \"either raw or in-heap\");\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -93,1 +94,1 @@\n-  assert(tags != NULL, \"invariant\");\n+  assert(tags != nullptr, \"invariant\");\n@@ -109,1 +110,1 @@\n-    assert(_tags != NULL, \"invariant\");\n+    assert(_tags != nullptr, \"invariant\");\n@@ -114,1 +115,1 @@\n-    assert(NULL == _pool_holder, \"invariant\");\n+    assert(nullptr == _pool_holder, \"invariant\");\n@@ -118,1 +119,1 @@\n-  if (cache() != NULL) {\n+  if (cache() != nullptr) {\n@@ -120,1 +121,1 @@\n-    set_cache(NULL);\n+    set_cache(nullptr);\n@@ -124,1 +125,1 @@\n-  set_resolved_klasses(NULL);\n+  set_resolved_klasses(nullptr);\n@@ -127,1 +128,1 @@\n-  set_operands(NULL);\n+  set_operands(nullptr);\n@@ -133,1 +134,1 @@\n-  set_tags(NULL);\n+  set_tags(nullptr);\n@@ -168,2 +169,2 @@\n-  if (_cache == NULL) {\n-    return NULL;\n+  if (_cache == nullptr) {\n+    return nullptr;\n@@ -228,1 +229,1 @@\n-  assert(resolved_klasses() == NULL, \"sanity\");\n+  assert(resolved_klasses() == nullptr, \"sanity\");\n@@ -259,1 +260,1 @@\n-  assert(k != NULL, \"must be valid klass\");\n+  assert(k != nullptr, \"must be valid klass\");\n@@ -266,1 +267,1 @@\n-  \/\/ and the Klass* non-NULL, so we need hardware store ordering here.\n+  \/\/ and the Klass* non-null, so we need hardware store ordering here.\n@@ -272,4 +273,5 @@\n-\/\/ Archive the resolved references\n-void ConstantPool::archive_resolved_references() {\n-  if (_cache == NULL) {\n-    return; \/\/ nothing to do\n+\/\/ Returns the _resolved_reference array after removing unarchivable items from it.\n+\/\/ Returns null if this class is not supported, or _resolved_reference doesn't exist.\n+objArrayOop ConstantPool::prepare_resolved_references_for_archiving() {\n+  if (_cache == nullptr) {\n+    return nullptr; \/\/ nothing to do\n@@ -283,1 +285,1 @@\n-    return;\n+    return nullptr;\n@@ -287,3 +289,3 @@\n-  Array<u2>* ref_map = reference_map();\n-  if (rr != NULL) {\n-    int ref_map_len = ref_map == NULL ? 0 : ref_map->length();\n+  if (rr != nullptr) {\n+    Array<u2>* ref_map = reference_map();\n+    int ref_map_len = ref_map == nullptr ? 0 : ref_map->length();\n@@ -293,2 +295,2 @@\n-      rr->obj_at_put(i, NULL);\n-      if (obj != NULL && i < ref_map_len) {\n+      rr->obj_at_put(i, nullptr);\n+      if (obj != nullptr && i < ref_map_len) {\n@@ -297,7 +299,4 @@\n-          oop archived_string = HeapShared::find_archived_heap_object(obj);\n-          \/\/ Update the reference to point to the archived copy\n-          \/\/ of this string.\n-          \/\/ If the string is too large to archive, NULL is\n-          \/\/ stored into rr. At run time, string_at_impl() will create and intern\n-          \/\/ the string.\n-          rr->obj_at_put(i, archived_string);\n+          assert(java_lang_String::is_instance(obj), \"must be\");\n+          if (!ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n+            rr->obj_at_put(i, obj);\n+          }\n@@ -307,8 +306,1 @@\n-\n-    oop archived = HeapShared::archive_object(rr);\n-    \/\/ If the resolved references array is not archived (too large),\n-    \/\/ the 'archived' object is NULL. No need to explicitly check\n-    \/\/ the return value of archive_object() here. At runtime, the\n-    \/\/ resolved references will be created using the normal process\n-    \/\/ when there is no archived value.\n-    _cache->set_archived_references(archived);\n+  return rr;\n@@ -320,1 +312,1 @@\n-  if (rr != NULL) {\n+  if (rr != nullptr) {\n@@ -324,1 +316,2 @@\n-      if (java_lang_String::is_instance(p)) {\n+      if (java_lang_String::is_instance(p) &&\n+          !ArchiveHeapWriter::is_string_too_large_to_archive(p)) {\n@@ -341,1 +334,1 @@\n-  assert(_cache != NULL, \"constant pool _cache should not be NULL\");\n+  assert(_cache != nullptr, \"constant pool _cache should not be null\");\n@@ -344,1 +337,1 @@\n-  if (resolved_references() != NULL) return;\n+  if (resolved_references() != nullptr) return;\n@@ -350,1 +343,1 @@\n-        _cache->archived_references() != NULL) {\n+        _cache->archived_references() != nullptr) {\n@@ -387,1 +380,1 @@\n-    resolved_references() != NULL ? resolved_references()->length() : 0);\n+    resolved_references() != nullptr ? resolved_references()->length() : 0);\n@@ -415,2 +408,2 @@\n-  if (cache() != NULL) {\n-    \/\/ cache() is NULL if this class is not yet linked.\n+  if (cache() != nullptr) {\n+    \/\/ cache() is null if this class is not yet linked.\n@@ -435,1 +428,1 @@\n-  \/\/ k could be NULL if the referenced class has been excluded via\n+  \/\/ k could be null if the referenced class has been excluded via\n@@ -438,1 +431,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -452,1 +445,1 @@\n-  resolved_klasses()->at_put(resolved_klass_index, NULL);\n+  resolved_klasses()->at_put(resolved_klass_index, nullptr);\n@@ -474,1 +467,1 @@\n-  const char * source_file = NULL;\n+  const char * source_file = nullptr;\n@@ -481,1 +474,1 @@\n-      if (s != NULL) {\n+      if (s != nullptr) {\n@@ -488,1 +481,1 @@\n-    if (source_file != NULL) {\n+    if (source_file != nullptr) {\n@@ -522,1 +515,1 @@\n-    if (klass != NULL) {\n+    if (klass != nullptr) {\n@@ -573,1 +566,1 @@\n-    Klass* bottom_klass = NULL;\n+    Klass* bottom_klass = nullptr;\n@@ -576,1 +569,1 @@\n-      assert(bottom_klass != NULL, \"Should be set\");\n+      assert(bottom_klass != nullptr, \"Should be set\");\n@@ -580,1 +573,1 @@\n-      assert(bottom_klass != NULL, \"Should be set\");\n+      assert(bottom_klass != nullptr, \"Should be set\");\n@@ -596,1 +589,1 @@\n-    assert(klass != NULL, \"must be resolved if exception was cleared\");\n+    assert(klass != nullptr, \"must be resolved if exception was cleared\");\n@@ -608,1 +601,1 @@\n-  \/\/ and the Klass* stored in _resolved_klasses is non-NULL, so we need\n+  \/\/ and the Klass* stored in _resolved_klasses is non-null, so we need\n@@ -623,1 +616,1 @@\n-    this_cp->resolved_klasses()->at_put(resolved_klass_index, NULL);\n+    this_cp->resolved_klasses()->at_put(resolved_klass_index, nullptr);\n@@ -633,1 +626,1 @@\n-\/\/ instanceof operations. Returns NULL if the class has not been loaded or\n+\/\/ instanceof operations. Returns null if the class has not been loaded or\n@@ -643,1 +636,1 @@\n-    assert(k != NULL, \"should be resolved\");\n+    assert(k != nullptr, \"should be resolved\");\n@@ -646,1 +639,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -657,1 +650,1 @@\n-    if (k != NULL && current->is_Java_thread()) {\n+    if (k != nullptr && current->is_Java_thread()) {\n@@ -661,1 +654,1 @@\n-      \/\/ return NULL if verification fails\n+      \/\/ return null if verification fails\n@@ -665,1 +658,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -676,1 +669,1 @@\n-  if (cpool->cache() == NULL)  return NULL;  \/\/ nothing to load yet\n+  if (cpool->cache() == nullptr)  return nullptr;  \/\/ nothing to load yet\n@@ -681,1 +674,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -689,1 +682,1 @@\n-  if (cpool->cache() == NULL)  return false;  \/\/ nothing to load yet\n+  if (cpool->cache() == nullptr)  return false;  \/\/ nothing to load yet\n@@ -696,1 +689,1 @@\n-  if (cpool->cache() == NULL)  return NULL;  \/\/ nothing to load yet\n+  if (cpool->cache() == nullptr)  return nullptr;  \/\/ nothing to load yet\n@@ -704,1 +697,1 @@\n-  if (cpool->cache() == NULL)  return false;  \/\/ nothing to load yet\n+  if (cpool->cache() == nullptr)  return false;  \/\/ nothing to load yet\n@@ -723,1 +716,1 @@\n-  if (!uncached && cache() != NULL) {\n+  if (!uncached && cache() != nullptr) {\n@@ -748,1 +741,1 @@\n-  if (!uncached && cache() != NULL) {\n+  if (!uncached && cache() != nullptr) {\n@@ -764,1 +757,1 @@\n-  if (!uncached && cache() != NULL) {\n+  if (!uncached && cache() != nullptr) {\n@@ -843,1 +836,1 @@\n-  if (message != NULL) {\n+  if (message != nullptr) {\n@@ -879,3 +872,3 @@\n-  Symbol* cause_sym = NULL;\n-  Symbol* cause_msg = NULL;\n-  if (cause != NULL && cause != pending_exception) {\n+  Symbol* cause_sym = nullptr;\n+  Symbol* cause_msg = nullptr;\n+  if (cause != nullptr && cause != pending_exception) {\n@@ -893,3 +886,3 @@\n-  Symbol* message = NULL;\n-  Symbol* cause = NULL;\n-  Symbol* cause_msg = NULL;\n+  Symbol* message = nullptr;\n+  Symbol* cause = nullptr;\n+  Symbol* cause_msg = nullptr;\n@@ -897,2 +890,2 @@\n-  assert(error != NULL, \"checking\");\n-  const char* cause_str = cause_msg != NULL ? cause_msg->as_C_string() : NULL;\n+  assert(error != nullptr, \"checking\");\n+  const char* cause_str = cause_msg != nullptr ? cause_msg->as_C_string() : nullptr;\n@@ -901,1 +894,1 @@\n-  if (message != NULL) {\n+  if (message != nullptr) {\n@@ -903,1 +896,1 @@\n-    if (cause != NULL) {\n+    if (cause != nullptr) {\n@@ -910,1 +903,1 @@\n-    if (cause != NULL) {\n+    if (cause != nullptr) {\n@@ -981,1 +974,1 @@\n-  oop result_oop = NULL;\n+  oop result_oop = nullptr;\n@@ -997,1 +990,1 @@\n-    if (result_oop != NULL) {\n+    if (result_oop != nullptr) {\n@@ -1001,1 +994,1 @@\n-        result_oop = NULL;\n+        result_oop = nullptr;\n@@ -1003,1 +996,1 @@\n-      if (status_return != NULL)  (*status_return) = true;\n+      if (status_return != nullptr)  (*status_return) = true;\n@@ -1014,1 +1007,1 @@\n-  if (status_return != NULL) {\n+  if (status_return != nullptr) {\n@@ -1021,1 +1014,1 @@\n-      if (this_cp->resolved_klasses()->at(resolved_klass_index) == NULL) {\n+      if (this_cp->resolved_klasses()->at(resolved_klass_index) == nullptr) {\n@@ -1023,1 +1016,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1037,1 +1030,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1085,2 +1078,2 @@\n-        const char* fail = NULL;\n-        if (result_oop == NULL) {\n+        const char* fail = nullptr;\n+        if (result_oop == nullptr) {\n@@ -1094,1 +1087,1 @@\n-        if (fail != NULL) {\n+        if (fail != nullptr) {\n@@ -1220,1 +1213,1 @@\n-    oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);\n+    oop new_result = (result_oop == nullptr ? Universe::the_null_sentinel() : result_oop);\n@@ -1228,1 +1221,1 @@\n-        old_result = NULL;\n+        old_result = nullptr;\n@@ -1239,1 +1232,1 @@\n-  oop str = StringTable::intern(sym, CHECK_(NULL));\n+  oop str = StringTable::intern(sym, CHECK_(nullptr));\n@@ -1285,1 +1278,1 @@\n-  if (str != NULL) return str;\n+  if (str != nullptr) return str;\n@@ -1287,1 +1280,1 @@\n-  str = StringTable::intern(sym, CHECK_(NULL));\n+  str = StringTable::intern(sym, CHECK_(nullptr));\n@@ -1537,1 +1530,1 @@\n-  if ( operands() != NULL) { \/\/ the safety check\n+  if ( operands() != nullptr) { \/\/ the safety check\n@@ -2348,1 +2341,1 @@\n-  if (pool_holder() != NULL) {\n+  if (pool_holder() != nullptr) {\n@@ -2378,1 +2371,1 @@\n-        guarantee(k != NULL, \"need klass\");\n+        guarantee(k != nullptr, \"need klass\");\n@@ -2475,1 +2468,1 @@\n-  if (operands() != NULL)  st->print(\"\/operands[%d]\", operands()->length());\n+  if (operands() != nullptr)  st->print(\"\/operands[%d]\", operands()->length());\n@@ -2477,1 +2470,1 @@\n-  if (pool_holder() != NULL) {\n+  if (pool_holder() != nullptr) {\n@@ -2483,1 +2476,1 @@\n-  if (cache() != NULL) {\n+  if (cache() != nullptr) {\n@@ -2504,2 +2497,2 @@\n-  if (pool_holder() != NULL) {\n-    \/\/ Note: pool_holder() can be NULL in temporary constant pools\n+  if (pool_holder() != nullptr) {\n+    \/\/ Note: pool_holder() can be null in temporary constant pools\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":102,"deletions":109,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-      (Symbol*)NULL : symbol_at(_generic_signature_index);\n+      nullptr : symbol_at(_generic_signature_index);\n@@ -197,1 +197,1 @@\n-      (Symbol*)NULL : symbol_at(_source_file_name_index);\n+      nullptr : symbol_at(_source_file_name_index);\n@@ -577,1 +577,1 @@\n-    if (operands == NULL || operands->length() == 0)  return 0;\n+    if (operands == nullptr || operands->length() == 0)  return 0;\n@@ -709,1 +709,1 @@\n-  void archive_resolved_references() NOT_CDS_JAVA_HEAP_RETURN;\n+  objArrayOop prepare_resolved_references_for_archiving() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -728,1 +728,1 @@\n-    return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);\n+    return resolve_constant_at_impl(h_this, index, _no_index_sentinel, nullptr, THREAD);\n@@ -733,1 +733,1 @@\n-    return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);\n+    return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, nullptr, THREAD);\n@@ -738,1 +738,1 @@\n-    return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);\n+    return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, nullptr, THREAD);\n@@ -823,1 +823,1 @@\n-  Array<u2>* reference_map() const        {  return (_cache == NULL) ? NULL :  _cache->reference_map(); }\n+  Array<u2>* reference_map() const        {  return (_cache == nullptr) ? nullptr :  _cache->reference_map(); }\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  _f1 = NULL;\n+  _f1 = nullptr;\n@@ -104,1 +104,1 @@\n-  assert(f1 != NULL, \"\");\n+  assert(f1 != nullptr, \"\");\n@@ -166,1 +166,1 @@\n-  assert(method->interpreter_entry() != NULL, \"should have been set at this point\");\n+  assert(method->interpreter_entry() != nullptr, \"should have been set at this point\");\n@@ -171,1 +171,1 @@\n-  InstanceKlass* holder = NULL;  \/\/ have to declare this outside the switch\n+  InstanceKlass* holder = nullptr;  \/\/ have to declare this outside the switch\n@@ -259,1 +259,1 @@\n-             method->method_holder()->is_init_thread(Thread::current()),\n+             method->method_holder()->is_init_thread(JavaThread::current()),\n@@ -405,1 +405,1 @@\n-  LogStream* log_stream = NULL;\n+  LogStream* log_stream = nullptr;\n@@ -452,1 +452,1 @@\n-  if (log_stream != NULL) {\n+  if (log_stream != nullptr) {\n@@ -492,1 +492,1 @@\n-    if (f1 != NULL) {\n+    if (f1 != nullptr) {\n@@ -530,1 +530,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -536,1 +536,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -572,1 +572,1 @@\n-  assert (_f1 != NULL, \"should not call with uninteresting entry\");\n+  assert (_f1 != nullptr, \"should not call with uninteresting entry\");\n@@ -590,1 +590,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -601,1 +601,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -603,1 +603,1 @@\n-  Method* m = NULL;\n+  Method* m = nullptr;\n@@ -608,2 +608,2 @@\n-    \/\/ NULL _f1 means this is a virtual entry so also not interesting\n-    return NULL;\n+    \/\/ null _f1 means this is a virtual entry so also not interesting\n+    return nullptr;\n@@ -618,3 +618,3 @@\n-  assert(m != NULL && m->is_method(), \"sanity check\");\n-  if (m == NULL || !m->is_method()) {\n-    return NULL;\n+  assert(m != nullptr && m->is_method(), \"sanity check\");\n+  if (m == nullptr || !m->is_method()) {\n+    return nullptr;\n@@ -738,1 +738,1 @@\n-  assert(_initial_entries != NULL, \"archived cpcache must have been initialized\");\n+  assert(_initial_entries != nullptr, \"archived cpcache must have been initialized\");\n@@ -745,1 +745,1 @@\n-  _initial_entries = NULL;\n+  _initial_entries = nullptr;\n@@ -754,1 +754,1 @@\n-  set_reference_map(NULL);\n+  set_reference_map(nullptr);\n@@ -756,1 +756,1 @@\n-  if (_initial_entries != NULL) {\n+  if (_initial_entries != nullptr) {\n@@ -759,1 +759,1 @@\n-    _initial_entries = NULL;\n+    _initial_entries = nullptr;\n@@ -767,1 +767,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -779,1 +779,1 @@\n-void ConstantPoolCache::set_archived_references(oop o) {\n+void ConstantPoolCache::set_archived_references(int root_index) {\n@@ -781,1 +781,1 @@\n-  _archived_references_index = HeapShared::append_root(o);\n+  _archived_references_index = root_index;\n@@ -793,1 +793,1 @@\n-    if (old_method == NULL || !old_method->is_old()) {\n+    if (old_method == nullptr || !old_method->is_old()) {\n@@ -811,1 +811,1 @@\n-    if (m != NULL && !entry_at(i)->check_no_old_or_obsolete_entries()) {\n+    if (m != nullptr && !entry_at(i)->check_no_old_or_obsolete_entries()) {\n@@ -823,1 +823,1 @@\n-    if (entry_at(i)->get_interesting_method_entry() != NULL) {\n+    if (entry_at(i)->get_interesting_method_entry() != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -136,1 +136,0 @@\n-  friend class constantPoolCacheKlass;\n@@ -151,1 +150,1 @@\n-    assert(existing_f1 == NULL || existing_f1 == f1, \"illegal field change\");\n+    assert(existing_f1 == nullptr || existing_f1 == f1, \"illegal field change\");\n@@ -236,1 +235,1 @@\n-    const methodHandle& method,                  \/\/ the method\/prototype if any (NULL, otherwise)\n+    const methodHandle& method,                  \/\/ the method\/prototype if any (null, otherwise)\n@@ -456,2 +455,2 @@\n-  oop  archived_references() NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  void set_archived_references(oop o) NOT_CDS_JAVA_HEAP_RETURN;\n+  oop  archived_references() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  void set_archived_references(int root_index) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -487,1 +486,0 @@\n-  friend class constantPoolCacheKlass;\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,1 +284,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -422,1 +422,1 @@\n-    bb_mark_fct(this, excps.handler_pc(i), NULL);\n+    bb_mark_fct(this, excps.handler_pc(i), nullptr);\n@@ -433,1 +433,1 @@\n-        bb_mark_fct(this, bci, NULL);\n+        bb_mark_fct(this, bci, nullptr);\n@@ -435,1 +435,1 @@\n-    fellThrough = jump_targets_do(&bcs, &GenerateOopMap::bb_mark_fct, NULL);\n+    fellThrough = jump_targets_do(&bcs, &GenerateOopMap::bb_mark_fct, nullptr);\n@@ -441,1 +441,1 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), NULL);\n+        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n@@ -445,1 +445,1 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), NULL);\n+        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n@@ -653,1 +653,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -676,3 +676,3 @@\n-#define ALLOC_RESOURCE_ARRAY(var, type, count) \\\n-  var = NEW_RESOURCE_ARRAY_RETURN_NULL(type, count);              \\\n-  if (var == NULL) {                                              \\\n+#define ALLOC_RESOURCE_ARRAY(var, type, count)                           \\\n+  var = NEW_RESOURCE_ARRAY_RETURN_NULL(type, count);                     \\\n+  if (var == nullptr) {                                                  \\\n@@ -680,1 +680,1 @@\n-    return;                                                       \\\n+    return;                                                              \\\n@@ -805,1 +805,1 @@\n-  guarantee(bb != NULL, \"null basicblock\");\n+  guarantee(bb != nullptr, \"null basicblock\");\n@@ -1161,1 +1161,1 @@\n-    bool fall_through = jump_targets_do(&itr, GenerateOopMap::merge_state, NULL);\n+    bool fall_through = jump_targets_do(&itr, GenerateOopMap::merge_state, nullptr);\n@@ -1167,1 +1167,1 @@\n-      ret_jump_targets_do(&itr, GenerateOopMap::merge_state, itr.get_index(), NULL);\n+      ret_jump_targets_do(&itr, GenerateOopMap::merge_state, itr.get_index(), nullptr);\n@@ -1230,1 +1230,1 @@\n-        guarantee(excBB != NULL, \"no basic block for exception\");\n+        guarantee(excBB != nullptr, \"no basic block for exception\");\n@@ -1848,1 +1848,1 @@\n-    guarantee(bb != NULL, \"no basic block for bci\");\n+    guarantee(bb != nullptr, \"no basic block for bci\");\n@@ -2104,1 +2104,1 @@\n-  _init_vars = NULL;\n+  _init_vars = nullptr;\n@@ -2125,1 +2125,1 @@\n-  TraceTime t_all(NULL, &_total_oopmap_time, TimeOopMap);\n+  TraceTime t_all(nullptr, &_total_oopmap_time, TimeOopMap);\n@@ -2137,1 +2137,1 @@\n-  _new_var_map    = NULL;\n+  _new_var_map    = nullptr;\n@@ -2255,1 +2255,1 @@\n-  guarantee(bb != NULL, \"no basic block for bci\");\n+  guarantee(bb != nullptr, \"no basic block for bci\");\n@@ -2315,1 +2315,1 @@\n-  assert(_new_var_map!=NULL, \"nothing to rewrite\");\n+  assert(_new_var_map!=nullptr, \"nothing to rewrite\");\n@@ -2339,1 +2339,1 @@\n-  _new_var_map = NULL;\n+  _new_var_map = nullptr;\n@@ -2539,1 +2539,1 @@\n-  assert(_ret_adr_tos != NULL, \"must be initialized\");\n+  assert(_ret_adr_tos != nullptr, \"must be initialized\");\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-  RetTable()                                                  { _first = NULL; }\n+  RetTable()                                                  { _first = nullptr; }\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-    char* data = NULL;                                           \\\n+    char* data = nullptr;                                        \\\n@@ -118,1 +118,1 @@\n-    if (clss_name != NULL) {                                     \\\n+    if (clss_name != nullptr) {                                  \\\n@@ -128,1 +128,1 @@\n-    char* data = NULL;                                           \\\n+    char* data = nullptr;                                        \\\n@@ -131,1 +131,1 @@\n-    if (clss_name != NULL) {                                     \\\n+    if (clss_name != nullptr) {                                  \\\n@@ -150,1 +150,1 @@\n-  assert(class_name != NULL, \"invariant\");\n+  assert(class_name != nullptr, \"invariant\");\n@@ -158,1 +158,1 @@\n-    if (super_klass != NULL) {\n+    if (super_klass != nullptr) {\n@@ -180,1 +180,1 @@\n-  if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {\n+  if (_nest_members == nullptr || _nest_members == Universe::the_empty_short_array()) {\n@@ -212,2 +212,2 @@\n-  assert(k != NULL, \"sanity check\");\n-  assert(_permitted_subclasses != NULL && _permitted_subclasses != Universe::the_empty_short_array(),\n+  assert(k != nullptr, \"sanity check\");\n+  assert(_permitted_subclasses != nullptr && _permitted_subclasses != Universe::the_empty_short_array(),\n@@ -251,1 +251,1 @@\n-\/\/ (such as a native JIT thread) then we simply return NULL, which in turn\n+\/\/ (such as a native JIT thread) then we simply return null, which in turn\n@@ -258,2 +258,2 @@\n-\/\/ VirtualMachineErrors are propagated with a NULL return.\n-\/\/ Under any conditions where the _nest_host can be set to non-NULL the resulting\n+\/\/ VirtualMachineErrors are propagated with a null return.\n+\/\/ Under any conditions where the _nest_host can be set to non-null the resulting\n@@ -264,1 +264,1 @@\n-  if (nest_host_k != NULL) {\n+  if (nest_host_k != nullptr) {\n@@ -277,1 +277,1 @@\n-      return NULL; \/\/ sentinel to say \"try again from a different context\"\n+      return nullptr; \/\/ sentinel to say \"try again from a different context\"\n@@ -287,1 +287,1 @@\n-        return NULL; \/\/ propagate VMEs\n+        return nullptr; \/\/ propagate VMEs\n@@ -304,1 +304,1 @@\n-      const char* error = NULL;\n+      const char* error = nullptr;\n@@ -366,3 +366,3 @@\n-  assert(host != NULL, \"NULL nest host specified\");\n-  assert(_nest_host == NULL, \"current class has resolved nest-host\");\n-  assert(nest_host_error() == NULL, \"unexpected nest host resolution error exists: %s\",\n+  assert(host != nullptr, \"null nest host specified\");\n+  assert(_nest_host == nullptr, \"current class has resolved nest-host\");\n+  assert(nest_host_error() == nullptr, \"unexpected nest host resolution error exists: %s\",\n@@ -370,1 +370,1 @@\n-  assert((host->_nest_host == NULL && host->_nest_host_index == 0) ||\n+  assert((host->_nest_host == nullptr && host->_nest_host_index == 0) ||\n@@ -381,1 +381,1 @@\n-    } else if (_nest_members != NULL && _nest_members != Universe::the_empty_short_array()) {\n+    } else if (_nest_members != nullptr && _nest_members != Universe::the_empty_short_array()) {\n@@ -393,1 +393,1 @@\n-  assert(this_key != NULL, \"sanity\");\n+  assert(this_key != nullptr, \"sanity\");\n@@ -409,1 +409,1 @@\n-  if (cur_host == NULL) {\n+  if (cur_host == nullptr) {\n@@ -414,1 +414,1 @@\n-  if (k_nest_host == NULL) {\n+  if (k_nest_host == nullptr) {\n@@ -430,1 +430,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -446,1 +446,1 @@\n-  assert(class_name != NULL, \"invariant\");\n+  assert(class_name != nullptr, \"invariant\");\n@@ -448,1 +448,1 @@\n-  assert(loader_data != NULL, \"invariant\");\n+  assert(loader_data != nullptr, \"invariant\");\n@@ -476,1 +476,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -491,2 +491,2 @@\n-  const char* bad = NULL;\n-  address end = NULL;\n+  const char* bad = nullptr;\n+  address end = nullptr;\n@@ -515,1 +515,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -529,1 +529,1 @@\n-  assert(default_vtable_indices() == NULL, \"only create once\");\n+  assert(default_vtable_indices() == nullptr, \"only create once\");\n@@ -540,4 +540,4 @@\n-  _nest_members(NULL),\n-  _nest_host(NULL),\n-  _permitted_subclasses(NULL),\n-  _record_components(NULL),\n+  _nest_members(nullptr),\n+  _nest_host(nullptr),\n+  _permitted_subclasses(nullptr),\n+  _record_components(nullptr),\n@@ -551,4 +551,4 @@\n-  _init_thread(NULL),\n-  _inline_type_field_klasses(NULL),\n-  _preload_classes(NULL),\n-  _adr_inlineklass_fixed_block(NULL)\n+  _init_thread(nullptr),\n+  _inline_type_field_klasses(nullptr),\n+  _preload_classes(nullptr),\n+  _adr_inlineklass_fixed_block(nullptr)\n@@ -566,1 +566,1 @@\n-  assert(NULL == _methods, \"underlying memory not zeroed?\");\n+  assert(nullptr == _methods, \"underlying memory not zeroed?\");\n@@ -577,1 +577,1 @@\n-  if (methods != NULL && methods != Universe::the_empty_method_array() &&\n+  if (methods != nullptr && methods != Universe::the_empty_method_array() &&\n@@ -581,1 +581,1 @@\n-      if (method == NULL) continue;  \/\/ maybe null if error processing\n+      if (method == nullptr) continue;  \/\/ maybe null if error processing\n@@ -600,1 +600,1 @@\n-    Array<InstanceKlass*>* sti = (super_klass == NULL) ? NULL :\n+    Array<InstanceKlass*>* sti = (super_klass == nullptr) ? nullptr :\n@@ -602,1 +602,1 @@\n-    if (ti != sti && ti != NULL && !ti->is_shared()) {\n+    if (ti != sti && ti != nullptr && !ti->is_shared()) {\n@@ -609,1 +609,1 @@\n-      local_interfaces != NULL && !local_interfaces->is_shared()) {\n+      local_interfaces != nullptr && !local_interfaces->is_shared()) {\n@@ -616,1 +616,1 @@\n-  if (record_components != NULL && !record_components->is_shared()) {\n+  if (record_components != nullptr && !record_components->is_shared()) {\n@@ -629,2 +629,2 @@\n-  if (java_mirror() != NULL) {\n-    java_lang_Class::set_klass(java_mirror(), NULL);\n+  if (java_mirror() != nullptr) {\n+    java_lang_Class::set_klass(java_mirror(), nullptr);\n@@ -643,1 +643,1 @@\n-  assert(array_klasses() == NULL, \"array classes shouldn't be created for this class yet\");\n+  assert(array_klasses() == nullptr, \"array classes shouldn't be created for this class yet\");\n@@ -653,1 +653,1 @@\n-  set_methods(NULL);\n+  set_methods(nullptr);\n@@ -656,1 +656,1 @@\n-  set_record_components(NULL);\n+  set_record_components(nullptr);\n@@ -658,1 +658,1 @@\n-  if (method_ordering() != NULL &&\n+  if (method_ordering() != nullptr &&\n@@ -663,1 +663,1 @@\n-  set_method_ordering(NULL);\n+  set_method_ordering(nullptr);\n@@ -666,1 +666,1 @@\n-  if (default_methods() != NULL &&\n+  if (default_methods() != nullptr &&\n@@ -672,1 +672,1 @@\n-  set_default_methods(NULL);\n+  set_default_methods(nullptr);\n@@ -675,1 +675,1 @@\n-  if (default_vtable_indices() != NULL &&\n+  if (default_vtable_indices() != nullptr &&\n@@ -679,1 +679,1 @@\n-  set_default_vtable_indices(NULL);\n+  set_default_vtable_indices(nullptr);\n@@ -685,1 +685,1 @@\n-  if (secondary_supers() != NULL &&\n+  if (secondary_supers() != nullptr &&\n@@ -692,1 +692,1 @@\n-  set_secondary_supers(NULL);\n+  set_secondary_supers(nullptr);\n@@ -695,2 +695,2 @@\n-  set_transitive_interfaces(NULL);\n-  set_local_interfaces(NULL);\n+  set_transitive_interfaces(nullptr);\n+  set_local_interfaces(nullptr);\n@@ -698,1 +698,1 @@\n-  if (fields() != NULL && !fields()->is_shared()) {\n+  if (fields() != nullptr && !fields()->is_shared()) {\n@@ -701,1 +701,1 @@\n-  set_fields(NULL, 0);\n+  set_fields(nullptr, 0);\n@@ -705,1 +705,1 @@\n-  if (constants() != NULL) {\n+  if (constants() != nullptr) {\n@@ -713,1 +713,1 @@\n-    set_constants(NULL);\n+    set_constants(nullptr);\n@@ -716,1 +716,1 @@\n-  if (inner_classes() != NULL &&\n+  if (inner_classes() != nullptr &&\n@@ -721,1 +721,1 @@\n-  set_inner_classes(NULL);\n+  set_inner_classes(nullptr);\n@@ -723,1 +723,1 @@\n-  if (nest_members() != NULL &&\n+  if (nest_members() != nullptr &&\n@@ -728,1 +728,1 @@\n-  set_nest_members(NULL);\n+  set_nest_members(nullptr);\n@@ -730,1 +730,1 @@\n-  if (permitted_subclasses() != NULL &&\n+  if (permitted_subclasses() != nullptr &&\n@@ -735,1 +735,1 @@\n-  set_permitted_subclasses(NULL);\n+  set_permitted_subclasses(nullptr);\n@@ -737,1 +737,1 @@\n-  if (preload_classes() != NULL &&\n+  if (preload_classes() != nullptr &&\n@@ -744,1 +744,1 @@\n-  if (annotations() != NULL && !annotations()->is_shared()) {\n+  if (annotations() != nullptr && !annotations()->is_shared()) {\n@@ -747,1 +747,1 @@\n-  set_annotations(NULL);\n+  set_annotations(nullptr);\n@@ -750,0 +750,6 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (DumpSharedSpaces) {\n+    HeapShared::remove_scratch_objects(this);\n+  }\n+#endif\n@@ -753,1 +759,1 @@\n-  return _record_components != NULL &&\n+  return _record_components != nullptr &&\n@@ -759,1 +765,1 @@\n-  return _permitted_subclasses != NULL &&\n+  return _permitted_subclasses != nullptr &&\n@@ -868,1 +874,1 @@\n-  if (super_klass != NULL) {\n+  if (super_klass != nullptr) {\n@@ -934,1 +940,1 @@\n-              if (klass == NULL) {\n+              if (klass == nullptr) {\n@@ -950,1 +956,1 @@\n-    if (preload_classes() != NULL) {\n+    if (preload_classes() != nullptr) {\n@@ -962,1 +968,1 @@\n-        if (klass != NULL) {\n+        if (klass != nullptr) {\n@@ -1173,1 +1179,1 @@\n-      jt->set_class_to_be_initialized(NULL);\n+      jt->set_class_to_be_initialized(nullptr);\n@@ -1239,1 +1245,1 @@\n-    if (super_klass != NULL && super_klass->should_be_initialized()) {\n+    if (super_klass != nullptr && super_klass->should_be_initialized()) {\n@@ -1271,1 +1277,1 @@\n-        if (fs.access_flags().is_static() && klass == NULL) {\n+        if (fs.access_flags().is_static() && klass == nullptr) {\n@@ -1280,1 +1286,1 @@\n-          assert(klass != NULL, \"Must  be\");\n+          assert(klass != nullptr, \"Must  be\");\n@@ -1283,1 +1289,1 @@\n-            if (java_mirror()->obj_field(fs.offset()) == NULL) {\n+            if (java_mirror()->obj_field(fs.offset()) == nullptr) {\n@@ -1310,1 +1316,1 @@\n-    if (class_initializer() != NULL) {\n+    if (class_initializer() != nullptr) {\n@@ -1372,1 +1378,1 @@\n-    set_init_thread(NULL); \/\/ reset _init_thread before changing _init_state\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n@@ -1377,1 +1383,1 @@\n-    set_init_thread(NULL); \/\/ reset _init_thread before changing _init_state\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n@@ -1385,2 +1391,2 @@\n-  if (ik == NULL) {\n-    return NULL;\n+  if (ik == nullptr) {\n+    return nullptr;\n@@ -1390,2 +1396,2 @@\n-    if (ikls != NULL && !ikls->is_loader_alive()) {\n-      return NULL;  \/\/ don't return unloaded class\n+    if (ikls != nullptr && !ikls->is_loader_alive()) {\n+      return nullptr;  \/\/ don't return unloaded class\n@@ -1403,2 +1409,2 @@\n-  assert(addr != NULL, \"null addr\");\n-  if (addr != NULL) {\n+  assert(addr != nullptr, \"null addr\");\n+  if (addr != nullptr) {\n@@ -1411,1 +1417,1 @@\n-  if (ik == NULL) {\n+  if (ik == nullptr) {\n@@ -1424,1 +1430,1 @@\n-\/\/   NULL                  - no implementor\n+\/\/   null                  - no implementor\n@@ -1442,1 +1448,1 @@\n-  if (super_ik != NULL && super_ik->implements_interface(this))\n+  if (super_ik != nullptr && super_ik->implements_interface(this))\n@@ -1449,1 +1455,1 @@\n-  if (iklass == NULL) {\n+  if (iklass == nullptr) {\n@@ -1465,1 +1471,1 @@\n-    set_implementor(NULL);\n+    set_implementor(nullptr);\n@@ -1495,1 +1501,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1503,1 +1509,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1595,1 +1601,1 @@\n-  if (array_klasses_acquire() == NULL) {\n+  if (array_klasses_acquire() == nullptr) {\n@@ -1603,1 +1609,1 @@\n-      if (array_klasses() == NULL) {\n+      if (array_klasses() == nullptr) {\n@@ -1619,2 +1625,2 @@\n-  if (ak == NULL) {\n-    return NULL;\n+  if (ak == nullptr) {\n+    return nullptr;\n@@ -1639,1 +1645,1 @@\n-  if (clinit != NULL && clinit->is_class_initializer()) {\n+  if (clinit != nullptr && clinit->is_class_initializer()) {\n@@ -1642,1 +1648,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1648,1 +1654,1 @@\n-       (ReplaySuppressInitializers >= 2 && class_loader() != NULL))) {\n+       (ReplaySuppressInitializers >= 2 && class_loader() != nullptr))) {\n@@ -1672,1 +1678,1 @@\n-    ls.print_cr(\"%s (\" PTR_FORMAT \")\", h_method() == NULL ? \"(no method)\" : \"\", p2i(this));\n+    ls.print_cr(\"%s (\" PTR_FORMAT \")\", h_method() == nullptr ? \"(no method)\" : \"\", p2i(this));\n@@ -1674,1 +1680,1 @@\n-  if (h_method() != NULL) {\n+  if (h_method() != nullptr) {\n@@ -1687,1 +1693,1 @@\n-  if (oop_map_cache == NULL) {\n+  if (oop_map_cache == nullptr) {\n@@ -1690,1 +1696,1 @@\n-    if ((oop_map_cache = _oop_map_cache) == NULL) {\n+    if ((oop_map_cache = _oop_map_cache) == nullptr) {\n@@ -1725,1 +1731,1 @@\n-    if (intf2 != NULL) return intf2;\n+    if (intf2 != nullptr) return intf2;\n@@ -1728,1 +1734,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1740,1 +1746,1 @@\n-    if (intf != NULL) return intf;\n+    if (intf != nullptr) return intf;\n@@ -1744,1 +1750,1 @@\n-    if (supr != NULL) return InstanceKlass::cast(supr)->find_field(name, sig, fd);\n+    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, fd);\n@@ -1747,1 +1753,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1760,1 +1766,1 @@\n-    if (intf != NULL) return intf;\n+    if (intf != nullptr) return intf;\n@@ -1764,1 +1770,1 @@\n-    if (supr != NULL) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n+    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n@@ -1767,1 +1773,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1793,1 +1799,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -1841,1 +1847,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -1861,1 +1867,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -1987,1 +1993,1 @@\n-  assert(((meth == NULL) || !meth->is_static()),\n+  assert(((meth == nullptr) || !meth->is_static()),\n@@ -2055,1 +2061,1 @@\n-  return hit >= 0 ? methods->at(hit): NULL;\n+  return hit >= 0 ? methods->at(hit): nullptr;\n@@ -2141,1 +2147,1 @@\n-  assert(end_ptr != NULL, \"just checking\");\n+  assert(end_ptr != nullptr, \"just checking\");\n@@ -2162,1 +2168,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -2168,1 +2174,1 @@\n-    if (method != NULL) {\n+    if (method != nullptr) {\n@@ -2178,1 +2184,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2186,1 +2192,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -2200,2 +2206,2 @@\n-  Method* m = NULL;\n-  if (default_methods() != NULL) {\n+  Method* m = nullptr;\n+  if (default_methods() != nullptr) {\n@@ -2205,1 +2211,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -2219,1 +2225,1 @@\n-  InstanceKlass *ik = NULL;\n+  InstanceKlass *ik = nullptr;\n@@ -2223,1 +2229,1 @@\n-    if (m != NULL && m->is_public() && !m->is_static() &&\n+    if (m != nullptr && m->is_public() && !m->is_static() &&\n@@ -2228,1 +2234,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2280,2 +2286,2 @@\n-  JNIid* probe = jni_ids() == NULL ? NULL : jni_ids()->find(offset);\n-  if (probe == NULL) {\n+  JNIid* probe = jni_ids() == nullptr ? nullptr : jni_ids()->find(offset);\n+  if (probe == nullptr) {\n@@ -2291,1 +2297,1 @@\n-  if (inner_class_list == NULL) {\n+  if (inner_class_list == nullptr) {\n@@ -2306,1 +2312,1 @@\n-  assert (inner_class_list != NULL, \"_inner_classes list is not set up\");\n+  assert (inner_class_list != nullptr, \"_inner_classes list is not set up\");\n@@ -2326,1 +2332,1 @@\n-  jmethodID id = NULL;\n+  jmethodID id = nullptr;\n@@ -2330,1 +2336,1 @@\n-  \/\/ transitions from NULL to non-NULL which is safe because we use\n+  \/\/ transitions from null to non-null which is safe because we use\n@@ -2341,1 +2347,1 @@\n-  \/\/ grow and we'll have transitions from non-NULL to bigger non-NULL.\n+  \/\/ grow and we'll have transitions from non-null to bigger non-null.\n@@ -2346,1 +2352,1 @@\n-  if (jmeths != NULL) {\n+  if (jmeths != nullptr) {\n@@ -2359,3 +2365,3 @@\n-  if (jmeths == NULL ||   \/\/ no cache yet\n-      length <= idnum ||  \/\/ cache is too short\n-      id == NULL) {       \/\/ cache doesn't contain entry\n+  if (jmeths == nullptr ||   \/\/ no cache yet\n+      length <= idnum ||     \/\/ cache is too short\n+      id == nullptr) {       \/\/ cache doesn't contain entry\n@@ -2368,2 +2374,2 @@\n-    jmethodID  to_dealloc_id     = NULL;\n-    jmethodID* to_dealloc_jmeths = NULL;\n+    jmethodID  to_dealloc_id     = nullptr;\n+    jmethodID* to_dealloc_jmeths = nullptr;\n@@ -2372,1 +2378,1 @@\n-    jmethodID* new_jmeths = NULL;\n+    jmethodID* new_jmeths = nullptr;\n@@ -2385,1 +2391,1 @@\n-      jmethodID new_id = NULL;\n+      jmethodID new_id = nullptr;\n@@ -2389,1 +2395,1 @@\n-        assert(current_method != NULL, \"old and but not obsolete, so should exist\");\n+        assert(current_method != nullptr, \"old and but not obsolete, so should exist\");\n@@ -2403,1 +2409,1 @@\n-    if (to_dealloc_jmeths != NULL) {\n+    if (to_dealloc_jmeths != nullptr) {\n@@ -2407,1 +2413,1 @@\n-    if (to_dealloc_id != NULL) {\n+    if (to_dealloc_id != nullptr) {\n@@ -2425,1 +2431,1 @@\n-    if (id == NULL) {\n+    if (id == nullptr) {\n@@ -2443,3 +2449,3 @@\n-  assert(new_id != NULL, \"sanity check\");\n-  assert(to_dealloc_id_p != NULL, \"sanity check\");\n-  assert(to_dealloc_jmeths_p != NULL, \"sanity check\");\n+  assert(new_id != nullptr, \"sanity check\");\n+  assert(to_dealloc_id_p != nullptr, \"sanity check\");\n+  assert(to_dealloc_jmeths_p != nullptr, \"sanity check\");\n@@ -2450,1 +2456,1 @@\n-  jmethodID  id     = NULL;\n+  jmethodID  id     = nullptr;\n@@ -2453,1 +2459,1 @@\n-  if (jmeths == NULL ||                         \/\/ no cache yet\n+  if (jmeths == nullptr ||                      \/\/ no cache yet\n@@ -2455,1 +2461,1 @@\n-    if (jmeths != NULL) {\n+    if (jmeths != nullptr) {\n@@ -2468,1 +2474,1 @@\n-  if (id == NULL) {\n+  if (id == nullptr) {\n@@ -2491,3 +2497,3 @@\n-  assert(cache != NULL, \"sanity check\");\n-  assert(length_p != NULL, \"sanity check\");\n-  assert(id_p != NULL, \"sanity check\");\n+  assert(cache != nullptr, \"sanity check\");\n+  assert(length_p != nullptr, \"sanity check\");\n+  assert(id_p != nullptr, \"sanity check\");\n@@ -2498,1 +2504,1 @@\n-    *id_p = NULL;\n+    *id_p = nullptr;\n@@ -2505,1 +2511,1 @@\n-\/\/ Lookup a jmethodID, NULL if not found.  Do no blocking, no allocations, no handles\n+\/\/ Lookup a jmethodID, null if not found.  Do no blocking, no allocations, no handles\n@@ -2510,2 +2516,2 @@\n-  jmethodID id = NULL;\n-  if (jmeths != NULL &&                         \/\/ If there is a cache\n+  jmethodID id = nullptr;\n+  if (jmeths != nullptr &&                      \/\/ If there is a cache\n@@ -2513,1 +2519,1 @@\n-    id = jmeths[idnum+1];                       \/\/ Look up the id (may be NULL)\n+    id = jmeths[idnum+1];                       \/\/ Look up the id (may be null)\n@@ -2557,2 +2563,2 @@\n-      if (impl != NULL && !impl->is_loader_alive()) {\n-        \/\/ NULL this field, might be an unloaded instance klass or NULL\n+      if (impl != nullptr && !impl->is_loader_alive()) {\n+        \/\/ null this field, might be an unloaded instance klass or null\n@@ -2560,1 +2566,1 @@\n-        if (Atomic::cmpxchg(iklass, impl, (InstanceKlass*)NULL) == impl) {\n+        if (Atomic::cmpxchg(iklass, impl, (InstanceKlass*)nullptr) == impl) {\n@@ -2578,2 +2584,2 @@\n-    if (mdo != NULL) {\n-      MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? NULL : mdo->extra_data_lock());\n+    if (mdo != nullptr) {\n+      MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? nullptr : mdo->extra_data_lock());\n@@ -2625,1 +2631,1 @@\n-      if (ioe->interface_klass() != NULL) {\n+      if (ioe->interface_klass() != nullptr) {\n@@ -2685,1 +2691,1 @@\n-  if (array_klasses() != NULL) {\n+  if (array_klasses() != nullptr) {\n@@ -2697,4 +2703,4 @@\n-  \/\/ These are not allocated from metaspace. They are safe to set to NULL.\n-  _source_debug_extension = NULL;\n-  _dep_context = NULL;\n-  _osr_nmethods_head = NULL;\n+  \/\/ These are not allocated from metaspace. They are safe to set to nullptr.\n+  _source_debug_extension = nullptr;\n+  _dep_context = nullptr;\n+  _osr_nmethods_head = nullptr;\n@@ -2702,4 +2708,4 @@\n-  _breakpoints = NULL;\n-  _previous_versions = NULL;\n-  _cached_class_file = NULL;\n-  _jvmti_cached_class_field_map = NULL;\n+  _breakpoints = nullptr;\n+  _previous_versions = nullptr;\n+  _cached_class_file = nullptr;\n+  _jvmti_cached_class_field_map = nullptr;\n@@ -2708,4 +2714,4 @@\n-  _init_thread = NULL;\n-  _methods_jmethod_ids = NULL;\n-  _jni_ids = NULL;\n-  _oop_map_cache = NULL;\n+  _init_thread = nullptr;\n+  _methods_jmethod_ids = nullptr;\n+  _jni_ids = nullptr;\n+  _oop_map_cache = nullptr;\n@@ -2713,1 +2719,1 @@\n-  _nest_host = NULL;\n+  _nest_host = nullptr;\n@@ -2716,1 +2722,1 @@\n-  _init_monitor = NULL;\n+  _init_monitor = nullptr;\n@@ -2723,1 +2729,1 @@\n-  if (array_klasses() != NULL) {\n+  if (array_klasses() != nullptr) {\n@@ -2730,1 +2736,1 @@\n-  _package_entry = NULL;\n+  _package_entry = nullptr;\n@@ -2733,1 +2739,1 @@\n-    _package_entry = NULL;\n+    _package_entry = nullptr;\n@@ -2736,1 +2742,1 @@\n-      _package_entry = NULL;\n+      _package_entry = nullptr;\n@@ -2740,1 +2746,1 @@\n-      _package_entry = NULL;\n+      _package_entry = nullptr;\n@@ -2787,1 +2793,1 @@\n-  if (array_klasses() != NULL) {\n+  if (array_klasses() != nullptr) {\n@@ -2819,1 +2825,1 @@\n-  if (java_super() != NULL && !java_super()->can_be_verified_at_dumptime()) {\n+  if (java_super() != nullptr && !java_super()->can_be_verified_at_dumptime()) {\n@@ -2861,1 +2867,1 @@\n-  assert(ik != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n@@ -2887,1 +2893,1 @@\n-  if (_oop_map_cache != NULL) {\n+  if (_oop_map_cache != nullptr) {\n@@ -2889,1 +2895,1 @@\n-    _oop_map_cache = NULL;\n+    _oop_map_cache = nullptr;\n@@ -2894,1 +2900,1 @@\n-  set_jni_ids(NULL);\n+  set_jni_ids(nullptr);\n@@ -2897,2 +2903,2 @@\n-  if (jmeths != (jmethodID*)NULL) {\n-    release_set_methods_jmethod_ids(NULL);\n+  if (jmeths != (jmethodID*)nullptr) {\n+    release_set_methods_jmethod_ids(nullptr);\n@@ -2902,1 +2908,1 @@\n-  assert(_dep_context == NULL,\n+  assert(_dep_context == nullptr,\n@@ -2913,1 +2919,1 @@\n-  if (_cached_class_file != NULL) {\n+  if (_cached_class_file != nullptr) {\n@@ -2915,1 +2921,1 @@\n-    _cached_class_file = NULL;\n+    _cached_class_file = nullptr;\n@@ -2927,2 +2933,2 @@\n-  if (array == NULL) {\n-    _source_debug_extension = NULL;\n+  if (array == nullptr) {\n+    _source_debug_extension = nullptr;\n@@ -2973,1 +2979,1 @@\n-  \/\/ Add the semicolon and the NULL\n+  \/\/ Add the semicolon and the null\n@@ -3016,1 +3022,1 @@\n-  if (is_shared() && _package_entry != NULL) {\n+  if (is_shared() && _package_entry != nullptr) {\n@@ -3022,1 +3028,1 @@\n-      _package_entry = NULL;\n+      _package_entry = nullptr;\n@@ -3029,1 +3035,1 @@\n-      (pkg_entry != NULL) ? NULL : ClassLoader::package_from_class_name(name());\n+      (pkg_entry != nullptr) ? nullptr : ClassLoader::package_from_class_name(name());\n@@ -3032,1 +3038,1 @@\n-  if (pkg_entry != NULL) {\n+  if (pkg_entry != nullptr) {\n@@ -3038,1 +3044,1 @@\n-  if (pkg_name != NULL && loader_data != NULL) {\n+  if (pkg_name != nullptr && loader_data != nullptr) {\n@@ -3041,1 +3047,1 @@\n-    _package_entry = pkg_entry != NULL ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n+    _package_entry = pkg_entry != nullptr ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n@@ -3046,1 +3052,1 @@\n-    if (_package_entry == NULL) {\n+    if (_package_entry == nullptr) {\n@@ -3053,1 +3059,1 @@\n-        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n+        assert(ModuleEntryTable::javabase_moduleEntry() != nullptr, JAVA_BASE_NAME \" module is null\");\n@@ -3056,1 +3062,1 @@\n-        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n+        assert(loader_data->unnamed_module() != nullptr, \"unnamed module is null\");\n@@ -3062,1 +3068,1 @@\n-      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n+      assert(_package_entry != nullptr, \"Package entry for class %s not found, loader %s\",\n@@ -3079,1 +3085,1 @@\n-                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n+                      (loader_data != nullptr) ? loader_data->loader_name_and_id() : \"null\",\n@@ -3094,1 +3100,1 @@\n-  if (_package_entry != NULL) {\n+  if (_package_entry != nullptr) {\n@@ -3118,2 +3124,2 @@\n-    classloader2 = NULL;\n-    classpkg2 = NULL;\n+    classloader2 = nullptr;\n+    classpkg2 = nullptr;\n@@ -3152,2 +3158,2 @@\n-    \/\/ Check that package_from_class_name() returns NULL, not \"\", if there is no package.\n-    assert(other_pkg == NULL || other_pkg->utf8_length() > 0, \"package name is empty string\");\n+    \/\/ Check that package_from_class_name() returns null, not \"\", if there is no package.\n+    assert(other_pkg == nullptr || other_pkg->utf8_length() > 0, \"package name is empty string\");\n@@ -3156,1 +3162,1 @@\n-      this->package() != NULL ? this->package()->name() : NULL;\n+      this->package() != nullptr ? this->package()->name() : nullptr;\n@@ -3158,1 +3164,1 @@\n-    if (this_package_name == NULL || other_pkg == NULL) {\n+    if (this_package_name == nullptr || other_pkg == nullptr) {\n@@ -3187,1 +3193,1 @@\n-      class_name != NULL && class_name->utf8_length() >= 5) {\n+      class_name != nullptr && class_name->utf8_length() >= 5) {\n@@ -3199,1 +3205,1 @@\n-      assert(pkg_name != NULL, \"Error in parsing package name starting with 'java\/'\");\n+      assert(pkg_name != nullptr, \"Error in parsing package name starting with 'java\/'\");\n@@ -3235,1 +3241,1 @@\n-  InstanceKlass* outer_klass = NULL;\n+  InstanceKlass* outer_klass = nullptr;\n@@ -3253,1 +3259,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -3258,1 +3264,1 @@\n-    if (NULL == outer_klass) {\n+    if (nullptr == outer_klass) {\n@@ -3270,1 +3276,1 @@\n-  if (NULL == outer_klass) return NULL;\n+  if (nullptr == outer_klass) return nullptr;\n@@ -3323,1 +3329,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -3358,1 +3364,1 @@\n-  return NULL; \/\/ offset entry not found\n+  return nullptr; \/\/ offset entry not found\n@@ -3371,1 +3377,1 @@\n-  if (!intf_method->is_abstract() && default_methods() != NULL) {\n+  if (!intf_method->is_abstract() && default_methods() != nullptr) {\n@@ -3396,1 +3402,1 @@\n-  if (default_methods() != NULL) {\n+  if (default_methods() != nullptr) {\n@@ -3399,1 +3405,1 @@\n-      if (old_method == NULL || !old_method->is_old()) {\n+      if (old_method == nullptr || !old_method->is_old()) {\n@@ -3428,1 +3434,1 @@\n-  assert(prev == NULL || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n+  assert(prev == nullptr || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n@@ -3441,1 +3447,1 @@\n-    if (inv != NULL && inv->is_in_use()) {\n+    if (inv != nullptr && inv->is_in_use()) {\n@@ -3450,1 +3456,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock\n@@ -3453,1 +3459,1 @@\n-  nmethod* last = NULL;\n+  nmethod* last = nullptr;\n@@ -3459,1 +3465,1 @@\n-  while(cur != NULL && cur != n) {\n+  while(cur != nullptr && cur != n) {\n@@ -3467,1 +3473,1 @@\n-  nmethod* next = NULL;\n+  nmethod* next = nullptr;\n@@ -3471,1 +3477,1 @@\n-    if (last == NULL) {\n+    if (last == nullptr) {\n@@ -3478,1 +3484,1 @@\n-  n->set_osr_link(NULL);\n+  n->set_osr_link(nullptr);\n@@ -3480,1 +3486,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -3492,1 +3498,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock,\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n@@ -3496,1 +3502,1 @@\n-  while (osr != NULL) {\n+  while (osr != nullptr) {\n@@ -3508,1 +3514,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock,\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n@@ -3511,2 +3517,2 @@\n-  nmethod* best = NULL;\n-  while (osr != NULL) {\n+  nmethod* best = nullptr;\n+  while (osr != nullptr) {\n@@ -3528,1 +3534,1 @@\n-        if (best == NULL || (osr->comp_level() > best->comp_level())) {\n+        if (best == nullptr || (osr->comp_level() > best->comp_level())) {\n@@ -3540,2 +3546,2 @@\n-  assert(match_level == false || best == NULL, \"shouldn't pick up anything if match_level is set\");\n-  if (best != NULL && best->comp_level() >= comp_level) {\n+  assert(match_level == false || best == nullptr, \"shouldn't pick up anything if match_level is set\");\n+  if (best != nullptr && best->comp_level() >= comp_level) {\n@@ -3544,1 +3550,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3571,1 +3577,1 @@\n-    } else if (self != NULL && e > 0 && e < 0x10000) {\n+    } else if (self != nullptr && e > 0 && e < 0x10000) {\n@@ -3583,1 +3589,1 @@\n-  return print_vtable(NULL, reinterpret_cast<intptr_t*>(start), len, st);\n+  return print_vtable(nullptr, reinterpret_cast<intptr_t*>(start), len, st);\n@@ -3588,1 +3594,1 @@\n-   if (array == NULL) { st->print_cr(\"NULL\"); return; }\n+   if (array == nullptr) { st->print_cr(\"nullptr\"); return; }\n@@ -3598,1 +3604,1 @@\n-  if (array == NULL) { st->print_cr(\"NULL\"); return; }\n+  if (array == nullptr) { st->print_cr(\"nullptr\"); return; }\n@@ -3608,1 +3614,1 @@\n-  return state_names[_init_state];\n+  return state_names[init_state()];\n@@ -3618,1 +3624,1 @@\n-  st->print(BULLET\"misc flags:        0x%x\", _misc_status.flags());               st->cr();\n+  st->print(BULLET\"misc flags:        0x%x\", _misc_flags.flags());               st->cr();\n@@ -3625,1 +3631,1 @@\n-  for (n = 0; sub != NULL; n++, sub = sub->next_sibling()) {\n+  for (n = 0; sub != nullptr; n++, sub = sub->next_sibling()) {\n@@ -3648,1 +3654,1 @@\n-  if (default_vtable_indices() != NULL) {\n+  if (default_vtable_indices() != nullptr) {\n@@ -3654,1 +3660,1 @@\n-  if (class_loader_data() != NULL) {\n+  if (class_loader_data() != nullptr) {\n@@ -3659,1 +3665,1 @@\n-  if (source_file_name() != NULL) {\n+  if (source_file_name() != nullptr) {\n@@ -3664,1 +3670,1 @@\n-  if (source_debug_extension() != NULL) {\n+  if (source_debug_extension() != nullptr) {\n@@ -3677,1 +3683,1 @@\n-         pv_node != NULL;\n+         pv_node != nullptr;\n@@ -3687,1 +3693,1 @@\n-  if (generic_signature() != NULL) {\n+  if (generic_signature() != nullptr) {\n@@ -3694,1 +3700,1 @@\n-  if (record_components() != NULL) {\n+  if (record_components() != nullptr) {\n@@ -3699,1 +3705,1 @@\n-  if (java_mirror() != NULL) {\n+  if (java_mirror() != nullptr) {\n@@ -3704,1 +3710,1 @@\n-    st->print_cr(BULLET\"java mirror:       NULL\");\n+    st->print_cr(BULLET\"java mirror:       null\");\n@@ -3709,1 +3715,1 @@\n-  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);\n+  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(nullptr, start_of_itable(), itable_length(), st);\n@@ -3736,1 +3742,1 @@\n-   if (_obj == NULL) {\n+   if (_obj == nullptr) {\n@@ -3752,1 +3758,1 @@\n-    if (value != NULL &&\n+    if (value != nullptr &&\n@@ -3770,1 +3776,1 @@\n-    if (real_klass != NULL && real_klass->is_instance_klass()) {\n+    if (real_klass != nullptr && real_klass->is_instance_klass()) {\n@@ -3796,1 +3802,1 @@\n-      && java_lang_String::value(obj) != NULL) {\n+      && java_lang_String::value(obj) != nullptr) {\n@@ -3807,1 +3813,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -3821,1 +3827,1 @@\n-    if (vmentry != NULL) {\n+    if (vmentry != nullptr) {\n@@ -3827,1 +3833,1 @@\n-    if (vmtarget != NULL) {\n+    if (vmtarget != nullptr) {\n@@ -3833,1 +3839,1 @@\n-      if (clazz != NULL) {\n+      if (clazz != nullptr) {\n@@ -3836,1 +3842,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"null\");\n@@ -3839,1 +3845,1 @@\n-      if (name != NULL) {\n+      if (name != nullptr) {\n@@ -3842,1 +3848,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"null\");\n@@ -3871,4 +3877,4 @@\n-  if (cfs != NULL) {\n-    if (cfs->source() != NULL) {\n-      const char* module_name = (module_entry->name() == NULL) ? UNNAMED_MODULE : module_entry->name()->as_C_string();\n-      if (module_name != NULL) {\n+  if (cfs != nullptr) {\n+    if (cfs->source() != nullptr) {\n+      const char* module_name = (module_entry->name() == nullptr) ? UNNAMED_MODULE : module_entry->name()->as_C_string();\n+      if (module_name != nullptr) {\n@@ -3889,3 +3895,3 @@\n-        NULL;\n-      \/\/ caller can be NULL, for example, during a JVMTI VM_Init hook\n-      if (caller != NULL) {\n+        nullptr;\n+      \/\/ caller can be null, for example, during a JVMTI VM_Init hook\n+      if (caller != nullptr) {\n@@ -3919,1 +3925,1 @@\n-    if (local_interfaces() != NULL && local_interfaces()->length() > 0) {\n+    if (local_interfaces() != nullptr && local_interfaces()->length() > 0) {\n@@ -3984,1 +3990,1 @@\n-  if (subklass() != NULL) {\n+  if (subklass() != nullptr) {\n@@ -3991,1 +3997,1 @@\n-  if (sib != NULL) {\n+  if (sib != nullptr) {\n@@ -4010,1 +4016,1 @@\n-  if (transitive_interfaces() != NULL) {\n+  if (transitive_interfaces() != nullptr) {\n@@ -4019,1 +4025,1 @@\n-  if (methods() != NULL) {\n+  if (methods() != nullptr) {\n@@ -4032,1 +4038,1 @@\n-  if (method_ordering() != NULL) {\n+  if (method_ordering() != nullptr) {\n@@ -4053,1 +4059,1 @@\n-  if (default_methods() != NULL) {\n+  if (default_methods() != nullptr) {\n@@ -4066,1 +4072,1 @@\n-  if (jni_ids() != NULL) {\n+  if (jni_ids() != nullptr) {\n@@ -4071,1 +4077,1 @@\n-  if (constants() != NULL) {\n+  if (constants() != nullptr) {\n@@ -4097,1 +4103,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -4101,1 +4107,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4105,1 +4111,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -4119,1 +4125,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -4141,2 +4147,2 @@\n-  assert(_init_thread == NULL, \"should be cleared before state change\");\n-  _init_state = state;\n+  assert(_init_thread == nullptr, \"should be cleared before state change\");\n+  Atomic::store(&_init_state, state);\n@@ -4174,1 +4180,1 @@\n-  if (previous_versions() == NULL) {\n+  if (previous_versions() == nullptr) {\n@@ -4184,1 +4190,1 @@\n-  assert(loader_data != NULL, \"should never be null\");\n+  assert(loader_data != nullptr, \"should never be null\");\n@@ -4195,1 +4201,1 @@\n-  for (; pv_node != NULL; ) {\n+  for (; pv_node != nullptr; ) {\n@@ -4198,1 +4204,1 @@\n-    assert(pvcp != NULL, \"cp ref was unexpectedly cleared\");\n+    assert(pvcp != nullptr, \"cp ref was unexpectedly cleared\");\n@@ -4210,1 +4216,1 @@\n-      pv_node->link_previous_versions(NULL);   \/\/ point next to NULL\n+      pv_node->link_previous_versions(nullptr);   \/\/ point next to null\n@@ -4221,1 +4227,1 @@\n-      assert(pvcp->pool_holder() != NULL, \"Constant pool with no holder\");\n+      assert(pvcp->pool_holder() != nullptr, \"Constant pool with no holder\");\n@@ -4242,1 +4248,1 @@\n-      _previous_versions != NULL) {\n+      _previous_versions != nullptr) {\n@@ -4256,1 +4262,1 @@\n-             prev_version != NULL;\n+             prev_version != nullptr;\n@@ -4329,1 +4335,1 @@\n-  assert(scratch_class->previous_versions() == NULL, \"shouldn't have a previous version\");\n+  assert(scratch_class->previous_versions() == nullptr, \"shouldn't have a previous version\");\n@@ -4337,1 +4343,1 @@\n-  Method* m = NULL;\n+  Method* m = nullptr;\n@@ -4341,1 +4347,1 @@\n-  if (m == NULL || m->method_idnum() != idnum) {\n+  if (m == nullptr || m->method_idnum() != idnum) {\n@@ -4349,1 +4355,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4357,1 +4363,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4360,1 +4366,1 @@\n-  if (m != NULL && m->orig_method_idnum() == idnum) {\n+  if (m != nullptr && m->orig_method_idnum() == idnum) {\n@@ -4371,1 +4377,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4377,2 +4383,2 @@\n-  if (holder == NULL) {\n-    return NULL; \/\/ The version of klass is gone, no method is found\n+  if (holder == nullptr) {\n+    return nullptr; \/\/ The version of klass is gone, no method is found\n@@ -4401,2 +4407,2 @@\n-  assert(_current != NULL, \"required\");\n-  if (_visit_subclasses && _current->subklass() != NULL) {\n+  assert(_current != nullptr, \"required\");\n+  if (_visit_subclasses && _current->subklass() != nullptr) {\n@@ -4407,1 +4413,1 @@\n-  while (_current->next_sibling() == NULL && _current != _root) {\n+  while (_current->next_sibling() == nullptr && _current != _root) {\n@@ -4412,1 +4418,1 @@\n-    _current = NULL;\n+    _current = nullptr;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":336,"deletions":330,"binary":false,"changes":666,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"oops\/instanceKlassMiscStatus.hpp\"\n+#include \"oops\/instanceKlassFlags.hpp\"\n@@ -85,1 +85,1 @@\n-\/\/ If \"obj\" argument to constructor is NULL, prints static fields, otherwise prints non-static fields.\n+\/\/ If \"obj\" argument to constructor is null, prints static fields, otherwise prints non-static fields.\n@@ -90,1 +90,1 @@\n-   FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}\n+   FieldPrinter(outputStream* st, oop obj = nullptr) : _obj(obj), _st(st) {}\n@@ -226,1 +226,1 @@\n-  \/\/ the source debug extension for this klass, NULL if not specified.\n+  \/\/ the source debug extension for this klass, null if not specified.\n@@ -228,1 +228,1 @@\n-  \/\/ it is stored in the instanceklass as a NULL-terminated UTF-8 string\n+  \/\/ it is stored in the instanceklass as a null-terminated UTF-8 string\n@@ -248,1 +248,1 @@\n-  \/\/ _misc_status right now.\n+  \/\/ _misc_flags right now.\n@@ -251,1 +251,1 @@\n-  ClassState      _init_state;              \/\/ state of class\n+  volatile ClassState _init_state;          \/\/ state of class\n@@ -256,1 +256,1 @@\n-  InstanceKlassMiscStatus _misc_status;\n+  InstanceKlassFlags _misc_flags;\n@@ -258,2 +258,2 @@\n-  Monitor*        _init_monitor;         \/\/ mutual exclusion to _init_state and _init_thread.\n-  Thread*         _init_thread;          \/\/ Pointer to current thread doing initialization (to handle recursive initialization)\n+  Monitor*             _init_monitor;       \/\/ mutual exclusion to _init_state and _init_thread.\n+  JavaThread* volatile _init_thread;        \/\/ Pointer to current thread doing initialization (to handle recursive initialization)\n@@ -263,1 +263,1 @@\n-  jmethodID*      volatile _methods_jmethod_ids;  \/\/ jmethodIDs corresponding to method_idnum, or NULL if none\n+  jmethodID*      volatile _methods_jmethod_ids;  \/\/ jmethodIDs corresponding to method_idnum, or null if none\n@@ -322,1 +322,1 @@\n-  \/\/     NULL: no implementor.\n+  \/\/     null: no implementor.\n@@ -343,3 +343,3 @@\n-  bool is_shared_boot_class() const { return _misc_status.is_shared_boot_class(); }\n-  bool is_shared_platform_class() const { return _misc_status.is_shared_platform_class(); }\n-  bool is_shared_app_class() const {  return _misc_status.is_shared_app_class(); }\n+  bool is_shared_boot_class() const { return _misc_flags.is_shared_boot_class(); }\n+  bool is_shared_platform_class() const { return _misc_flags.is_shared_platform_class(); }\n+  bool is_shared_app_class() const {  return _misc_flags.is_shared_app_class(); }\n@@ -347,1 +347,1 @@\n-  bool is_shared_unregistered_class() const { return _misc_status.is_shared_unregistered_class(); }\n+  bool is_shared_unregistered_class() const { return _misc_flags.is_shared_unregistered_class(); }\n@@ -352,1 +352,1 @@\n-  bool shared_loading_failed() const { return _misc_status.shared_loading_failed(); }\n+  bool shared_loading_failed() const { return _misc_flags.shared_loading_failed(); }\n@@ -354,1 +354,1 @@\n-  void set_shared_loading_failed() { _misc_status.set_shared_loading_failed(true); }\n+  void set_shared_loading_failed() { _misc_flags.set_shared_loading_failed(true); }\n@@ -357,2 +357,2 @@\n-  void set_shared_class_loader_type(s2 loader_type) { _misc_status.set_shared_class_loader_type(loader_type); }\n-  void assign_class_loader_type() { _misc_status.assign_class_loader_type(_class_loader_data); }\n+  void set_shared_class_loader_type(s2 loader_type) { _misc_flags.set_shared_class_loader_type(loader_type); }\n+  void assign_class_loader_type() { _misc_flags.assign_class_loader_type(_class_loader_data); }\n@@ -361,2 +361,2 @@\n-  bool has_nonstatic_fields() const        { return _misc_status.has_nonstatic_fields(); }\n-  void set_has_nonstatic_fields(bool b)    { _misc_status.set_has_nonstatic_fields(b); }\n+  bool has_nonstatic_fields() const        { return _misc_flags.has_nonstatic_fields(); }\n+  void set_has_nonstatic_fields(bool b)    { _misc_flags.set_has_nonstatic_fields(b); }\n@@ -364,2 +364,2 @@\n-  bool has_localvariable_table() const     { return _misc_status.has_localvariable_table(); }\n-  void set_has_localvariable_table(bool b) { _misc_status.set_has_localvariable_table(b); }\n+  bool has_localvariable_table() const     { return _misc_flags.has_localvariable_table(); }\n+  void set_has_localvariable_table(bool b) { _misc_flags.set_has_localvariable_table(b); }\n@@ -367,2 +367,2 @@\n-  bool has_inline_type_fields() const { return _misc_status.has_inline_type_fields(); }\n-  void set_has_inline_type_fields()   { _misc_status.set_has_inline_type_fields(true); }\n+  bool has_inline_type_fields() const { return _misc_flags.has_inline_type_fields(); }\n+  void set_has_inline_type_fields()   { _misc_flags.set_has_inline_type_fields(true); }\n@@ -370,2 +370,2 @@\n-  bool is_empty_inline_type() const   { return _misc_status.is_empty_inline_type(); }\n-  void set_is_empty_inline_type()     { _misc_status.set_is_empty_inline_type(true); }\n+  bool is_empty_inline_type() const   { return _misc_flags.is_empty_inline_type(); }\n+  void set_is_empty_inline_type()     { _misc_flags.set_is_empty_inline_type(true); }\n@@ -378,2 +378,2 @@\n-  bool is_naturally_atomic() const  { return _misc_status.is_naturally_atomic(); }\n-  void set_is_naturally_atomic()    { _misc_status.set_is_naturally_atomic(true); }\n+  bool is_naturally_atomic() const  { return _misc_flags.is_naturally_atomic(); }\n+  void set_is_naturally_atomic()    { _misc_flags.set_is_naturally_atomic(true); }\n@@ -386,2 +386,2 @@\n-  bool is_declared_atomic() const { return _misc_status.is_declared_atomic(); }\n-  void set_is_declared_atomic()   { _misc_status.set_is_declared_atomic(true); }\n+  bool is_declared_atomic() const { return _misc_flags.is_declared_atomic(); }\n+  void set_is_declared_atomic()   { _misc_flags.set_is_declared_atomic(true); }\n@@ -389,2 +389,2 @@\n-  bool carries_value_modifier() const { return _misc_status.carries_value_modifier(); }\n-  void set_carries_value_modifier()   { _misc_status.set_carries_value_modifier(true); }\n+  bool carries_value_modifier() const { return _misc_flags.carries_value_modifier(); }\n+  void set_carries_value_modifier()   { _misc_flags.set_carries_value_modifier(true); }\n@@ -392,2 +392,2 @@\n-  bool carries_identity_modifier() const  { return _misc_status.carries_identity_modifier(); }\n-  void set_carries_identity_modifier()    { _misc_status.set_carries_identity_modifier(true); }\n+  bool carries_identity_modifier() const  { return _misc_flags.carries_identity_modifier(); }\n+  void set_carries_identity_modifier()    { _misc_flags.set_carries_identity_modifier(true); }\n@@ -438,1 +438,1 @@\n-    guarantee(_local_interfaces == NULL || a == NULL, \"Just checking\");\n+    guarantee(_local_interfaces == nullptr || a == nullptr, \"Just checking\");\n@@ -443,1 +443,1 @@\n-    guarantee(_transitive_interfaces == NULL || a == NULL, \"Just checking\");\n+    guarantee(_transitive_interfaces == nullptr || a == nullptr, \"Just checking\");\n@@ -464,1 +464,1 @@\n-    guarantee(_fields == NULL || f == NULL, \"Just checking\");\n+    guarantee(_fields == nullptr || f == nullptr, \"Just checking\");\n@@ -505,1 +505,1 @@\n-    assert(_nest_host != NULL, \"must be\");\n+    assert(_nest_host != nullptr, \"must be\");\n@@ -510,1 +510,1 @@\n-  \/\/ Returns NULL if there was no error.\n+  \/\/ Returns null if there was no error.\n@@ -513,1 +513,1 @@\n-  \/\/ Returns NULL if resolution is not possible from the calling context.\n+  \/\/ Returns null if resolution is not possible from the calling context.\n@@ -539,1 +539,1 @@\n-  bool in_unnamed_package() const   { return (_package_entry == NULL); }\n+  bool in_unnamed_package() const   { return (_package_entry == nullptr); }\n@@ -572,1 +572,1 @@\n-  bool is_init_thread(Thread *thread)      { return thread == _init_thread; }\n+  bool is_init_thread(JavaThread *thread)  { return thread == Atomic::load(&_init_thread); }\n@@ -575,1 +575,1 @@\n-  bool is_rewritten() const                { return _misc_status.rewritten(); }\n+  bool is_rewritten() const                { return _misc_flags.rewritten(); }\n@@ -596,2 +596,2 @@\n-  bool should_verify_class() const         { return _misc_status.should_verify_class(); }\n-  void set_should_verify_class(bool value) { _misc_status.set_should_verify_class(value); }\n+  bool should_verify_class() const         { return _misc_flags.should_verify_class(); }\n+  void set_should_verify_class(bool value) { _misc_flags.set_should_verify_class(value); }\n@@ -604,1 +604,1 @@\n-  static ByteSize misc_status_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_status)); }\n+  static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }\n@@ -647,1 +647,1 @@\n-  \/\/ find a local method (returns NULL if not found)\n+  \/\/ find a local method (returns null if not found)\n@@ -661,1 +661,1 @@\n-  \/\/ find a local method (returns NULL if not found)\n+  \/\/ find a local method (returns null if not found)\n@@ -668,1 +668,1 @@\n-  \/\/ find a local method from given methods array (returns NULL if not found)\n+  \/\/ find a local method from given methods array (returns null if not found)\n@@ -684,1 +684,1 @@\n-  \/\/ lookup operation (returns NULL if not found)\n+  \/\/ lookup operation (returns null if not found)\n@@ -691,1 +691,1 @@\n-  \/\/ (returns NULL if not found)\n+  \/\/ (returns null if not found)\n@@ -695,1 +695,1 @@\n-  \/\/ (returns NULL if not found)\n+  \/\/ (returns null if not found)\n@@ -716,2 +716,2 @@\n-  bool is_contended() const                { return _misc_status.is_contended(); }\n-  void set_is_contended(bool value)        { _misc_status.set_is_contended(value); }\n+  bool is_contended() const                { return _misc_flags.is_contended(); }\n+  void set_is_contended(bool value)        { _misc_flags.set_is_contended(value); }\n@@ -746,2 +746,2 @@\n-  bool has_contended_annotations() const { return _misc_status.has_contended_annotations(); }\n-  void set_has_contended_annotations(bool value)  { _misc_status.set_has_contended_annotations(value); }\n+  bool has_contended_annotations() const { return _misc_flags.has_contended_annotations(); }\n+  void set_has_contended_annotations(bool value)  { _misc_flags.set_has_contended_annotations(value); }\n@@ -770,1 +770,1 @@\n-  InstanceKlass* previous_versions() const { return NULL; }\n+  InstanceKlass* previous_versions() const { return nullptr; }\n@@ -774,1 +774,1 @@\n-    for (InstanceKlass* ik = this; ik != NULL; ik = ik->previous_versions()) {\n+    for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n@@ -779,1 +779,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -782,2 +782,2 @@\n-  bool has_been_redefined() const { return _misc_status.has_been_redefined(); }\n-  void set_has_been_redefined() { _misc_status.set_has_been_redefined(true); }\n+  bool has_been_redefined() const { return _misc_flags.has_been_redefined(); }\n+  void set_has_been_redefined() { _misc_flags.set_has_been_redefined(true); }\n@@ -785,2 +785,2 @@\n-  bool is_scratch_class() const { return _misc_status.is_scratch_class(); }\n-  void set_is_scratch_class() { _misc_status.set_is_scratch_class(true); }\n+  bool is_scratch_class() const { return _misc_flags.is_scratch_class(); }\n+  void set_is_scratch_class() { _misc_flags.set_is_scratch_class(true); }\n@@ -800,1 +800,1 @@\n-    _previous_versions = NULL;\n+    _previous_versions = nullptr;\n@@ -836,1 +836,1 @@\n-    assert(data == NULL, \"unexpected call with JVMTI disabled\");\n+    assert(data == nullptr, \"unexpected call with JVMTI disabled\");\n@@ -838,1 +838,1 @@\n-  JvmtiCachedClassFileData * get_cached_class_file() { return (JvmtiCachedClassFileData *)NULL; }\n+  JvmtiCachedClassFileData * get_cached_class_file() { return (JvmtiCachedClassFileData *)nullptr; }\n@@ -842,2 +842,2 @@\n-  bool has_nonstatic_concrete_methods() const { return _misc_status.has_nonstatic_concrete_methods(); }\n-  void set_has_nonstatic_concrete_methods(bool b) { _misc_status.set_has_nonstatic_concrete_methods(b); }\n+  bool has_nonstatic_concrete_methods() const { return _misc_flags.has_nonstatic_concrete_methods(); }\n+  void set_has_nonstatic_concrete_methods(bool b) { _misc_flags.set_has_nonstatic_concrete_methods(b); }\n@@ -845,2 +845,2 @@\n-  bool declares_nonstatic_concrete_methods() const { return _misc_status.declares_nonstatic_concrete_methods(); }\n-  void set_declares_nonstatic_concrete_methods(bool b) { _misc_status.set_declares_nonstatic_concrete_methods(b); }\n+  bool declares_nonstatic_concrete_methods() const { return _misc_flags.declares_nonstatic_concrete_methods(); }\n+  void set_declares_nonstatic_concrete_methods(bool b) { _misc_flags.set_declares_nonstatic_concrete_methods(b); }\n@@ -883,1 +883,1 @@\n-    return (_annotations != NULL) ? _annotations->class_annotations() : NULL;\n+    return (_annotations != nullptr) ? _annotations->class_annotations() : nullptr;\n@@ -886,1 +886,1 @@\n-    return (_annotations != NULL) ? _annotations->fields_annotations() : NULL;\n+    return (_annotations != nullptr) ? _annotations->fields_annotations() : nullptr;\n@@ -889,1 +889,1 @@\n-    return (_annotations != NULL) ? _annotations->class_type_annotations() : NULL;\n+    return (_annotations != nullptr) ? _annotations->class_type_annotations() : nullptr;\n@@ -892,1 +892,1 @@\n-    return (_annotations != NULL) ? _annotations->fields_type_annotations() : NULL;\n+    return (_annotations != nullptr) ? _annotations->fields_type_annotations() : nullptr;\n@@ -992,1 +992,1 @@\n-    assert(k != NULL, \"k should not be null\");\n+    assert(k != nullptr, \"k should not be null\");\n@@ -998,1 +998,1 @@\n-    return (super() == NULL) ? NULL : cast(super());\n+    return (super() == nullptr) ? nullptr : cast(super());\n@@ -1156,4 +1156,5 @@\n-  void set_rewritten()                  { _misc_status.set_rewritten(true); }\n-  void set_init_thread(Thread *thread)  {\n-    assert(thread == nullptr || _init_thread == nullptr, \"Only one thread is allowed to own initialization\");\n-    _init_thread = thread;\n+  void set_rewritten()                  { _misc_flags.set_rewritten(true); }\n+  void set_init_thread(JavaThread *thread)  {\n+    assert((thread == JavaThread::current() && _init_thread == nullptr) ||\n+           (thread == nullptr && _init_thread == JavaThread::current()), \"Only one thread is allowed to own initialization\");\n+    Atomic::store(&_init_thread, thread);\n@@ -1165,1 +1166,1 @@\n-  \/\/ going from NULL to non-NULL.\n+  \/\/ going from null to non-null.\n@@ -1193,1 +1194,1 @@\n-  \/\/ find a local method (returns NULL if not found)\n+  \/\/ find a local method (returns null if not found)\n@@ -1326,1 +1327,1 @@\n-    if (k->inner_classes() != NULL) {\n+    if (k->inner_classes() != nullptr) {\n@@ -1412,1 +1413,1 @@\n-    return (_current == NULL);\n+    return (_current == nullptr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":88,"deletions":87,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -235,1 +235,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -237,1 +237,1 @@\n-    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_OOPS_INSTANCEKLASSMISCSTATUS_HPP\n-#define SHARE_OOPS_INSTANCEKLASSMISCSTATUS_HPP\n+#ifndef SHARE_OOPS_INSTANCEKLASSFLAGS_HPP\n+#define SHARE_OOPS_INSTANCEKLASSFLAGS_HPP\n@@ -30,1 +30,1 @@\n-class InstanceKlassMiscStatus {\n+class InstanceKlassFlags {\n@@ -77,1 +77,1 @@\n-  InstanceKlassMiscStatus() : _flags(0) {}\n+  InstanceKlassFlags() : _flags(0) {}\n@@ -110,1 +110,1 @@\n-#endif \/\/ SHARE_OOPS_INSTANCEKLASSMISCSTATUS_HPP\n+#endif \/\/ SHARE_OOPS_INSTANCEKLASSFLAGS_HPP\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/hotspot\/share\/oops\/instanceKlassMiscStatus.hpp","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  if (_name != NULL) _name->increment_refcount();\n+  if (_name != nullptr) _name->increment_refcount();\n@@ -99,1 +99,1 @@\n-  while (t != NULL) {\n+  while (t != nullptr) {\n@@ -107,1 +107,1 @@\n-  if (_name != NULL) _name->decrement_refcount();\n+  if (_name != nullptr) _name->decrement_refcount();\n@@ -134,1 +134,1 @@\n-    if (s == NULL || s->next_sibling() != NULL) \/\/ Oops; wrong count; give up\n+    if (s == nullptr || s->next_sibling() != nullptr) \/\/ Oops; wrong count; give up\n@@ -162,1 +162,1 @@\n-  assert(s != NULL, \"Throw NPE!\");\n+  assert(s != nullptr, \"Throw NPE!\");\n@@ -179,1 +179,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -191,1 +191,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -232,1 +232,1 @@\n-  if (super() == NULL)\n+  if (super() == nullptr)\n@@ -241,2 +241,2 @@\n-  if (k == NULL) {\n-    set_super(NULL);\n+  if (k == nullptr) {\n+    set_super(nullptr);\n@@ -246,1 +246,1 @@\n-    assert(super() == NULL || super() == vmClasses::Object_klass(),\n+    assert(super() == nullptr || super() == vmClasses::Object_klass(),\n@@ -277,1 +277,1 @@\n-        assert(primary_super_of_depth(j1) == NULL, \"super list padding\");\n+        assert(primary_super_of_depth(j1) == nullptr, \"super list padding\");\n@@ -279,1 +279,1 @@\n-      while (t != NULL) {\n+      while (t != nullptr) {\n@@ -289,1 +289,1 @@\n-  if (secondary_supers() == NULL) {\n+  if (secondary_supers() == nullptr) {\n@@ -296,1 +296,1 @@\n-    for (p = super(); !(p == NULL || p->can_be_primary_super()); p = p->super()) {\n+    for (p = super(); !(p == nullptr || p->can_be_primary_super()); p = p->super()) {\n@@ -304,1 +304,1 @@\n-    if (secondaries == NULL) {\n+    if (secondaries == nullptr) {\n@@ -311,1 +311,1 @@\n-    for (p = super(); !(p == NULL || p->can_be_primary_super()); p = p->super()) {\n+    for (p = super(); !(p == nullptr || p->can_be_primary_super()); p = p->super()) {\n@@ -343,1 +343,1 @@\n-      \/\/ We must not copy any NULL placeholders left over from bootstrap.\n+      \/\/ We must not copy any null placeholders left over from bootstrap.\n@@ -345,1 +345,1 @@\n-      assert(s2->at(j) != NULL, \"correct bootstrapping order\");\n+      assert(s2->at(j) != nullptr, \"correct bootstrapping order\");\n@@ -356,1 +356,1 @@\n-  assert(transitive_interfaces == NULL, \"sanity\");\n+  assert(transitive_interfaces == nullptr, \"sanity\");\n@@ -358,1 +358,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -364,2 +364,2 @@\n-  assert(super() == NULL || super()->is_instance_klass(), \"must be instance klass\");\n-  return _super == NULL ? NULL : InstanceKlass::cast(_super);\n+  assert(super() == nullptr || super()->is_instance_klass(), \"must be instance klass\");\n+  return _super == nullptr ? nullptr : InstanceKlass::cast(_super);\n@@ -375,1 +375,1 @@\n-       chain != NULL;\n+       chain != nullptr;\n@@ -389,1 +389,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -396,1 +396,1 @@\n-       chain != NULL;\n+       chain != nullptr;\n@@ -409,1 +409,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -432,1 +432,1 @@\n-  if (super == NULL) return;        \/\/ special case: class Object\n+  if (super == nullptr) return;     \/\/ special case: class Object\n@@ -434,1 +434,1 @@\n-          && (super->superklass() == NULL || !is_interface())),\n+          && (super->superklass() == nullptr || !is_interface())),\n@@ -442,1 +442,1 @@\n-    if (prev_first_subklass != NULL) {\n+    if (prev_first_subklass != nullptr) {\n@@ -461,1 +461,1 @@\n-    if (subklass == NULL || subklass->is_loader_alive()) {\n+    if (subklass == nullptr || subklass->is_loader_alive()) {\n@@ -486,1 +486,1 @@\n-    if (sub != NULL) {\n+    if (sub != nullptr) {\n@@ -493,1 +493,1 @@\n-    if (sibling != NULL) {\n+    if (sibling != nullptr) {\n@@ -504,1 +504,1 @@\n-      while ((ik = ik->previous_versions()) != NULL) {\n+      while ((ik = ik->previous_versions()) != nullptr) {\n@@ -526,1 +526,1 @@\n-    \/\/ to follow these pointers anyway, as they will be set to NULL in\n+    \/\/ to follow these pointers anyway, as they will be set to null in\n@@ -549,3 +549,3 @@\n-  set_subklass(NULL);\n-  set_next_sibling(NULL);\n-  set_next_link(NULL);\n+  set_subklass(nullptr);\n+  set_next_sibling(nullptr);\n+  set_next_link(nullptr);\n@@ -554,1 +554,1 @@\n-  set_class_loader_data(NULL);\n+  set_class_loader_data(nullptr);\n@@ -580,1 +580,1 @@\n-  if (class_loader_data() == NULL) {\n+  if (class_loader_data() == nullptr) {\n@@ -589,1 +589,1 @@\n-  ModuleEntry* module_entry = NULL;\n+  ModuleEntry* module_entry = nullptr;\n@@ -602,1 +602,1 @@\n-  Handle module_handle(THREAD, ((module_entry != NULL) ? module_entry->module() : (oop)NULL));\n+  Handle module_handle(THREAD, ((module_entry != nullptr) ? module_entry->module() : (oop)nullptr));\n@@ -624,1 +624,1 @@\n-  if (java_mirror() == NULL) {\n+  if (java_mirror() == nullptr) {\n@@ -646,3 +646,3 @@\n-void Klass::set_archived_java_mirror(oop m) {\n-  assert(DumpSharedSpaces, \"called only during runtime\");\n-  _archived_mirror_index = HeapShared::append_root(m);\n+void Klass::set_archived_java_mirror(int mirror_index) {\n+  assert(DumpSharedSpaces, \"called only during dumptime\");\n+  _archived_mirror_index = mirror_index;\n@@ -693,1 +693,1 @@\n-  if (name() == NULL)  return \"<unknown>\";\n+  if (name() == nullptr)  return \"<unknown>\";\n@@ -698,1 +698,1 @@\n-  if (name() == NULL)  return \"<unknown>\";\n+  if (name() == nullptr)  return \"<unknown>\";\n@@ -775,1 +775,1 @@\n-  if (super() != NULL) {\n+  if (super() != nullptr) {\n@@ -778,1 +778,1 @@\n-  if (secondary_super_cache() != NULL) {\n+  if (secondary_super_cache() != nullptr) {\n@@ -784,1 +784,1 @@\n-    if (ko != NULL) {\n+    if (ko != nullptr) {\n@@ -789,1 +789,1 @@\n-  if (java_mirror_no_keepalive() != NULL) {\n+  if (java_mirror_no_keepalive() != nullptr) {\n@@ -852,1 +852,1 @@\n-  if (joint_description == NULL) {\n+  if (joint_description == nullptr) {\n@@ -911,1 +911,1 @@\n-  assert(cld != NULL, \"class_loader_data should not be null\");\n+  assert(cld != nullptr, \"class_loader_data should not be null\");\n@@ -925,1 +925,1 @@\n-    if (parent_cld == NULL) {\n+    if (parent_cld == nullptr) {\n@@ -927,1 +927,1 @@\n-      if (cl_name_and_id != NULL) {\n+      if (cl_name_and_id != nullptr) {\n@@ -944,1 +944,1 @@\n-  if (class_description == NULL) {\n+  if (class_description == nullptr) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-  \/\/ First subclass (NULL if none); _subklass->next_sibling() is next one\n+  \/\/ First subclass (null if none); _subklass->next_sibling() is next one\n@@ -152,1 +152,1 @@\n-  \/\/ Sibling link (or NULL); links all subklasses of a klass\n+  \/\/ Sibling link (or null); links all subklasses of a klass\n@@ -226,1 +226,1 @@\n-  virtual InstanceKlass* java_super() const  { return NULL; }\n+  virtual InstanceKlass* java_super() const  { return nullptr; }\n@@ -238,1 +238,1 @@\n-  \/\/ If there is no such element, return either NULL or this.\n+  \/\/ If there is no such element, return either null or this.\n@@ -242,1 +242,1 @@\n-    assert(super == NULL || super->super_depth() == i, \"correct display\");\n+    assert(super == nullptr || super->super_depth() == i, \"correct display\");\n@@ -271,2 +271,2 @@\n-  oop archived_java_mirror() NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  void set_archived_java_mirror(oop m) NOT_CDS_JAVA_HEAP_RETURN;\n+  oop archived_java_mirror() NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  void set_archived_java_mirror(int mirror_index) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -278,1 +278,1 @@\n-  \/\/ Set java mirror OopHandle to NULL for CDS\n+  \/\/ Set java mirror OopHandle to null for CDS\n@@ -553,1 +553,1 @@\n-  \/\/ These will return NULL instead of allocating on the heap:\n+  \/\/ These will return null instead of allocating on the heap:\n@@ -592,1 +592,1 @@\n-    } else if (_java_mirror.ptr_raw() == NULL) {\n+    } else if (_java_mirror.ptr_raw() == nullptr) {\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-  vtable_length = super == NULL ? 0 : super->vtable_length();\n+  vtable_length = super == nullptr ? 0 : super->vtable_length();\n@@ -93,1 +93,1 @@\n-  get_mirandas(&new_mirandas, all_mirandas, super, methods, NULL, local_interfaces,\n+  get_mirandas(&new_mirandas, all_mirandas, super, methods, nullptr, local_interfaces,\n@@ -109,1 +109,1 @@\n-  if (super == NULL && vtable_length != Universe::base_vtable_size()) {\n+  if (super == nullptr && vtable_length != Universe::base_vtable_size()) {\n@@ -134,1 +134,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -215,1 +215,1 @@\n-    if (default_methods != NULL) {\n+    if (default_methods != nullptr) {\n@@ -219,1 +219,1 @@\n-        assert(def_vtable_indices != NULL, \"should be created\");\n+        assert(def_vtable_indices != nullptr, \"should be created\");\n@@ -317,1 +317,1 @@\n-  while (superk != NULL && superk->super() != NULL) {\n+  while (superk != nullptr && superk->super() != nullptr) {\n@@ -346,1 +346,1 @@\n-      superk = (InstanceKlass*)NULL;\n+      superk = (InstanceKlass*)nullptr;\n@@ -350,1 +350,1 @@\n-    superk = superk->super() == NULL ? NULL : InstanceKlass::cast(superk->super());\n+    superk = superk->super() == nullptr ? nullptr : InstanceKlass::cast(superk->super());\n@@ -391,1 +391,1 @@\n-  Array<int>* def_vtable_indices = NULL;\n+  Array<int>* def_vtable_indices = nullptr;\n@@ -403,1 +403,1 @@\n-    assert(def_vtable_indices != NULL, \"def vtable alloc?\");\n+    assert(def_vtable_indices != nullptr, \"def vtable alloc?\");\n@@ -441,1 +441,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -454,2 +454,2 @@\n-  assert(target_klass != NULL, \"impossible\");\n-  if (target_klass == NULL) {\n+  assert(target_klass != nullptr, \"impossible\");\n+  if (target_klass == nullptr) {\n@@ -494,1 +494,1 @@\n-                                                     target_classname)) != NULL))) {\n+                                                     target_classname)) != nullptr))) {\n@@ -507,1 +507,1 @@\n-        if (supers != NULL) {\n+        if (supers != nullptr) {\n@@ -515,1 +515,1 @@\n-          if (def_vtable_indices != NULL) {\n+          if (def_vtable_indices != nullptr) {\n@@ -553,1 +553,1 @@\n-      const char* sig = (m != NULL) ? m->name_and_sig_as_C_string() : \"<NULL>\";\n+      const char* sig = (m != nullptr) ? m->name_and_sig_as_C_string() : \"<null>\";\n@@ -555,1 +555,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -571,1 +571,1 @@\n-    if (target_method() != NULL && super_klass != NULL) {\n+    if (target_method() != nullptr && super_klass != nullptr) {\n@@ -592,1 +592,1 @@\n-          if (failed_type_symbol != NULL) {\n+          if (failed_type_symbol != nullptr) {\n@@ -618,1 +618,1 @@\n-  GrowableArray<InstanceKlass*>* supers = new GrowableArray<InstanceKlass*>(_length, _length, NULL);\n+  GrowableArray<InstanceKlass*>* supers = new GrowableArray<InstanceKlass*>(_length, _length, nullptr);\n@@ -663,1 +663,1 @@\n-  if (target_method->method_holder() != NULL &&\n+  if (target_method->method_holder() != nullptr &&\n@@ -672,1 +672,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -687,3 +687,3 @@\n-  Method* super_method = NULL;\n-  InstanceKlass *holder = NULL;\n-  Method* recheck_method =  NULL;\n+  Method* super_method = nullptr;\n+  InstanceKlass *holder = nullptr;\n+  Method* recheck_method =  nullptr;\n@@ -691,1 +691,1 @@\n-  while (k != NULL) {\n+  while (k != nullptr) {\n@@ -694,1 +694,1 @@\n-    if (super_method == NULL) {\n+    if (super_method == nullptr) {\n@@ -746,1 +746,1 @@\n-    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != NULL) {\n+    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n@@ -852,1 +852,1 @@\n-                                       Klass::PrivateLookupMode::skip) != NULL)\n+                                       Klass::PrivateLookupMode::skip) != nullptr)\n@@ -858,2 +858,2 @@\n-  if ((default_methods != NULL) &&\n-    (InstanceKlass::find_method(default_methods, name, signature) != NULL))\n+  if ((default_methods != nullptr) &&\n+    (InstanceKlass::find_method(default_methods, name, signature) != nullptr))\n@@ -869,1 +869,1 @@\n-  for (const Klass* cursuper = super; cursuper != NULL; cursuper = cursuper->super())\n+  for (const Klass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super())\n@@ -876,1 +876,1 @@\n-     if (found_mth != NULL && (!is_interface ||\n+     if (found_mth != nullptr && (!is_interface ||\n@@ -918,1 +918,1 @@\n-        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == NULL) {\n+        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n@@ -921,1 +921,1 @@\n-        if (all_mirandas != NULL) {\n+        if (all_mirandas != nullptr) {\n@@ -965,1 +965,1 @@\n-  get_mirandas(&mirandas, NULL, ik()->super(), ik()->methods(),\n+  get_mirandas(&mirandas, nullptr, ik()->super(), ik()->methods(),\n@@ -973,1 +973,1 @@\n-      if (meth != NULL) {\n+      if (meth != nullptr) {\n@@ -1000,1 +1000,1 @@\n-  if (default_methods != NULL) {\n+  if (default_methods != nullptr) {\n@@ -1022,1 +1022,1 @@\n-    if (old_method == NULL || !old_method->is_old()) {\n+    if (old_method == nullptr || !old_method->is_old()) {\n@@ -1055,1 +1055,1 @@\n-    if (m != NULL &&\n+    if (m != nullptr &&\n@@ -1070,1 +1070,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1092,1 +1092,1 @@\n-  if (m == NULL) return;\n+  if (m == nullptr) return;\n@@ -1115,1 +1115,1 @@\n-    if (offset_entry  != NULL && offset_entry->interface_klass() != NULL) { \/\/ Check that itable is initialized\n+    if (offset_entry  != nullptr && offset_entry->interface_klass() != nullptr) { \/\/ Check that itable is initialized\n@@ -1164,1 +1164,1 @@\n-      assert(interf != NULL && ioe->offset() != 0, \"bad offset entry in itable\");\n+      assert(interf != nullptr && ioe->offset() != 0, \"bad offset entry in itable\");\n@@ -1171,1 +1171,1 @@\n-  guarantee(ioe->interface_klass() == NULL && ioe->offset() == 0, \"terminator entry missing\");\n+  guarantee(ioe->interface_klass() == nullptr && ioe->offset() == 0, \"terminator entry missing\");\n@@ -1182,1 +1182,1 @@\n-    if (target != NULL && interface_method != NULL) {\n+    if (target != nullptr && interface_method != nullptr) {\n@@ -1197,1 +1197,1 @@\n-        if (failed_type_symbol != NULL) {\n+        if (failed_type_symbol != nullptr) {\n@@ -1226,1 +1226,1 @@\n-    new GrowableArray<Method*>(_size_method_table, _size_method_table, NULL);\n+    new GrowableArray<Method*>(_size_method_table, _size_method_table, nullptr);\n@@ -1263,1 +1263,1 @@\n-        assert(m != NULL, \"methods can never be null\");\n+        assert(m != nullptr, \"methods can never be null\");\n@@ -1325,1 +1325,1 @@\n-    Method* target = NULL;\n+    Method* target = nullptr;\n@@ -1336,2 +1336,2 @@\n-    if (target == NULL || !target->is_public() || target->is_abstract() || target->is_overpass()) {\n-      assert(target == NULL || !target->is_overpass() || target->is_public(),\n+    if (target == nullptr || !target->is_public() || target->is_abstract() || target->is_overpass()) {\n+      assert(target == nullptr || !target->is_overpass() || target->is_public(),\n@@ -1340,1 +1340,1 @@\n-      if (!(target == NULL) && !target->is_public()) {\n+      if (!(target == nullptr) && !target->is_public()) {\n@@ -1352,1 +1352,1 @@\n-      if (supers != NULL) {\n+      if (supers != nullptr) {\n@@ -1359,1 +1359,1 @@\n-        if (target != NULL) {\n+        if (target != nullptr) {\n@@ -1383,1 +1383,1 @@\n-    if (old_method == NULL || !old_method->is_old()) {\n+    if (old_method == nullptr || !old_method->is_old()) {\n@@ -1406,1 +1406,1 @@\n-    if (m != NULL &&\n+    if (m != nullptr &&\n@@ -1423,1 +1423,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1586,1 +1586,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -1618,1 +1618,1 @@\n-    assert(method() != NULL, \"must have set method\");\n+    assert(method() != nullptr, \"must have set method\");\n@@ -1620,1 +1620,1 @@\n-  if (method() != NULL) {\n+  if (method() != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  void initialize_vtable(GrowableArray<InstanceKlass*>* supers = NULL);\n+  void initialize_vtable(GrowableArray<InstanceKlass*>* supers = nullptr);\n@@ -193,2 +193,2 @@\n-  void set(Method* method)  { assert(method != NULL, \"use clear\"); _method = method; }\n-  void clear()                { _method = NULL; }\n+  void set(Method* method)  { assert(method != nullptr, \"use clear\"); _method = method; }\n+  void clear()                { _method = nullptr; }\n@@ -204,1 +204,1 @@\n-  assert(table()[i].method() != NULL, \"should not be null\");\n+  assert(table()[i].method() != nullptr, \"should not be null\");\n@@ -249,1 +249,1 @@\n-  void clear()             { _method = NULL; }\n+  void clear()             { _method = nullptr; }\n@@ -304,1 +304,1 @@\n-  void initialize_itable(GrowableArray<Method*>* supers = NULL);\n+  void initialize_itable(GrowableArray<Method*>* supers = nullptr);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/integralConstant.hpp\"\n@@ -33,0 +32,2 @@\n+#include <type_traits>\n+\n@@ -406,1 +407,1 @@\n-struct PrimitiveConversions::Translate<markWord> : public TrueType {\n+struct PrimitiveConversions::Translate<markWord> : public std::true_type {\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-  set_method_data(NULL);\n+  set_method_data(nullptr);\n@@ -116,2 +116,2 @@\n-  set_interpreter_entry(NULL); \/\/ sets i2i entry and from_int\n-  set_adapter_entry(NULL);\n+  set_interpreter_entry(nullptr); \/\/ sets i2i entry and from_int\n+  set_adapter_entry(nullptr);\n@@ -122,1 +122,1 @@\n-    set_signature_handler(NULL);\n+    set_signature_handler(nullptr);\n@@ -133,1 +133,1 @@\n-  set_constMethod(NULL);\n+  set_constMethod(nullptr);\n@@ -135,1 +135,1 @@\n-  set_method_data(NULL);\n+  set_method_data(nullptr);\n@@ -139,1 +139,1 @@\n-  if (code() != NULL) _code = NULL;\n+  if (code() != nullptr) _code = nullptr;\n@@ -152,1 +152,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -157,1 +157,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -162,1 +162,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -167,1 +167,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -172,1 +172,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -178,1 +178,1 @@\n-  assert(adapter() != NULL, \"must have\");\n+  assert(adapter() != nullptr, \"must have\");\n@@ -246,1 +246,1 @@\n-                          ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string());\n+                          ex_klass == nullptr ? \"null\" : ex_klass->external_name(), mh->name()->as_C_string());\n@@ -273,1 +273,1 @@\n-                               ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n+                               ex_klass == nullptr ? \"null\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n@@ -276,1 +276,1 @@\n-      } else if (ex_klass == NULL) {\n+      } else if (ex_klass == nullptr) {\n@@ -280,1 +280,1 @@\n-          log_info(exceptions)(\"NULL exception class is implicitly caught by handler in method \\\"%s\\\" at BCI: %d\",\n+          log_info(exceptions)(\"null exception class is implicitly caught by handler in method \\\"%s\\\" at BCI: %d\",\n@@ -302,1 +302,1 @@\n-        assert(k != NULL, \"klass not loaded\");\n+        assert(k != nullptr, \"klass not loaded\");\n@@ -307,1 +307,1 @@\n-                                 ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n+                                 ex_klass == nullptr ? \"null\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n@@ -382,1 +382,1 @@\n-  if (is_native() && bcp == NULL) {\n+  if (is_native() && bcp == nullptr) {\n@@ -477,1 +477,1 @@\n-    if (trial_name == NULL) {\n+    if (trial_name == nullptr) {\n@@ -481,1 +481,1 @@\n-    if (method == NULL) {\n+    if (method == nullptr) {\n@@ -493,1 +493,1 @@\n-  return NULL; \/\/ not found\n+  return nullptr; \/\/ not found\n@@ -498,1 +498,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -509,1 +509,1 @@\n-    if (method == NULL) {\n+    if (method == nullptr) {\n@@ -519,1 +519,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -537,1 +537,1 @@\n-  if (is_accessor() || is_empty_method() || (code() != NULL)) {\n+  if (is_accessor() || is_empty_method() || (code() != nullptr)) {\n@@ -542,1 +542,1 @@\n-  else if ((method_counters() != NULL &&\n+  else if ((method_counters() != nullptr &&\n@@ -544,1 +544,1 @@\n-           (method_data() != NULL &&\n+           (method_data() != nullptr &&\n@@ -581,1 +581,1 @@\n-  if (method_data() != NULL) {\n+  if (method_data() != nullptr) {\n@@ -627,1 +627,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -646,1 +646,1 @@\n-  if (counters == NULL) {\n+  if (counters == nullptr) {\n@@ -649,1 +649,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -820,1 +820,1 @@\n-  if (method_holder() != NULL &&\n+  if (method_holder() != nullptr &&\n@@ -1011,1 +1011,1 @@\n-    return SystemDictionary::find_instance_klass(thread, klass_name, loader, prot) != NULL;\n+    return SystemDictionary::find_instance_klass(thread, klass_name, loader, prot) != nullptr;\n@@ -1031,1 +1031,1 @@\n-  assert(function != NULL, \"use clear_native_function to unregister natives\");\n+  assert(function != nullptr, \"use clear_native_function to unregister natives\");\n@@ -1040,1 +1040,1 @@\n-      function != NULL) {\n+      function != nullptr) {\n@@ -1055,1 +1055,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -1065,1 +1065,1 @@\n-  return (func != NULL && func != SharedRuntime::native_method_throw_unsatisfied_link_error_entry());\n+  return (func != nullptr && func != SharedRuntime::native_method_throw_unsatisfied_link_error_entry());\n@@ -1085,1 +1085,1 @@\n-  assert(reason != NULL, \"must provide a reason\");\n+  assert(reason != nullptr, \"must provide a reason\");\n@@ -1099,1 +1099,1 @@\n-    if (reason != NULL) {\n+    if (reason != nullptr) {\n@@ -1104,1 +1104,1 @@\n-  if ((TraceDeoptimization || LogCompilation) && (xtty != NULL)) {\n+  if ((TraceDeoptimization || LogCompilation) && (xtty != nullptr)) {\n@@ -1108,1 +1108,1 @@\n-    if (reason != NULL) {\n+    if (reason != nullptr) {\n@@ -1189,1 +1189,1 @@\n-  \/\/ this may be NULL if c2i adapters have not been made yet\n+  \/\/ this may be null if c2i adapters have not been made yet\n@@ -1191,4 +1191,4 @@\n-  if (adapter() == NULL) {\n-    _from_compiled_entry    = NULL;\n-    _from_compiled_inline_entry = NULL;\n-    _from_compiled_inline_ro_entry = NULL;\n+  if (adapter() == nullptr) {\n+    _from_compiled_entry    = nullptr;\n+    _from_compiled_inline_entry = nullptr;\n+    _from_compiled_inline_ro_entry = nullptr;\n@@ -1203,1 +1203,1 @@\n-  _code = NULL;\n+  _code = nullptr;\n@@ -1207,1 +1207,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n@@ -1218,1 +1218,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n@@ -1226,7 +1226,7 @@\n-  _code = NULL;\n-  _adapter = NULL;\n-  _i2i_entry = NULL;\n-  _from_compiled_entry = NULL;\n-  _from_compiled_inline_entry = NULL;\n-  _from_compiled_inline_ro_entry = NULL;\n-  _from_interpreted_entry = NULL;\n+  _code = nullptr;\n+  _adapter = nullptr;\n+  _i2i_entry = nullptr;\n+  _from_compiled_entry = nullptr;\n+  _from_compiled_inline_entry = nullptr;\n+  _from_compiled_inline_ro_entry = nullptr;\n+  _from_interpreted_entry = nullptr;\n@@ -1235,2 +1235,2 @@\n-    *native_function_addr() = NULL;\n-    set_signature_handler(NULL);\n+    *native_function_addr() = nullptr;\n+    set_signature_handler(nullptr);\n@@ -1240,1 +1240,1 @@\n-  set_method_data(NULL);\n+  set_method_data(nullptr);\n@@ -1250,1 +1250,1 @@\n-  if (adapter() != NULL) {\n+  if (adapter() != nullptr) {\n@@ -1253,1 +1253,1 @@\n-  assert( _code == NULL, \"nothing compiled yet\" );\n+  assert( _code == nullptr, \"nothing compiled yet\" );\n@@ -1258,1 +1258,1 @@\n-  assert(adapter() == NULL, \"init'd to NULL\");\n+  assert(adapter() == nullptr, \"init'd to null\");\n@@ -1260,1 +1260,1 @@\n-  assert(entry != NULL, \"interpreter entry must be non-null\");\n+  assert(entry != nullptr, \"interpreter entry must be non-null\");\n@@ -1288,3 +1288,3 @@\n-    _from_interpreted_entry = NULL;\n-    _from_compiled_entry = NULL;\n-    _i2i_entry = NULL;\n+    _from_interpreted_entry = nullptr;\n+    _from_compiled_entry = nullptr;\n+    _i2i_entry = nullptr;\n@@ -1299,1 +1299,1 @@\n-  if (adapter == NULL ) {\n+  if (adapter == nullptr ) {\n@@ -1326,1 +1326,1 @@\n-  assert(_from_compiled_entry != NULL, \"must be set\");\n+  assert(_from_compiled_entry != nullptr, \"must be set\");\n@@ -1332,1 +1332,1 @@\n-  assert(_from_compiled_inline_entry != NULL, \"must be set\");\n+  assert(_from_compiled_inline_entry != nullptr, \"must be set\");\n@@ -1338,1 +1338,1 @@\n-  assert(_from_compiled_inline_ro_entry != NULL, \"must be set\");\n+  assert(_from_compiled_inline_ro_entry != nullptr, \"must be set\");\n@@ -1348,1 +1348,1 @@\n-  return code == NULL || (code->method() == NULL) || (code->method() == (Method*)this && !code->is_osr_method());\n+  return code == nullptr || (code->method() == nullptr) || (code->method() == (Method*)this && !code->is_osr_method());\n@@ -1357,1 +1357,1 @@\n-  guarantee(mh->adapter() != NULL, \"Adapter blob must already exist!\");\n+  guarantee(mh->adapter() != nullptr, \"Adapter blob must already exist!\");\n@@ -1378,1 +1378,1 @@\n-    assert(mh->_from_interpreted_entry == NULL, \"initialized incorrectly\"); \/\/ see link_method\n+    assert(mh->_from_interpreted_entry == nullptr, \"initialized incorrectly\"); \/\/ see link_method\n@@ -1406,1 +1406,1 @@\n-    if (ik->lookup_method(name(), signature()) == NULL) {\n+    if (ik->lookup_method(name(), signature()) == nullptr) {\n@@ -1563,1 +1563,1 @@\n-  if (klass != NULL && klass->class_loader() != NULL) {\n+  if (klass != nullptr && klass->class_loader() != nullptr) {\n@@ -1568,1 +1568,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1681,1 +1681,1 @@\n-  \/\/ if loader is not the default loader (i.e., != NULL), we can't know the intrinsics\n+  \/\/ if loader is not the default loader (i.e., non-null), we can't know the intrinsics\n@@ -1686,1 +1686,1 @@\n-  if ((ik->class_loader() != NULL) && !SystemDictionary::is_platform_class_loader(ik->class_loader())) {\n+  if ((ik->class_loader() != nullptr) && !SystemDictionary::is_platform_class_loader(ik->class_loader())) {\n@@ -1780,1 +1780,1 @@\n-      if( klass == NULL) { sig_is_loaded = false; }\n+      if( klass == nullptr) { sig_is_loaded = false; }\n@@ -1811,1 +1811,1 @@\n-    if (func == NULL) {\n+    if (func == nullptr) {\n@@ -1912,1 +1912,1 @@\n-  for (; bp != NULL; bp = bp->next()) {\n+  for (; bp != nullptr; bp = bp->next()) {\n@@ -1927,1 +1927,1 @@\n-  for (; bp != NULL; bp = bp->next()) {\n+  for (; bp != nullptr; bp = bp->next()) {\n@@ -1946,1 +1946,1 @@\n-  BreakpointInfo* prev_bp = NULL;\n+  BreakpointInfo* prev_bp = nullptr;\n@@ -1948,1 +1948,1 @@\n-  for (BreakpointInfo* bp = ik->breakpoints(); bp != NULL; bp = next_bp) {\n+  for (BreakpointInfo* bp = ik->breakpoints(); bp != nullptr; bp = next_bp) {\n@@ -1955,1 +1955,1 @@\n-      if (prev_bp != NULL)\n+      if (prev_bp != nullptr)\n@@ -1994,2 +1994,2 @@\n-  if (((mcs != NULL) ? mcs->invocation_counter()->carry() : false) ||\n-      ((mdo != NULL) ? mdo->invocation_counter()->carry() : false)) {\n+  if (((mcs != nullptr) ? mcs->invocation_counter()->carry() : false) ||\n+      ((mdo != nullptr) ? mdo->invocation_counter()->carry() : false)) {\n@@ -1998,2 +1998,2 @@\n-    return ((mcs != NULL) ? mcs->invocation_counter()->count() : 0) +\n-           ((mdo != NULL) ? mdo->invocation_counter()->count() : 0);\n+    return ((mcs != nullptr) ? mcs->invocation_counter()->count() : 0) +\n+           ((mdo != nullptr) ? mdo->invocation_counter()->count() : 0);\n@@ -2006,2 +2006,2 @@\n-  if (((mcs != NULL) ? mcs->backedge_counter()->carry() : false) ||\n-      ((mdo != NULL) ? mdo->backedge_counter()->carry() : false)) {\n+  if (((mcs != nullptr) ? mcs->backedge_counter()->carry() : false) ||\n+      ((mdo != nullptr) ? mdo->backedge_counter()->carry() : false)) {\n@@ -2010,2 +2010,2 @@\n-    return ((mcs != NULL) ? mcs->backedge_counter()->count() : 0) +\n-           ((mdo != NULL) ? mdo->backedge_counter()->count() : 0);\n+    return ((mcs != nullptr) ? mcs->backedge_counter()->count() : 0) +\n+           ((mdo != nullptr) ? mdo->backedge_counter()->count() : 0);\n@@ -2017,1 +2017,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -2026,1 +2026,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -2035,1 +2035,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -2042,1 +2042,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -2056,1 +2056,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -2116,1 +2116,1 @@\n-    if (_next == NULL) {\n+    if (_next == nullptr) {\n@@ -2138,1 +2138,1 @@\n-    for (JNIMethodBlockNode* b = _last_free; b != NULL; b = b->_next) {\n+    for (JNIMethodBlockNode* b = _last_free; b != nullptr; b = b->_next) {\n@@ -2160,1 +2160,1 @@\n-      if (b->_next == NULL) {\n+      if (b->_next == nullptr) {\n@@ -2165,1 +2165,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2169,2 +2169,2 @@\n-    if (m == NULL) return false;\n-    for (JNIMethodBlockNode* b = &_head; b != NULL; b = b->_next) {\n+    if (m == nullptr) return false;\n+    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n@@ -2200,1 +2200,1 @@\n-    for (JNIMethodBlockNode* b = &_head; b != NULL; b = b->_next) {\n+    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n@@ -2202,1 +2202,1 @@\n-        b->_methods[i] = NULL;\n+        b->_methods[i] = nullptr;\n@@ -2210,1 +2210,1 @@\n-    for (JNIMethodBlockNode* b = &_head; b != NULL; b = b->_next) {\n+    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n@@ -2223,1 +2223,1 @@\n-JNIMethodBlockNode::JNIMethodBlockNode(int num_methods) : _top(0), _next(NULL) {\n+JNIMethodBlockNode::JNIMethodBlockNode(int num_methods) : _top(0), _next(nullptr) {\n@@ -2236,1 +2236,1 @@\n-  if (cld->jmethod_ids() == NULL) {\n+  if (cld->jmethod_ids() == nullptr) {\n@@ -2249,1 +2249,1 @@\n-  if (cld->jmethod_ids() == NULL) {\n+  if (cld->jmethod_ids() == nullptr) {\n@@ -2265,1 +2265,1 @@\n-  assert(cld->jmethod_ids() != NULL, \"should have method handles\");\n+  assert(cld->jmethod_ids() != nullptr, \"should have method handles\");\n@@ -2274,1 +2274,1 @@\n-           new_method->method_holder()->class_loader() == NULL, \/\/ allow Unsafe substitution\n+           new_method->method_holder()->class_loader() == nullptr, \/\/ allow Unsafe substitution\n@@ -2282,1 +2282,1 @@\n-  assert(m != NULL, \"should be called with non-null method\");\n+  assert(m != nullptr, \"should be called with non-null method\");\n@@ -2285,1 +2285,1 @@\n-  if (cld->jmethod_ids() == NULL) return false;\n+  if (cld->jmethod_ids() == nullptr) return false;\n@@ -2290,1 +2290,1 @@\n-  if (mid == NULL) return NULL;\n+  if (mid == nullptr) return nullptr;\n@@ -2292,2 +2292,2 @@\n-  if (o == NULL || o == JNIMethodBlock::_free_method) {\n-    return NULL;\n+  if (o == nullptr || o == JNIMethodBlock::_free_method) {\n+    return nullptr;\n@@ -2298,1 +2298,1 @@\n-  \/\/ unloaded, we need to return NULL here too because after a safepoint, its memory\n+  \/\/ unloaded, we need to return null here too because after a safepoint, its memory\n@@ -2300,1 +2300,1 @@\n-  return o->method_holder()->is_loader_alive() ? o : NULL;\n+  return o->method_holder()->is_loader_alive() ? o : nullptr;\n@@ -2335,1 +2335,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -2414,1 +2414,1 @@\n-  if (a == NULL)\n+  if (a == nullptr)\n@@ -2426,1 +2426,1 @@\n-  if (method_data() != NULL) {\n+  if (method_data() != nullptr) {\n@@ -2464,1 +2464,1 @@\n-  if (code() != NULL) {\n+  if (code() != nullptr) {\n@@ -2498,1 +2498,1 @@\n-  if (WizardMode && code() != NULL) st->print(\" ((nmethod*)%p)\", code());\n+  if (WizardMode && code() != nullptr) st->print(\" ((nmethod*)%p)\", code());\n@@ -2507,1 +2507,1 @@\n-  guarantee(md == NULL ||\n+  guarantee(md == nullptr ||\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":128,"deletions":128,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-  \/\/ field can come and go.  It can transition from NULL to not-null at any\n+  \/\/ field can come and go.  It can transition from null to not-null at any\n@@ -123,1 +123,1 @@\n-  \/\/ NULL only at safepoints (because of a de-opt).\n+  \/\/ null only at safepoints (because of a de-opt).\n@@ -176,1 +176,1 @@\n-  Symbol* generic_signature() const              { int idx = generic_signature_index(); return ((idx != 0) ? constants()->symbol_at(idx) : (Symbol*)NULL); }\n+  Symbol* generic_signature() const              { int idx = generic_signature_index(); return ((idx != 0) ? constants()->symbol_at(idx) : nullptr); }\n@@ -244,1 +244,1 @@\n-    if (mcs == NULL) {\n+    if (mcs == nullptr) {\n@@ -252,1 +252,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -258,1 +258,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -265,1 +265,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -308,1 +308,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -316,1 +316,1 @@\n-    if (mcs == NULL) {\n+    if (mcs == nullptr) {\n@@ -351,1 +351,1 @@\n-  \/\/ exception of klass ex_klass thrown at throw_bci. A value of NULL\n+  \/\/ exception of klass ex_klass thrown at throw_bci. A value of null\n@@ -382,1 +382,1 @@\n-    _method_counters = NULL;\n+    _method_counters = nullptr;\n@@ -389,1 +389,1 @@\n-    return mcs == NULL ? 0 : mcs->prev_event_count();\n+    return mcs == nullptr ? 0 : mcs->prev_event_count();\n@@ -393,1 +393,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -399,1 +399,1 @@\n-    return mcs == NULL ? 0 : mcs->prev_time();\n+    return mcs == nullptr ? 0 : mcs->prev_time();\n@@ -403,1 +403,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -409,1 +409,1 @@\n-    return mcs == NULL ? 0 : mcs->rate();\n+    return mcs == nullptr ? 0 : mcs->rate();\n@@ -413,1 +413,1 @@\n-    if (mcs != NULL) {\n+    if (mcs != nullptr) {\n@@ -528,1 +528,1 @@\n-  \/\/ Must specify a real function (not NULL).\n+  \/\/ Must specify a real function (not null).\n@@ -799,1 +799,1 @@\n-  \/\/ refers to NULL (as is the case for any weak reference).\n+  \/\/ refers to null (as is the case for any weak reference).\n@@ -810,1 +810,1 @@\n-  \/\/ result guaranteed not to be NULL.\n+  \/\/ result guaranteed not to be null.\n@@ -812,1 +812,1 @@\n-    assert(mid != NULL, \"JNI method id should not be null\");\n+    assert(mid != nullptr, \"JNI method id should not be null\");\n@@ -817,1 +817,1 @@\n-  \/\/ should provide a valid jmethodID, but might not. NULL is returned\n+  \/\/ should provide a valid jmethodID, but might not. Null is returned\n@@ -831,1 +831,1 @@\n-  \/\/ Lookup the jmethodID for this method.  Return NULL if not found.\n+  \/\/ Lookup the jmethodID for this method.  Return null if not found.\n@@ -974,1 +974,1 @@\n-   return method_holder()->lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != NULL;\n+   return method_holder()->lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != nullptr;\n@@ -1009,1 +1009,1 @@\n-    if (_method_counters == NULL) {\n+    if (_method_counters == nullptr) {\n@@ -1048,1 +1048,1 @@\n-  static void sort_methods(Array<Method*>* methods, bool set_idnums = true, method_comparator_func func = NULL);\n+  static void sort_methods(Array<Method*>* methods, bool set_idnums = true, method_comparator_func func = nullptr);\n@@ -1059,1 +1059,1 @@\n-    assert(new_method != NULL, \"method_with_idnum() should not be NULL\");\n+    assert(new_method != nullptr, \"method_with_idnum() should not be null\");\n@@ -1194,1 +1194,1 @@\n-      _table = NULL;\n+      _table = nullptr;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-inline bool Method::has_compiled_code() const { return code() != NULL; }\n+inline bool Method::has_compiled_code() const { return code() != nullptr; }\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  _data = NULL;\n+  _data = nullptr;\n@@ -121,1 +121,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -138,1 +138,1 @@\n-  if (extra != NULL) {\n+  if (extra != nullptr) {\n@@ -320,2 +320,2 @@\n-    if (k != NULL && (always_clean || !k->is_loader_alive())) {\n-      set_type(i, with_status((Klass*)NULL, p));\n+    if (k != nullptr && (always_clean || !k->is_loader_alive())) {\n+      set_type(i, with_status((Klass*)nullptr, p));\n@@ -329,2 +329,2 @@\n-  if (k != NULL && (always_clean || !k->is_loader_alive())) {\n-    set_type(with_status((Klass*)NULL, p));\n+  if (k != nullptr && (always_clean || !k->is_loader_alive())) {\n+    set_type(with_status((Klass*)nullptr, p));\n@@ -409,1 +409,1 @@\n-    if (p != NULL && (always_clean || !p->is_loader_alive())) {\n+    if (p != nullptr && (always_clean || !p->is_loader_alive())) {\n@@ -419,1 +419,1 @@\n-    if (receiver(row) != NULL)  entries++;\n+    if (receiver(row) != nullptr)  entries++;\n@@ -428,1 +428,1 @@\n-    if (receiver(row) != NULL) {\n+    if (receiver(row) != nullptr) {\n@@ -433,1 +433,1 @@\n-    if (receiver(row) != NULL) {\n+    if (receiver(row) != nullptr) {\n@@ -837,1 +837,1 @@\n-FailedSpeculation::FailedSpeculation(address speculation, int speculation_len) : _data_len(speculation_len), _next(NULL) {\n+FailedSpeculation::FailedSpeculation(address speculation, int speculation_len) : _data_len(speculation_len), _next(nullptr) {\n@@ -846,1 +846,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -850,1 +850,1 @@\n-      if (method != NULL) {\n+      if (method != nullptr) {\n@@ -854,1 +854,1 @@\n-        if (jvmci_name != NULL) {\n+        if (jvmci_name != nullptr) {\n@@ -867,1 +867,1 @@\n-  assert(failed_speculations_address != NULL, \"must be\");\n+  assert(failed_speculations_address != nullptr, \"must be\");\n@@ -870,1 +870,1 @@\n-  if (fs == NULL) {\n+  if (fs == nullptr) {\n@@ -880,3 +880,3 @@\n-    if (*cursor == NULL) {\n-      FailedSpeculation* old_fs = Atomic::cmpxchg(cursor, (FailedSpeculation*) NULL, fs);\n-      if (old_fs == NULL) {\n+    if (*cursor == nullptr) {\n+      FailedSpeculation* old_fs = Atomic::cmpxchg(cursor, (FailedSpeculation*) nullptr, fs);\n+      if (old_fs == nullptr) {\n@@ -894,1 +894,1 @@\n-  assert(failed_speculations_address != NULL, \"must be\");\n+  assert(failed_speculations_address != nullptr, \"must be\");\n@@ -896,1 +896,1 @@\n-  while (fs != NULL) {\n+  while (fs != nullptr) {\n@@ -1138,1 +1138,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1187,1 +1187,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1233,1 +1233,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1250,1 +1250,1 @@\n-    parameters_type_data()->post_initialize(NULL, this);\n+    parameters_type_data()->post_initialize(nullptr, this);\n@@ -1357,1 +1357,1 @@\n-  _failed_speculations = NULL;\n+  _failed_speculations = nullptr;\n@@ -1392,1 +1392,1 @@\n-  DataLayout* prev = NULL;\n+  DataLayout* prev = nullptr;\n@@ -1396,1 +1396,1 @@\n-      else if (prev != NULL)   set_hint_di(dp_to_di((address)prev));\n+      else if (prev != nullptr)   set_hint_di(dp_to_di((address)prev));\n@@ -1404,1 +1404,1 @@\n-\/\/ Translate a bci to its corresponding data, or NULL.\n+\/\/ Translate a bci to its corresponding data, or null.\n@@ -1415,1 +1415,1 @@\n-  return bci_to_extra_data(bci, NULL, false);\n+  return bci_to_extra_data(bci, nullptr, false);\n@@ -1443,1 +1443,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1446,1 +1446,1 @@\n-      return NULL; \/\/ ArgInfoData is at the end of extra data section.\n+      return nullptr; \/\/ ArgInfoData is at the end of extra data section.\n@@ -1448,1 +1448,1 @@\n-      if (m == NULL && dp->bci() == bci) {\n+      if (m == nullptr && dp->bci() == bci) {\n@@ -1453,1 +1453,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -1459,1 +1459,1 @@\n-          if (data->method() == NULL) {\n+          if (data->method() == nullptr) {\n@@ -1461,1 +1461,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -1472,1 +1472,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1476,1 +1476,1 @@\n-\/\/ Translate a bci to its corresponding extra data, or NULL.\n+\/\/ Translate a bci to its corresponding extra data, or null.\n@@ -1484,2 +1484,2 @@\n-  if (m != NULL && m->is_old()) {\n-    return NULL;\n+  if (m != nullptr && m->is_old()) {\n+    return nullptr;\n@@ -1495,1 +1495,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1504,1 +1504,1 @@\n-    if (result != NULL || dp >= end) {\n+    if (result != nullptr || dp >= end) {\n@@ -1508,1 +1508,1 @@\n-    assert(dp->tag() == DataLayout::no_tag || (dp->tag() == DataLayout::speculative_trap_data_tag && m != NULL), \"should be free\");\n+    assert(dp->tag() == DataLayout::no_tag || (dp->tag() == DataLayout::speculative_trap_data_tag && m != nullptr), \"should be free\");\n@@ -1510,1 +1510,1 @@\n-    u1 tag = m == NULL ? DataLayout::bit_data_tag : DataLayout::speculative_trap_data_tag;\n+    u1 tag = m == nullptr ? DataLayout::bit_data_tag : DataLayout::speculative_trap_data_tag;\n@@ -1512,2 +1512,2 @@\n-    if (m != NULL && next_extra(dp)->tag() != DataLayout::no_tag) {\n-      return NULL;\n+    if (m != nullptr && next_extra(dp)->tag() != DataLayout::no_tag) {\n+      return nullptr;\n@@ -1529,1 +1529,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1539,1 +1539,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1784,1 +1784,1 @@\n-      assert(m != NULL, \"should have a method\");\n+      assert(m != nullptr, \"should have a method\");\n@@ -1828,1 +1828,1 @@\n-      assert(m != NULL && cl->is_live(m), \"Method should exist\");\n+      assert(m != nullptr && cl->is_live(m), \"Method should exist\");\n@@ -1851,1 +1851,1 @@\n-  if (parameters != NULL) {\n+  if (parameters != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -410,1 +410,1 @@\n-    return is_BitData()         ? (BitData*)        this : NULL;\n+    return is_BitData()         ? (BitData*)        this : nullptr;\n@@ -414,1 +414,1 @@\n-    return is_CounterData()     ? (CounterData*)    this : NULL;\n+    return is_CounterData()     ? (CounterData*)    this : nullptr;\n@@ -418,1 +418,1 @@\n-    return is_JumpData()        ? (JumpData*)       this : NULL;\n+    return is_JumpData()        ? (JumpData*)       this : nullptr;\n@@ -422,1 +422,1 @@\n-    return is_ReceiverTypeData() ? (ReceiverTypeData*)this : NULL;\n+    return is_ReceiverTypeData() ? (ReceiverTypeData*)this : nullptr;\n@@ -426,1 +426,1 @@\n-    return is_VirtualCallData() ? (VirtualCallData*)this : NULL;\n+    return is_VirtualCallData() ? (VirtualCallData*)this : nullptr;\n@@ -430,1 +430,1 @@\n-    return is_RetData()         ? (RetData*)        this : NULL;\n+    return is_RetData()         ? (RetData*)        this : nullptr;\n@@ -434,1 +434,1 @@\n-    return is_BranchData()      ? (BranchData*)     this : NULL;\n+    return is_BranchData()      ? (BranchData*)     this : nullptr;\n@@ -438,1 +438,1 @@\n-    return is_ArrayData()       ? (ArrayData*)      this : NULL;\n+    return is_ArrayData()       ? (ArrayData*)      this : nullptr;\n@@ -442,1 +442,1 @@\n-    return is_MultiBranchData() ? (MultiBranchData*)this : NULL;\n+    return is_MultiBranchData() ? (MultiBranchData*)this : nullptr;\n@@ -446,1 +446,1 @@\n-    return is_ArgInfoData() ? (ArgInfoData*)this : NULL;\n+    return is_ArgInfoData() ? (ArgInfoData*)this : nullptr;\n@@ -450,1 +450,1 @@\n-    return is_CallTypeData() ? (CallTypeData*)this : NULL;\n+    return is_CallTypeData() ? (CallTypeData*)this : nullptr;\n@@ -454,1 +454,1 @@\n-    return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : NULL;\n+    return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : nullptr;\n@@ -458,1 +458,1 @@\n-    return is_ParametersTypeData() ? (ParametersTypeData*)this : NULL;\n+    return is_ParametersTypeData() ? (ParametersTypeData*)this : nullptr;\n@@ -462,1 +462,1 @@\n-    return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;\n+    return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : nullptr;\n@@ -487,1 +487,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const {\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const {\n@@ -550,1 +550,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -600,1 +600,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -674,1 +674,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -732,1 +732,1 @@\n-      assert(res != NULL, \"invalid\");\n+      assert(res != nullptr, \"invalid\");\n@@ -735,1 +735,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -756,1 +756,1 @@\n-    : _pd(NULL), _base_off(base_off) {}\n+    : _pd(nullptr), _base_off(base_off) {}\n@@ -1092,1 +1092,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1157,1 +1157,1 @@\n-    assert(recv == NULL || recv->is_klass(), \"wrong type\");\n+    assert(recv == nullptr || recv->is_klass(), \"wrong type\");\n@@ -1195,1 +1195,1 @@\n-    set_receiver(row, NULL);\n+    set_receiver(row, nullptr);\n@@ -1232,1 +1232,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1264,1 +1264,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1396,1 +1396,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1488,1 +1488,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1552,1 +1552,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1711,1 +1711,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1736,1 +1736,1 @@\n-  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1795,1 +1795,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -1865,1 +1865,1 @@\n-  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+  virtual void print_data_on(outputStream* st, const char* extra = nullptr) const;\n@@ -2047,1 +2047,1 @@\n-\/\/ is NULL to begin with, the interpreter assumes that the current method\n+\/\/ is null to begin with, the interpreter assumes that the current method\n@@ -2296,1 +2296,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2447,1 +2447,1 @@\n-                                                   assert(aid != NULL, \"arg_info must be not null\");\n+                                                   assert(aid != nullptr, \"arg_info must be not null\");\n@@ -2456,1 +2456,1 @@\n-                                                   assert(aid != NULL, \"arg_info must be not null\");\n+                                                   assert(aid != nullptr, \"arg_info must be not null\");\n@@ -2472,1 +2472,1 @@\n-    return param == NULL ? 0 : param->size_in_bytes();\n+    return param == nullptr ? 0 : param->size_in_bytes();\n@@ -2485,2 +2485,2 @@\n-  bool is_valid(ProfileData* current) const { return current != NULL; }\n-  bool is_valid(DataLayout*  current) const { return current != NULL; }\n+  bool is_valid(ProfileData* current) const { return current != nullptr; }\n+  bool is_valid(DataLayout*  current) const { return current != nullptr; }\n@@ -2499,1 +2499,1 @@\n-  \/\/ Get the data at an arbitrary bci, or NULL if there is none.\n+  \/\/ Get the data at an arbitrary bci, or null if there is none.\n@@ -2504,3 +2504,3 @@\n-    ProfileData* data = NULL;\n-    \/\/ If m not NULL, try to allocate a SpeculativeTrapData entry\n-    if (m == NULL) {\n+    ProfileData* data = nullptr;\n+    \/\/ If m not null, try to allocate a SpeculativeTrapData entry\n+    if (m == nullptr) {\n@@ -2509,1 +2509,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -2513,1 +2513,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -2519,1 +2519,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -2522,1 +2522,1 @@\n-    return bci_to_extra_data(bci, NULL, true);\n+    return bci_to_extra_data(bci, nullptr, true);\n@@ -2573,1 +2573,1 @@\n-    return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)->data_in()->as_ParametersTypeData() : NULL;\n+    return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)->data_in()->as_ParametersTypeData() : nullptr;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  Klass* super_klass = NULL;\n+  Klass* super_klass = nullptr;\n@@ -69,1 +69,1 @@\n-    if (element_super != NULL) {\n+    if (element_super != nullptr) {\n@@ -76,1 +76,1 @@\n-      bool supers_exist = super_klass != NULL;\n+      bool supers_exist = super_klass != nullptr;\n@@ -82,1 +82,1 @@\n-        if (elem_super->array_klass_or_null() == NULL) {\n+        if (elem_super->array_klass_or_null() == nullptr) {\n@@ -88,1 +88,1 @@\n-        if (element_klass->array_klass_or_null() == NULL) {\n+        if (element_klass->array_klass_or_null() == nullptr) {\n@@ -94,1 +94,1 @@\n-        Klass* ek = NULL;\n+        Klass* ek = nullptr;\n@@ -128,1 +128,1 @@\n-  assert(module != NULL, \"No module entry for array\");\n+  assert(module != nullptr, \"No module entry for array\");\n@@ -134,1 +134,1 @@\n-  \/\/ including classes in the bootstrap (NULL) class loader.\n+  \/\/ including classes in the bootstrap (null) class loader.\n@@ -157,1 +157,1 @@\n-  assert(bk != NULL && (bk->is_instance_klass() || bk->is_typeArray_klass()), \"invalid bottom klass\");\n+  assert(bk != nullptr && (bk->is_instance_klass() || bk->is_typeArray_klass()), \"invalid bottom klass\");\n@@ -335,1 +335,1 @@\n-    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(s, src_offset, NULL) ==\n+    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(s, src_offset, nullptr) ==\n@@ -337,1 +337,1 @@\n-    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(d, dst_offset, NULL) ==\n+    assert(arrayOopDesc::obj_offset_to_raw<narrowOop>(d, dst_offset, nullptr) ==\n@@ -343,1 +343,1 @@\n-    assert(arrayOopDesc::obj_offset_to_raw<oop>(s, src_offset, NULL) ==\n+    assert(arrayOopDesc::obj_offset_to_raw<oop>(s, src_offset, nullptr) ==\n@@ -345,1 +345,1 @@\n-    assert(arrayOopDesc::obj_offset_to_raw<oop>(d, dst_offset, NULL) ==\n+    assert(arrayOopDesc::obj_offset_to_raw<oop>(d, dst_offset, nullptr) ==\n@@ -358,1 +358,1 @@\n-  if (higher_dimension_acquire() == NULL) {\n+  if (higher_dimension_acquire() == nullptr) {\n@@ -366,1 +366,1 @@\n-      if (higher_dimension() == NULL) {\n+      if (higher_dimension() == nullptr) {\n@@ -392,2 +392,2 @@\n-  if (higher_dimension_acquire() == NULL) {\n-    return NULL;\n+  if (higher_dimension_acquire() == nullptr) {\n+    return nullptr;\n@@ -418,1 +418,1 @@\n-  assert(transitive_interfaces == NULL, \"sanity\");\n+  assert(transitive_interfaces == nullptr, \"sanity\");\n@@ -421,1 +421,1 @@\n-  int num_elem_supers = elem_supers == NULL ? 0 : elem_supers->length();\n+  int num_elem_supers = elem_supers == nullptr ? 0 : elem_supers->length();\n@@ -426,1 +426,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -434,1 +434,1 @@\n-      assert(array_super != NULL, \"must already have been created\");\n+      assert(array_super != nullptr, \"must already have been created\");\n@@ -453,1 +453,1 @@\n-  if (element_klass() == NULL) {\n+  if (element_klass() == nullptr) {\n@@ -465,1 +465,1 @@\n-  assert(bottom_klass() != NULL, \"ObjArrayKlass returned unexpected NULL bottom_klass\");\n+  assert(bottom_klass() != nullptr, \"ObjArrayKlass returned unexpected null bottom_klass\");\n@@ -471,1 +471,1 @@\n-  assert(bottom_klass() != NULL, \"ObjArrayKlass returned unexpected NULL bottom_klass\");\n+  assert(bottom_klass() != nullptr, \"ObjArrayKlass returned unexpected null bottom_klass\");\n@@ -502,1 +502,1 @@\n-    if (oa->obj_at(index) != NULL) {\n+    if (oa->obj_at(index) != nullptr) {\n@@ -506,1 +506,1 @@\n-      st->print_cr(\"NULL\");\n+      st->print_cr(\"null\");\n@@ -523,1 +523,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -526,1 +526,1 @@\n-    st->print_cr(\"NULL\");\n+    st->print_cr(\"null\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    st->print(\"BAD WORD\");\n+    st->print_cr(\"BAD WORD\");\n@@ -45,1 +45,1 @@\n-    st->print(\"BAD META WORD\");\n+    st->print_cr(\"BAD META WORD\");\n@@ -89,1 +89,1 @@\n-  if (oop_desc != NULL) {\n+  if (oop_desc != nullptr) {\n@@ -126,1 +126,1 @@\n-  return obj == NULL ? true : is_oop(obj, ignore_mark_word);\n+  return obj == nullptr ? true : is_oop(obj, ignore_mark_word);\n@@ -165,1 +165,1 @@\n-    if (narrow_klass == 0) return NULL;\n+    if (narrow_klass == 0) return nullptr;\n@@ -176,1 +176,1 @@\n-    if (CompressedOops::is_null(narrow_oop)) return NULL;\n+    if (CompressedOops::is_null(narrow_oop)) return nullptr;\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,2 @@\n+  \/\/ Get the raw value without any checks.\n+  inline Klass* klass_raw() const;\n@@ -278,1 +280,1 @@\n-  \/\/ this call returns \"NULL\" for that thread; any other thread has the\n+  \/\/ this call returns null for that thread; any other thread has the\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -110,0 +110,8 @@\n+Klass* oopDesc::klass_raw() const {\n+  if (UseCompressedClassPointers) {\n+    return CompressedKlassPointers::decode_raw(_metadata._compressed_klass);\n+  } else {\n+    return _metadata._klass;\n+  }\n+}\n+\n@@ -111,1 +119,1 @@\n-  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  assert(Universe::is_bootstrapping() || (k != nullptr && k->is_klass()), \"incorrect Klass\");\n@@ -120,1 +128,1 @@\n-  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  assert(Universe::is_bootstrapping() || (k != nullptr && k->is_klass()), \"incorrect Klass\");\n@@ -288,1 +296,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -359,1 +367,1 @@\n-  return obj == NULL || obj->klass()->is_subtype_of(klass);\n+  return obj == nullptr || obj->klass()->is_subtype_of(klass);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/integralConstant.hpp\"\n@@ -32,0 +31,2 @@\n+#include <type_traits>\n+\n@@ -71,1 +72,1 @@\n-\/\/ Converting NULL to oop to Handle implicit is no longer accepted by the\n+\/\/ Converting null to oop to Handle implicit is no longer accepted by the\n@@ -112,1 +113,1 @@\n-struct PrimitiveConversions::Translate<oop> : public TrueType {\n+struct PrimitiveConversions::Translate<oop> : public std::true_type {\n@@ -120,25 +121,25 @@\n-#define DEF_OOP(type)                                                      \\\n-   class type##OopDesc;                                                    \\\n-   class type##Oop : public oop {                                          \\\n-     public:                                                               \\\n-       type##Oop() : oop() {}                                              \\\n-       type##Oop(const type##Oop& o) : oop(o) {}                           \\\n-       type##Oop(const oop& o) : oop(o) {}                                 \\\n-       type##Oop(type##OopDesc* o) : oop((oopDesc*)o) {}                   \\\n-       operator type##OopDesc* () const { return (type##OopDesc*)obj(); }  \\\n-       type##OopDesc* operator->() const {                                 \\\n-            return (type##OopDesc*)obj();                                  \\\n-       }                                                                   \\\n-       type##Oop& operator=(const type##Oop& o) {                          \\\n-            oop::operator=(o);                                             \\\n-            return *this;                                                  \\\n-       }                                                                   \\\n-   };                                                                      \\\n-                                                                           \\\n-   template<>                                                              \\\n-   struct PrimitiveConversions::Translate<type##Oop> : public TrueType {   \\\n-     typedef type##Oop Value;                                              \\\n-     typedef type##OopDesc* Decayed;                                       \\\n-                                                                           \\\n-     static Decayed decay(Value x) { return (type##OopDesc*)x.obj(); }     \\\n-     static Value recover(Decayed x) { return type##Oop(x); }              \\\n+#define DEF_OOP(type)                                                          \\\n+   class type##OopDesc;                                                        \\\n+   class type##Oop : public oop {                                              \\\n+     public:                                                                   \\\n+       type##Oop() : oop() {}                                                  \\\n+       type##Oop(const type##Oop& o) : oop(o) {}                               \\\n+       type##Oop(const oop& o) : oop(o) {}                                     \\\n+       type##Oop(type##OopDesc* o) : oop((oopDesc*)o) {}                       \\\n+       operator type##OopDesc* () const { return (type##OopDesc*)obj(); }      \\\n+       type##OopDesc* operator->() const {                                     \\\n+            return (type##OopDesc*)obj();                                      \\\n+       }                                                                       \\\n+       type##Oop& operator=(const type##Oop& o) {                              \\\n+            oop::operator=(o);                                                 \\\n+            return *this;                                                      \\\n+       }                                                                       \\\n+   };                                                                          \\\n+                                                                               \\\n+   template<>                                                                  \\\n+   struct PrimitiveConversions::Translate<type##Oop> : public std::true_type { \\\n+     typedef type##Oop Value;                                                  \\\n+     typedef type##OopDesc* Decayed;                                           \\\n+                                                                               \\\n+     static Decayed decay(Value x) { return (type##OopDesc*)x.obj(); }         \\\n+     static Value recover(Decayed x) { return type##Oop(x); }                  \\\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-    if (scan == NULL)\n+    if (scan == nullptr)\n@@ -223,1 +223,1 @@\n-  if (strchr(pattern, '*') == NULL) {\n+  if (strchr(pattern, '*') == nullptr) {\n@@ -263,1 +263,1 @@\n-  if (s == NULL) {\n+  if (s == nullptr) {\n@@ -418,1 +418,0 @@\n-#ifdef ASSERT\n@@ -421,1 +420,0 @@\n-#endif\n@@ -441,1 +439,0 @@\n-#ifdef ASSERT\n@@ -444,1 +441,0 @@\n-#endif\n@@ -464,1 +460,0 @@\n-#ifdef ASSERT\n@@ -467,1 +462,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-    if (s != NULL) {\n+    if (s != nullptr) {\n@@ -181,1 +181,1 @@\n-    if (s != NULL) {\n+    if (s != nullptr) {\n@@ -231,1 +231,1 @@\n-    assert(len >= 0 && substring != NULL, \"substring must be valid\");\n+    assert(len >= 0 && substring != nullptr, \"substring must be valid\");\n@@ -296,1 +296,1 @@\n-  void print_symbol_on(outputStream* st = NULL) const;\n+  void print_symbol_on(outputStream* st = nullptr) const;\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  Symbol* sym = NULL;\n-  if (name_str != NULL) {\n+  Symbol* sym = nullptr;\n+  if (name_str != nullptr) {\n@@ -60,1 +60,1 @@\n-  \/\/ including classes in the bootstrap (NULL) class loader.\n+  \/\/ including classes in the bootstrap (null) class loader.\n@@ -180,1 +180,1 @@\n-  if (higher_dimension_acquire() == NULL) {\n+  if (higher_dimension_acquire() == nullptr) {\n@@ -188,1 +188,1 @@\n-      if (higher_dimension() == NULL) {\n+      if (higher_dimension() == nullptr) {\n@@ -213,2 +213,2 @@\n-  if (higher_dimension_acquire() == NULL) {\n-    return NULL;\n+  if (higher_dimension_acquire() == nullptr) {\n+    return nullptr;\n@@ -252,1 +252,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -374,1 +374,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-                               int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n+                               int caller_bci, bool& should_delay, ciCallProfile& profile) {\n@@ -131,1 +131,0 @@\n-#ifndef PRODUCT\n@@ -142,1 +141,0 @@\n-#endif\n@@ -183,1 +181,1 @@\n-        callee_method->instructions_size() > inline_small_code_size) {\n+        callee_method->inline_instructions_size() > inline_small_code_size) {\n@@ -202,1 +200,1 @@\n-                                   int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n+                                   int caller_bci, bool& should_delay, ciCallProfile& profile) {\n@@ -246,1 +244,0 @@\n-#ifndef PRODUCT\n@@ -266,1 +263,0 @@\n-#endif\n@@ -281,1 +277,1 @@\n-      callee_method->instructions_size() > InlineSmallCode) {\n+      callee_method->inline_instructions_size() > InlineSmallCode) {\n@@ -382,1 +378,1 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n+  if (!should_inline(callee_method, caller_method, caller_bci, should_delay, profile)) {\n@@ -386,1 +382,1 @@\n-  if (should_not_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n+  if (should_not_inline(callee_method, caller_method, caller_bci, should_delay, profile)) {\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -621,3 +621,6 @@\n-  develop(bool, VerifyIterativeGVN, false,                                  \\\n-          \"Verify Def-Use modifications during sparse Iterative Global \"    \\\n-          \"Value Numbering\")                                                \\\n+  develop(uint, VerifyIterativeGVN, 0,                                      \\\n+          \"Verify Iterative Global Value Numbering\"                         \\\n+          \"=XY, with Y: verify Def-Use modifications during IGVN\"           \\\n+          \"          X: verify that type(n) == n->Value() after IGVN\"       \\\n+          \"X and Y in 0=off; 1=on\")                                         \\\n+          constraint(VerifyIterativeGVNConstraintFunc, AtParse)             \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,0 +224,3 @@\n+  case vmIntrinsics::_vectorizedHashCode:\n+    if (!Matcher::match_rule_supported(Op_VectorizedHashCode)) return false;\n+    break;\n@@ -790,0 +793,1 @@\n+  case vmIntrinsics::_IndexPartiallyInUpperRange:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-    regalloc->dump_register(n,buf);\n+    regalloc->dump_register(n,buf,sizeof(buf));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,15 @@\n-  const Type* ft = phase->type(in(1))->filter_speculative(_type);\n+\n+  const Type* in_type = phase->type(in(1));\n+  const Type* ft = in_type->filter_speculative(_type);\n+\n+  \/\/ Check if both _type and in_type had a speculative type, but for the just\n+  \/\/ computed ft the speculative type was dropped.\n+  if (ft->speculative() == nullptr &&\n+      _type->speculative() != nullptr &&\n+      in_type->speculative() != nullptr) {\n+    \/\/ Speculative type may have disagreed between cast and input, and was\n+    \/\/ dropped in filtering. Recompute so that ft can take speculative type\n+    \/\/ of in_type. If we did not do it now, a subsequent ::Value call would\n+    \/\/ do it, and violate idempotence of ::Value.\n+    ft = in_type->filter_speculative(ft);\n+  }\n@@ -64,4 +78,7 @@\n-      const Type* t1 = phase->type(in(1));\n-      if( t1 == Type::TOP )  assert(ft == Type::TOP, \"special case #1\");\n-      const Type* rt = t1->join_speculative(_type);\n-      if (rt->empty())       assert(ft == Type::TOP, \"special case #2\");\n+      if (in_type == Type::TOP) {\n+        assert(ft == Type::TOP, \"special case #1\");\n+      }\n+      const Type* rt = in_type->join_speculative(_type);\n+      if (rt->empty()) {\n+        assert(ft == Type::TOP, \"special case #2\");\n+      }\n@@ -71,4 +88,5 @@\n-    if (phase->type(in(1)) == TypePtr::NULL_PTR &&\n-        _type->isa_ptr() && _type->is_ptr()->_ptr == TypePtr::NotNull)\n-    assert(ft == Type::TOP, \"special case #3\");\n-    break;\n+    if (in_type == TypePtr::NULL_PTR &&\n+        _type->isa_ptr() && _type->is_ptr()->_ptr == TypePtr::NotNull) {\n+      assert(ft == Type::TOP, \"special case #3\");\n+      break;\n+    }\n@@ -230,3 +248,17 @@\n-  \/\/ Try to improve the type of the CastII if we recognize a CmpI\/If\n-  \/\/ pattern.\n-  if (_dependency != RegularDependency) {\n+  \/\/ Try to improve the type of the CastII if we recognize a CmpI\/If pattern.\n+  \/\/\n+  \/\/ in1  in2\n+  \/\/  |    |\n+  \/\/  +--- | --+\n+  \/\/  |    |   |\n+  \/\/ CmpINode  |\n+  \/\/    |      |\n+  \/\/ BoolNode  |\n+  \/\/    |      |\n+  \/\/  IfNode   |\n+  \/\/    |      |\n+  \/\/  IfProj   |\n+  \/\/    |      |\n+  \/\/   CastIINode\n+  \/\/\n+  if (carry_dependency()) {\n@@ -364,1 +396,1 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+  if (!phase->C->post_loop_opts_phase()) {\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":46,"deletions":14,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -439,0 +439,13 @@\n+void RegionNode::set_loop_status(RegionNode::LoopStatus status) {\n+  assert(status != RegionNode::LoopStatus::NeverIrreducibleEntry, \"do not set this\");\n+  assert(loop_status() == RegionNode::LoopStatus::NeverIrreducibleEntry, \"why set our status again?\");\n+  _loop_status = status;\n+}\n+\n+#ifdef ASSERT\n+void RegionNode::verify_can_be_irreducible_entry() const {\n+  assert(loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry, \"must be marked irreducible\");\n+  assert(!is_Loop(), \"LoopNode cannot be irreducible loop entry\");\n+}\n+#endif \/\/ASSERT\n+\n@@ -532,0 +545,1 @@\n+  bool found_top = false; \/\/ irreducible loops need to check reachability if we find TOP\n@@ -555,0 +569,1 @@\n+        found_top = true;\n@@ -590,1 +605,14 @@\n-  if (can_reshape && cnt == 1) {\n+  if (can_reshape && found_top && loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry) {\n+    \/\/ Is it a dead irreducible loop?\n+    \/\/ If an irreducible loop loses one of the multiple entries\n+    \/\/ that went into the loop head, or any secondary entries,\n+    \/\/ we need to verify if the irreducible loop is still reachable,\n+    \/\/ as the special logic in is_unreachable_region only works\n+    \/\/ for reducible loops.\n+    if (is_unreachable_from_root(phase)) {\n+      \/\/ The irreducible loop is dead - must remove it\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      remove_unreachable_subgraph(igvn);\n+      return nullptr;\n+    }\n+  } else if (can_reshape && cnt == 1) {\n@@ -600,42 +628,2 @@\n-      \/\/ This region and therefore all nodes on the input control path(s) are unreachable\n-      \/\/ from root. To avoid incomplete removal of unreachable subgraphs, walk up the CFG\n-      \/\/ and aggressively replace all nodes by top.\n-      Node* top = phase->C->top();\n-      ResourceMark rm;\n-      Node_List nstack;\n-      VectorSet visited;\n-      nstack.push(this);\n-      visited.set(_idx);\n-      while (nstack.size() != 0) {\n-        Node* n = nstack.pop();\n-        for (uint i = 0; i < n->req(); ++i) {\n-          Node* m = n->in(i);\n-          assert(m != (Node*)phase->C->root(), \"Should be unreachable from root\");\n-          if (m != NULL && m->is_CFG() && !visited.test_set(m->_idx)) {\n-            nstack.push(m);\n-          }\n-        }\n-        if (n->is_Region()) {\n-          \/\/ Eagerly replace phis with top to avoid regionless phis.\n-          n->set_req(0, NULL);\n-          bool progress = true;\n-          uint max = n->outcnt();\n-          DUIterator j;\n-          while (progress) {\n-            progress = false;\n-            for (j = n->outs(); n->has_out(j); j++) {\n-              Node* u = n->out(j);\n-              if (u->is_Phi()) {\n-                igvn->replace_node(u, top);\n-                if (max != n->outcnt()) {\n-                  progress = true;\n-                  j = n->refresh_out_pos(j);\n-                  max = n->outcnt();\n-                }\n-              }\n-            }\n-          }\n-        }\n-        igvn->replace_node(n, top);\n-      }\n-      return NULL;\n+      remove_unreachable_subgraph(igvn);\n+      return nullptr;\n@@ -814,0 +802,53 @@\n+\/\/--------------------------remove_unreachable_subgraph----------------------\n+\/\/ This region and therefore all nodes on the input control path(s) are unreachable\n+\/\/ from root. To avoid incomplete removal of unreachable subgraphs, walk up the CFG\n+\/\/ and aggressively replace all nodes by top.\n+\/\/ If a control node \"def\" with a single control output \"use\" has its single output\n+\/\/ \"use\" replaced with top, then \"use\" removes itself. This has the consequence that\n+\/\/ when we visit \"use\", it already has all inputs removed. They are lost and we cannot\n+\/\/ traverse them. This is why we fist find all unreachable nodes, and then remove\n+\/\/ them in a second step.\n+void RegionNode::remove_unreachable_subgraph(PhaseIterGVN* igvn) {\n+  Node* top = igvn->C->top();\n+  ResourceMark rm;\n+  Unique_Node_List unreachable; \/\/ visit each only once\n+  unreachable.push(this);\n+  \/\/ Recursively find all control inputs.\n+  for (uint i = 0; i < unreachable.size(); i++) {\n+    Node* n = unreachable.at(i);\n+    for (uint i = 0; i < n->req(); ++i) {\n+      Node* m = n->in(i);\n+      assert(m == nullptr || !m->is_Root(), \"Should be unreachable from root\");\n+      if (m != nullptr && m->is_CFG()) {\n+        unreachable.push(m);\n+      }\n+    }\n+  }\n+  \/\/ Remove all unreachable nodes.\n+  for (uint i = 0; i < unreachable.size(); i++) {\n+    Node* n = unreachable.at(i);\n+    if (n->is_Region()) {\n+      \/\/ Eagerly replace phis with top to avoid regionless phis.\n+      n->set_req(0, nullptr);\n+      bool progress = true;\n+      uint max = n->outcnt();\n+      DUIterator j;\n+      while (progress) {\n+        progress = false;\n+        for (j = n->outs(); n->has_out(j); j++) {\n+          Node* u = n->out(j);\n+          if (u->is_Phi()) {\n+            igvn->replace_node(u, top);\n+            if (max != n->outcnt()) {\n+              progress = true;\n+              j = n->refresh_out_pos(j);\n+              max = n->outcnt();\n+            }\n+          }\n+        }\n+      }\n+    }\n+    igvn->replace_node(n, top);\n+  }\n+}\n+\n@@ -963,0 +1004,16 @@\n+#ifndef PRODUCT\n+void RegionNode::dump_spec(outputStream* st) const {\n+  Node::dump_spec(st);\n+  switch (loop_status()) {\n+  case RegionNode::LoopStatus::MaybeIrreducibleEntry:\n+    st->print(\"#irreducible \");\n+    break;\n+  case RegionNode::LoopStatus::Reducible:\n+    st->print(\"#reducible \");\n+    break;\n+  case RegionNode::LoopStatus::NeverIrreducibleEntry:\n+    break; \/\/ nothing\n+  }\n+}\n+#endif\n+\n@@ -1290,2 +1347,1 @@\n-  ft = phase->saturate(ft, phase->type_or_null(this), _type);\n-\n+  ft = phase->saturate_and_maybe_push_to_igvn_worklist(this, ft);\n@@ -1373,0 +1429,3 @@\n+  if (must_wait_for_region_in_irreducible_loop(phase)) {\n+    return this;\n+  }\n@@ -1728,0 +1787,12 @@\n+  \/\/ This optimization tries to find two or more inputs of phi with the same constant value\n+  \/\/ It then splits them into a separate Phi, and according Region. If this is a loop-entry,\n+  \/\/ and the loop entry has multiple fall-in edges, and some of those fall-in edges have that\n+  \/\/ constant, and others not, we may split the fall-in edges into separate Phi's, and create\n+  \/\/ an irreducible loop. For reducible loops, this never seems to happen, as the multiple\n+  \/\/ fall-in edges are already merged before the loop head during parsing. But with irreducible\n+  \/\/ loops present the order or merging during parsing can sometimes prevent this.\n+  if (phase->C->has_irreducible_loop()) {\n+    \/\/ Avoid this optimization if any irreducible loops are present. Else we may create\n+    \/\/ an irreducible loop that we do not detect.\n+    return nullptr;\n+  }\n@@ -1966,0 +2037,25 @@\n+\/\/ If the Phi's Region is in an irreducible loop, and the Region\n+\/\/ has had an input removed, but not yet transformed, it could be\n+\/\/ that the Region (and this Phi) are not reachable from Root.\n+\/\/ If we allow the Phi to collapse before the Region, this may lead\n+\/\/ to dead-loop data. Wait for the Region to check for reachability,\n+\/\/ and potentially remove the dead code.\n+bool PhiNode::must_wait_for_region_in_irreducible_loop(PhaseGVN* phase) const {\n+  RegionNode* region = in(0)->as_Region();\n+  if (region->loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry) {\n+    Node* top = phase->C->top();\n+    for (uint j = 1; j < req(); j++) {\n+      Node* rc = region->in(j); \/\/ for each control input\n+      if (rc == nullptr || phase->type(rc) == Type::TOP) {\n+        \/\/ Region is missing a control input\n+        Node* n = in(j);\n+        if (n != nullptr && n != top) {\n+          \/\/ Phi still has its input, so region just lost its input\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1985,0 +2081,4 @@\n+  if (must_wait_for_region_in_irreducible_loop(phase)) {\n+    return nullptr;\n+  }\n+\n@@ -2102,1 +2202,1 @@\n-    if (ident != uin && !ident->is_top()) {\n+    if (ident != uin && !ident->is_top() && !must_wait_for_region_in_irreducible_loop(phase)) {\n@@ -2110,1 +2210,2 @@\n-    assert(ident == uin || ident->is_top(), \"Identity must clean this up\");\n+    \/\/ Identity may not return the expected uin, if it has to wait for the region, in irreducible case\n+    assert(ident == uin || ident->is_top() || must_wait_for_region_in_irreducible_loop(phase), \"Identity must clean this up\");\n@@ -2648,2 +2749,5 @@\n-\n-  assert(cached_vbox != NULL, \"sanity\");\n+  if (cached_vbox == nullptr) {\n+    \/\/ We have a Phi dead-loop (no data-input). Phi nodes are considered safe,\n+    \/\/ so just avoid this optimization.\n+    return nullptr;\n+  }\n@@ -2890,0 +2994,4 @@\n+  if (phase->type(in(0)->in(0)) == Type::TOP) {\n+    assert(in(0)->is_CatchProj(), \"control is CatchProj\");\n+    return phase->C->top(); \/\/ dead code\n+  }\n@@ -2947,1 +3055,1 @@\n-      ra->dump_register(n, buf);\n+      ra->dump_register(n, buf, sizeof(buf));\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":158,"deletions":50,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,12 @@\n+public:\n+  enum LoopStatus {\n+    \/\/ No guarantee: the region may be an irreducible loop entry, thus we have to\n+    \/\/ be careful when removing entry control to it.\n+    MaybeIrreducibleEntry,\n+    \/\/ Limited guarantee: this region may be (nested) inside an irreducible loop,\n+    \/\/ but it will never be an irreducible loop entry.\n+    NeverIrreducibleEntry,\n+    \/\/ Strong guarantee: this region is not (nested) inside an irreducible loop.\n+    Reducible,\n+  };\n+\n@@ -70,0 +82,1 @@\n+  LoopStatus _loop_status;\n@@ -79,1 +92,5 @@\n-  RegionNode(uint required) : Node(required), _is_unreachable_region(false) {\n+  RegionNode(uint required)\n+    : Node(required),\n+      _is_unreachable_region(false),\n+      _loop_status(LoopStatus::NeverIrreducibleEntry)\n+  {\n@@ -98,0 +115,4 @@\n+  LoopStatus loop_status() const { return _loop_status; };\n+  void set_loop_status(LoopStatus status);\n+  DEBUG_ONLY(void verify_can_be_irreducible_entry() const;)\n+\n@@ -108,0 +129,1 @@\n+  void remove_unreachable_subgraph(PhaseIterGVN* igvn);\n@@ -109,0 +131,1 @@\n+  NOT_PRODUCT(virtual void dump_spec(outputStream* st) const;)\n@@ -153,0 +176,2 @@\n+  bool must_wait_for_region_in_irreducible_loop(PhaseGVN* phase) const;\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2186,1 +2186,1 @@\n-static char *print_reg(OptoReg::Name reg, const PhaseChaitin* pc, char* buf) {\n+static char *print_reg(OptoReg::Name reg, const PhaseChaitin* pc, char* buf, size_t buf_size) {\n@@ -2188,1 +2188,1 @@\n-    sprintf(buf, \"<OptoReg::%d>\", (int)reg);\n+    os::snprintf_checked(buf, buf_size, \"<OptoReg::%d>\", (int)reg);\n@@ -2192,1 +2192,1 @@\n-    sprintf(buf,\"%s + #%d\",OptoReg::regname(OptoReg::c_frame_pointer),\n+    os::snprintf_checked(buf, buf_size, \"%s + #%d\",OptoReg::regname(OptoReg::c_frame_pointer),\n@@ -2199,1 +2199,1 @@\n-char *PhaseChaitin::dump_register(const Node* n, char* buf) const {\n+char *PhaseChaitin::dump_register(const Node* n, char* buf, size_t buf_size) const {\n@@ -2202,1 +2202,1 @@\n-    print_reg( get_reg_first(n), this, buf );\n+    print_reg( get_reg_first(n), this, buf, buf_size);\n@@ -2206,1 +2206,1 @@\n-      sprintf(buf,\"L%d\",lidx);  \/\/ No register binding yet\n+      os::snprintf_checked(buf, buf_size, \"L%d\",lidx);  \/\/ No register binding yet\n@@ -2212,1 +2212,1 @@\n-          print_reg( lrgs(lidx).reg(), this, buf ); \/\/ a bound machine register\n+          print_reg( lrgs(lidx).reg(), this, buf, buf_size); \/\/ a bound machine register\n@@ -2214,1 +2214,1 @@\n-          sprintf(buf,\"L%d\",lidx); \/\/ No register binding yet\n+          os::snprintf_checked(buf, buf_size, \"L%d\",lidx); \/\/ No register binding yet\n@@ -2219,1 +2219,1 @@\n-        print_reg( lrgs(lidx).reg(), this, buf );\n+        print_reg( lrgs(lidx).reg(), this, buf, buf_size);\n@@ -2221,1 +2221,1 @@\n-        sprintf(buf,\"L%d\",lidx); \/\/ No register binding yet\n+        os::snprintf_checked(buf, buf_size, \"L%d\",lidx); \/\/ No register binding yet\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -516,0 +516,1 @@\n+macro(VectorizedHashCode)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -772,0 +772,3 @@\n+\n+    gvn.set_type(root(), root()->bottom_type());\n+\n@@ -1004,0 +1007,6 @@\n+#ifdef ASSERT\n+  _phase_optimize_finished = false;\n+  _exception_backedge = false;\n+  _type_verify = NULL;\n+#endif\n+\n@@ -1101,6 +1110,0 @@\n-\n-#ifdef ASSERT\n-  _type_verify_symmetry = true;\n-  _phase_optimize_finished = false;\n-  _exception_backedge = false;\n-#endif\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+class VerifyMeetResult;\n@@ -1242,1 +1243,1 @@\n-  bool _type_verify_symmetry;\n+  VerifyMeetResult* _type_verify;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -960,2 +960,1 @@\n-      _gvn.set_type(ex_klass_node, TypeInstKlassPtr::OBJECT);\n-\n+      ex_klass_node = _gvn.transform(ex_klass_node);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -838,0 +838,1 @@\n+    case Op_VectorizedHashCode:\n@@ -3526,2 +3527,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n-              op == Op_CountPositives ||\n+              op == Op_FastLock || op == Op_AryEq ||\n+              op == Op_StrComp || op == Op_CountPositives ||\n@@ -3529,1 +3530,2 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n+              op == Op_StrEquals || op == Op_VectorizedHashCode ||\n+              op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,1 @@\n+    case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -311,0 +312,2 @@\n+  case vmIntrinsics::_vectorizedHashCode:       return inline_vectorizedHashCode();\n+\n@@ -735,0 +738,2 @@\n+  case vmIntrinsics::_IndexPartiallyInUpperRange:\n+    return inline_index_partially_in_upper_range();\n@@ -1079,0 +1084,1 @@\n+\n@@ -1374,4 +1380,7 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const Type* dst_type = dst->Value(&_gvn);\n-  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType dst_elem = dst_type->isa_aryptr()->elem()->array_element_basic_type();\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* dst_type = dst->Value(&_gvn)->isa_aryptr();\n+  if (src_type == nullptr || dst_type == nullptr) {\n+    return false;\n+  }\n+  BasicType src_elem = src_type->elem()->array_element_basic_type();\n+  BasicType dst_elem = dst_type->elem()->array_element_basic_type();\n@@ -3338,1 +3347,2 @@\n-  Node* event_writer = access_load(jobj, xtype, T_OBJECT, IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);\n+  Node* jobj_untagged = _gvn.transform(new AddPNode(top(), jobj, _gvn.MakeConX(-JNIHandles::TypeTag::global)));\n+  Node* event_writer = access_load(jobj_untagged, xtype, T_OBJECT, IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);\n@@ -3567,3 +3577,1 @@\n-  \/\/ Stores of oops to native memory not supported yet by BarrierSetC2::store_at_resolved\n-  \/\/ access_store_at(NULL, thread_obj_handle, adr_type, arr, _gvn.type(arr), T_OBJECT, IN_NATIVE | MO_UNORDERED);\n-  store_to_memory(control(), thread_obj_handle, arr, T_OBJECT, adr_type, MemNode::unordered);\n+  access_store_at(NULL, thread_obj_handle, adr_type, arr, _gvn.type(arr), T_OBJECT, IN_NATIVE | MO_UNORDERED);\n@@ -5280,18 +5288,1 @@\n-        JVMState* old_jvms = alloc->jvms()->clone_shallow(C);\n-        uint size = alloc->req();\n-        SafePointNode* sfpt = new SafePointNode(size, old_jvms);\n-        old_jvms->set_map(sfpt);\n-        for (uint i = 0; i < size; i++) {\n-          sfpt->init_req(i, alloc->in(i));\n-        }\n-        \/\/ re-push array length for deoptimization\n-        sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), alloc->in(AllocateNode::ALength));\n-        old_jvms->set_sp(old_jvms->sp()+1);\n-        old_jvms->set_monoff(old_jvms->monoff()+1);\n-        old_jvms->set_scloff(old_jvms->scloff()+1);\n-        old_jvms->set_endoff(old_jvms->endoff()+1);\n-        old_jvms->set_should_reexecute(true);\n-\n-        sfpt->set_i_o(map()->i_o());\n-        sfpt->set_memory(map()->memory());\n-        sfpt->set_control(map()->control());\n+        SafePointNode* sfpt = create_safepoint_with_state_before_array_allocation(alloc);\n@@ -5312,0 +5303,24 @@\n+\/\/ Clone the JVMState of the array allocation and create a new safepoint with it. Re-push the array length to the stack\n+\/\/ such that uncommon traps can be emitted to re-execute the array allocation in the interpreter.\n+SafePointNode* LibraryCallKit::create_safepoint_with_state_before_array_allocation(const AllocateArrayNode* alloc) const {\n+  JVMState* old_jvms = alloc->jvms()->clone_shallow(C);\n+  uint size = alloc->req();\n+  SafePointNode* sfpt = new SafePointNode(size, old_jvms);\n+  old_jvms->set_map(sfpt);\n+  for (uint i = 0; i < size; i++) {\n+    sfpt->init_req(i, alloc->in(i));\n+  }\n+  \/\/ re-push array length for deoptimization\n+  sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), alloc->in(AllocateNode::ALength));\n+  old_jvms->set_sp(old_jvms->sp()+1);\n+  old_jvms->set_monoff(old_jvms->monoff()+1);\n+  old_jvms->set_scloff(old_jvms->scloff()+1);\n+  old_jvms->set_endoff(old_jvms->endoff()+1);\n+  old_jvms->set_should_reexecute(true);\n+\n+  sfpt->set_i_o(map()->i_o());\n+  sfpt->set_memory(map()->memory());\n+  sfpt->set_control(map()->control());\n+  return sfpt;\n+}\n+\n@@ -5319,1 +5334,1 @@\n-void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms,\n+void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms_before_guards,\n@@ -5321,1 +5336,3 @@\n-  if (saved_jvms != NULL && !stopped()) {\n+  if (saved_jvms_before_guards != NULL && !stopped()) {\n+    replace_unrelated_uncommon_traps_with_alloc_state(alloc, saved_jvms_before_guards);\n+\n@@ -5324,3 +5341,3 @@\n-    saved_jvms->map()->set_control(map()->control());\n-    assert(saved_jvms->map()->memory() == map()->memory(), \"memory state changed?\");\n-    assert(saved_jvms->map()->i_o() == map()->i_o(), \"IO state changed?\");\n+    saved_jvms_before_guards->map()->set_control(map()->control());\n+    assert(saved_jvms_before_guards->map()->memory() == map()->memory(), \"memory state changed?\");\n+    assert(saved_jvms_before_guards->map()->i_o() == map()->i_o(), \"IO state changed?\");\n@@ -5329,2 +5346,2 @@\n-    map()->replaced_nodes().apply(saved_jvms->map(), new_idx);\n-    set_jvms(saved_jvms);\n+    map()->replaced_nodes().apply(saved_jvms_before_guards->map(), new_idx);\n+    set_jvms(saved_jvms_before_guards);\n@@ -5405,0 +5422,52 @@\n+\/\/ Unrelated UCTs between the array allocation and the array copy, which are considered safe by tightly_coupled_allocation(),\n+\/\/ need to be replaced by an UCT with a state before the array allocation (including the array length). This is necessary\n+\/\/ because we could hit one of these UCTs (which are executed before the emitted array copy guards and the actual array\n+\/\/ allocation which is moved down in arraycopy_move_allocation_here()). When later resuming execution in the interpreter,\n+\/\/ we would have wrongly skipped the array allocation. To prevent this, we resume execution at the array allocation in\n+\/\/ the interpreter similar to what we are doing for the newly emitted guards for the array copy.\n+void LibraryCallKit::replace_unrelated_uncommon_traps_with_alloc_state(AllocateArrayNode* alloc,\n+                                                                       JVMState* saved_jvms_before_guards) {\n+  if (saved_jvms_before_guards->map()->control()->is_IfProj()) {\n+    \/\/ There is at least one unrelated uncommon trap which needs to be replaced.\n+    SafePointNode* sfpt = create_safepoint_with_state_before_array_allocation(alloc);\n+\n+    JVMState* saved_jvms = jvms();\n+    const int saved_reexecute_sp = _reexecute_sp;\n+    set_jvms(sfpt->jvms());\n+    _reexecute_sp = jvms()->sp();\n+\n+    replace_unrelated_uncommon_traps_with_alloc_state(saved_jvms_before_guards);\n+\n+    \/\/ Restore state\n+    set_jvms(saved_jvms);\n+    _reexecute_sp = saved_reexecute_sp;\n+  }\n+}\n+\n+\/\/ Replace the unrelated uncommon traps with new uncommon trap nodes by reusing the action and reason. The new uncommon\n+\/\/ traps will have the state of the array allocation. Let the old uncommon trap nodes die.\n+void LibraryCallKit::replace_unrelated_uncommon_traps_with_alloc_state(JVMState* saved_jvms_before_guards) {\n+  Node* if_proj = saved_jvms_before_guards->map()->control(); \/\/ Start the search right before the newly emitted guards\n+  while (if_proj->is_IfProj()) {\n+    CallStaticJavaNode* uncommon_trap = get_uncommon_trap_from_success_proj(if_proj);\n+    if (uncommon_trap != nullptr) {\n+      create_new_uncommon_trap(uncommon_trap);\n+    }\n+    assert(if_proj->in(0)->is_If(), \"must be If\");\n+    if_proj = if_proj->in(0)->in(0);\n+  }\n+  assert(if_proj->is_Proj() && if_proj->in(0)->is_Initialize(),\n+         \"must have reached control projection of init node\");\n+}\n+\n+void LibraryCallKit::create_new_uncommon_trap(CallStaticJavaNode* uncommon_trap_call) {\n+  const int trap_request = uncommon_trap_call->uncommon_trap_request();\n+  assert(trap_request != 0, \"no valid UCT trap request\");\n+  PreserveJVMState pjvms(this);\n+  set_control(uncommon_trap_call->in(0));\n+  uncommon_trap(Deoptimization::trap_request_reason(trap_request),\n+                Deoptimization::trap_request_action(trap_request));\n+  assert(stopped(), \"Should be stopped\");\n+  _gvn.hash_delete(uncommon_trap_call);\n+  uncommon_trap_call->set_req(0, top()); \/\/ not used anymore, kill it\n+}\n@@ -5425,1 +5494,1 @@\n-  JVMState* saved_jvms = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);\n+  JVMState* saved_jvms_before_guards = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);\n@@ -5428,3 +5497,3 @@\n-  \/\/ if saved_jvms != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n-  \/\/ if saved_jvms == NULL and alloc != NULL, we can't emit any guards\n-  bool can_emit_guards = (alloc == NULL || saved_jvms != NULL);\n+  \/\/ if saved_jvms_before_guards != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n+  \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we can't emit any guards\n+  bool can_emit_guards = (alloc == NULL || saved_jvms_before_guards != NULL);\n@@ -5446,1 +5515,1 @@\n-  src  = saved_jvms != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src,  T_ARRAY);\n+  src  = saved_jvms_before_guards != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n@@ -5451,1 +5520,1 @@\n-    \/\/ if saved_jvms == NULL and alloc != NULL, we don't emit any\n+    \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we don't emit any\n@@ -5569,1 +5638,1 @@\n-  if (saved_jvms != NULL) {\n+  if (saved_jvms_before_guards != NULL) {\n@@ -5661,0 +5730,1 @@\n+    arraycopy_move_allocation_here(alloc, dest, saved_jvms_before_guards, saved_reexecute_sp, new_idx);\n@@ -5663,2 +5733,0 @@\n-  arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);\n-\n@@ -5729,20 +5797,8 @@\n-    if ((ctl->is_IfFalse() || ctl->is_IfTrue()) && ctl->in(0)->is_If()) {\n-      IfNode* iff = ctl->in(0)->as_If();\n-      Node* not_ctl = iff->proj_out_or_null(1 - ctl->as_Proj()->_con);\n-      assert(not_ctl != NULL && not_ctl != ctl, \"found alternate\");\n-      \/\/ One more try:  Various low-level checks bottom out in\n-      \/\/ uncommon traps.  If the debug-info of the trap omits\n-      \/\/ any reference to the allocation, as we've already\n-      \/\/ observed, then there can be no objection to the trap.\n-      bool found_trap = false;\n-      for (DUIterator_Fast jmax, j = not_ctl->fast_outs(jmax); j < jmax; j++) {\n-        Node* obs = not_ctl->fast_out(j);\n-        if (obs->in(0) == not_ctl && obs->is_Call() &&\n-            (obs->as_Call()->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point())) {\n-          found_trap = true; break;\n-        }\n-      }\n-      if (found_trap) {\n-        ctl = iff->in(0);       \/\/ This test feeds a harmless uncommon trap.\n-        continue;\n-      }\n+    \/\/ Various low-level checks bottom out in uncommon traps. These\n+    \/\/ are considered safe since we've already checked above that\n+    \/\/ there is no unexpected observer of this allocation.\n+    if (get_uncommon_trap_from_success_proj(ctl) != nullptr) {\n+      assert(ctl->in(0)->is_If(), \"must be If\");\n+      ctl = ctl->in(0)->in(0);\n+    } else {\n+      return nullptr;\n@@ -5750,1 +5806,0 @@\n-    return NULL;\n@@ -5761,0 +5816,14 @@\n+CallStaticJavaNode* LibraryCallKit::get_uncommon_trap_from_success_proj(Node* node) {\n+  if (node->is_IfProj()) {\n+    Node* other_proj = node->as_IfProj()->other_if_proj();\n+    for (DUIterator_Fast jmax, j = other_proj->fast_outs(jmax); j < jmax; j++) {\n+      Node* obs = other_proj->fast_out(j);\n+      if (obs->in(0) == other_proj && obs->is_CallStaticJava() &&\n+          (obs->as_CallStaticJava()->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point())) {\n+        return obs->as_CallStaticJava();\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -5775,6 +5844,4 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const Type* dst_type = dst->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  const TypeAryPtr* top_dest = dst_type->isa_aryptr();\n-  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM ||\n-      top_dest == NULL || top_dest->elem() == Type::BOTTOM) {\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* dst_type = dst->Value(&_gvn)->isa_aryptr();\n+  if (src_type == nullptr || src_type->elem() == Type::BOTTOM ||\n+      dst_type == nullptr || dst_type->elem() == Type::BOTTOM) {\n@@ -5786,2 +5853,2 @@\n-  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType dst_elem = dst_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType src_elem = src_type->elem()->array_element_basic_type();\n+  BasicType dst_elem = dst_type->elem()->array_element_basic_type();\n@@ -5830,6 +5897,4 @@\n-  const Type* x_type = x->Value(&_gvn);\n-  const Type* y_type = y->Value(&_gvn);\n-  const TypeAryPtr* top_x = x_type->isa_aryptr();\n-  const TypeAryPtr* top_y = y_type->isa_aryptr();\n-  if (top_x  == NULL || top_x->elem()  == Type::BOTTOM ||\n-      top_y == NULL || top_y->elem() == Type::BOTTOM) {\n+  const TypeAryPtr* x_type = x->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* y_type = y->Value(&_gvn)->isa_aryptr();\n+  if (x_type == nullptr || x_type->elem() == Type::BOTTOM ||\n+      y_type == nullptr || y_type->elem() == Type::BOTTOM) {\n@@ -5840,2 +5905,2 @@\n-  BasicType x_elem = x_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType y_elem = y_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType x_elem = x_type->elem()->array_element_basic_type();\n+  BasicType y_elem = y_type->elem()->array_element_basic_type();\n@@ -5938,6 +6003,4 @@\n-  const Type* x_type = x->Value(&_gvn);\n-  const Type* z_type = z->Value(&_gvn);\n-  const TypeAryPtr* top_x = x_type->isa_aryptr();\n-  const TypeAryPtr* top_z = z_type->isa_aryptr();\n-  if (top_x  == NULL || top_x->elem()  == Type::BOTTOM ||\n-      top_z  == NULL || top_z->elem()  == Type::BOTTOM) {\n+  const TypeAryPtr* x_type = x->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* z_type = z->Value(&_gvn)->isa_aryptr();\n+  if (x_type == nullptr || x_type->elem() == Type::BOTTOM ||\n+      z_type == nullptr || z_type->elem() == Type::BOTTOM) {\n@@ -5948,2 +6011,2 @@\n-  BasicType x_elem = x_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType z_elem = z_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType x_elem = x_type->elem()->array_element_basic_type();\n+  BasicType z_elem = z_type->elem()->array_element_basic_type();\n@@ -5985,0 +6048,1 @@\n+  in = must_be_not_null(in, true);\n@@ -5987,6 +6051,4 @@\n-  const Type* out_type = out->Value(&_gvn);\n-  const Type* in_type = in->Value(&_gvn);\n-  const TypeAryPtr* top_out = out_type->isa_aryptr();\n-  const TypeAryPtr* top_in = in_type->isa_aryptr();\n-  if (top_out  == NULL || top_out->elem()  == Type::BOTTOM ||\n-      top_in == NULL || top_in->elem() == Type::BOTTOM) {\n+  const TypeAryPtr* out_type = out->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* in_type = in->Value(&_gvn)->isa_aryptr();\n+  if (out_type == nullptr || out_type->elem() == Type::BOTTOM ||\n+       in_type == nullptr ||  in_type->elem() == Type::BOTTOM) {\n@@ -5997,2 +6059,2 @@\n-  BasicType out_elem = out_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType in_elem = in_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType out_elem = out_type->elem()->array_element_basic_type();\n+  BasicType in_elem = in_type->elem()->array_element_basic_type();\n@@ -6036,12 +6098,8 @@\n-  const Type* a_type = a->Value(&_gvn);\n-  const TypeAryPtr* top_a = a_type->isa_aryptr();\n-  const Type* b_type = b->Value(&_gvn);\n-  const TypeAryPtr* top_b = b_type->isa_aryptr();\n-  const Type* n_type = a->Value(&_gvn);\n-  const TypeAryPtr* top_n = n_type->isa_aryptr();\n-  const Type* m_type = a->Value(&_gvn);\n-  const TypeAryPtr* top_m = m_type->isa_aryptr();\n-  if (top_a  == NULL || top_a->elem()  == Type::BOTTOM ||\n-      top_b == NULL || top_b->elem()  == Type::BOTTOM ||\n-      top_n == NULL || top_n->elem()  == Type::BOTTOM ||\n-      top_m == NULL || top_m->elem()  == Type::BOTTOM) {\n+  const TypeAryPtr* a_type = a->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* b_type = b->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* n_type = n->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* m_type = m->Value(&_gvn)->isa_aryptr();\n+  if (a_type == nullptr || a_type->elem() == Type::BOTTOM ||\n+      b_type == nullptr || b_type->elem() == Type::BOTTOM ||\n+      n_type == nullptr || n_type->elem() == Type::BOTTOM ||\n+      m_type == nullptr || m_type->elem() == Type::BOTTOM) {\n@@ -6052,4 +6110,4 @@\n-  BasicType a_elem = a_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType b_elem = b_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType n_elem = n_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType m_elem = m_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType a_elem = a_type->elem()->array_element_basic_type();\n+  BasicType b_elem = b_type->elem()->array_element_basic_type();\n+  BasicType n_elem = n_type->elem()->array_element_basic_type();\n+  BasicType m_elem = m_type->elem()->array_element_basic_type();\n@@ -6095,9 +6153,6 @@\n-  const Type* a_type = a->Value(&_gvn);\n-  const TypeAryPtr* top_a = a_type->isa_aryptr();\n-  const Type* n_type = a->Value(&_gvn);\n-  const TypeAryPtr* top_n = n_type->isa_aryptr();\n-  const Type* m_type = a->Value(&_gvn);\n-  const TypeAryPtr* top_m = m_type->isa_aryptr();\n-  if (top_a  == NULL || top_a->elem()  == Type::BOTTOM ||\n-      top_n == NULL || top_n->elem()  == Type::BOTTOM ||\n-      top_m == NULL || top_m->elem()  == Type::BOTTOM) {\n+  const TypeAryPtr* a_type = a->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* n_type = n->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* m_type = m->Value(&_gvn)->isa_aryptr();\n+  if (a_type == nullptr || a_type->elem() == Type::BOTTOM ||\n+      n_type == nullptr || n_type->elem() == Type::BOTTOM ||\n+      m_type == nullptr || m_type->elem() == Type::BOTTOM) {\n@@ -6108,3 +6163,3 @@\n-  BasicType a_elem = a_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType n_elem = n_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType m_elem = m_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType a_elem = a_type->elem()->array_element_basic_type();\n+  BasicType n_elem = n_type->elem()->array_element_basic_type();\n+  BasicType m_elem = m_type->elem()->array_element_basic_type();\n@@ -6151,6 +6206,4 @@\n-  const Type* newArr_type = newArr->Value(&_gvn);\n-  const TypeAryPtr* top_newArr = newArr_type->isa_aryptr();\n-  const Type* oldArr_type = oldArr->Value(&_gvn);\n-  const TypeAryPtr* top_oldArr = oldArr_type->isa_aryptr();\n-  if (top_newArr == NULL || top_newArr->elem() == Type::BOTTOM || top_oldArr == NULL\n-      || top_oldArr->elem() == Type::BOTTOM) {\n+  const TypeAryPtr* newArr_type = newArr->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* oldArr_type = oldArr->Value(&_gvn)->isa_aryptr();\n+  if (newArr_type == nullptr || newArr_type->elem() == Type::BOTTOM ||\n+      oldArr_type == nullptr || oldArr_type->elem() == Type::BOTTOM) {\n@@ -6160,2 +6213,2 @@\n-  BasicType newArr_elem = newArr_type->isa_aryptr()->elem()->array_element_basic_type();\n-  BasicType oldArr_elem = oldArr_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType newArr_elem = newArr_type->elem()->array_element_basic_type();\n+  BasicType oldArr_elem = oldArr_type->elem()->array_element_basic_type();\n@@ -6318,0 +6371,34 @@\n+\/\/------------------------------inline_vectorizedHashcode----------------------------\n+bool LibraryCallKit::inline_vectorizedHashCode() {\n+  assert(UseVectorizedHashCodeIntrinsic, \"not implemented on this platform\");\n+\n+  assert(callee()->signature()->size() == 5, \"vectorizedHashCode has 5 parameters\");\n+  Node* array          = argument(0);\n+  Node* offset         = argument(1);\n+  Node* length         = argument(2);\n+  Node* initialValue   = argument(3);\n+  Node* basic_type     = argument(4);\n+\n+  if (basic_type == top()) {\n+    return false; \/\/ failed input validation\n+  }\n+\n+  const TypeInt* basic_type_t = _gvn.type(basic_type)->is_int();\n+  if (!basic_type_t->is_con()) {\n+    return false; \/\/ Only intrinsify if mode argument is constant\n+  }\n+\n+  array = must_be_not_null(array, true);\n+\n+  BasicType bt = (BasicType)basic_type_t->get_con();\n+\n+  \/\/ Resolve address of first element\n+  Node* array_start = array_element_address(array, offset, bt);\n+\n+  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(TypeAryPtr::get_array_body_type(bt)),\n+    array_start, length, initialValue, basic_type)));\n+  clear_upper_avx();\n+\n+  return true;\n+}\n+\n@@ -6366,3 +6453,2 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  if (src_type == nullptr || src_type->elem() == Type::BOTTOM) {\n@@ -6374,1 +6460,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType src_elem = src_type->elem()->array_element_basic_type();\n@@ -6455,3 +6541,2 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  if (src_type == nullptr || src_type->elem() == Type::BOTTOM) {\n@@ -6463,1 +6548,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType src_elem = src_type->elem()->array_element_basic_type();\n@@ -6548,3 +6633,2 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  if (src_type == nullptr || src_type->elem() == Type::BOTTOM) {\n@@ -6556,1 +6640,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType src_elem = src_type->elem()->array_element_basic_type();\n@@ -6790,5 +6874,4 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const Type* dest_type = dest->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  const TypeAryPtr* top_dest = dest_type->isa_aryptr();\n-  assert (top_src  != NULL && top_src->elem()  != Type::BOTTOM &&  top_dest != NULL && top_dest->elem() != Type::BOTTOM, \"args are strange\");\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* dest_type = dest->Value(&_gvn)->isa_aryptr();\n+  assert( src_type != nullptr &&  src_type->elem() != Type::BOTTOM &&\n+         dest_type != nullptr && dest_type->elem() != Type::BOTTOM, \"args are strange\");\n@@ -6851,6 +6934,4 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const Type* dest_type = dest->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  const TypeAryPtr* top_dest = dest_type->isa_aryptr();\n-  assert (top_src  != NULL && top_src->elem()  != Type::BOTTOM\n-          &&  top_dest != NULL && top_dest->elem() != Type::BOTTOM, \"args are strange\");\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* dest_type = dest->Value(&_gvn)->isa_aryptr();\n+  assert( src_type != nullptr &&  src_type->elem() != Type::BOTTOM &&\n+         dest_type != nullptr && dest_type->elem() != Type::BOTTOM, \"args are strange\");\n@@ -6939,6 +7020,4 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const Type* dest_type = dest->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  const TypeAryPtr* top_dest = dest_type->isa_aryptr();\n-  assert(top_src != NULL && top_src->elem() != Type::BOTTOM\n-         &&  top_dest != NULL && top_dest->elem() != Type::BOTTOM, \"args are strange\");\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* dest_type = dest->Value(&_gvn)->isa_aryptr();\n+  assert( src_type != nullptr &&  src_type->elem() != Type::BOTTOM &&\n+         dest_type != nullptr && dest_type->elem() != Type::BOTTOM, \"args are strange\");\n@@ -7013,6 +7092,4 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const Type* dest_type = dest->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  const TypeAryPtr* top_dest = dest_type->isa_aryptr();\n-  assert(top_src != NULL && top_src->elem() != Type::BOTTOM &&\n-         top_dest != NULL && top_dest->elem() != Type::BOTTOM, \"args are strange\");\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* dest_type = dest->Value(&_gvn)->isa_aryptr();\n+  assert( src_type != nullptr &&  src_type->elem() != Type::BOTTOM &&\n+         dest_type != nullptr && dest_type->elem() != Type::BOTTOM, \"args are strange\");\n@@ -7452,3 +7529,2 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  if (src_type == nullptr || src_type->elem() == Type::BOTTOM) {\n@@ -7459,1 +7535,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType src_elem = src_type->elem()->array_element_basic_type();\n@@ -7544,3 +7620,2 @@\n-  const Type* src_type = src->Value(&_gvn);\n-  const TypeAryPtr* top_src = src_type->isa_aryptr();\n-  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n+  const TypeAryPtr* src_type = src->Value(&_gvn)->isa_aryptr();\n+  if (src_type == nullptr || src_type->elem() == Type::BOTTOM) {\n@@ -7551,1 +7626,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType src_elem = src_type->elem()->array_element_basic_type();\n@@ -7682,9 +7757,6 @@\n-  const Type* in_type = in->Value(&_gvn);\n-  const Type* ct_type = ct->Value(&_gvn);\n-  const Type* out_type = out->Value(&_gvn);\n-  const TypeAryPtr* top_in = in_type->isa_aryptr();\n-  const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n-  const TypeAryPtr* top_out = out_type->isa_aryptr();\n-  assert(top_in != NULL && top_in->elem() != Type::BOTTOM &&\n-         top_ct != NULL && top_ct->elem() != Type::BOTTOM &&\n-         top_out != NULL && top_out->elem() != Type::BOTTOM, \"args are strange\");\n+  const TypeAryPtr* in_type = in->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* ct_type = ct->Value(&_gvn)->isa_aryptr();\n+  const TypeAryPtr* out_type = out->Value(&_gvn)->isa_aryptr();\n+  assert( in_type != nullptr &&  in_type->elem() != Type::BOTTOM &&\n+          ct_type != nullptr &&  ct_type->elem() != Type::BOTTOM &&\n+         out_type != nullptr && out_type->elem() != Type::BOTTOM, \"args are strange\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":256,"deletions":184,"binary":false,"changes":440,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,0 +218,1 @@\n+  bool inline_vectorizedHashCode();\n@@ -291,0 +292,5 @@\n+  static CallStaticJavaNode* get_uncommon_trap_from_success_proj(Node* node);\n+  SafePointNode* create_safepoint_with_state_before_array_allocation(const AllocateArrayNode* alloc) const;\n+  void replace_unrelated_uncommon_traps_with_alloc_state(AllocateArrayNode* alloc, JVMState* saved_jvms_before_guards);\n+  void replace_unrelated_uncommon_traps_with_alloc_state(JVMState* saved_jvms_before_guards);\n+  void create_new_uncommon_trap(CallStaticJavaNode* uncommon_trap_call);\n@@ -292,1 +298,1 @@\n-  void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,\n+  void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms_before_guards, int saved_reexecute_sp,\n@@ -377,0 +383,1 @@\n+  bool inline_index_partially_in_upper_range();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,8 +75,7 @@\n-         HasRangeChecks      = 1<<13,\n-         IsMultiversioned    = 1<<14,\n-         StripMined          = 1<<15,\n-         SubwordLoop         = 1<<16,\n-         ProfileTripFailed   = 1<<17,\n-         LoopNestInnerLoop   = 1<< 18,\n-         LoopNestLongOuterLoop = 1<< 19,\n-         FlattenedArrays     = 1<<20};\n+         IsMultiversioned    = 1<<13,\n+         StripMined          = 1<<14,\n+         SubwordLoop         = 1<<15,\n+         ProfileTripFailed   = 1<<16,\n+         LoopNestInnerLoop   = 1<< 17,\n+         LoopNestLongOuterLoop = 1<< 18,\n+         FlattenedArrays     = 1<<19};\n@@ -87,1 +86,1 @@\n-  enum { LoopNotRCEChecked = 0, LoopRCEChecked = 1, RCEPostLoop = 2 };\n+  enum { RCEPostLoop = 1 };\n@@ -99,1 +98,0 @@\n-  bool range_checks_present() const { return _loop_flags & HasRangeChecks; }\n@@ -119,2 +117,0 @@\n-  void mark_has_range_checks() { _loop_flags |=  HasRangeChecks; }\n-  void clear_has_range_checks() { _loop_flags &= ~HasRangeChecks; }\n@@ -133,2 +129,0 @@\n-  int has_been_range_checked() const { return _postloop_flags & LoopRCEChecked; }\n-  void set_has_been_range_checked() { _postloop_flags |= LoopRCEChecked; }\n@@ -628,1 +622,3 @@\n-          _rce_candidate:1;     \/\/ True if candidate for range check elimination\n+          _rce_candidate:1,     \/\/ True if candidate for range check elimination\n+          _has_range_checks:1,\n+          _has_range_checks_computed:1;\n@@ -640,0 +636,1 @@\n+      _has_range_checks(0), _has_range_checks_computed(0),\n@@ -787,0 +784,11 @@\n+  bool compute_has_range_checks() const;\n+  bool range_checks_present() {\n+    if (!_has_range_checks_computed) {\n+      if (compute_has_range_checks()) {\n+        _has_range_checks = 1;\n+      }\n+      _has_range_checks_computed = 1;\n+    }\n+    return _has_range_checks;\n+  }\n+\n@@ -788,2 +796,2 @@\n-  void dump_head() const;       \/\/ Dump loop head only\n-  void dump() const;            \/\/ Dump this loop recursively\n+  void dump_head();       \/\/ Dump loop head only\n+  void dump();            \/\/ Dump this loop recursively\n@@ -1071,0 +1079,6 @@\n+#ifdef ASSERT\n+  \/\/ verify that regions in irreducible loops are marked is_in_irreducible_loop\n+  void verify_regions_in_irreducible_loops();\n+  bool is_in_irreducible_loop(RegionNode* region);\n+#endif\n+\n@@ -1431,4 +1445,1 @@\n-  int do_range_check( IdealLoopTree *loop, Node_List &old_new );\n-\n-  \/\/ Check to see if do_range_check(...) cleaned the main loop of range-checks\n-  void has_range_checks(IdealLoopTree *loop);\n+  void do_range_check(IdealLoopTree *loop, Node_List &old_new);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2334,0 +2334,4 @@\n+      assert(use->in(idx) == old, \"old is still input of use\");\n+      \/\/ We notify all uses of old, including use, and the indirect uses,\n+      \/\/ that may now be optimized because we have replaced old with phi.\n+      _igvn.add_users_to_worklist(old);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1102,0 +1102,1 @@\n+    case Op_VectorizedHashCode:\n@@ -2288,0 +2289,1 @@\n+    case Op_VectorizedHashCode:\n@@ -2427,6 +2429,0 @@\n-    case Op_VectorCmpMasked: {\n-      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n-      n->set_req(2, pair1);\n-      n->del_req(3);\n-      break;\n-    }\n@@ -2464,1 +2460,2 @@\n-    case Op_StrIndexOf: {\n+    case Op_StrIndexOf:\n+    case Op_VectorizedHashCode: {\n@@ -2473,0 +2470,1 @@\n+    case Op_EncodeISOArray:\n@@ -2474,2 +2472,1 @@\n-    case Op_StrInflatedCopy:\n-    case Op_EncodeISOArray: {\n+    case Op_StrInflatedCopy: {\n@@ -2509,0 +2506,1 @@\n+    case Op_VectorCmpMasked:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -193,0 +193,2 @@\n+      } else if (proj_in->is_top()) {\n+        break; \/\/ dead code\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -747,0 +747,4 @@\n+bool Node::is_not_dead(const Node* n) {\n+  return n == nullptr || !PhaseIterGVN::is_verify_def_use() || !(n->is_dead());\n+}\n+\n@@ -1154,1 +1158,1 @@\n-\/\/ these Ideal calls need to hold.  Running with '+VerifyIterativeGVN' checks\n+\/\/ these Ideal calls need to hold.  Running with '-XX:VerifyIterativeGVN=1' checks\n@@ -1156,1 +1160,1 @@\n-\/\/ hacking an Ideal call, be sure to test with +VerifyIterativeGVN!\n+\/\/ hacking an Ideal call, be sure to test with '-XX:VerifyIterativeGVN=1'\n@@ -1389,0 +1393,1 @@\n+  VectorSet dead_set; \/\/ notify uses only once\n@@ -1396,0 +1401,4 @@\n+    if (!dead_set.test_set(dead->_idx)) {\n+      \/\/ If dead has any live uses, those are now still attached. Notify them before we lose them.\n+      igvn->add_users_to_worklist(dead);\n+    }\n@@ -2286,1 +2295,1 @@\n-    sprintf(buf,\"_\");           \/\/ null\n+    os::snprintf_checked(buf, sizeof(buf), \"_\");           \/\/ null\n@@ -2288,1 +2297,1 @@\n-    sprintf(buf, \"%d\", n->_idx);  \/\/ new node\n+    os::snprintf_checked(buf, sizeof(buf), \"%d\", n->_idx);  \/\/ new node\n@@ -2290,1 +2299,1 @@\n-    sprintf(buf, \"o%d\", n->_idx); \/\/ old node\n+    os::snprintf_checked(buf, sizeof(buf), \"o%d\", n->_idx); \/\/ old node\n@@ -2298,1 +2307,1 @@\n-  sprintf(buf, \"B%d\", b->_pre_order);\n+  os::snprintf_checked(buf, sizeof(buf), \"B%d\", b->_pre_order);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+class ConINode;\n@@ -418,1 +419,1 @@\n-#define is_not_dead(n) ((n) == NULL || !VerifyIterativeGVN || !((n)->is_dead()))\n+  static bool is_not_dead(const Node* n);\n@@ -722,0 +723,3 @@\n+      DEFINE_CLASS_ID(Con, Type, 9)\n+          DEFINE_CLASS_ID(ConI, Con, 0)\n+\n@@ -875,0 +879,1 @@\n+  DEFINE_CLASS_QUERY(ConI)\n@@ -1054,1 +1059,1 @@\n-  \/\/ +VerifyIterativeGVN!\n+  \/\/ -XX:VerifyIterativeGVN=1\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -417,1 +417,1 @@\n-          (C->has_java_calls() || frame_size_in_bytes > os::vm_page_size()>>3\n+          (C->has_java_calls() || frame_size_in_bytes > (int)(os::vm_page_size())>>3\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-                            NOT_PRODUCT_ARG(bool& should_delay)\n+                            bool& should_delay,\n@@ -84,1 +84,1 @@\n-                                NOT_PRODUCT_ARG(bool& should_delay)\n+                                bool& should_delay,\n@@ -225,0 +225,23 @@\n+    bool is_in_irreducible_loop() const {\n+      return flow()->is_in_irreducible_loop();\n+    }\n+    bool is_irreducible_loop_entry() const {\n+      return flow()->is_irreducible_loop_head() || flow()->is_irreducible_loop_secondary_entry();\n+    }\n+    void copy_irreducible_status_to(RegionNode* region, const JVMState* jvms) {\n+      assert(!is_irreducible_loop_entry() || is_in_irreducible_loop(), \"entry is part of irreducible loop\");\n+      if (is_in_irreducible_loop()) {\n+        \/\/ The block is in an irreducible loop of this method, so it is possible that this\n+        \/\/ region becomes an irreducible loop entry. (no guarantee)\n+        region->set_loop_status(RegionNode::LoopStatus::MaybeIrreducibleEntry);\n+      } else if (jvms->caller() != nullptr) {\n+        \/\/ The block is not in an irreducible loop of this method, hence it cannot ever\n+        \/\/ be the entry of an irreducible loop. But it may be inside an irreducible loop\n+        \/\/ of a caller of this inlined method. (limited guarantee)\n+        assert(region->loop_status() == RegionNode::LoopStatus::NeverIrreducibleEntry, \"status not changed\");\n+      } else {\n+        \/\/ The block is not in an irreducible loop of this method, and there is no outer\n+        \/\/ method. This region will never be in an irreducible loop (strong guarantee)\n+        region->set_loop_status(RegionNode::LoopStatus::Reducible);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -552,1 +552,0 @@\n-  gvn().set_type(root(), root()->bottom_type());\n@@ -708,0 +707,1 @@\n+          block->copy_irreducible_status_to(r, jvms());\n@@ -1573,1 +1573,6 @@\n-    if (b->is_loop_head()) tty->print(\"  lphd\");\n+    if (b->is_loop_head()) {\n+      tty->print(\"  lphd\");\n+    }\n+    if (b->is_irreducible_loop_entry()) {\n+      tty->print(\"  irreducible\");\n+    }\n@@ -1798,0 +1803,1 @@\n+      target->copy_irreducible_status_to(r, jvms());\n@@ -1836,1 +1842,1 @@\n-      if (!block()->flow()->is_irreducible_entry()) {\n+      if (!block()->flow()->is_irreducible_loop_secondary_entry()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -377,1 +377,1 @@\n-  if (GenerateRangeChecks && need_range_check) {\n+  if (need_range_check) {\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -942,1 +942,1 @@\n-    if (!no_dead_loop) n->dump(3);\n+    if (!no_dead_loop) n->dump_bfs(100,0,\"#\");\n@@ -1021,1 +1021,1 @@\n-  if (VerifyIterativeGVN) {\n+  if (is_verify_def_use()) {\n@@ -1132,1 +1132,1 @@\n-  if (VerifyIterativeGVN && PrintOpto) {\n+  if (is_verify_def_use() && PrintOpto) {\n@@ -1150,0 +1150,2 @@\n+\n+  verify_optimize();\n@@ -1213,0 +1215,91 @@\n+#ifdef ASSERT\n+void PhaseIterGVN::verify_optimize() {\n+  if (is_verify_Value()) {\n+    ResourceMark rm;\n+    Unique_Node_List worklist;\n+    bool failure = false;\n+    \/\/ BFS all nodes, starting at root\n+    worklist.push(C->root());\n+    for (uint j = 0; j < worklist.size(); ++j) {\n+      Node* n = worklist.at(j);\n+      failure |= verify_node_value(n);\n+      \/\/ traverse all inputs and outputs\n+      for (uint i = 0; i < n->req(); i++) {\n+        if (n->in(i) != nullptr) {\n+          worklist.push(n->in(i));\n+        }\n+      }\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        worklist.push(n->fast_out(i));\n+      }\n+    }\n+    \/\/ If we get this assert, check why the reported nodes were not processed again in IGVN.\n+    \/\/ We should either make sure that these nodes are properly added back to the IGVN worklist\n+    \/\/ in PhaseIterGVN::add_users_to_worklist to update them again or add an exception\n+    \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+    assert(!failure, \"Missed optimization opportunity in PhaseIterGVN\");\n+  }\n+}\n+\n+\/\/ Check that type(n) == n->Value(), return true if we have a failure.\n+\/\/ We have a list of exceptions, see detailed comments in code.\n+\/\/ (1) Integer \"widen\" changes, but the range is the same.\n+\/\/ (2) LoadNode performs deep traversals. Load is not notified for changes far away.\n+\/\/ (3) CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+bool PhaseIterGVN::verify_node_value(Node* n) {\n+  \/\/ If we assert inside type(n), because the type is still a nullptr, then maybe\n+  \/\/ the node never went through gvn.transform, which would be a bug.\n+  const Type* told = type(n);\n+  const Type* tnew = n->Value(this);\n+  if (told == tnew) {\n+    return false;\n+  }\n+  \/\/ Exception (1)\n+  \/\/ Integer \"widen\" changes, but range is the same.\n+  if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n+    const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n+    const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n+    if (t0->lo_as_long() == t1->lo_as_long() &&\n+        t0->hi_as_long() == t1->hi_as_long()) {\n+      return false; \/\/ ignore integer widen\n+    }\n+  }\n+  \/\/ Exception (2)\n+  \/\/ LoadNode performs deep traversals. Load is not notified for changes far away.\n+  if (n->is_Load() && !told->singleton()) {\n+    \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n+    \/\/ which means we would need to notify modifications from far up in\n+    \/\/ the inputs all the way down to the LoadNode. We don't do that.\n+    return false;\n+  }\n+  \/\/ Exception (3)\n+  \/\/ CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+    \/\/ SubNode::Value\n+    \/\/ CmpPNode::sub\n+    \/\/ MemNode::detect_ptr_independence\n+    \/\/ MemNode::all_controls_dominate\n+    \/\/ We find all controls of a pointer load, and see if they dominate the control of\n+    \/\/ an allocation. If they all dominate, we know the allocation is after (independent)\n+    \/\/ of the pointer load, and we can say the pointers are different. For this we call\n+    \/\/ n->dominates(sub, nlist) to check if controls n of the pointer load dominate the\n+    \/\/ control sub of the allocation. The problems is that sometimes dominates answers\n+    \/\/ false conservatively, and later it can determine that it is indeed true. Loops with\n+    \/\/ Region heads can lead to giving up, whereas LoopNodes can be skipped easier, and\n+    \/\/ so the traversal becomes more powerful. This is difficult to remidy, we would have\n+    \/\/ to notify the CmpP of CFG updates. Luckily, we recompute CmpP::Value during CCP\n+    \/\/ after loop-opts, so that should take care of many of these cases.\n+    return false;\n+  }\n+  tty->cr();\n+  tty->print_cr(\"Missed Value optimization:\");\n+  n->dump_bfs(1, 0, \"\");\n+  tty->print_cr(\"Current type:\");\n+  told->dump_on(tty);\n+  tty->cr();\n+  tty->print_cr(\"Optimized type:\");\n+  tnew->dump_on(tty);\n+  tty->cr();\n+  return true;\n+}\n+#endif\n@@ -1247,1 +1340,2 @@\n-  if (VerifyIterativeGVN) {\n+#ifdef ASSERT\n+  if (is_verify_def_use()) {\n@@ -1250,0 +1344,1 @@\n+#endif\n@@ -1497,1 +1592,1 @@\n-  if( VerifyIterativeGVN ) {\n+  if (is_verify_def_use()) {\n@@ -1591,2 +1686,2 @@\n-      if (use_op == Op_CmpI) {\n-        Node* phi = countedloop_phi_from_cmp((CmpINode*)use, n);\n+      if (use_op == Op_CmpI || use_op == Op_CmpL) {\n+        Node* phi = countedloop_phi_from_cmp(use->as_Cmp(), n);\n@@ -1594,5 +1689,3 @@\n-          \/\/ If an opaque node feeds into the limit condition of a\n-          \/\/ CountedLoop, we need to process the Phi node for the\n-          \/\/ induction variable when the opaque node is removed:\n-          \/\/ the range of values taken by the Phi is now known and\n-          \/\/ so its type is also known.\n+          \/\/ Input to the cmp of a loop exit check has changed, thus\n+          \/\/ the loop limit may have changed, which can then change the\n+          \/\/ range values of the trip-count Phi.\n@@ -1601,12 +1694,61 @@\n-        Node* in1 = use->in(1);\n-        for (uint i = 0; i < in1->outcnt(); i++) {\n-          if (in1->raw_out(i)->Opcode() == Op_CastII) {\n-            Node* castii = in1->raw_out(i);\n-            if (castii->in(0) != NULL && castii->in(0)->in(0) != NULL && castii->in(0)->in(0)->is_If()) {\n-              Node* ifnode = castii->in(0)->in(0);\n-              if (ifnode->in(1) != NULL && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == use) {\n-                \/\/ Reprocess a CastII node that may depend on an\n-                \/\/ opaque node value when the opaque node is\n-                \/\/ removed. In case it carries a dependency we can do\n-                \/\/ a better job of computing its type.\n-                _worklist.push(castii);\n+      }\n+      if (use_op == Op_CmpI) {\n+        Node* cmp = use;\n+        Node* in1 = cmp->in(1);\n+        Node* in2 = cmp->in(2);\n+        \/\/ Notify CmpI \/ If pattern from CastIINode::Value (left pattern).\n+        \/\/ Must also notify if in1 is modified and possibly turns into X (right pattern).\n+        \/\/\n+        \/\/ in1  in2                   in1  in2\n+        \/\/  |    |                     |    |\n+        \/\/  +--- | --+                 |    |\n+        \/\/  |    |   |                 |    |\n+        \/\/ CmpINode  |                CmpINode\n+        \/\/    |      |                   |\n+        \/\/ BoolNode  |                BoolNode\n+        \/\/    |      |        OR         |\n+        \/\/  IfNode   |                 IfNode\n+        \/\/    |      |                   |\n+        \/\/  IfProj   |                 IfProj   X\n+        \/\/    |      |                   |      |\n+        \/\/   CastIINode                 CastIINode\n+        \/\/\n+        if (in1 != in2) { \/\/ if they are equal, the CmpI can fold them away\n+          if (in1 == n) {\n+            \/\/ in1 modified -> could turn into X -> do traversal based on right pattern.\n+            for (DUIterator_Fast i2max, i2 = cmp->fast_outs(i2max); i2 < i2max; i2++) {\n+              Node* bol = cmp->fast_out(i2); \/\/ For each Bool\n+              if (bol->is_Bool()) {\n+                for (DUIterator_Fast i3max, i3 = bol->fast_outs(i3max); i3 < i3max; i3++) {\n+                  Node* iff = bol->fast_out(i3); \/\/ For each If\n+                  if (iff->is_If()) {\n+                    for (DUIterator_Fast i4max, i4 = iff->fast_outs(i4max); i4 < i4max; i4++) {\n+                      Node* if_proj = iff->fast_out(i4); \/\/ For each IfProj\n+                      assert(if_proj->is_IfProj(), \"If only has IfTrue and IfFalse as outputs\");\n+                      for (DUIterator_Fast i5max, i5 = if_proj->fast_outs(i5max); i5 < i5max; i5++) {\n+                        Node* castii = if_proj->fast_out(i5); \/\/ For each CastII\n+                        if (castii->is_CastII() &&\n+                            castii->as_CastII()->carry_dependency()) {\n+                          _worklist.push(castii);\n+                        }\n+                      }\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          } else {\n+            \/\/ Only in2 modified -> can assume X == in2 (left pattern).\n+            assert(n == in2, \"only in2 modified\");\n+            \/\/ Find all CastII with input in1.\n+            for (DUIterator_Fast jmax, j = in1->fast_outs(jmax); j < jmax; j++) {\n+              Node* castii = in1->fast_out(j);\n+              if (castii->is_CastII() && castii->as_CastII()->carry_dependency()) {\n+                \/\/ Find If.\n+                if (castii->in(0) != nullptr && castii->in(0)->in(0) != nullptr && castii->in(0)->in(0)->is_If()) {\n+                  Node* ifnode = castii->in(0)->in(0);\n+                  \/\/ Check that if connects to the cmp\n+                  if (ifnode->in(1) != nullptr && ifnode->in(1)->is_Bool() && ifnode->in(1)->in(1) == cmp) {\n+                    _worklist.push(castii);\n+                  }\n+                }\n@@ -1629,1 +1771,1 @@\n-    \/\/ If changed Cast input, check Phi users for simple cycles\n+    \/\/ If changed Cast input, notify down for Phi and Sub - both do \"uncast\"\n@@ -1633,1 +1775,2 @@\n-        if (u->is_Phi())\n+        if (u->is_Phi() || u->is_Sub()) {\n+          \/\/ Phi (.., CastII, ..) or Sub(Cast(x), x)\n@@ -1635,0 +1778,18 @@\n+        } else if (u->is_ConstraintCast()) {\n+          \/\/ Follow cast-chains down to Sub: Sub( CastII(CastII(x)), x)\n+          \/\/ This case is quite rare. Let's BFS-traverse casts, to find Subs:\n+          ResourceMark rm;\n+          Unique_Node_List casts;\n+          casts.push(u); \/\/ start traversal\n+          for (uint j = 0; j < casts.size(); ++j) {\n+            Node* cast = casts.at(j); \/\/ for every cast\n+            for (DUIterator_Fast kmax, k = cast->fast_outs(kmax); k < kmax; k++) {\n+              Node* cast_use = cast->fast_out(k);\n+              if (cast_use->is_ConstraintCast()) {\n+                casts.push(cast_use); \/\/ traverse this cast also\n+              } else if (cast_use->is_Sub()) {\n+                _worklist.push(cast_use); \/\/ found Sub\n+              }\n+            }\n+          }\n+        }\n@@ -1645,0 +1806,9 @@\n+    \/\/ If changed LShift inputs, check And users for shift and mask (And) operation\n+    if (use_op == Op_LShiftI || use_op == Op_LShiftL) {\n+      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+        Node* u = use->fast_out(i2);\n+        if (u->Opcode() == Op_AndI || u->Opcode() == Op_AndL) {\n+          _worklist.push(u);\n+        }\n+      }\n+    }\n@@ -1803,11 +1973,6 @@\n-static bool ccp_type_widens(const Type* t, const Type* t0) {\n-  assert(t->meet(t0) == t->remove_speculative(), \"Not monotonic\");\n-  switch (t->base() == t0->base() ? t->base() : Type::Top) {\n-  case Type::Int:\n-    assert(t0->isa_int()->_widen <= t->isa_int()->_widen, \"widen increases\");\n-    break;\n-  case Type::Long:\n-    assert(t0->isa_long()->_widen <= t->isa_long()->_widen, \"widen increases\");\n-    break;\n-  default:\n-    break;\n+void PhaseCCP::verify_type(Node* n, const Type* tnew, const Type* told) {\n+  if (tnew->meet(told) != tnew->remove_speculative()) {\n+    n->dump(1);\n+    tty->print(\"told = \"); told->dump(); tty->cr();\n+    tty->print(\"tnew = \"); tnew->dump(); tty->cr();\n+    fatal(\"Not monotonic\");\n@@ -1815,1 +1980,2 @@\n-  return true;\n+  assert(!told->isa_int() || !tnew->isa_int() || told->is_int()->_widen <= tnew->is_int()->_widen, \"widen increases\");\n+  assert(!told->isa_long() || !tnew->isa_long() || told->is_long()->_widen <= tnew->is_long()->_widen, \"widen increases\");\n@@ -1850,1 +2016,1 @@\n-      assert(ccp_type_widens(new_type, type(n)), \"ccp type must widen\");\n+      DEBUG_ONLY(verify_type(n, new_type, type(n));)\n@@ -1861,1 +2027,1 @@\n-\/\/ We have a list of exceptions, see comments in code.\n+\/\/ We have a list of exceptions, see comments in verify_node_value.\n@@ -1866,29 +2032,1 @@\n-    const Type* told = type(n);\n-    const Type* tnew = n->Value(this);\n-    if (told != tnew) {\n-      \/\/ Check special cases that are ok\n-      if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n-        const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n-        const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n-        if (t0->lo_as_long() == t1->lo_as_long() &&\n-            t0->hi_as_long() == t1->hi_as_long()) {\n-          continue; \/\/ ignore integer widen\n-        }\n-      }\n-      if (n->is_Load()) {\n-        \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n-        \/\/ which means we would need to notify modifications from far up in\n-        \/\/ the inputs all the way down to the LoadNode. We don't do that.\n-        continue;\n-      }\n-      tty->cr();\n-      tty->print_cr(\"Missed optimization (PhaseCCP):\");\n-      n->dump_bfs(1, 0, \"\");\n-      tty->print_cr(\"Current type:\");\n-      told->dump_on(tty);\n-      tty->cr();\n-      tty->print_cr(\"Optimized type:\");\n-      tnew->dump_on(tty);\n-      tty->cr();\n-      failure = true;\n-    }\n+    failure |= verify_node_value(n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":208,"deletions":70,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -338,0 +338,3 @@\n+  virtual const Type* saturate_and_maybe_push_to_igvn_worklist(const TypeNode* n, const Type* new_type) {\n+    return saturate(new_type, type_or_null(n), n->type());\n+  }\n@@ -479,0 +482,4 @@\n+#ifdef ASSERT\n+  void verify_optimize();\n+  bool verify_node_value(Node* n);\n+#endif\n@@ -569,0 +576,8 @@\n+  static bool is_verify_def_use() {\n+    \/\/ '-XX:VerifyIterativeGVN=1'\n+    return (VerifyIterativeGVN % 10) == 1;\n+  }\n+  static bool is_verify_Value() {\n+    \/\/ '-XX:VerifyIterativeGVN=10'\n+    return ((VerifyIterativeGVN % 100) \/ 10) == 1;\n+  }\n@@ -570,1 +585,1 @@\n-  \/\/ Sub-quadratic implementation of VerifyIterativeGVN.\n+  \/\/ Sub-quadratic implementation of '-XX:VerifyIterativeGVN=1' (Use-Def verification).\n@@ -611,0 +626,1 @@\n+  void verify_type(Node* n, const Type* tnew, const Type* told);\n@@ -624,0 +640,8 @@\n+  virtual const Type* saturate_and_maybe_push_to_igvn_worklist(const TypeNode* n, const Type* new_type) {\n+    const Type* t = saturate(new_type, type_or_null(n), n->type());\n+    if (t != new_type) {\n+      \/\/ Type was widened in CCP, but IGVN may be able to make it narrower.\n+      _worklist.push((Node*)n);\n+    }\n+    return t;\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -783,0 +783,3 @@\n+\n+  const Type* t_sub = sub(t1, t2); \/\/ compare based on immediate inputs\n+\n@@ -835,2 +838,4 @@\n-        \/\/ compute union, so that cmp handles all possible results from the two cases\n-        return cmp1->meet(cmp2);\n+        \/\/ Compute union, so that cmp handles all possible results from the two cases\n+        const Type* t_cmp = cmp1->meet(cmp2);\n+        \/\/ Pick narrowest type, based on overflow computation and on immediate inputs\n+        return t_sub->filter(t_cmp);\n@@ -841,1 +846,1 @@\n-  return sub(t1, t2);            \/\/ Local flavor of type subtraction\n+  return t_sub;\n@@ -1252,1 +1257,1 @@\n-  this->set_req(1,ldk2);\n+  this->set_req_X(1, ldk2, phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -191,9 +191,0 @@\n-    Node* subklass = NULL;\n-    if (sub_t->isa_oopptr()) {\n-      Node* adr = phase->transform(new AddPNode(obj_or_subklass, obj_or_subklass, phase->MakeConX(oopDesc::klass_offset_in_bytes())));\n-      subklass  = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), adr, TypeInstPtr::KLASS));\n-      record_for_cleanup(subklass, phase);\n-    } else {\n-      subklass = obj_or_subklass;\n-    }\n-\n@@ -203,1 +194,1 @@\n-        return verify_helper(phase, subklass, cached_t);\n+        return verify_helper(phase, load_klass(phase), cached_t);\n@@ -213,0 +204,1 @@\n+          Node* subklass = load_klass(phase);\n@@ -234,0 +226,15 @@\n+\n+Node* SubTypeCheckNode::load_klass(PhaseGVN* phase) const {\n+  Node* obj_or_subklass = in(ObjOrSubKlass);\n+  const Type* sub_t = phase->type(obj_or_subklass);\n+  Node* subklass = NULL;\n+  if (sub_t->isa_oopptr()) {\n+    Node* adr = phase->transform(new AddPNode(obj_or_subklass, obj_or_subklass, phase->MakeConX(oopDesc::klass_offset_in_bytes())));\n+    subklass  = phase->transform(LoadKlassNode::make(*phase, NULL, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+    record_for_cleanup(subklass, phase);\n+  } else {\n+    subklass = obj_or_subklass;\n+  }\n+  return subklass;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -850,2 +850,148 @@\n-void Type::check_symmetrical(const Type* t, const Type* mt) const {\n-  const Type* mt2 = t->xmeet(this);\n+class VerifyMeet;\n+class VerifyMeetResult : public ArenaObj {\n+  friend class VerifyMeet;\n+  friend class Type;\n+private:\n+  class VerifyMeetResultEntry {\n+  private:\n+    const Type* _in1;\n+    const Type* _in2;\n+    const Type* _res;\n+  public:\n+    VerifyMeetResultEntry(const Type* in1, const Type* in2, const Type* res):\n+            _in1(in1), _in2(in2), _res(res) {\n+    }\n+    VerifyMeetResultEntry():\n+            _in1(NULL), _in2(NULL), _res(NULL) {\n+    }\n+\n+    bool operator==(const VerifyMeetResultEntry& rhs) const {\n+      return _in1 == rhs._in1 &&\n+             _in2 == rhs._in2 &&\n+             _res == rhs._res;\n+    }\n+\n+    bool operator!=(const VerifyMeetResultEntry& rhs) const {\n+      return !(rhs == *this);\n+    }\n+\n+    static int compare(const VerifyMeetResultEntry& v1, const VerifyMeetResultEntry& v2) {\n+      if ((intptr_t) v1._in1 < (intptr_t) v2._in1) {\n+        return -1;\n+      } else if (v1._in1 == v2._in1) {\n+        if ((intptr_t) v1._in2 < (intptr_t) v2._in2) {\n+          return -1;\n+        } else if (v1._in2 == v2._in2) {\n+          assert(v1._res == v2._res || v1._res == NULL || v2._res == NULL, \"same inputs should lead to same result\");\n+          return 0;\n+        }\n+        return 1;\n+      }\n+      return 1;\n+    }\n+    const Type* res() const { return _res; }\n+  };\n+  uint _depth;\n+  GrowableArray<VerifyMeetResultEntry> _cache;\n+\n+  \/\/ With verification code, the meet of A and B causes the computation of:\n+  \/\/ 1- meet(A, B)\n+  \/\/ 2- meet(B, A)\n+  \/\/ 3- meet(dual(meet(A, B)), dual(A))\n+  \/\/ 4- meet(dual(meet(A, B)), dual(B))\n+  \/\/ 5- meet(dual(A), dual(B))\n+  \/\/ 6- meet(dual(B), dual(A))\n+  \/\/ 7- meet(dual(meet(dual(A), dual(B))), A)\n+  \/\/ 8- meet(dual(meet(dual(A), dual(B))), B)\n+  \/\/\n+  \/\/ In addition the meet of A[] and B[] requires the computation of the meet of A and B.\n+  \/\/\n+  \/\/ The meet of A[] and B[] triggers the computation of:\n+  \/\/ 1- meet(A[], B[][)\n+  \/\/   1.1- meet(A, B)\n+  \/\/   1.2- meet(B, A)\n+  \/\/   1.3- meet(dual(meet(A, B)), dual(A))\n+  \/\/   1.4- meet(dual(meet(A, B)), dual(B))\n+  \/\/   1.5- meet(dual(A), dual(B))\n+  \/\/   1.6- meet(dual(B), dual(A))\n+  \/\/   1.7- meet(dual(meet(dual(A), dual(B))), A)\n+  \/\/   1.8- meet(dual(meet(dual(A), dual(B))), B)\n+  \/\/ 2- meet(B[], A[])\n+  \/\/   2.1- meet(B, A) = 1.2\n+  \/\/   2.2- meet(A, B) = 1.1\n+  \/\/   2.3- meet(dual(meet(B, A)), dual(B)) = 1.4\n+  \/\/   2.4- meet(dual(meet(B, A)), dual(A)) = 1.3\n+  \/\/   2.5- meet(dual(B), dual(A)) = 1.6\n+  \/\/   2.6- meet(dual(A), dual(B)) = 1.5\n+  \/\/   2.7- meet(dual(meet(dual(B), dual(A))), B) = 1.8\n+  \/\/   2.8- meet(dual(meet(dual(B), dual(A))), B) = 1.7\n+  \/\/ etc.\n+  \/\/ The number of meet operations performed grows exponentially with the number of dimensions of the arrays but the number\n+  \/\/ of different meet operations is linear in the number of dimensions. The function below caches meet results for the\n+  \/\/ duration of the meet at the root of the recursive calls.\n+  \/\/\n+  const Type* meet(const Type* t1, const Type* t2) {\n+    bool found = false;\n+    const VerifyMeetResultEntry meet(t1, t2, NULL);\n+    int pos = _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+    const Type* res = NULL;\n+    if (found) {\n+      res = _cache.at(pos).res();\n+    } else {\n+      res = t1->xmeet(t2);\n+      _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+      found = false;\n+      _cache.find_sorted<VerifyMeetResultEntry, VerifyMeetResultEntry::compare>(meet, found);\n+      assert(found, \"should be in table after it's added\");\n+    }\n+    return res;\n+  }\n+\n+  void add(const Type* t1, const Type* t2, const Type* res) {\n+    _cache.insert_sorted<VerifyMeetResultEntry::compare>(VerifyMeetResultEntry(t1, t2, res));\n+  }\n+\n+  bool empty_cache() const {\n+    return _cache.length() == 0;\n+  }\n+public:\n+  VerifyMeetResult(Compile* C) :\n+          _depth(0), _cache(C->comp_arena(), 2, 0, VerifyMeetResultEntry()) {\n+  }\n+};\n+\n+void Type::assert_type_verify_empty() const {\n+  assert(Compile::current()->_type_verify == NULL || Compile::current()->_type_verify->empty_cache(), \"cache should have been discarded\");\n+}\n+\n+class VerifyMeet {\n+private:\n+  Compile* _C;\n+public:\n+  VerifyMeet(Compile* C) : _C(C) {\n+    if (C->_type_verify == NULL) {\n+      C->_type_verify = new (C->comp_arena())VerifyMeetResult(C);\n+    }\n+    _C->_type_verify->_depth++;\n+  }\n+\n+  ~VerifyMeet() {\n+    assert(_C->_type_verify->_depth != 0, \"\");\n+    _C->_type_verify->_depth--;\n+    if (_C->_type_verify->_depth == 0) {\n+      _C->_type_verify->_cache.trunc_to(0);\n+    }\n+  }\n+\n+  const Type* meet(const Type* t1, const Type* t2) const {\n+    return _C->_type_verify->meet(t1, t2);\n+  }\n+\n+  void add(const Type* t1, const Type* t2, const Type* res) const {\n+    _C->_type_verify->add(t1, t2, res);\n+  }\n+};\n+\n+void Type::check_symmetrical(const Type* t, const Type* mt, const VerifyMeet& verify) const {\n+  Compile* C = Compile::current();\n+  const Type* mt2 = verify.meet(t, this);\n@@ -862,2 +1008,2 @@\n-  const Type* t2t    = dual_join->xmeet(t->_dual);\n-  const Type* t2this = dual_join->xmeet(this->_dual);\n+  const Type* t2t    = verify.meet(dual_join,t->_dual);\n+  const Type* t2this = verify.meet(dual_join,this->_dual);\n@@ -884,1 +1030,1 @@\n-#endif\n+#endif\n@@ -900,0 +1046,5 @@\n+#ifdef ASSERT\n+  Compile* C = Compile::current();\n+  VerifyMeet verify(C);\n+#endif\n+\n@@ -905,4 +1056,5 @@\n-  if (isa_narrowoop() || t->isa_narrowoop()) return mt;\n-  if (isa_narrowklass() || t->isa_narrowklass()) return mt;\n-  Compile* C = Compile::current();\n-  if (!C->_type_verify_symmetry) {\n+  verify.add(this_t, t, mt);\n+  if (isa_narrowoop() || t->isa_narrowoop()) {\n+    return mt;\n+  }\n+  if (isa_narrowklass() || t->isa_narrowklass()) {\n@@ -911,15 +1063,3 @@\n-  this_t->check_symmetrical(t, mt);\n-  \/\/ In the case of an array, computing the meet above, caused the\n-  \/\/ computation of the meet of the elements which at verification\n-  \/\/ time caused the computation of the meet of the dual of the\n-  \/\/ elements. Computing the meet of the dual of the arrays here\n-  \/\/ causes the meet of the dual of the elements to be computed which\n-  \/\/ would cause the meet of the dual of the dual of the elements,\n-  \/\/ that is the meet of the elements already computed above to be\n-  \/\/ computed. Avoid redundant computations by requesting no\n-  \/\/ verification.\n-  C->_type_verify_symmetry = false;\n-  const Type *mt_dual = this_t->_dual->xmeet(t->_dual);\n-  this_t->_dual->check_symmetrical(t->_dual, mt_dual);\n-  assert(!C->_type_verify_symmetry, \"shouldn't have changed\");\n-  C->_type_verify_symmetry = true;\n+  this_t->check_symmetrical(t, mt, verify);\n+  const Type *mt_dual = verify.meet(this_t->_dual, t->_dual);\n+  this_t->_dual->check_symmetrical(t->_dual, mt_dual, verify);\n@@ -1701,1 +1841,1 @@\n-static const char* intname(char* buf, jint n) {\n+static const char* intname(char* buf, size_t buf_size, jint n) {\n@@ -1705,1 +1845,1 @@\n-    sprintf(buf, \"min+\" INT32_FORMAT, n - min_jint);\n+    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n@@ -1709,1 +1849,1 @@\n-    sprintf(buf, \"max-\" INT32_FORMAT, max_jint - n);\n+    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n@@ -1711,1 +1851,1 @@\n-    sprintf(buf, INT32_FORMAT, n);\n+    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n@@ -1720,1 +1860,1 @@\n-    st->print(\"int:%s\", intname(buf, get_con()));\n+    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n@@ -1730,1 +1870,1 @@\n-    st->print(\"int:>=%s\", intname(buf, _lo));\n+    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n@@ -1732,1 +1872,1 @@\n-    st->print(\"int:<=%s\", intname(buf, _hi));\n+    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n@@ -1734,1 +1874,1 @@\n-    st->print(\"int:%s..%s\", intname(buf, _lo), intname(buf2, _hi));\n+    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n@@ -1967,1 +2107,1 @@\n-static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {\n+static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n@@ -1970,1 +2110,1 @@\n-    sprintf(buf, \"%s+\" JLONG_FORMAT, xname, n - x);\n+    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n@@ -1973,1 +2113,1 @@\n-    sprintf(buf, \"%s-\" JLONG_FORMAT, xname, x - n);\n+    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n@@ -1980,1 +2120,1 @@\n-static const char* longname(char* buf, jlong n) {\n+static const char* longname(char* buf, size_t buf_size, jlong n) {\n@@ -1985,1 +2125,1 @@\n-    sprintf(buf, \"min+\" JLONG_FORMAT, n - min_jlong);\n+    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n@@ -1989,2 +2129,2 @@\n-    sprintf(buf, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, n)) != NULL)\n+    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n+  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != NULL)\n@@ -1992,1 +2132,1 @@\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != NULL)\n@@ -1994,1 +2134,1 @@\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != NULL)\n@@ -1997,1 +2137,1 @@\n-    sprintf(buf, JLONG_FORMAT, n);\n+    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n@@ -2006,1 +2146,1 @@\n-    st->print(\"long:%s\", longname(buf, get_con()));\n+    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n@@ -2008,1 +2148,1 @@\n-    st->print(\"long:>=%s\", longname(buf, _lo));\n+    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n@@ -2010,1 +2150,1 @@\n-    st->print(\"long:<=%s\", longname(buf, _hi));\n+    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n@@ -2012,1 +2152,1 @@\n-    st->print(\"long:%s..%s\", longname(buf, _lo), longname(buf2, _hi));\n+    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":187,"deletions":47,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+class VerifyMeet;\n@@ -199,1 +200,1 @@\n-  void check_symmetrical(const Type *t, const Type *mt) const;\n+  void check_symmetrical(const Type* t, const Type* mt, const VerifyMeet& verify) const NOT_DEBUG_RETURN;\n@@ -210,0 +211,1 @@\n+    assert_type_verify_empty();\n@@ -213,0 +215,2 @@\n+  void assert_type_verify_empty() const NOT_DEBUG_RETURN;\n+\n@@ -922,3 +926,3 @@\n-    int _hash_computed:1;\n-    int _exact_klass_computed:1;\n-    int _is_loaded_computed:1;\n+    uint _hash_computed:1;\n+    uint _exact_klass_computed:1;\n+    uint _is_loaded_computed:1;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,1 +202,1 @@\n-    return result != NULL && result->is_static_field_id();\n+    return result != nullptr && result->is_static_field_id();\n@@ -204,1 +204,1 @@\n-    return result != NULL;\n+    return result != nullptr;\n@@ -246,1 +246,1 @@\n-  } while (k != NULL);\n+  } while (k != nullptr);\n@@ -283,1 +283,1 @@\n-  jclass cls = NULL;\n+  jclass cls = nullptr;\n@@ -287,1 +287,1 @@\n-  TempNewSymbol class_name = name == NULL ? NULL :\n+  TempNewSymbol class_name = name == nullptr ? nullptr :\n@@ -292,1 +292,1 @@\n-  ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);\n+  ClassFileStream st((u1*)buf, bufLen, nullptr, ClassFileStream::verify);\n@@ -317,1 +317,1 @@\n-  jclass result = NULL;\n+  jclass result = nullptr;\n@@ -331,1 +331,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -334,1 +334,1 @@\n-    if (k->class_loader() == NULL &&\n+    if (k->class_loader() == nullptr &&\n@@ -342,2 +342,2 @@\n-      \/\/ a non-NULL Class object.  When invoked from JNI_OnUnload,\n-      \/\/ it will return NULL to indicate no context.\n+      \/\/ a non-null Class object.  When invoked from JNI_OnUnload,\n+      \/\/ it will return null to indicate no context.\n@@ -345,1 +345,1 @@\n-      if (mirror != NULL) {\n+      if (mirror != nullptr) {\n@@ -358,1 +358,1 @@\n-  if (log_is_enabled(Debug, class, resolve) && result != NULL) {\n+  if (log_is_enabled(Debug, class, resolve) && result != nullptr) {\n@@ -371,1 +371,1 @@\n-  jmethodID ret = NULL;\n+  jmethodID ret = nullptr;\n@@ -376,1 +376,1 @@\n-  oop mirror     = NULL;\n+  oop mirror     = nullptr;\n@@ -392,1 +392,1 @@\n-  ret = m==NULL? NULL : m->jmethod_id();  \/\/ return NULL if reflected method deleted\n+  ret = m==nullptr? nullptr : m->jmethod_id();  \/\/ return null if reflected method deleted\n@@ -402,1 +402,1 @@\n-  jfieldID ret = NULL;\n+  jfieldID ret = nullptr;\n@@ -419,1 +419,1 @@\n-    assert(id != NULL, \"corrupt Field object\");\n+    assert(id != nullptr, \"corrupt Field object\");\n@@ -443,1 +443,1 @@\n-  jobject ret = NULL;\n+  jobject ret = nullptr;\n@@ -464,1 +464,1 @@\n-  jclass obj = NULL;\n+  jclass obj = nullptr;\n@@ -468,2 +468,2 @@\n-  \/\/ primitive classes return NULL\n-  if (java_lang_Class::is_primitive(mirror)) return NULL;\n+  \/\/ primitive classes return null\n+  if (java_lang_Class::is_primitive(mirror)) return nullptr;\n@@ -473,1 +473,1 @@\n-  \/\/ interfaces return NULL\n+  \/\/ interfaces return null\n@@ -476,1 +476,1 @@\n-  if (k->is_interface()) return NULL;\n+  if (k->is_interface()) return nullptr;\n@@ -486,1 +486,1 @@\n-  obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(THREAD, super->java_mirror());\n+  obj = (super == nullptr) ? nullptr : (jclass) JNIHandles::make_local(THREAD, super->java_mirror());\n@@ -504,1 +504,1 @@\n-  assert(sub_klass != NULL && super_klass != NULL, \"invalid arguments to jni_IsAssignableFrom\");\n+  assert(sub_klass != nullptr && super_klass != nullptr, \"invalid arguments to jni_IsAssignableFrom\");\n@@ -591,1 +591,1 @@\n-    if (thread != NULL && thread->threadObj() != NULL) {\n+    if (thread != nullptr && thread->threadObj() != nullptr) {\n@@ -628,1 +628,1 @@\n-  if (state != NULL && state->is_exception_detected()) {\n+  if (state != nullptr && state->is_exception_detected()) {\n@@ -670,2 +670,2 @@\n-  if (new_handles != NULL) {\n-    \/\/ As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.\n+  if (new_handles != nullptr) {\n+    \/\/ As a sanity check we only release the handle blocks if the pop_frame_link is not null.\n@@ -673,1 +673,1 @@\n-    \/\/ PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise\n+    \/\/ PushLocalFrame call. Note that we set the pop_frame_link to null explicitly, otherwise\n@@ -676,1 +676,1 @@\n-    old_handles->set_pop_frame_link(NULL);              \/\/ clear link we won't release new_handles below\n+    old_handles->set_pop_frame_link(nullptr);              \/\/ clear link we won't release new_handles below\n@@ -752,1 +752,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -783,1 +783,1 @@\n-    _arguments = NULL;\n+    _arguments = nullptr;\n@@ -912,1 +912,1 @@\n-  if (recv == NULL) {\n+  if (recv == nullptr) {\n@@ -977,1 +977,1 @@\n-  jobject ret = NULL;\n+  jobject ret = nullptr;\n@@ -991,1 +991,1 @@\n-  jobject obj = NULL;\n+  jobject obj = nullptr;\n@@ -996,1 +996,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -998,1 +998,1 @@\n-    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n@@ -1010,1 +1010,1 @@\n-    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_NULL);\n@@ -1023,1 +1023,1 @@\n-  jobject obj = NULL;\n+  jobject obj = nullptr;\n@@ -1028,1 +1028,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -1030,1 +1030,1 @@\n-    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n@@ -1042,1 +1042,1 @@\n-    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_NULL);\n@@ -1055,1 +1055,1 @@\n-  jobject obj = NULL;\n+  jobject obj = nullptr;\n@@ -1060,1 +1060,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -1062,1 +1062,1 @@\n-    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n@@ -1079,1 +1079,1 @@\n-    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);\n+    jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_NULL);\n@@ -1102,1 +1102,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -1106,1 +1106,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -1123,1 +1123,1 @@\n-  const char *name_to_probe = (name_str == NULL)\n+  const char *name_to_probe = (name_str == nullptr)\n@@ -1129,1 +1129,1 @@\n-  if (name == NULL || signature == NULL) {\n+  if (name == nullptr || signature == nullptr) {\n@@ -1154,1 +1154,1 @@\n-      m = NULL;\n+      m = nullptr;\n@@ -1158,1 +1158,1 @@\n-    if (m == NULL &&  klass->is_instance_klass()) {\n+    if (m == nullptr &&  klass->is_instance_klass()) {\n@@ -1162,1 +1162,1 @@\n-  if (m == NULL || (m->is_static() != is_static)) {\n+  if (m == nullptr || (m->is_static() != is_static)) {\n@@ -1610,1 +1610,1 @@\n-  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n@@ -1666,1 +1666,1 @@\n-  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n@@ -1719,1 +1719,1 @@\n-  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n@@ -1770,1 +1770,1 @@\n-  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK);\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK);\n@@ -1781,1 +1781,1 @@\n-  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK);\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK);\n@@ -1791,1 +1791,1 @@\n-  jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK);\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK);\n@@ -1816,1 +1816,1 @@\n-  if (fieldname == NULL || signame == NULL) {\n+  if (fieldname == nullptr || signame == nullptr) {\n@@ -1843,1 +1843,1 @@\n-  oop res = NULL;\n+  oop res = nullptr;\n@@ -2020,1 +2020,1 @@\n-  jobject ret = NULL;\n+  jobject ret = nullptr;\n@@ -2055,1 +2055,1 @@\n-  jfieldID ret = NULL;\n+  jfieldID ret = nullptr;\n@@ -2063,1 +2063,1 @@\n-  if (fieldname == NULL || signame == NULL) {\n+  if (fieldname == nullptr || signame == nullptr) {\n@@ -2097,1 +2097,1 @@\n-    JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id->holder(), fieldID, true);\n+    JvmtiExport::jni_GetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true);\n@@ -2121,1 +2121,1 @@\n-    JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id->holder(), fieldID, true); \\\n+    JvmtiExport::jni_GetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true); \\\n@@ -2154,1 +2154,1 @@\n-    JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id->holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);\n+    JvmtiExport::jni_SetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);\n@@ -2175,1 +2175,1 @@\n-    JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id->holder(), fieldID, true, SigType, (jvalue *)&field_value); \\\n+    JvmtiExport::jni_SetField_probe(thread, nullptr, nullptr, id->holder(), fieldID, true, SigType, (jvalue *)&field_value); \\\n@@ -2219,1 +2219,1 @@\n-  jstring ret = NULL;\n+  jstring ret = nullptr;\n@@ -2240,1 +2240,1 @@\n-  jchar* buf = NULL;\n+  jchar* buf = nullptr;\n@@ -2243,1 +2243,1 @@\n-  if (s_value != NULL) {\n+  if (s_value != nullptr) {\n@@ -2247,2 +2247,2 @@\n-    \/* JNI Specification states return NULL on OOM *\/\n-    if (buf != NULL) {\n+    \/* JNI Specification states return null on OOM *\/\n+    if (buf != nullptr) {\n@@ -2261,1 +2261,1 @@\n-      if (isCopy != NULL) {\n+      if (isCopy != nullptr) {\n@@ -2274,1 +2274,1 @@\n-  if (chars != NULL) {\n+  if (chars != nullptr) {\n@@ -2310,1 +2310,1 @@\n-  char* result = NULL;\n+  char* result = nullptr;\n@@ -2313,1 +2313,1 @@\n-  if (s_value != NULL) {\n+  if (s_value != nullptr) {\n@@ -2315,1 +2315,1 @@\n-    \/* JNI Specification states return NULL on OOM *\/\n+    \/* JNI Specification states return null on OOM *\/\n@@ -2317,1 +2317,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -2319,1 +2319,1 @@\n-      if (isCopy != NULL) {\n+      if (isCopy != nullptr) {\n@@ -2331,1 +2331,1 @@\n-  if (chars != NULL) {\n+  if (chars != nullptr) {\n@@ -2357,1 +2357,1 @@\n-  jobjectArray ret = NULL;\n+  jobjectArray ret = nullptr;\n@@ -2364,1 +2364,1 @@\n-  if (initial_value != NULL) {  \/\/ array already initialized with NULL\n+  if (initial_value != nullptr) {  \/\/ array already initialized with null\n@@ -2378,1 +2378,1 @@\n-  jobject ret = NULL;\n+  jobject ret = nullptr;\n@@ -2380,1 +2380,1 @@\n-  oop res = NULL;\n+  oop res = nullptr;\n@@ -2387,1 +2387,1 @@\n-      assert(res != NULL, \"Must be set in one of two paths above\");\n+      assert(res != nullptr, \"Must be set in one of two paths above\");\n@@ -2412,1 +2412,1 @@\n-   oop res = NULL;\n+   oop res = nullptr;\n@@ -2420,1 +2420,1 @@\n-       if (v != NULL && v->is_a(element_vklass)) {\n+       if (v != nullptr && v->is_a(element_vklass)) {\n@@ -2439,1 +2439,1 @@\n-       if (v == NULL || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {\n+       if (v == nullptr || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {\n@@ -2474,1 +2474,1 @@\n-  Return ret = NULL;\\\n+  Return ret = nullptr;\\\n@@ -2510,2 +2510,2 @@\n-  static char* bad_address = NULL;\n-  if (bad_address == NULL) {\n+  static char* bad_address = nullptr;\n+  if (bad_address == nullptr) {\n@@ -2514,1 +2514,1 @@\n-    if (bad_address != NULL) {\n+    if (bad_address != nullptr) {\n@@ -2536,1 +2536,1 @@\n-    if (isCopy != NULL) { \\\n+    if (isCopy != nullptr) { \\\n@@ -2539,1 +2539,1 @@\n-    \/* Empty array: legal but useless, can't return NULL. \\\n+    \/* Empty array: legal but useless, can't return null. \\\n@@ -2544,1 +2544,1 @@\n-    \/* JNI Specification states return NULL on OOM *\/                    \\\n+    \/* JNI Specification states return null on OOM *\/                    \\\n@@ -2546,1 +2546,1 @@\n-    if (result != NULL) {                                                \\\n+    if (result != nullptr) {                                             \\\n@@ -2756,1 +2756,1 @@\n-    if ((cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) &&\n+    if ((cl ==  nullptr || SystemDictionary::is_platform_class_loader(cl)) &&\n@@ -2761,1 +2761,1 @@\n-      do_warning = (caller == NULL) || caller->class_loader() != cl;\n+      do_warning = (caller == nullptr) || caller->class_loader() != cl;\n@@ -2777,1 +2777,1 @@\n-    if (name == NULL || signature == NULL) {\n+    if (name == nullptr || signature == nullptr) {\n@@ -2811,1 +2811,1 @@\n-        m->set_signature_handler(NULL);\n+        m->set_signature_handler(nullptr);\n@@ -2832,1 +2832,1 @@\n-  if (jobj == NULL) {\n+  if (jobj == nullptr) {\n@@ -2850,1 +2850,1 @@\n-  if (jobj == NULL) {\n+  if (jobj == nullptr) {\n@@ -2908,1 +2908,1 @@\n-      if (buf != NULL) {\n+      if (buf != nullptr) {\n@@ -2915,19 +2915,0 @@\n-static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    const oop o = JNIHandles::resolve_non_null(obj);\n-    return Universe::heap()->pin_object(thread, o);\n-  } else {\n-    GCLocker::lock_critical(thread);\n-    return JNIHandles::resolve_non_null(obj);\n-  }\n-}\n-\n-static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    const oop o = JNIHandles::resolve_non_null(obj);\n-    return Universe::heap()->unpin_object(thread, o);\n-  } else {\n-    GCLocker::unlock_critical(thread);\n-  }\n-}\n-\n@@ -2936,1 +2917,9 @@\n-  if (isCopy != NULL) {\n+  Handle a(thread, JNIHandles::resolve_non_null(array));\n+  assert(a->is_typeArray(), \"just checking\");\n+\n+  \/\/ Pin object\n+  Universe::heap()->pin_object(thread, a());\n+\n+  BasicType type = TypeArrayKlass::cast(a->klass())->element_type();\n+  void* ret = arrayOop(a())->base(type);\n+  if (isCopy != nullptr) {\n@@ -2939,4 +2928,0 @@\n-  oop a = lock_gc_or_pin_object(thread, array);\n-  assert(a->is_typeArray(), \"Primitive array only\");\n-  BasicType type = TypeArrayKlass::cast(a->klass())->element_type();\n-  void* ret = arrayOop(a)->base(type);\n@@ -2950,1 +2935,2 @@\n-  unlock_gc_or_unpin_object(thread, array);\n+  \/\/ Unpin object\n+  Universe::heap()->unpin_object(thread, JNIHandles::resolve_non_null(array));\n@@ -2955,28 +2941,0 @@\n-static typeArrayOop lock_gc_or_pin_string_value(JavaThread* thread, oop str) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    \/\/ Forbid deduplication before obtaining the value array, to prevent\n-    \/\/ deduplication from replacing the value array while setting up or in\n-    \/\/ the critical section.  That would lead to the release operation\n-    \/\/ unpinning the wrong object.\n-    if (StringDedup::is_enabled()) {\n-      NoSafepointVerifier nsv;\n-      StringDedup::forbid_deduplication(str);\n-    }\n-    typeArrayOop s_value = java_lang_String::value(str);\n-    return (typeArrayOop) Universe::heap()->pin_object(thread, s_value);\n-  } else {\n-    Handle h(thread, str);      \/\/ Handlize across potential safepoint.\n-    GCLocker::lock_critical(thread);\n-    return java_lang_String::value(h());\n-  }\n-}\n-\n-static void unlock_gc_or_unpin_string_value(JavaThread* thread, oop str) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    typeArrayOop s_value = java_lang_String::value(str);\n-    Universe::heap()->unpin_object(thread, s_value);\n-  } else {\n-    GCLocker::unlock_critical(thread);\n-  }\n-}\n-\n@@ -2988,1 +2946,5 @@\n-    typeArrayOop s_value = lock_gc_or_pin_string_value(thread, s);\n+    typeArrayHandle s_value(thread, java_lang_String::value(s));\n+\n+    \/\/ Pin value array\n+    Universe::heap()->pin_object(thread, s_value());\n+\n@@ -2990,1 +2952,1 @@\n-    if (isCopy != NULL) *isCopy = JNI_FALSE;\n+    if (isCopy != nullptr) *isCopy = JNI_FALSE;\n@@ -2996,2 +2958,2 @@\n-    \/* JNI Specification states return NULL on OOM *\/\n-    if (ret != NULL) {\n+    \/* JNI Specification states return null on OOM *\/\n+    if (ret != nullptr) {\n@@ -3003,1 +2965,1 @@\n-    if (isCopy != NULL) *isCopy = JNI_TRUE;\n+    if (isCopy != nullptr) *isCopy = JNI_TRUE;\n@@ -3014,0 +2976,1 @@\n+\n@@ -3019,2 +2982,6 @@\n-    \/\/ For non-latin1 string, drop the associated gc-locker\/pin.\n-    unlock_gc_or_unpin_string_value(thread, s);\n+    \/\/ StringDedup can have replaced the value array, so don't fetch the array from 's'.\n+    \/\/ Instead, we calculate the address based on the jchar array exposed with GetStringCritical.\n+    oop value = cast_to_oop((address)chars - arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+\n+    \/\/ Unpin value array\n+    Universe::heap()->unpin_object(thread, value);\n@@ -3030,2 +2997,2 @@\n-  if (ret == NULL) {\n-    THROW_OOP_(Universe::out_of_memory_error_c_heap(), NULL);\n+  if (ret == nullptr) {\n+    THROW_OOP_(Universe::out_of_memory_error_c_heap(), nullptr);\n@@ -3059,6 +3026,6 @@\n-static jclass    bufferClass                 = NULL;\n-static jclass    directBufferClass           = NULL;\n-static jclass    directByteBufferClass       = NULL;\n-static jmethodID directByteBufferConstructor = NULL;\n-static jfieldID  directBufferAddressField    = NULL;\n-static jfieldID  bufferCapacityField         = NULL;\n+static jclass    bufferClass                 = nullptr;\n+static jclass    directBufferClass           = nullptr;\n+static jclass    directByteBufferClass       = nullptr;\n+static jmethodID directByteBufferConstructor = nullptr;\n+static jfieldID  directBufferAddressField    = nullptr;\n+static jfieldID  bufferCapacityField         = nullptr;\n@@ -3073,1 +3040,1 @@\n-  if (log_is_enabled(Debug, class, resolve) && result != NULL) {\n+  if (log_is_enabled(Debug, class, resolve) && result != nullptr) {\n@@ -3079,1 +3046,1 @@\n-\/\/ These lookups are done with the NULL (bootstrap) ClassLoader to\n+\/\/ These lookups are done with the null (bootstrap) ClassLoader to\n@@ -3083,3 +3050,3 @@\n-  if ((bufferClass           = lookupOne(env, \"java\/nio\/Buffer\", thread))           == NULL) { return false; }\n-  if ((directBufferClass     = lookupOne(env, \"sun\/nio\/ch\/DirectBuffer\", thread))   == NULL) { return false; }\n-  if ((directByteBufferClass = lookupOne(env, \"java\/nio\/DirectByteBuffer\", thread)) == NULL) { return false; }\n+  if ((bufferClass           = lookupOne(env, \"java\/nio\/Buffer\", thread))           == nullptr) { return false; }\n+  if ((directBufferClass     = lookupOne(env, \"sun\/nio\/ch\/DirectBuffer\", thread))   == nullptr) { return false; }\n+  if ((directByteBufferClass = lookupOne(env, \"java\/nio\/DirectByteBuffer\", thread)) == nullptr) { return false; }\n@@ -3107,2 +3074,2 @@\n-    \/\/ Global refs will be NULL if out-of-memory (no exception is pending)\n-    if (bufferClass == NULL || directBufferClass == NULL || directByteBufferClass == NULL) {\n+    \/\/ Global refs will be null if out-of-memory (no exception is pending)\n+    if (bufferClass == nullptr || directBufferClass == nullptr || directByteBufferClass == nullptr) {\n@@ -3114,1 +3081,1 @@\n-    directByteBufferConstructor = env->GetMethodID(directByteBufferClass, \"<init>\", \"(JI)V\");\n+    directByteBufferConstructor = env->GetMethodID(directByteBufferClass, \"<init>\", \"(JJ)V\");\n@@ -3133,3 +3100,3 @@\n-    if ((directByteBufferConstructor == NULL) ||\n-        (directBufferAddressField    == NULL) ||\n-        (bufferCapacityField         == NULL)) {\n+    if ((directByteBufferConstructor == nullptr) ||\n+        (directBufferAddressField    == nullptr) ||\n+        (bufferCapacityField         == nullptr)) {\n@@ -3159,2 +3126,2 @@\n-      HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);\n-      return NULL;\n+      HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(nullptr);\n+      return nullptr;\n@@ -3166,4 +3133,1 @@\n-  \/\/ NOTE that package-private DirectByteBuffer constructor currently\n-  \/\/ takes int capacity\n-  jint  cap  = (jint)  capacity;\n-  jobject ret = env->NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);\n+  jobject ret = env->NewObject(directByteBufferClass, directByteBufferConstructor, addr, capacity);\n@@ -3183,1 +3147,1 @@\n-  void* ret = NULL;\n+  void* ret = nullptr;\n@@ -3192,1 +3156,1 @@\n-  if ((buf != NULL) && (!env->IsInstanceOf(buf, directBufferClass))) {\n+  if ((buf != nullptr) && (!env->IsInstanceOf(buf, directBufferClass))) {\n@@ -3219,1 +3183,1 @@\n-  if (buf == NULL) {\n+  if (buf == nullptr) {\n@@ -3255,1 +3219,1 @@\n-  if (thread_obj != NULL && thread_obj->is_a(vmClasses::BasicVirtualThread_klass())) {\n+  if (thread_obj != nullptr && thread_obj->is_a(vmClasses::BasicVirtualThread_klass())) {\n@@ -3265,3 +3229,3 @@\n-    NULL,\n-    NULL,\n-    NULL,\n+    nullptr,\n+    nullptr,\n+    nullptr,\n@@ -3269,1 +3233,1 @@\n-    NULL,\n+    nullptr,\n@@ -3622,1 +3586,1 @@\n-  assert(jt != NULL, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n@@ -3842,1 +3806,1 @@\n-    if (numVMs != NULL) *numVMs = 1;\n+    if (numVMs != nullptr) *numVMs = 1;\n@@ -3845,1 +3809,1 @@\n-    if (numVMs != NULL) *numVMs = 0;\n+    if (numVMs != nullptr) *numVMs = 0;\n@@ -3870,1 +3834,1 @@\n-  destroyargs.group = NULL;\n+  destroyargs.group = nullptr;\n@@ -3922,1 +3886,1 @@\n-  if (t != NULL) {\n+  if (t != nullptr) {\n@@ -3966,3 +3930,3 @@\n-  oop group = NULL;\n-  char* thread_name = NULL;\n-  if (args != NULL && Threads::is_supported_jni_version(args->version)) {\n+  oop group = nullptr;\n+  char* thread_name = nullptr;\n+  if (args != nullptr && Threads::is_supported_jni_version(args->version)) {\n@@ -3970,1 +3934,1 @@\n-    thread_name = args->name; \/\/ may be NULL\n+    thread_name = args->name; \/\/ may be null\n@@ -3972,1 +3936,1 @@\n-  if (group == NULL) group = Universe::main_thread_group();\n+  if (group == nullptr) group = Universe::main_thread_group();\n@@ -4047,1 +4011,1 @@\n-  if (current == NULL) {\n+  if (current == nullptr) {\n@@ -4103,1 +4067,1 @@\n-    *penv = NULL;\n+    *penv = nullptr;\n@@ -4110,1 +4074,1 @@\n-    *penv = NULL;\n+    *penv = nullptr;\n@@ -4127,1 +4091,1 @@\n-  if (thread != NULL && thread->is_Java_thread()) {\n+  if (thread != nullptr && thread->is_Java_thread()) {\n@@ -4146,1 +4110,1 @@\n-      *penv = NULL;\n+      *penv = nullptr;\n@@ -4151,1 +4115,1 @@\n-    *penv = NULL;\n+    *penv = nullptr;\n@@ -4174,3 +4138,3 @@\n-    NULL,\n-    NULL,\n-    NULL,\n+    nullptr,\n+    nullptr,\n+    nullptr,\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":183,"deletions":219,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    if (cur == NULL || !cur->is_Java_thread()) {                         \\\n+    if (cur == nullptr || !cur->is_Java_thread()) {                      \\\n@@ -104,1 +104,1 @@\n-    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thr));         \\\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thr));               \\\n@@ -277,1 +277,1 @@\n-  if (oopObj == NULL) {\n+  if (oopObj == nullptr) {\n@@ -308,1 +308,1 @@\n-  if ((s == NULL) || !java_lang_String::is_instance(s))\n+  if ((s == nullptr) || !java_lang_String::is_instance(s))\n@@ -319,1 +319,1 @@\n-  if (aOop == NULL || !aOop->is_array()) {\n+  if (aOop == nullptr || !aOop->is_array()) {\n@@ -374,3 +374,3 @@\n-  if (carray == NULL) {\n-    tty->print_cr(\"%s: elements vector NULL\" PTR_FORMAT, fn_name, p2i(obj));\n-    NativeReportJNIFatalError(thr, \"Elements vector NULL\");\n+  if (carray == nullptr) {\n+    tty->print_cr(\"%s: elements vector null\" PTR_FORMAT, fn_name, p2i(obj));\n+    NativeReportJNIFatalError(thr, \"Elements vector null\");\n@@ -386,1 +386,1 @@\n-  if (orig_result == NULL) {\n+  if (orig_result == nullptr) {\n@@ -392,1 +392,1 @@\n-  if (rsz != NULL) {\n+  if (rsz != nullptr) {\n@@ -427,1 +427,1 @@\n-  if ((obj != NULL) && (JNIHandles::handle_type(thr, obj) != JNIInvalidRefType)) {\n+  if ((obj != nullptr) && (JNIHandles::handle_type(thr, obj) != JNIInvalidRefType)) {\n@@ -432,1 +432,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -440,1 +440,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -453,1 +453,1 @@\n-  if (obj == NULL) return NULL;\n+  if (obj == nullptr) return nullptr;\n@@ -456,1 +456,1 @@\n-  if (oopObj == NULL) {\n+  if (oopObj == nullptr) {\n@@ -466,1 +466,1 @@\n-  if (name == NULL) return;  \/\/ implementation accepts NULL so just return\n+  if (name == nullptr) return;  \/\/ implementation accepts null so just return\n@@ -490,1 +490,1 @@\n-  if (mirror == NULL) {\n+  if (mirror == nullptr) {\n@@ -500,1 +500,1 @@\n-  if (!(k != NULL || (allow_primitive && java_lang_Class::is_primitive(mirror)))) {\n+  if (!(k != nullptr || (allow_primitive && java_lang_Class::is_primitive(mirror)))) {\n@@ -508,1 +508,1 @@\n-  assert(klass != NULL, \"klass argument must have a value\");\n+  assert(klass != nullptr, \"klass argument must have a value\");\n@@ -521,1 +521,1 @@\n-  if (clazz != NULL) {\n+  if (clazz != nullptr) {\n@@ -529,1 +529,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -531,1 +531,1 @@\n-    assert(recv != NULL, \"validate_object checks that\");\n+    assert(recv != nullptr, \"validate_object checks that\");\n@@ -659,3 +659,3 @@\n-      if (oopObj == NULL) {\n-        \/\/ Unchecked Throw tolerates a NULL obj, so just warn\n-        ReportJNIWarning(thr, \"JNI Throw called with NULL throwable\");\n+      if (oopObj == nullptr) {\n+        \/\/ Unchecked Throw tolerates a null obj, so just warn\n+        ReportJNIWarning(thr, \"JNI Throw called with null throwable\");\n@@ -678,1 +678,1 @@\n-      assert(k != NULL, \"validate_class shouldn't return NULL Klass*\");\n+      assert(k != nullptr, \"validate_class shouldn't return null Klass*\");\n@@ -744,1 +744,1 @@\n-      if (lobj != NULL) {\n+      if (lobj != nullptr) {\n@@ -790,1 +790,1 @@\n-       * to NULL objects. If the handles are valid, but contain NULL,\n+       * to nullptr objects. If the handles are valid, but contain nullptr,\n@@ -793,1 +793,1 @@\n-      if (obj1 != NULL && jniCheck::validate_handle(thr, obj1) != NULL) {\n+      if (obj1 != nullptr && jniCheck::validate_handle(thr, obj1) != nullptr) {\n@@ -796,1 +796,1 @@\n-      if (obj2 != NULL && jniCheck::validate_handle(thr, obj2) != NULL) {\n+      if (obj2 != nullptr && jniCheck::validate_handle(thr, obj2) != nullptr) {\n@@ -810,1 +810,1 @@\n-      if (ref != NULL) {\n+      if (ref != nullptr) {\n@@ -937,1 +937,1 @@\n-      jniCheck::validate_call(thr, NULL, methodID, obj); \\\n+      jniCheck::validate_call(thr, nullptr, methodID, obj); \\\n@@ -955,1 +955,1 @@\n-      jniCheck::validate_call(thr, NULL, methodID, obj); \\\n+      jniCheck::validate_call(thr, nullptr, methodID, obj); \\\n@@ -971,1 +971,1 @@\n-      jniCheck::validate_call(thr, NULL, methodID, obj); \\\n+      jniCheck::validate_call(thr, nullptr, methodID, obj); \\\n@@ -998,1 +998,1 @@\n-      jniCheck::validate_call(thr, NULL, methodID, obj);\n+      jniCheck::validate_call(thr, nullptr, methodID, obj);\n@@ -1014,1 +1014,1 @@\n-      jniCheck::validate_call(thr, NULL, methodID, obj);\n+      jniCheck::validate_call(thr, nullptr, methodID, obj);\n@@ -1028,1 +1028,1 @@\n-      jniCheck::validate_call(thr, NULL, methodID, obj);\n+      jniCheck::validate_call(thr, nullptr, methodID, obj);\n@@ -1447,1 +1447,1 @@\n-    jchar* new_result = NULL;\n+    jchar* new_result = nullptr;\n@@ -1449,3 +1449,3 @@\n-    assert (isCopy == NULL || *isCopy == JNI_TRUE, \"GetStringChars didn't return a copy as expected\");\n-    if (result != NULL) {\n-      size_t len = UNCHECKED()->GetStringLength(env,str) + 1; \/\/ + 1 for NULL termination\n+    assert (isCopy == nullptr || *isCopy == JNI_TRUE, \"GetStringChars didn't return a copy as expected\");\n+    if (result != nullptr) {\n+      size_t len = UNCHECKED()->GetStringLength(env,str) + 1; \/\/ + 1 for null termination\n@@ -1454,1 +1454,1 @@\n-      if (new_result == NULL) {\n+      if (new_result == nullptr) {\n@@ -1473,1 +1473,1 @@\n-    if (chars == NULL) {\n+    if (chars == nullptr) {\n@@ -1531,1 +1531,1 @@\n-    char* new_result = NULL;\n+    char* new_result = nullptr;\n@@ -1533,3 +1533,3 @@\n-    assert (isCopy == NULL || *isCopy == JNI_TRUE, \"GetStringUTFChars didn't return a copy as expected\");\n-    if (result != NULL) {\n-      size_t len = strlen(result) + 1; \/\/ + 1 for NULL termination\n+    assert (isCopy == nullptr || *isCopy == JNI_TRUE, \"GetStringUTFChars didn't return a copy as expected\");\n+    if (result != nullptr) {\n+      size_t len = strlen(result) + 1; \/\/ + 1 for null termination\n@@ -1537,1 +1537,1 @@\n-      if (new_result == NULL) {\n+      if (new_result == nullptr) {\n@@ -1556,1 +1556,1 @@\n-    if (chars == NULL) {\n+    if (chars == nullptr) {\n@@ -1662,1 +1662,1 @@\n-    if (result != NULL) { \\\n+    if (result != nullptr) { \\\n@@ -1843,1 +1843,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -1899,1 +1899,1 @@\n-      if (obj != NULL) {\n+      if (obj != nullptr) {\n@@ -2003,3 +2003,3 @@\n-    NULL,\n-    NULL,\n-    NULL,\n+    nullptr,\n+    nullptr,\n+    nullptr,\n@@ -2007,1 +2007,1 @@\n-    NULL,\n+    nullptr,\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":57,"deletions":57,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-  const char * source_file = NULL;\n+  const char * source_file = nullptr;\n@@ -153,1 +153,1 @@\n-  InstanceKlass* caller = NULL;\n+  InstanceKlass* caller = nullptr;\n@@ -164,1 +164,1 @@\n-    Method* last_caller = NULL;\n+    Method* last_caller = nullptr;\n@@ -190,1 +190,1 @@\n-    } else if (last_caller != NULL &&\n+    } else if (last_caller != nullptr &&\n@@ -210,1 +210,1 @@\n-      if (s != NULL) {\n+      if (s != nullptr) {\n@@ -215,1 +215,1 @@\n-  if (caller != NULL) {\n+  if (caller != nullptr) {\n@@ -220,1 +220,1 @@\n-      if (source_file != NULL) {\n+      if (source_file != nullptr) {\n@@ -293,1 +293,1 @@\n-  if (src == NULL || dst == NULL) {\n+  if (src == nullptr || dst == nullptr) {\n@@ -310,1 +310,1 @@\n-  Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : \"\"), CHECK);\n+  Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != nullptr ? value : \"\"), CHECK);\n@@ -343,1 +343,1 @@\n-  while (p != NULL) {\n+  while (p != nullptr) {\n@@ -348,1 +348,1 @@\n-        Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : \"\"), CHECK_NULL);\n+        Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != nullptr ? value : \"\"), CHECK_NULL);\n@@ -512,1 +512,1 @@\n-  if (!ShowCodeDetailsInExceptionMessages) return NULL;\n+  if (!ShowCodeDetailsInExceptionMessages) return nullptr;\n@@ -519,1 +519,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -522,1 +522,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -531,1 +531,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -561,1 +561,1 @@\n-    THROW_MSG_(vmSymbols::java_lang_InternalError(), \"doStackWalk: no stack trace\", NULL);\n+    THROW_MSG_(vmSymbols::java_lang_InternalError(), \"doStackWalk: no stack trace\", nullptr);\n@@ -575,1 +575,1 @@\n-    THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), \"not enough space in buffers\", NULL);\n+    THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), \"not enough space in buffers\", nullptr);\n@@ -616,2 +616,2 @@\n-  \/\/ as implemented in the classic virtual machine; return 0 if object is NULL\n-  if (handle == NULL) {\n+  \/\/ as implemented in the classic virtual machine; return 0 if object is nullptr\n+  if (handle == nullptr) {\n@@ -699,1 +699,1 @@\n-  oop new_obj_oop = NULL;\n+  oop new_obj_oop = nullptr;\n@@ -761,1 +761,1 @@\n-    assert(m != NULL, \"sanity\");\n+    assert(m != nullptr, \"sanity\");\n@@ -783,1 +783,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -788,1 +788,1 @@\n-  oop mirror = NULL;\n+  oop mirror = nullptr;\n@@ -793,1 +793,1 @@\n-  if (mirror == NULL) {\n+  if (mirror == nullptr) {\n@@ -807,1 +807,1 @@\n-  if (name == NULL || (int)strlen(name) > Symbol::max_length()) {\n+  if (name == nullptr || (int)strlen(name) > Symbol::max_length()) {\n@@ -810,1 +810,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -816,2 +816,2 @@\n-  if (k == NULL) {\n-    return NULL;\n+  if (k == nullptr) {\n+    return nullptr;\n@@ -836,1 +836,1 @@\n-  oop protection_domain = NULL;\n+  oop protection_domain = nullptr;\n@@ -840,1 +840,1 @@\n-  \/\/ The caller is also passed as NULL by the java code if there is no security\n+  \/\/ The caller is also passed as null by the java code if there is no security\n@@ -842,1 +842,1 @@\n-  if (from_class != NULL && loader_oop != NULL) {\n+  if (from_class != nullptr && loader_oop != nullptr) {\n@@ -851,1 +851,1 @@\n-  if (log_is_enabled(Debug, class, resolve) && result != NULL) {\n+  if (log_is_enabled(Debug, class, resolve) && result != nullptr) {\n@@ -864,2 +864,2 @@\n-  Klass* from_class = (from_class_oop == NULL)\n-                           ? (Klass*)NULL\n+  Klass* from_class = (from_class_oop == nullptr)\n+                           ? (Klass*)nullptr\n@@ -867,3 +867,3 @@\n-  oop class_loader = NULL;\n-  oop protection_domain = NULL;\n-  if (from_class != NULL) {\n+  oop class_loader = nullptr;\n+  oop protection_domain = nullptr;\n+  if (from_class != nullptr) {\n@@ -878,1 +878,1 @@\n-  if (log_is_enabled(Debug, class, resolve) && result != NULL) {\n+  if (log_is_enabled(Debug, class, resolve) && result != nullptr) {\n@@ -899,1 +899,1 @@\n-  if (source == NULL)  source = \"__JVM_DefineClass__\";\n+  if (source == nullptr)  source = \"__JVM_DefineClass__\";\n@@ -915,1 +915,1 @@\n-  TempNewSymbol class_name = name == NULL ? NULL :\n+  TempNewSymbol class_name = name == nullptr ? nullptr :\n@@ -954,1 +954,1 @@\n-  if (lookup_k == NULL) {\n+  if (lookup_k == nullptr) {\n@@ -966,1 +966,1 @@\n-  InstanceKlass* host_class = NULL;\n+  InstanceKlass* host_class = nullptr;\n@@ -981,1 +981,1 @@\n-    if (classData != NULL) {\n+    if (classData != nullptr) {\n@@ -1000,1 +1000,1 @@\n-  TempNewSymbol class_name = name == NULL ? NULL :\n+  TempNewSymbol class_name = name == nullptr ? nullptr :\n@@ -1008,1 +1008,1 @@\n-  InstanceKlass* ik = NULL;\n+  InstanceKlass* ik = nullptr;\n@@ -1060,1 +1060,1 @@\n-  return jvm_define_class_common(name, loader, buf, len, pd, NULL, THREAD);\n+  return jvm_define_class_common(name, loader, buf, len, pd, nullptr, THREAD);\n@@ -1077,1 +1077,1 @@\n-  if (lookup == NULL) {\n+  if (lookup == nullptr) {\n@@ -1081,1 +1081,1 @@\n-  assert(buf != NULL, \"buf must not be NULL\");\n+  assert(buf != nullptr, \"buf must not be null\");\n@@ -1098,1 +1098,1 @@\n-  if (str == NULL) return NULL;\n+  if (str == nullptr) return nullptr;\n@@ -1113,1 +1113,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1119,1 +1119,1 @@\n-  \/\/   us to pass the NULL as the initiating class loader.\n+  \/\/   us to pass the null as the initiating class loader.\n@@ -1125,1 +1125,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -1131,1 +1131,1 @@\n-  return (k == NULL) ? NULL :\n+  return (k == nullptr) ? nullptr :\n@@ -1179,1 +1179,1 @@\n-  assert (cls != NULL, \"illegal class\");\n+  assert (cls != nullptr, \"illegal class\");\n@@ -1272,1 +1272,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1278,2 +1278,2 @@\n-  \/\/ is an array, return NULL.\n-  if (signers == NULL) return NULL;\n+  \/\/ is an array, return null.\n+  if (signers == nullptr) return nullptr;\n@@ -1309,2 +1309,2 @@\n-  if (mirror == NULL) {\n-    THROW_(vmSymbols::java_lang_NullPointerException(), NULL);\n+  if (mirror == nullptr) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), nullptr);\n@@ -1315,1 +1315,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1330,1 +1330,1 @@\n-  if (!UsePrivilegedStack) return NULL;\n+  if (!UsePrivilegedStack) return nullptr;\n@@ -1340,2 +1340,2 @@\n-  oop previous_protection_domain = NULL;\n-  Handle privileged_context(thread, NULL);\n+  oop previous_protection_domain = nullptr;\n+  Handle privileged_context(thread, nullptr);\n@@ -1343,1 +1343,1 @@\n-  oop protection_domain = NULL;\n+  oop protection_domain = nullptr;\n@@ -1374,1 +1374,1 @@\n-    if ((previous_protection_domain != protection_domain) && (protection_domain != NULL)) {\n+    if ((previous_protection_domain != protection_domain) && (protection_domain != nullptr)) {\n@@ -1386,1 +1386,1 @@\n-    if (is_privileged && privileged_context.is_null()) return NULL;\n+    if (is_privileged && privileged_context.is_null()) return nullptr;\n@@ -1444,1 +1444,1 @@\n-      if (result() != NULL) {\n+      if (result() != nullptr) {\n@@ -1450,1 +1450,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1455,1 +1455,1 @@\n-  return (k != NULL) && k->is_array_klass() ? true : false;\n+  return (k != nullptr) && k->is_array_klass() ? true : false;\n@@ -1552,1 +1552,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1556,1 +1556,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1562,2 +1562,2 @@\n-  if (outer_klass == NULL)  return NULL;  \/\/ already a top-level class\n-  if (!inner_is_member)  return NULL;     \/\/ a hidden class (inside a method)\n+  if (outer_klass == nullptr)  return nullptr;  \/\/ already a top-level class\n+  if (!inner_is_member)  return nullptr;     \/\/ a hidden class (inside a method)\n@@ -1572,1 +1572,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1576,1 +1576,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1588,1 +1588,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1593,1 +1593,1 @@\n-  assert (cls != NULL, \"illegal class\");\n+  assert (cls != nullptr, \"illegal class\");\n@@ -1602,1 +1602,1 @@\n-      if (sym == NULL) return NULL;\n+      if (sym == nullptr) return nullptr;\n@@ -1607,1 +1607,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1612,1 +1612,1 @@\n-  assert (cls != NULL, \"illegal class\");\n+  assert (cls != nullptr, \"illegal class\");\n@@ -1622,1 +1622,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1659,1 +1659,1 @@\n-  oop mirror    = NULL;\n+  oop mirror    = nullptr;\n@@ -1674,2 +1674,2 @@\n-  assert(m != NULL, \"cannot find method\");\n-  return m;  \/\/ caller has to deal with NULL in product mode\n+  assert(m != nullptr, \"cannot find method\");\n+  return m;  \/\/ caller has to deal with null in product mode\n@@ -1681,1 +1681,1 @@\n-  assert (cls != NULL, \"illegal class\");\n+  assert (cls != nullptr, \"illegal class\");\n@@ -1688,1 +1688,1 @@\n-      if (type_annotations != NULL) {\n+      if (type_annotations != nullptr) {\n@@ -1694,1 +1694,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1698,1 +1698,1 @@\n-  assert (method != NULL, \"illegal method\");\n+  assert (method != nullptr, \"illegal method\");\n@@ -1701,2 +1701,2 @@\n-  if (m == NULL) {\n-    return NULL;\n+  if (m == nullptr) {\n+    return nullptr;\n@@ -1706,1 +1706,1 @@\n-  if (type_annotations != NULL) {\n+  if (type_annotations != nullptr) {\n@@ -1711,1 +1711,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1715,1 +1715,1 @@\n-  assert (field != NULL, \"illegal field\");\n+  assert (field != nullptr, \"illegal field\");\n@@ -1719,1 +1719,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1744,1 +1744,1 @@\n-    return (jobjectArray)NULL;\n+    return (jobjectArray)nullptr;\n@@ -1769,1 +1769,1 @@\n-      \/\/ For a 0 index, give a NULL symbol\n+      \/\/ For a 0 index, give a null symbol\n@@ -1771,1 +1771,1 @@\n-        mh->constants()->symbol_at(params[i].name_cp_index) : NULL;\n+        mh->constants()->symbol_at(params[i].name_cp_index) : nullptr;\n@@ -1838,1 +1838,1 @@\n-  if (k != NULL && k->is_instance_klass()) {\n+  if (k != nullptr && k->is_instance_klass()) {\n@@ -1848,1 +1848,1 @@\n-\/\/ or NULL if the attribute is not present.\n+\/\/ or null if the attribute is not present.\n@@ -1859,1 +1859,1 @@\n-  if (components != NULL) {\n+  if (components != nullptr) {\n@@ -1870,1 +1870,1 @@\n-      assert(component != NULL, \"unexpected NULL record component\");\n+      assert(component != nullptr, \"unexpected null record component\");\n@@ -1877,1 +1877,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1948,1 +1948,1 @@\n-      result->obj_at_put(i, NULL);\n+      result->obj_at_put(i, nullptr);\n@@ -2013,1 +2013,1 @@\n-  return (jclass) (host == NULL ? NULL :\n+  return (jclass) (host == nullptr ? nullptr :\n@@ -2032,1 +2032,1 @@\n-    int length = members == NULL ? 0 : members->length();\n+    int length = members == nullptr ? 0 : members->length();\n@@ -2048,1 +2048,1 @@\n-            return NULL; \/\/ propagate VMEs\n+            return nullptr; \/\/ propagate VMEs\n@@ -2124,1 +2124,1 @@\n-          return NULL; \/\/ propagate VMEs\n+          return nullptr; \/\/ propagate VMEs\n@@ -2154,1 +2154,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2175,1 +2175,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2210,1 +2210,1 @@\n-  if (k == NULL) return NULL;\n+  if (k == nullptr) return nullptr;\n@@ -2226,1 +2226,1 @@\n-    if (k_o == NULL) return NULL;\n+    if (k_o == nullptr) return nullptr;\n@@ -2275,1 +2275,1 @@\n-    if (k_o == NULL) return NULL;\n+    if (k_o == nullptr) return nullptr;\n@@ -2282,1 +2282,1 @@\n-  if (target_klass == NULL) {\n+  if (target_klass == nullptr) {\n@@ -2484,1 +2484,1 @@\n-  assert(cls != NULL, \"bad class\");\n+  assert(cls != nullptr, \"bad class\");\n@@ -2496,1 +2496,1 @@\n-  bool system_class = k->class_loader() == NULL;\n+  bool system_class = k->class_loader() == nullptr;\n@@ -2515,1 +2515,1 @@\n-  if ((o == NULL) || (!k->is_array_klass())) {\n+  if ((o == nullptr) || (!k->is_array_klass())) {\n@@ -2524,1 +2524,1 @@\n-  if ((o == NULL) || (!k->is_array_klass())) {\n+  if ((o == nullptr) || (!k->is_array_klass())) {\n@@ -2755,1 +2755,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2771,1 +2771,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2787,1 +2787,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2802,1 +2802,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2829,1 +2829,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2848,1 +2848,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2962,1 +2962,1 @@\n-  if (Arguments::vfprintf_hook() != NULL) {\n+  if (Arguments::vfprintf_hook() != nullptr) {\n@@ -2982,1 +2982,1 @@\n-  if (Arguments::vfprintf_hook() != NULL) {\n+  if (Arguments::vfprintf_hook() != nullptr) {\n@@ -3035,1 +3035,1 @@\n-  JavaThread *native_thread = NULL;\n+  JavaThread *native_thread = nullptr;\n@@ -3055,1 +3055,1 @@\n-    if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {\n+    if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != nullptr) {\n@@ -3075,1 +3075,1 @@\n-      if (native_thread->osthread() != NULL) {\n+      if (native_thread->osthread() != nullptr) {\n@@ -3086,1 +3086,1 @@\n-  assert(native_thread != NULL, \"Starting null thread?\");\n+  assert(native_thread != nullptr, \"Starting null thread?\");\n@@ -3088,1 +3088,1 @@\n-  if (native_thread->osthread() == NULL) {\n+  if (native_thread->osthread() == nullptr) {\n@@ -3118,2 +3118,2 @@\n-  oop java_thread = NULL;\n-  JavaThread* receiver = NULL;\n+  oop java_thread = nullptr;\n+  JavaThread* receiver = nullptr;\n@@ -3177,1 +3177,1 @@\n-  assert(jthread != NULL, \"no current carrier thread!\");\n+  assert(jthread != nullptr, \"no current carrier thread!\");\n@@ -3183,1 +3183,1 @@\n-  assert(theThread != (oop)NULL, \"no current thread!\");\n+  assert(theThread != (oop)nullptr, \"no current thread!\");\n@@ -3200,2 +3200,2 @@\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, NULL);\n+  JavaThread* receiver = nullptr;\n+  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, nullptr);\n@@ -3211,1 +3211,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -3264,1 +3264,1 @@\n-  if (vmClasses::reflect_CallerSensitive_klass() != NULL) {\n+  if (vmClasses::reflect_CallerSensitive_klass() != nullptr) {\n@@ -3322,1 +3322,1 @@\n-  if (ref != NULL) {\n+  if (ref != nullptr) {\n@@ -3353,1 +3353,1 @@\n-  if (java_lang_ref_Reference::unknown_referent_no_keepalive(ref_oop) == NULL) {\n+  if (java_lang_ref_Reference::unknown_referent_no_keepalive(ref_oop) == nullptr) {\n@@ -3387,1 +3387,1 @@\n-    if (loader != NULL && !SystemDictionary::is_platform_class_loader(loader)) {\n+    if (loader != nullptr && !SystemDictionary::is_platform_class_loader(loader)) {\n@@ -3395,1 +3395,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3404,1 +3404,1 @@\n-  if (arr == NULL) {\n+  if (arr == nullptr) {\n@@ -3504,1 +3504,1 @@\n-  if (load_result == NULL) {\n+  if (load_result == nullptr) {\n@@ -3537,1 +3537,1 @@\n-                    find_result != NULL ? \"Found\" : \"Failed to find\",\n+                    find_result != nullptr ? \"Found\" : \"Failed to find\",\n@@ -3566,1 +3566,1 @@\n-  if (str == NULL) return NULL;\n+  if (str == nullptr) return nullptr;\n@@ -3614,1 +3614,1 @@\n-  \/\/   us to pass the NULL as the initiating class loader.  The VM is responsible for\n+  \/\/   us to pass the null as the initiating class loader.  The VM is responsible for\n@@ -3616,1 +3616,1 @@\n-  \/\/   protection_domain. The protection_domain is passed as NULL by the java code\n+  \/\/   protection_domain. The protection_domain is passed as null by the java code\n@@ -3640,1 +3640,1 @@\n-      assert(ret_type != NULL, \"sanity check: ret_type oop must not be NULL!\");\n+      assert(ret_type != nullptr, \"sanity check: ret_type oop must not be null!\");\n@@ -3703,2 +3703,2 @@\n-  Symbol* interface_method_name = NULL;\n-  if (interfaceMethodName != NULL) {\n+  Symbol* interface_method_name = nullptr;\n+  if (interfaceMethodName != nullptr) {\n@@ -3734,3 +3734,3 @@\n-  if (interfaceMethodName == NULL || factoryType == NULL || interfaceMethodType == NULL ||\n-      implementationMember == NULL || dynamicMethodType == NULL) {\n-    THROW_(vmSymbols::java_lang_NullPointerException(), NULL);\n+  if (interfaceMethodName == nullptr || factoryType == nullptr || interfaceMethodType == nullptr ||\n+      implementationMember == nullptr || dynamicMethodType == nullptr) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), nullptr);\n@@ -3743,1 +3743,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3762,2 +3762,2 @@\n-  jclass jcls = NULL;\n-  if (lambda_ik != NULL) {\n+  jclass jcls = nullptr;\n+  if (lambda_ik != nullptr) {\n@@ -3765,1 +3765,1 @@\n-    jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(THREAD, loaded_lambda->java_mirror());\n+    jcls = loaded_lambda == nullptr ? nullptr : (jclass) JNIHandles::make_local(THREAD, loaded_lambda->java_mirror());\n@@ -3769,1 +3769,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3814,1 +3814,1 @@\n-  if (line != NULL) {\n+  if (line != nullptr) {\n@@ -3877,1 +3877,1 @@\n-  if (threads == NULL) {\n+  if (threads == nullptr) {\n@@ -3934,2 +3934,2 @@\n-  if (ofClass == NULL) {\n-    return NULL;\n+  if (ofClass == nullptr) {\n+    return nullptr;\n@@ -3940,1 +3940,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3944,1 +3944,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3949,1 +3949,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3977,1 +3977,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4032,1 +4032,1 @@\n-    if (state != NULL && state->is_pending_interp_only_mode()) {\n+    if (state != nullptr && state->is_pending_interp_only_mode()) {\n@@ -4090,1 +4090,1 @@\n-  if (last_unmount && thread->jvmti_thread_state() != NULL) {\n+  if (last_unmount && thread->jvmti_thread_state() != nullptr) {\n@@ -4092,1 +4092,1 @@\n-    thread->set_jvmti_thread_state(NULL);\n+    thread->set_jvmti_thread_state(nullptr);\n@@ -4094,1 +4094,1 @@\n-    java_lang_Thread::set_jvmti_thread_state(vt, NULL);\n+    java_lang_Thread::set_jvmti_thread_state(vt, nullptr);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":172,"deletions":172,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    AnnotationArray* anno = fields_anno == NULL ? NULL : fields_anno->at(fs.index());\n-    AnnotationArray* type_anno = fields_type_anno == NULL ? NULL : fields_type_anno->at(fs.index());\n+    AnnotationArray* anno = fields_anno == nullptr ? nullptr : fields_anno->at(fs.index());\n+    AnnotationArray* type_anno = fields_type_anno == nullptr ? nullptr : fields_type_anno->at(fs.index());\n@@ -99,1 +99,1 @@\n-    if (anno != NULL) {\n+    if (anno != nullptr) {\n@@ -102,1 +102,1 @@\n-    if (type_anno != NULL) {\n+    if (type_anno != nullptr) {\n@@ -119,1 +119,1 @@\n-    if (anno != NULL) {\n+    if (anno != nullptr) {\n@@ -122,1 +122,1 @@\n-    if (type_anno != NULL) {\n+    if (type_anno != nullptr) {\n@@ -323,1 +323,1 @@\n-  assert(ik()->source_file_name() != NULL, \"caller must check\");\n+  assert(ik()->source_file_name() != nullptr, \"caller must check\");\n@@ -337,1 +337,1 @@\n-  assert(ik()->source_debug_extension() != NULL, \"caller must check\");\n+  assert(ik()->source_debug_extension() != nullptr, \"caller must check\");\n@@ -497,1 +497,1 @@\n-    if (component->annotations() != NULL) {\n+    if (component->annotations() != nullptr) {\n@@ -500,1 +500,1 @@\n-    if (component->type_annotations() != NULL) {\n+    if (component->type_annotations() != nullptr) {\n@@ -516,1 +516,1 @@\n-    if (component->annotations() != NULL) {\n+    if (component->annotations() != nullptr) {\n@@ -519,1 +519,1 @@\n-    if (component->type_annotations() != NULL) {\n+    if (component->type_annotations() != nullptr) {\n@@ -715,1 +715,1 @@\n-  if (default_anno != NULL) {\n+  if (default_anno != nullptr) {\n@@ -728,1 +728,1 @@\n-  if (anno != NULL) {\n+  if (anno != nullptr) {\n@@ -731,1 +731,1 @@\n-  if (param_anno != NULL) {\n+  if (param_anno != nullptr) {\n@@ -734,1 +734,1 @@\n-  if (type_anno != NULL) {\n+  if (type_anno != nullptr) {\n@@ -745,1 +745,1 @@\n-  if (default_anno != NULL) {\n+  if (default_anno != nullptr) {\n@@ -758,1 +758,1 @@\n-  if (anno != NULL) {\n+  if (anno != nullptr) {\n@@ -761,1 +761,1 @@\n-  if (param_anno != NULL) {\n+  if (param_anno != nullptr) {\n@@ -764,1 +764,1 @@\n-  if (type_anno != NULL) {\n+  if (type_anno != nullptr) {\n@@ -779,1 +779,1 @@\n-  if (generic_signature != NULL) {\n+  if (generic_signature != nullptr) {\n@@ -782,1 +782,1 @@\n-  if (ik()->source_file_name() != NULL) {\n+  if (ik()->source_file_name() != nullptr) {\n@@ -785,1 +785,1 @@\n-  if (ik()->source_debug_extension() != NULL) {\n+  if (ik()->source_debug_extension() != nullptr) {\n@@ -791,1 +791,1 @@\n-  if (anno != NULL) {\n+  if (anno != nullptr) {\n@@ -794,1 +794,1 @@\n-  if (type_anno != NULL) {\n+  if (type_anno != nullptr) {\n@@ -797,1 +797,1 @@\n-  if (cpool()->operands() != NULL) {\n+  if (cpool()->operands() != nullptr) {\n@@ -809,1 +809,1 @@\n-  if (ik()->record_components() != NULL) {\n+  if (ik()->record_components() != nullptr) {\n@@ -815,1 +815,1 @@\n-  if (generic_signature != NULL) {\n+  if (generic_signature != nullptr) {\n@@ -818,1 +818,1 @@\n-  if (ik()->source_file_name() != NULL) {\n+  if (ik()->source_file_name() != nullptr) {\n@@ -821,1 +821,1 @@\n-  if (ik()->source_debug_extension() != NULL) {\n+  if (ik()->source_debug_extension() != nullptr) {\n@@ -824,1 +824,1 @@\n-  if (anno != NULL) {\n+  if (anno != nullptr) {\n@@ -827,1 +827,1 @@\n-  if (type_anno != NULL) {\n+  if (type_anno != nullptr) {\n@@ -839,1 +839,1 @@\n-  if (ik()->record_components() != NULL) {\n+  if (ik()->record_components() != nullptr) {\n@@ -842,1 +842,1 @@\n-  if (cpool()->operands() != NULL) {\n+  if (cpool()->operands() != nullptr) {\n@@ -922,1 +922,1 @@\n-  write_u2(super_class == NULL? 0 :  \/\/ zero for java.lang.Object\n+  write_u2(super_class == nullptr? 0 :  \/\/ zero for java.lang.Object\n@@ -971,1 +971,1 @@\n-  assert(sym != NULL, \"attribute name symbol not found\");\n+  assert(sym != nullptr, \"attribute name symbol not found\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-\/\/ mem_ptr - pre-checked for NULL\n+\/\/ mem_ptr - pre-checked for null\n@@ -140,1 +140,1 @@\n-\/\/ mem - NULL is a valid value, must be checked\n+\/\/ mem - null is a valid value, must be checked\n@@ -147,1 +147,1 @@\n-\/\/ data - NULL is a valid value, must be checked\n+\/\/ data - null is a valid value, must be checked\n@@ -151,2 +151,2 @@\n-  JvmtiThreadState* state = NULL;\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiThreadState* state = nullptr;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -155,3 +155,3 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n-  if (thread == NULL) {\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n+  if (thread == nullptr) {\n@@ -167,3 +167,3 @@\n-  if (state == NULL) {\n-    if (data == NULL) {\n-      \/\/ leaving state unset same as data set to NULL\n+  if (state == nullptr) {\n+    if (data == nullptr) {\n+      \/\/ leaving state unset same as data set to null\n@@ -176,1 +176,1 @@\n-    if (state == NULL) {\n+    if (state == nullptr) {\n@@ -186,1 +186,1 @@\n-\/\/ data_ptr - pre-checked for NULL\n+\/\/ data_ptr - pre-checked for null\n@@ -190,1 +190,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -192,1 +192,1 @@\n-    *data_ptr = (state == NULL) ? NULL :\n+    *data_ptr = (state == nullptr) ? nullptr :\n@@ -205,1 +205,1 @@\n-    JvmtiVTMSTransitionDisabler disabler;\n+    JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -208,2 +208,2 @@\n-    JavaThread* java_thread = NULL;\n-    oop thread_obj = NULL;\n+    JavaThread* java_thread = nullptr;\n+    oop thread_obj = nullptr;\n@@ -218,1 +218,1 @@\n-    *data_ptr = (state == NULL) ? NULL :\n+    *data_ptr = (state == nullptr) ? nullptr :\n@@ -228,2 +228,2 @@\n-\/\/ module_count_ptr - pre-checked for NULL\n-\/\/ modules_ptr - pre-checked for NULL\n+\/\/ module_count_ptr - pre-checked for null\n+\/\/ modules_ptr - pre-checked for null\n@@ -238,3 +238,3 @@\n-\/\/ class_loader - NULL is a valid value, must be pre-checked\n-\/\/ package_name - pre-checked for NULL\n-\/\/ module_ptr - pre-checked for NULL\n+\/\/ class_loader - null is a valid value, must be pre-checked\n+\/\/ package_name - pre-checked for null\n+\/\/ module_ptr - pre-checked for null\n@@ -252,1 +252,1 @@\n-  *module_ptr = module != NULL ? JNIHandles::make_local(THREAD, module) : NULL;\n+  *module_ptr = module != nullptr ? JNIHandles::make_local(THREAD, module) : nullptr;\n@@ -257,2 +257,2 @@\n-\/\/ module - pre-checked for NULL\n-\/\/ to_module - pre-checked for NULL\n+\/\/ module - pre-checked for null\n+\/\/ to_module - pre-checked for null\n@@ -277,3 +277,3 @@\n-\/\/ module - pre-checked for NULL\n-\/\/ pkg_name - pre-checked for NULL\n-\/\/ to_module - pre-checked for NULL\n+\/\/ module - pre-checked for null\n+\/\/ pkg_name - pre-checked for null\n+\/\/ to_module - pre-checked for null\n@@ -299,3 +299,3 @@\n-\/\/ module - pre-checked for NULL\n-\/\/ pkg_name - pre-checked for NULL\n-\/\/ to_module - pre-checked for NULL\n+\/\/ module - pre-checked for null\n+\/\/ pkg_name - pre-checked for null\n+\/\/ to_module - pre-checked for null\n@@ -321,2 +321,2 @@\n-\/\/ module - pre-checked for NULL\n-\/\/ service - pre-checked for NULL\n+\/\/ module - pre-checked for null\n+\/\/ service - pre-checked for null\n@@ -342,3 +342,3 @@\n-\/\/ module - pre-checked for NULL\n-\/\/ service - pre-checked for NULL\n-\/\/ impl_class - pre-checked for NULL\n+\/\/ module - pre-checked for null\n+\/\/ service - pre-checked for null\n+\/\/ impl_class - pre-checked for null\n@@ -369,2 +369,2 @@\n-\/\/ module - pre-checked for NULL\n-\/\/ is_modifiable_class_ptr - pre-checked for NULL\n+\/\/ module - pre-checked for null\n+\/\/ is_modifiable_class_ptr - pre-checked for null\n@@ -390,2 +390,2 @@\n-\/\/ class_count_ptr - pre-checked for NULL\n-\/\/ classes_ptr - pre-checked for NULL\n+\/\/ class_count_ptr - pre-checked for null\n+\/\/ classes_ptr - pre-checked for null\n@@ -398,3 +398,3 @@\n-\/\/ initiating_loader - NULL is a valid value, must be checked\n-\/\/ class_count_ptr - pre-checked for NULL\n-\/\/ classes_ptr - pre-checked for NULL\n+\/\/ initiating_loader - null is a valid value, must be checked\n+\/\/ class_count_ptr - pre-checked for null\n+\/\/ classes_ptr - pre-checked for null\n@@ -408,1 +408,1 @@\n-\/\/ is_modifiable_class_ptr - pre-checked for NULL\n+\/\/ is_modifiable_class_ptr - pre-checked for null\n@@ -417,1 +417,1 @@\n-\/\/ classes - pre-checked for NULL\n+\/\/ classes - pre-checked for null\n@@ -435,1 +435,1 @@\n-    if (k_mirror == NULL) {\n+    if (k_mirror == nullptr) {\n@@ -454,1 +454,1 @@\n-    if (ik->get_cached_class_file_bytes() == NULL) {\n+    if (ik->get_cached_class_file_bytes() == nullptr) {\n@@ -488,1 +488,1 @@\n-\/\/ class_definitions - pre-checked for NULL\n+\/\/ class_definitions - pre-checked for null\n@@ -509,1 +509,1 @@\n-\/\/ size_ptr - pre-checked for NULL\n+\/\/ size_ptr - pre-checked for null\n@@ -522,1 +522,1 @@\n-\/\/ prefix - NULL is a valid value, must be checked\n+\/\/ prefix - null is a valid value, must be checked\n@@ -525,2 +525,2 @@\n-  return prefix == NULL?\n-              SetNativeMethodPrefixes(0, NULL) :\n+  return prefix == nullptr?\n+              SetNativeMethodPrefixes(0, nullptr) :\n@@ -532,1 +532,1 @@\n-\/\/ prefixes - pre-checked for NULL\n+\/\/ prefixes - pre-checked for null\n@@ -550,1 +550,1 @@\n-\/\/ callbacks - NULL is a valid value, must be checked\n+\/\/ callbacks - null is a valid value, must be checked\n@@ -560,1 +560,1 @@\n-\/\/ event_thread - NULL is a valid value, must be checked\n+\/\/ event_thread - null is a valid value, must be checked\n@@ -578,1 +578,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(event_thread);\n@@ -580,2 +580,2 @@\n-  if (event_thread == NULL) {\n-    \/\/ Can be called at Agent_OnLoad() time with event_thread == NULL\n+  if (event_thread == nullptr) {\n+    \/\/ Can be called at Agent_OnLoad() time with event_thread == nullptr\n@@ -586,1 +586,1 @@\n-    JvmtiEventController::set_user_enabled(this, NULL, (oop) NULL, event_type, enabled);\n+    JvmtiEventController::set_user_enabled(this, nullptr, (oop) nullptr, event_type, enabled);\n@@ -591,2 +591,2 @@\n-    JavaThread* java_thread = NULL;\n-    oop thread_obj = NULL;\n+    JavaThread* java_thread = nullptr;\n+    oop thread_obj = nullptr;\n@@ -613,1 +613,1 @@\n-\/\/ capabilities_ptr - pre-checked for NULL\n+\/\/ capabilities_ptr - pre-checked for null\n@@ -623,1 +623,1 @@\n-\/\/ capabilities_ptr - pre-checked for NULL\n+\/\/ capabilities_ptr - pre-checked for null\n@@ -633,1 +633,1 @@\n-\/\/ capabilities_ptr - pre-checked for NULL\n+\/\/ capabilities_ptr - pre-checked for null\n@@ -641,1 +641,1 @@\n-\/\/ capabilities_ptr - pre-checked for NULL\n+\/\/ capabilities_ptr - pre-checked for null\n@@ -652,1 +652,1 @@\n-\/\/ segment - pre-checked for NULL\n+\/\/ segment - pre-checked for null\n@@ -671,1 +671,1 @@\n-    if (zip_entry == NULL) {\n+    if (zip_entry == nullptr) {\n@@ -690,1 +690,1 @@\n-\/\/ segment - pre-checked for NULL\n+\/\/ segment - pre-checked for null\n@@ -696,1 +696,1 @@\n-    for (SystemProperty* p = Arguments::system_properties(); p != NULL; p = p->next()) {\n+    for (SystemProperty* p = Arguments::system_properties(); p != nullptr; p = p->next()) {\n@@ -713,1 +713,1 @@\n-    if (zip_entry == NULL) {\n+    if (zip_entry == nullptr) {\n@@ -761,1 +761,1 @@\n-\/\/ phase_ptr - pre-checked for NULL\n+\/\/ phase_ptr - pre-checked for null\n@@ -776,1 +776,1 @@\n-\/\/ data - NULL is a valid value, must be checked\n+\/\/ data - null is a valid value, must be checked\n@@ -784,1 +784,1 @@\n-\/\/ data_ptr - pre-checked for NULL\n+\/\/ data_ptr - pre-checked for null\n@@ -791,1 +791,1 @@\n-\/\/ version_ptr - pre-checked for NULL\n+\/\/ version_ptr - pre-checked for null\n@@ -799,1 +799,1 @@\n-\/\/ name_ptr - pre-checked for NULL\n+\/\/ name_ptr - pre-checked for null\n@@ -806,1 +806,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -843,1 +843,1 @@\n-\/\/ format_ptr - pre-checked for NULL\n+\/\/ format_ptr - pre-checked for null\n@@ -855,1 +855,1 @@\n-\/\/ thread_state_ptr - pre-checked for NULL\n+\/\/ thread_state_ptr - pre-checked for null\n@@ -859,1 +859,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -862,2 +862,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -881,1 +881,1 @@\n-\/\/ thread_ptr - pre-checked for NULL\n+\/\/ thread_ptr - pre-checked for null\n@@ -892,2 +892,2 @@\n-\/\/ threads_count_ptr - pre-checked for NULL\n-\/\/ threads_ptr - pre-checked for NULL\n+\/\/ threads_count_ptr - pre-checked for null\n+\/\/ threads_ptr - pre-checked for null\n@@ -897,1 +897,1 @@\n-  Handle *thread_objs = NULL;\n+  Handle *thread_objs = nullptr;\n@@ -908,1 +908,1 @@\n-    *threads_ptr = NULL;\n+    *threads_ptr = nullptr;\n@@ -933,2 +933,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -946,1 +946,1 @@\n-      err = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, NULL);\n+      err = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, nullptr);\n@@ -951,1 +951,1 @@\n-  err = suspend_thread(thread_oop, current, \/* single_suspend *\/ true, NULL);\n+  err = suspend_thread(thread_oop, current, \/* single_suspend *\/ true, nullptr);\n@@ -957,2 +957,2 @@\n-\/\/ request_list - pre-checked for NULL\n-\/\/ results - pre-checked for NULL\n+\/\/ request_list - pre-checked for null\n+\/\/ results - pre-checked for null\n@@ -963,1 +963,1 @@\n-  Handle self_tobj = Handle(current, NULL);\n+  Handle self_tobj = Handle(current, nullptr);\n@@ -971,2 +971,2 @@\n-      JavaThread *java_thread = NULL;\n-      oop thread_oop = NULL;\n+      JavaThread *java_thread = nullptr;\n+      oop thread_oop = nullptr;\n@@ -976,1 +976,1 @@\n-      if (thread_oop != NULL &&\n+      if (thread_oop != nullptr &&\n@@ -982,1 +982,1 @@\n-        if (thread_oop == NULL || err != JVMTI_ERROR_INVALID_THREAD) {\n+        if (thread_oop == nullptr || err != JVMTI_ERROR_INVALID_THREAD) {\n@@ -992,1 +992,1 @@\n-      results[i] = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, NULL);\n+      results[i] = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, nullptr);\n@@ -997,1 +997,1 @@\n-  if (self_tobj() != NULL) {\n+  if (self_tobj() != nullptr) {\n@@ -999,1 +999,1 @@\n-    results[self_idx] = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true, NULL);\n+    results[self_idx] = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true, nullptr);\n@@ -1016,1 +1016,1 @@\n-  Handle self_tobj = Handle(current, NULL);\n+  Handle self_tobj = Handle(current, nullptr);\n@@ -1044,1 +1044,1 @@\n-          vt_oop != NULL &&\n+          vt_oop != nullptr &&\n@@ -1054,1 +1054,1 @@\n-        suspend_thread(vt_oop, java_thread, \/* single_suspend *\/ false, NULL);\n+        suspend_thread(vt_oop, java_thread, \/* single_suspend *\/ false, nullptr);\n@@ -1070,2 +1070,2 @@\n-  if (self_tobj() != NULL) {\n-    suspend_thread(self_tobj(), current, \/* single_suspend *\/ false, NULL);\n+  if (self_tobj() != nullptr) {\n+    suspend_thread(self_tobj(), current, \/* single_suspend *\/ false, nullptr);\n@@ -1083,2 +1083,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -1095,2 +1095,2 @@\n-\/\/ request_list - pre-checked for NULL\n-\/\/ results - pre-checked for NULL\n+\/\/ request_list - pre-checked for null\n+\/\/ results - pre-checked for null\n@@ -1099,2 +1099,2 @@\n-  oop thread_oop = NULL;\n-  JavaThread* java_thread = NULL;\n+  oop thread_oop = nullptr;\n+  JavaThread* java_thread = nullptr;\n@@ -1108,1 +1108,1 @@\n-    if (thread_oop != NULL &&\n+    if (thread_oop != nullptr &&\n@@ -1114,1 +1114,1 @@\n-      if (thread_oop == NULL || err != JVMTI_ERROR_INVALID_THREAD) {\n+      if (thread_oop == nullptr || err != JVMTI_ERROR_INVALID_THREAD) {\n@@ -1157,1 +1157,1 @@\n-        vt_oop != NULL &&\n+        vt_oop != nullptr &&\n@@ -1184,1 +1184,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1186,2 +1186,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -1193,1 +1193,1 @@\n-  if (thread_oop != NULL && java_lang_VirtualThread::is_instance(thread_oop)) {\n+  if (thread_oop != nullptr && java_lang_VirtualThread::is_instance(thread_oop)) {\n@@ -1216,1 +1216,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1219,2 +1219,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -1252,1 +1252,1 @@\n-\/\/ info_ptr - pre-checked for NULL\n+\/\/ info_ptr - pre-checked for null\n@@ -1258,2 +1258,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -1261,1 +1261,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1264,2 +1264,2 @@\n-  \/\/ if thread is NULL the current thread is used\n-  if (thread == NULL) {\n+  \/\/ if thread is null the current thread is used\n+  if (thread == nullptr) {\n@@ -1268,1 +1268,1 @@\n-    if (thread_oop == NULL || !thread_oop->is_a(vmClasses::Thread_klass())) {\n+    if (thread_oop == nullptr || !thread_oop->is_a(vmClasses::Thread_klass())) {\n@@ -1279,1 +1279,1 @@\n-      if (thread_oop == NULL) {\n+      if (thread_oop == nullptr) {\n@@ -1299,1 +1299,1 @@\n-      thread_group = Handle(current_thread, NULL);\n+      thread_group = Handle(current_thread, nullptr);\n@@ -1307,1 +1307,1 @@\n-      thread_group = Handle(current_thread, NULL);\n+      thread_group = Handle(current_thread, nullptr);\n@@ -1314,1 +1314,1 @@\n-  if (loader != NULL) {\n+  if (loader != nullptr) {\n@@ -1325,1 +1325,1 @@\n-    if (name() != NULL) {\n+    if (name() != nullptr) {\n@@ -1329,1 +1329,1 @@\n-      n = UNICODE::as_utf8((jchar*) NULL, utf8_length);\n+      n = UNICODE::as_utf8((jchar*) nullptr, utf8_length);\n@@ -1333,1 +1333,1 @@\n-    if (info_ptr->name == NULL)\n+    if (info_ptr->name == nullptr)\n@@ -1341,1 +1341,1 @@\n-  info_ptr->context_class_loader = (context_class_loader.is_null()) ? NULL :\n+  info_ptr->context_class_loader = (context_class_loader.is_null()) ? nullptr :\n@@ -1350,2 +1350,2 @@\n-\/\/ owned_monitor_count_ptr - pre-checked for NULL\n-\/\/ owned_monitors_ptr - pre-checked for NULL\n+\/\/ owned_monitor_count_ptr - pre-checked for null\n+\/\/ owned_monitors_ptr - pre-checked for null\n@@ -1361,1 +1361,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1364,2 +1364,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -1374,1 +1374,1 @@\n-    if (java_thread != NULL) {\n+    if (java_thread != nullptr) {\n@@ -1423,2 +1423,2 @@\n-\/\/ monitor_info_count_ptr - pre-checked for NULL\n-\/\/ monitor_info_ptr - pre-checked for NULL\n+\/\/ monitor_info_count_ptr - pre-checked for null\n+\/\/ monitor_info_ptr - pre-checked for null\n@@ -1434,1 +1434,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1437,2 +1437,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -1447,1 +1447,1 @@\n-    if (java_thread != NULL) {\n+    if (java_thread != nullptr) {\n@@ -1498,1 +1498,1 @@\n-\/\/ monitor_ptr - pre-checked for NULL\n+\/\/ monitor_ptr - pre-checked for null\n@@ -1504,1 +1504,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1507,2 +1507,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -1516,1 +1516,1 @@\n-    if (java_thread != NULL) {\n+    if (java_thread != nullptr) {\n@@ -1521,1 +1521,1 @@\n-      *monitor_ptr = NULL;\n+      *monitor_ptr = nullptr;\n@@ -1543,2 +1543,2 @@\n-\/\/ proc - pre-checked for NULL\n-\/\/ arg - NULL is a valid value, must be checked\n+\/\/ proc - pre-checked for null\n+\/\/ arg - null is a valid value, must be checked\n@@ -1549,2 +1549,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -1557,1 +1557,1 @@\n-    if (thread_oop == NULL) {\n+    if (thread_oop == nullptr) {\n@@ -1563,1 +1563,1 @@\n-  if (java_thread != NULL) {\n+  if (java_thread != nullptr) {\n@@ -1582,1 +1582,1 @@\n-  if (new_thread->osthread() == NULL) {\n+  if (new_thread->osthread() == nullptr) {\n@@ -1598,2 +1598,2 @@\n-\/\/ group_count_ptr - pre-checked for NULL\n-\/\/ groups_ptr - pre-checked for NULL\n+\/\/ group_count_ptr - pre-checked for null\n+\/\/ groups_ptr - pre-checked for null\n@@ -1624,1 +1624,1 @@\n-\/\/ info_ptr - pre-checked for NULL\n+\/\/ info_ptr - pre-checked for null\n@@ -1648,1 +1648,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -1653,1 +1653,1 @@\n-    info_ptr->name = NULL;\n+    info_ptr->name = nullptr;\n@@ -1659,4 +1659,4 @@\n-\/\/ thread_count_ptr - pre-checked for NULL\n-\/\/ threads_ptr - pre-checked for NULL\n-\/\/ group_count_ptr - pre-checked for NULL\n-\/\/ groups_ptr - pre-checked for NULL\n+\/\/ thread_count_ptr - pre-checked for null\n+\/\/ threads_ptr - pre-checked for null\n+\/\/ group_count_ptr - pre-checked for null\n+\/\/ groups_ptr - pre-checked for null\n@@ -1670,1 +1670,1 @@\n-  Handle *thread_objs = NULL;\n+  Handle *thread_objs = nullptr;\n@@ -1694,1 +1694,1 @@\n-  if (nthreads > 0 && *threads_ptr == NULL) {\n+  if (nthreads > 0 && *threads_ptr == nullptr) {\n@@ -1697,1 +1697,1 @@\n-  if (ngroups > 0 && *groups_ptr == NULL) {\n+  if (ngroups > 0 && *groups_ptr == nullptr) {\n@@ -1711,2 +1711,2 @@\n-\/\/ frame_buffer - pre-checked for NULL\n-\/\/ count_ptr - pre-checked for NULL\n+\/\/ frame_buffer - pre-checked for null\n+\/\/ count_ptr - pre-checked for null\n@@ -1718,1 +1718,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1721,2 +1721,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -1729,1 +1729,1 @@\n-    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n+    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n@@ -1760,2 +1760,2 @@\n-\/\/ stack_info_ptr - pre-checked for NULL\n-\/\/ thread_count_ptr - pre-checked for NULL\n+\/\/ stack_info_ptr - pre-checked for null\n+\/\/ thread_count_ptr - pre-checked for null\n@@ -1778,1 +1778,1 @@\n-\/\/ thread_list - pre-checked for NULL\n+\/\/ thread_list - pre-checked for null\n@@ -1780,1 +1780,1 @@\n-\/\/ stack_info_ptr - pre-checked for NULL\n+\/\/ stack_info_ptr - pre-checked for null\n@@ -1794,1 +1794,1 @@\n-    oop thread_obj = NULL;\n+    oop thread_obj = nullptr;\n@@ -1800,1 +1800,1 @@\n-    if (java_lang_VirtualThread::is_instance(thread_obj) && java_thread == NULL) {\n+    if (java_lang_VirtualThread::is_instance(thread_obj) && java_thread == nullptr) {\n@@ -1830,1 +1830,1 @@\n-\/\/ count_ptr - pre-checked for NULL\n+\/\/ count_ptr - pre-checked for null\n@@ -1836,1 +1836,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1839,2 +1839,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -1847,1 +1847,1 @@\n-    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n+    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n@@ -1877,1 +1877,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -1880,1 +1880,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1883,2 +1883,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -1887,1 +1887,1 @@\n-  if (thread_obj != NULL && java_lang_VirtualThread::is_instance(thread_obj)) {\n+  if (thread_obj != nullptr && java_lang_VirtualThread::is_instance(thread_obj)) {\n@@ -1897,1 +1897,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1921,2 +1921,2 @@\n-\/\/ method_ptr - pre-checked for NULL\n-\/\/ location_ptr - pre-checked for NULL\n+\/\/ method_ptr - pre-checked for null\n+\/\/ location_ptr - pre-checked for null\n@@ -1928,1 +1928,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1931,2 +1931,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -1939,1 +1939,1 @@\n-    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n+    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n@@ -1968,1 +1968,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -1971,2 +1971,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -1982,1 +1982,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1989,1 +1989,1 @@\n-    if (java_thread == NULL || java_thread == current) {\n+    if (java_thread == nullptr || java_thread == current) {\n@@ -2071,4 +2071,4 @@\n-\/\/ klass - NULL is a valid value, must be checked\n-\/\/ initial_object - NULL is a valid value, must be checked\n-\/\/ callbacks - pre-checked for NULL\n-\/\/ user_data - NULL is a valid value, must be checked\n+\/\/ klass - null is a valid value, must be checked\n+\/\/ initial_object - null is a valid value, must be checked\n+\/\/ callbacks - pre-checked for null\n+\/\/ user_data - null is a valid value, must be checked\n@@ -2078,2 +2078,2 @@\n-  Klass* k = NULL;\n-  if (klass != NULL) {\n+  Klass* k = nullptr;\n+  if (klass != nullptr) {\n@@ -2081,1 +2081,1 @@\n-    if (k_mirror == NULL) {\n+    if (k_mirror == nullptr) {\n@@ -2088,1 +2088,1 @@\n-    if (klass == NULL) {\n+    if (klass == nullptr) {\n@@ -2093,1 +2093,1 @@\n-  if (initial_object != NULL) {\n+  if (initial_object != nullptr) {\n@@ -2095,1 +2095,1 @@\n-    if (init_obj == NULL) {\n+    if (init_obj == nullptr) {\n@@ -2109,3 +2109,3 @@\n-\/\/ klass - NULL is a valid value, must be checked\n-\/\/ callbacks - pre-checked for NULL\n-\/\/ user_data - NULL is a valid value, must be checked\n+\/\/ klass - null is a valid value, must be checked\n+\/\/ callbacks - pre-checked for null\n+\/\/ user_data - null is a valid value, must be checked\n@@ -2115,2 +2115,2 @@\n-  Klass* k = NULL;\n-  if (klass != NULL) {\n+  Klass* k = nullptr;\n+  if (klass != nullptr) {\n@@ -2118,1 +2118,1 @@\n-    if (k_mirror == NULL) {\n+    if (k_mirror == nullptr) {\n@@ -2125,1 +2125,1 @@\n-    if (k == NULL) {\n+    if (k == nullptr) {\n@@ -2136,1 +2136,1 @@\n-\/\/ tag_ptr - pre-checked for NULL\n+\/\/ tag_ptr - pre-checked for null\n@@ -2156,4 +2156,4 @@\n-\/\/ tags - pre-checked for NULL\n-\/\/ count_ptr - pre-checked for NULL\n-\/\/ object_result_ptr - NULL is a valid value, must be checked\n-\/\/ tag_result_ptr - NULL is a valid value, must be checked\n+\/\/ tags - pre-checked for null\n+\/\/ count_ptr - pre-checked for null\n+\/\/ object_result_ptr - null is a valid value, must be checked\n+\/\/ tag_result_ptr - null is a valid value, must be checked\n@@ -2178,2 +2178,2 @@\n-\/\/ object_reference_callback - pre-checked for NULL\n-\/\/ user_data - NULL is a valid value, must be checked\n+\/\/ object_reference_callback - pre-checked for null\n+\/\/ user_data - null is a valid value, must be checked\n@@ -2189,4 +2189,4 @@\n-\/\/ heap_root_callback - NULL is a valid value, must be checked\n-\/\/ stack_ref_callback - NULL is a valid value, must be checked\n-\/\/ object_ref_callback - NULL is a valid value, must be checked\n-\/\/ user_data - NULL is a valid value, must be checked\n+\/\/ heap_root_callback - null is a valid value, must be checked\n+\/\/ stack_ref_callback - null is a valid value, must be checked\n+\/\/ object_ref_callback - null is a valid value, must be checked\n+\/\/ user_data - null is a valid value, must be checked\n@@ -2201,2 +2201,2 @@\n-\/\/ heap_object_callback - pre-checked for NULL\n-\/\/ user_data - NULL is a valid value, must be checked\n+\/\/ heap_object_callback - pre-checked for null\n+\/\/ user_data - null is a valid value, must be checked\n@@ -2208,1 +2208,1 @@\n-  JvmtiTagMap::tag_map_for(this)->iterate_over_heap(object_filter, NULL, heap_object_callback, user_data);\n+  JvmtiTagMap::tag_map_for(this)->iterate_over_heap(object_filter, nullptr, heap_object_callback, user_data);\n@@ -2214,2 +2214,2 @@\n-\/\/ heap_object_callback - pre-checked for NULL\n-\/\/ user_data - NULL is a valid value, must be checked\n+\/\/ heap_object_callback - pre-checked for null\n+\/\/ user_data - null is a valid value, must be checked\n@@ -2223,1 +2223,1 @@\n-  if (klass == NULL) {\n+  if (klass == nullptr) {\n@@ -2238,1 +2238,1 @@\n-\/\/ value_ptr - pre-checked for NULL\n+\/\/ value_ptr - pre-checked for null\n@@ -2246,1 +2246,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2249,2 +2249,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2279,1 +2279,1 @@\n-\/\/ value - pre-checked for NULL\n+\/\/ value - pre-checked for null\n@@ -2287,1 +2287,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2290,2 +2290,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2321,1 +2321,1 @@\n-\/\/ value_ptr - pre-checked for NULL\n+\/\/ value_ptr - pre-checked for null\n@@ -2329,1 +2329,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2332,2 +2332,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2363,1 +2363,1 @@\n-\/\/ value_ptr - pre-checked for NULL\n+\/\/ value_ptr - pre-checked for null\n@@ -2371,1 +2371,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2374,2 +2374,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2405,1 +2405,1 @@\n-\/\/ value_ptr - pre-checked for NULL\n+\/\/ value_ptr - pre-checked for null\n@@ -2413,1 +2413,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2416,2 +2416,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2447,1 +2447,1 @@\n-\/\/ value_ptr - pre-checked for NULL\n+\/\/ value_ptr - pre-checked for null\n@@ -2455,1 +2455,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2458,2 +2458,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2496,1 +2496,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2499,2 +2499,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2533,1 +2533,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2536,2 +2536,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2570,1 +2570,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2573,2 +2573,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2607,1 +2607,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2610,2 +2610,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2644,1 +2644,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n@@ -2647,2 +2647,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n@@ -2676,1 +2676,1 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n@@ -2702,1 +2702,1 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n@@ -2787,2 +2787,2 @@\n-\/\/ signature_ptr - NULL is a valid value, must be checked\n-\/\/ generic_ptr - NULL is a valid value, must be checked\n+\/\/ signature_ptr - null is a valid value, must be checked\n+\/\/ generic_ptr - null is a valid value, must be checked\n@@ -2793,1 +2793,1 @@\n-  Klass* k = NULL;\n+  Klass* k = nullptr;\n@@ -2798,2 +2798,2 @@\n-  if (signature_ptr != NULL) {\n-    char* result = NULL;\n+  if (signature_ptr != nullptr) {\n+    char* result = nullptr;\n@@ -2812,2 +2812,2 @@\n-  if (generic_ptr != NULL) {\n-    *generic_ptr = NULL;\n+  if (generic_ptr != nullptr) {\n+    *generic_ptr = nullptr;\n@@ -2816,1 +2816,1 @@\n-      if (soo != NULL) {\n+      if (soo != nullptr) {\n@@ -2818,1 +2818,1 @@\n-        if (gen_sig != NULL) {\n+        if (gen_sig != nullptr) {\n@@ -2836,1 +2836,1 @@\n-\/\/ status_ptr - pre-checked for NULL\n+\/\/ status_ptr - pre-checked for null\n@@ -2854,1 +2854,1 @@\n-\/\/ source_name_ptr - pre-checked for NULL\n+\/\/ source_name_ptr - pre-checked for null\n@@ -2882,1 +2882,1 @@\n-\/\/ modifiers_ptr - pre-checked for NULL\n+\/\/ modifiers_ptr - pre-checked for null\n@@ -2906,2 +2906,2 @@\n-\/\/ method_count_ptr - pre-checked for NULL\n-\/\/ methods_ptr - pre-checked for NULL\n+\/\/ method_count_ptr - pre-checked for null\n+\/\/ methods_ptr - pre-checked for null\n@@ -2947,1 +2947,1 @@\n-      result_list[result_index] = NULL;\n+      result_list[result_index] = nullptr;\n@@ -2954,1 +2954,1 @@\n-      if (id == NULL) {\n+      if (id == nullptr) {\n@@ -2970,1 +2970,1 @@\n-    \/\/ copy results skipping NULL methodIDs\n+    \/\/ copy results skipping null methodIDs\n@@ -2974,1 +2974,1 @@\n-      if (result_list[index] == NULL) {\n+      if (result_list[index] == nullptr) {\n@@ -2991,2 +2991,2 @@\n-\/\/ field_count_ptr - pre-checked for NULL\n-\/\/ fields_ptr - pre-checked for NULL\n+\/\/ field_count_ptr - pre-checked for null\n+\/\/ fields_ptr - pre-checked for null\n@@ -3046,2 +3046,2 @@\n-\/\/ interface_count_ptr - pre-checked for NULL\n-\/\/ interfaces_ptr - pre-checked for NULL\n+\/\/ interface_count_ptr - pre-checked for null\n+\/\/ interfaces_ptr - pre-checked for null\n@@ -3073,1 +3073,1 @@\n-    int result_length = (interface_list == NULL ? 0 : interface_list->length());\n+    int result_length = (interface_list == nullptr ? 0 : interface_list->length());\n@@ -3092,2 +3092,2 @@\n-\/\/ minor_version_ptr - pre-checked for NULL\n-\/\/ major_version_ptr - pre-checked for NULL\n+\/\/ minor_version_ptr - pre-checked for null\n+\/\/ major_version_ptr - pre-checked for null\n@@ -3118,3 +3118,3 @@\n-\/\/ constant_pool_count_ptr - pre-checked for NULL\n-\/\/ constant_pool_byte_count_ptr - pre-checked for NULL\n-\/\/ constant_pool_bytes_ptr - pre-checked for NULL\n+\/\/ constant_pool_count_ptr - pre-checked for null\n+\/\/ constant_pool_byte_count_ptr - pre-checked for null\n+\/\/ constant_pool_bytes_ptr - pre-checked for null\n@@ -3169,1 +3169,1 @@\n-\/\/ is_interface_ptr - pre-checked for NULL\n+\/\/ is_interface_ptr - pre-checked for null\n@@ -3176,1 +3176,1 @@\n-      if (k != NULL && k->is_interface()) {\n+      if (k != nullptr && k->is_interface()) {\n@@ -3188,1 +3188,1 @@\n-\/\/ is_array_class_ptr - pre-checked for NULL\n+\/\/ is_array_class_ptr - pre-checked for null\n@@ -3195,1 +3195,1 @@\n-      if (k != NULL && k->is_array_klass()) {\n+      if (k != nullptr && k->is_array_klass()) {\n@@ -3207,1 +3207,1 @@\n-\/\/ classloader_ptr - pre-checked for NULL\n+\/\/ classloader_ptr - pre-checked for null\n@@ -3221,1 +3221,1 @@\n-    if (result_oop == NULL) {\n+    if (result_oop == nullptr) {\n@@ -3234,1 +3234,1 @@\n-\/\/ source_debug_extension_ptr - pre-checked for NULL\n+\/\/ source_debug_extension_ptr - pre-checked for null\n@@ -3262,1 +3262,1 @@\n-\/\/ hash_code_ptr - pre-checked for NULL\n+\/\/ hash_code_ptr - pre-checked for null\n@@ -3277,1 +3277,1 @@\n-\/\/ info_ptr - pre-checked for NULL\n+\/\/ info_ptr - pre-checked for null\n@@ -3292,3 +3292,3 @@\n-\/\/ name_ptr - NULL is a valid value, must be checked\n-\/\/ signature_ptr - NULL is a valid value, must be checked\n-\/\/ generic_ptr - NULL is a valid value, must be checked\n+\/\/ name_ptr - null is a valid value, must be checked\n+\/\/ signature_ptr - null is a valid value, must be checked\n+\/\/ generic_ptr - null is a valid value, must be checked\n@@ -3299,1 +3299,1 @@\n-  if (name_ptr == NULL) {\n+  if (name_ptr == nullptr) {\n@@ -3304,1 +3304,1 @@\n-    if (*name_ptr == NULL)\n+    if (*name_ptr == nullptr)\n@@ -3308,1 +3308,1 @@\n-  if (signature_ptr== NULL) {\n+  if (signature_ptr== nullptr) {\n@@ -3313,1 +3313,1 @@\n-    if (*signature_ptr == NULL)\n+    if (*signature_ptr == nullptr)\n@@ -3317,2 +3317,2 @@\n-  if (generic_ptr != NULL) {\n-    *generic_ptr = NULL;\n+  if (generic_ptr != nullptr) {\n+    *generic_ptr = nullptr;\n@@ -3320,1 +3320,1 @@\n-    if (soop != NULL) {\n+    if (soop != nullptr) {\n@@ -3322,1 +3322,1 @@\n-      if (gen_sig != NULL) {\n+      if (gen_sig != nullptr) {\n@@ -3335,1 +3335,1 @@\n-\/\/ declaring_class_ptr - pre-checked for NULL\n+\/\/ declaring_class_ptr - pre-checked for null\n@@ -3344,1 +3344,1 @@\n-\/\/ modifiers_ptr - pre-checked for NULL\n+\/\/ modifiers_ptr - pre-checked for null\n@@ -3356,1 +3356,1 @@\n-\/\/ is_synthetic_ptr - pre-checked for NULL\n+\/\/ is_synthetic_ptr - pre-checked for null\n@@ -3368,4 +3368,4 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ name_ptr - NULL is a valid value, must be checked\n-\/\/ signature_ptr - NULL is a valid value, must be checked\n-\/\/ generic_ptr - NULL is a valid value, must be checked\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ name_ptr - null is a valid value, must be checked\n+\/\/ signature_ptr - null is a valid value, must be checked\n+\/\/ generic_ptr - null is a valid value, must be checked\n@@ -3378,1 +3378,1 @@\n-  if (name_ptr == NULL) {\n+  if (name_ptr == nullptr) {\n@@ -3385,1 +3385,1 @@\n-  if (signature_ptr == NULL) {\n+  if (signature_ptr == nullptr) {\n@@ -3393,2 +3393,2 @@\n-  if (generic_ptr != NULL) {\n-    *generic_ptr = NULL;\n+  if (generic_ptr != nullptr) {\n+    *generic_ptr = nullptr;\n@@ -3396,1 +3396,1 @@\n-    if (soop != NULL) {\n+    if (soop != nullptr) {\n@@ -3398,1 +3398,1 @@\n-      if (gen_sig != NULL) {\n+      if (gen_sig != nullptr) {\n@@ -3411,2 +3411,2 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ declaring_class_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ declaring_class_ptr - pre-checked for null\n@@ -3421,2 +3421,2 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ modifiers_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ modifiers_ptr - pre-checked for null\n@@ -3431,2 +3431,2 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ max_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ max_ptr - pre-checked for null\n@@ -3442,2 +3442,2 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ size_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ size_ptr - pre-checked for null\n@@ -3454,3 +3454,3 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ entry_count_ptr - pre-checked for NULL\n-\/\/ table_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ entry_count_ptr - pre-checked for null\n+\/\/ table_ptr - pre-checked for null\n@@ -3496,3 +3496,3 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ start_location_ptr - pre-checked for NULL\n-\/\/ end_location_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ start_location_ptr - pre-checked for null\n+\/\/ end_location_ptr - pre-checked for null\n@@ -3516,3 +3516,3 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ entry_count_ptr - pre-checked for NULL\n-\/\/ table_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ entry_count_ptr - pre-checked for null\n+\/\/ table_ptr - pre-checked for null\n@@ -3553,3 +3553,3 @@\n-      char *name_buf = NULL;\n-      char *sig_buf = NULL;\n-      char *gen_sig_buf = NULL;\n+      char *name_buf = nullptr;\n+      char *sig_buf = nullptr;\n+      char *gen_sig_buf = nullptr;\n@@ -3593,3 +3593,3 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ bytecode_count_ptr - pre-checked for NULL\n-\/\/ bytecodes_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ bytecode_count_ptr - pre-checked for null\n+\/\/ bytecodes_ptr - pre-checked for null\n@@ -3615,2 +3615,2 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ is_native_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ is_native_ptr - pre-checked for null\n@@ -3625,2 +3625,2 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ is_synthetic_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ is_synthetic_ptr - pre-checked for null\n@@ -3635,2 +3635,2 @@\n-\/\/ method - pre-checked for validity, but may be NULL meaning obsolete method\n-\/\/ is_obsolete_ptr - pre-checked for NULL\n+\/\/ method - pre-checked for validity, but may be null meaning obsolete method\n+\/\/ is_obsolete_ptr - pre-checked for null\n@@ -3647,1 +3647,1 @@\n-  if (method == NULL || method->is_obsolete()) {\n+  if (method == nullptr || method->is_obsolete()) {\n@@ -3659,2 +3659,2 @@\n-\/\/ name - pre-checked for NULL\n-\/\/ monitor_ptr - pre-checked for NULL\n+\/\/ name - pre-checked for null\n+\/\/ monitor_ptr - pre-checked for null\n@@ -3697,1 +3697,1 @@\n-    if (rmonitor->owner() != NULL) {\n+    if (rmonitor->owner() != nullptr) {\n@@ -3807,1 +3807,1 @@\n-\/\/ function_table - pre-checked for NULL\n+\/\/ function_table - pre-checked for null\n@@ -3818,1 +3818,1 @@\n-\/\/ function_table - pre-checked for NULL\n+\/\/ function_table - pre-checked for null\n@@ -3822,1 +3822,1 @@\n-  if (*function_table == NULL)\n+  if (*function_table == nullptr)\n@@ -3859,2 +3859,2 @@\n-\/\/ extension_count_ptr - pre-checked for NULL\n-\/\/ extensions - pre-checked for NULL\n+\/\/ extension_count_ptr - pre-checked for null\n+\/\/ extensions - pre-checked for null\n@@ -3867,2 +3867,2 @@\n-\/\/ extension_count_ptr - pre-checked for NULL\n-\/\/ extensions - pre-checked for NULL\n+\/\/ extension_count_ptr - pre-checked for null\n+\/\/ extensions - pre-checked for null\n@@ -3875,1 +3875,1 @@\n-\/\/ callback - NULL is a valid value, must be checked\n+\/\/ callback - null is a valid value, must be checked\n@@ -3885,1 +3885,1 @@\n-\/\/ info_ptr - pre-checked for NULL\n+\/\/ info_ptr - pre-checked for null\n@@ -3893,1 +3893,1 @@\n-\/\/ nanos_ptr - pre-checked for NULL\n+\/\/ nanos_ptr - pre-checked for null\n@@ -3910,1 +3910,1 @@\n-\/\/ info_ptr - pre-checked for NULL\n+\/\/ info_ptr - pre-checked for null\n@@ -3918,1 +3918,1 @@\n-\/\/ nanos_ptr - pre-checked for NULL\n+\/\/ nanos_ptr - pre-checked for null\n@@ -3923,2 +3923,2 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n@@ -3928,1 +3928,1 @@\n-  if (thread_oop != NULL && java_lang_VirtualThread::is_instance(thread_oop)) {\n+  if (thread_oop != nullptr && java_lang_VirtualThread::is_instance(thread_oop)) {\n@@ -3942,1 +3942,1 @@\n-\/\/ info_ptr - pre-checked for NULL\n+\/\/ info_ptr - pre-checked for null\n@@ -3950,1 +3950,1 @@\n-\/\/ nanos_ptr - pre-checked for NULL\n+\/\/ nanos_ptr - pre-checked for null\n@@ -3958,1 +3958,1 @@\n-\/\/ processor_count_ptr - pre-checked for NULL\n+\/\/ processor_count_ptr - pre-checked for null\n@@ -3978,2 +3978,2 @@\n-\/\/ count_ptr - pre-checked for NULL\n-\/\/ property_ptr - pre-checked for NULL\n+\/\/ count_ptr - pre-checked for null\n+\/\/ property_ptr - pre-checked for null\n@@ -3994,1 +3994,1 @@\n-  for (SystemProperty* p = Arguments::system_properties(); p != NULL && readable_count < *count_ptr; p = p->next()) {\n+  for (SystemProperty* p = Arguments::system_properties(); p != nullptr && readable_count < *count_ptr; p = p->next()) {\n@@ -4017,2 +4017,2 @@\n-\/\/ property - pre-checked for NULL\n-\/\/ value_ptr - pre-checked for NULL\n+\/\/ property - pre-checked for null\n+\/\/ value_ptr - pre-checked for null\n@@ -4026,1 +4026,1 @@\n-  if (value == NULL) {\n+  if (value == nullptr) {\n@@ -4038,2 +4038,2 @@\n-\/\/ property - pre-checked for NULL\n-\/\/ value - NULL is a valid value, must be checked\n+\/\/ property - pre-checked for null\n+\/\/ value - null is a valid value, must be checked\n@@ -4042,1 +4042,1 @@\n-  for (SystemProperty* p = Arguments::system_properties(); p != NULL; p = p->next()) {\n+  for (SystemProperty* p = Arguments::system_properties(); p != nullptr; p = p->next()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":406,"deletions":406,"binary":false,"changes":812,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-      _jthread = NULL;\n+      _jthread = nullptr;\n@@ -130,1 +130,1 @@\n-    if (_jthread != NULL)\n+    if (_jthread != nullptr)\n@@ -154,1 +154,1 @@\n-    if (state != NULL) {\n+    if (state != nullptr) {\n@@ -168,1 +168,1 @@\n-    if (state != NULL) {\n+    if (state != nullptr) {\n@@ -176,1 +176,1 @@\n-  jclass to_jclass(Klass* klass) { return (klass == NULL ? NULL : (jclass)to_jobject(klass->java_mirror())); }\n+  jclass to_jclass(Klass* klass) { return (klass == nullptr ? nullptr : (jclass)to_jobject(klass->java_mirror())); }\n@@ -202,1 +202,1 @@\n-    assert(thread->vthread() != NULL || thread->threadObj() == NULL, \"sanity check\");\n+    assert(thread->vthread() != nullptr || thread->threadObj() == nullptr, \"sanity check\");\n@@ -263,1 +263,1 @@\n-      _class_name = name != NULL? name->as_utf8() : NULL;\n+      _class_name = name != nullptr? name->as_utf8() : nullptr;\n@@ -266,2 +266,2 @@\n-      if (class_being_redefined == NULL) {\n-        _class_being_redefined = NULL;\n+      if (class_being_redefined == nullptr) {\n+        _class_being_redefined = nullptr;\n@@ -408,1 +408,1 @@\n-    *penv = NULL;\n+    *penv = nullptr;\n@@ -638,1 +638,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -646,1 +646,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -660,1 +660,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -669,1 +669,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -676,2 +676,2 @@\n-static OopStorage* _jvmti_oop_storage = NULL;\n-static OopStorage* _weak_tag_storage = NULL;\n+static OopStorage* _jvmti_oop_storage = nullptr;\n+static OopStorage* _weak_tag_storage = nullptr;\n@@ -680,1 +680,1 @@\n-  assert(_jvmti_oop_storage != NULL, \"not yet initialized\");\n+  assert(_jvmti_oop_storage != nullptr, \"not yet initialized\");\n@@ -685,1 +685,1 @@\n-  assert(_weak_tag_storage != NULL, \"not yet initialized\");\n+  assert(_weak_tag_storage != nullptr, \"not yet initialized\");\n@@ -704,1 +704,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -712,1 +712,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -726,1 +726,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -734,1 +734,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -760,1 +760,1 @@\n-\/\/ If thread_oop_p is not NULL, then the caller wants to use the oop\n+\/\/ If thread_oop_p is not null, then the caller wants to use the oop\n@@ -770,2 +770,2 @@\n-  assert(t_list != NULL, \"must have a ThreadsList\");\n-  assert(jt_pp != NULL, \"must have a return JavaThread pointer\");\n+  assert(t_list != nullptr, \"must have a ThreadsList\");\n+  assert(jt_pp != nullptr, \"must have a return JavaThread pointer\");\n@@ -774,2 +774,2 @@\n-  if (thread_oop_p != NULL) {\n-    *thread_oop_p = NULL;\n+  if (thread_oop_p != nullptr) {\n+    *thread_oop_p = nullptr;\n@@ -779,2 +779,2 @@\n-  if (thread_oop == NULL) {\n-    \/\/ NULL jthread, GC'ed jthread or a bad JNI handle.\n+  if (thread_oop == nullptr) {\n+    \/\/ null jthread, GC'ed jthread or a bad JNI handle.\n@@ -791,1 +791,1 @@\n-  if (thread_oop_p != NULL) {\n+  if (thread_oop_p != nullptr) {\n@@ -798,1 +798,1 @@\n-  if (java_thread == NULL) {\n+  if (java_thread == nullptr) {\n@@ -833,3 +833,3 @@\n-  assert(t_list != NULL, \"must have a ThreadsList\");\n-  assert(thread_oop != NULL, \"must have an oop\");\n-  assert(jt_pp != NULL, \"must have a return JavaThread pointer\");\n+  assert(t_list != nullptr, \"must have a ThreadsList\");\n+  assert(thread_oop != nullptr, \"must have an oop\");\n+  assert(jt_pp != nullptr, \"must have a return JavaThread pointer\");\n@@ -844,1 +844,1 @@\n-  if (java_thread == NULL) {\n+  if (java_thread == nullptr) {\n@@ -895,1 +895,1 @@\n-    _curr_env = NULL;\n+    _curr_env = nullptr;\n@@ -901,1 +901,1 @@\n-    if (_state != NULL) {\n+    if (_state != nullptr) {\n@@ -904,2 +904,2 @@\n-      Klass* klass = (_class_being_redefined == NULL) ? NULL : _class_being_redefined;\n-      if (_load_kind != jvmti_class_load_kind_load && klass != NULL) {\n+      Klass* klass = (_class_being_redefined == nullptr) ? nullptr : _class_being_redefined;\n+      if (_load_kind != jvmti_class_load_kind_load && klass != nullptr) {\n@@ -907,1 +907,1 @@\n-        assert(module_entry != NULL, \"module_entry should always be set\");\n+        assert(module_entry != nullptr, \"module_entry should always be set\");\n@@ -909,1 +909,1 @@\n-            module_entry->module() != NULL &&\n+            module_entry->module() != nullptr &&\n@@ -927,1 +927,1 @@\n-      _class_being_redefined = NULL;\n+      _class_being_redefined = nullptr;\n@@ -945,1 +945,1 @@\n-      for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+      for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -954,1 +954,1 @@\n-    for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+    for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -968,1 +968,1 @@\n-    unsigned char *new_data = NULL;\n+    unsigned char *new_data = nullptr;\n@@ -975,1 +975,1 @@\n-    if (callback != NULL) {\n+    if (callback != nullptr) {\n@@ -983,1 +983,1 @@\n-    if (new_data != NULL) {\n+    if (new_data != nullptr) {\n@@ -986,1 +986,1 @@\n-      if (caching_needed && *_cached_class_file_ptr == NULL) {\n+      if (caching_needed && *_cached_class_file_ptr == nullptr) {\n@@ -992,1 +992,1 @@\n-        if (p == NULL) {\n+        if (p == nullptr) {\n@@ -1036,1 +1036,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -1084,1 +1084,1 @@\n-      assert(k != NULL, \"class for non-primitive mirror must exist\");\n+      assert(k != nullptr, \"class for non-primitive mirror must exist\");\n@@ -1111,1 +1111,1 @@\n-  JvmtiCompiledMethodLoadEventMark(JavaThread *thread, nmethod *nm, void* compile_info_ptr = NULL)\n+  JvmtiCompiledMethodLoadEventMark(JavaThread *thread, nmethod *nm, void* compile_info_ptr = nullptr)\n@@ -1115,1 +1115,1 @@\n-    _compile_info = compile_info_ptr; \/\/ Set void pointer of compiledMethodLoad Event. Default value is NULL.\n+    _compile_info = compile_info_ptr; \/\/ Set void pointer of compiledMethodLoad Event. Default value is null.\n@@ -1159,1 +1159,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -1173,1 +1173,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -1190,1 +1190,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1200,1 +1200,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1207,2 +1207,2 @@\n-                     (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                     (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string(),\n+                     (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                     (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string(),\n@@ -1215,1 +1215,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -1280,1 +1280,1 @@\n-  if (vt != NULL && java_lang_VirtualThread::is_instance(vt)) {\n+  if (vt != nullptr && java_lang_VirtualThread::is_instance(vt)) {\n@@ -1304,1 +1304,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1323,1 +1323,1 @@\n-  if (state != NULL) {\n+  if (state != nullptr) {\n@@ -1331,1 +1331,1 @@\n-  if (state != NULL && state->is_enabled(JVMTI_EVENT_SINGLE_STEP)) {\n+  if (state != nullptr && state->is_enabled(JVMTI_EVENT_SINGLE_STEP)) {\n@@ -1346,1 +1346,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1357,1 +1357,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1365,1 +1365,1 @@\n-                                         klass==NULL? \"NULL\" : klass->external_name() ));\n+                                         klass==nullptr? \"null\" : klass->external_name() ));\n@@ -1369,1 +1369,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -1384,1 +1384,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1395,1 +1395,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1403,1 +1403,1 @@\n-                                            klass==NULL? \"NULL\" : klass->external_name() ));\n+                                            klass==nullptr? \"null\" : klass->external_name() ));\n@@ -1407,1 +1407,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -1440,1 +1440,1 @@\n-    for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+    for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -1450,1 +1450,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1475,1 +1475,1 @@\n-    for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+    for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -1486,1 +1486,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1503,1 +1503,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1512,1 +1512,1 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1524,1 +1524,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1541,1 +1541,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1548,1 +1548,1 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1559,1 +1559,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1575,1 +1575,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1582,1 +1582,1 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1593,1 +1593,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1610,1 +1610,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1617,1 +1617,1 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1628,1 +1628,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1645,1 +1645,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1652,1 +1652,1 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1663,1 +1663,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1678,1 +1678,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1688,1 +1688,1 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1706,1 +1706,1 @@\n-  assert(objects != NULL, \"Nothing to post\");\n+  assert(objects != nullptr, \"Nothing to post\");\n@@ -1722,1 +1722,1 @@\n-  if (callback != NULL) {\n+  if (callback != nullptr) {\n@@ -1752,1 +1752,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -1759,1 +1759,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -1761,1 +1761,1 @@\n-                    resource_exhausted_flags, NULL, description);\n+                    resource_exhausted_flags, nullptr, description);\n@@ -1772,1 +1772,1 @@\n-  if (state == NULL || !state->is_interp_only_mode()) {\n+  if (state == nullptr || !state->is_interp_only_mode()) {\n@@ -1781,2 +1781,2 @@\n-                     (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                     (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string() ));\n+                     (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                     (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string() ));\n@@ -1788,1 +1788,1 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1792,2 +1792,2 @@\n-                                             (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                                             (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string() ));\n+                                             (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                                             (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string() ));\n@@ -1799,1 +1799,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1813,1 +1813,1 @@\n-  if (state == NULL || !state->is_interp_only_mode()) {\n+  if (state == nullptr || !state->is_interp_only_mode()) {\n@@ -1866,2 +1866,2 @@\n-                                           (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                                           (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string() ));\n+                                           (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                                           (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string() ));\n@@ -1871,1 +1871,1 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1875,2 +1875,2 @@\n-                                            (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                                            (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string() ));\n+                                            (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                                            (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string() ));\n@@ -1882,1 +1882,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -1891,1 +1891,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1901,2 +1901,2 @@\n-                                            (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                                            (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string() ));\n+                                            (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                                            (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string() ));\n@@ -1909,1 +1909,1 @@\n-          if (callback != NULL) {\n+          if (callback != nullptr) {\n@@ -1933,1 +1933,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1941,1 +1941,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -1946,2 +1946,2 @@\n-                    (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                    (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string(),\n+                    (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                    (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string(),\n@@ -1954,1 +1954,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -1975,1 +1975,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -1987,2 +1987,2 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n-      if (ets->is_enabled(JVMTI_EVENT_EXCEPTION) && (exception != NULL)) {\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n+      if (ets->is_enabled(JVMTI_EVENT_EXCEPTION) && (exception != nullptr)) {\n@@ -1993,2 +1993,2 @@\n-                      (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                      (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string(),\n+                      (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                      (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string(),\n@@ -2007,1 +2007,1 @@\n-        Method* current_method = NULL;\n+        Method* current_method = nullptr;\n@@ -2042,1 +2042,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -2063,1 +2063,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -2069,2 +2069,2 @@\n-                     (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                     (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string(),\n+                     (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                     (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string(),\n@@ -2094,1 +2094,1 @@\n-      assert(location != NULL, \"must be a known location\");\n+      assert(location != nullptr, \"must be a known location\");\n@@ -2104,2 +2104,2 @@\n-      for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n-        if (ets->is_enabled(JVMTI_EVENT_EXCEPTION_CATCH) && (exception_handle() != NULL)) {\n+      for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n+        if (ets->is_enabled(JVMTI_EVENT_EXCEPTION_CATCH) && (exception_handle() != nullptr)) {\n@@ -2109,2 +2109,2 @@\n-                      (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                      (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string(),\n+                      (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                      (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string(),\n@@ -2117,1 +2117,1 @@\n-          if (callback != NULL) {\n+          if (callback != nullptr) {\n@@ -2134,1 +2134,1 @@\n-    if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);\n+    if (jobj != nullptr) return JNIHandles::resolve_non_null(jobj);\n@@ -2163,1 +2163,1 @@\n-    assert(obj != NULL, \"non-static needs an object\");\n+    assert(obj != nullptr, \"non-static needs an object\");\n@@ -2179,1 +2179,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -2189,1 +2189,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -2193,2 +2193,2 @@\n-                     (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                     (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string(),\n+                     (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                     (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string(),\n@@ -2203,1 +2203,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2219,1 +2219,1 @@\n-    if (jobj != NULL) return JNIHandles::resolve_non_null(jobj);\n+    if (jobj != nullptr) return JNIHandles::resolve_non_null(jobj);\n@@ -2250,1 +2250,1 @@\n-    assert(obj != NULL, \"non-static needs an object\");\n+    assert(obj != nullptr, \"non-static needs an object\");\n@@ -2335,1 +2335,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -2346,1 +2346,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -2351,2 +2351,2 @@\n-                    (mh() == NULL) ? \"NULL\" : mh()->klass_name()->as_C_string(),\n-                    (mh() == NULL) ? \"NULL\" : mh()->name()->as_C_string(),\n+                    (mh() == nullptr) ? \"null\" : mh()->klass_name()->as_C_string(),\n+                    (mh() == nullptr) ? \"null\" : mh()->name()->as_C_string(),\n@@ -2361,1 +2361,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2385,1 +2385,1 @@\n-    for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+    for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -2392,1 +2392,1 @@\n-        JNIEnv* jni_env = (env->phase() == JVMTI_PHASE_PRIMORDIAL) ? NULL : jem.jni_env();\n+        JNIEnv* jni_env = (env->phase() == JVMTI_PHASE_PRIMORDIAL) ? nullptr : jem.jni_env();\n@@ -2394,1 +2394,1 @@\n-        if (callback != NULL) {\n+        if (callback != nullptr) {\n@@ -2408,1 +2408,1 @@\n-  record->header.next = NULL;\n+  record->header.next = nullptr;\n@@ -2421,1 +2421,1 @@\n-    assert(pc_address != NULL, \"pc_address must be non-null\");\n+    assert(pc_address != nullptr, \"pc_address must be non-null\");\n@@ -2424,1 +2424,1 @@\n-    for(ScopeDesc* sd = nm->scope_desc_at(p->real_pc(nm));sd != NULL;sd = sd->sender()) {\n+    for(ScopeDesc* sd = nm->scope_desc_at(p->real_pc(nm));sd != nullptr;sd = sd->sender()) {\n@@ -2432,3 +2432,3 @@\n-    for(ScopeDesc* sd = nm->scope_desc_at(p->real_pc(nm));sd != NULL;sd = sd->sender()) {\n-      \/\/ sd->method() can be NULL for stubs but not for nmethods. To be completely robust, include an assert that we should never see a null sd->method()\n-      guarantee(sd->method() != NULL, \"sd->method() cannot be null.\");\n+    for(ScopeDesc* sd = nm->scope_desc_at(p->real_pc(nm));sd != nullptr;sd = sd->sender()) {\n+      \/\/ sd->method() can be null for stubs but not for nmethods. To be completely robust, include an assert that we should never see a null sd->method()\n+      guarantee(sd->method() != nullptr, \"sd->method() cannot be null.\");\n@@ -2458,1 +2458,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -2469,1 +2469,1 @@\n-  if (callback == NULL) {\n+  if (callback == nullptr) {\n@@ -2479,2 +2479,2 @@\n-            (nm->method() == NULL) ? \"NULL\" : nm->method()->klass_name()->as_C_string(),\n-            (nm->method() == NULL) ? \"NULL\" : nm->method()->name()->as_C_string()));\n+            (nm->method() == nullptr) ? \"null\" : nm->method()->klass_name()->as_C_string(),\n+            (nm->method() == nullptr) ? \"null\" : nm->method()->name()->as_C_string()));\n@@ -2495,1 +2495,1 @@\n-  assert(name != NULL && name[0] != '\\0', \"sanity check\");\n+  assert(name != nullptr && name[0] != '\\0', \"sanity check\");\n@@ -2509,1 +2509,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -2518,1 +2518,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2560,1 +2560,1 @@\n-    if (callback != NULL) {\n+    if (callback != nullptr) {\n@@ -2576,1 +2576,1 @@\n-  \/\/ The collector and\/or state might be NULL if JvmtiDynamicCodeEventCollector\n+  \/\/ The collector and\/or state might be null if JvmtiDynamicCodeEventCollector\n@@ -2579,1 +2579,1 @@\n-  if (state != NULL) {\n+  if (state != nullptr) {\n@@ -2581,1 +2581,1 @@\n-    if (collector != NULL) {\n+    if (collector != nullptr) {\n@@ -2590,1 +2590,1 @@\n-  if (thread != NULL && thread->is_Java_thread())  {\n+  if (thread != nullptr && thread->is_Java_thread())  {\n@@ -2596,2 +2596,2 @@\n-    if (state != NULL) {\n-      \/\/ state is non NULL when VMObjectAllocEventCollector is enabled.\n+    if (state != nullptr) {\n+      \/\/ state is non null when VMObjectAllocEventCollector is enabled.\n@@ -2600,1 +2600,1 @@\n-      if (collector != NULL && collector->is_enabled()) {\n+      if (collector != nullptr && collector->is_enabled()) {\n@@ -2614,1 +2614,1 @@\n-  if (thread != NULL && thread->is_Java_thread())  {\n+  if (thread != nullptr && thread->is_Java_thread())  {\n@@ -2620,2 +2620,2 @@\n-    if (state != NULL) {\n-      \/\/ state is non NULL when SampledObjectAllocEventCollector is enabled.\n+    if (state != nullptr) {\n+      \/\/ state is non null when SampledObjectAllocEventCollector is enabled.\n@@ -2625,1 +2625,1 @@\n-      if (collector != NULL && collector->is_enabled()) {\n+      if (collector != nullptr && collector->is_enabled()) {\n@@ -2638,1 +2638,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -2644,1 +2644,1 @@\n-      \/\/ JNIEnv is NULL here because this event is posted from VM Thread\n+      \/\/ JNIEnv is null here because this event is posted from VM Thread\n@@ -2646,1 +2646,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2659,1 +2659,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -2665,1 +2665,1 @@\n-      \/\/ JNIEnv is NULL here because this event is posted from VM Thread\n+      \/\/ JNIEnv is null here because this event is posted from VM Thread\n@@ -2667,1 +2667,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2680,1 +2680,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -2686,1 +2686,1 @@\n-     \/\/ JNIEnv is NULL here because this event is posted from VM Thread\n+     \/\/ JNIEnv is null here because this event is posted from VM Thread\n@@ -2688,1 +2688,1 @@\n-     if (callback != NULL) {\n+     if (callback != nullptr) {\n@@ -2698,1 +2698,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -2712,1 +2712,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -2721,1 +2721,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2731,1 +2731,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -2746,1 +2746,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -2755,1 +2755,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2765,1 +2765,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -2779,1 +2779,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -2788,1 +2788,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2799,1 +2799,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -2813,1 +2813,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -2822,1 +2822,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2831,1 +2831,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -2843,1 +2843,1 @@\n-  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -2847,1 +2847,1 @@\n-                                         object==NULL? \"NULL\" : object->klass()->external_name()));\n+                                         object==nullptr? \"null\" : object->klass()->external_name()));\n@@ -2852,1 +2852,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2862,1 +2862,1 @@\n-  if (state == NULL) {\n+  if (state == nullptr) {\n@@ -2865,1 +2865,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -2878,1 +2878,1 @@\n-  for (JvmtiEnvThreadState* ets = it.first(); ets != NULL; ets = it.next(ets)) {\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n@@ -2883,1 +2883,1 @@\n-                 object == NULL ? \"NULL\" : object->klass()->external_name()));\n+                 object == nullptr ? \"null\" : object->klass()->external_name()));\n@@ -2889,1 +2889,1 @@\n-      if (callback != NULL) {\n+      if (callback != nullptr) {\n@@ -2903,1 +2903,1 @@\n-  if (thread->jvmti_thread_state() != NULL) {\n+  if (thread->jvmti_thread_state() != nullptr) {\n@@ -2915,1 +2915,1 @@\n-  if (state != NULL) {\n+  if (state != nullptr) {\n@@ -2938,1 +2938,1 @@\n-  void* library = NULL;\n+  void* library = nullptr;\n@@ -2944,1 +2944,1 @@\n-  bool is_absolute_path = (absParam != NULL) && (strcmp(absParam,\"true\")==0);\n+  bool is_absolute_path = (absParam != nullptr) && (strcmp(absParam,\"true\")==0);\n@@ -2947,1 +2947,1 @@\n-  AgentLibrary *agent_lib = new AgentLibrary(agent, options, is_absolute_path, NULL);\n+  AgentLibrary *agent_lib = new AgentLibrary(agent, options, is_absolute_path, nullptr);\n@@ -2962,1 +2962,1 @@\n-      if (library == NULL) {\n+      if (library == nullptr) {\n@@ -2969,1 +2969,1 @@\n-    if (library != NULL) {\n+    if (library != nullptr) {\n@@ -2978,1 +2978,1 @@\n-    OnAttachEntry_t on_attach_entry = NULL;\n+    OnAttachEntry_t on_attach_entry = nullptr;\n@@ -2981,1 +2981,1 @@\n-    if (on_attach_entry == NULL) {\n+    if (on_attach_entry == nullptr) {\n@@ -2997,1 +2997,1 @@\n-        result = (*on_attach_entry)(&main_vm, (char*)options, NULL);\n+        result = (*on_attach_entry)(&main_vm, (char*)options, nullptr);\n@@ -3041,1 +3041,1 @@\n-  \/\/ state can only be NULL if the current thread is exiting which\n+  \/\/ state can only be null if the current thread is exiting which\n@@ -3043,1 +3043,1 @@\n-  guarantee(state != NULL, \"exiting thread called setup_jvmti_thread_state\");\n+  guarantee(state != nullptr, \"exiting thread called setup_jvmti_thread_state\");\n@@ -3080,1 +3080,1 @@\n-  if (state != NULL) {\n+  if (state != nullptr) {\n@@ -3108,1 +3108,1 @@\n-JvmtiDynamicCodeEventCollector::JvmtiDynamicCodeEventCollector() : _code_blobs(NULL) {\n+JvmtiDynamicCodeEventCollector::JvmtiDynamicCodeEventCollector() : _code_blobs(nullptr) {\n@@ -3119,1 +3119,1 @@\n- if (_code_blobs != NULL) {\n+ if (_code_blobs != nullptr) {\n@@ -3132,1 +3132,1 @@\n- if (_code_blobs == NULL) {\n+ if (_code_blobs == nullptr) {\n@@ -3140,1 +3140,1 @@\n-    _allocated(NULL), _enable(false), _post_callback(NULL) {\n+    _allocated(nullptr), _enable(false), _post_callback(nullptr) {\n@@ -3155,1 +3155,1 @@\n-    delete _allocated, _allocated = NULL;\n+    delete _allocated, _allocated = nullptr;\n@@ -3161,1 +3161,1 @@\n-  if (_allocated == NULL) {\n+  if (_allocated == nullptr) {\n@@ -3168,1 +3168,1 @@\n-NoJvmtiVMObjectAllocMark::NoJvmtiVMObjectAllocMark() : _collector(NULL) {\n+NoJvmtiVMObjectAllocMark::NoJvmtiVMObjectAllocMark() : _collector(nullptr) {\n@@ -3174,1 +3174,1 @@\n-  if (thread != NULL && thread->is_Java_thread())  {\n+  if (thread != nullptr && thread->is_Java_thread())  {\n@@ -3177,1 +3177,1 @@\n-    if (state != NULL) {\n+    if (state != nullptr) {\n@@ -3180,1 +3180,1 @@\n-      if (collector != NULL && collector->is_enabled()) {\n+      if (collector != nullptr && collector->is_enabled()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":233,"deletions":233,"binary":false,"changes":466,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-      for (Klass* l = k->array_klass_or_null(); l != NULL; l = l->array_klass_or_null()) {\n+      for (Klass* l = k->array_klass_or_null(); l != nullptr; l = l->array_klass_or_null()) {\n@@ -133,2 +133,2 @@\n-    \/\/ dictionary, or the NULL ClassLoaderData dictionary for bootstrap loader.\n-    if (loader != NULL) {\n+    \/\/ dictionary, or the null ClassLoaderData dictionary for bootstrap loader.\n+    if (loader != nullptr) {\n@@ -137,1 +137,1 @@\n-      if (data != NULL && data->dictionary() != NULL) {\n+      if (data != nullptr && data->dictionary() != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,2 +111,2 @@\n-    if (_cache[i] == NULL) {\n-      assert(false, \"cannot recache NULL elements\");\n+    if (_cache[i] == nullptr) {\n+      assert(false, \"cannot recache null elements\");\n@@ -117,1 +117,1 @@\n-  _cache[len] = NULL;\n+  _cache[len] = nullptr;\n@@ -124,2 +124,2 @@\n-  assert(e1 != NULL, \"e1 != NULL\");\n-  assert(e2 != NULL, \"e2 != NULL\");\n+  assert(e1 != nullptr, \"e1 != nullptr\");\n+  assert(e2 != nullptr, \"e2 != nullptr\");\n@@ -135,4 +135,4 @@\n-  _this_obj       = NULL;\n-  _listener_fun   = NULL;\n-  _elements       = NULL;\n-  _cache          = NULL;\n+  _this_obj       = nullptr;\n+  _listener_fun   = nullptr;\n+  _elements       = nullptr;\n+  _cache          = nullptr;\n@@ -162,1 +162,1 @@\n-  assert(e != NULL, \"e != NULL\");\n+  assert(e != nullptr, \"e != nullptr\");\n@@ -180,1 +180,1 @@\n-  assert(e != NULL, \"e != NULL\");\n+  assert(e != nullptr, \"e != nullptr\");\n@@ -203,1 +203,1 @@\n-  assert(_method != NULL, \"No method for breakpoint.\");\n+  assert(_method != nullptr, \"No method for breakpoint.\");\n@@ -239,1 +239,1 @@\n-       pv_node != NULL;\n+       pv_node != nullptr;\n@@ -280,2 +280,2 @@\n-  const char *class_name  = (_method == NULL) ? \"NULL\" : _method->klass_name()->as_C_string();\n-  const char *method_name = (_method == NULL) ? \"NULL\" : _method->name()->as_C_string();\n+  const char *class_name  = (_method == nullptr) ? \"null\" : _method->klass_name()->as_C_string();\n+  const char *method_name = (_method == nullptr) ? \"null\" : _method->name()->as_C_string();\n@@ -405,2 +405,2 @@\n-JvmtiBreakpoints *JvmtiCurrentBreakpoints::_jvmti_breakpoints  = NULL;\n-address *         JvmtiCurrentBreakpoints::_breakpoint_list    = NULL;\n+JvmtiBreakpoints *JvmtiCurrentBreakpoints::_jvmti_breakpoints  = nullptr;\n+address *         JvmtiCurrentBreakpoints::_breakpoint_list    = nullptr;\n@@ -410,1 +410,1 @@\n-  if (_jvmti_breakpoints != NULL) return (*_jvmti_breakpoints);\n+  if (_jvmti_breakpoints != nullptr) return (*_jvmti_breakpoints);\n@@ -412,1 +412,1 @@\n-  assert(_jvmti_breakpoints != NULL, \"_jvmti_breakpoints != NULL\");\n+  assert(_jvmti_breakpoints != nullptr, \"_jvmti_breakpoints != nullptr\");\n@@ -418,1 +418,1 @@\n-  assert(this_jvmti != NULL, \"this_jvmti != NULL\");\n+  assert(this_jvmti != nullptr, \"this_jvmti != nullptr\");\n@@ -421,1 +421,1 @@\n-  assert(cache[n] == NULL, \"cache must be NULL terminated\");\n+  assert(cache[n] == nullptr, \"cache must be null terminated\");\n@@ -441,1 +441,1 @@\n-  , _jvf(NULL)\n+  , _jvf(nullptr)\n@@ -454,3 +454,3 @@\n-  assert(ty_sign != NULL, \"type signature must not be NULL\");\n-  assert(thread != NULL, \"thread must not be NULL\");\n-  assert(klass != NULL, \"klass must not be NULL\");\n+  assert(ty_sign != nullptr, \"type signature must not be null\");\n+  assert(thread != nullptr, \"thread must not be null\");\n+  assert(klass != nullptr, \"klass must not be null\");\n@@ -550,1 +550,1 @@\n-  if (_set && slot_type == T_OBJECT && jobj != NULL) { \/\/ NULL reference is allowed\n+  if (_set && slot_type == T_OBJECT && jobj != nullptr) { \/\/ null reference is allowed\n@@ -611,1 +611,1 @@\n-  if (_jvf == NULL) {\n+  if (_jvf == nullptr) {\n@@ -752,1 +752,1 @@\n-  : VM_BaseGetOrSetLocal(NULL, depth, index, type, _DEFAULT_VALUE, false, self),\n+  : VM_BaseGetOrSetLocal(nullptr, depth, index, type, _DEFAULT_VALUE, false, self),\n@@ -754,1 +754,1 @@\n-    _eb(false, NULL, NULL)\n+    _eb(false, nullptr, nullptr)\n@@ -760,1 +760,1 @@\n-  : VM_BaseGetOrSetLocal(NULL, depth, index, type, value, true, self),\n+  : VM_BaseGetOrSetLocal(nullptr, depth, index, type, value, true, self),\n@@ -776,1 +776,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -784,1 +784,1 @@\n-  while ((vf != NULL) && (d < _depth)) {\n+  while ((vf != nullptr) && (d < _depth)) {\n@@ -795,1 +795,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -797,1 +797,1 @@\n-  if (vf == NULL) {\n+  if (vf == nullptr) {\n@@ -799,1 +799,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -805,1 +805,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -823,1 +823,1 @@\n-  : VM_BaseGetOrSetLocal(NULL, depth, index, type, _DEFAULT_VALUE, false, self)\n+  : VM_BaseGetOrSetLocal(nullptr, depth, index, type, _DEFAULT_VALUE, false, self)\n@@ -832,1 +832,1 @@\n-  : VM_BaseGetOrSetLocal(NULL, depth, index, type, value, true, self)\n+  : VM_BaseGetOrSetLocal(nullptr, depth, index, type, value, true, self)\n@@ -850,1 +850,1 @@\n-  assert(cont != NULL, \"vthread contintuation must not be NULL\");\n+  assert(cont != nullptr, \"vthread contintuation must not be null\");\n@@ -852,1 +852,1 @@\n-  javaVFrame* jvf = NULL;\n+  javaVFrame* jvf = nullptr;\n@@ -854,1 +854,1 @@\n-  bool is_cont_mounted = (java_thread != NULL);\n+  bool is_cont_mounted = (java_thread != nullptr);\n@@ -858,1 +858,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -877,1 +877,1 @@\n-  while ((jvf != NULL) && (d < _depth)) {\n+  while ((jvf != nullptr) && (d < _depth)) {\n@@ -882,1 +882,1 @@\n-  if (d < _depth || jvf == NULL) {\n+  if (d < _depth || jvf == nullptr) {\n@@ -884,1 +884,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -889,1 +889,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -989,1 +989,1 @@\n-        (_event_data.dynamic_code_generated.name == NULL)\n+        (_event_data.dynamic_code_generated.name == nullptr)\n@@ -993,1 +993,1 @@\n-      if (_event_data.dynamic_code_generated.name != NULL) {\n+      if (_event_data.dynamic_code_generated.name != nullptr) {\n@@ -1002,1 +1002,1 @@\n-        (_event_data.class_unload.name == NULL)\n+        (_event_data.class_unload.name == nullptr)\n@@ -1004,1 +1004,1 @@\n-      if (_event_data.class_unload.name != NULL) {\n+      if (_event_data.class_unload.name != nullptr) {\n@@ -1030,1 +1030,1 @@\n-  if (cf != NULL && _type == TYPE_COMPILED_METHOD_LOAD) {\n+  if (cf != nullptr && _type == TYPE_COMPILED_METHOD_LOAD) {\n@@ -1038,1 +1038,1 @@\n-  if (cf != NULL && _type == TYPE_COMPILED_METHOD_LOAD) {\n+  if (cf != nullptr && _type == TYPE_COMPILED_METHOD_LOAD) {\n@@ -1052,1 +1052,1 @@\n-  return JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE  && _queue_head != NULL;\n+  return JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE  && _queue_head != nullptr;\n@@ -1058,1 +1058,1 @@\n-  if (_queue_tail == NULL) {\n+  if (_queue_tail == nullptr) {\n@@ -1061,1 +1061,1 @@\n-    assert(_queue_tail->next() == NULL, \"Must be the last element in the list\");\n+    assert(_queue_tail->next() == nullptr, \"Must be the last element in the list\");\n@@ -1066,1 +1066,1 @@\n-  assert((_queue_head == NULL) == (_queue_tail == NULL),\n+  assert((_queue_head == nullptr) == (_queue_tail == nullptr),\n@@ -1071,1 +1071,1 @@\n-  assert(_queue_head != NULL, \"Nothing to dequeue\");\n+  assert(_queue_head != nullptr, \"Nothing to dequeue\");\n@@ -1073,1 +1073,1 @@\n-  if (_queue_head == NULL) {\n+  if (_queue_head == nullptr) {\n@@ -1080,2 +1080,2 @@\n-  if (_queue_head == NULL) {\n-    _queue_tail = NULL;\n+  if (_queue_head == nullptr) {\n+    _queue_tail = nullptr;\n@@ -1084,1 +1084,1 @@\n-  assert((_queue_head == NULL) == (_queue_tail == NULL),\n+  assert((_queue_head == nullptr) == (_queue_tail == nullptr),\n@@ -1094,1 +1094,1 @@\n-  while (_queue_head != NULL) {\n+  while (_queue_head != nullptr) {\n@@ -1101,1 +1101,1 @@\n-  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+  for(QueueNode* node = _queue_head; node != nullptr; node = node->next()) {\n@@ -1108,1 +1108,1 @@\n-  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+  for(QueueNode* node = _queue_head; node != nullptr; node = node->next()) {\n@@ -1114,1 +1114,1 @@\n-  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+  for(QueueNode* node = _queue_head; node != nullptr; node = node->next()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,6 +67,6 @@\n-Array<Method*>* VM_RedefineClasses::_old_methods = NULL;\n-Array<Method*>* VM_RedefineClasses::_new_methods = NULL;\n-Method**  VM_RedefineClasses::_matching_old_methods = NULL;\n-Method**  VM_RedefineClasses::_matching_new_methods = NULL;\n-Method**  VM_RedefineClasses::_deleted_methods      = NULL;\n-Method**  VM_RedefineClasses::_added_methods        = NULL;\n+Array<Method*>* VM_RedefineClasses::_old_methods = nullptr;\n+Array<Method*>* VM_RedefineClasses::_new_methods = nullptr;\n+Method**  VM_RedefineClasses::_matching_old_methods = nullptr;\n+Method**  VM_RedefineClasses::_matching_new_methods = nullptr;\n+Method**  VM_RedefineClasses::_deleted_methods      = nullptr;\n+Method**  VM_RedefineClasses::_added_methods        = nullptr;\n@@ -89,1 +89,1 @@\n-  _the_class = NULL;\n+  _the_class = nullptr;\n@@ -106,1 +106,1 @@\n-  if (redef_classes == NULL) {\n+  if (redef_classes == nullptr) {\n@@ -144,1 +144,1 @@\n-  assert(redef_classes != NULL, \"_classes_being_redefined is not allocated\");\n+  assert(redef_classes != nullptr, \"_classes_being_redefined is not allocated\");\n@@ -173,1 +173,1 @@\n-  if (_class_defs == NULL) {\n+  if (_class_defs == nullptr) {\n@@ -179,1 +179,1 @@\n-    if (_class_defs[i].klass == NULL) {\n+    if (_class_defs[i].klass == nullptr) {\n@@ -187,1 +187,1 @@\n-    if (_class_defs[i].class_bytes == NULL) {\n+    if (_class_defs[i].class_bytes == nullptr) {\n@@ -214,1 +214,1 @@\n-      if (_scratch_classes[i] != NULL) {\n+      if (_scratch_classes[i] != nullptr) {\n@@ -221,1 +221,1 @@\n-          _scratch_classes[i]->set_cached_class_file(NULL);\n+          _scratch_classes[i]->set_cached_class_file(nullptr);\n@@ -314,1 +314,1 @@\n-  _the_class = NULL;\n+  _the_class = nullptr;\n@@ -338,1 +338,1 @@\n-  if (k == NULL || !k->is_instance_klass()) {\n+  if (k == nullptr || !k->is_instance_klass()) {\n@@ -482,1 +482,1 @@\n-      const char *entry_name = NULL;\n+      const char *entry_name = nullptr;\n@@ -722,1 +722,1 @@\n-  if (merge_cp->operands() == NULL) {\n+  if (merge_cp->operands() == nullptr) {\n@@ -740,1 +740,1 @@\n-  _operands_index_map_p = NULL;\n+  _operands_index_map_p = nullptr;\n@@ -777,1 +777,1 @@\n-    if (the_syms == NULL || scr_syms == NULL) {\n+    if (the_syms == nullptr || scr_syms == nullptr) {\n@@ -847,2 +847,2 @@\n-  bool the_record_exists = the_record != NULL;\n-  bool scr_record_exists = scr_record != NULL;\n+  bool the_record_exists = the_record != nullptr;\n+  bool scr_record_exists = scr_record != nullptr;\n@@ -879,1 +879,1 @@\n-      const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? NULL :\n+      const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? nullptr :\n@@ -881,1 +881,1 @@\n-      const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? NULL :\n+      const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? nullptr :\n@@ -942,1 +942,1 @@\n-  \/\/ Check for NULL superclass first since this might be java.lang.Object\n+  \/\/ Check for null superclass first since this might be java.lang.Object\n@@ -944,1 +944,1 @@\n-      (the_class->super() == NULL || scratch_class->super() == NULL ||\n+      (the_class->super() == nullptr || scratch_class->super() == nullptr ||\n@@ -950,2 +950,2 @@\n-       the_class->super() == NULL ? \"NULL\" : the_class->super()->external_name(),\n-       scratch_class->super() == NULL ? \"NULL\" : scratch_class->super()->external_name());\n+       the_class->super() == nullptr ? \"null\" : the_class->super()->external_name(),\n+       scratch_class->super() == nullptr ? \"null\" : scratch_class->super()->external_name());\n@@ -1170,1 +1170,1 @@\n-          if (idnum_owner != NULL) {\n+          if (idnum_owner != nullptr) {\n@@ -1210,1 +1210,1 @@\n-        if (idnum_owner != NULL) {\n+        if (idnum_owner != nullptr) {\n@@ -1370,1 +1370,1 @@\n-  if (_scratch_classes == NULL) {\n+  if (_scratch_classes == nullptr) {\n@@ -1375,1 +1375,1 @@\n-    _scratch_classes[i] = NULL;\n+    _scratch_classes[i] = nullptr;\n@@ -1382,1 +1382,1 @@\n-  \/\/ state can only be NULL if the current thread is exiting which\n+  \/\/ state can only be null if the current thread is exiting which\n@@ -1384,1 +1384,1 @@\n-  guarantee(state != NULL, \"exiting thread calling load_new_class_versions\");\n+  guarantee(state != nullptr, \"exiting thread calling load_new_class_versions\");\n@@ -1455,1 +1455,1 @@\n-        if (message != NULL) {\n+        if (message != nullptr) {\n@@ -1620,1 +1620,1 @@\n-  if (merge_cp_p == NULL) {\n+  if (merge_cp_p == nullptr) {\n@@ -1624,1 +1624,1 @@\n-  if (merge_cp_length_p == NULL) {\n+  if (merge_cp_length_p == nullptr) {\n@@ -1804,1 +1804,1 @@\n-                 _loader_data(loader_data), _cp(merge_cp), _scratch_cp(NULL) {}\n+                 _loader_data(loader_data), _cp(merge_cp), _scratch_cp(nullptr) {}\n@@ -1807,1 +1807,1 @@\n-    if (_scratch_cp != NULL) {\n+    if (_scratch_cp != nullptr) {\n@@ -1870,1 +1870,1 @@\n-  merge_cp->set_pool_holder(NULL);\n+  merge_cp->set_pool_holder(nullptr);\n@@ -2088,1 +2088,1 @@\n-  if (components != NULL) {\n+  if (components != nullptr) {\n@@ -2101,1 +2101,1 @@\n-      if (annotations != NULL && annotations->length() != 0) {\n+      if (annotations != nullptr && annotations->length() != 0) {\n@@ -2111,1 +2111,1 @@\n-      if (type_annotations != NULL && type_annotations->length() != 0) {\n+      if (type_annotations != nullptr && type_annotations->length() != 0) {\n@@ -2129,1 +2129,1 @@\n-  assert(permitted_subclasses != NULL, \"unexpected null permitted_subclasses\");\n+  assert(permitted_subclasses != nullptr, \"unexpected null permitted_subclasses\");\n@@ -2155,1 +2155,1 @@\n-  if (methods == NULL || methods->length() == 0) {\n+  if (methods == nullptr || methods->length() == 0) {\n@@ -2253,1 +2253,1 @@\n-            Relocator rc(method, NULL \/* no RelocatorListener needed *\/);\n+            Relocator rc(method, nullptr \/* no RelocatorListener needed *\/);\n@@ -2324,1 +2324,1 @@\n-  if (class_annotations == NULL || class_annotations->length() == 0) {\n+  if (class_annotations == nullptr || class_annotations->length() == 0) {\n@@ -2610,1 +2610,1 @@\n-  if (fields_annotations == NULL || fields_annotations->length() == 0) {\n+  if (fields_annotations == nullptr || fields_annotations->length() == 0) {\n@@ -2619,1 +2619,1 @@\n-    if (field_annotations == NULL || field_annotations->length() == 0) {\n+    if (field_annotations == nullptr || field_annotations->length() == 0) {\n@@ -2644,1 +2644,1 @@\n-    if (method_annotations == NULL || method_annotations->length() == 0) {\n+    if (method_annotations == nullptr || method_annotations->length() == 0) {\n@@ -2680,1 +2680,1 @@\n-    if (method_parameter_annotations == NULL\n+    if (method_parameter_annotations == nullptr\n@@ -2728,1 +2728,1 @@\n-    if (method_default_annotations == NULL\n+    if (method_default_annotations == nullptr\n@@ -2753,1 +2753,1 @@\n-  if (class_type_annotations == NULL || class_type_annotations->length() == 0) {\n+  if (class_type_annotations == nullptr || class_type_annotations->length() == 0) {\n@@ -2770,1 +2770,1 @@\n-  if (fields_type_annotations == NULL || fields_type_annotations->length() == 0) {\n+  if (fields_type_annotations == nullptr || fields_type_annotations->length() == 0) {\n@@ -2779,1 +2779,1 @@\n-    if (field_type_annotations == NULL || field_type_annotations->length() == 0) {\n+    if (field_type_annotations == nullptr || field_type_annotations->length() == 0) {\n@@ -2805,1 +2805,1 @@\n-    if (method_type_annotations == NULL || method_type_annotations->length() == 0) {\n+    if (method_type_annotations == nullptr || method_type_annotations->length() == 0) {\n@@ -3777,1 +3777,1 @@\n-      if (methods->at(index)->method_data() != NULL) {\n+      if (methods->at(index)->method_data() != nullptr) {\n@@ -3816,1 +3816,1 @@\n-    if (cp_cache != NULL) {\n+    if (cp_cache != nullptr) {\n@@ -3822,1 +3822,1 @@\n-         pv_node != NULL;\n+         pv_node != nullptr;\n@@ -3825,1 +3825,1 @@\n-      if (cp_cache != NULL) {\n+      if (cp_cache != nullptr) {\n@@ -3836,1 +3836,1 @@\n-    if (jmid != NULL) {\n+    if (jmid != nullptr) {\n@@ -4019,1 +4019,1 @@\n-    if (name_symbol != NULL) {\n+    if (name_symbol != nullptr) {\n@@ -4021,1 +4021,1 @@\n-      if (method != NULL) {\n+      if (method != nullptr) {\n@@ -4030,1 +4030,1 @@\n-          if (method != NULL) {\n+          if (method != nullptr) {\n@@ -4044,1 +4044,1 @@\n-          if (method != NULL) {\n+          if (method != nullptr) {\n@@ -4052,1 +4052,1 @@\n-    return NULL;  \/\/ This whole branch bore nothing\n+    return nullptr;  \/\/ This whole branch bore nothing\n@@ -4097,1 +4097,1 @@\n-        if (new_method != NULL) {\n+        if (new_method != nullptr) {\n@@ -4301,1 +4301,1 @@\n-      if (ik != NULL) {\n+      if (ik != nullptr) {\n@@ -4314,1 +4314,1 @@\n-    } while (ik != NULL);\n+    } while (ik != nullptr);\n@@ -4384,1 +4384,1 @@\n-  \/\/ NULL out in scratch class to not delete twice.  The class to be redefined\n+  \/\/ null out in scratch class to not delete twice.  The class to be redefined\n@@ -4386,1 +4386,1 @@\n-  scratch_class->set_cached_class_file(NULL);\n+  scratch_class->set_cached_class_file(nullptr);\n@@ -4408,1 +4408,1 @@\n-    scratch_class->source_debug_extension() == NULL ? 0 :\n+    scratch_class->source_debug_extension() == nullptr ? 0 :\n@@ -4452,1 +4452,1 @@\n-  if (the_class->oop_map_cache() != NULL) {\n+  if (the_class->oop_map_cache() != nullptr) {\n@@ -4539,2 +4539,2 @@\n-    if (ik->constants() != NULL &&\n-        ik->constants()->cache() != NULL &&\n+    if (ik->constants() != nullptr &&\n+        ik->constants()->cache() != nullptr &&\n@@ -4636,1 +4636,1 @@\n-  if (_the_class != NULL) {\n+  if (_the_class != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":77,"deletions":77,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -544,1 +544,1 @@\n-    return cache == NULL ? 0 : cache->length;\n+    return cache == nullptr ? 0 : cache->length;\n@@ -547,1 +547,1 @@\n-    return cache == NULL ? NULL : cache->data;\n+    return cache == nullptr ? nullptr : cache->data;\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -80,1 +81,1 @@\n-MethodHandlesAdapterBlob* MethodHandles::_adapter_code = NULL;\n+MethodHandlesAdapterBlob* MethodHandles::_adapter_code = nullptr;\n@@ -87,2 +88,2 @@\n-  assert(vmClasses::MethodHandle_klass() != NULL, \"should be present\");\n-  assert(_adapter_code == NULL, \"generate only once\");\n+  assert(vmClasses::MethodHandle_klass() != nullptr, \"should be present\");\n+  assert(_adapter_code == nullptr, \"generate only once\");\n@@ -115,1 +116,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -142,2 +143,0 @@\n-  SEARCH_SUPERCLASSES   = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,\n-  SEARCH_INTERFACES     = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,\n@@ -170,1 +169,1 @@\n-  if (signature == NULL) {\n+  if (signature == nullptr) {\n@@ -201,1 +200,1 @@\n-    if (k != NULL && k->is_instance_klass()) {\n+    if (k != nullptr && k->is_instance_klass()) {\n@@ -204,1 +203,1 @@\n-      if (mname2 != NULL) {\n+      if (mname2 != nullptr) {\n@@ -206,1 +205,1 @@\n-        if (java_lang_invoke_MemberName::name(mname2) == NULL)\n+        if (java_lang_invoke_MemberName::name(mname2) == nullptr)\n@@ -208,1 +207,1 @@\n-        if (java_lang_invoke_MemberName::type(mname2) == NULL)\n+        if (java_lang_invoke_MemberName::type(mname2) == nullptr)\n@@ -217,1 +216,1 @@\n-    if (k != NULL && k->is_instance_klass()) {\n+    if (k != nullptr && k->is_instance_klass()) {\n@@ -219,2 +218,2 @@\n-      if (m == NULL || is_signature_polymorphic(m->intrinsic_id()))\n-        return NULL;            \/\/ do not resolve unless there is a concrete signature\n+      if (m == nullptr || is_signature_polymorphic(m->intrinsic_id()))\n+        return nullptr;            \/\/ do not resolve unless there is a concrete signature\n@@ -228,1 +227,1 @@\n-    if (k != NULL && k->is_instance_klass()) {\n+    if (k != nullptr && k->is_instance_klass()) {\n@@ -230,1 +229,1 @@\n-      if (m == NULL)  return NULL;\n+      if (m == nullptr)  return nullptr;\n@@ -235,1 +234,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -243,1 +242,1 @@\n-  assert(m_klass != NULL, \"null holder for method handle\");\n+  assert(m_klass != nullptr, \"null holder for method handle\");\n@@ -296,1 +295,1 @@\n-        return NULL;  \/\/ elicit an error later in product build\n+        return nullptr;  \/\/ elicit an error later in product build\n@@ -329,1 +328,1 @@\n-  default:  assert(false, \"bad CallInfo\");  return NULL;\n+  default:  assert(false, \"bad CallInfo\");  return nullptr;\n@@ -365,1 +364,1 @@\n-  java_lang_invoke_MemberName::set_method (mname_oop, NULL);\n+  java_lang_invoke_MemberName::set_method (mname_oop, nullptr);\n@@ -371,1 +370,1 @@\n-  if (name != NULL)\n+  if (name != nullptr)\n@@ -373,1 +372,1 @@\n-  if (type != NULL)\n+  if (type != nullptr)\n@@ -393,1 +392,1 @@\n-  if (klass == NULL)\n+  if (klass == nullptr)\n@@ -407,1 +406,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -492,1 +491,1 @@\n-  if (mh_klass != NULL && is_method_handle_invoke_name(mh_klass, name)) {\n+  if (mh_klass != nullptr && is_method_handle_invoke_name(mh_klass, name)) {\n@@ -498,1 +497,1 @@\n-  if (vh_klass != NULL && is_method_handle_invoke_name(vh_klass, name)) {\n+  if (vh_klass != nullptr && is_method_handle_invoke_name(vh_klass, name)) {\n@@ -508,1 +507,1 @@\n-  if (klass != NULL &&\n+  if (klass != nullptr &&\n@@ -552,1 +551,1 @@\n-    THROW_MSG_(vmSymbols::java_lang_InternalError(), \"unrecognized type\", NULL);\n+    THROW_MSG_(vmSymbols::java_lang_InternalError(), \"unrecognized type\", nullptr);\n@@ -584,2 +583,2 @@\n-  Symbol* bsig = NULL;\n-  if (sig == NULL) {\n+  Symbol* bsig = nullptr;\n+  if (sig == nullptr) {\n@@ -664,1 +663,1 @@\n-  if (s == NULL)  return NULL;\n+  if (s == nullptr)  return nullptr;\n@@ -669,1 +668,1 @@\n-  if (s == NULL)  return NULL;\n+  if (s == nullptr)  return nullptr;\n@@ -686,1 +685,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -697,1 +696,1 @@\n-  if (java_lang_invoke_MemberName::vmtarget(mname()) != NULL) {\n+  if (java_lang_invoke_MemberName::vmtarget(mname()) != nullptr) {\n@@ -720,1 +719,1 @@\n-  InstanceKlass* defc = NULL;\n+  InstanceKlass* defc = nullptr;\n@@ -723,1 +722,1 @@\n-    if (defc_klass == NULL)  return empty;  \/\/ a primitive; no resolution possible\n+    if (defc_klass == nullptr)  return empty;  \/\/ a primitive; no resolution possible\n@@ -730,1 +729,1 @@\n-  if (defc == NULL) {\n+  if (defc == nullptr) {\n@@ -737,1 +736,1 @@\n-  if (name == NULL)  return empty;  \/\/ no such name\n+  if (name == nullptr)  return empty;  \/\/ no such name\n@@ -759,1 +758,1 @@\n-  if (type == NULL)  return empty;  \/\/ no such signature exists in the VM\n+  if (type == nullptr)  return empty;  \/\/ no such signature exists in the VM\n@@ -762,1 +761,1 @@\n-  LinkInfo::AccessCheck access_check = caller != NULL ?\n+  LinkInfo::AccessCheck access_check = caller != nullptr ?\n@@ -766,1 +765,1 @@\n-  LinkInfo::LoaderConstraintCheck loader_constraint_check = (caller != NULL && (lookup_mode & LM_UNCONDITIONAL) == 0) ?\n+  LinkInfo::LoaderConstraintCheck loader_constraint_check = (caller != nullptr && (lookup_mode & LM_UNCONDITIONAL) == 0) ?\n@@ -869,3 +868,3 @@\n-  bool have_defc = (java_lang_invoke_MemberName::clazz(mname()) != NULL);\n-  bool have_name = (java_lang_invoke_MemberName::name(mname()) != NULL);\n-  bool have_type = (java_lang_invoke_MemberName::type(mname()) != NULL);\n+  bool have_defc = (java_lang_invoke_MemberName::clazz(mname()) != nullptr);\n+  bool have_name = (java_lang_invoke_MemberName::name(mname()) != nullptr);\n+  bool have_type = (java_lang_invoke_MemberName::type(mname()) != nullptr);\n@@ -887,1 +886,1 @@\n-      if (vmtarget == NULL) {\n+      if (vmtarget == nullptr) {\n@@ -891,1 +890,1 @@\n-      DEBUG_ONLY(vmtarget = NULL);  \/\/ safety\n+      DEBUG_ONLY(vmtarget = nullptr);  \/\/ safety\n@@ -910,1 +909,1 @@\n-      if (clazz == NULL) {\n+      if (clazz == nullptr) {\n@@ -914,1 +913,1 @@\n-      DEBUG_ONLY(clazz = NULL);  \/\/ safety\n+      DEBUG_ONLY(clazz = nullptr);  \/\/ safety\n@@ -939,113 +938,0 @@\n-int MethodHandles::find_MemberNames(Klass* k,\n-                                    Symbol* name, Symbol* sig,\n-                                    int mflags, Klass* caller,\n-                                    int skip, objArrayHandle results, TRAPS) {\n-  \/\/ %%% take caller into account!\n-\n-  if (k == NULL || !k->is_instance_klass())  return -1;\n-\n-  int rfill = 0, rlimit = results->length(), rskip = skip;\n-  \/\/ overflow measurement:\n-  int overflow = 0, overflow_limit = MAX2(1000, rlimit);\n-\n-  int match_flags = mflags;\n-  bool search_superc = ((match_flags & SEARCH_SUPERCLASSES) != 0);\n-  bool search_intfc  = ((match_flags & SEARCH_INTERFACES)   != 0);\n-  bool local_only = !(search_superc | search_intfc);\n-\n-  if (name != NULL) {\n-    if (name->utf8_length() == 0)  return 0; \/\/ a match is not possible\n-  }\n-  if (sig != NULL) {\n-    if (sig->starts_with(JVM_SIGNATURE_FUNC))\n-      match_flags &= ~(IS_FIELD | IS_TYPE);\n-    else\n-      match_flags &= ~(IS_OBJECT_CONSTRUCTOR | IS_METHOD);\n-  }\n-\n-  if ((match_flags & IS_TYPE) != 0) {\n-    \/\/ NYI, and Core Reflection works quite well for this query\n-  }\n-\n-  if ((match_flags & IS_FIELD) != 0) {\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {\n-      if (name != NULL && st.name() != name)\n-          continue;\n-      if (sig != NULL && st.signature() != sig)\n-        continue;\n-      \/\/ passed the filters\n-      if (rskip > 0) {\n-        --rskip;\n-      } else if (rfill < rlimit) {\n-        Handle result(THREAD, results->obj_at(rfill++));\n-        if (!java_lang_invoke_MemberName::is_instance(result()))\n-          return -99;  \/\/ caller bug!\n-        oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());\n-        if (saved != result())\n-          results->obj_at_put(rfill-1, saved);  \/\/ show saved instance to user\n-      } else if (++overflow >= overflow_limit) {\n-        match_flags = 0; break; \/\/ got tired of looking at overflow\n-      }\n-    }\n-  }\n-\n-  if ((match_flags & (IS_METHOD | IS_OBJECT_CONSTRUCTOR)) != 0) {\n-    \/\/ watch out for these guys:\n-    Symbol* init_name   = vmSymbols::object_initializer_name();\n-    Symbol* clinit_name = vmSymbols::class_initializer_name();\n-    Symbol* factory_name = vmSymbols::inline_factory_name();\n-    if (name == clinit_name)  clinit_name = NULL; \/\/ hack for exposing <clinit>\n-    bool ctor_ok = true, sfac_ok = true;\n-    \/\/ fix name so that it captures the intention of IS_OBJECT_CONSTRUCTOR\n-    if (!(match_flags & IS_METHOD)) {\n-      \/\/ constructors only\n-      if (name == NULL) {\n-        name = init_name;\n-      } else if (name != init_name) {\n-        return 0;               \/\/ no constructors of this method name\n-      }\n-      sfac_ok = false;\n-    } else if (!(match_flags & IS_OBJECT_CONSTRUCTOR)) {\n-      \/\/ methods only\n-      ctor_ok = false;  \/\/ but sfac_ok is true\n-    } else {\n-      \/\/ caller will accept either sort; no need to adjust name\n-    }\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {\n-      Method* m = st.method();\n-      Symbol* m_name = m->name();\n-      if (m_name == clinit_name)\n-        continue;\n-      if (name != NULL && m_name != name)\n-          continue;\n-      if (sig != NULL && m->signature() != sig)\n-        continue;\n-      if (m_name == init_name) {  \/\/ might be ctor\n-        if (m->is_object_constructor()  && !ctor_ok)  continue;\n-      }\n-      if (m_name == factory_name) { \/\/ might be sfac\n-        if (m->is_static_vnew_factory() && !sfac_ok) continue;\n-      }\n-      \/\/ passed the filters\n-      if (rskip > 0) {\n-        --rskip;\n-      } else if (rfill < rlimit) {\n-        Handle result(THREAD, results->obj_at(rfill++));\n-        if (!java_lang_invoke_MemberName::is_instance(result()))\n-          return -99;  \/\/ caller bug!\n-        CallInfo info(m, NULL, CHECK_0);\n-        oop saved = MethodHandles::init_method_MemberName(result, info);\n-        if (saved != result())\n-          results->obj_at_put(rfill-1, saved);  \/\/ show saved instance to user\n-      } else if (++overflow >= overflow_limit) {\n-        match_flags = 0; break; \/\/ got tired of looking at overflow\n-      }\n-    }\n-  }\n-\n-  \/\/ return number of elements we at leasted wanted to initialize\n-  return rfill + overflow;\n-}\n-\n@@ -1105,0 +991,2 @@\n+    \/\/ LSan appears unable to keep track of qname, ignore it.\n+    LSAN_IGNORE_OBJECT(qname);\n@@ -1128,2 +1016,0 @@\n-    template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \\\n-    template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \\\n@@ -1194,2 +1080,2 @@\n-  if (mname_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), \"mname is null\"); }\n-  if (target_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), \"target is null\"); }\n+  if (mname_jh == nullptr) { THROW_MSG(vmSymbols::java_lang_InternalError(), \"mname is null\"); }\n+  if (target_jh == nullptr) { THROW_MSG(vmSymbols::java_lang_InternalError(), \"target is null\"); }\n@@ -1204,1 +1090,1 @@\n-  if (mname_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), \"mname is null\"); }\n+  if (mname_jh == nullptr) { THROW_MSG(vmSymbols::java_lang_InternalError(), \"mname is null\"); }\n@@ -1213,1 +1099,1 @@\n-  if (mname_jh == NULL) { THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \"mname is null\"); }\n+  if (mname_jh == nullptr) { THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \"mname is null\"); }\n@@ -1222,2 +1108,2 @@\n-  if (VerifyMethodHandles && (lookup_mode & LM_TRUSTED) == LM_TRUSTED && caller_jh != NULL &&\n-      java_lang_invoke_MemberName::clazz(mname()) != NULL) {\n+  if (VerifyMethodHandles && (lookup_mode & LM_TRUSTED) == LM_TRUSTED && caller_jh != nullptr &&\n+      java_lang_invoke_MemberName::clazz(mname()) != nullptr) {\n@@ -1225,1 +1111,1 @@\n-    if (reference_klass != NULL && reference_klass->is_objArray_klass()) {\n+    if (reference_klass != nullptr && reference_klass->is_objArray_klass()) {\n@@ -1230,1 +1116,1 @@\n-    if (reference_klass != NULL && reference_klass->is_instance_klass()) {\n+    if (reference_klass != nullptr && reference_klass->is_instance_klass()) {\n@@ -1248,1 +1134,1 @@\n-  Klass* caller = caller_jh == NULL ? NULL :\n+  Klass* caller = caller_jh == nullptr ? nullptr :\n@@ -1262,1 +1148,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1279,2 +1165,2 @@\n-  if (mname == NULL ||\n-      java_lang_invoke_MemberName::clazz(mname) == NULL) {\n+  if (mname == nullptr ||\n+      java_lang_invoke_MemberName::clazz(mname) == nullptr) {\n@@ -1316,1 +1202,1 @@\n-  if (mname_jh == NULL)  return NULL;\n+  if (mname_jh == nullptr)  return nullptr;\n@@ -1329,1 +1215,1 @@\n-    assert(vmtarget != NULL && vmtarget->is_method(), \"vmtarget is only method\");\n+    assert(vmtarget != nullptr && vmtarget->is_method(), \"vmtarget is only method\");\n@@ -1337,43 +1223,0 @@\n-\n-\n-\/\/  static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-\/\/          int matchFlags, Class<?> caller, int skip, MemberName[] results);\n-JVM_ENTRY(jint, MHN_getMembers(JNIEnv *env, jobject igcls,\n-                               jclass clazz_jh, jstring name_jh, jstring sig_jh,\n-                               int mflags, jclass caller_jh, jint skip, jobjectArray results_jh)) {\n-  if (clazz_jh == NULL || results_jh == NULL)  return -1;\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz_jh));\n-\n-  objArrayHandle results(THREAD, (objArrayOop) JNIHandles::resolve(results_jh));\n-  if (results.is_null() || !results->is_objArray())  return -1;\n-\n-  TempNewSymbol name = NULL;\n-  TempNewSymbol sig = NULL;\n-  if (name_jh != NULL) {\n-    name = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(name_jh));\n-    if (name == NULL)  return 0; \/\/ a match is not possible\n-  }\n-  if (sig_jh != NULL) {\n-    sig = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(sig_jh));\n-    if (sig == NULL)  return 0; \/\/ a match is not possible\n-  }\n-\n-  Klass* caller = NULL;\n-  if (caller_jh != NULL) {\n-    oop caller_oop = JNIHandles::resolve_non_null(caller_jh);\n-    if (!java_lang_Class::is_instance(caller_oop))  return -1;\n-    caller = java_lang_Class::as_Klass(caller_oop);\n-  }\n-\n-  if (name != NULL && sig != NULL && results.not_null()) {\n-    \/\/ try a direct resolve\n-    \/\/ %%% TO DO\n-  }\n-\n-  int res = MethodHandles::find_MemberNames(k, name, sig, mflags,\n-                                            caller, skip, results, CHECK_0);\n-  \/\/ TO DO: expand at least some of the MemberNames, to avoid massive callbacks\n-  return res;\n-}\n-JVM_END\n-\n@@ -1410,1 +1253,1 @@\n-  if (caller_k == NULL || !caller_k->is_instance_klass()) {\n+  if (caller_k == nullptr || !caller_k->is_instance_klass()) {\n@@ -1415,1 +1258,1 @@\n-  if (index_info_oop == NULL ||\n+  if (index_info_oop == nullptr ||\n@@ -1434,1 +1277,1 @@\n-        oop pseudo_arg = NULL;\n+        oop pseudo_arg = nullptr;\n@@ -1515,1 +1358,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1526,1 +1369,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1554,3 +1397,0 @@\n-  \/\/  static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-  \/\/          int matchFlags, Class<?> caller, int skip, MemberName[] results);\n-  {CC \"getMembers\",                CC \"(\" CLS \"\" STRG \"\" STRG \"I\" CLS \"I[\" MEM \")I\", FN_PTR(MHN_getMembers)},\n@@ -1578,1 +1418,1 @@\n-  assert(vmClasses::MethodHandle_klass() != NULL, \"should be present\");\n+  assert(vmClasses::MethodHandle_klass() != nullptr, \"should be present\");\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":71,"deletions":231,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -517,1 +517,1 @@\n-    if (StubRoutines::unsafe_arraycopy() != NULL) {\n+    if (StubRoutines::unsafe_arraycopy() != nullptr) {\n@@ -534,1 +534,1 @@\n-  if (srcObj == NULL && dstObj == NULL) {\n+  if (srcObj == nullptr && dstObj == nullptr) {\n@@ -571,1 +571,1 @@\n-  assert(StubRoutines::data_cache_writeback() != NULL, \"sanity\");\n+  assert(StubRoutines::data_cache_writeback() != nullptr, \"sanity\");\n@@ -578,1 +578,1 @@\n-  assert(StubRoutines::data_cache_writeback_sync() != NULL, \"sanity\");\n+  assert(StubRoutines::data_cache_writeback_sync() != nullptr, \"sanity\");\n@@ -607,2 +607,2 @@\n-  assert(clazz != NULL, \"clazz must not be NULL\");\n-  assert(name != NULL, \"name must not be NULL\");\n+  assert(clazz != nullptr, \"clazz must not be null\");\n+  assert(name != nullptr, \"name must not be null\");\n@@ -630,1 +630,1 @@\n-  assert(field != NULL, \"field must not be NULL\");\n+  assert(field != nullptr, \"field must not be null\");\n@@ -662,1 +662,1 @@\n-  assert(field != NULL, \"field must not be NULL\");\n+  assert(field != nullptr, \"field must not be null\");\n@@ -669,1 +669,1 @@\n-  \/\/ large.  In that last case, this function would return NULL, since\n+  \/\/ large.  In that last case, this function would return null, since\n@@ -684,1 +684,1 @@\n-  assert(clazz != NULL, \"clazz must not be NULL\");\n+  assert(clazz != nullptr, \"clazz must not be null\");\n@@ -689,1 +689,1 @@\n-  if (klass != NULL && klass->should_be_initialized()) {\n+  if (klass != nullptr && klass->should_be_initialized()) {\n@@ -697,1 +697,1 @@\n-  assert(clazz != NULL, \"clazz must not be NULL\");\n+  assert(clazz != nullptr, \"clazz must not be null\");\n@@ -702,1 +702,1 @@\n-  if (klass != NULL && klass->should_be_initialized()) {\n+  if (klass != nullptr && klass->should_be_initialized()) {\n@@ -711,1 +711,1 @@\n-  assert(clazz != NULL, \"clazz must not be NULL\");\n+  assert(clazz != nullptr, \"clazz must not be null\");\n@@ -716,1 +716,1 @@\n-  if (k == NULL || !k->is_array_klass()) {\n+  if (k == nullptr || !k->is_array_klass()) {\n@@ -780,1 +780,1 @@\n-  env->ThrowNew(cls, NULL);\n+  env->ThrowNew(cls, nullptr);\n@@ -787,1 +787,1 @@\n-  char *utfName = NULL;\n+  char *utfName = nullptr;\n@@ -791,1 +791,1 @@\n-  assert(data != NULL, \"Class bytes must not be NULL\");\n+  assert(data != nullptr, \"Class bytes must not be null\");\n@@ -799,1 +799,1 @@\n-  if (body == NULL) {\n+  if (body == nullptr) {\n@@ -809,1 +809,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -815,1 +815,1 @@\n-      if (utfName == NULL) {\n+      if (utfName == nullptr) {\n@@ -899,2 +899,2 @@\n-  assert(event != NULL, \"invariant\");\n-  event->set_parkedClass((obj != NULL) ? obj->klass() : NULL);\n+  assert(event != nullptr, \"invariant\");\n+  event->set_parkedClass((obj != nullptr) ? obj->klass() : nullptr);\n@@ -903,1 +903,1 @@\n-  event->set_address((obj != NULL) ? (u8)cast_from_oop<uintptr_t>(obj) : 0);\n+  event->set_address((obj != nullptr) ? (u8)cast_from_oop<uintptr_t>(obj) : 0);\n@@ -929,1 +929,1 @@\n-  if (jthread != NULL) {\n+  if (jthread != nullptr) {\n@@ -931,2 +931,2 @@\n-    JavaThread* thr = NULL;\n-    oop java_thread = NULL;\n+    JavaThread* thr = nullptr;\n+    oop java_thread = nullptr;\n@@ -934,1 +934,1 @@\n-    if (java_thread != NULL) {\n+    if (java_thread != nullptr) {\n@@ -936,1 +936,1 @@\n-      if (thr != NULL) {\n+      if (thr != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,1 @@\n+#include \"os_linux.hpp\"\n@@ -163,1 +164,1 @@\n-  return os::vm_page_size();\n+  return (jint)os::vm_page_size();\n@@ -195,1 +196,1 @@\n-          if (plus_char != NULL) {\n+          if (plus_char != nullptr) {\n@@ -213,1 +214,1 @@\n-  if (h_name == NULL) {\n+  if (h_name == nullptr) {\n@@ -228,1 +229,1 @@\n-  if (h_name == NULL) {\n+  if (h_name == nullptr) {\n@@ -283,2 +284,2 @@\n-  if (!( UseCompressedOops && rhs.base() != NULL &&\n-         CompressedOops::base() != NULL &&\n+  if (!( UseCompressedOops && rhs.base() != nullptr &&\n+         CompressedOops::base() != nullptr &&\n@@ -725,1 +726,1 @@\n-  assert(method != NULL, \"method should not be null\");\n+  assert(method != nullptr, \"method should not be null\");\n@@ -749,1 +750,1 @@\n-                assert(cm != NULL, \"sanity check\");\n+                assert(cm != nullptr, \"sanity check\");\n@@ -774,1 +775,1 @@\n-    for (jint d = 0; d < depth && jvf != NULL; d++) {\n+    for (jint d = 0; d < depth && jvf != nullptr; d++) {\n@@ -777,1 +778,1 @@\n-    result = jvf != NULL && jvf->fr().is_deoptimized_frame();\n+    result = jvf != nullptr && jvf->fr().is_deoptimized_frame();\n@@ -795,1 +796,1 @@\n-  } else if (mh->code() != NULL) {\n+  } else if (mh->code() != nullptr) {\n@@ -812,1 +813,1 @@\n-  if (code == NULL) {\n+  if (code == nullptr) {\n@@ -819,1 +820,1 @@\n-  if (comp == NULL) {\n+  if (comp == nullptr) {\n@@ -838,1 +839,1 @@\n-  if (method == NULL || comp_level > CompilationPolicy::highest_compile_level()) {\n+  if (method == nullptr || comp_level > CompilationPolicy::highest_compile_level()) {\n@@ -892,2 +893,2 @@\n-  assert(comp != NULL, \"compiler not available\");\n-  if (compilation_context != NULL) {\n+  assert(comp != nullptr, \"compiler not available\");\n+  if (compilation_context != nullptr) {\n@@ -899,1 +900,1 @@\n-    \/\/ Calling with NULL matches default directive\n+    \/\/ Calling with null matches default directive\n@@ -912,1 +913,1 @@\n-  return (code != NULL ? code->comp_level() : CompLevel_none);\n+  return (code != nullptr ? code->comp_level() : CompLevel_none);\n@@ -932,1 +933,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -940,1 +941,1 @@\n-\/\/ If 'reason' is NULL, the sum of the traps for all reasons will be returned.\n+\/\/ If 'reason' is null, the sum of the traps for all reasons will be returned.\n@@ -949,1 +950,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -951,2 +952,2 @@\n-    char* reason_str = (reason_obj == NULL) ?\n-      NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n+    char* reason_str = (reason_obj == nullptr) ?\n+      nullptr : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n@@ -955,1 +956,1 @@\n-      if (reason_str != NULL && !strcmp(reason_str, Deoptimization::trap_reason_name(reason))) {\n+      if (reason_str != nullptr && !strcmp(reason_str, Deoptimization::trap_reason_name(reason))) {\n@@ -962,1 +963,1 @@\n-      } else if (reason_str == NULL) {\n+      } else if (reason_str == nullptr) {\n@@ -980,1 +981,1 @@\n-  if (reason_obj == NULL && action_obj == NULL) {\n+  if (reason_obj == nullptr && action_obj == nullptr) {\n@@ -984,4 +985,4 @@\n-  const char *reason_str = (reason_obj == NULL) ?\n-    NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n-  const char *action_str = (action_obj == NULL) ?\n-    NULL : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(action_obj));\n+  const char *reason_str = (reason_obj == nullptr) ?\n+    nullptr : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reason_obj));\n+  const char *action_str = (action_obj == nullptr) ?\n+    nullptr : java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(action_obj));\n@@ -997,1 +998,1 @@\n-  return (code != NULL && code->is_osr_method() ? code->osr_entry_bci() : InvocationEntryBci);\n+  return (code != nullptr && code->is_osr_method() ? code->osr_entry_bci() : InvocationEntryBci);\n@@ -1042,2 +1043,2 @@\n-  if (method == NULL) {\n-    tty->print_cr(\"WB error: request to compile NULL method\");\n+  if (method == nullptr) {\n+    tty->print_cr(\"WB error: request to compile null method\");\n@@ -1050,1 +1051,1 @@\n-  if (comp == NULL) {\n+  if (comp == nullptr) {\n@@ -1065,1 +1066,1 @@\n-  if ((!is_blocking && is_queued) || nm != NULL) {\n+  if ((!is_blocking && is_queued) || nm != nullptr) {\n@@ -1071,1 +1072,1 @@\n-    if (code != NULL && code->as_nmethod_or_null() != NULL) {\n+    if (code != nullptr && code->as_nmethod_or_null() != nullptr) {\n@@ -1074,1 +1075,1 @@\n-  } else if (mh->lookup_osr_nmethod_for(bci, comp_level, false) != NULL) {\n+  } else if (mh->lookup_osr_nmethod_for(bci, comp_level, false) != nullptr) {\n@@ -1095,1 +1096,1 @@\n-  if (clinit == NULL || clinit->method_holder()->is_not_initialized()) {\n+  if (clinit == nullptr || clinit->method_holder()->is_not_initialized()) {\n@@ -1120,1 +1121,1 @@\n-  const char* error_msg = NULL;\n+  const char* error_msg = nullptr;\n@@ -1124,2 +1125,2 @@\n-  if (m == NULL) {\n-    assert(error_msg != NULL, \"Always have an error message\");\n+  if (m == nullptr) {\n+    assert(error_msg != nullptr, \"Always have an error message\");\n@@ -1152,1 +1153,1 @@\n-  const char* error_msg = NULL;\n+  const char* error_msg = nullptr;\n@@ -1155,2 +1156,2 @@\n-  if (m == NULL) {\n-    assert(error_msg != NULL, \"Must have error_msg\");\n+  if (m == nullptr) {\n+    assert(error_msg != nullptr, \"Must have error_msg\");\n@@ -1174,1 +1175,1 @@\n-  if (mdo == NULL) {\n+  if (mdo == nullptr) {\n@@ -1194,1 +1195,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -1209,1 +1210,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -1216,1 +1217,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -1220,1 +1221,1 @@\n-  const char* flag_name = env->GetStringUTFChars(name, NULL);\n+  const char* flag_name = env->GetStringUTFChars(name, nullptr);\n@@ -1230,1 +1231,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -1234,1 +1235,1 @@\n-  const char* flag_name = env->GetStringUTFChars(name, NULL);\n+  const char* flag_name = env->GetStringUTFChars(name, nullptr);\n@@ -1246,1 +1247,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1250,1 +1251,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1252,1 +1253,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1274,2 +1275,2 @@\n-  const char* flag_name = env->GetStringUTFChars(name, NULL);\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  const char* flag_name = env->GetStringUTFChars(name, nullptr);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1283,1 +1284,1 @@\n-  return (flag != NULL) && flag->is_constant_in_binary();\n+  return (flag != nullptr) && flag->is_constant_in_binary();\n@@ -1288,1 +1289,1 @@\n-  return (flag != NULL) && !(flag->is_unlocked() || flag->is_unlocker());\n+  return (flag != nullptr) && !(flag->is_unlocked() || flag->is_unlocker());\n@@ -1297,1 +1298,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1307,1 +1308,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1340,1 +1341,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1348,1 +1349,1 @@\n-    CHECK_JNI_EXCEPTION_(env, NULL);\n+    CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1351,1 +1352,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1397,2 +1398,2 @@\n-  if (value == NULL) {\n-    ccstrValue = NULL;\n+  if (value == nullptr) {\n+    ccstrValue = nullptr;\n@@ -1401,1 +1402,1 @@\n-    ccstrValue = env->GetStringUTFChars(value, NULL);\n+    ccstrValue = env->GetStringUTFChars(value, nullptr);\n@@ -1408,1 +1409,1 @@\n-      assert(param == NULL, \"old value is freed automatically and not returned\");\n+      assert(param == nullptr, \"old value is freed automatically and not returned\");\n@@ -1411,1 +1412,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -1430,1 +1431,1 @@\n-  return (StringTable::lookup(name, len) != NULL);\n+  return (StringTable::lookup(name, len) != nullptr);\n@@ -1455,1 +1456,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -1467,1 +1468,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1498,2 +1499,2 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n-  jobjectArray result = env->NewObjectArray(4, clazz, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  jobjectArray result = env->NewObjectArray(4, clazz, nullptr);\n@@ -1502,1 +1503,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1506,1 +1507,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1510,1 +1511,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1514,1 +1515,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1523,1 +1524,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1526,2 +1527,2 @@\n-  jobjectArray result = NULL;\n-  if (code == NULL) {\n+  jobjectArray result = nullptr;\n+  if (code == nullptr) {\n@@ -1535,3 +1536,3 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n-  result = env->NewObjectArray(5, clazz, NULL);\n-  if (result == NULL) {\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  result = env->NewObjectArray(5, clazz, nullptr);\n+  if (result == nullptr) {\n@@ -1543,1 +1544,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1547,1 +1548,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1551,1 +1552,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1556,1 +1557,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1560,1 +1561,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1576,1 +1577,1 @@\n-    if (blob != NULL) {\n+    if (blob != nullptr) {\n@@ -1606,2 +1607,2 @@\n-    if (heap == NULL) {\n-      return NULL;\n+    if (heap == nullptr) {\n+      return nullptr;\n@@ -1610,1 +1611,1 @@\n-         cb != NULL; cb = (CodeBlob*) heap->next(cb)) {\n+         cb != nullptr; cb = (CodeBlob*) heap->next(cb)) {\n@@ -1617,1 +1618,1 @@\n-  jobjectArray result = NULL;\n+  jobjectArray result = nullptr;\n@@ -1619,4 +1620,4 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n-  result = env->NewObjectArray(blobs.length(), clazz, NULL);\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n-  if (result == NULL) {\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  result = env->NewObjectArray(blobs.length(), clazz, nullptr);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  if (result == nullptr) {\n@@ -1629,1 +1630,1 @@\n-    CHECK_JNI_EXCEPTION_(env, NULL);\n+    CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1631,1 +1632,1 @@\n-    CHECK_JNI_EXCEPTION_(env, NULL);\n+    CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -1738,1 +1739,1 @@\n-  ClassLoaderData* cld = class_loader_oop != NULL\n+  ClassLoaderData* cld = class_loader_oop != nullptr\n@@ -1845,1 +1846,1 @@\n-  if (cp->cache() == NULL) {\n+  if (cp->cache() == nullptr) {\n@@ -1854,1 +1855,1 @@\n-  if (cp->cache() == NULL) {\n+  if (cp->cache() == nullptr) {\n@@ -1964,2 +1965,2 @@\n-  assert(value != NULL, \"sanity\");\n-  if (method == NULL || name == NULL) {\n+  assert(value != nullptr, \"sanity\");\n+  if (method == nullptr || name == nullptr) {\n@@ -1973,1 +1974,1 @@\n-  const char* flag_name = env->GetStringUTFChars(name, NULL);\n+  const char* flag_name = env->GetStringUTFChars(name, nullptr);\n@@ -1993,1 +1994,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2003,1 +2004,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2013,1 +2014,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2023,1 +2024,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2032,1 +2033,1 @@\n-    CHECK_JNI_EXCEPTION_(env, NULL);\n+    CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -2035,1 +2036,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2043,1 +2044,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -2103,1 +2104,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2200,1 +2201,1 @@\n-      for (javaVFrame* vf = jt->last_java_vframe(&rmap); vf != NULL; vf = vf->java_sender()) {\n+      for (javaVFrame* vf = jt->last_java_vframe(&rmap); vf != nullptr; vf = vf->java_sender()) {\n@@ -2202,1 +2203,1 @@\n-        if (monitors != NULL) {\n+        if (monitors != nullptr) {\n@@ -2209,1 +2210,1 @@\n-            if (owner != NULL) {\n+            if (owner != nullptr) {\n@@ -2224,1 +2225,1 @@\n-  if (thread_handle != NULL) {\n+  if (thread_handle != nullptr) {\n@@ -2227,1 +2228,1 @@\n-    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, nullptr);\n@@ -2258,1 +2259,1 @@\n-  } else if (thread_handle != NULL) {\n+  } else if (thread_handle != nullptr) {\n@@ -2261,1 +2262,1 @@\n-    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, nullptr);\n@@ -2287,1 +2288,1 @@\n-  if (thread_handle != NULL) {\n+  if (thread_handle != nullptr) {\n@@ -2290,1 +2291,1 @@\n-    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, NULL);\n+    bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &target, nullptr);\n@@ -2326,1 +2327,1 @@\n-  assert(field_name != NULL && strlen(field_name) > 0, \"Field name not valid\");\n+  assert(field_name != nullptr && strlen(field_name) > 0, \"Field name not valid\");\n@@ -2340,1 +2341,1 @@\n-  if (res == NULL) {\n+  if (res == nullptr) {\n@@ -2357,2 +2358,2 @@\n-  if (string == NULL) {\n-    return NULL;\n+  if (string == nullptr) {\n+    return nullptr;\n@@ -2383,1 +2384,1 @@\n-    if (method_array[i].fnPtr == NULL) continue;\n+    if (method_array[i].fnPtr == nullptr) continue;\n@@ -2386,1 +2387,1 @@\n-      if (throwable_obj != NULL) {\n+      if (throwable_obj != nullptr) {\n@@ -2408,1 +2409,1 @@\n-  const char* dir = env->GetStringUTFChars(compDirect, NULL);\n+  const char* dir = env->GetStringUTFChars(compDirect, nullptr);\n@@ -2433,1 +2434,1 @@\n-  const char* lf = env->GetStringUTFChars(libfile, NULL);\n+  const char* lf = env->GetStringUTFChars(libfile, nullptr);\n@@ -2446,0 +2447,12 @@\n+\/\/ Physical memory of the host machine (including containers)\n+WB_ENTRY(jlong, WB_HostPhysicalMemory(JNIEnv* env, jobject o))\n+  LINUX_ONLY(return os::Linux::physical_memory();)\n+  return os::physical_memory();\n+WB_END\n+\n+\/\/ Physical swap of the host machine (including containers), Linux only.\n+WB_ENTRY(jlong, WB_HostPhysicalSwap(JNIEnv* env, jobject o))\n+  LINUX_ONLY(return (jlong)os::Linux::host_swap();)\n+  return -1; \/\/ Not used\/implemented on other platforms\n+WB_END\n+\n@@ -2454,1 +2467,1 @@\n-  const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, NULL);\n+  const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, nullptr);\n@@ -2456,1 +2469,1 @@\n-  const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, NULL);\n+  const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, nullptr);\n@@ -2458,1 +2471,1 @@\n-  const char* p_s_mountinfo = env->GetStringUTFChars(proc_self_mountinfo, NULL);\n+  const char* p_s_mountinfo = env->GetStringUTFChars(proc_self_mountinfo, nullptr);\n@@ -2509,1 +2522,1 @@\n-  if (t == NULL) {\n+  if (t == nullptr) {\n@@ -2556,1 +2569,1 @@\n-      current_frame->print_value_on(&st, NULL);\n+      current_frame->print_value_on(&st, nullptr);\n@@ -2582,1 +2595,1 @@\n-  CHECK_JNI_EXCEPTION_(env, NULL);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n@@ -2851,0 +2864,2 @@\n+  {CC\"hostPhysicalMemory\",        CC\"()J\",            (void*)&WB_HostPhysicalMemory },\n+  {CC\"hostPhysicalSwap\",          CC\"()J\",            (void*)&WB_HostPhysicalSwap },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":152,"deletions":137,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -76,2 +76,2 @@\n-char*  Arguments::_jvm_flags_file               = NULL;\n-char** Arguments::_jvm_flags_array              = NULL;\n+char*  Arguments::_jvm_flags_file               = nullptr;\n+char** Arguments::_jvm_flags_array              = nullptr;\n@@ -79,1 +79,1 @@\n-char** Arguments::_jvm_args_array               = NULL;\n+char** Arguments::_jvm_args_array               = nullptr;\n@@ -81,2 +81,2 @@\n-char*  Arguments::_java_command                 = NULL;\n-SystemProperty* Arguments::_system_properties   = NULL;\n+char*  Arguments::_java_command                 = nullptr;\n+SystemProperty* Arguments::_system_properties   = nullptr;\n@@ -87,1 +87,1 @@\n-const char*  Arguments::_java_vendor_url_bug    = NULL;\n+const char*  Arguments::_java_vendor_url_bug    = nullptr;\n@@ -100,2 +100,2 @@\n-char*  Arguments::SharedArchivePath             = NULL;\n-char*  Arguments::SharedDynamicArchivePath      = NULL;\n+char*  Arguments::SharedArchivePath             = nullptr;\n+char*  Arguments::SharedDynamicArchivePath      = nullptr;\n@@ -111,3 +111,3 @@\n-abort_hook_t     Arguments::_abort_hook         = NULL;\n-exit_hook_t      Arguments::_exit_hook          = NULL;\n-vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;\n+abort_hook_t     Arguments::_abort_hook         = nullptr;\n+exit_hook_t      Arguments::_exit_hook          = nullptr;\n+vfprintf_hook_t  Arguments::_vfprintf_hook      = nullptr;\n@@ -116,6 +116,6 @@\n-SystemProperty *Arguments::_sun_boot_library_path = NULL;\n-SystemProperty *Arguments::_java_library_path = NULL;\n-SystemProperty *Arguments::_java_home = NULL;\n-SystemProperty *Arguments::_java_class_path = NULL;\n-SystemProperty *Arguments::_jdk_boot_class_path_append = NULL;\n-SystemProperty *Arguments::_vm_info = NULL;\n+SystemProperty *Arguments::_sun_boot_library_path = nullptr;\n+SystemProperty *Arguments::_java_library_path = nullptr;\n+SystemProperty *Arguments::_java_home = nullptr;\n+SystemProperty *Arguments::_java_class_path = nullptr;\n+SystemProperty *Arguments::_jdk_boot_class_path_append = nullptr;\n+SystemProperty *Arguments::_vm_info = nullptr;\n@@ -123,2 +123,2 @@\n-GrowableArray<ModulePatchPath*> *Arguments::_patch_mod_prefix = NULL;\n-PathString *Arguments::_boot_class_path = NULL;\n+GrowableArray<ModulePatchPath*> *Arguments::_patch_mod_prefix = nullptr;\n+PathString *Arguments::_boot_class_path = nullptr;\n@@ -127,1 +127,1 @@\n-char* Arguments::_ext_dirs = NULL;\n+char* Arguments::_ext_dirs = nullptr;\n@@ -134,1 +134,1 @@\n-  if (new_value == NULL) {\n+  if (new_value == nullptr) {\n@@ -138,1 +138,1 @@\n-  if (_value != NULL) {\n+  if (_value != nullptr) {\n@@ -149,1 +149,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -151,1 +151,1 @@\n-    if (_value != NULL) {\n+    if (_value != nullptr) {\n@@ -155,3 +155,3 @@\n-    assert(sp != NULL, \"Unable to allocate space for new append path value\");\n-    if (sp != NULL) {\n-      if (_value != NULL) {\n+    assert(sp != nullptr, \"Unable to allocate space for new append path value\");\n+    if (sp != nullptr) {\n+      if (_value != nullptr) {\n@@ -171,2 +171,2 @@\n-  if (value == NULL) {\n-    _value = NULL;\n+  if (value == nullptr) {\n+    _value = nullptr;\n@@ -180,1 +180,1 @@\n-  if (_value != NULL) {\n+  if (_value != nullptr) {\n@@ -182,1 +182,1 @@\n-    _value = NULL;\n+    _value = nullptr;\n@@ -187,1 +187,1 @@\n-  assert(module_name != NULL && path != NULL, \"Invalid module name or path value\");\n+  assert(module_name != nullptr && path != nullptr, \"Invalid module name or path value\");\n@@ -195,1 +195,1 @@\n-  if (_module_name != NULL) {\n+  if (_module_name != nullptr) {\n@@ -197,1 +197,1 @@\n-    _module_name = NULL;\n+    _module_name = nullptr;\n@@ -199,1 +199,1 @@\n-  if (_path != NULL) {\n+  if (_path != nullptr) {\n@@ -201,1 +201,1 @@\n-    _path = NULL;\n+    _path = nullptr;\n@@ -206,2 +206,2 @@\n-  if (key == NULL) {\n-    _key = NULL;\n+  if (key == nullptr) {\n+    _key = nullptr;\n@@ -212,1 +212,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -222,2 +222,2 @@\n-  if (options == NULL) {\n-    _options = NULL;\n+  if (options == nullptr) {\n+    _options = nullptr;\n@@ -230,1 +230,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -251,1 +251,1 @@\n-  const char* tail = NULL;\n+  const char* tail = nullptr;\n@@ -253,1 +253,1 @@\n-  if (tail != NULL && *tail == '\\0') {\n+  if (tail != nullptr && *tail == '\\0') {\n@@ -265,1 +265,1 @@\n-  for (\/* empty *\/; *names != NULL; ++names) {\n+  for (\/* empty *\/; *names != nullptr; ++names) {\n@@ -280,2 +280,2 @@\n-  assert((*option)->optionString != NULL, \"invariant\");\n-  char* tail = NULL;\n+  assert((*option)->optionString != nullptr, \"invariant\");\n+  char* tail = nullptr;\n@@ -327,1 +327,1 @@\n-  _libraryList.add(new AgentLibrary(name, options, false, NULL));\n+  _libraryList.add(new AgentLibrary(name, options, false, nullptr));\n@@ -331,1 +331,1 @@\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, NULL));\n+  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr));\n@@ -335,1 +335,1 @@\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, NULL, true));\n+  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr, true));\n@@ -399,1 +399,1 @@\n-  _boot_class_path = new PathString(NULL);\n+  _boot_class_path = new PathString(nullptr);\n@@ -411,1 +411,1 @@\n-  \/\/ Properties values are set to NULL and they are\n+  \/\/ Properties values are set to nullptr and they are\n@@ -413,3 +413,3 @@\n-  _sun_boot_library_path = new SystemProperty(\"sun.boot.library.path\", NULL,  true);\n-  _java_library_path = new SystemProperty(\"java.library.path\", NULL,  true);\n-  _java_home =  new SystemProperty(\"java.home\", NULL,  true);\n+  _sun_boot_library_path = new SystemProperty(\"sun.boot.library.path\", nullptr,  true);\n+  _java_library_path = new SystemProperty(\"java.library.path\", nullptr,  true);\n+  _java_home =  new SystemProperty(\"java.home\", nullptr,  true);\n@@ -421,1 +421,1 @@\n-  _jdk_boot_class_path_append = new SystemProperty(\"jdk.boot.class.path.append\", NULL, false, true);\n+  _jdk_boot_class_path_append = new SystemProperty(\"jdk.boot.class.path.append\", nullptr, false, true);\n@@ -559,0 +559,3 @@\n+  { \"G1ConcRSLogCacheSize\",    JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n+  { \"G1ConcRSHotCardLimit\",   JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n+\n@@ -574,1 +577,1 @@\n-  { NULL, JDK_Version(0), JDK_Version(0) }\n+  { nullptr, JDK_Version(0), JDK_Version(0) }\n@@ -586,1 +589,1 @@\n-  { NULL, NULL}\n+  { nullptr, nullptr}\n@@ -600,1 +603,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -610,1 +613,1 @@\n-  assert(version != NULL, \"Must provide a version buffer\");\n+  assert(version != nullptr, \"Must provide a version buffer\");\n@@ -621,1 +624,1 @@\n-        if (real_flag != NULL) {\n+        if (real_flag != nullptr) {\n@@ -636,1 +639,1 @@\n-  assert(version != NULL, \"Must provide a version buffer\");\n+  assert(version != nullptr, \"Must provide a version buffer\");\n@@ -653,1 +656,1 @@\n-  for (size_t i = 0; aliased_jvm_flags[i].alias_name != NULL; i++) {\n+  for (size_t i = 0; aliased_jvm_flags[i].alias_name != nullptr; i++) {\n@@ -664,1 +667,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -693,1 +696,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -726,1 +729,1 @@\n-        if (JVMFlag::find_declared_flag(flag.name) != NULL) {\n+        if (JVMFlag::find_declared_flag(flag.name) != nullptr) {\n@@ -741,1 +744,1 @@\n-        if (JVMFlag::find_declared_flag(flag.name) != NULL) {\n+        if (JVMFlag::find_declared_flag(flag.name) != nullptr) {\n@@ -850,1 +853,1 @@\n-    value = NULL;\n+    value = nullptr;\n@@ -861,1 +864,1 @@\n-  size_t old_len = old_value != NULL ? strlen(old_value) : 0;\n+  size_t old_len = old_value != nullptr ? strlen(old_value) : 0;\n@@ -864,1 +867,1 @@\n-  char* free_this_too = NULL;\n+  char* free_this_too = nullptr;\n@@ -898,1 +901,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -916,1 +919,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -925,1 +928,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -934,2 +937,2 @@\n-  if (real_name == NULL) {\n-    return NULL;\n+  if (real_name == nullptr) {\n+    return nullptr;\n@@ -967,1 +970,1 @@\n-  if (flag == NULL) {\n+  if (flag == nullptr) {\n@@ -1004,1 +1007,1 @@\n-  assert(bldarray != NULL, \"illegal argument\");\n+  assert(bldarray != nullptr, \"illegal argument\");\n@@ -1006,1 +1009,1 @@\n-  if (arg == NULL) {\n+  if (arg == nullptr) {\n@@ -1013,1 +1016,1 @@\n-  if (*bldarray == NULL) {\n+  if (*bldarray == nullptr) {\n@@ -1033,2 +1036,2 @@\n-  if (args == NULL || count == 0) {\n-    return NULL;\n+  if (args == nullptr || count == 0) {\n+    return nullptr;\n@@ -1038,1 +1041,1 @@\n-    length += strlen(args[i]) + 1; \/\/ add 1 for a space or NULL terminating character\n+    length += strlen(args[i]) + 1; \/\/ add 1 for a space or null terminating character\n@@ -1043,2 +1046,2 @@\n-    size_t offset = strlen(args[j]) + 1; \/\/ add 1 for a space or NULL terminating character\n-    jio_snprintf(dst, length, \"%s \", args[j]); \/\/ jio_snprintf will replace the last space character with NULL character\n+    size_t offset = strlen(args[j]) + 1; \/\/ add 1 for a space or null terminating character\n+    jio_snprintf(dst, length, \"%s \", args[j]); \/\/ jio_snprintf will replace the last space character with null character\n@@ -1062,1 +1065,1 @@\n-  if (_java_class_path != NULL) {\n+  if (_java_class_path != nullptr) {\n@@ -1091,1 +1094,1 @@\n-  if (java_command() != NULL) {\n+  if (java_command() != nullptr) {\n@@ -1128,1 +1131,1 @@\n-  if (equal_sign == NULL) {\n+  if (equal_sign == nullptr) {\n@@ -1150,1 +1153,1 @@\n-  if (found_flag != NULL) {\n+  if (found_flag != nullptr) {\n@@ -1181,1 +1184,1 @@\n-    if (fuzzy_matched != NULL) {\n+    if (fuzzy_matched != nullptr) {\n@@ -1196,1 +1199,1 @@\n-  if (stream == NULL) {\n+  if (stream == nullptr) {\n@@ -1270,1 +1273,1 @@\n-  if (eq == NULL) {\n+  if (eq == nullptr) {\n@@ -1314,1 +1317,1 @@\n-      if (old_java_command != NULL) {\n+      if (old_java_command != nullptr) {\n@@ -1327,1 +1330,1 @@\n-      if (old_java_vendor_url_bug != NULL) {\n+      if (old_java_vendor_url_bug != nullptr) {\n@@ -1359,1 +1362,1 @@\n-  while (sp != NULL) {\n+  while (sp != nullptr) {\n@@ -1378,1 +1381,1 @@\n-  if (ArchiveClassesAtExit != NULL) {\n+  if (ArchiveClassesAtExit != nullptr) {\n@@ -1386,1 +1389,1 @@\n-    if (get_property(unsupported_properties[i]) != NULL) {\n+    if (get_property(unsupported_properties[i]) != nullptr) {\n@@ -1479,1 +1482,1 @@\n-  \/\/ We need to fit both the NULL page and the heap into the memory budget, while\n+  \/\/ We need to fit both the null page and the heap into the memory budget, while\n@@ -1481,1 +1484,1 @@\n-  \/\/ NULL page is located before the heap, we pad the NULL page to the conservative\n+  \/\/ null page is located before the heap, we pad the null page to the conservative\n@@ -1483,1 +1486,1 @@\n-  size_t displacement_due_to_null_page = align_up((size_t)os::vm_page_size(),\n+  size_t displacement_due_to_null_page = align_up(os::vm_page_size(),\n@@ -1552,1 +1555,1 @@\n-                                          (size_t)os::vm_allocation_granularity(),\n+                                          os::vm_allocation_granularity(),\n@@ -1912,1 +1915,1 @@\n-  assert(_sun_java_launcher != NULL, \"property must have value\");\n+  assert(_sun_java_launcher != nullptr, \"property must have value\");\n@@ -2012,1 +2015,1 @@\n-  if (option_type == NULL) {\n+  if (option_type == nullptr) {\n@@ -2168,1 +2171,1 @@\n-    if ((_name = strrchr(name, (int) *os::file_separator())) == NULL) {\n+    if ((_name = strrchr(name, (int) *os::file_separator())) == nullptr) {\n@@ -2205,1 +2208,1 @@\n-  assert(patch_mod_tail != NULL, \"Unexpected NULL patch-module value\");\n+  assert(patch_mod_tail != nullptr, \"Unexpected null patch-module value\");\n@@ -2208,1 +2211,1 @@\n-  if (module_equal == NULL) {\n+  if (module_equal == nullptr) {\n@@ -2215,1 +2218,1 @@\n-    if (module_name != NULL) {\n+    if (module_name != nullptr) {\n@@ -2315,1 +2318,1 @@\n-    bool silent = (option == NULL); \/\/ Allow testing to silence error messages\n+    bool silent = (option == nullptr); \/\/ Allow testing to silence error messages\n@@ -2417,1 +2420,1 @@\n-      if (tail != NULL) {\n+      if (tail != nullptr) {\n@@ -2419,1 +2422,1 @@\n-        size_t len = (pos == NULL) ? strlen(tail) : pos - tail;\n+        size_t len = (pos == nullptr) ? strlen(tail) : pos - tail;\n@@ -2423,2 +2426,2 @@\n-        char *options = NULL;\n-        if(pos != NULL) {\n+        char *options = nullptr;\n+        if(pos != nullptr) {\n@@ -2482,1 +2485,1 @@\n-      if(tail != NULL) {\n+      if(tail != nullptr) {\n@@ -2485,1 +2488,1 @@\n-        if (pos == NULL) {\n+        if (pos == nullptr) {\n@@ -2494,2 +2497,2 @@\n-        char *options = NULL;\n-        if(pos != NULL) {\n+        char *options = nullptr;\n+        if(pos != nullptr) {\n@@ -2514,1 +2517,1 @@\n-      if (tail != NULL) {\n+      if (tail != nullptr) {\n@@ -2949,1 +2952,1 @@\n-      if (jvmciFlag != NULL && jvmciFlag->is_unlocked()) {\n+      if (jvmciFlag != nullptr && jvmciFlag->is_unlocked()) {\n@@ -3079,1 +3082,1 @@\n-  if (dir != NULL) {\n+  if (dir != nullptr) {\n@@ -3089,1 +3092,1 @@\n-  if (dir != NULL) {\n+  if (dir != nullptr) {\n@@ -3173,1 +3176,1 @@\n-  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+  if (ArchiveClassesAtExit != nullptr && RecordDynamicDumpInfo) {\n@@ -3179,1 +3182,1 @@\n-  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n+  if (ArchiveClassesAtExit == nullptr && !RecordDynamicDumpInfo) {\n@@ -3186,1 +3189,1 @@\n-    if (SharedArchiveFile == NULL) {\n+    if (SharedArchiveFile == nullptr) {\n@@ -3190,1 +3193,1 @@\n-    if (ArchiveClassesAtExit != NULL) {\n+    if (ArchiveClassesAtExit != nullptr) {\n@@ -3233,1 +3236,1 @@\n-    _args.options = NULL;\n+    _args.options = nullptr;\n@@ -3237,1 +3240,1 @@\n-    _vm_options_file_arg = NULL;\n+    _vm_options_file_arg = nullptr;\n@@ -3249,1 +3252,1 @@\n-    if (options_arr == NULL) {\n+    if (options_arr == nullptr) {\n@@ -3257,1 +3260,1 @@\n-      if (options_arr[i].optionString == NULL) {\n+      if (options_arr[i].optionString == nullptr) {\n@@ -3272,1 +3275,1 @@\n-  bool  found_vm_options_file_arg() { return _vm_options_file_arg != NULL; }\n+  bool  found_vm_options_file_arg() { return _vm_options_file_arg != nullptr; }\n@@ -3276,1 +3279,1 @@\n-    if (_vm_options_file_arg != NULL) {\n+    if (_vm_options_file_arg != nullptr) {\n@@ -3283,1 +3286,1 @@\n-    if (_vm_options_file_arg != NULL) {\n+    if (_vm_options_file_arg != nullptr) {\n@@ -3286,1 +3289,1 @@\n-    if (_args.options == NULL) return;\n+    if (_args.options == nullptr) return;\n@@ -3298,1 +3301,1 @@\n-    assert(_args.options == NULL, \"shouldn't be set yet\");\n+    assert(_args.options == nullptr, \"shouldn't be set yet\");\n@@ -3335,1 +3338,1 @@\n-  if (buffer == NULL || os::have_special_privileges()) {\n+  if (buffer == nullptr || os::have_special_privileges()) {\n@@ -3339,1 +3342,1 @@\n-  if ((buffer = os::strdup(buffer)) == NULL) {\n+  if ((buffer = os::strdup(buffer)) == nullptr) {\n@@ -3378,1 +3381,1 @@\n-  \/\/ '+ 1' for NULL termination even with max bytes\n+  \/\/ '+ 1' for null termination even with max bytes\n@@ -3382,1 +3385,1 @@\n-  if (NULL == buf) {\n+  if (nullptr == buf) {\n@@ -3462,1 +3465,1 @@\n-    \/\/ steal a white space character and set it to NULL\n+    \/\/ steal a white space character and set it to null\n@@ -3468,1 +3471,1 @@\n-    option.extraInfo = NULL;\n+    option.extraInfo = nullptr;\n@@ -3505,1 +3508,1 @@\n-  if (end != NULL) *end = '\\0';\n+  if (end != nullptr) *end = '\\0';\n@@ -3517,1 +3520,1 @@\n-  if (archive_path == NULL) {\n+  if (archive_path == nullptr) {\n@@ -3536,1 +3539,1 @@\n-  if (end_ptr == NULL || end_ptr == begin_ptr) {\n+  if (end_ptr == nullptr || end_ptr == begin_ptr) {\n@@ -3550,1 +3553,1 @@\n-  assert(end_ptr != NULL, \"sanity\");\n+  assert(end_ptr != nullptr, \"sanity\");\n@@ -3602,1 +3605,1 @@\n-        char* base_archive_path = NULL;\n+        char* base_archive_path = nullptr;\n@@ -3620,1 +3623,1 @@\n-        } else if (base_archive_path == NULL) {\n+        } else if (base_archive_path == nullptr) {\n@@ -3631,2 +3634,2 @@\n-        if (SharedArchivePath == NULL) {\n-          assert(SharedDynamicArchivePath == NULL, \"must be\");\n+        if (SharedArchivePath == nullptr) {\n+          assert(SharedDynamicArchivePath == nullptr, \"must be\");\n@@ -3845,1 +3848,1 @@\n-    return LogConfiguration::parse_log_arguments(_legacyGCLogging.file, gc_conf, NULL, NULL, &errstream);\n+    return LogConfiguration::parse_log_arguments(_legacyGCLogging.file, gc_conf, nullptr, nullptr, &errstream);\n@@ -3917,1 +3920,1 @@\n-  if (vmoptions != NULL) {\n+  if (vmoptions != nullptr) {\n@@ -3954,1 +3957,1 @@\n-  settings_file_specified = (flags_file != NULL);\n+  settings_file_specified = (flags_file != nullptr);\n@@ -4052,1 +4055,1 @@\n-  if (DumpLoadedClassList != NULL) {\n+  if (DumpLoadedClassList != nullptr) {\n@@ -4070,1 +4073,1 @@\n-                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n+                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", nullptr);\n@@ -4210,1 +4213,1 @@\n-  while(pl != NULL) {\n+  while(pl != nullptr) {\n@@ -4220,1 +4223,1 @@\n-  while(pl != NULL) {\n+  while(pl != nullptr) {\n@@ -4230,1 +4233,1 @@\n-  assert(key != NULL, \"just checking\");\n+  assert(key != nullptr, \"just checking\");\n@@ -4232,1 +4235,1 @@\n-  for (prop = pl; prop != NULL; prop = prop->next()) {\n+  for (prop = pl; prop != nullptr; prop = prop->next()) {\n@@ -4235,1 +4238,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4240,1 +4243,1 @@\n-  assert(key != NULL, \"just checking\");\n+  assert(key != nullptr, \"just checking\");\n@@ -4244,1 +4247,1 @@\n-  for (prop = pl; prop != NULL; prop = prop->next()) {\n+  for (prop = pl; prop != nullptr; prop = prop->next()) {\n@@ -4251,2 +4254,2 @@\n-        \/\/ Property is internal and not jdk.boot.class.path.append so return NULL.\n-        return NULL;\n+        \/\/ Property is internal and not jdk.boot.class.path.append so return null.\n+        return nullptr;\n@@ -4256,1 +4259,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4261,1 +4264,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -4264,1 +4267,1 @@\n-    while (p->next() != NULL) {\n+    while (p->next() != nullptr) {\n@@ -4273,1 +4276,1 @@\n-  if (plist == NULL)\n+  if (plist == nullptr)\n@@ -4288,1 +4291,1 @@\n-  if (plist == NULL)\n+  if (plist == nullptr)\n@@ -4294,1 +4297,1 @@\n-  for (prop = *plist; prop != NULL; prop = prop->next()) {\n+  for (prop = *plist; prop != nullptr; prop = prop->next()) {\n@@ -4313,1 +4316,1 @@\n-\/\/ NULL terminator character is not long enough for holding the expanded\n+\/\/ null terminator character is not long enough for holding the expanded\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":170,"deletions":167,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    const char* file;        \/\/ NULL -> stdout\n+    const char* file;        \/\/ null -> stdout\n@@ -117,1 +117,1 @@\n-                          value() != NULL);\n+                          value() != nullptr);\n@@ -147,1 +147,1 @@\n-  \/\/ Is this library valid or not. Don't rely on os_lib == NULL as statically\n+  \/\/ Is this library valid or not. Don't rely on os_lib == nullptr as statically\n@@ -189,1 +189,1 @@\n-  bool is_empty() const                     { return _first == NULL; }\n+  bool is_empty() const                     { return _first == nullptr; }\n@@ -200,1 +200,1 @@\n-    lib->_next = NULL;\n+    lib->_next = nullptr;\n@@ -206,2 +206,2 @@\n-    AgentLibrary* prev = NULL;\n-    for (curr = first(); curr != NULL; prev = curr, curr = curr->next()) {\n+    AgentLibrary* prev = nullptr;\n+    for (curr = first(); curr != nullptr; prev = curr, curr = curr->next()) {\n@@ -212,1 +212,1 @@\n-    assert(curr != NULL, \"always should be found\");\n+    assert(curr != nullptr, \"always should be found\");\n@@ -214,1 +214,1 @@\n-    if (curr != NULL) {\n+    if (curr != nullptr) {\n@@ -216,1 +216,1 @@\n-      if (prev == NULL) {\n+      if (prev == nullptr) {\n@@ -224,1 +224,1 @@\n-      curr->_next = NULL;\n+      curr->_next = nullptr;\n@@ -229,2 +229,2 @@\n-    _first = NULL;\n-    _last = NULL;\n+    _first = nullptr;\n+    _last = nullptr;\n@@ -440,1 +440,1 @@\n-    return is_bad_option(option, ignore, NULL);\n+    return is_bad_option(option, ignore, nullptr);\n@@ -471,1 +471,1 @@\n-  \/\/ Return NULL if the arg has expired.\n+  \/\/ Return nullptr if the arg has expired.\n@@ -524,1 +524,1 @@\n-    if (_jvm_flags_file != NULL) {\n+    if (_jvm_flags_file != nullptr) {\n@@ -609,1 +609,1 @@\n-    assert(get_boot_class_path() == NULL, \"Boot class path previously set\");\n+    assert(get_boot_class_path() == nullptr, \"Boot class path previously set\");\n@@ -627,1 +627,1 @@\n-  static char* get_default_shared_archive_path() NOT_CDS_RETURN_(NULL);\n+  static char* get_default_shared_archive_path() NOT_CDS_RETURN_(nullptr);\n@@ -682,5 +682,5 @@\n-\/\/ similar to UNSUPPORTED_OPTION but sets flag to NULL\n-#define UNSUPPORTED_OPTION_NULL(opt)                     \\\n-do {                                                     \\\n-  if (opt) {                                             \\\n-    if (FLAG_IS_CMDLINE(opt)) {                          \\\n+\/\/ similar to UNSUPPORTED_OPTION but sets flag to nullptr\n+#define UNSUPPORTED_OPTION_NULL(opt)                         \\\n+do {                                                         \\\n+  if (opt) {                                                 \\\n+    if (FLAG_IS_CMDLINE(opt)) {                              \\\n@@ -688,3 +688,3 @@\n-    }                                                    \\\n-    FLAG_SET_DEFAULT(opt, NULL);                         \\\n-  }                                                      \\\n+    }                                                        \\\n+    FLAG_SET_DEFAULT(opt, nullptr);                          \\\n+  }                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,1 +218,1 @@\n-  assert (chunk->at(0)->scope() != NULL,\"expect only compiled java frames\");\n+  assert (chunk->at(0)->scope() != nullptr,\"expect only compiled java frames\");\n@@ -240,1 +240,1 @@\n-  InlineKlass* vk = NULL;\n+  InlineKlass* vk = nullptr;\n@@ -243,1 +243,1 @@\n-    if (vk != NULL) {\n+    if (vk != nullptr) {\n@@ -260,1 +260,1 @@\n-  if (objects != NULL || vk != NULL) {\n+  if (objects != nullptr || vk != nullptr) {\n@@ -265,1 +265,1 @@\n-      if (vk != NULL) {\n+      if (vk != nullptr) {\n@@ -268,1 +268,1 @@\n-      if (objects != NULL) {\n+      if (objects != nullptr) {\n@@ -270,1 +270,1 @@\n-        bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n+        bool skip_internal = (compiled_method != nullptr) && !compiled_method->is_compiled_by_jvmci();\n@@ -277,1 +277,1 @@\n-      if (vk != NULL) {\n+      if (vk != nullptr) {\n@@ -280,1 +280,1 @@\n-      if (objects != NULL) {\n+      if (objects != nullptr) {\n@@ -282,1 +282,1 @@\n-        bool skip_internal = (compiled_method != NULL) && !compiled_method->is_compiled_by_jvmci();\n+        bool skip_internal = (compiled_method != nullptr) && !compiled_method->is_compiled_by_jvmci();\n@@ -291,1 +291,1 @@\n-  if (save_oop_result || vk != NULL) {\n+  if (save_oop_result || vk != nullptr) {\n@@ -310,1 +310,1 @@\n-    assert (cvf->scope() != NULL,\"expect only compiled java frames\");\n+    assert (cvf->scope() != nullptr,\"expect only compiled java frames\");\n@@ -329,1 +329,1 @@\n-              if (monitor != NULL && monitor->object() == mi->owner()) {\n+              if (monitor != nullptr && monitor->object() == mi->owner()) {\n@@ -392,1 +392,1 @@\n-  assert(current->deopt_mark() == NULL, \"Pending deopt!\");\n+  assert(current->deopt_mark() == nullptr, \"Pending deopt!\");\n@@ -407,1 +407,1 @@\n-  assert(current->deopt_compiled_method() == NULL, \"Pending deopt!\");\n+  assert(current->deopt_compiled_method() == nullptr, \"Pending deopt!\");\n@@ -466,1 +466,1 @@\n-    guarantee(expressions != NULL && expressions->length() > 0, \"must have exception to throw\");\n+    guarantee(expressions != nullptr && expressions->length() > 0, \"must have exception to throw\");\n@@ -469,1 +469,1 @@\n-    guarantee(exceptionObject() != NULL, \"exception oop can not be null\");\n+    guarantee(exceptionObject() != nullptr, \"exception oop can not be null\");\n@@ -481,1 +481,1 @@\n-  assert(current->vframe_array_head() == NULL, \"Pending deopt!\");\n+  assert(current->vframe_array_head() == nullptr, \"Pending deopt!\");\n@@ -499,1 +499,1 @@\n-  if (deoptee_nm != NULL && deoptee_nm->is_method_handle_return(deoptee.pc()))\n+  if (deoptee_nm != nullptr && deoptee_nm->is_method_handle_return(deoptee.pc()))\n@@ -638,1 +638,1 @@\n-  assert(CodeCache::find_blob(frame_pcs[0]) != NULL, \"bad pc\");\n+  assert(CodeCache::find_blob(frame_pcs[0]) != nullptr, \"bad pc\");\n@@ -641,1 +641,1 @@\n-  if (exceptionObject() != NULL) {\n+  if (exceptionObject() != nullptr) {\n@@ -689,1 +689,1 @@\n-  if (array == NULL) {\n+  if (array == nullptr) {\n@@ -692,1 +692,1 @@\n-  thread->set_vframe_array_head(NULL);\n+  thread->set_vframe_array_head(nullptr);\n@@ -698,1 +698,1 @@\n-  if (old_array != NULL) {\n+  if (old_array != nullptr) {\n@@ -700,1 +700,1 @@\n-    old_array->set_unroll_block(NULL);\n+    old_array->set_unroll_block(nullptr);\n@@ -709,2 +709,2 @@\n-  thread->set_deopt_mark(NULL);\n-  thread->set_deopt_compiled_method(NULL);\n+  thread->set_deopt_mark(nullptr);\n+  thread->set_deopt_compiled_method(nullptr);\n@@ -789,1 +789,1 @@\n-  thread->frame_anchor()->set_last_Java_sp(NULL);\n+  thread->frame_anchor()->set_last_Java_sp(nullptr);\n@@ -953,1 +953,1 @@\n-  if (nmethod_only != NULL) {\n+  if (nmethod_only != nullptr) {\n@@ -980,1 +980,1 @@\n-    guarantee(ik != NULL, \"%s must be loaded\", klass_name_str);\n+    guarantee(ik != nullptr, \"%s must be loaded\", klass_name_str);\n@@ -1006,1 +1006,1 @@\n-    if (_singleton == NULL) {\n+    if (_singleton == nullptr) {\n@@ -1019,1 +1019,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1038,5 +1038,5 @@\n-template<> BoxCache<jint, java_lang_Integer_IntegerCache, java_lang_Integer>* BoxCache<jint, java_lang_Integer_IntegerCache, java_lang_Integer>::_singleton = NULL;\n-template<> BoxCache<jlong, java_lang_Long_LongCache, java_lang_Long>* BoxCache<jlong, java_lang_Long_LongCache, java_lang_Long>::_singleton = NULL;\n-template<> BoxCache<jchar, java_lang_Character_CharacterCache, java_lang_Character>* BoxCache<jchar, java_lang_Character_CharacterCache, java_lang_Character>::_singleton = NULL;\n-template<> BoxCache<jshort, java_lang_Short_ShortCache, java_lang_Short>* BoxCache<jshort, java_lang_Short_ShortCache, java_lang_Short>::_singleton = NULL;\n-template<> BoxCache<jbyte, java_lang_Byte_ByteCache, java_lang_Byte>* BoxCache<jbyte, java_lang_Byte_ByteCache, java_lang_Byte>::_singleton = NULL;\n+template<> BoxCache<jint, java_lang_Integer_IntegerCache, java_lang_Integer>* BoxCache<jint, java_lang_Integer_IntegerCache, java_lang_Integer>::_singleton = nullptr;\n+template<> BoxCache<jlong, java_lang_Long_LongCache, java_lang_Long>* BoxCache<jlong, java_lang_Long_LongCache, java_lang_Long>::_singleton = nullptr;\n+template<> BoxCache<jchar, java_lang_Character_CharacterCache, java_lang_Character>* BoxCache<jchar, java_lang_Character_CharacterCache, java_lang_Character>::_singleton = nullptr;\n+template<> BoxCache<jshort, java_lang_Short_ShortCache, java_lang_Short>* BoxCache<jshort, java_lang_Short_ShortCache, java_lang_Short>::_singleton = nullptr;\n+template<> BoxCache<jbyte, java_lang_Byte_ByteCache, java_lang_Byte>* BoxCache<jbyte, java_lang_Byte_ByteCache, java_lang_Byte>::_singleton = nullptr;\n@@ -1060,1 +1060,1 @@\n-    if (_singleton == NULL) {\n+    if (_singleton == nullptr) {\n@@ -1081,1 +1081,1 @@\n-BooleanBoxCache* BooleanBoxCache::_singleton = NULL;\n+BooleanBoxCache* BooleanBoxCache::_singleton = nullptr;\n@@ -1098,1 +1098,1 @@\n-   return NULL;\n+   return nullptr;\n@@ -1125,1 +1125,1 @@\n-    oop obj = NULL;\n+    oop obj = nullptr;\n@@ -1134,1 +1134,1 @@\n-        if (obj != NULL) {\n+        if (obj != nullptr) {\n@@ -1142,1 +1142,1 @@\n-      if (obj == NULL) {\n+      if (obj == nullptr) {\n@@ -1167,1 +1167,1 @@\n-    if (obj == NULL) {\n+    if (obj == nullptr) {\n@@ -1172,1 +1172,1 @@\n-    assert(obj != NULL || HAS_PENDING_EXCEPTION, \"allocation should succeed or we should get an exception\");\n+    assert(obj != nullptr || HAS_PENDING_EXCEPTION, \"allocation should succeed or we should get an exception\");\n@@ -1192,1 +1192,1 @@\n-  if (new_vt == NULL) {\n+  if (new_vt == nullptr) {\n@@ -1378,1 +1378,1 @@\n-    _klass = NULL;\n+    _klass = nullptr;\n@@ -1391,1 +1391,1 @@\n-  while (ik != NULL) {\n+  while (ik != nullptr) {\n@@ -1418,1 +1418,1 @@\n-      assert(vk != NULL, \"must be resolved\");\n+      assert(vk != nullptr, \"must be resolved\");\n@@ -1599,1 +1599,1 @@\n-            mark.locker()->set_displaced_header(markWord::encode((BasicLock*) NULL));\n+            mark.locker()->set_displaced_header(markWord::encode((BasicLock*) nullptr));\n@@ -1605,1 +1605,1 @@\n-            if (waiting_monitor != NULL && waiting_monitor->object() == obj()) {\n+            if (waiting_monitor != nullptr && waiting_monitor->object() == obj()) {\n@@ -1685,1 +1685,1 @@\n-    if (monitors != NULL) {\n+    if (monitors != nullptr) {\n@@ -1688,1 +1688,1 @@\n-        if (src->obj() != NULL) {\n+        if (src->obj() != nullptr) {\n@@ -1706,1 +1706,1 @@\n-  if (LogCompilation && xtty != NULL) {\n+  if (LogCompilation && xtty != nullptr) {\n@@ -1708,1 +1708,1 @@\n-    assert(cm != NULL, \"only compiled methods can deopt\");\n+    assert(cm != nullptr, \"only compiled methods can deopt\");\n@@ -1762,3 +1762,3 @@\n-  if (imm_mdo != NULL) {\n-    ProfileData* pdata = imm_mdo->allocate_bci_to_data(imm_scope->bci(), NULL);\n-    if (pdata != NULL && pdata->is_BitData()) {\n+  if (imm_mdo != nullptr) {\n+    ProfileData* pdata = imm_mdo->allocate_bci_to_data(imm_scope->bci(), nullptr);\n+    if (pdata != nullptr && pdata->is_BitData()) {\n@@ -1773,1 +1773,1 @@\n-  if (trap_mdo != NULL) {\n+  if (trap_mdo != nullptr) {\n@@ -1826,1 +1826,1 @@\n-  if (mdo == NULL && create_if_missing && !HAS_PENDING_EXCEPTION) {\n+  if (mdo == nullptr && create_if_missing && !HAS_PENDING_EXCEPTION) {\n@@ -1913,2 +1913,2 @@\n-  assert(nm != NULL, \"invariant\");\n-  assert(method != NULL, \"invariant\");\n+  assert(nm != nullptr, \"invariant\");\n+  assert(method != nullptr, \"invariant\");\n@@ -2070,1 +2070,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -2081,1 +2081,1 @@\n-      Symbol* class_name = NULL;\n+      Symbol* class_name = nullptr;\n@@ -2088,1 +2088,1 @@\n-          if (xtty != NULL)\n+          if (xtty != nullptr)\n@@ -2093,1 +2093,1 @@\n-        if (xtty != NULL)\n+        if (xtty != nullptr)\n@@ -2096,1 +2096,1 @@\n-      if (xtty != NULL && trap_mdo != NULL && (int)reason < (int)MethodData::_trap_hist_limit) {\n+      if (xtty != nullptr && trap_mdo != nullptr && (int)reason < (int)MethodData::_trap_hist_limit) {\n@@ -2104,1 +2104,1 @@\n-        int dos = (pdata == NULL)? 0: pdata->trap_state();\n+        int dos = (pdata == nullptr)? 0: pdata->trap_state();\n@@ -2114,1 +2114,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -2127,1 +2127,1 @@\n-          if (installed_code_name != NULL) {\n+          if (installed_code_name != nullptr) {\n@@ -2142,1 +2142,1 @@\n-        if (class_name != NULL) {\n+        if (class_name != nullptr) {\n@@ -2149,1 +2149,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -2278,2 +2278,2 @@\n-    ProfileData* pdata = NULL;\n-    if (ProfileTraps && CompilerConfig::is_c2_or_jvmci_compiler_enabled() && update_trap_state && trap_mdo != NULL) {\n+    ProfileData* pdata = nullptr;\n+    if (ProfileTraps && CompilerConfig::is_c2_or_jvmci_compiler_enabled() && update_trap_state && trap_mdo != nullptr) {\n@@ -2360,1 +2360,1 @@\n-      if (pdata != NULL) {\n+      if (pdata != nullptr) {\n@@ -2373,1 +2373,1 @@\n-      if ((reason != Reason_rtm_state_change) && (trap_mdo != NULL) &&\n+      if ((reason != Reason_rtm_state_change) && (trap_mdo != nullptr) &&\n@@ -2380,1 +2380,1 @@\n-      if (reason == Reason_tenured && trap_mdo != NULL) {\n+      if (reason == Reason_tenured && trap_mdo != nullptr) {\n@@ -2450,1 +2450,1 @@\n-  ProfileData* pdata = NULL;\n+  ProfileData* pdata = nullptr;\n@@ -2460,1 +2460,1 @@\n-    pdata = trap_mdo->allocate_bci_to_data(trap_bci, reason_is_speculate(reason) ? compiled_method : NULL);\n+    pdata = trap_mdo->allocate_bci_to_data(trap_bci, reason_is_speculate(reason) ? compiled_method : nullptr);\n@@ -2462,1 +2462,1 @@\n-    if (pdata != NULL) {\n+    if (pdata != nullptr) {\n@@ -2464,1 +2464,1 @@\n-        if (LogCompilation && xtty != NULL) {\n+        if (LogCompilation && xtty != nullptr) {\n@@ -2485,1 +2485,1 @@\n-      if (LogCompilation && xtty != NULL) {\n+      if (LogCompilation && xtty != nullptr) {\n@@ -2516,1 +2516,1 @@\n-                           NULL,\n+                           nullptr,\n@@ -2740,1 +2740,1 @@\n-  juint* bc_counter_addr = NULL;\n+  juint* bc_counter_addr = nullptr;\n@@ -2747,1 +2747,1 @@\n-      if ((counter == 0 && bc_counter_addr == NULL)\n+      if ((counter == 0 && bc_counter_addr == nullptr)\n@@ -2755,1 +2755,1 @@\n-  if (bc_counter_addr == NULL) {\n+  if (bc_counter_addr == nullptr) {\n@@ -2772,1 +2772,1 @@\n-  if (reason_str == NULL && action_str == NULL) {\n+  if (reason_str == nullptr && action_str == nullptr) {\n@@ -2777,1 +2777,1 @@\n-    if (reason_str == NULL || !strcmp(reason_str, trap_reason_name(reason))) {\n+    if (reason_str == nullptr || !strcmp(reason_str, trap_reason_name(reason))) {\n@@ -2779,1 +2779,1 @@\n-        if (action_str == NULL || !strcmp(action_str, trap_action_name(action))) {\n+        if (action_str == nullptr || !strcmp(action_str, trap_action_name(action))) {\n@@ -2796,1 +2796,1 @@\n-    if (xtty != NULL)  xtty->head(\"statistics type='deoptimization'\");\n+    if (xtty != nullptr)  xtty->head(\"statistics type='deoptimization'\");\n@@ -2828,1 +2828,1 @@\n-    if (xtty != NULL)  xtty->tail(\"statistics\");\n+    if (xtty != nullptr)  xtty->tail(\"statistics\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":92,"deletions":92,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-  static void deoptimize_all_marked(nmethod* nmethod_only = NULL);\n+  static void deoptimize_all_marked(nmethod* nmethod_only = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -65,2 +65,2 @@\n-  if (md == NULL)\n-    return NULL;\n+  if (md == nullptr)\n+    return nullptr;\n@@ -73,2 +73,2 @@\n-  if (type_annos == NULL)\n-    return NULL;\n+  if (type_annos == nullptr)\n+    return nullptr;\n@@ -204,1 +204,1 @@\n-      if (obj->obj_field(offset()) != NULL) {\n+      if (obj->obj_field(offset()) != nullptr) {\n@@ -207,1 +207,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"nullptr\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  DEBUG_ONLY (_update_for_id = NULL;)\n+  DEBUG_ONLY (_update_for_id = nullptr;)\n@@ -77,1 +77,1 @@\n-  if (walk_cont == WalkContinuation::include && thread != NULL && thread->last_continuation() != NULL) {\n+  if (walk_cont == WalkContinuation::include && thread != nullptr && thread->last_continuation() != nullptr) {\n@@ -83,1 +83,1 @@\n-  for (int i = 0; i < reg_count ; i++ ) _location[i] = NULL;\n+  for (int i = 0; i < reg_count ; i++ ) _location[i] = nullptr;\n@@ -88,1 +88,1 @@\n-  _thread         = NULL;\n+  _thread         = nullptr;\n@@ -93,1 +93,1 @@\n-  DEBUG_ONLY (_update_for_id = NULL;)\n+  DEBUG_ONLY (_update_for_id = nullptr;)\n@@ -101,1 +101,1 @@\n-  for (int i = 0; i < reg_count ; i++ ) _location[i] = NULL;\n+  for (int i = 0; i < reg_count ; i++ ) _location[i] = nullptr;\n@@ -107,1 +107,1 @@\n-  assert(map != NULL, \"RegisterMap must be present\");\n+  assert(map != nullptr, \"RegisterMap must be present\");\n@@ -141,1 +141,1 @@\n-  return _chunk() != NULL ? _chunk()->cont() : (oop)NULL;\n+  return _chunk() != nullptr ? _chunk()->cont() : (oop)nullptr;\n@@ -145,2 +145,2 @@\n-  assert(chunk == NULL || _walk_cont, \"\");\n-  assert(chunk == NULL || _chunk.not_null(), \"\");\n+  assert(chunk == nullptr || _walk_cont, \"\");\n+  assert(chunk == nullptr || _chunk.not_null(), \"\");\n@@ -150,1 +150,1 @@\n-  if (chunk == NULL) {\n+  if (chunk == nullptr) {\n@@ -176,1 +176,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -185,1 +185,1 @@\n-    if (src != NULL) {\n+    if (src != nullptr) {\n@@ -226,1 +226,1 @@\n-  if (_cb != NULL && _cb->is_nmethod()) {\n+  if (_cb != nullptr && _cb->is_nmethod()) {\n@@ -244,1 +244,1 @@\n-  return (_cb != NULL &&\n+  return (_cb != nullptr &&\n@@ -256,1 +256,1 @@\n-  return (_cb != NULL && _cb->is_runtime_stub());\n+  return (_cb != nullptr && _cb->is_runtime_stub());\n@@ -260,1 +260,1 @@\n-  return (_cb != NULL && _cb->is_safepoint_stub());\n+  return (_cb != nullptr && _cb->is_safepoint_stub());\n@@ -293,1 +293,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -311,1 +311,1 @@\n-  assert(_cb != NULL && _cb->is_compiled(), \"must be an nmethod\");\n+  assert(_cb != nullptr && _cb->is_compiled(), \"must be an nmethod\");\n@@ -338,1 +338,1 @@\n-  assert(thread == NULL\n+  assert(thread == nullptr\n@@ -342,1 +342,1 @@\n-  assert(_cb != NULL && _cb->is_compiled(), \"must be\");\n+  assert(_cb != nullptr && _cb->is_compiled(), \"must be\");\n@@ -377,1 +377,1 @@\n-  if (thread != NULL) {\n+  if (thread != nullptr) {\n@@ -416,5 +416,0 @@\n-void frame::interpreter_frame_set_locals(intptr_t* locs)  {\n-  assert(is_interpreted_frame(), \"Not an interpreted frame\");\n-  *interpreter_frame_locals_addr() = locs;\n-}\n-\n@@ -490,2 +485,1 @@\n-  intptr_t* first = _on_heap ? fp() + (intptr_t)*interpreter_frame_locals_addr()\n-                             : *interpreter_frame_locals_addr();\n+  intptr_t* first = interpreter_frame_locals();\n@@ -527,1 +521,1 @@\n-  if (sp() == NULL)            return \"Empty\";\n+  if (sp() == nullptr)            return \"Empty\";\n@@ -533,1 +527,1 @@\n-  NOT_PRODUCT(address end   = NULL;)\n+  NOT_PRODUCT(address end   = nullptr;)\n@@ -536,1 +530,1 @@\n-  if (sp() != NULL)\n+  if (sp() != nullptr)\n@@ -547,1 +541,1 @@\n-    if (desc != NULL) {\n+    if (desc != nullptr) {\n@@ -557,1 +551,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -560,1 +554,1 @@\n-    if (end == NULL) {\n+    if (end == nullptr) {\n@@ -570,1 +564,1 @@\n-  print_value_on(st,NULL);\n+  print_value_on(st,nullptr);\n@@ -631,1 +625,1 @@\n-  if (buf == NULL || buflen < 1) return;\n+  if (buf == nullptr || buflen < 1) return;\n@@ -640,1 +634,1 @@\n-    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n+    while ((p2 = strstr(p1, os::file_separator())) != nullptr) p1 = p2 + len;\n@@ -667,1 +661,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -670,1 +664,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -678,1 +672,1 @@\n-          if (module->version() != NULL) {\n+          if (module->version() != nullptr) {\n@@ -688,1 +682,1 @@\n-      if (desc != NULL) {\n+      if (desc != nullptr) {\n@@ -698,1 +692,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -710,1 +704,1 @@\n-          if (module->version() != NULL) {\n+          if (module->version() != nullptr) {\n@@ -721,1 +715,1 @@\n-          if (jvmciName != NULL) {\n+          if (jvmciName != nullptr) {\n@@ -883,1 +877,1 @@\n-    _f = NULL; \/\/ will be set later\n+    _f = nullptr; \/\/ will be set later\n@@ -944,1 +938,1 @@\n-  Symbol* signature = NULL;\n+  Symbol* signature = nullptr;\n@@ -1010,4 +1004,4 @@\n-  assert(_cb != NULL, \"sanity check\");\n-  assert((oop_map() == NULL) == (_cb->oop_maps() == NULL), \"frame and _cb must agree that oopmap is set or not\");\n-  if (oop_map() != NULL) {\n-    if (df != NULL) {\n+  assert(_cb != nullptr, \"sanity check\");\n+  assert((oop_map() == nullptr) == (_cb->oop_maps() == nullptr), \"frame and _cb must agree that oopmap is set or not\");\n+  if (oop_map() != nullptr) {\n+    if (df != nullptr) {\n@@ -1030,1 +1024,1 @@\n-  if (cf != NULL)\n+  if (cf != nullptr)\n@@ -1058,1 +1052,1 @@\n-    if (loc == NULL) {\n+    if (loc == nullptr) {\n@@ -1064,1 +1058,1 @@\n-      assert(loc != NULL, \"missing register map entry reg: \" INTPTR_FORMAT \" %s loc: \" INTPTR_FORMAT, reg->value(), reg->name(), p2i(loc));\n+      assert(loc != nullptr, \"missing register map entry reg: \" INTPTR_FORMAT \" %s loc: \" INTPTR_FORMAT, reg->value(), reg->name(), p2i(loc));\n@@ -1116,3 +1110,3 @@\n-  if (oop_adr == NULL) {\n-    guarantee(oop_adr != NULL, \"bad register save location\");\n-    return NULL;\n+  if (oop_adr == nullptr) {\n+    guarantee(oop_adr != nullptr, \"bad register save location\");\n+    return nullptr;\n@@ -1128,1 +1122,1 @@\n-  assert(_cb != NULL && _cb->is_nmethod() && nm->method()->is_native(),\n+  assert(_cb != nullptr && _cb->is_nmethod() && nm->method()->is_native(),\n@@ -1137,1 +1131,1 @@\n-  assert(_cb != NULL && _cb->is_nmethod() && nm->method()->is_native(),\n+  assert(_cb != nullptr && _cb->is_nmethod() && nm->method()->is_native(),\n@@ -1147,1 +1141,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -1169,1 +1163,1 @@\n-  \/*if (_cb != NULL && _cb->is_nmethod()) {\n+  \/*if (_cb != nullptr && _cb->is_nmethod()) {\n@@ -1181,1 +1175,1 @@\n-    char *t = NULL;\n+    char *t = nullptr;\n@@ -1199,1 +1193,1 @@\n-  if (_cb != NULL && _cb->is_nmethod()) {\n+  if (_cb != nullptr && _cb->is_nmethod()) {\n@@ -1210,1 +1204,1 @@\n-    assert(m != NULL, \"expecting a method in this frame\");\n+    assert(m != nullptr, \"expecting a method in this frame\");\n@@ -1238,1 +1232,1 @@\n-    oops_do_internal(&VerifyOopClosure::verify_oop, NULL, NULL, DerivedPointerIterationMode::_ignore, map, false);\n+    oops_do_internal(&VerifyOopClosure::verify_oop, nullptr, nullptr, DerivedPointerIterationMode::_ignore, map, false);\n@@ -1349,2 +1343,2 @@\n-    if (p != NULL && (((intptr_t)p & WordAlignmentMask) == 0)) {\n-      const char* type_name = NULL;\n+    if (p != nullptr && (((intptr_t)p & WordAlignmentMask) == 0)) {\n+      const char* type_name = nullptr;\n@@ -1359,1 +1353,1 @@\n-      if (type_name != NULL) {\n+      if (type_name != nullptr) {\n@@ -1394,1 +1388,1 @@\n-    if (desc != NULL) {\n+    if (desc != nullptr) {\n@@ -1397,1 +1391,1 @@\n-        desc->description() != NULL ? desc->description()               : \"?\"), 2);\n+        desc->description() != nullptr ? desc->description()               : \"?\"), 2);\n@@ -1423,1 +1417,1 @@\n-    intptr_t* tos = NULL;\n+    intptr_t* tos = nullptr;\n@@ -1430,1 +1424,1 @@\n-    if (tos != NULL) {\n+    if (tos != nullptr) {\n@@ -1434,1 +1428,1 @@\n-    if (reg_map != NULL) {\n+    if (reg_map != nullptr) {\n@@ -1436,1 +1430,1 @@\n-      oops_do(&oopsFn, NULL, &oopsFn, reg_map);\n+      oops_do(&oopsFn, nullptr, &oopsFn, reg_map);\n@@ -1506,1 +1500,1 @@\n-    if (reg_map != NULL && is_java_frame()) {\n+    if (reg_map != nullptr && is_java_frame()) {\n@@ -1508,1 +1502,1 @@\n-      for (ScopeDesc* scope = cm->scope_desc_at(pc()); scope != NULL; scope = scope->sender(), scope_no++) {\n+      for (ScopeDesc* scope = cm->scope_desc_at(pc()); scope != nullptr; scope = scope->sender(), scope_no++) {\n@@ -1515,1 +1509,1 @@\n-          int scvs_length = scvs != NULL ? scvs->length() : 0;\n+          int scvs_length = scvs != nullptr ? scvs->length() : 0;\n@@ -1518,1 +1512,1 @@\n-            if (stack_address != NULL) {\n+            if (stack_address != nullptr) {\n@@ -1525,1 +1519,1 @@\n-          int scvs_length = scvs != NULL ? scvs->length() : 0;\n+          int scvs_length = scvs != nullptr ? scvs->length() : 0;\n@@ -1528,1 +1522,1 @@\n-            if (stack_address != NULL) {\n+            if (stack_address != nullptr) {\n@@ -1536,1 +1530,1 @@\n-      oops_do(&oopsFn, NULL, &oopsFn, reg_map);\n+      oops_do(&oopsFn, nullptr, &oopsFn, reg_map);\n@@ -1539,1 +1533,1 @@\n-      if (oop_map() != NULL) {\n+      if (oop_map() != nullptr) {\n@@ -1559,2 +1553,2 @@\n-    if ((_cb != NULL) &&\n-        (_cb->name() != NULL)) {\n+    if ((_cb != nullptr) &&\n+        (_cb->name() != nullptr)) {\n@@ -1625,1 +1619,1 @@\n-  if (thread != NULL) {\n+  if (thread != nullptr) {\n@@ -1658,1 +1652,1 @@\n-  intptr_t* last = NULL;\n+  intptr_t* last = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":81,"deletions":87,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-    if (_oop_map == NULL) {\n+    if (_oop_map == nullptr) {\n@@ -162,1 +162,1 @@\n-  \/\/ should have an id() of NULL so it is a distinguishing value for an unmatchable frame.\n+  \/\/ should have an id() of null so it is a distinguishing value for an unmatchable frame.\n@@ -165,1 +165,1 @@\n-  \/\/ A NULL id is only valid when comparing for equality.\n+  \/\/ A null id is only valid when comparing for equality.\n@@ -178,1 +178,1 @@\n-  bool is_empty()                const { return _pc == NULL; }\n+  bool is_empty()                const { return _pc == nullptr; }\n@@ -296,3 +296,3 @@\n-  intptr_t** interpreter_frame_locals_addr() const;\n-  intptr_t*  interpreter_frame_bcp_addr() const;\n-  intptr_t*  interpreter_frame_mdp_addr() const;\n+  intptr_t* interpreter_frame_locals() const;\n+  intptr_t* interpreter_frame_bcp_addr() const;\n+  intptr_t* interpreter_frame_mdp_addr() const;\n@@ -418,1 +418,1 @@\n-  void print_value() const { print_value_on(tty,NULL); }\n+  void print_value() const { print_value_on(tty,nullptr); }\n@@ -426,1 +426,1 @@\n-  void describe(FrameValues& values, int frame_no, const RegisterMap* reg_map=NULL);\n+  void describe(FrameValues& values, int frame_no, const RegisterMap* reg_map=nullptr);\n@@ -461,1 +461,1 @@\n-    oops_do_internal(f, cf, NULL, dpim, map, true);\n+    oops_do_internal(f, cf, nullptr, dpim, map, true);\n@@ -470,1 +470,1 @@\n-    oops_do_internal(f, cf, NULL, derived_mode, map, true);\n+    oops_do_internal(f, cf, nullptr, derived_mode, map, true);\n@@ -498,2 +498,2 @@\n-    location = NULL;\n-    description = NULL;\n+    location = nullptr;\n+    description = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,3 @@\n+  product(bool, UseVectorizedHashCodeIntrinsic, false, DIAGNOSTIC,           \\\n+          \"Enables intrinsification of ArraysSupport.vectorizedHashCode()\") \\\n+                                                                            \\\n@@ -544,1 +547,1 @@\n-  product(ccstr, HeapDumpPath, NULL, MANAGEABLE,                            \\\n+  product(ccstr, HeapDumpPath, nullptr, MANAGEABLE,                            \\\n@@ -598,1 +601,1 @@\n-  product(ccstr, PrintAssemblyOptions, NULL, DIAGNOSTIC,                    \\\n+  product(ccstr, PrintAssemblyOptions, nullptr, DIAGNOSTIC,                    \\\n@@ -626,1 +629,1 @@\n-          \"Start debugger when an implicit OS (e.g. NULL) \"                 \\\n+          \"Start debugger when an implicit OS (e.g. nullptr) \"                 \\\n@@ -850,1 +853,1 @@\n-  product(ccstr, TraceJVMTI, NULL,                                          \\\n+  product(ccstr, TraceJVMTI, nullptr,                                          \\\n@@ -962,3 +965,0 @@\n-  develop(bool, GenerateRangeChecks, true,                                  \\\n-          \"Generate range checks for array accesses\")                       \\\n-                                                                            \\\n@@ -1053,1 +1053,1 @@\n-  product(ccstr, LogFile, NULL, DIAGNOSTIC,                                 \\\n+  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                                 \\\n@@ -1057,1 +1057,1 @@\n-  product(ccstr, ErrorFile, NULL,                                           \\\n+  product(ccstr, ErrorFile, nullptr,                                           \\\n@@ -1094,1 +1094,1 @@\n-  product(ccstr, AbortVMOnException, NULL, DIAGNOSTIC,                      \\\n+  product(ccstr, AbortVMOnException, nullptr, DIAGNOSTIC,                      \\\n@@ -1098,1 +1098,1 @@\n-  product(ccstr, AbortVMOnExceptionMessage, NULL, DIAGNOSTIC,               \\\n+  product(ccstr, AbortVMOnExceptionMessage, nullptr, DIAGNOSTIC,               \\\n@@ -1130,1 +1130,1 @@\n-  product_pd(uintx, TypeProfileLevel,                                       \\\n+  product_pd(uint, TypeProfileLevel,                                        \\\n@@ -1332,3 +1332,0 @@\n-  notproduct(ccstrlist, SuppressErrorAt, \"\",                                \\\n-          \"List of assertions (file:line) to muzzle\")                       \\\n-                                                                            \\\n@@ -1444,1 +1441,1 @@\n-  product(ccstr, MetaspaceReclaimPolicy, \"balanced\",                        \\\n+  product(ccstr, MetaspaceReclaimPolicy, \"balanced\", DIAGNOSTIC,            \\\n@@ -1762,1 +1759,1 @@\n-  product(ccstr, PerfDataSaveFile, NULL,                                    \\\n+  product(ccstr, PerfDataSaveFile, nullptr,                                    \\\n@@ -1842,1 +1839,1 @@\n-  product(ccstr, PauseAtStartupFile, NULL, DIAGNOSTIC,                      \\\n+  product(ccstr, PauseAtStartupFile, nullptr, DIAGNOSTIC,                      \\\n@@ -1949,1 +1946,1 @@\n-  product(ccstr, AllocateHeapAt, NULL,                                      \\\n+  product(ccstr, AllocateHeapAt, nullptr,                                      \\\n@@ -1984,1 +1981,1 @@\n-  JFR_ONLY(product(ccstr, FlightRecorderOptions, NULL,                      \\\n+  JFR_ONLY(product(ccstr, FlightRecorderOptions, nullptr,                      \\\n@@ -1987,1 +1984,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, NULL,                       \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  return real_allocate_handle(NULL);\n+  return real_allocate_handle(nullptr);\n@@ -58,1 +58,1 @@\n-  if (_value != NULL) {                                                \\\n+  if (_value != nullptr) {                                             \\\n@@ -60,1 +60,1 @@\n-    if (h._thread != NULL) {                                           \\\n+    if (h._thread != nullptr) {                                        \\\n@@ -69,1 +69,1 @@\n-    _thread = NULL;                                                    \\\n+    _thread = nullptr;                                                 \\\n@@ -75,1 +75,1 @@\n-  if (_value != NULL) {                                                \\\n+  if (_value != nullptr) {                                             \\\n@@ -77,1 +77,1 @@\n-    if (s._thread != NULL) {                                           \\\n+    if (s._thread != nullptr) {                                        \\\n@@ -86,1 +86,1 @@\n-    _thread = NULL;                                                    \\\n+    _thread = nullptr;                                                 \\\n@@ -91,1 +91,1 @@\n-  if (_value != NULL) {                                                \\\n+  if (_value != nullptr) {                                             \\\n@@ -127,1 +127,1 @@\n-  if (_prev != NULL) _prev->oops_do(f);\n+  if (_prev != nullptr) _prev->oops_do(f);\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,2 @@\n-  oop     obj() const                            { return _handle == NULL ? (oop)NULL : *_handle; }\n-  oop     non_null_obj() const                   { assert(_handle != NULL, \"resolving NULL handle\"); return *_handle; }\n+  oop     obj() const                            { return _handle == nullptr ? (oop)nullptr : *_handle; }\n+  oop     non_null_obj() const                   { assert(_handle != nullptr, \"resolving nullptr handle\"); return *_handle; }\n@@ -76,1 +76,1 @@\n-  Handle()                                       { _handle = NULL; }\n+  Handle()                                       { _handle = nullptr; }\n@@ -89,2 +89,2 @@\n-  bool    is_null() const                        { return _handle == NULL; }\n-  bool    not_null() const                       { return _handle != NULL; }\n+  bool    is_null() const                        { return _handle == nullptr; }\n+  bool    not_null() const                       { return _handle != nullptr; }\n@@ -103,1 +103,1 @@\n-  static oop raw_resolve(oop *handle)            { return handle == NULL ? (oop)NULL : *handle; }\n+  static oop raw_resolve(oop *handle)            { return handle == nullptr ? (oop)nullptr : *handle; }\n@@ -149,1 +149,1 @@\n-    type*        non_null_obj() const            { assert(_value != NULL, \"resolving NULL _value\"); return _value; } \\\n+    type*        non_null_obj() const            { assert(_value != nullptr, \"resolving nullptr _value\"); return _value; } \\\n@@ -153,1 +153,1 @@\n-    name##Handle () : _value(NULL), _thread(NULL) {}   \\\n+    name##Handle () : _value(nullptr), _thread(nullptr) {}   \\\n@@ -171,2 +171,2 @@\n-    bool    is_null() const                      { return _value == NULL; } \\\n-    bool    not_null() const                     { return _value != NULL; } \\\n+    bool    is_null() const                      { return _value == nullptr; } \\\n+    bool    not_null() const                     { return _value != nullptr; } \\\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-  if (obj == NULL) {\n-    _handle = NULL;\n+  if (obj == nullptr) {\n+    _handle = nullptr;\n@@ -50,1 +50,1 @@\n-  assert(_handle != NULL, \"should not use replace\");\n+  assert(_handle != nullptr, \"should not use replace\");\n@@ -69,1 +69,1 @@\n-  if (obj != NULL) {                                                   \\\n+  if (obj != nullptr) {                                                   \\\n@@ -89,1 +89,1 @@\n-  if(_chunk->next() != NULL) {\n+  if(_chunk->next() != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcHeapSummary.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -127,0 +129,8 @@\n+#ifdef LEAK_SANITIZER\n+  {\n+    \/\/ Register the Java heap with LSan.\n+    VirtualSpaceSummary summary = Universe::heap()->create_heap_space_summary();\n+    LSAN_REGISTER_ROOT_REGION(summary.start(), summary.reserved_size());\n+  }\n+#endif \/\/ LEAK_SANITIZER\n+\n@@ -186,0 +196,7 @@\n+#ifdef LEAK_SANITIZER\n+    {\n+      \/\/ Unregister the Java heap with LSan.\n+      VirtualSpaceSummary summary = Universe::heap()->create_heap_space_summary();\n+      LSAN_UNREGISTER_ROOT_REGION(summary.start(), summary.reserved_size());\n+    }\n+#endif \/\/ LEAK_SANITIZER\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  \/\/ legal state. We have no last Java frame if last_Java_sp == NULL so\n+  \/\/ legal state. We have no last Java frame if last_Java_sp == nullptr so\n@@ -99,2 +99,0 @@\n-  assert (_thread->thread_state() != _thread_in_native, \"cannot set native pc to NULL\");\n-\n@@ -182,1 +180,1 @@\n-  Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver->klass();\n+  Klass* recvrKlass = receiver.is_null() ? (Klass*)nullptr : receiver->klass();\n@@ -411,1 +409,1 @@\n-  jobject value_buffer = NULL;\n+  jobject value_buffer = nullptr;\n@@ -416,1 +414,1 @@\n-    if (vk != NULL && vk->can_be_returned_as_fields()) {\n+    if (vk != nullptr && vk->can_be_returned_as_fields()) {\n@@ -438,2 +436,2 @@\n-        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(NULL, alternative_target());\n-        if (verified_entry_point != NULL) {\n+        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n+        if (verified_entry_point != nullptr) {\n@@ -472,1 +470,1 @@\n-    thread->set_vm_result(NULL);\n+    thread->set_vm_result(nullptr);\n@@ -505,1 +503,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -583,1 +581,1 @@\n-      guarantee((size_t)v >= (size_t)os::vm_page_size(),\n+      guarantee((size_t)v >= os::vm_page_size(),\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-OopStorage* JavaThread::_thread_oop_storage = NULL;\n+OopStorage* JavaThread::_thread_oop_storage = nullptr;\n@@ -153,1 +153,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -158,1 +158,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -161,2 +161,2 @@\n-  _jvmti_vthread = OopHandle(_thread_oop_storage, NULL);\n-  _scopedValueCache = OopHandle(_thread_oop_storage, NULL);\n+  _jvmti_vthread = OopHandle(_thread_oop_storage, nullptr);\n+  _scopedValueCache = OopHandle(_thread_oop_storage, nullptr);\n@@ -178,1 +178,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -187,1 +187,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -196,1 +196,1 @@\n-  if (_scopedValueCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n+  if (_scopedValueCache.ptr_raw() != nullptr) { \/\/ i.e. if the OopHandle has been allocated\n@@ -199,1 +199,1 @@\n-    assert(p == NULL, \"not yet initialized\");\n+    assert(p == nullptr, \"not yet initialized\");\n@@ -204,1 +204,1 @@\n-  set_scopedValueCache(NULL);\n+  set_scopedValueCache(nullptr);\n@@ -208,1 +208,1 @@\n-  if (vthread_oop != NULL) {\n+  if (vthread_oop != nullptr) {\n@@ -216,1 +216,1 @@\n-  assert(threadObj() == NULL, \"should only create Java thread object once\");\n+  assert(threadObj() == nullptr, \"should only create Java thread object once\");\n@@ -229,1 +229,1 @@\n-  if (thread_name != NULL) {\n+  if (thread_name != nullptr) {\n@@ -286,2 +286,2 @@\n-  if (new_counters == NULL) {\n-    return NULL;\n+  if (new_counters == nullptr) {\n+    return nullptr;\n@@ -289,1 +289,1 @@\n-  if (old_counters == NULL) {\n+  if (old_counters == nullptr) {\n@@ -307,1 +307,1 @@\n-  if (new_counters == NULL) {\n+  if (new_counters == nullptr) {\n@@ -327,1 +327,1 @@\n-    if (new_counters == NULL) {\n+    if (new_counters == nullptr) {\n@@ -413,1 +413,1 @@\n-  _current_pending_monitor(NULL),\n+  _current_pending_monitor(nullptr),\n@@ -415,3 +415,3 @@\n-  _current_waiting_monitor(NULL),\n-  _active_handles(NULL),\n-  _free_handle_block(NULL),\n+  _current_waiting_monitor(nullptr),\n+  _active_handles(nullptr),\n+  _free_handle_block(nullptr),\n@@ -545,1 +545,1 @@\n-  if (_threadObj.peek() == NULL) {\n+  if (_threadObj.peek() == nullptr) {\n@@ -547,1 +547,1 @@\n-    \/\/ been interrupted. We can find NULL during VM initialization\n+    \/\/ been interrupted. We can find null during VM initialization\n@@ -602,1 +602,1 @@\n-  \/\/ The _osthread may be NULL here because we ran out of memory (too many threads active).\n+  \/\/ The _osthread may be null here because we ran out of memory (too many threads active).\n@@ -621,1 +621,1 @@\n-  _SleepEvent = NULL;\n+  _SleepEvent = nullptr;\n@@ -626,1 +626,1 @@\n-  if (old_array != NULL) {\n+  if (old_array != nullptr) {\n@@ -628,1 +628,1 @@\n-    old_array->set_unroll_block(NULL);\n+    old_array->set_unroll_block(nullptr);\n@@ -634,1 +634,1 @@\n-  if (updates != NULL) {\n+  if (updates != nullptr) {\n@@ -639,1 +639,1 @@\n-    set_deferred_updates(NULL);\n+    set_deferred_updates(nullptr);\n@@ -644,1 +644,1 @@\n-  if (_thread_stat != NULL) delete _thread_stat;\n+  if (_thread_stat != nullptr) delete _thread_stat;\n@@ -701,1 +701,1 @@\n-  assert(_threadObj.peek() != NULL, \"just checking\");\n+  assert(_threadObj.peek() != nullptr, \"just checking\");\n@@ -737,1 +737,1 @@\n-  java_lang_Thread::set_thread(threadObj(), NULL);\n+  java_lang_Thread::set_thread(threadObj(), nullptr);\n@@ -744,1 +744,1 @@\n-  return (threadObj != NULL && java_lang_Thread::is_daemon(threadObj));\n+  return (threadObj != nullptr && java_lang_Thread::is_daemon(threadObj));\n@@ -882,1 +882,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -884,1 +884,1 @@\n-    set_active_handles(NULL);\n+    set_active_handles(nullptr);\n@@ -888,1 +888,1 @@\n-  if (free_handle_block() != NULL) {\n+  if (free_handle_block() != nullptr) {\n@@ -890,1 +890,1 @@\n-    set_free_handle_block(NULL);\n+    set_free_handle_block(nullptr);\n@@ -907,1 +907,1 @@\n-  char* thread_name = NULL;\n+  char* thread_name = nullptr;\n@@ -953,1 +953,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -955,1 +955,1 @@\n-    set_active_handles(NULL);\n+    set_active_handles(nullptr);\n@@ -959,1 +959,1 @@\n-  if (free_handle_block() != NULL) {\n+  if (free_handle_block() != nullptr) {\n@@ -961,1 +961,1 @@\n-    set_free_handle_block(NULL);\n+    set_free_handle_block(nullptr);\n@@ -983,1 +983,1 @@\n-    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n+    JavaThread *ret = op == nullptr ? nullptr : JavaThread::cast(op->calling_thread());\n@@ -991,1 +991,1 @@\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+  for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n@@ -1012,1 +1012,1 @@\n-  guarantee(monitor_chunks() != NULL, \"must be non empty\");\n+  guarantee(monitor_chunks() != nullptr, \"must be non empty\");\n@@ -1034,1 +1034,1 @@\n-  assert(java_throwable != NULL, \"should have an _async_exception to throw\");\n+  assert(java_throwable != nullptr, \"should have an _async_exception to throw\");\n@@ -1246,1 +1246,1 @@\n-        while (found != NULL) {\n+        while (found != nullptr) {\n@@ -1314,1 +1314,1 @@\n-  assert(old_handles != NULL && new_handles != NULL, \"should not be NULL\");\n+  assert(old_handles != nullptr && new_handles != nullptr, \"should not be null\");\n@@ -1326,1 +1326,1 @@\n-  old_handles->set_pop_frame_link(NULL);\n+  old_handles->set_pop_frame_link(nullptr);\n@@ -1337,1 +1337,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -1345,1 +1345,1 @@\n-    for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+    for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n@@ -1350,1 +1350,1 @@\n-  assert(vframe_array_head() == NULL, \"deopt in progress at a safepoint!\");\n+  assert(vframe_array_head() == nullptr, \"deopt in progress at a safepoint!\");\n@@ -1354,1 +1354,1 @@\n-  if (list != NULL) {\n+  if (list != nullptr) {\n@@ -1368,1 +1368,1 @@\n-  if (jvmti_thread_state() != NULL) {\n+  if (jvmti_thread_state() != nullptr) {\n@@ -1389,1 +1389,1 @@\n-  StackWatermarkSet::finish_processing(this, NULL \/* context *\/, StackWatermarkKind::gc);\n+  StackWatermarkSet::finish_processing(this, nullptr \/* context *\/, StackWatermarkKind::gc);\n@@ -1414,1 +1414,1 @@\n-  if (jvmti_thread_state() != NULL) {\n+  if (jvmti_thread_state() != nullptr) {\n@@ -1428,1 +1428,1 @@\n-    if (ct->env() != NULL) {\n+    if (ct->env() != nullptr) {\n@@ -1432,1 +1432,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -1466,1 +1466,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1474,1 +1474,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1477,1 +1477,1 @@\n-      assert(vt != NULL, \"\");\n+      assert(vt != nullptr, \"\");\n@@ -1488,1 +1488,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -1490,1 +1490,1 @@\n-      task->print(st, NULL, true, false);\n+      task->print(st, nullptr, true, false);\n@@ -1548,1 +1548,1 @@\n-  oops_do(&VerifyOopClosure::verify_oop, NULL);\n+  oops_do(&VerifyOopClosure::verify_oop, nullptr);\n@@ -1555,1 +1555,1 @@\n-\/\/ Most callers of this method assume that it can't return NULL but a\n+\/\/ Most callers of this method assume that it can't return null but a\n@@ -1560,1 +1560,1 @@\n-\/\/ for such that this method never returns NULL.\n+\/\/ for such that this method never returns null.\n@@ -1571,1 +1571,1 @@\n-\/\/ Returns a non-NULL representation of this thread's name, or a suitable\n+\/\/ Returns a non-null representation of this thread's name, or a suitable\n@@ -1583,1 +1583,1 @@\n-    if (thread_obj != NULL) {\n+    if (thread_obj != nullptr) {\n@@ -1585,2 +1585,2 @@\n-      if (name != NULL) {\n-        if (buf == NULL) {\n+      if (name != nullptr) {\n+        if (buf == nullptr) {\n@@ -1612,1 +1612,1 @@\n-  assert(name_str != NULL, \"unexpected NULL thread name\");\n+  assert(name_str != nullptr, \"unexpected null thread name\");\n@@ -1618,1 +1618,1 @@\n-  assert(thread_obj != NULL, \"precondition\");\n+  assert(thread_obj != nullptr, \"precondition\");\n@@ -1621,1 +1621,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -1672,1 +1672,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1675,1 +1675,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1711,1 +1711,1 @@\n-  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+  for (vframe* f = start_vf; f != nullptr; f = f->sender()) {\n@@ -1745,1 +1745,1 @@\n-  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+  for (vframe* f = start_vf; f != nullptr; f = f->sender()) {\n@@ -1797,1 +1797,1 @@\n-  assert(_popframe_preserved_args == NULL, \"should not wipe out old PopFrame preserved arguments\");\n+  assert(_popframe_preserved_args == nullptr, \"should not wipe out old PopFrame preserved arguments\");\n@@ -1820,1 +1820,1 @@\n-  assert(_popframe_preserved_args != NULL, \"should not free PopFrame preserved arguments twice\");\n+  assert(_popframe_preserved_args != nullptr, \"should not free PopFrame preserved arguments twice\");\n@@ -1822,1 +1822,1 @@\n-  _popframe_preserved_args = NULL;\n+  _popframe_preserved_args = nullptr;\n@@ -1842,1 +1842,1 @@\n-    if (obj == NULL) return;\n+    if (obj == nullptr) return;\n@@ -1942,1 +1942,1 @@\n-  guarantee (entry != NULL, \"Not a carrier thread\");\n+  guarantee (entry != nullptr, \"Not a carrier thread\");\n@@ -1956,1 +1956,1 @@\n-  assert(reg_map != NULL, \"a map must be given\");\n+  assert(reg_map != nullptr, \"a map must be given\");\n@@ -1960,1 +1960,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1972,1 +1972,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2047,1 +2047,1 @@\n-  if (shutdown_klass != NULL) {\n+  if (shutdown_klass != nullptr) {\n@@ -2096,1 +2096,1 @@\n-  assert(target->osthread() != NULL, \"target thread is not properly initialized\");\n+  assert(target->osthread() != nullptr, \"target thread is not properly initialized\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":89,"deletions":89,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-  \/\/ be NULLed. This is because we rarely ever see the race and end up\n+  \/\/ be nulled. This is because we rarely ever see the race and end up\n@@ -167,1 +167,1 @@\n-    \/\/ Especially, reloading pointer from thread after NULL check must be prevented.\n+    \/\/ Especially, reloading pointer from thread after null check must be prevented.\n@@ -228,1 +228,1 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = NULL);\n+  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n@@ -518,1 +518,1 @@\n-  \/\/ Thread oop. threadObj() can be NULL for initial JavaThread\n+  \/\/ Thread oop. threadObj() can be null for initial JavaThread\n@@ -540,1 +540,1 @@\n-  \/\/ Allocates a new Java level thread object for this thread. thread_name may be NULL.\n+  \/\/ Allocates a new Java level thread object for this thread. thread_name may be null.\n@@ -599,1 +599,1 @@\n-  bool cont_fastpath() const                   { return _cont_fastpath == NULL && _cont_fastpath_thread_state != 0; }\n+  bool cont_fastpath() const                   { return _cont_fastpath == nullptr && _cont_fastpath_thread_state != 0; }\n@@ -713,2 +713,2 @@\n-  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, \"must be\"); _jvmci._alternate_call_target = a; }\n-  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, \"must be\"); _jvmci._implicit_exception_pc = a; }\n+  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == nullptr, \"must be\"); _jvmci._alternate_call_target = a; }\n+  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == nullptr, \"must be\"); _jvmci._implicit_exception_pc = a; }\n@@ -736,2 +736,2 @@\n-    set_exception_oop(NULL);\n-    set_exception_pc(NULL);\n+    set_exception_oop(nullptr);\n+    set_exception_pc(nullptr);\n@@ -748,4 +748,0 @@\n-  void set_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = true; }\n-  void clr_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = false; }\n-  bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }\n-\n@@ -859,2 +855,2 @@\n-  bool is_pending_jni_exception_check() const { return _pending_jni_exception_check_fn != NULL; }\n-  void clear_pending_jni_exception_check() { _pending_jni_exception_check_fn = NULL; }\n+  bool is_pending_jni_exception_check() const { return _pending_jni_exception_check_fn != nullptr; }\n+  void clear_pending_jni_exception_check() { _pending_jni_exception_check_fn = nullptr; }\n@@ -888,1 +884,1 @@\n-  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+  const char* get_thread_name_string(char* buf = nullptr, int buflen = 0) const;\n@@ -981,1 +977,1 @@\n-  \/\/ Returns the current thread as a JavaThread, or NULL if not attached\n+  \/\/ Returns the current thread as a JavaThread, or nullptr if not attached\n@@ -1012,1 +1008,1 @@\n-  \/\/ one which means NULL can be returned. JvmtiThreadState::state_for()\n+  \/\/ one which means null can be returned. JvmtiThreadState::state_for()\n@@ -1015,1 +1011,1 @@\n-  \/\/ returns it. JvmtiThreadState::state_for() will return NULL only if\n+  \/\/ returns it. JvmtiThreadState::state_for() will return null only if\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-OopStorage* JNIHandles::_global_handles = NULL;\n-OopStorage* JNIHandles::_weak_global_handles = NULL;\n+OopStorage* JNIHandles::_global_handles = nullptr;\n+OopStorage* JNIHandles::_weak_global_handles = nullptr;\n@@ -64,1 +64,1 @@\n-\/\/ Used by NewLocalRef which requires NULL on out-of-memory\n+\/\/ Used by NewLocalRef which requires null on out-of-memory\n@@ -66,2 +66,2 @@\n-  if (obj == NULL) {\n-    return NULL;                \/\/ ignore null handles\n+  if (obj == nullptr) {\n+    return nullptr;                \/\/ ignore null handles\n@@ -71,0 +71,1 @@\n+    STATIC_ASSERT(TypeTag::local == 0);\n@@ -89,1 +90,1 @@\n-  jobject res = NULL;\n+  jobject res = nullptr;\n@@ -94,3 +95,3 @@\n-    \/\/ Return NULL on allocation failure.\n-    if (ptr != NULL) {\n-      assert(*ptr == NULL, \"invariant\");\n+    \/\/ Return null on allocation failure.\n+    if (ptr != nullptr) {\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(nullptr), \"invariant\");\n@@ -98,1 +99,2 @@\n-      res = reinterpret_cast<jobject>(ptr);\n+      char* tptr = reinterpret_cast<char*>(ptr) + TypeTag::global;\n+      res = reinterpret_cast<jobject>(tptr);\n@@ -107,1 +109,1 @@\n-jobject JNIHandles::make_weak_global(Handle obj, AllocFailType alloc_failmode) {\n+jweak JNIHandles::make_weak_global(Handle obj, AllocFailType alloc_failmode) {\n@@ -110,1 +112,1 @@\n-  jobject res = NULL;\n+  jweak res = nullptr;\n@@ -115,3 +117,3 @@\n-    \/\/ Return NULL on allocation failure.\n-    if (ptr != NULL) {\n-      assert(*ptr == NULL, \"invariant\");\n+    \/\/ Return nullptr on allocation failure.\n+    if (ptr != nullptr) {\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(nullptr), \"invariant\");\n@@ -119,2 +121,2 @@\n-      char* tptr = reinterpret_cast<char*>(ptr) + weak_tag_value;\n-      res = reinterpret_cast<jobject>(tptr);\n+      char* tptr = reinterpret_cast<char*>(ptr) + TypeTag::weak_global;\n+      res = reinterpret_cast<jweak>(tptr);\n@@ -128,1 +130,1 @@\n-\/\/ Resolve some erroneous cases to NULL, rather than treating them as\n+\/\/ Resolve some erroneous cases to null, rather than treating them as\n@@ -130,1 +132,1 @@\n-\/\/ treated as NULL (though a deleted and later reallocated handle\n+\/\/ treated as null (though a deleted and later reallocated handle\n@@ -133,2 +135,2 @@\n-  oop result = NULL;\n-  if (handle != NULL) {\n+  oop result = nullptr;\n+  if (handle != nullptr) {\n@@ -140,4 +142,3 @@\n-bool JNIHandles::is_global_weak_cleared(jweak handle) {\n-  assert(handle != NULL, \"precondition\");\n-  assert(is_jweak(handle), \"not a weak handle\");\n-  oop* oop_ptr = jweak_ptr(handle);\n+bool JNIHandles::is_weak_global_cleared(jweak handle) {\n+  assert(handle != nullptr, \"precondition\");\n+  oop* oop_ptr = weak_global_ptr(handle);\n@@ -145,1 +146,1 @@\n-  return value == NULL;\n+  return value == nullptr;\n@@ -149,4 +150,3 @@\n-  if (handle != NULL) {\n-    assert(!is_jweak(handle), \"wrong method for destroying jweak\");\n-    oop* oop_ptr = jobject_ptr(handle);\n-    NativeAccess<>::oop_store(oop_ptr, (oop)NULL);\n+  if (handle != nullptr) {\n+    oop* oop_ptr = global_ptr(handle);\n+    NativeAccess<>::oop_store(oop_ptr, (oop)nullptr);\n@@ -158,5 +158,4 @@\n-void JNIHandles::destroy_weak_global(jobject handle) {\n-  if (handle != NULL) {\n-    assert(is_jweak(handle), \"JNI handle not jweak\");\n-    oop* oop_ptr = jweak_ptr(handle);\n-    NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(oop_ptr, (oop)NULL);\n+void JNIHandles::destroy_weak_global(jweak handle) {\n+  if (handle != nullptr) {\n+    oop* oop_ptr = weak_global_ptr(handle);\n+    NativeAccess<ON_PHANTOM_OOP_REF>::oop_store(oop_ptr, (oop)nullptr);\n@@ -187,1 +186,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -189,2 +188,2 @@\n-  if (is_jweak(handle)) {\n-    if (is_storage_handle(weak_global_handles(), jweak_ptr(handle))) {\n+  if (is_weak_global_tagged(handle)) {\n+    if (is_storage_handle(weak_global_handles(), weak_global_ptr(handle))) {\n@@ -193,2 +192,2 @@\n-  } else {\n-    switch (global_handles()->allocation_status(jobject_ptr(handle))) {\n+  } else if (is_global_tagged(handle)) {\n+    switch (global_handles()->allocation_status(global_ptr(handle))) {\n@@ -202,7 +201,0 @@\n-    case OopStorage::INVALID_ENTRY:\n-      \/\/ Not in global storage.  Might be a local handle.\n-      if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n-        result = JNILocalRefType;\n-      }\n-      break;\n-\n@@ -212,0 +204,7 @@\n+  } else {\n+    \/\/ Not in global storage.  Might be a local handle.\n+    if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n+      result = JNILocalRefType;\n+    } else {\n+      ShouldNotReachHere();\n+    }\n@@ -218,1 +217,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -222,1 +221,1 @@\n-  while (block != NULL) {\n+  while (block != nullptr) {\n@@ -237,1 +236,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -247,2 +246,2 @@\n-  assert(handle != NULL, \"precondition\");\n-  return !is_jweak(handle) && is_storage_handle(global_handles(), jobject_ptr(handle));\n+  assert(handle != nullptr, \"precondition\");\n+  return is_global_tagged(handle) && is_storage_handle(global_handles(), global_ptr(handle));\n@@ -253,2 +252,2 @@\n-  assert(handle != NULL, \"precondition\");\n-  return is_jweak(handle) && is_storage_handle(weak_global_handles(), jweak_ptr(handle));\n+  assert(handle != nullptr, \"precondition\");\n+  return is_weak_global_tagged(handle) && is_storage_handle(weak_global_handles(), weak_global_ptr(handle));\n@@ -357,1 +356,1 @@\n-    \/\/ NOT using Access here; just bare clobbering to NULL, since the\n+    \/\/ NOT using Access here; just bare clobbering to null, since the\n@@ -366,1 +365,1 @@\n-  assert(thread == NULL || thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n+  assert(thread == nullptr || thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n@@ -371,1 +370,1 @@\n-  if (thread != NULL && thread->free_handle_block() != NULL) {\n+  if (thread != nullptr && thread->free_handle_block() != nullptr) {\n@@ -378,2 +377,2 @@\n-      if (block == NULL) {\n-        return NULL;\n+      if (block == nullptr) {\n+        return nullptr;\n@@ -388,2 +387,2 @@\n-  block->_next = NULL;\n-  block->_pop_frame_link = NULL;\n+  block->_next = nullptr;\n+  block->_pop_frame_link = nullptr;\n@@ -391,2 +390,2 @@\n-  debug_only(block->_last = NULL);\n-  debug_only(block->_free_list = NULL);\n+  debug_only(block->_last = nullptr);\n+  debug_only(block->_free_list = nullptr);\n@@ -399,1 +398,1 @@\n-  assert(thread == NULL || thread == Thread::current(), \"sanity check\");\n+  assert(thread == nullptr || thread == Thread::current(), \"sanity check\");\n@@ -402,1 +401,1 @@\n-  \/\/ Note that if thread == NULL, we use it as an implicit argument that\n+  \/\/ Note that if thread == nullptr, we use it as an implicit argument that\n@@ -405,1 +404,1 @@\n-  if (thread != NULL ) {\n+  if (thread != nullptr ) {\n@@ -408,1 +407,1 @@\n-    block->_pop_frame_link = NULL;\n+    block->_pop_frame_link = nullptr;\n@@ -412,2 +411,2 @@\n-    if ( freelist != NULL ) {\n-      while ( block->_next != NULL ) block = block->_next;\n+    if ( freelist != nullptr ) {\n+      while ( block->_next != nullptr ) block = block->_next;\n@@ -416,1 +415,1 @@\n-    block = NULL;\n+    block = nullptr;\n@@ -418,2 +417,2 @@\n-    DEBUG_ONLY(block->set_pop_frame_link(NULL));\n-    while (block != NULL) {\n+    DEBUG_ONLY(block->set_pop_frame_link(nullptr));\n+    while (block != nullptr) {\n@@ -422,1 +421,1 @@\n-      assert(block->pop_frame_link() == NULL, \"pop_frame_link should be NULL\");\n+      assert(block->pop_frame_link() == nullptr, \"pop_frame_link should be nullptr\");\n@@ -427,1 +426,1 @@\n-  if (pop_frame_link != NULL) {\n+  if (pop_frame_link != nullptr) {\n@@ -440,2 +439,2 @@\n-  while (current_chain != NULL) {\n-    for (JNIHandleBlock* current = current_chain; current != NULL;\n+  while (current_chain != nullptr) {\n+    for (JNIHandleBlock* current = current_chain; current != nullptr;\n@@ -443,1 +442,1 @@\n-      assert(current == current_chain || current->pop_frame_link() == NULL,\n+      assert(current == current_chain || current->pop_frame_link() == nullptr,\n@@ -471,1 +470,1 @@\n-    for (JNIHandleBlock* current = _next; current != NULL;\n+    for (JNIHandleBlock* current = _next; current != nullptr;\n@@ -473,2 +472,2 @@\n-      assert(current->_last == NULL, \"only first block should have _last set\");\n-      assert(current->_free_list == NULL,\n+      assert(current->_last == nullptr, \"only first block should have _last set\");\n+      assert(current->_free_list == nullptr,\n@@ -479,1 +478,1 @@\n-        for (current = current->_next; current != NULL; current = current->_next) {\n+        for (current = current->_next; current != nullptr; current = current->_next) {\n@@ -489,1 +488,1 @@\n-    _free_list = NULL;\n+    _free_list = nullptr;\n@@ -498,1 +497,1 @@\n-    NativeAccess<IS_DEST_UNINITIALIZED>::oop_store(handle, obj);\n+    *handle = obj;\n@@ -503,1 +502,1 @@\n-  if (_free_list != NULL) {\n+  if (_free_list != nullptr) {\n@@ -506,1 +505,1 @@\n-    NativeAccess<IS_DEST_UNINITIALIZED>::oop_store(handle, obj);\n+    *handle = obj;\n@@ -510,1 +509,1 @@\n-  if (_last->_next != NULL) {\n+  if (_last->_next != nullptr) {\n@@ -521,2 +520,2 @@\n-    if (_last->_next == NULL) {\n-      return NULL;\n+    if (_last->_next == nullptr) {\n+      return nullptr;\n@@ -531,1 +530,1 @@\n-  assert(_allocate_before_rebuild == 0 && _free_list == NULL, \"just checking\");\n+  assert(_allocate_before_rebuild == 0 && _free_list == nullptr, \"just checking\");\n@@ -534,1 +533,1 @@\n-  for (JNIHandleBlock* current = this; current != NULL; current = current->_next) {\n+  for (JNIHandleBlock* current = this; current != nullptr; current = current->_next) {\n@@ -539,1 +538,1 @@\n-        *handle = _free_list == NULL ? 0 : tag_free_list((uintptr_t)_free_list);\n+        *handle = _free_list == nullptr ? 0 : tag_free_list((uintptr_t)_free_list);\n@@ -566,1 +565,1 @@\n-  for (JNIHandleBlock* current = (JNIHandleBlock*) this; current != NULL; current = current->_next) {\n+  for (JNIHandleBlock* current = (JNIHandleBlock*) this; current != nullptr; current = current->_next) {\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":92,"deletions":93,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,2 @@\n-inline bool JNIHandles::is_jweak(jobject handle) {\n-  STATIC_ASSERT(weak_tag_size == 1);\n-  STATIC_ASSERT(weak_tag_value == 1);\n-  return (reinterpret_cast<uintptr_t>(handle) & weak_tag_mask) != 0;\n+inline bool JNIHandles::is_tagged_with(jobject handle, TypeTag tag) {\n+  return (reinterpret_cast<uintptr_t>(handle) & tag_mask) == tag;\n@@ -41,2 +39,15 @@\n-inline oop* JNIHandles::jobject_ptr(jobject handle) {\n-  assert(!is_jweak(handle), \"precondition\");\n+inline bool JNIHandles::is_local_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::local);\n+}\n+\n+inline bool JNIHandles::is_weak_global_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::weak_global);\n+}\n+\n+inline bool JNIHandles::is_global_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::global);\n+}\n+\n+inline oop* JNIHandles::local_ptr(jobject handle) {\n+  assert(is_local_tagged(handle), \"precondition\");\n+  STATIC_ASSERT(TypeTag::local == 0);\n@@ -46,3 +57,9 @@\n-inline oop* JNIHandles::jweak_ptr(jobject handle) {\n-  assert(is_jweak(handle), \"precondition\");\n-  char* ptr = reinterpret_cast<char*>(handle) - weak_tag_value;\n+inline oop* JNIHandles::global_ptr(jobject handle) {\n+  assert(is_global_tagged(handle), \"precondition\");\n+  char* ptr = reinterpret_cast<char*>(handle) - TypeTag::global;\n+  return reinterpret_cast<oop*>(ptr);\n+}\n+\n+inline oop* JNIHandles::weak_global_ptr(jweak handle) {\n+  assert(is_weak_global_tagged(handle), \"precondition\");\n+  char* ptr = reinterpret_cast<char*>(handle) - TypeTag::weak_global;\n@@ -55,1 +72,1 @@\n-  assert(handle != NULL, \"precondition\");\n+  assert(handle != nullptr, \"precondition\");\n@@ -58,2 +75,7 @@\n-  if (is_jweak(handle)) {       \/\/ Unlikely\n-    result = NativeAccess<ON_PHANTOM_OOP_REF|decorators>::oop_load(jweak_ptr(handle));\n+  if (is_weak_global_tagged(handle)) {       \/\/ Unlikely\n+    result = NativeAccess<ON_PHANTOM_OOP_REF|decorators>::oop_load(weak_global_ptr(handle));\n+  } else if (is_global_tagged(handle)) {\n+    result = NativeAccess<decorators>::oop_load(global_ptr(handle));\n+    \/\/ Construction of jobjects canonicalize a null value into a null\n+    \/\/ jobject, so for non-jweak the pointee should never be null.\n+    assert(external_guard || result != nullptr, \"Invalid JNI handle\");\n@@ -61,1 +83,1 @@\n-    result = NativeAccess<decorators>::oop_load(jobject_ptr(handle));\n+    result = *local_ptr(handle);\n@@ -64,1 +86,1 @@\n-    assert(external_guard || result != NULL, \"Invalid JNI handle\");\n+    assert(external_guard || result != nullptr, \"Invalid JNI handle\");\n@@ -70,2 +92,2 @@\n-  oop result = NULL;\n-  if (handle != NULL) {\n+  oop result = nullptr;\n+  if (handle != nullptr) {\n@@ -78,2 +100,2 @@\n-  oop result = NULL;\n-  if (handle != NULL) {\n+  oop result = nullptr;\n+  if (handle != nullptr) {\n@@ -85,1 +107,1 @@\n-  assert(handle != NULL, \"JNI handle should not be null\");\n+  assert(handle != nullptr, \"JNI handle should not be null\");\n@@ -88,1 +110,1 @@\n-  assert(result != NULL, \"NULL read from jni handle\");\n+  assert(result != nullptr, \"nullptr read from jni handle\");\n@@ -93,3 +115,2 @@\n-  if (handle != NULL) {\n-    assert(!is_jweak(handle), \"Invalid JNI local handle\");\n-    NativeAccess<>::oop_store(jobject_ptr(handle), (oop)NULL);\n+  if (handle != nullptr) {\n+    *local_ptr(handle) = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.inline.hpp","additions":45,"deletions":24,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-      return ((_start != NULL) && (addr >= _start) && (addr < _end));\n+      return ((_start != nullptr) && (addr >= _start) && (addr < _end));\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  if (mirror == NULL || java_lang_Class::is_primitive(mirror)) {\n+  if (mirror == nullptr || java_lang_Class::is_primitive(mirror)) {\n@@ -65,2 +65,2 @@\n-  const char * source_file = NULL;\n-  Klass* caller = NULL;\n+  const char * source_file = nullptr;\n+  Klass* caller = nullptr;\n@@ -80,1 +80,1 @@\n-      if (s != NULL) {\n+      if (s != nullptr) {\n@@ -85,1 +85,1 @@\n-  if (caller != NULL) {\n+  if (caller != nullptr) {\n@@ -89,1 +89,1 @@\n-    if (source_file != NULL) {\n+    if (source_file != nullptr) {\n@@ -100,1 +100,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -107,1 +107,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -115,1 +115,1 @@\n-  if (box == NULL) {\n+  if (box == nullptr) {\n@@ -279,1 +279,1 @@\n-      if (obj != NULL) {\n+      if (obj != nullptr) {\n@@ -338,1 +338,1 @@\n-  if (element_mirror == NULL) {\n+  if (element_mirror == nullptr) {\n@@ -365,1 +365,1 @@\n-  if (element_mirror == NULL) {\n+  if (element_mirror == nullptr) {\n@@ -456,1 +456,1 @@\n-  if ((current_class == NULL) ||\n+  if ((current_class == nullptr) ||\n@@ -505,1 +505,1 @@\n-    assert(package_to != NULL, \"can not obtain new_class' package\");\n+    assert(package_to != nullptr, \"can not obtain new_class' package\");\n@@ -543,2 +543,2 @@\n-  char * msg = NULL;\n-  if (result != OTHER_PROBLEM && new_class != NULL && current_class != NULL) {\n+  char * msg = nullptr;\n+  if (result != OTHER_PROBLEM && new_class != nullptr && current_class != nullptr) {\n@@ -551,1 +551,1 @@\n-    ModuleEntry* module_to = NULL;\n+    ModuleEntry* module_to = nullptr;\n@@ -568,1 +568,1 @@\n-        assert(jlm != NULL, \"Null jlm in module_to ModuleEntry\");\n+        assert(jlm != nullptr, \"Null jlm in module_to ModuleEntry\");\n@@ -580,1 +580,1 @@\n-      assert(new_class->package() != NULL,\n+      assert(new_class->package() != nullptr,\n@@ -595,1 +595,1 @@\n-        assert(jlm != NULL, \"Null jlm in module_from ModuleEntry\");\n+        assert(jlm != nullptr, \"Null jlm in module_from ModuleEntry\");\n@@ -631,1 +631,1 @@\n-  if ((current_class == NULL) ||\n+  if ((current_class == nullptr) ||\n@@ -761,1 +761,1 @@\n-    } else if (return_type != NULL) {\n+    } else if (return_type != nullptr) {\n@@ -790,1 +790,1 @@\n-  oop return_type_oop = NULL;\n+  oop return_type_oop = nullptr;\n@@ -792,1 +792,1 @@\n-  if (parameter_types.is_null() || return_type_oop == NULL) return NULL;\n+  if (parameter_types.is_null() || return_type_oop == nullptr) return nullptr;\n@@ -802,1 +802,1 @@\n-  if (name == NULL) return NULL;\n+  if (name == nullptr) return nullptr;\n@@ -816,1 +816,1 @@\n-  if (method->generic_signature() != NULL) {\n+  if (method->generic_signature() != nullptr) {\n@@ -841,2 +841,2 @@\n-  objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);\n-  if (parameter_types.is_null()) return NULL;\n+  objArrayHandle parameter_types = get_parameter_types(method, parameter_count, nullptr, CHECK_NULL);\n+  if (parameter_types.is_null()) return nullptr;\n@@ -857,1 +857,1 @@\n-  if (method->generic_signature() != NULL) {\n+  if (method->generic_signature() != nullptr) {\n@@ -905,1 +905,1 @@\n-  if(NULL != sym) {\n+  if(nullptr != sym) {\n@@ -909,1 +909,1 @@\n-    java_lang_reflect_Parameter::set_name(rh(), NULL);\n+    java_lang_reflect_Parameter::set_name(rh(), nullptr);\n@@ -1108,1 +1108,1 @@\n-      if (arg != NULL) {\n+      if (arg != nullptr) {\n@@ -1169,1 +1169,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -1186,1 +1186,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,1 @@\n-  while (tmp_tss != NULL) {\n+  while (tmp_tss != nullptr) {\n@@ -232,1 +232,1 @@\n-  ThreadSafepointState *tss_head = NULL;\n+  ThreadSafepointState *tss_head = nullptr;\n@@ -236,1 +236,1 @@\n-    assert(cur_tss->get_next() == NULL, \"Must be NULL\");\n+    assert(cur_tss->get_next() == nullptr, \"Must be nullptr\");\n@@ -244,1 +244,1 @@\n-  *p_prev = NULL;\n+  *p_prev = nullptr;\n@@ -252,1 +252,1 @@\n-    assert(tss_head == NULL, \"Must be empty\");\n+    assert(tss_head == nullptr, \"Must be empty\");\n@@ -267,1 +267,1 @@\n-    while (cur_tss != NULL) {\n+    while (cur_tss != nullptr) {\n@@ -271,1 +271,1 @@\n-        *p_prev = NULL;\n+        *p_prev = nullptr;\n@@ -274,1 +274,1 @@\n-        tmp->set_next(NULL);\n+        tmp->set_next(nullptr);\n@@ -291,1 +291,1 @@\n-  assert(tss_head == NULL, \"Must be empty\");\n+  assert(tss_head == nullptr, \"Must be empty\");\n@@ -602,1 +602,1 @@\n-  assert(heap != NULL, \"heap not initialized yet?\");\n+  assert(heap != nullptr, \"heap not initialized yet?\");\n@@ -605,1 +605,1 @@\n-  if (cleanup_workers != NULL) {\n+  if (cleanup_workers != nullptr) {\n@@ -688,1 +688,1 @@\n-  assert(thread != NULL, \"thread must be set\");\n+  assert(thread != nullptr, \"thread must be set\");\n@@ -809,1 +809,1 @@\n-    _safepoint_id(SafepointSynchronize::InactiveSafepointCounter), _next(NULL) {\n+    _safepoint_id(SafepointSynchronize::InactiveSafepointCounter), _next(nullptr) {\n@@ -820,1 +820,1 @@\n-    thread->set_safepoint_state(NULL);\n+    thread->set_safepoint_state(nullptr);\n@@ -897,1 +897,1 @@\n-  assert(cb != NULL && cb->is_compiled(), \"return address should be in nmethod\");\n+  assert(cb != nullptr && cb->is_compiled(), \"return address should be in nmethod\");\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -565,1 +565,1 @@\n-  current->set_exception_pc(NULL);\n+  current->set_exception_pc(nullptr);\n@@ -574,2 +574,2 @@\n-  CompiledMethod* nm = (blob != NULL) ? blob->as_compiled_method_or_null() : NULL;\n-  if (nm != NULL) {\n+  CompiledMethod* nm = (blob != nullptr) ? blob->as_compiled_method_or_null() : nullptr;\n+  if (nm != nullptr) {\n@@ -609,1 +609,1 @@\n-  if (blob != NULL && blob->is_upcall_stub()) {\n+  if (blob != nullptr && blob->is_upcall_stub()) {\n@@ -619,2 +619,2 @@\n-  guarantee(blob == NULL || !blob->is_runtime_stub(), \"caller should have skipped stub\");\n-  guarantee(!VtableStubs::contains(return_address), \"NULL exceptions in vtables should have been handled already!\");\n+  guarantee(blob == nullptr || !blob->is_runtime_stub(), \"caller should have skipped stub\");\n+  guarantee(!VtableStubs::contains(return_address), \"null exceptions in vtables should have been handled already!\");\n@@ -632,1 +632,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -647,1 +647,1 @@\n-  guarantee(cb != NULL && cb->is_compiled(), \"safepoint polling: pc must refer to an nmethod\");\n+  guarantee(cb != nullptr && cb->is_compiled(), \"safepoint polling: pc must refer to an nmethod\");\n@@ -664,1 +664,1 @@\n-    assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+    assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n@@ -668,1 +668,1 @@\n-    assert(SharedRuntime::polling_page_vectors_safepoint_handler_blob() != NULL,\n+    assert(SharedRuntime::polling_page_vectors_safepoint_handler_blob() != nullptr,\n@@ -672,1 +672,1 @@\n-    assert(SharedRuntime::polling_page_safepoint_handler_blob() != NULL,\n+    assert(SharedRuntime::polling_page_safepoint_handler_blob() != nullptr,\n@@ -697,1 +697,1 @@\n-    if (trap_mdo != NULL) {\n+    if (trap_mdo != nullptr) {\n@@ -702,2 +702,2 @@\n-        ProfileData* pdata = trap_mdo->allocate_bci_to_data(bci, NULL);\n-        if (pdata != NULL && pdata->is_BitData()) {\n+        ProfileData* pdata = trap_mdo->allocate_bci_to_data(bci, nullptr);\n+        if (pdata != nullptr && pdata->is_BitData()) {\n@@ -741,1 +741,1 @@\n-  assert(cm != NULL, \"must exist\");\n+  assert(cm != nullptr, \"must exist\");\n@@ -750,1 +750,1 @@\n-    if (t != NULL) {\n+    if (t != nullptr) {\n@@ -797,1 +797,1 @@\n-        if (sd != NULL) {\n+        if (sd != nullptr) {\n@@ -802,1 +802,1 @@\n-    } while (recursive_exception || (!top_frame_only && handler_bci < 0 && sd != NULL));\n+    } while (recursive_exception || (!top_frame_only && handler_bci < 0 && sd != nullptr));\n@@ -810,1 +810,1 @@\n-  if (t == NULL && (nm->is_compiled_by_c1() || handler_bci != -1)) {\n+  if (t == nullptr && (nm->is_compiled_by_c1() || handler_bci != -1)) {\n@@ -821,2 +821,2 @@\n-  if (t == NULL && nm->is_compiled_by_c1()) {\n-    assert(nm->unwind_handler_begin() != NULL, \"\");\n+  if (t == nullptr && nm->is_compiled_by_c1()) {\n+    assert(nm->unwind_handler_begin() != nullptr, \"\");\n@@ -827,1 +827,1 @@\n-  if (t == NULL) {\n+  if (t == nullptr) {\n@@ -838,1 +838,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -859,1 +859,1 @@\n-  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), NULL);\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), nullptr);\n@@ -865,1 +865,1 @@\n-  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), NULL);\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), nullptr);\n@@ -903,1 +903,1 @@\n-  address target_pc = NULL;\n+  address target_pc = nullptr;\n@@ -925,1 +925,1 @@\n-        assert(current->deopt_mark() == NULL, \"no stack overflow from deopt blob\/uncommon trap\");\n+        assert(current->deopt_mark() == nullptr, \"no stack overflow from deopt blob\/uncommon trap\");\n@@ -938,2 +938,2 @@\n-          \/\/ If vt_stub is NULL, then return NULL to signal handler to report the SEGV error.\n-          if (vt_stub == NULL) return NULL;\n+          \/\/ If vt_stub is null, then return null to signal handler to report the SEGV error.\n+          if (vt_stub == nullptr) return nullptr;\n@@ -958,2 +958,2 @@\n-          \/\/ If code blob is NULL, then return NULL to signal handler to report the SEGV error.\n-          if (cb == NULL) return NULL;\n+          \/\/ If code blob is null, then return null to signal handler to report the SEGV error.\n+          if (cb == nullptr) return nullptr;\n@@ -970,1 +970,1 @@\n-              return NULL;\n+              return nullptr;\n@@ -998,1 +998,1 @@\n-          \/\/ If there's an unexpected fault, target_pc might be NULL,\n+          \/\/ If there's an unexpected fault, target_pc might be null,\n@@ -1009,1 +1009,1 @@\n-        guarantee(cm != NULL, \"must have containing compiled method for implicit division-by-zero exceptions\");\n+        guarantee(cm != nullptr, \"must have containing compiled method for implicit division-by-zero exceptions\");\n@@ -1014,1 +1014,1 @@\n-        \/\/ If there's an unexpected fault, target_pc might be NULL,\n+        \/\/ If there's an unexpected fault, target_pc might be null,\n@@ -1042,1 +1042,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1082,2 +1082,2 @@\n-  assert(thread != NULL, \"No thread\");\n-  if (thread == NULL) {\n+  assert(thread != nullptr, \"No thread\");\n+  if (thread == nullptr) {\n@@ -1089,1 +1089,1 @@\n-  return (obj == NULL) ? 0 : java_lang_Thread::thread_id(obj);\n+  return (obj == nullptr) ? 0 : java_lang_Thread::thread_id(obj);\n@@ -1169,1 +1169,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1247,1 +1247,1 @@\n-        attached_method = methodHandle(current, NULL);\n+        attached_method = methodHandle(current, nullptr);\n@@ -1272,1 +1272,1 @@\n-    if (callee == NULL) {\n+    if (callee == nullptr) {\n@@ -1274,1 +1274,1 @@\n-      if (callee == NULL) {\n+      if (callee == nullptr) {\n@@ -1313,1 +1313,1 @@\n-    Klass* rk = NULL;\n+    Klass* rk = nullptr;\n@@ -1411,1 +1411,1 @@\n-  if (callee != NULL) {\n+  if (callee != nullptr) {\n@@ -1415,1 +1415,1 @@\n-  if (callee != NULL && !callee->is_in_use()) {\n+  if (callee != nullptr && !callee->is_in_use()) {\n@@ -1417,1 +1417,1 @@\n-    callee = NULL;\n+    callee = nullptr;\n@@ -1420,1 +1420,1 @@\n-  address dest_entry_point = callee == NULL ? 0 : callee->entry_point(); \/\/ used below\n+  address dest_entry_point = callee == nullptr ? 0 : callee->entry_point(); \/\/ used below\n@@ -1426,1 +1426,1 @@\n-    Klass* receiver_klass = NULL;\n+    Klass* receiver_klass = nullptr;\n@@ -1432,1 +1432,1 @@\n-      receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver->klass();\n+      receiver_klass = invoke_code == Bytecodes::_invokehandle ? nullptr : receiver->klass();\n@@ -1456,1 +1456,1 @@\n-        (callee == NULL || (callee->is_in_use() && callee_method->code() == callee))) {\n+        (callee == nullptr || (callee->is_in_use() && callee_method->code() == callee))) {\n@@ -1462,1 +1462,1 @@\n-        assert((cb != NULL) && cb->is_compiled() && (((CompiledMethod*)cb) == callee),\n+        assert((cb != nullptr) && cb->is_compiled() && (((CompiledMethod*)cb) == callee),\n@@ -1477,1 +1477,1 @@\n-            callee != NULL && callee->is_compiled_by_jvmci()) {\n+            callee != nullptr && callee->is_compiled_by_jvmci()) {\n@@ -1503,1 +1503,1 @@\n-  guarantee(caller_cb != NULL && caller_cb->is_compiled(), \"must be called from compiled method\");\n+  guarantee(caller_cb != nullptr && caller_cb->is_compiled(), \"must be called from compiled method\");\n@@ -1507,2 +1507,2 @@\n-  \/\/ note: a) receiver is NULL for static calls\n-  \/\/       b) an exception is thrown if receiver is NULL for non-static calls\n+  \/\/ note: a) receiver is null for static calls\n+  \/\/       b) an exception is thrown if receiver is null for non-static calls\n@@ -1642,1 +1642,1 @@\n-    guarantee(callee != NULL && callee->is_method(), \"bad handshake\");\n+    guarantee(callee != nullptr && callee->is_method(), \"bad handshake\");\n@@ -1644,1 +1644,1 @@\n-    current->set_callee_target(NULL);\n+    current->set_callee_target(nullptr);\n@@ -1704,1 +1704,1 @@\n-      Klass *recv_klass = (recv != NULL) ? recv->klass() : NULL;\n+      Klass *recv_klass = (recv != nullptr) ? recv->klass() : nullptr;\n@@ -1730,1 +1730,1 @@\n-      enter_special = caller.cb() != NULL && caller.cb()->is_compiled()\n+      enter_special = caller.cb() != nullptr && caller.cb()->is_compiled()\n@@ -1749,1 +1749,1 @@\n-  assert(entry != NULL, \"Jump to zero!\");\n+  assert(entry != nullptr, \"Jump to zero!\");\n@@ -1765,1 +1765,1 @@\n-  assert(entry != NULL, \"Jump to zero!\");\n+  assert(entry != nullptr, \"Jump to zero!\");\n@@ -1782,1 +1782,1 @@\n-  assert(entry != NULL, \"Jump to zero!\");\n+  assert(entry != nullptr, \"Jump to zero!\");\n@@ -1809,1 +1809,1 @@\n-    if (ic_oop != NULL) {\n+    if (ic_oop != nullptr) {\n@@ -1820,1 +1820,1 @@\n-        \/\/ We can't assert for callee_method->code() != NULL because it\n+        \/\/ We can't assert for callee_method->code() != nullptr because it\n@@ -1874,1 +1874,1 @@\n-  \/\/ receiver is NULL for static calls. An exception is thrown for NULL\n+  \/\/ receiver is null for static calls. An exception is thrown for null\n@@ -2033,1 +2033,1 @@\n-    address call_addr = NULL;\n+    address call_addr = nullptr;\n@@ -2044,1 +2044,1 @@\n-    if (call_addr != NULL) {\n+    if (call_addr != nullptr) {\n@@ -2141,1 +2141,1 @@\n-    if (callee != NULL && (callee == cb || callee->is_adapter_blob())) {\n+    if (callee != nullptr && (callee == cb || callee->is_adapter_blob())) {\n@@ -2193,1 +2193,1 @@\n-  if (callee == NULL) {\n+  if (callee == nullptr) {\n@@ -2198,1 +2198,1 @@\n-  if (cb == NULL || !cb->is_compiled() || callee->is_unloading()) {\n+  if (cb == nullptr || !cb->is_compiled() || callee->is_unloading()) {\n@@ -2215,2 +2215,2 @@\n-  \/\/ call site with the same old data. clear_code will set code() to NULL\n-  \/\/ at the end of it. If we happen to see that NULL then we can skip trying\n+  \/\/ call site with the same old data. clear_code will set code() to null\n+  \/\/ at the end of it. If we happen to see that null then we can skip trying\n@@ -2218,1 +2218,1 @@\n-  \/\/ from_compiled_entry and the NULL isn't present yet then we lose the race\n+  \/\/ from_compiled_entry and the null isn't present yet then we lose the race\n@@ -2221,1 +2221,1 @@\n-  if (moop->code() == NULL) return;\n+  if (moop->code() == nullptr) return;\n@@ -2274,1 +2274,1 @@\n-  if (src == NULL || dest == NULL) {\n+  if (src == nullptr || dest == nullptr) {\n@@ -2300,2 +2300,2 @@\n-  Symbol* target_klass_name = NULL;\n-  if (target_klass == NULL) {\n+  Symbol* target_klass_name = nullptr;\n+  if (target_klass == nullptr) {\n@@ -2315,2 +2315,2 @@\n-  assert(target_klass != NULL || target_klass_name != NULL, \"one must be provided\");\n-  const char* target_name = target_klass == NULL ? target_klass_name->as_klass_external_name() :\n+  assert(target_klass != nullptr || target_klass_name != nullptr, \"one must be provided\");\n+  const char* target_name = target_klass == nullptr ? target_klass_name->as_klass_external_name() :\n@@ -2324,1 +2324,1 @@\n-  if (target_klass != NULL && caster_klass->module() == target_klass->module()) {\n+  if (target_klass != nullptr && caster_klass->module() == target_klass->module()) {\n@@ -2328,2 +2328,2 @@\n-    target_klass_description = (target_klass != NULL) ? target_klass->class_in_module_of_loader() : \"\";\n-    klass_separator = (target_klass != NULL) ? \"; \" : \"\";\n+    target_klass_description = (target_klass != nullptr) ? target_klass->class_in_module_of_loader() : \"\";\n+    klass_separator = (target_klass != nullptr) ? \"; \" : \"\";\n@@ -2336,1 +2336,1 @@\n-  if (message == NULL) {\n+  if (message == nullptr) {\n@@ -2406,1 +2406,1 @@\n-  if (xtty != NULL)  xtty->head(\"statistics type='SharedRuntime'\");\n+  if (xtty != nullptr)  xtty->head(\"statistics type='SharedRuntime'\");\n@@ -2443,1 +2443,1 @@\n-  if (xtty != NULL)  xtty->tail(\"statistics\");\n+  if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -2462,2 +2462,2 @@\n-    Method* method = (nm == NULL) ? NULL : nm->method();\n-    if (method != NULL) {\n+    Method* method = (nm == nullptr) ? nullptr : nm->method();\n+    if (method != nullptr) {\n@@ -2622,1 +2622,1 @@\n-    int total_args_passed = (sig != NULL) ? sig->length() : 0;\n+    int total_args_passed = (sig != nullptr) ? sig->length() : 0;\n@@ -2820,6 +2820,6 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_no_arg_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_int_arg_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_obj_arg_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_obj_int_arg_handler = NULL;\n-AdapterHandlerEntry* AdapterHandlerLibrary::_obj_obj_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_no_arg_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_int_arg_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_arg_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_int_arg_handler = nullptr;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_obj_arg_handler = nullptr;\n@@ -2827,1 +2827,1 @@\n-BufferBlob* AdapterHandlerLibrary::_buffer = NULL;\n+BufferBlob* AdapterHandlerLibrary::_buffer = nullptr;\n@@ -2854,5 +2854,5 @@\n-  AdapterBlob* no_arg_blob = NULL;\n-  AdapterBlob* int_arg_blob = NULL;\n-  AdapterBlob* obj_arg_blob = NULL;\n-  AdapterBlob* obj_int_arg_blob = NULL;\n-  AdapterBlob* obj_obj_arg_blob = NULL;\n+  AdapterBlob* no_arg_blob = nullptr;\n+  AdapterBlob* int_arg_blob = nullptr;\n+  AdapterBlob* obj_arg_blob = nullptr;\n+  AdapterBlob* obj_int_arg_blob = nullptr;\n+  AdapterBlob* obj_obj_arg_blob = nullptr;\n@@ -2868,1 +2868,1 @@\n-    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n+    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(nullptr),\n@@ -2877,1 +2877,1 @@\n-    SigEntry::add_entry(obj_args.sig(), T_OBJECT, NULL);\n+    SigEntry::add_entry(obj_args.sig(), T_OBJECT, nullptr);\n@@ -2884,1 +2884,1 @@\n-    SigEntry::add_entry(int_args.sig(), T_INT, NULL);\n+    SigEntry::add_entry(int_args.sig(), T_INT, nullptr);\n@@ -2889,2 +2889,2 @@\n-    SigEntry::add_entry(obj_int_args.sig(), T_OBJECT, NULL);\n-    SigEntry::add_entry(obj_int_args.sig(), T_INT, NULL);\n+    SigEntry::add_entry(obj_int_args.sig(), T_OBJECT, nullptr);\n+    SigEntry::add_entry(obj_int_args.sig(), T_INT, nullptr);\n@@ -2895,2 +2895,2 @@\n-    SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT, NULL);\n-    SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT, NULL);\n+    SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT, nullptr);\n+    SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT, nullptr);\n@@ -2900,5 +2900,5 @@\n-    assert(no_arg_blob != NULL &&\n-          obj_arg_blob != NULL &&\n-          int_arg_blob != NULL &&\n-          obj_int_arg_blob != NULL &&\n-          obj_obj_arg_blob != NULL, \"Initial adapters must be properly created\");\n+    assert(no_arg_blob != nullptr &&\n+          obj_arg_blob != nullptr &&\n+          int_arg_blob != nullptr &&\n+          obj_int_arg_blob != nullptr &&\n+          obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n@@ -2930,1 +2930,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2938,1 +2938,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2947,2 +2947,2 @@\n-          if (vk != NULL) {\n-            return NULL;\n+          if (vk != nullptr) {\n+            return nullptr;\n@@ -2969,2 +2969,2 @@\n-          if (vk != NULL) {\n-            return NULL;\n+          if (vk != nullptr) {\n+            return nullptr;\n@@ -2985,1 +2985,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2990,1 +2990,1 @@\n-  _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),\n+  _regs(nullptr), _regs_cc(nullptr), _regs_cc_ro(nullptr),\n@@ -2993,3 +2993,3 @@\n-  _sig = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n-  _sig_cc = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n-  _sig_cc_ro = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+  _sig = new GrowableArray<SigEntry>((method != nullptr) ? method->size_of_parameters() : 1);\n+  _sig_cc = new GrowableArray<SigEntry>((method != nullptr) ? method->size_of_parameters() : 1);\n+  _sig_cc_ro = new GrowableArray<SigEntry>((method != nullptr) ? method->size_of_parameters() : 1);\n@@ -3057,1 +3057,1 @@\n-  while (holder != NULL) {\n+  while (holder != nullptr) {\n@@ -3059,1 +3059,1 @@\n-    if (super_method == NULL) {\n+    if (super_method == nullptr) {\n@@ -3073,1 +3073,1 @@\n-    if (m != NULL && !m->is_static() && m->is_public()) {\n+    if (m != nullptr && !m->is_static() && m->is_public()) {\n@@ -3083,1 +3083,1 @@\n-  if (_method != NULL) {\n+  if (_method != nullptr) {\n@@ -3104,1 +3104,1 @@\n-        if (vk != NULL && vk->can_be_passed_as_fields() && (init || _method->is_scalarized_arg(arg_num))) {\n+        if (vk != nullptr && vk->can_be_passed_as_fields() && (init || _method->is_scalarized_arg(arg_num))) {\n@@ -3156,2 +3156,2 @@\n-              _sig_cc->insert_before(last+1, SigEntry(T_BOOLEAN, -1, NULL));\n-              _sig_cc_ro->insert_before(last_ro+1, SigEntry(T_BOOLEAN, -1, NULL));\n+              _sig_cc->insert_before(last+1, SigEntry(T_BOOLEAN, -1, nullptr));\n+              _sig_cc_ro->insert_before(last_ro+1, SigEntry(T_BOOLEAN, -1, nullptr));\n@@ -3217,1 +3217,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -3222,1 +3222,1 @@\n-  AdapterBlob* new_adapter = NULL;\n+  AdapterBlob* new_adapter = nullptr;\n@@ -3240,1 +3240,1 @@\n-      entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n+      entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(nullptr),\n@@ -3253,1 +3253,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -3256,1 +3256,1 @@\n-        AdapterBlob* comparison_blob = NULL;\n+        AdapterBlob* comparison_blob = nullptr;\n@@ -3258,1 +3258,1 @@\n-        assert(comparison_blob == NULL, \"no blob should be created when creating an adapter for comparison\");\n+        assert(comparison_blob == nullptr, \"no blob should be created when creating an adapter for comparison\");\n@@ -3271,1 +3271,1 @@\n-  if (new_adapter != NULL) {\n+  if (new_adapter != nullptr) {\n@@ -3285,1 +3285,1 @@\n-  bool contains_all_checks = StubRoutines::code2() != NULL;\n+  bool contains_all_checks = StubRoutines::code2() != nullptr;\n@@ -3324,1 +3324,1 @@\n-  if (new_adapter == NULL) {\n+  if (new_adapter == nullptr) {\n@@ -3329,1 +3329,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3343,1 +3343,1 @@\n-      if (first_pc != NULL) {\n+      if (first_pc != nullptr) {\n@@ -3363,7 +3363,7 @@\n-  if (base == NULL)  base = _c2i_entry;\n-  assert(base <= _c2i_entry || _c2i_entry == NULL, \"\");\n-  assert(base <= _c2i_inline_entry || _c2i_inline_entry == NULL, \"\");\n-  assert(base <= _c2i_inline_ro_entry || _c2i_inline_ro_entry == NULL, \"\");\n-  assert(base <= _c2i_unverified_entry || _c2i_unverified_entry == NULL, \"\");\n-  assert(base <= _c2i_unverified_inline_entry || _c2i_unverified_inline_entry == NULL, \"\");\n-  assert(base <= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, \"\");\n+  if (base == nullptr)  base = _c2i_entry;\n+  assert(base <= _c2i_entry || _c2i_entry == nullptr, \"\");\n+  assert(base <= _c2i_inline_entry || _c2i_inline_entry == nullptr, \"\");\n+  assert(base <= _c2i_inline_ro_entry || _c2i_inline_ro_entry == nullptr, \"\");\n+  assert(base <= _c2i_unverified_entry || _c2i_unverified_entry == nullptr, \"\");\n+  assert(base <= _c2i_unverified_inline_entry || _c2i_unverified_inline_entry == nullptr, \"\");\n+  assert(base <= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == nullptr, \"\");\n@@ -3375,1 +3375,1 @@\n-  assert(old_base != NULL, \"\");\n+  assert(old_base != nullptr, \"\");\n@@ -3377,1 +3377,1 @@\n-  if (_i2c_entry != NULL)\n+  if (_i2c_entry != nullptr)\n@@ -3379,1 +3379,1 @@\n-  if (_c2i_entry != NULL)\n+  if (_c2i_entry != nullptr)\n@@ -3381,1 +3381,1 @@\n-  if (_c2i_inline_entry != NULL)\n+  if (_c2i_inline_entry != nullptr)\n@@ -3383,1 +3383,1 @@\n-  if (_c2i_inline_ro_entry != NULL)\n+  if (_c2i_inline_ro_entry != nullptr)\n@@ -3385,1 +3385,1 @@\n-  if (_c2i_unverified_entry != NULL)\n+  if (_c2i_unverified_entry != nullptr)\n@@ -3387,1 +3387,1 @@\n-  if (_c2i_unverified_inline_entry != NULL)\n+  if (_c2i_unverified_inline_entry != nullptr)\n@@ -3389,1 +3389,1 @@\n-  if (_c2i_no_clinit_check_entry != NULL)\n+  if (_c2i_no_clinit_check_entry != nullptr)\n@@ -3397,1 +3397,1 @@\n-  if (_sig_cc != NULL) {\n+  if (_sig_cc != nullptr) {\n@@ -3418,1 +3418,1 @@\n-  assert(_saved_code != NULL && other->_saved_code != NULL, \"code not saved\");\n+  assert(_saved_code != nullptr && other->_saved_code != nullptr, \"code not saved\");\n@@ -3437,1 +3437,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -3450,1 +3450,1 @@\n-    if (method->code() != NULL) {\n+    if (method->code() != nullptr) {\n@@ -3460,1 +3460,1 @@\n-    if (buf != NULL) {\n+    if (buf != nullptr) {\n@@ -3511,1 +3511,1 @@\n-      if (nm != NULL) {\n+      if (nm != nullptr) {\n@@ -3530,1 +3530,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -3648,1 +3648,1 @@\n-    if (kptr->obj() != NULL) active_monitor_count++;\n+    if (kptr->obj() != nullptr) active_monitor_count++;\n@@ -3672,1 +3672,1 @@\n-    if (kptr2->obj() != NULL) {         \/\/ Avoid 'holes' in the monitor array\n+    if (kptr2->obj() != nullptr) {         \/\/ Avoid 'holes' in the monitor array\n@@ -3734,1 +3734,1 @@\n-  if (get_i2c_entry() != NULL) {\n+  if (get_i2c_entry() != nullptr) {\n@@ -3737,1 +3737,1 @@\n-  if (get_c2i_entry() != NULL) {\n+  if (get_c2i_entry() != nullptr) {\n@@ -3740,1 +3740,1 @@\n-  if (get_c2i_entry() != NULL) {\n+  if (get_c2i_entry() != nullptr) {\n@@ -3743,1 +3743,1 @@\n-  if (get_c2i_entry() != NULL) {\n+  if (get_c2i_entry() != nullptr) {\n@@ -3746,1 +3746,1 @@\n-  if (get_c2i_unverified_entry() != NULL) {\n+  if (get_c2i_unverified_entry() != nullptr) {\n@@ -3749,1 +3749,1 @@\n-  if (get_c2i_unverified_entry() != NULL) {\n+  if (get_c2i_unverified_entry() != nullptr) {\n@@ -3752,1 +3752,1 @@\n-  if (get_c2i_no_clinit_check_entry() != NULL) {\n+  if (get_c2i_no_clinit_check_entry() != nullptr) {\n@@ -3776,1 +3776,1 @@\n-  CompiledMethod* nm = NULL;\n+  CompiledMethod* nm = nullptr;\n@@ -3790,1 +3790,1 @@\n-    Method* method = NULL;\n+    Method* method = nullptr;\n@@ -3794,1 +3794,1 @@\n-      if (method != NULL && method->has_reserved_stack_access()) {\n+      if (method != nullptr && method->has_reserved_stack_access()) {\n@@ -3799,1 +3799,1 @@\n-      if (cb != NULL && cb->is_compiled()) {\n+      if (cb != nullptr && cb->is_compiled()) {\n@@ -3804,1 +3804,1 @@\n-        for (ScopeDesc *sd = nm->scope_desc_near(fr.pc()); sd != NULL; sd = sd->sender()) {\n+        for (ScopeDesc *sd = nm->scope_desc_near(fr.pc()); sd != nullptr; sd = sd->sender()) {\n@@ -3806,1 +3806,1 @@\n-          if (method != NULL && method->has_reserved_stack_access()) {\n+          if (method != nullptr && method->has_reserved_stack_access()) {\n@@ -3834,1 +3834,1 @@\n-  if (new_obj == NULL) return;\n+  if (new_obj == nullptr) return;\n@@ -3877,1 +3877,1 @@\n-      assert(vk != NULL, \"Unexpected klass\");\n+      assert(vk != nullptr, \"Unexpected klass\");\n@@ -3914,1 +3914,1 @@\n-  if (regs == NULL) {\n+  if (regs == nullptr) {\n@@ -4010,1 +4010,1 @@\n-    assert(verif_vk == NULL, \"broken calling convention\");\n+    assert(verif_vk == nullptr, \"broken calling convention\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":184,"deletions":184,"binary":false,"changes":368,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,1 @@\n-    assert(_ic_miss_blob!= NULL, \"oops\");\n+    assert(_ic_miss_blob!= nullptr, \"oops\");\n@@ -225,1 +225,1 @@\n-    assert(_wrong_method_blob!= NULL, \"oops\");\n+    assert(_wrong_method_blob!= nullptr, \"oops\");\n@@ -230,1 +230,1 @@\n-    assert(_wrong_method_abstract_blob!= NULL, \"oops\");\n+    assert(_wrong_method_abstract_blob!= nullptr, \"oops\");\n@@ -240,1 +240,1 @@\n-    assert(_resolve_opt_virtual_call_blob != NULL, \"oops\");\n+    assert(_resolve_opt_virtual_call_blob != nullptr, \"oops\");\n@@ -244,1 +244,1 @@\n-    assert(_resolve_virtual_call_blob != NULL, \"oops\");\n+    assert(_resolve_virtual_call_blob != nullptr, \"oops\");\n@@ -248,1 +248,1 @@\n-    assert(_resolve_static_call_blob != NULL, \"oops\");\n+    assert(_resolve_static_call_blob != nullptr, \"oops\");\n@@ -268,1 +268,1 @@\n-  static void throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message = NULL);\n+  static void throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message = nullptr);\n@@ -319,1 +319,1 @@\n-  static char* generate_class_cast_message(Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name = NULL);\n+  static char* generate_class_cast_message(Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name = nullptr);\n@@ -351,3 +351,3 @@\n-    assert(callee_method->verified_code_entry() != NULL, \"Jump to zero!\");\n-    assert(callee_method->verified_inline_code_entry() != NULL, \"Jump to zero!\");\n-    assert(callee_method->verified_inline_ro_code_entry() != NULL, \"Jump to zero!\");\n+    assert(callee_method->verified_code_entry() != nullptr, \"Jump to zero!\");\n+    assert(callee_method->verified_inline_code_entry() != nullptr, \"Jump to zero!\");\n+    assert(callee_method->verified_inline_ro_code_entry() != nullptr, \"Jump to zero!\");\n@@ -404,1 +404,1 @@\n-  \/\/ NULL is being passed as the second VMRegPair array, so arguments are either\n+  \/\/ null is being passed as the second VMRegPair array, so arguments are either\n@@ -679,1 +679,1 @@\n-    _sig_cc(NULL)\n+    _sig_cc(nullptr)\n@@ -738,1 +738,1 @@\n-                                        address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry = NULL);\n+                                        address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry = nullptr);\n@@ -806,1 +806,1 @@\n-  CompiledEntrySignature(Method* method = NULL);\n+  CompiledEntrySignature(Method* method = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,1 @@\n-  if (_method != NULL) {\n+  if (_method != nullptr) {\n@@ -194,1 +194,1 @@\n-  if (_method == NULL && _param_size > fp_max_size_of_parameters) {\n+  if (_method == nullptr && _param_size > fp_max_size_of_parameters) {\n@@ -211,1 +211,1 @@\n-  if (_method != NULL) {\n+  if (_method != nullptr) {\n@@ -310,1 +310,1 @@\n-  \/\/ avoid a number of NULL checks in the parser\n+  \/\/ avoid a number of null checks in the parser\n@@ -312,1 +312,1 @@\n-  _names = NULL;\n+  _names = nullptr;\n@@ -319,1 +319,1 @@\n-    assert(_names == NULL, \"_names unexpectedly created\");\n+    assert(_names == nullptr, \"_names unexpectedly created\");\n@@ -325,1 +325,1 @@\n-  if (_names != NULL) {\n+  if (_names != nullptr) {\n@@ -341,1 +341,1 @@\n-    return (tem == NULL ? limit : tem + 1 - base);\n+    return (tem == nullptr ? limit : tem + 1 - base);\n@@ -353,1 +353,1 @@\n-      return (tem == NULL ? limit : tem + 1 - base);\n+      return (tem == nullptr ? limit : tem + 1 - base);\n@@ -497,1 +497,1 @@\n-    if (_names == NULL) {\n+    if (_names == nullptr) {\n@@ -524,1 +524,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -527,1 +527,1 @@\n-  Klass* k = NULL;\n+  Klass* k = nullptr;\n@@ -529,1 +529,1 @@\n-    \/\/ Note:  SD::resolve_or_null returns NULL for most failure modes,\n+    \/\/ Note:  SD::resolve_or_null returns null for most failure modes,\n@@ -557,2 +557,2 @@\n-  if (klass == NULL) {\n-    return NULL;\n+  if (klass == nullptr) {\n+    return nullptr;\n@@ -577,1 +577,1 @@\n-  initialize_load_origin(NULL);\n+  initialize_load_origin(nullptr);\n@@ -583,1 +583,1 @@\n-  assert(load_origin != NULL, \"\");\n+  assert(load_origin != nullptr, \"\");\n@@ -594,1 +594,1 @@\n-  assert(_load_origin != NULL, \"\");\n+  assert(_load_origin != nullptr, \"\");\n@@ -623,1 +623,1 @@\n-  if (method_sig != NULL && len > 1 && method_sig[index] == JVM_SIGNATURE_FUNC) {\n+  if (method_sig != nullptr && len > 1 && method_sig[index] == JVM_SIGNATURE_FUNC) {\n@@ -645,1 +645,1 @@\n-  return (type_sig != NULL && len >= 1 &&\n+  return (type_sig != nullptr && len >= 1 &&\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -364,1 +364,1 @@\n-      _method(NULL) {\n+      _method(nullptr) {\n@@ -638,1 +638,1 @@\n-    _handles_cached = (load_origin == NULL);\n+    _handles_cached = (load_origin == nullptr);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    if (chunk != NULL && chunk->has_bitmap()) {\n+    if (chunk != nullptr && chunk->has_bitmap()) {\n@@ -63,2 +63,2 @@\n-      \/\/ The narrow_oop_base could be NULL or be the address\n-      \/\/ of the page below heap. Use NULL value for both cases.\n+      \/\/ The narrow_oop_base could be null or be the address\n+      \/\/ of the page below heap. Use null value for both cases.\n@@ -70,1 +70,1 @@\n-  if (chunk != NULL) {\n+  if (chunk != nullptr) {\n@@ -95,1 +95,1 @@\n-  if (chunk != NULL) {\n+  if (chunk != nullptr) {\n@@ -107,1 +107,1 @@\n-         p2i(addr), chunk != NULL, chunk != NULL && chunk->has_bitmap() && UseCompressedOops);\n+         p2i(addr), chunk != nullptr, chunk != nullptr && chunk->has_bitmap() && UseCompressedOops);\n@@ -115,1 +115,1 @@\n-         p2i(addr), chunk != NULL, chunk != NULL && chunk->has_bitmap() && UseCompressedOops);\n+         p2i(addr), chunk != nullptr, chunk != nullptr && chunk->has_bitmap() && UseCompressedOops);\n@@ -249,1 +249,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -253,1 +253,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -264,1 +264,1 @@\n-    assert(value_addr == NULL || reg_map->thread() == NULL || reg_map->thread()->is_in_usable_stack(value_addr), INTPTR_FORMAT, p2i(value_addr));\n+    assert(value_addr == nullptr || reg_map->thread() == nullptr || reg_map->thread()->is_in_usable_stack(value_addr), INTPTR_FORMAT, p2i(value_addr));\n@@ -272,1 +272,1 @@\n-  assert(value_addr == NULL || Continuation::is_in_usable_stack(value_addr, reg_map->as_RegisterMap()) || (reg_map->thread() != NULL && reg_map->thread()->is_in_usable_stack(value_addr)), INTPTR_FORMAT, p2i(value_addr));\n+  assert(value_addr == nullptr || Continuation::is_in_usable_stack(value_addr, reg_map->as_RegisterMap()) || (reg_map->thread() != nullptr && reg_map->thread()->is_in_usable_stack(value_addr)), INTPTR_FORMAT, p2i(value_addr));\n@@ -300,1 +300,1 @@\n-      if (_handle_value() != NULL) {\n+      if (_handle_value() != nullptr) {\n@@ -303,1 +303,1 @@\n-        st->print(\"NULL\");\n+        st->print(\"null\");\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-UnsafeCopyMemory* UnsafeCopyMemory::_table                      = NULL;\n+UnsafeCopyMemory* UnsafeCopyMemory::_table                      = nullptr;\n@@ -46,1 +46,1 @@\n-address UnsafeCopyMemory::_common_exit_stub_pc                  = NULL;\n+address UnsafeCopyMemory::_common_exit_stub_pc                  = nullptr;\n@@ -53,3 +53,3 @@\n-BufferBlob* StubRoutines::_code1                                = NULL;\n-BufferBlob* StubRoutines::_code2                                = NULL;\n-BufferBlob* StubRoutines::_code3                                = NULL;\n+BufferBlob* StubRoutines::_code1                                = nullptr;\n+BufferBlob* StubRoutines::_code2                                = nullptr;\n+BufferBlob* StubRoutines::_code3                                = nullptr;\n@@ -57,2 +57,2 @@\n-address StubRoutines::_call_stub_return_address                 = NULL;\n-address StubRoutines::_call_stub_entry                          = NULL;\n+address StubRoutines::_call_stub_return_address                 = nullptr;\n+address StubRoutines::_call_stub_entry                          = nullptr;\n@@ -60,7 +60,7 @@\n-address StubRoutines::_catch_exception_entry                    = NULL;\n-address StubRoutines::_forward_exception_entry                  = NULL;\n-address StubRoutines::_throw_AbstractMethodError_entry          = NULL;\n-address StubRoutines::_throw_IncompatibleClassChangeError_entry = NULL;\n-address StubRoutines::_throw_NullPointerException_at_call_entry = NULL;\n-address StubRoutines::_throw_StackOverflowError_entry           = NULL;\n-address StubRoutines::_throw_delayed_StackOverflowError_entry   = NULL;\n+address StubRoutines::_catch_exception_entry                    = nullptr;\n+address StubRoutines::_forward_exception_entry                  = nullptr;\n+address StubRoutines::_throw_AbstractMethodError_entry          = nullptr;\n+address StubRoutines::_throw_IncompatibleClassChangeError_entry = nullptr;\n+address StubRoutines::_throw_NullPointerException_at_call_entry = nullptr;\n+address StubRoutines::_throw_StackOverflowError_entry           = nullptr;\n+address StubRoutines::_throw_delayed_StackOverflowError_entry   = nullptr;\n@@ -68,6 +68,6 @@\n-address StubRoutines::_verify_oop_subroutine_entry              = NULL;\n-address StubRoutines::_atomic_xchg_entry                        = NULL;\n-address StubRoutines::_atomic_cmpxchg_entry                     = NULL;\n-address StubRoutines::_atomic_cmpxchg_long_entry                = NULL;\n-address StubRoutines::_atomic_add_entry                         = NULL;\n-address StubRoutines::_fence_entry                              = NULL;\n+address StubRoutines::_verify_oop_subroutine_entry              = nullptr;\n+address StubRoutines::_atomic_xchg_entry                        = nullptr;\n+address StubRoutines::_atomic_cmpxchg_entry                     = nullptr;\n+address StubRoutines::_atomic_cmpxchg_long_entry                = nullptr;\n+address StubRoutines::_atomic_add_entry                         = nullptr;\n+address StubRoutines::_fence_entry                              = nullptr;\n@@ -103,2 +103,2 @@\n-address StubRoutines::_data_cache_writeback              = NULL;\n-address StubRoutines::_data_cache_writeback_sync         = NULL;\n+address StubRoutines::_data_cache_writeback              = nullptr;\n+address StubRoutines::_data_cache_writeback_sync         = nullptr;\n@@ -106,4 +106,4 @@\n-address StubRoutines::_checkcast_arraycopy               = NULL;\n-address StubRoutines::_checkcast_arraycopy_uninit        = NULL;\n-address StubRoutines::_unsafe_arraycopy                  = NULL;\n-address StubRoutines::_generic_arraycopy                 = NULL;\n+address StubRoutines::_checkcast_arraycopy               = nullptr;\n+address StubRoutines::_checkcast_arraycopy_uninit        = nullptr;\n+address StubRoutines::_unsafe_arraycopy                  = nullptr;\n+address StubRoutines::_generic_arraycopy                 = nullptr;\n@@ -118,65 +118,65 @@\n-address StubRoutines::_aescrypt_encryptBlock               = NULL;\n-address StubRoutines::_aescrypt_decryptBlock               = NULL;\n-address StubRoutines::_cipherBlockChaining_encryptAESCrypt = NULL;\n-address StubRoutines::_cipherBlockChaining_decryptAESCrypt = NULL;\n-address StubRoutines::_electronicCodeBook_encryptAESCrypt  = NULL;\n-address StubRoutines::_electronicCodeBook_decryptAESCrypt  = NULL;\n-address StubRoutines::_counterMode_AESCrypt                = NULL;\n-address StubRoutines::_galoisCounterMode_AESCrypt          = NULL;\n-address StubRoutines::_ghash_processBlocks                 = NULL;\n-address StubRoutines::_chacha20Block                       = NULL;\n-address StubRoutines::_base64_encodeBlock                  = NULL;\n-address StubRoutines::_base64_decodeBlock                  = NULL;\n-address StubRoutines::_poly1305_processBlocks              = NULL;\n-\n-address StubRoutines::_md5_implCompress      = NULL;\n-address StubRoutines::_md5_implCompressMB    = NULL;\n-address StubRoutines::_sha1_implCompress     = NULL;\n-address StubRoutines::_sha1_implCompressMB   = NULL;\n-address StubRoutines::_sha256_implCompress   = NULL;\n-address StubRoutines::_sha256_implCompressMB = NULL;\n-address StubRoutines::_sha512_implCompress   = NULL;\n-address StubRoutines::_sha512_implCompressMB = NULL;\n-address StubRoutines::_sha3_implCompress     = NULL;\n-address StubRoutines::_sha3_implCompressMB   = NULL;\n-\n-address StubRoutines::_updateBytesCRC32 = NULL;\n-address StubRoutines::_crc_table_adr =    NULL;\n-\n-address StubRoutines::_crc32c_table_addr = NULL;\n-address StubRoutines::_updateBytesCRC32C = NULL;\n-address StubRoutines::_updateBytesAdler32 = NULL;\n-\n-address StubRoutines::_multiplyToLen = NULL;\n-address StubRoutines::_squareToLen = NULL;\n-address StubRoutines::_mulAdd = NULL;\n-address StubRoutines::_montgomeryMultiply = NULL;\n-address StubRoutines::_montgomerySquare = NULL;\n-address StubRoutines::_bigIntegerRightShiftWorker = NULL;\n-address StubRoutines::_bigIntegerLeftShiftWorker = NULL;\n-\n-address StubRoutines::_vectorizedMismatch = NULL;\n-\n-address StubRoutines::_dexp = NULL;\n-address StubRoutines::_dlog = NULL;\n-address StubRoutines::_dlog10 = NULL;\n-address StubRoutines::_dpow = NULL;\n-address StubRoutines::_dsin = NULL;\n-address StubRoutines::_dcos = NULL;\n-address StubRoutines::_dlibm_sin_cos_huge = NULL;\n-address StubRoutines::_dlibm_reduce_pi04l = NULL;\n-address StubRoutines::_dlibm_tan_cot_huge = NULL;\n-address StubRoutines::_dtan = NULL;\n-\n-address StubRoutines::_load_inline_type_fields_in_regs = NULL;\n-address StubRoutines::_store_inline_type_fields_to_buf = NULL;\n-\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{NULL}, {NULL}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{NULL}, {NULL}};\n-\n-address StubRoutines::_cont_thaw          = NULL;\n-address StubRoutines::_cont_returnBarrier = NULL;\n-address StubRoutines::_cont_returnBarrierExc = NULL;\n-\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = NULL;)\n-JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = NULL;)\n+address StubRoutines::_aescrypt_encryptBlock               = nullptr;\n+address StubRoutines::_aescrypt_decryptBlock               = nullptr;\n+address StubRoutines::_cipherBlockChaining_encryptAESCrypt = nullptr;\n+address StubRoutines::_cipherBlockChaining_decryptAESCrypt = nullptr;\n+address StubRoutines::_electronicCodeBook_encryptAESCrypt  = nullptr;\n+address StubRoutines::_electronicCodeBook_decryptAESCrypt  = nullptr;\n+address StubRoutines::_counterMode_AESCrypt                = nullptr;\n+address StubRoutines::_galoisCounterMode_AESCrypt          = nullptr;\n+address StubRoutines::_ghash_processBlocks                 = nullptr;\n+address StubRoutines::_chacha20Block                       = nullptr;\n+address StubRoutines::_base64_encodeBlock                  = nullptr;\n+address StubRoutines::_base64_decodeBlock                  = nullptr;\n+address StubRoutines::_poly1305_processBlocks              = nullptr;\n+\n+address StubRoutines::_md5_implCompress      = nullptr;\n+address StubRoutines::_md5_implCompressMB    = nullptr;\n+address StubRoutines::_sha1_implCompress     = nullptr;\n+address StubRoutines::_sha1_implCompressMB   = nullptr;\n+address StubRoutines::_sha256_implCompress   = nullptr;\n+address StubRoutines::_sha256_implCompressMB = nullptr;\n+address StubRoutines::_sha512_implCompress   = nullptr;\n+address StubRoutines::_sha512_implCompressMB = nullptr;\n+address StubRoutines::_sha3_implCompress     = nullptr;\n+address StubRoutines::_sha3_implCompressMB   = nullptr;\n+\n+address StubRoutines::_updateBytesCRC32 = nullptr;\n+address StubRoutines::_crc_table_adr =    nullptr;\n+\n+address StubRoutines::_crc32c_table_addr = nullptr;\n+address StubRoutines::_updateBytesCRC32C = nullptr;\n+address StubRoutines::_updateBytesAdler32 = nullptr;\n+\n+address StubRoutines::_multiplyToLen = nullptr;\n+address StubRoutines::_squareToLen = nullptr;\n+address StubRoutines::_mulAdd = nullptr;\n+address StubRoutines::_montgomeryMultiply = nullptr;\n+address StubRoutines::_montgomerySquare = nullptr;\n+address StubRoutines::_bigIntegerRightShiftWorker = nullptr;\n+address StubRoutines::_bigIntegerLeftShiftWorker = nullptr;\n+\n+address StubRoutines::_vectorizedMismatch = nullptr;\n+\n+address StubRoutines::_dexp = nullptr;\n+address StubRoutines::_dlog = nullptr;\n+address StubRoutines::_dlog10 = nullptr;\n+address StubRoutines::_dpow = nullptr;\n+address StubRoutines::_dsin = nullptr;\n+address StubRoutines::_dcos = nullptr;\n+address StubRoutines::_dlibm_sin_cos_huge = nullptr;\n+address StubRoutines::_dlibm_reduce_pi04l = nullptr;\n+address StubRoutines::_dlibm_tan_cot_huge = nullptr;\n+address StubRoutines::_dtan = nullptr;\n+\n+address StubRoutines::_load_inline_type_fields_in_regs = nullptr;\n+address StubRoutines::_store_inline_type_fields_to_buf = nullptr;\n+\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+\n+address StubRoutines::_cont_thaw          = nullptr;\n+address StubRoutines::_cont_returnBarrier = nullptr;\n+address StubRoutines::_cont_returnBarrierExc = nullptr;\n+\n+JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = nullptr;)\n+JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = nullptr;)\n@@ -214,1 +214,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -218,1 +218,1 @@\n-  if (_code1 == NULL) {\n+  if (_code1 == nullptr) {\n@@ -225,1 +225,1 @@\n-    if (_code1 == NULL) {\n+    if (_code1 == nullptr) {\n@@ -274,1 +274,1 @@\n-  if (_code3 == NULL) {\n+  if (_code3 == nullptr) {\n@@ -278,1 +278,1 @@\n-    if (_code3 == NULL) {\n+    if (_code3 == nullptr) {\n@@ -290,1 +290,1 @@\n-  if (_code2 == NULL) {\n+  if (_code2 == nullptr) {\n@@ -297,1 +297,1 @@\n-    if (_code2 == NULL) {\n+    if (_code2 == nullptr) {\n@@ -326,1 +326,1 @@\n-  if (_##type##_fill != NULL) {                                                              \\\n+  if (_##type##_fill != nullptr) {                                                              \\\n@@ -514,1 +514,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -518,1 +518,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -591,1 +591,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -600,1 +600,1 @@\n-  _ucm_entry = NULL;\n+  _ucm_entry = nullptr;\n@@ -602,1 +602,1 @@\n-    address err_exit_pc = NULL;\n+    address err_exit_pc = nullptr;\n@@ -604,1 +604,1 @@\n-      err_exit_pc = error_exit_pc != NULL ? error_exit_pc : UnsafeCopyMemory::common_exit_stub_pc();\n+      err_exit_pc = error_exit_pc != nullptr ? error_exit_pc : UnsafeCopyMemory::common_exit_stub_pc();\n@@ -606,2 +606,2 @@\n-    assert(err_exit_pc != NULL || continue_at_scope_end, \"error exit not set\");\n-    _ucm_entry = UnsafeCopyMemory::add_to_table(_cgen->assembler()->pc(), NULL, err_exit_pc);\n+    assert(err_exit_pc != nullptr || continue_at_scope_end, \"error exit not set\");\n+    _ucm_entry = UnsafeCopyMemory::add_to_table(_cgen->assembler()->pc(), nullptr, err_exit_pc);\n@@ -612,1 +612,1 @@\n-  if (_ucm_entry != NULL) {\n+  if (_ucm_entry != nullptr) {\n@@ -614,1 +614,1 @@\n-    if (_ucm_entry->error_exit_pc() == NULL) {\n+    if (_ucm_entry->error_exit_pc() == nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":110,"deletions":110,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-  UnsafeCopyMemory() : _start_pc(NULL), _end_pc(NULL), _error_exit_pc(NULL) {}\n+  UnsafeCopyMemory() : _start_pc(nullptr), _end_pc(nullptr), _error_exit_pc(nullptr) {}\n@@ -120,1 +120,1 @@\n-  UnsafeCopyMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc = NULL);\n+  UnsafeCopyMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc = nullptr);\n@@ -276,2 +276,2 @@\n-      (_code1 != NULL && _code1->blob_contains(addr)) ||\n-      (_code2 != NULL && _code2->blob_contains(addr)) ;\n+      (_code1 != nullptr && _code1->blob_contains(addr)) ||\n+      (_code2 != nullptr && _code2->blob_contains(addr)) ;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-  ObjectMonitor* prev = NULL;\n+  ObjectMonitor* prev = nullptr;\n@@ -132,2 +132,2 @@\n-  \/\/ The in-use list head can be NULL during the final audit.\n-  while (m != NULL) {\n+  \/\/ The in-use list head can be null during the final audit.\n+  while (m != nullptr) {\n@@ -146,2 +146,2 @@\n-      } while (next != NULL && next->is_being_async_deflated());\n-      if (prev == NULL) {\n+      } while (next != nullptr && next->is_being_async_deflated());\n+      if (prev == nullptr) {\n@@ -204,1 +204,1 @@\n-  char* bytes = NULL;                                                      \\\n+  char* bytes = nullptr;                                                      \\\n@@ -208,1 +208,1 @@\n-  if (klassname != NULL) {                                                 \\\n+  if (klassname != nullptr) {                                                 \\\n@@ -325,1 +325,1 @@\n-  if (obj == NULL) return false;  \/\/ slow-path for invalid obj\n+  if (obj == nullptr) return false;  \/\/ slow-path for invalid obj\n@@ -340,1 +340,1 @@\n-    if (mon->first_waiter() != NULL) {\n+    if (mon->first_waiter() != nullptr) {\n@@ -353,1 +353,1 @@\n-      } while (mon->first_waiter() != NULL && all);\n+      } while (mon->first_waiter() != nullptr && all);\n@@ -374,1 +374,1 @@\n-  if (obj == NULL) return false;       \/\/ Need to throw NPE\n+  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n@@ -388,1 +388,1 @@\n-    if (m->object_peek() == NULL) {\n+    if (m->object_peek() == nullptr) {\n@@ -406,1 +406,1 @@\n-    \/\/ non-NULL so this BasicLock is not seen as recursive nor as\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n@@ -415,1 +415,1 @@\n-    if (owner == NULL && m->try_set_owner_from(NULL, current) == NULL) {\n+    if (owner == nullptr && m->try_set_owner_from(nullptr, current) == nullptr) {\n@@ -451,1 +451,1 @@\n-    if (newline != NULL) {\n+    if (newline != nullptr) {\n@@ -516,1 +516,1 @@\n-      lock->set_displaced_header(markWord::from_pointer(NULL));\n+      lock->set_displaced_header(markWord::from_pointer(nullptr));\n@@ -552,1 +552,1 @@\n-      \/\/ If the displaced header is NULL, then this exit matches up with\n+      \/\/ If the displaced header is null, then this exit matches up with\n@@ -688,1 +688,1 @@\n-  if (_obj() != NULL) {\n+  if (_obj() != nullptr) {\n@@ -694,1 +694,1 @@\n-  if (_obj() != NULL) {\n+  if (_obj() != nullptr) {\n@@ -896,1 +896,1 @@\n-    ObjectMonitor* monitor = NULL;\n+    ObjectMonitor* monitor = nullptr;\n@@ -1033,1 +1033,1 @@\n-  address owner = NULL;\n+  address owner = nullptr;\n@@ -1047,1 +1047,1 @@\n-    assert(monitor != NULL, \"monitor should be non-null\");\n+    assert(monitor != nullptr, \"monitor should be non-null\");\n@@ -1051,2 +1051,2 @@\n-  if (owner != NULL) {\n-    \/\/ owning_thread_from_monitor_owner() may also return NULL here\n+  if (owner != nullptr) {\n+    \/\/ owning_thread_from_monitor_owner() may also return null here\n@@ -1061,1 +1061,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1080,1 +1080,1 @@\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != NULL) {\n+    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n@@ -1105,1 +1105,1 @@\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != NULL) {\n+    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n@@ -1221,1 +1221,1 @@\n-  assert(event != NULL, \"invariant\");\n+  assert(event != nullptr, \"invariant\");\n@@ -1342,2 +1342,2 @@\n-      \/\/ with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.\n-      m->set_owner_from(NULL, mark.locker());\n+      \/\/ with CAS.  That is, we can avoid the xchg-nullptr .... ST idiom.\n+      m->set_owner_from(nullptr, mark.locker());\n@@ -1377,1 +1377,1 @@\n-    \/\/ to inflate and then CAS() again to try to swing _owner from NULL to current.\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n@@ -1389,1 +1389,1 @@\n-      m = NULL;\n+      m = nullptr;\n@@ -1424,1 +1424,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1437,1 +1437,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1515,1 +1515,1 @@\n-  LogStream* ls = NULL;\n+  LogStream* ls = nullptr;\n@@ -1523,1 +1523,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1544,1 +1544,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n@@ -1558,1 +1558,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n@@ -1581,1 +1581,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1725,1 +1725,1 @@\n-  LogStream* ls = NULL;\n+  LogStream* ls = nullptr;\n@@ -1733,1 +1733,1 @@\n-  assert(ls != NULL, \"sanity check\");\n+  assert(ls != nullptr, \"sanity check\");\n@@ -1804,1 +1804,1 @@\n-                  \"have non-NULL _header field.\", p2i(n));\n+                  \"have non-null _header field.\", p2i(n));\n@@ -1808,1 +1808,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -1846,2 +1846,2 @@\n-                 mid->is_busy(), mark.hash() != 0, mid->owner() != NULL,\n-                 p2i(obj), obj == NULL ? \"\" : obj->klass()->external_name());\n+                 mid->is_busy(), mark.hash() != 0, mid->owner() != nullptr,\n+                 p2i(obj), obj == nullptr ? \"\" : obj->klass()->external_name());\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  if (scope() == NULL) return new StackValueCollection(0);\n+  if (scope() == nullptr) return new StackValueCollection(0);\n@@ -59,1 +59,1 @@\n-  if (scv_list == NULL) return new StackValueCollection(0);\n+  if (scv_list == nullptr) return new StackValueCollection(0);\n@@ -73,1 +73,1 @@\n-    if (list != NULL ) {\n+    if (list != nullptr ) {\n@@ -114,2 +114,2 @@\n-  jvmtiDeferredLocalVariableSet* locals = NULL;\n-  if (deferred != NULL ) {\n+  jvmtiDeferredLocalVariableSet* locals = nullptr;\n+  if (deferred != nullptr ) {\n@@ -130,1 +130,1 @@\n-  if (locals == NULL) {\n+  if (locals == nullptr) {\n@@ -150,1 +150,1 @@\n-  if (lcls != NULL) {\n+  if (lcls != nullptr) {\n@@ -164,1 +164,1 @@\n-  if (exprs != NULL) {\n+  if (exprs != nullptr) {\n@@ -177,1 +177,1 @@\n-  if (mtrs != NULL) {\n+  if (mtrs != nullptr) {\n@@ -190,1 +190,1 @@\n-  if (scope() == NULL) return new StackValueCollection(0);\n+  if (scope() == nullptr) return new StackValueCollection(0);\n@@ -192,1 +192,1 @@\n-  if (scv_list == NULL) return new StackValueCollection(0);\n+  if (scv_list == nullptr) return new StackValueCollection(0);\n@@ -206,1 +206,1 @@\n-    if (list != NULL ) {\n+    if (list != nullptr ) {\n@@ -244,1 +244,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -262,1 +262,1 @@\n-  if (monitors == NULL) {\n+  if (monitors == nullptr) {\n@@ -288,1 +288,1 @@\n-  if (list != NULL ) {\n+  if (list != nullptr ) {\n@@ -304,1 +304,1 @@\n-  _scope  = NULL;\n+  _scope  = nullptr;\n@@ -317,1 +317,1 @@\n-  guarantee(_scope != NULL, \"scope must be present\");\n+  guarantee(_scope != nullptr, \"scope must be present\");\n@@ -331,1 +331,1 @@\n-  if (scope() == NULL) return true;\n+  if (scope() == nullptr) return true;\n@@ -342,1 +342,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -359,1 +359,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -369,1 +369,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -379,1 +379,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -384,1 +384,1 @@\n-  return (scope()->objects() != NULL) || scope()->has_ea_local_in_scope();\n+  return (scope()->objects() != nullptr) || scope()->has_ea_local_in_scope();\n@@ -388,1 +388,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n@@ -398,1 +398,1 @@\n-  if (scope() == NULL) {\n+  if (scope() == nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-  VM_Operation() : _calling_thread(NULL) {}\n+  VM_Operation() : _calling_thread(nullptr) {}\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-  if (_deadlocks != NULL) {\n+  if (_deadlocks != nullptr) {\n@@ -190,1 +190,1 @@\n-    while (cycle != NULL) {\n+    while (cycle != nullptr) {\n@@ -207,1 +207,1 @@\n-  if (_out != NULL) {\n+  if (_out != nullptr) {\n@@ -209,1 +209,1 @@\n-    for (DeadlockCycle* cycle = _deadlocks; cycle != NULL; cycle = cycle->next()) {\n+    for (DeadlockCycle* cycle = _deadlocks; cycle != nullptr; cycle = cycle->next()) {\n@@ -230,1 +230,1 @@\n-  _threads = NULL;\n+  _threads = nullptr;\n@@ -304,1 +304,1 @@\n-      ThreadConcurrentLocks* tcl = NULL;\n+      ThreadConcurrentLocks* tcl = nullptr;\n@@ -316,1 +316,1 @@\n-      if (th() == NULL) {\n+      if (th() == nullptr) {\n@@ -326,1 +326,1 @@\n-      if (jt != NULL && !_result->t_list()->includes(jt)) {\n+      if (jt != nullptr && !_result->t_list()->includes(jt)) {\n@@ -330,1 +330,1 @@\n-        jt = NULL;\n+        jt = nullptr;\n@@ -332,1 +332,1 @@\n-      if (jt == NULL || \/* thread not alive *\/\n+      if (jt == nullptr || \/* thread not alive *\/\n@@ -335,1 +335,1 @@\n-        \/\/ add a NULL snapshot if skipped\n+        \/\/ add a nullptr snapshot if skipped\n@@ -339,1 +339,1 @@\n-      ThreadConcurrentLocks* tcl = NULL;\n+      ThreadConcurrentLocks* tcl = nullptr;\n@@ -356,1 +356,1 @@\n-Thread * volatile VM_Exit::_shutdown_thread = NULL;\n+Thread * volatile VM_Exit::_shutdown_thread = nullptr;\n@@ -412,1 +412,1 @@\n-          if (ct->compiler() == NULL || !ct->compiler()->is_jvmci()) {\n+          if (ct->compiler() == nullptr || !ct->compiler()->is_jvmci()) {\n@@ -482,1 +482,1 @@\n-  if (exit_hook != NULL) {\n+  if (exit_hook != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,2 +184,2 @@\n-  VM_FindDeadlocks(bool concurrent_locks) :  _concurrent_locks(concurrent_locks), _deadlocks(NULL), _out(NULL), _setter() {};\n-  VM_FindDeadlocks(outputStream* st) : _concurrent_locks(true), _deadlocks(NULL), _out(st) {};\n+  VM_FindDeadlocks(bool concurrent_locks) :  _concurrent_locks(concurrent_locks), _deadlocks(nullptr), _out(nullptr), _setter() {};\n+  VM_FindDeadlocks(outputStream* st) : _concurrent_locks(true), _deadlocks(nullptr), _out(st) {};\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,2 +240,2 @@\n-  nonstatic_field(InstanceKlass,               _init_state,                                   InstanceKlass::ClassState)             \\\n-  nonstatic_field(InstanceKlass,               _init_thread,                                  Thread*)                               \\\n+  volatile_nonstatic_field(InstanceKlass,      _init_state,                                   InstanceKlass::ClassState)             \\\n+  volatile_nonstatic_field(InstanceKlass,      _init_thread,                                  JavaThread*)                           \\\n@@ -385,6 +385,0 @@\n-  \/******\/                                                                                                                           \\\n-  \/* os *\/                                                                                                                           \\\n-  \/******\/                                                                                                                           \\\n-                                                                                                                                     \\\n-     static_field(os,                          _polling_page,                                 address)                               \\\n-                                                                                                                                     \\\n@@ -819,1 +813,1 @@\n-  nonstatic_field(ciMethod,                    _instructions_size,                            int)                                   \\\n+  nonstatic_field(ciMethod,                    _inline_instructions_size,                     int)                                   \\\n@@ -3084,1 +3078,1 @@\n-    while (types->typeName != NULL) {\n+    while (types->typeName != nullptr) {\n@@ -3105,1 +3099,1 @@\n-  const char* start = NULL;\n+  const char* start = nullptr;\n@@ -3111,1 +3105,1 @@\n-  if (start != NULL) {\n+  if (start != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-    DCmd* cmd = NULL;\n+    DCmd* cmd = nullptr;\n@@ -193,1 +193,1 @@\n-    if (factory != NULL) {\n+    if (factory != nullptr) {\n@@ -199,2 +199,2 @@\n-      if(p._class != NULL) {\n-        if(p._action != NULL) {\n+      if(p._class != nullptr) {\n+        if(p._action != nullptr) {\n@@ -202,1 +202,1 @@\n-                  p._class, p._name == NULL ? \"null\" : p._name, p._action);\n+                  p._class, p._name == nullptr ? \"null\" : p._name, p._action);\n@@ -205,1 +205,1 @@\n-                  p._class, p._name == NULL ? \"null\" : p._name);\n+                  p._class, p._name == nullptr ? \"null\" : p._name);\n@@ -210,1 +210,1 @@\n-      if (cmd != NULL) {\n+      if (cmd != nullptr) {\n@@ -270,2 +270,2 @@\n-  const char* val = NULL;\n-  if (_value.value() != NULL) {\n+  const char* val = nullptr;\n+  if (_value.value() != nullptr) {\n@@ -302,1 +302,1 @@\n-  if (_libpath.value() == NULL) {\n+  if (_libpath.value() == nullptr) {\n@@ -308,1 +308,1 @@\n-  bool is_java_agent = (suffix != NULL) && (strncmp(\".jar\", suffix, 4) == 0);\n+  bool is_java_agent = (suffix != nullptr) && (strncmp(\".jar\", suffix, 4) == 0);\n@@ -311,1 +311,1 @@\n-    if (_option.value() == NULL) {\n+    if (_option.value() == nullptr) {\n@@ -322,1 +322,1 @@\n-      if (opt == NULL) {\n+      if (opt == nullptr) {\n@@ -460,1 +460,1 @@\n-  assert(count_res != NULL && name_res != NULL, \"Unexpected layout of FinalizerHistogramEntry\");\n+  assert(count_res != nullptr && name_res != nullptr, \"Unexpected layout of FinalizerHistogramEntry\");\n@@ -805,1 +805,1 @@\n-  if (str != NULL) {\n+  if (str != nullptr) {\n@@ -867,2 +867,2 @@\n-  _log(\"log\", \"Name of log to be printed. If omitted, all logs are printed.\", \"STRING\", false, NULL),\n-  _max(\"max\", \"Maximum number of events to be printed (newest first). If omitted, all events are printed.\", \"STRING\", false, NULL)\n+  _log(\"log\", \"Name of log to be printed. If omitted, all logs are printed.\", \"STRING\", false, nullptr),\n+  _max(\"max\", \"Maximum number of events to be printed (newest first). If omitted, all events are printed.\", \"STRING\", false, nullptr)\n@@ -877,2 +877,2 @@\n-  if (max_value != NULL) {\n-    char* endptr = NULL;\n+  if (max_value != nullptr) {\n+    char* endptr = nullptr;\n@@ -886,1 +886,1 @@\n-  if (log_name != NULL) {\n+  if (log_name != nullptr) {\n@@ -1031,1 +1031,1 @@\n-  if (file != NULL) {\n+  if (file != nullptr) {\n@@ -1057,1 +1057,1 @@\n-static debugInit_startDebuggingViaCommandPtr dvc_start_ptr = NULL;\n+static debugInit_startDebuggingViaCommandPtr dvc_start_ptr = nullptr;\n@@ -1060,2 +1060,2 @@\n-  char const* transport = NULL;\n-  char const* addr = NULL;\n+  char const* transport = nullptr;\n+  char const* addr = nullptr;\n@@ -1069,2 +1069,2 @@\n-    for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n-      if ((strcmp(\"jdwp\", agent->name()) == 0) && (dvc_start_ptr == NULL)) {\n+    for (AgentLibrary* agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n+      if ((strcmp(\"jdwp\", agent->name()) == 0) && (dvc_start_ptr == nullptr)) {\n@@ -1081,1 +1081,1 @@\n-  if (error != NULL) {\n+  if (error != nullptr) {\n@@ -1103,2 +1103,2 @@\n-  ThreadDumpToFileDCmd* dcmd = new ThreadDumpToFileDCmd(NULL, false);\n-  if (dcmd != NULL) {\n+  ThreadDumpToFileDCmd* dcmd = new ThreadDumpToFileDCmd(nullptr, false);\n+  if (dcmd != nullptr) {\n@@ -1113,1 +1113,1 @@\n-  bool json = (_format.value() != NULL) && (strcmp(_format.value(), \"json\") == 0);\n+  bool json = (_format.value() != nullptr) && (strcmp(_format.value(), \"json\") == 0);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -126,1 +126,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -148,1 +148,1 @@\n-                        \"control\", NULL};\n+                        \"control\", nullptr};\n@@ -166,1 +166,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -187,1 +187,1 @@\n-                        \"control\", NULL};\n+                        \"control\", nullptr};\n@@ -209,1 +209,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -240,1 +240,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -284,1 +284,1 @@\n-      \"monitor\", NULL};\n+      \"monitor\", nullptr};\n@@ -303,1 +303,1 @@\n-      \"monitor\", NULL};\n+      \"monitor\", nullptr};\n@@ -332,1 +332,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -357,1 +357,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -383,1 +383,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -432,1 +432,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -456,1 +456,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -564,1 +564,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -586,1 +586,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -607,1 +607,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -628,1 +628,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -648,1 +648,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -673,1 +673,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -694,1 +694,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -714,1 +714,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -736,1 +736,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -756,1 +756,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -821,1 +821,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -843,1 +843,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -865,1 +865,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -887,1 +887,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -907,1 +907,1 @@\n-    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", NULL };\n+    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", nullptr };\n@@ -931,1 +931,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n@@ -956,1 +956,1 @@\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", NULL};\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -515,1 +515,1 @@\n-    _buffer(NULL),\n+    _buffer(nullptr),\n@@ -546,1 +546,1 @@\n-    _buffer = NULL;\n+    _buffer = nullptr;\n@@ -759,1 +759,1 @@\n-  ParWriterBufferQueue() : _head(NULL), _tail(NULL), _length(0) { }\n+  ParWriterBufferQueue() : _head(nullptr), _tail(nullptr), _length(0) { }\n@@ -762,2 +762,2 @@\n-    if (_head == NULL) {\n-      assert(is_empty() && _tail == NULL, \"Sanity check\");\n+    if (_head == nullptr) {\n+      assert(is_empty() && _tail == nullptr, \"Sanity check\");\n@@ -766,1 +766,1 @@\n-      assert ((_tail->_next == NULL && _tail->_buffer != NULL), \"Buffer queue is polluted\");\n+      assert ((_tail->_next == nullptr && _tail->_buffer != nullptr), \"Buffer queue is polluted\");\n@@ -771,1 +771,1 @@\n-    assert(_tail->_next == NULL, \"Buffer queue is polluted\");\n+    assert(_tail->_next == nullptr, \"Buffer queue is polluted\");\n@@ -775,1 +775,1 @@\n-    if (_head == NULL)  return NULL;\n+    if (_head == nullptr)  return nullptr;\n@@ -777,1 +777,1 @@\n-    assert (entry->_buffer != NULL, \"polluted buffer in writer list\");\n+    assert (entry->_buffer != nullptr, \"polluted buffer in writer list\");\n@@ -779,2 +779,2 @@\n-    if (_head == NULL) {\n-      _tail = NULL;\n+    if (_head == nullptr) {\n+      _tail = nullptr;\n@@ -782,1 +782,1 @@\n-    entry->_next = NULL;\n+    entry->_next = nullptr;\n@@ -830,1 +830,1 @@\n-    _buffer_base(NULL),\n+    _buffer_base(nullptr),\n@@ -837,1 +837,1 @@\n-     assert(_buffer_queue != NULL, \"Sanity check\");\n+     assert(_buffer_queue != nullptr, \"Sanity check\");\n@@ -840,1 +840,1 @@\n-     if (_buffer_base != NULL) {\n+     if (_buffer_base != nullptr) {\n@@ -842,1 +842,1 @@\n-       _buffer_base = NULL;\n+       _buffer_base = nullptr;\n@@ -845,1 +845,1 @@\n-     _buffer_queue = NULL;\n+     _buffer_queue = nullptr;\n@@ -850,1 +850,1 @@\n-  char const* error() const override    { return _err == NULL ? _backend_ptr->error() : _err; }\n+  char const* error() const override    { return _err == nullptr ? _backend_ptr->error() : _err; }\n@@ -853,1 +853,1 @@\n-    assert(_lock == NULL, \"ParDumpWriter lock must be initialized only once\");\n+    assert(_lock == nullptr, \"ParDumpWriter lock must be initialized only once\");\n@@ -858,1 +858,1 @@\n-    assert(_lock != NULL, \"ParDumpWriter lock is not initialized\");\n+    assert(_lock != nullptr, \"ParDumpWriter lock is not initialized\");\n@@ -860,1 +860,1 @@\n-    _lock = NULL;\n+    _lock = nullptr;\n@@ -889,2 +889,2 @@\n-    assert(_buffer_queue != NULL, \"Internal buffer queue is not ready when allocate internal buffer\");\n-    assert(_buffer == NULL && _buffer_base == NULL, \"current buffer must be NULL before allocate\");\n+    assert(_buffer_queue != nullptr, \"Internal buffer queue is not ready when allocate internal buffer\");\n+    assert(_buffer == nullptr && _buffer_base == nullptr, \"current buffer must be null before allocate\");\n@@ -892,1 +892,1 @@\n-    if (_buffer == NULL) {\n+    if (_buffer == nullptr) {\n@@ -902,1 +902,1 @@\n-    if ((new_error != NULL) && (_err == NULL)) {\n+    if ((new_error != nullptr) && (_err == nullptr)) {\n@@ -926,1 +926,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -932,1 +932,1 @@\n-    entry->_next = NULL;\n+    entry->_next = nullptr;\n@@ -935,1 +935,1 @@\n-    _buffer_base =_buffer = NULL;\n+    _buffer_base =_buffer = nullptr;\n@@ -940,1 +940,1 @@\n-    assert(entry != NULL && entry->_buffer != NULL, \"Invalid entry to reclaim\");\n+    assert(entry != nullptr && entry->_buffer != nullptr, \"Invalid entry to reclaim\");\n@@ -942,1 +942,1 @@\n-    entry->_buffer = NULL;\n+    entry->_buffer = nullptr;\n@@ -965,1 +965,1 @@\n-      entry = NULL;\n+      entry = nullptr;\n@@ -974,1 +974,1 @@\n-      _buffer_base = _buffer = NULL;\n+      _buffer_base = _buffer = nullptr;\n@@ -981,1 +981,1 @@\n-Monitor* ParDumpWriter::_lock = NULL;\n+Monitor* ParDumpWriter::_lock = nullptr;\n@@ -1049,1 +1049,1 @@\n-    if (o != NULL && o->klass()->java_mirror() == NULL) {\n+    if (o != nullptr && o->klass()->java_mirror() == nullptr) {\n@@ -1052,1 +1052,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1158,1 +1158,1 @@\n-      if (o != NULL && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == NULL) {\n+      if (o != nullptr && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == nullptr) {\n@@ -1165,1 +1165,1 @@\n-      assert(oopDesc::is_oop_or_null(o), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(o));\n+      assert(oopDesc::is_oop_or_null(o), \"Expected an oop or nullptr at \" PTR_FORMAT, p2i(o));\n@@ -1249,1 +1249,1 @@\n-  if (resolved_references != NULL) {\n+  if (resolved_references != nullptr) {\n@@ -1256,1 +1256,1 @@\n-    while (prev != NULL && prev->constants()->resolved_references_or_null() != NULL) {\n+    while (prev != nullptr && prev->constants()->resolved_references_or_null() != nullptr) {\n@@ -1288,1 +1288,1 @@\n-  if (resolved_references != NULL) {\n+  if (resolved_references != nullptr) {\n@@ -1295,1 +1295,1 @@\n-    while (prev != NULL && prev->constants()->resolved_references_or_null() != NULL) {\n+    while (prev != nullptr && prev->constants()->resolved_references_or_null() != nullptr) {\n@@ -1437,2 +1437,2 @@\n-  if (java_super == NULL) {\n-    writer->write_objectID(oop(NULL));\n+  if (java_super == nullptr) {\n+    writer->write_objectID(oop(nullptr));\n@@ -1448,2 +1448,2 @@\n-  writer->write_objectID(oop(NULL));\n-  writer->write_objectID(oop(NULL));\n+  writer->write_objectID(oop(nullptr));\n+  writer->write_objectID(oop(nullptr));\n@@ -1470,1 +1470,1 @@\n-  InstanceKlass* ik = NULL; \/\/ bottom class for object arrays, NULL for primitive type arrays\n+  InstanceKlass* ik = nullptr; \/\/ bottom class for object arrays, null for primitive type arrays\n@@ -1473,1 +1473,1 @@\n-    assert(bk != NULL, \"checking\");\n+    assert(bk != nullptr, \"checking\");\n@@ -1486,1 +1486,1 @@\n-  assert(java_super != NULL, \"checking\");\n+  assert(java_super != nullptr, \"checking\");\n@@ -1489,3 +1489,3 @@\n-  writer->write_objectID(ik == NULL ? oop(NULL) : ik->class_loader());\n-  writer->write_objectID(ik == NULL ? oop(NULL) : ik->signers());\n-  writer->write_objectID(ik == NULL ? oop(NULL) : ik->protection_domain());\n+  writer->write_objectID(ik == nullptr ? oop(nullptr) : ik->class_loader());\n+  writer->write_objectID(ik == nullptr ? oop(nullptr) : ik->signers());\n+  writer->write_objectID(ik == nullptr ? oop(nullptr) : ik->protection_domain());\n@@ -1493,2 +1493,2 @@\n-  writer->write_objectID(oop(NULL));    \/\/ reserved\n-  writer->write_objectID(oop(NULL));\n+  writer->write_objectID(oop(nullptr));    \/\/ reserved\n+  writer->write_objectID(oop(nullptr));\n@@ -1554,1 +1554,1 @@\n-    if (o != NULL && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == NULL) {\n+    if (o != nullptr && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == nullptr) {\n@@ -2039,1 +2039,1 @@\n-  if (o != NULL) {\n+  if (o != nullptr) {\n@@ -2069,1 +2069,1 @@\n-  if (o == NULL) return;\n+  if (o == nullptr) return;\n@@ -2113,1 +2113,1 @@\n-    HeapDumpLargeObjectListElem(oop obj) : _obj(obj), _next(NULL) { }\n+    HeapDumpLargeObjectListElem(oop obj) : _obj(obj), _next(nullptr) { }\n@@ -2121,1 +2121,1 @@\n-  HeapDumpLargeObjectList() : _head(NULL) { }\n+  HeapDumpLargeObjectList() : _head(nullptr) { }\n@@ -2124,1 +2124,1 @@\n-    assert (obj != NULL, \"sanity check\");\n+    assert (obj != nullptr, \"sanity check\");\n@@ -2126,1 +2126,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -2130,1 +2130,1 @@\n-    assert (entry->_obj != NULL, \"sanity check\");\n+    assert (entry->_obj != nullptr, \"sanity check\");\n@@ -2143,2 +2143,2 @@\n-    if (_head == NULL) {\n-      return NULL;\n+    if (_head == nullptr) {\n+      return nullptr;\n@@ -2148,1 +2148,1 @@\n-    assert (entry != NULL, \"illegal larger object list entry\");\n+    assert (entry != nullptr, \"illegal larger object list entry\");\n@@ -2151,1 +2151,1 @@\n-    assert (ret != NULL, \"illegal oop pointer\");\n+    assert (ret != nullptr, \"illegal oop pointer\");\n@@ -2156,1 +2156,1 @@\n-    while (_head !=  NULL) {\n+    while (_head !=  nullptr) {\n@@ -2162,1 +2162,1 @@\n-    return _head == NULL;\n+    return _head == nullptr;\n@@ -2179,1 +2179,1 @@\n-  HeapObjectDumper(AbstractDumpWriter* writer, HeapDumpLargeObjectList* list = NULL) {\n+  HeapObjectDumper(AbstractDumpWriter* writer, HeapDumpLargeObjectList* list = nullptr) {\n@@ -2196,1 +2196,1 @@\n-  if (DumperSupport::mask_dormant_archived_object(o) == NULL) {\n+  if (DumperSupport::mask_dormant_archived_object(o) == nullptr) {\n@@ -2203,1 +2203,1 @@\n-  if (_list != NULL && is_large(o)) {\n+  if (_list != nullptr && is_large(o)) {\n@@ -2350,1 +2350,1 @@\n-    assert (_dumper_controller == NULL, \"dumper controller must be NULL\");\n+    assert (_dumper_controller == nullptr, \"dumper controller must be null\");\n@@ -2380,2 +2380,2 @@\n-  static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, \"Error\"); return _global_dumper; }\n-  static DumpWriter* writer()            {  assert(_global_writer != NULL, \"Error\"); return _global_writer; }\n+  static VM_HeapDumper* dumper()         {  assert(_global_dumper != nullptr, \"Error\"); return _global_dumper; }\n+  static DumpWriter* writer()            {  assert(_global_writer != nullptr, \"Error\"); return _global_writer; }\n@@ -2383,1 +2383,1 @@\n-    assert(_global_dumper == NULL, \"Error\");\n+    assert(_global_dumper == nullptr, \"Error\");\n@@ -2387,1 +2387,1 @@\n-    assert(_global_writer == NULL, \"Error\");\n+    assert(_global_writer == nullptr, \"Error\");\n@@ -2390,2 +2390,2 @@\n-  void clear_global_dumper() { _global_dumper = NULL; }\n-  void clear_global_writer() { _global_writer = NULL; }\n+  void clear_global_dumper() { _global_dumper = nullptr; }\n+  void clear_global_writer() { _global_writer = nullptr; }\n@@ -2425,1 +2425,1 @@\n-    _stack_traces = NULL;\n+    _stack_traces = nullptr;\n@@ -2428,2 +2428,2 @@\n-    _dumper_controller = NULL;\n-    _poi = NULL;\n+    _dumper_controller = nullptr;\n+    _poi = nullptr;\n@@ -2440,2 +2440,2 @@\n-      _oome_thread = NULL;\n-      _oome_constructor = NULL;\n+      _oome_thread = nullptr;\n+      _oome_constructor = nullptr;\n@@ -2446,1 +2446,1 @@\n-    if (_stack_traces != NULL) {\n+    if (_stack_traces != nullptr) {\n@@ -2452,1 +2452,1 @@\n-    if (_dumper_controller != NULL) {\n+    if (_dumper_controller != nullptr) {\n@@ -2454,1 +2454,1 @@\n-      _dumper_controller = NULL;\n+      _dumper_controller = nullptr;\n@@ -2465,2 +2465,2 @@\n-VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;\n-DumpWriter*    VM_HeapDumper::_global_writer = NULL;\n+VM_HeapDumper* VM_HeapDumper::_global_dumper = nullptr;\n+DumpWriter*    VM_HeapDumper::_global_writer = nullptr;\n@@ -2524,1 +2524,1 @@\n-  assert(threadObj != NULL, \"sanity check\");\n+  assert(threadObj != nullptr, \"sanity check\");\n@@ -2540,1 +2540,1 @@\n-    frame* last_entry_frame = NULL;\n+    frame* last_entry_frame = nullptr;\n@@ -2543,1 +2543,1 @@\n-    if (java_thread == _oome_thread && _oome_constructor != NULL) {\n+    if (java_thread == _oome_thread && _oome_constructor != nullptr) {\n@@ -2546,1 +2546,1 @@\n-    while (vf != NULL) {\n+    while (vf != nullptr) {\n@@ -2558,1 +2558,1 @@\n-              if (o != NULL) {\n+              if (o != nullptr) {\n@@ -2572,1 +2572,1 @@\n-               if (o != NULL) {\n+               if (o != nullptr) {\n@@ -2588,1 +2588,1 @@\n-            if (last_entry_frame != NULL) {\n+            if (last_entry_frame != nullptr) {\n@@ -2597,1 +2597,1 @@\n-        last_entry_frame = NULL;\n+        last_entry_frame = nullptr;\n@@ -2603,1 +2603,1 @@\n-        assert(fr != NULL, \"sanity check\");\n+        assert(fr != nullptr, \"sanity check\");\n@@ -2685,1 +2685,1 @@\n-  if (workers == NULL) {\n+  if (workers == nullptr) {\n@@ -2696,1 +2696,1 @@\n-      _poi = NULL;\n+      _poi = nullptr;\n@@ -2764,1 +2764,1 @@\n-    \/\/ These should be classes in the NULL class loader data, and not all classes\n+    \/\/ These should be classes in the null class loader data, and not all classes\n@@ -2836,1 +2836,1 @@\n-    if (threadObj != NULL && !thread->is_exiting() && !thread->is_hidden_from_external_view()) {\n+    if (threadObj != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view()) {\n@@ -2852,1 +2852,1 @@\n-      if (thread == _oome_thread && _oome_constructor != NULL) {\n+      if (thread == _oome_thread && _oome_constructor != nullptr) {\n@@ -2890,1 +2890,1 @@\n-  assert(path != NULL && strlen(path) > 0, \"path missing\");\n+  assert(path != nullptr && strlen(path) > 0, \"path missing\");\n@@ -2893,1 +2893,1 @@\n-  if (out != NULL) {\n+  if (out != nullptr) {\n@@ -2900,1 +2900,1 @@\n-  AbstractCompressor* compressor = NULL;\n+  AbstractCompressor* compressor = nullptr;\n@@ -2905,1 +2905,1 @@\n-    if (compressor == NULL) {\n+    if (compressor == nullptr) {\n@@ -2913,1 +2913,1 @@\n-  if (writer.error() != NULL) {\n+  if (writer.error() != nullptr) {\n@@ -2915,1 +2915,1 @@\n-    if (out != NULL) {\n+    if (out != nullptr) {\n@@ -2917,1 +2917,1 @@\n-        (error() != NULL) ? error() : \"reason unknown\");\n+        (error() != nullptr) ? error() : \"reason unknown\");\n@@ -2935,1 +2935,1 @@\n-  if (error() == NULL) {\n+  if (error() == nullptr) {\n@@ -2940,0 +2940,2 @@\n+    event.set_overwrite(overwrite);\n+    event.set_compression(compression);\n@@ -2941,0 +2943,2 @@\n+  } else {\n+    log_debug(cds, heap)(\"Error %s while dumping heap\", error());\n@@ -2944,1 +2948,1 @@\n-  if (out != NULL) {\n+  if (out != nullptr) {\n@@ -2946,1 +2950,1 @@\n-    if (error() == NULL) {\n+    if (error() == nullptr) {\n@@ -2954,1 +2958,1 @@\n-  return (writer.error() == NULL) ? 0 : -1;\n+  return (writer.error() == nullptr) ? 0 : -1;\n@@ -2962,1 +2966,1 @@\n-  set_error(NULL);\n+  set_error(nullptr);\n@@ -2966,1 +2970,1 @@\n-\/\/ returns the error string (resource allocated), or NULL\n+\/\/ returns the error string (resource allocated), or null\n@@ -2968,1 +2972,1 @@\n-  if (error() != NULL) {\n+  if (error() != nullptr) {\n@@ -2973,1 +2977,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2979,1 +2983,1 @@\n-  if (_error != NULL) {\n+  if (_error != nullptr) {\n@@ -2982,2 +2986,2 @@\n-  if (error == NULL) {\n-    _error = NULL;\n+  if (error == nullptr) {\n+    _error = nullptr;\n@@ -2986,1 +2990,1 @@\n-    assert(_error != NULL, \"allocation failure\");\n+    assert(_error != nullptr, \"allocation failure\");\n@@ -3021,1 +3025,1 @@\n-                      (HeapDumpPath == NULL ? 0 : strlen(HeapDumpPath)) +\n+                      (HeapDumpPath == nullptr ? 0 : strlen(HeapDumpPath)) +\n@@ -3030,1 +3034,1 @@\n-    if (HeapDumpPath == NULL || HeapDumpPath[0] == '\\0') {\n+    if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n@@ -3036,1 +3040,1 @@\n-      if (dir == NULL) {\n+      if (dir == nullptr) {\n@@ -3060,1 +3064,1 @@\n-    if (my_path == NULL) {\n+    if (my_path == nullptr) {\n@@ -3069,1 +3073,1 @@\n-    if (my_path == NULL) {\n+    if (my_path == nullptr) {\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":130,"deletions":126,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-  bool has_pending_exception() const             { return _pending_exception != NULL; }\n+  bool has_pending_exception() const             { return _pending_exception != nullptr; }\n@@ -97,2 +97,2 @@\n-  ThreadShadow() : _pending_exception(NULL),\n-                   _exception_file(NULL), _exception_line(0) {}\n+  ThreadShadow() : _pending_exception(nullptr),\n+                   _exception_file(nullptr), _exception_line(0) {}\n@@ -127,1 +127,1 @@\n-  static void _throw(JavaThread* thread, const char* file, int line, Handle exception, const char* msg = NULL);\n+  static void _throw(JavaThread* thread, const char* file, int line, Handle exception, const char* msg = nullptr);\n@@ -187,3 +187,3 @@\n-  static void debug_check_abort(Handle exception, const char* message = NULL);\n-  static void debug_check_abort_helper(Handle exception, const char* message = NULL);\n-  static void debug_check_abort(const char *value_string, const char* message = NULL);\n+  static void debug_check_abort(Handle exception, const char* message = nullptr);\n+  static void debug_check_abort_helper(Handle exception, const char* message = nullptr);\n+  static void debug_check_abort(const char *value_string, const char* message = nullptr);\n@@ -228,1 +228,1 @@\n-#define CHECK_NULL                               CHECK_(NULL)\n+#define CHECK_NULL                               CHECK_(nullptr)\n@@ -237,1 +237,1 @@\n-#define CHECK_AND_CLEAR_NULL                    CHECK_AND_CLEAR_(NULL)\n+#define CHECK_AND_CLEAR_NULL                    CHECK_AND_CLEAR_(nullptr)\n@@ -247,1 +247,1 @@\n-#define CHECK_AND_CLEAR_NONASYNC_NULL           CHECK_AND_CLEAR_NONASYNC_(NULL)\n+#define CHECK_AND_CLEAR_NONASYNC_NULL           CHECK_AND_CLEAR_NONASYNC_(nullptr)\n@@ -265,1 +265,1 @@\n-  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, NULL); return;  }\n+  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, nullptr); return;  }\n@@ -286,1 +286,1 @@\n-  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, NULL); return result; }\n+  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, nullptr); return result; }\n@@ -311,1 +311,1 @@\n-#define THROW_MSG_CAUSE_NULL(name, message, cause) THROW_MSG_CAUSE_(name, message, cause, NULL)\n+#define THROW_MSG_CAUSE_NULL(name, message, cause) THROW_MSG_CAUSE_(name, message, cause, nullptr)\n@@ -313,2 +313,2 @@\n-#define THROW_NULL(name)                    THROW_(name, NULL)\n-#define THROW_MSG_NULL(name, message)       THROW_MSG_(name, message, NULL)\n+#define THROW_NULL(name)                    THROW_(name, nullptr)\n+#define THROW_MSG_NULL(name, message)       THROW_MSG_(name, message, nullptr)\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,5 +81,5 @@\n-  assert(min_intx ==  (intx)CONST64(0x8000000000000000), \"correct constant\");\n-  assert(max_intx ==  CONST64(0x7FFFFFFFFFFFFFFF), \"correct constant\");\n-  assert(max_uintx == CONST64(0xFFFFFFFFFFFFFFFF), \"correct constant\");\n-  assert( 8 == sizeof( intx),      \"wrong size for basic type\");\n-  assert( 8 == sizeof( jobject),   \"wrong size for basic type\");\n+  static_assert(min_intx ==  (intx)CONST64(0x8000000000000000), \"correct constant\");\n+  static_assert(max_intx ==  CONST64(0x7FFFFFFFFFFFFFFF), \"correct constant\");\n+  static_assert(max_uintx == CONST64(0xFFFFFFFFFFFFFFFF), \"correct constant\");\n+  static_assert( 8 == sizeof( intx),      \"wrong size for basic type\");\n+  static_assert( 8 == sizeof( jobject),   \"wrong size for basic type\");\n@@ -87,5 +87,5 @@\n-  assert(min_intx ==  (intx)0x80000000,  \"correct constant\");\n-  assert(max_intx ==  0x7FFFFFFF,  \"correct constant\");\n-  assert(max_uintx == 0xFFFFFFFF,  \"correct constant\");\n-  assert( 4 == sizeof( intx),      \"wrong size for basic type\");\n-  assert( 4 == sizeof( jobject),   \"wrong size for basic type\");\n+  static_assert(min_intx ==  (intx)0x80000000,  \"correct constant\");\n+  static_assert(max_intx ==  0x7FFFFFFF,  \"correct constant\");\n+  static_assert(max_uintx == 0xFFFFFFFF,  \"correct constant\");\n+  static_assert( 4 == sizeof( intx),      \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( jobject),   \"wrong size for basic type\");\n@@ -93,17 +93,17 @@\n-  assert( (~max_juint) == 0,  \"max_juint has all its bits\");\n-  assert( (~max_uintx) == 0,  \"max_uintx has all its bits\");\n-  assert( (~max_julong) == 0, \"max_julong has all its bits\");\n-  assert( 1 == sizeof( jbyte),     \"wrong size for basic type\");\n-  assert( 2 == sizeof( jchar),     \"wrong size for basic type\");\n-  assert( 2 == sizeof( jshort),    \"wrong size for basic type\");\n-  assert( 4 == sizeof( juint),     \"wrong size for basic type\");\n-  assert( 4 == sizeof( jint),      \"wrong size for basic type\");\n-  assert( 1 == sizeof( jboolean),  \"wrong size for basic type\");\n-  assert( 8 == sizeof( jlong),     \"wrong size for basic type\");\n-  assert( 4 == sizeof( jfloat),    \"wrong size for basic type\");\n-  assert( 8 == sizeof( jdouble),   \"wrong size for basic type\");\n-  assert( 1 == sizeof( u1),        \"wrong size for basic type\");\n-  assert( 2 == sizeof( u2),        \"wrong size for basic type\");\n-  assert( 4 == sizeof( u4),        \"wrong size for basic type\");\n-  assert(wordSize == BytesPerWord, \"should be the same since they're used interchangeably\");\n-  assert(wordSize == HeapWordSize, \"should be the same since they're also used interchangeably\");\n+  static_assert( (~max_juint) == 0,  \"max_juint has all its bits\");\n+  static_assert( (~max_uintx) == 0,  \"max_uintx has all its bits\");\n+  static_assert( (~max_julong) == 0, \"max_julong has all its bits\");\n+  static_assert( 1 == sizeof( jbyte),     \"wrong size for basic type\");\n+  static_assert( 2 == sizeof( jchar),     \"wrong size for basic type\");\n+  static_assert( 2 == sizeof( jshort),    \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( juint),     \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( jint),      \"wrong size for basic type\");\n+  static_assert( 1 == sizeof( jboolean),  \"wrong size for basic type\");\n+  static_assert( 8 == sizeof( jlong),     \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( jfloat),    \"wrong size for basic type\");\n+  static_assert( 8 == sizeof( jdouble),   \"wrong size for basic type\");\n+  static_assert( 1 == sizeof( u1),        \"wrong size for basic type\");\n+  static_assert( 2 == sizeof( u2),        \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( u4),        \"wrong size for basic type\");\n+  static_assert(wordSize == BytesPerWord, \"should be the same since they're used interchangeably\");\n+  static_assert(wordSize == HeapWordSize, \"should be the same since they're also used interchangeably\");\n@@ -159,5 +159,5 @@\n-  assert(is_power_of_2(sizeof(juint)), \"juint must be power of 2\");\n-  assert(is_power_of_2(HeapWordSize), \"HeapWordSize must be power of 2\");\n-  assert((size_t)HeapWordSize >= sizeof(juint),\n-         \"HeapWord should be at least as large as juint\");\n-  assert(sizeof(NULL) == sizeof(char*), \"NULL must be same size as pointer\");\n+  static_assert(is_power_of_2(sizeof(juint)), \"juint must be power of 2\");\n+  static_assert(is_power_of_2(HeapWordSize), \"HeapWordSize must be power of 2\");\n+  static_assert((size_t)HeapWordSize >= sizeof(juint),\n+                \"HeapWord should be at least as large as juint\");\n+  static_assert(sizeof(NULL) == sizeof(char*), \"NULL must be same size as pointer\");\n@@ -223,1 +223,1 @@\n-  NULL, NULL, NULL, NULL,\n+  nullptr, nullptr, nullptr, nullptr,\n@@ -258,1 +258,1 @@\n-    if (type2name_tab[t] != NULL && 0 == strcmp(type2name_tab[t], name))\n+    if (type2name_tab[t] != nullptr && 0 == strcmp(type2name_tab[t], name))\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+#include <cstdint>\n@@ -124,0 +125,1 @@\n+#define INT64_PLUS_FORMAT        \"%+\"         PRId64\n@@ -191,0 +193,1 @@\n+FORBID_C_FUNCTION(int sprintf(char*, const char*, ...), \"use os::snprintf\");\n@@ -527,0 +530,7 @@\n+\/\/ Additional Java basic types\n+\n+typedef uint8_t  jubyte;\n+typedef uint16_t jushort;\n+typedef uint32_t juint;\n+typedef uint64_t julong;\n+\n@@ -1071,1 +1081,0 @@\n-#define       badOop            (cast_to_oop(::badOopVal))\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -325,15 +325,0 @@\n-  void truncate_to(int idx) {\n-    for (int i = 0, j = idx; j < length(); i++, j++) {\n-      at_put(i, at(j));\n-    }\n-    trunc_to(length() - idx);\n-  }\n-\n-  void truncate_from(int idx) {\n-    trunc_to(idx);\n-  }\n-\n-  size_t data_size_in_bytes() const {\n-    return _len * sizeof(E);\n-  }\n-\n@@ -516,1 +501,1 @@\n-  if (this->_data != NULL) {\n+  if (this->_data != nullptr) {\n@@ -525,1 +510,1 @@\n-  expand_to(next_power_of_2((uint32_t)j));\n+  expand_to(next_power_of_2(j));\n@@ -796,1 +781,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -853,1 +838,1 @@\n-  GrowableArrayIterator() : _array(NULL), _position(0) { }\n+  GrowableArrayIterator() : _array(nullptr), _position(0) { }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  for (char* dst = string; *dst && (dst = strstr(dst, from)) != NULL;) {\n+  for (char* dst = string; *dst && (dst = strstr(dst, from)) != nullptr;) {\n@@ -52,1 +52,1 @@\n-  assert(str1 != NULL && str2 != NULL, \"sanity\");\n+  assert(str1 != nullptr && str2 != nullptr, \"sanity\");\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import jdk.internal.util.ByteArray;\n@@ -1103,1 +1104,1 @@\n-     * Reads an 8 bit byte.\n+     * Reads an 8-bit byte.\n@@ -1105,1 +1106,1 @@\n-     * @return  the 8 bit byte read.\n+     * @return  the 8-bit byte read.\n@@ -1114,1 +1115,1 @@\n-     * Reads an unsigned 8 bit byte.\n+     * Reads an unsigned 8-bit byte.\n@@ -1116,1 +1117,1 @@\n-     * @return  the 8 bit byte read.\n+     * @return  the 8-bit byte read.\n@@ -1125,1 +1126,1 @@\n-     * Reads a 16 bit char.\n+     * Reads a 16-bit char.\n@@ -1127,1 +1128,1 @@\n-     * @return  the 16 bit char read.\n+     * @return  the 16-bit char read.\n@@ -1136,1 +1137,1 @@\n-     * Reads a 16 bit short.\n+     * Reads a 16-bit short.\n@@ -1138,1 +1139,1 @@\n-     * @return  the 16 bit short read.\n+     * @return  the 16-bit short read.\n@@ -1147,1 +1148,1 @@\n-     * Reads an unsigned 16 bit short.\n+     * Reads an unsigned 16-bit short.\n@@ -1149,1 +1150,1 @@\n-     * @return  the 16 bit short read.\n+     * @return  the 16-bit short read.\n@@ -1158,1 +1159,1 @@\n-     * Reads a 32 bit int.\n+     * Reads a 32-bit int.\n@@ -1160,1 +1161,1 @@\n-     * @return  the 32 bit integer read.\n+     * @return  the 32-bit integer read.\n@@ -1169,1 +1170,1 @@\n-     * Reads a 64 bit long.\n+     * Reads a 64-bit long.\n@@ -1171,1 +1172,1 @@\n-     * @return  the read 64 bit long.\n+     * @return  the read 64-bit long.\n@@ -1180,1 +1181,1 @@\n-     * Reads a 32 bit float.\n+     * Reads a 32-bit float.\n@@ -1182,1 +1183,1 @@\n-     * @return  the 32 bit float read.\n+     * @return  the 32-bit float read.\n@@ -1191,1 +1192,1 @@\n-     * Reads a 64 bit double.\n+     * Reads a 64-bit double.\n@@ -1193,1 +1194,1 @@\n-     * @return  the 64 bit double read.\n+     * @return  the 64-bit double read.\n@@ -2658,1 +2659,1 @@\n-            return (off >= 0) ? Bits.getBoolean(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getBoolean(primValues, off) : val;\n@@ -2668,1 +2669,1 @@\n-            return (off >= 0) ? Bits.getChar(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getChar(primValues, off) : val;\n@@ -2673,1 +2674,1 @@\n-            return (off >= 0) ? Bits.getShort(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getShort(primValues, off) : val;\n@@ -2678,1 +2679,1 @@\n-            return (off >= 0) ? Bits.getInt(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getInt(primValues, off) : val;\n@@ -2683,1 +2684,1 @@\n-            return (off >= 0) ? Bits.getFloat(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getFloat(primValues, off) : val;\n@@ -2688,1 +2689,1 @@\n-            return (off >= 0) ? Bits.getLong(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getLong(primValues, off) : val;\n@@ -2693,1 +2694,1 @@\n-            return (off >= 0) ? Bits.getDouble(primValues, off) : val;\n+            return (off >= 0) ? ByteArray.getDouble(primValues, off) : val;\n@@ -3141,1 +3142,1 @@\n-                            int len = Bits.getInt(hbuf, 1);\n+                            int len = ByteArray.getInt(hbuf, 1);\n@@ -3440,1 +3441,1 @@\n-            char v = Bits.getChar(buf, pos);\n+            char v = ByteArray.getChar(buf, pos);\n@@ -3452,1 +3453,1 @@\n-            short v = Bits.getShort(buf, pos);\n+            short v = ByteArray.getShort(buf, pos);\n@@ -3464,1 +3465,1 @@\n-            int v = Bits.getShort(buf, pos) & 0xFFFF;\n+            int v = ByteArray.getShort(buf, pos) & 0xFFFF;\n@@ -3476,1 +3477,1 @@\n-            int v = Bits.getInt(buf, pos);\n+            int v = ByteArray.getInt(buf, pos);\n@@ -3488,1 +3489,1 @@\n-            float v = Bits.getFloat(buf, pos);\n+            float v = ByteArray.getFloat(buf, pos);\n@@ -3500,1 +3501,1 @@\n-            long v = Bits.getLong(buf, pos);\n+            long v = ByteArray.getLong(buf, pos);\n@@ -3512,1 +3513,1 @@\n-            double v = Bits.getDouble(buf, pos);\n+            double v = ByteArray.getDouble(buf, pos);\n@@ -3550,1 +3551,1 @@\n-                    v[off++] = Bits.getBoolean(buf, pos++);\n+                    v[off++] = ByteArray.getBoolean(buf, pos++);\n@@ -3571,1 +3572,1 @@\n-                    v[off++] = Bits.getChar(buf, pos);\n+                    v[off++] = ByteArray.getChar(buf, pos);\n@@ -3593,1 +3594,1 @@\n-                    v[off++] = Bits.getShort(buf, pos);\n+                    v[off++] = ByteArray.getShort(buf, pos);\n@@ -3615,1 +3616,1 @@\n-                    v[off++] = Bits.getInt(buf, pos);\n+                    v[off++] = ByteArray.getInt(buf, pos);\n@@ -3637,1 +3638,1 @@\n-                    v[off++] = Bits.getFloat(buf, pos);\n+                    v[off++] = ByteArray.getFloat(buf, pos);\n@@ -3659,1 +3660,1 @@\n-                    v[off++] = Bits.getLong(buf, pos);\n+                    v[off++] = ByteArray.getLong(buf, pos);\n@@ -3681,1 +3682,1 @@\n-                    v[off++] = Bits.getDouble(buf, pos);\n+                    v[off++] = ByteArray.getDouble(buf, pos);\n@@ -3889,1 +3890,1 @@\n-    private static class HandleTable {\n+    private static final class HandleTable {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":43,"deletions":42,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+\n+import jdk.internal.util.ByteArray;\n@@ -777,1 +779,1 @@\n-     * Writes an 8 bit byte.\n+     * Writes an 8-bit byte.\n@@ -788,1 +790,1 @@\n-     * Writes a 16 bit short.\n+     * Writes a 16-bit short.\n@@ -799,1 +801,1 @@\n-     * Writes a 16 bit char.\n+     * Writes a 16-bit char.\n@@ -810,1 +812,1 @@\n-     * Writes a 32 bit int.\n+     * Writes a 32-bit int.\n@@ -821,1 +823,1 @@\n-     * Writes a 64 bit long.\n+     * Writes a 64-bit long.\n@@ -832,1 +834,1 @@\n-     * Writes a 32 bit float.\n+     * Writes a 32-bit float.\n@@ -843,1 +845,1 @@\n-     * Writes a 64 bit double.\n+     * Writes a 64-bit double.\n@@ -1650,1 +1652,1 @@\n-            Bits.putBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n+            ByteArray.setBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n@@ -1658,1 +1660,1 @@\n-            Bits.putChar(primVals, getFieldOffset(name, Character.TYPE), val);\n+            ByteArray.setChar(primVals, getFieldOffset(name, Character.TYPE), val);\n@@ -1662,1 +1664,1 @@\n-            Bits.putShort(primVals, getFieldOffset(name, Short.TYPE), val);\n+            ByteArray.setShort(primVals, getFieldOffset(name, Short.TYPE), val);\n@@ -1666,1 +1668,1 @@\n-            Bits.putInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n+            ByteArray.setInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n@@ -1670,1 +1672,1 @@\n-            Bits.putFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n+            ByteArray.setFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n@@ -1674,1 +1676,1 @@\n-            Bits.putLong(primVals, getFieldOffset(name, Long.TYPE), val);\n+            ByteArray.setLong(primVals, getFieldOffset(name, Long.TYPE), val);\n@@ -1678,1 +1680,1 @@\n-            Bits.putDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n+            ByteArray.setDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n@@ -1766,1 +1768,1 @@\n-    private static class BlockDataOutputStream\n+    private static final class BlockDataOutputStream\n@@ -1920,1 +1922,1 @@\n-                Bits.putInt(hbuf, 1, len);\n+                ByteArray.setInt(hbuf, 1, len);\n@@ -1937,1 +1939,1 @@\n-            Bits.putBoolean(buf, pos++, v);\n+            ByteArray.setBoolean(buf, pos++, v);\n@@ -1949,1 +1951,1 @@\n-                Bits.putChar(buf, pos, (char) v);\n+                ByteArray.setChar(buf, pos, (char) v);\n@@ -1958,1 +1960,1 @@\n-                Bits.putShort(buf, pos, (short) v);\n+                ByteArray.setShort(buf, pos, (short) v);\n@@ -1967,1 +1969,1 @@\n-                Bits.putInt(buf, pos, v);\n+                ByteArray.setInt(buf, pos, v);\n@@ -1976,1 +1978,1 @@\n-                Bits.putFloat(buf, pos, v);\n+                ByteArray.setFloat(buf, pos, v);\n@@ -1985,1 +1987,1 @@\n-                Bits.putLong(buf, pos, v);\n+                ByteArray.setLong(buf, pos, v);\n@@ -1994,1 +1996,1 @@\n-                Bits.putDouble(buf, pos, v);\n+                ByteArray.setDouble(buf, pos, v);\n@@ -2054,1 +2056,1 @@\n-                    Bits.putBoolean(buf, pos++, v[off++]);\n+                    ByteArray.setBoolean(buf, pos++, v[off++]);\n@@ -2067,1 +2069,1 @@\n-                        Bits.putChar(buf, pos, v[off++]);\n+                        ByteArray.setChar(buf, pos, v[off++]);\n@@ -2084,1 +2086,1 @@\n-                        Bits.putShort(buf, pos, v[off++]);\n+                        ByteArray.setShort(buf, pos, v[off++]);\n@@ -2101,1 +2103,1 @@\n-                        Bits.putInt(buf, pos, v[off++]);\n+                        ByteArray.setInt(buf, pos, v[off++]);\n@@ -2118,1 +2120,1 @@\n-                        Bits.putFloat(buf, pos, v[off++]);\n+                        ByteArray.setFloat(buf, pos, v[off++]);\n@@ -2135,1 +2137,1 @@\n-                        Bits.putLong(buf, pos, v[off++]);\n+                        ByteArray.setLong(buf, pos, v[off++]);\n@@ -2152,1 +2154,1 @@\n-                        Bits.putDouble(buf, pos, v[off++]);\n+                        ByteArray.setDouble(buf, pos, v[off++]);\n@@ -2272,1 +2274,1 @@\n-    private static class HandleTable {\n+    private static final class HandleTable {\n@@ -2397,1 +2399,1 @@\n-    private static class ReplaceTable {\n+    private static final class ReplaceTable {\n@@ -2461,1 +2463,1 @@\n-    private static class DebugTraceInfoStack {\n+    private static final class DebugTraceInfoStack {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":36,"deletions":34,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+import jdk.internal.util.ByteArray;\n@@ -1903,1 +1904,1 @@\n-    private static class MemberSignature {\n+    private static final class MemberSignature {\n@@ -1934,1 +1935,1 @@\n-    private static class FieldReflector {\n+    private static final class FieldReflector {\n@@ -1937,1 +1938,1 @@\n-        private static final Unsafe unsafe = Unsafe.getUnsafe();\n+        private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -1962,2 +1963,2 @@\n-            Object obj = unsafe.uninitializedDefaultValue(clazz);\n-            return unsafe.makePrivateBuffer(obj);\n+            Object obj = UNSAFE.uninitializedDefaultValue(clazz);\n+            return UNSAFE.makePrivateBuffer(obj);\n@@ -1973,1 +1974,1 @@\n-            return unsafe.finishPrivateBuffer(obj);\n+            return UNSAFE.finishPrivateBuffer(obj);\n@@ -1998,1 +1999,1 @@\n-                    unsafe.objectFieldOffset(rf) : Unsafe.INVALID_FIELD_OFFSET;\n+                    UNSAFE.objectFieldOffset(rf) : Unsafe.INVALID_FIELD_OFFSET;\n@@ -2040,8 +2041,8 @@\n-                    case 'Z' -> Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));\n-                    case 'B' -> buf[off] = unsafe.getByte(obj, key);\n-                    case 'C' -> Bits.putChar(buf, off, unsafe.getChar(obj, key));\n-                    case 'S' -> Bits.putShort(buf, off, unsafe.getShort(obj, key));\n-                    case 'I' -> Bits.putInt(buf, off, unsafe.getInt(obj, key));\n-                    case 'F' -> Bits.putFloat(buf, off, unsafe.getFloat(obj, key));\n-                    case 'J' -> Bits.putLong(buf, off, unsafe.getLong(obj, key));\n-                    case 'D' -> Bits.putDouble(buf, off, unsafe.getDouble(obj, key));\n+                    case 'Z' -> ByteArray.setBoolean(buf, off, UNSAFE.getBoolean(obj, key));\n+                    case 'B' -> buf[off] = UNSAFE.getByte(obj, key);\n+                    case 'C' -> ByteArray.setChar(buf, off, UNSAFE.getChar(obj, key));\n+                    case 'S' -> ByteArray.setShort(buf, off, UNSAFE.getShort(obj, key));\n+                    case 'I' -> ByteArray.setInt(buf, off, UNSAFE.getInt(obj, key));\n+                    case 'F' -> ByteArray.setFloat(buf, off, UNSAFE.getFloat(obj, key));\n+                    case 'J' -> ByteArray.setLong(buf, off, UNSAFE.getLong(obj, key));\n+                    case 'D' -> ByteArray.setDouble(buf, off, UNSAFE.getDouble(obj, key));\n@@ -2069,8 +2070,8 @@\n-                    case 'Z' -> unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off));\n-                    case 'B' -> unsafe.putByte(obj, key, buf[off]);\n-                    case 'C' -> unsafe.putChar(obj, key, Bits.getChar(buf, off));\n-                    case 'S' -> unsafe.putShort(obj, key, Bits.getShort(buf, off));\n-                    case 'I' -> unsafe.putInt(obj, key, Bits.getInt(buf, off));\n-                    case 'F' -> unsafe.putFloat(obj, key, Bits.getFloat(buf, off));\n-                    case 'J' -> unsafe.putLong(obj, key, Bits.getLong(buf, off));\n-                    case 'D' -> unsafe.putDouble(obj, key, Bits.getDouble(buf, off));\n+                    case 'Z' -> UNSAFE.putBoolean(obj, key, ByteArray.getBoolean(buf, off));\n+                    case 'B' -> UNSAFE.putByte(obj, key, buf[off]);\n+                    case 'C' -> UNSAFE.putChar(obj, key, ByteArray.getChar(buf, off));\n+                    case 'S' -> UNSAFE.putShort(obj, key, ByteArray.getShort(buf, off));\n+                    case 'I' -> UNSAFE.putInt(obj, key, ByteArray.getInt(buf, off));\n+                    case 'F' -> UNSAFE.putFloat(obj, key, ByteArray.getFloat(buf, off));\n+                    case 'J' -> UNSAFE.putLong(obj, key, ByteArray.getLong(buf, off));\n+                    case 'D' -> UNSAFE.putDouble(obj, key, ByteArray.getDouble(buf, off));\n@@ -2099,3 +2100,3 @@\n-                            unsafe.isFlattened(f)\n-                                    ? unsafe.getValue(obj, readKeys[i], f.getType())\n-                                    : unsafe.getReference(obj, readKeys[i]);\n+                            UNSAFE.isFlattened(f)\n+                                    ? UNSAFE.getValue(obj, readKeys[i], f.getType())\n+                                    : UNSAFE.getReference(obj, readKeys[i]);\n@@ -2152,2 +2153,2 @@\n-                            if (unsafe.isFlattened(f)) {\n-                                unsafe.putValue(obj, key, f.getType(), val);\n+                            if (UNSAFE.isFlattened(f)) {\n+                                UNSAFE.putValue(obj, key, f.getType(), val);\n@@ -2155,1 +2156,1 @@\n-                                unsafe.putReference(obj, key, val);\n+                                UNSAFE.putReference(obj, key, val);\n@@ -2536,7 +2537,7 @@\n-                    short.class, lkp.findStatic(Bits.class, \"getShort\", MethodType.methodType(short.class, byte[].class, int.class)),\n-                    int.class, lkp.findStatic(Bits.class, \"getInt\", MethodType.methodType(int.class, byte[].class, int.class)),\n-                    long.class, lkp.findStatic(Bits.class, \"getLong\", MethodType.methodType(long.class, byte[].class, int.class)),\n-                    float.class, lkp.findStatic(Bits.class, \"getFloat\", MethodType.methodType(float.class, byte[].class, int.class)),\n-                    double.class, lkp.findStatic(Bits.class, \"getDouble\", MethodType.methodType(double.class, byte[].class, int.class)),\n-                    char.class, lkp.findStatic(Bits.class, \"getChar\", MethodType.methodType(char.class, byte[].class, int.class)),\n-                    boolean.class, lkp.findStatic(Bits.class, \"getBoolean\", MethodType.methodType(boolean.class, byte[].class, int.class))\n+                    short.class, lkp.findStatic(ByteArray.class, \"getShort\", MethodType.methodType(short.class, byte[].class, int.class)),\n+                    int.class, lkp.findStatic(ByteArray.class, \"getInt\", MethodType.methodType(int.class, byte[].class, int.class)),\n+                    long.class, lkp.findStatic(ByteArray.class, \"getLong\", MethodType.methodType(long.class, byte[].class, int.class)),\n+                    float.class, lkp.findStatic(ByteArray.class, \"getFloat\", MethodType.methodType(float.class, byte[].class, int.class)),\n+                    double.class, lkp.findStatic(ByteArray.class, \"getDouble\", MethodType.methodType(double.class, byte[].class, int.class)),\n+                    char.class, lkp.findStatic(ByteArray.class, \"getChar\", MethodType.methodType(char.class, byte[].class, int.class)),\n+                    boolean.class, lkp.findStatic(ByteArray.class, \"getBoolean\", MethodType.methodType(boolean.class, byte[].class, int.class))\n@@ -2545,1 +2546,1 @@\n-                throw new InternalError(\"Can't lookup Bits.getXXX\", e);\n+                throw new InternalError(\"Can't lookup \" + ByteArray.class.getName() + \".getXXX\", e);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2465,0 +2465,3 @@\n+            public int countPositives(byte[] bytes, int offset, int length) {\n+                return StringCoding.countPositives(bytes, offset, length);\n+            }\n@@ -2468,1 +2471,3 @@\n-\n+            public char getUTF16Char(byte[] bytes, int index) {\n+                return StringUTF16.getChar(bytes, index);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+     * @since 20\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,10 +153,0 @@\n-        \/\/ Derived int constants, which (unlike the enums) can be constant folded.\n-        \/\/ We can remove them when JDK-8161245 is fixed.\n-        static final byte\n-                L_TYPE_NUM = (byte) L_TYPE.ordinal(),\n-                I_TYPE_NUM = (byte) I_TYPE.ordinal(),\n-                J_TYPE_NUM = (byte) J_TYPE.ordinal(),\n-                F_TYPE_NUM = (byte) F_TYPE.ordinal(),\n-                D_TYPE_NUM = (byte) D_TYPE.ordinal(),\n-                V_TYPE_NUM = (byte) V_TYPE.ordinal();\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -517,1 +517,1 @@\n-        return oldSpeciesData().extendWith((byte) type.ordinal());\n+        return oldSpeciesData().extendWith(type);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-    static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-            int matchFlags, Class<?> caller, int skip, MemberName[] results);\n@@ -123,4 +121,1 @@\n-            MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n-            \/\/ The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:\n-            MN_SEARCH_SUPERCLASSES   = 0x00100000,\n-            MN_SEARCH_INTERFACES     = 0x00200000;\n+            MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import java.util.Comparator;\n@@ -236,0 +237,6 @@\n+     * @apiNote The {@code Lookup} object returned by this method is allowed to\n+     * {@linkplain Lookup#defineClass(byte[]) define classes} in the runtime package\n+     * of {@code targetClass}. Extreme caution should be taken when opening a package\n+     * to another module as such defined classes have the same full privilege\n+     * access as other members in {@code targetClass}'s module.\n+     *\n@@ -854,1 +861,1 @@\n-     * and create a new {@code Lookup} with <a href=\"#privacc\">private access<\/a>\n+     * and produce a new {@code Lookup} with <a href=\"#privacc\">private access<\/a>\n@@ -872,0 +879,6 @@\n+     * <p>\n+     * The {@code Lookup} object returned by {@code privateLookupIn} is allowed to\n+     * {@linkplain Lookup#defineClass(byte[]) define classes} in the runtime package\n+     * of {@code T}. Extreme caution should be taken when opening a package\n+     * to another module as such defined classes have the same full privilege\n+     * access as other members in {@code M2}.\n@@ -6784,2 +6797,1 @@\n-        final List<Class<?>> empty = List.of();\n-        final List<Class<?>> longest = mhs.filter(Objects::nonNull).\n+        return mhs.filter(Objects::nonNull)\n@@ -6787,10 +6799,5 @@\n-                        map(MethodHandle::type).\n-                        filter(t -> t.parameterCount() > skipSize).\n-                        map(MethodType::parameterList).\n-                        reduce((p, q) -> p.size() >= q.size() ? p : q).orElse(empty);\n-        return longest.isEmpty() ? empty : longest.subList(skipSize, longest.size());\n-    }\n-\n-    private static List<Class<?>> longestParameterList(List<List<Class<?>>> lists) {\n-        final List<Class<?>> empty = List.of();\n-        return lists.stream().reduce((p, q) -> p.size() >= q.size() ? p : q).orElse(empty);\n+                .map(MethodHandle::type)\n+                .filter(t -> t.parameterCount() > skipSize)\n+                .max(Comparator.comparingInt(MethodType::parameterCount))\n+                .map(methodType -> List.of(Arrays.copyOfRange(methodType.ptypes(), skipSize, methodType.parameterCount())))\n+                .orElse(List.of());\n@@ -6802,1 +6809,1 @@\n-        return longestParameterList(List.of(longest1, longest2));\n+        return longest1.size() >= longest2.size() ? longest1 : longest2;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,1 @@\n+            Class<?> decl = f.getDeclaringClass();\n@@ -129,2 +130,2 @@\n-                            ? new VarHandleValues.FieldStaticReadOnly(refc, foffset, type)\n-                            : new VarHandleValues.FieldStaticReadWrite(refc, foffset, type));\n+                            ? new VarHandleValues.FieldStaticReadOnly(decl, refc, foffset, type)\n+                            : new VarHandleValues.FieldStaticReadWrite(decl, refc, foffset, type));\n@@ -133,2 +134,2 @@\n-                            ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)\n-                            : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type);\n+                            ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n+                            : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type);\n@@ -139,2 +140,2 @@\n-                       ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)\n-                       : new VarHandleBooleans.FieldStaticReadWrite(base, foffset));\n+                       ? new VarHandleBooleans.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleBooleans.FieldStaticReadWrite(decl, base, foffset));\n@@ -144,2 +145,2 @@\n-                       ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)\n-                       : new VarHandleBytes.FieldStaticReadWrite(base, foffset));\n+                       ? new VarHandleBytes.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleBytes.FieldStaticReadWrite(decl, base, foffset));\n@@ -149,2 +150,2 @@\n-                       ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)\n-                       : new VarHandleShorts.FieldStaticReadWrite(base, foffset));\n+                       ? new VarHandleShorts.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleShorts.FieldStaticReadWrite(decl, base, foffset));\n@@ -154,2 +155,2 @@\n-                       ? new VarHandleChars.FieldStaticReadOnly(base, foffset)\n-                       : new VarHandleChars.FieldStaticReadWrite(base, foffset));\n+                       ? new VarHandleChars.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleChars.FieldStaticReadWrite(decl, base, foffset));\n@@ -159,2 +160,2 @@\n-                       ? new VarHandleInts.FieldStaticReadOnly(base, foffset)\n-                       : new VarHandleInts.FieldStaticReadWrite(base, foffset));\n+                       ? new VarHandleInts.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleInts.FieldStaticReadWrite(decl, base, foffset));\n@@ -164,2 +165,2 @@\n-                       ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)\n-                       : new VarHandleLongs.FieldStaticReadWrite(base, foffset));\n+                       ? new VarHandleLongs.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleLongs.FieldStaticReadWrite(decl, base, foffset));\n@@ -169,2 +170,2 @@\n-                       ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)\n-                       : new VarHandleFloats.FieldStaticReadWrite(base, foffset));\n+                       ? new VarHandleFloats.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleFloats.FieldStaticReadWrite(decl, base, foffset));\n@@ -174,2 +175,2 @@\n-                       ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)\n-                       : new VarHandleDoubles.FieldStaticReadWrite(base, foffset));\n+                       ? new VarHandleDoubles.FieldStaticReadOnly(decl, base, foffset)\n+                       : new VarHandleDoubles.FieldStaticReadWrite(decl, base, foffset));\n@@ -199,1 +200,1 @@\n-    static Field getStaticFieldFromBaseAndOffset(Object base,\n+    static Field getStaticFieldFromBaseAndOffset(Class<?> declaringClass,\n@@ -202,3 +203,1 @@\n-        \/\/ @@@ This is a little fragile assuming the base is the class\n-        Class<?> receiverType = (Class<?>) base;\n-        for (Field f : receiverType.getDeclaredFields()) {\n+        for (Field f : declaringClass.getDeclaredFields()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -391,0 +391,1 @@\n+        final Class<?> declaringClass;\n@@ -397,2 +398,2 @@\n-        FieldStaticReadOnly(Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM, false);\n+        FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM, false);\n@@ -401,1 +402,1 @@\n-        protected FieldStaticReadOnly(Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        protected FieldStaticReadOnly(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n@@ -404,0 +405,1 @@\n+            this.declaringClass = declaringClass;\n@@ -415,1 +417,1 @@\n-                : new FieldStaticReadOnly(base, fieldOffset{#if[Object]?, fieldType}, vform, true);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, vform, true);\n@@ -422,1 +424,1 @@\n-                : new FieldStaticReadOnly(base, fieldOffset{#if[Object]?, fieldType}, vform, false);\n+                : new FieldStaticReadOnly(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, vform, false);\n@@ -433,3 +435,3 @@\n-                base, fieldOffset, {#if[Object]?fieldType:$type$.class});\n-            var receiverTypeRef = staticField.getDeclaringClass().describeConstable();\n-            if (!receiverTypeRef.isPresent())\n+                declaringClass, fieldOffset, {#if[Object]?fieldType:$type$.class});\n+            var declaringTypeRef = declaringClass.describeConstable();\n+            if (!declaringTypeRef.isPresent())\n@@ -437,1 +439,1 @@\n-            return Optional.of(VarHandleDesc.ofStaticField(receiverTypeRef.get(), staticField.getName(), fieldTypeRef.get()));\n+            return Optional.of(VarHandleDesc.ofStaticField(declaringTypeRef.get(), staticField.getName(), fieldTypeRef.get()));\n@@ -477,2 +479,3 @@\n-        FieldStaticReadWrite(Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n-            this(base, fieldOffset{#if[Object]?, fieldType}, false);\n+\n+        FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType}) {\n+            this(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, false);\n@@ -481,1 +484,1 @@\n-        private FieldStaticReadWrite(Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n+        private FieldStaticReadWrite(Class<?> declaringClass, Object base, long fieldOffset{#if[Object]?, Class<?> fieldType},\n@@ -483,1 +486,1 @@\n-            super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM, exact);\n+            super(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM, exact);\n@@ -490,1 +493,1 @@\n-                : new FieldStaticReadWrite(base, fieldOffset{#if[Object]?, fieldType}, true);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, true);\n@@ -497,1 +500,1 @@\n-                : new FieldStaticReadWrite(base, fieldOffset{#if[Object]?, fieldType}, false);\n+                : new FieldStaticReadWrite(declaringClass, base, fieldOffset{#if[Object]?, fieldType}, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,0 +306,5 @@\n+    \/**\n+     * Count the number of leading positive bytes in the range.\n+     *\/\n+    int countPositives(byte[] ba, int off, int len);\n+\n@@ -346,0 +351,10 @@\n+    \/**\n+     * Get the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     * @return the char value\n+     *\/\n+    char getUTF16Char(byte[] bytes, int index);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -276,0 +276,2 @@\n+    exports jdk.internal.util to\n+        java.desktop;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,1 @@\n-     * or instance initializer, an <a href=Name.html#empty_name>empty name<\/a> is\n+     * or instance initializer, an {@linkplain Name##empty_name empty name} is\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.stream.Collectors;\n@@ -426,0 +427,9 @@\n+    \/**\n+     * Describe modifier flags as they migh appear in source code, i.e.,\n+     * separated by spaces and in the order suggested by JLS 8.1.1.\n+     *\/\n+    public static String toSource(long flags) {\n+        return asModifierSet(flags).stream()\n+          .map(Modifier::toString)\n+          .collect(Collectors.joining(\" \"));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1367,2 +1367,1 @@\n-\n-            sym.owner.appendUniqueTypeAttributes(newattrs.toList());\n+            appendTypeAnnotationsToOwner(sym, newattrs.toList());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -124,1 +124,0 @@\n-        qualifiedSymbolCache = new HashMap<>();\n@@ -1458,3 +1457,0 @@\n-                        if (tMap.containsKey(ti)) {\n-                            throw new AssertionError(\"Malformed intersection\");\n-                        }\n@@ -3751,50 +3747,0 @@\n-    \/** Cache the symbol to reflect the qualifying type.\n-     *  key: corresponding type\n-     *  value: qualified symbol\n-     *\/\n-    private Map<Type, Symbol> qualifiedSymbolCache;\n-\n-    public void clearQualifiedSymbolCache() {\n-        qualifiedSymbolCache.clear();\n-    }\n-\n-    \/** Construct a symbol to reflect the qualifying type that should\n-     *  appear in the byte code as per JLS 13.1.\n-     *\n-     *  For {@literal target >= 1.2}: Clone a method with the qualifier as owner (except\n-     *  for those cases where we need to work around VM bugs).\n-     *\n-     *  For {@literal target <= 1.1}: If qualified variable or method is defined in a\n-     *  non-accessible class, clone it with the qualifier class as owner.\n-     *\n-     *  @param sym    The accessed symbol\n-     *  @param site   The qualifier's type.\n-     *\/\n-    public Symbol binaryQualifier(Symbol sym, Type site) {\n-\n-        if (site.hasTag(ARRAY)) {\n-            if (sym == syms.lengthVar ||\n-                    sym.owner != syms.arrayClass)\n-                return sym;\n-            \/\/ array clone can be qualified by the array type in later targets\n-            Symbol qualifier;\n-            if ((qualifier = qualifiedSymbolCache.get(site)) == null) {\n-                qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name, site, syms.noSymbol);\n-                qualifiedSymbolCache.put(site, qualifier);\n-            }\n-            return sym.clone(qualifier);\n-        }\n-\n-        if (sym.owner == site.tsym ||\n-                (sym.flags() & (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {\n-            return sym;\n-        }\n-\n-        \/\/ leave alone methods inherited from Object\n-        \/\/ JLS 13.1.\n-        if (sym.owner == syms.objectType.tsym)\n-            return sym;\n-\n-        return sym.clone(site.tsym);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-                log.error(pos, Errors.CantAssignValToFinalVar(v));\n+                log.error(pos, Errors.CantAssignValToVar(Flags.toSource(v.flags() & (STATIC | FINAL)), v));\n@@ -5217,1 +5217,1 @@\n-        Set<Type> boundSet = new HashSet<>();\n+        Set<Symbol> boundSet = new HashSet<>();\n@@ -5221,1 +5221,1 @@\n-            boundSet.add(types.erasure(bounds.head.type));\n+            boundSet.add(types.erasure(bounds.head.type).tsym);\n@@ -5320,1 +5320,1 @@\n-            Env<AttrContext> errEnv = env.dup(env.tree);\n+            Env<AttrContext> errEnv = env.dup(env.tree, env.info.dup());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3129,2 +3129,2 @@\n-    void checkNotRepeated(DiagnosticPosition pos, Type it, Set<Type> its) {\n-        if (its.contains(it))\n+    void checkNotRepeated(DiagnosticPosition pos, Type it, Set<Symbol> its) {\n+        if (its.contains(it.tsym))\n@@ -3133,1 +3133,1 @@\n-            its.add(it);\n+            its.add(it.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -522,3 +522,0 @@\n-        if (init != null) {\n-            refSym = (MethodSymbol) types.binaryQualifier(refSym, init.type);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -850,1 +850,1 @@\n-            Set<Type> interfaceSet = new HashSet<>();\n+            Set<Symbol> interfaceSet = new HashSet<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+        qualifiedSymbolCache = new HashMap<>();\n@@ -184,0 +185,6 @@\n+    \/** Cache the symbol to reflect the qualifying type.\n+     *  key: corresponding type\n+     *  value: qualified symbol\n+     *\/\n+    Map<Type, Symbol> qualifiedSymbolCache;\n+\n@@ -227,0 +234,40 @@\n+    \/** Construct a symbol to reflect the qualifying type that should\n+     *  appear in the byte code as per JLS 13.1.\n+     *\n+     *  For {@literal target >= 1.2}: Clone a method with the qualifier as owner (except\n+     *  for those cases where we need to work around VM bugs).\n+     *\n+     *  For {@literal target <= 1.1}: If qualified variable or method is defined in a\n+     *  non-accessible class, clone it with the qualifier class as owner.\n+     *\n+     *  @param sym    The accessed symbol\n+     *  @param site   The qualifier's type.\n+     *\/\n+    Symbol binaryQualifier(Symbol sym, Type site) {\n+\n+        if (site.hasTag(ARRAY)) {\n+            if (sym == syms.lengthVar ||\n+                sym.owner != syms.arrayClass)\n+                return sym;\n+            \/\/ array clone can be qualified by the array type in later targets\n+            Symbol qualifier;\n+            if ((qualifier = qualifiedSymbolCache.get(site)) == null) {\n+                qualifier = new ClassSymbol(Flags.PUBLIC, site.tsym.name, site, syms.noSymbol);\n+                qualifiedSymbolCache.put(site, qualifier);\n+            }\n+            return sym.clone(qualifier);\n+        }\n+\n+        if (sym.owner == site.tsym ||\n+            (sym.flags() & (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {\n+            return sym;\n+        }\n+\n+        \/\/ leave alone methods inherited from Object\n+        \/\/ JLS 13.1.\n+        if (sym.owner == syms.objectType.tsym)\n+            return sym;\n+\n+        return sym.clone(site.tsym);\n+    }\n+\n@@ -1132,1 +1179,1 @@\n-                sym = types.binaryQualifier(sym, env.enclClass.type);\n+                sym = binaryQualifier(sym, env.enclClass.type);\n@@ -1148,1 +1195,1 @@\n-                sym = types.binaryQualifier(sym, fieldAccess.selected.type);\n+                sym = binaryQualifier(sym, fieldAccess.selected.type);\n@@ -2351,1 +2398,1 @@\n-                sym = types.binaryQualifier(sym, env.enclClass.type);\n+                sym = binaryQualifier(sym, env.enclClass.type);\n@@ -2355,1 +2402,1 @@\n-            sym = types.binaryQualifier(sym, env.enclClass.type);\n+            sym = binaryQualifier(sym, env.enclClass.type);\n@@ -2408,1 +2455,1 @@\n-                sym = types.binaryQualifier(sym, tree.selected.type);\n+                sym = binaryQualifier(sym, tree.selected.type);\n@@ -2527,1 +2574,1 @@\n-            types.clearQualifiedSymbolCache();\n+            qualifiedSymbolCache.clear();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+            case PACKAGE:\n+            case MODULE:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,6 +257,22 @@\n-    protected static final int EXPR = 0x1;\n-    protected static final int TYPE = 0x2;\n-    protected static final int NOPARAMS = 0x4;\n-    protected static final int TYPEARG = 0x8;\n-    protected static final int DIAMOND = 0x10;\n-    protected static final int NOLAMBDA = 0x20;\n+    protected static final int EXPR          = 1 << 0;\n+    protected static final int TYPE          = 1 << 1;\n+    protected static final int NOPARAMS      = 1 << 2;\n+    protected static final int TYPEARG       = 1 << 3;\n+    protected static final int DIAMOND       = 1 << 4;\n+    protected static final int NOLAMBDA      = 1 << 5;\n+\n+    protected void setMode(int mode) {\n+        this.mode = mode;\n+    }\n+\n+    protected void setLastMode(int mode) {\n+        lastmode = mode;\n+    }\n+\n+    protected boolean isMode(int mode) {\n+        return (this.mode & mode) != 0;\n+    }\n+\n+    protected boolean wasTypeMode() {\n+        return (lastmode & TYPE) != 0;\n+    }\n@@ -265,1 +281,1 @@\n-        mode = (mode & NOLAMBDA) | EXPR;\n+        setMode((mode & NOLAMBDA) | EXPR);\n@@ -269,1 +285,1 @@\n-        mode = (mode & NOLAMBDA) | TYPE;\n+        setMode((mode & NOLAMBDA) | TYPE);\n@@ -509,1 +525,1 @@\n-        if ((mode & EXPR) != 0)\n+        if (isMode(EXPR))\n@@ -889,1 +905,1 @@\n-        mode = newmode;\n+        setMode(newmode);\n@@ -891,2 +907,2 @@\n-        lastmode = mode;\n-        mode = prevmode;\n+        setLastMode(mode);\n+        setMode(prevmode);\n@@ -911,1 +927,1 @@\n-        if ((mode & EXPR) != 0 &&\n+        if (isMode(EXPR) &&\n@@ -955,1 +971,1 @@\n-        if ((mode & EXPR) != 0 && token.kind == QUES) {\n+        if (isMode(EXPR) && token.kind == QUES) {\n@@ -984,1 +1000,1 @@\n-        if ((mode & EXPR) != 0 && prec(token.kind) >= TreeInfo.orPrec) {\n+        if (isMode(EXPR) && prec(token.kind) >= TreeInfo.orPrec) {\n@@ -1209,1 +1225,1 @@\n-            if ((mode & TYPE) != 0 && (mode & (TYPEARG|NOPARAMS)) == TYPEARG) {\n+            if (isMode(TYPE) && isMode(TYPEARG) && !isMode(NOPARAMS)) {\n@@ -1215,1 +1231,1 @@\n-            if (typeArgs == null && (mode & EXPR) != 0) {\n+            if (typeArgs == null && isMode(EXPR)) {\n@@ -1231,1 +1247,1 @@\n-            if (typeArgs == null && (mode & EXPR) != 0) {\n+            if (typeArgs == null && isMode(EXPR)) {\n@@ -1267,1 +1283,1 @@\n-            if ((mode & EXPR) != 0) {\n+            if (isMode(EXPR)) {\n@@ -1279,1 +1295,1 @@\n-            if ((mode & EXPR) != 0) {\n+            if (isMode(EXPR)) {\n@@ -1289,1 +1305,1 @@\n-            if (typeArgs == null && (mode & EXPR) != 0) {\n+            if (typeArgs == null && isMode(EXPR)) {\n@@ -1296,1 +1312,1 @@\n-            if ((mode & EXPR) != 0) {\n+            if (isMode(EXPR)) {\n@@ -1314,1 +1330,1 @@\n-            if ((mode & TYPE) == 0) {\n+            if (!isMode(TYPE)) {\n@@ -1344,1 +1360,1 @@\n-            if ((mode & EXPR) != 0 && (mode & NOLAMBDA) == 0 && peekToken(ARROW)) {\n+            if (isMode(EXPR) && !isMode(NOLAMBDA) && peekToken(ARROW)) {\n@@ -1369,1 +1385,1 @@\n-                            if ((mode & EXPR) != 0) {\n+                            if (isMode(EXPR)) {\n@@ -1379,1 +1395,1 @@\n-                        if ((mode & EXPR) != 0) {\n+                        if (isMode(EXPR)) {\n@@ -1391,2 +1407,2 @@\n-                        int oldmode = mode;\n-                        mode &= ~NOPARAMS;\n+                        int prevmode = mode;\n+                        setMode(mode & ~NOPARAMS);\n@@ -1394,2 +1410,2 @@\n-                        mode = oldmode;\n-                        if ((mode & EXPR) != 0) {\n+                        setMode(prevmode);\n+                        if (isMode(EXPR)) {\n@@ -1434,1 +1450,1 @@\n-                        if ((mode & TYPE) != 0 && token.kind == MONKEYS_AT) {\n+                        if (isMode(TYPE) && token.kind == MONKEYS_AT) {\n@@ -1460,1 +1476,1 @@\n-                        if ((mode & TYPE) == 0 && isParameterizedTypePrefix()) {\n+                        if (!isMode(TYPE) && isParameterizedTypePrefix()) {\n@@ -1510,1 +1526,1 @@\n-            if ((mode & EXPR) != 0) {\n+            if (isMode(EXPR)) {\n@@ -1554,0 +1570,1 @@\n+            \/\/ Not reachable.\n@@ -1617,2 +1634,2 @@\n-                if ((mode & TYPE) != 0) {\n-                    int oldmode = mode;\n+                if (isMode(TYPE)) {\n+                    int prevmode = mode;\n@@ -1633,1 +1650,1 @@\n-                    mode = oldmode;\n+                    setMode(prevmode);\n@@ -1635,1 +1652,1 @@\n-                if ((mode & EXPR) != 0) {\n+                if (isMode(EXPR)) {\n@@ -1644,1 +1661,1 @@\n-                if (token.kind == SUPER && (mode & EXPR) != 0) {\n+                if (token.kind == SUPER && isMode(EXPR)) {\n@@ -1650,1 +1667,1 @@\n-                } else if ((token.kind == NEW) && (mode & EXPR) != 0) {\n+                } else if (token.kind == NEW && isMode(EXPR)) {\n@@ -1660,1 +1677,1 @@\n-                    if ((mode & TYPE) != 0 && token.kind == MONKEYS_AT) {\n+                    if (isMode(TYPE) && token.kind == MONKEYS_AT) {\n@@ -1678,1 +1695,1 @@\n-            } else if ((mode & EXPR) != 0 && token.kind == COLCOL) {\n+            } else if (isMode(EXPR) && token.kind == COLCOL) {\n@@ -1693,1 +1710,1 @@\n-        while ((token.kind == PLUSPLUS || token.kind == SUBSUB) && (mode & EXPR) != 0) {\n+        while ((token.kind == PLUSPLUS || token.kind == SUBSUB) && isMode(EXPR)) {\n@@ -1836,2 +1853,2 @@\n-                        return (mode & NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA\n-                                                      : ParensResult.PARENS;\n+                        return !isMode(NOLAMBDA) ? ParensResult.IMPLICIT_LAMBDA\n+                                                 : ParensResult.PARENS;\n@@ -2086,1 +2103,1 @@\n-        if ((mode & EXPR) != 0 && token.kind == LPAREN || typeArgs != null) {\n+        if (isMode(EXPR) && token.kind == LPAREN || typeArgs != null) {\n@@ -2141,2 +2158,2 @@\n-            (mode & TYPE) != 0 &&\n-            (mode & NOPARAMS) == 0) {\n+            isMode(TYPE) &&\n+            !isMode(NOPARAMS)) {\n@@ -2155,2 +2172,2 @@\n-            if ((mode & useMode) == 0 ||\n-                (mode & NOPARAMS) != 0) {\n+            if (!isMode(useMode) ||\n+                isMode(NOPARAMS)) {\n@@ -2159,1 +2176,1 @@\n-            mode = useMode;\n+            setMode(useMode);\n@@ -2174,1 +2191,1 @@\n-                mode |= DIAMOND;\n+                setMode(mode | DIAMOND);\n@@ -2179,1 +2196,1 @@\n-                args.append(((mode & EXPR) == 0) ? typeArgument() : parseType());\n+                args.append(!isMode(EXPR) ? typeArgument() : parseType());\n@@ -2182,1 +2199,1 @@\n-                    args.append(((mode & EXPR) == 0) ? typeArgument() : parseType());\n+                    args.append(!isMode(EXPR) ? typeArgument() : parseType());\n@@ -2303,1 +2320,1 @@\n-        if ((mode & EXPR) != 0 && token.kind == DOT) {\n+        if (isMode(EXPR) && token.kind == DOT) {\n@@ -2331,1 +2348,1 @@\n-        } else if ((mode & TYPE) != 0) {\n+        } else if (isMode(TYPE)) {\n@@ -2394,1 +2411,1 @@\n-        int oldmode = mode;\n+        int prevmode = mode;\n@@ -2401,1 +2418,1 @@\n-            diamondFound = (mode & DIAMOND) != 0;\n+            diamondFound = isMode(DIAMOND);\n@@ -2420,1 +2437,1 @@\n-                diamondFound = (mode & DIAMOND) != 0;\n+                diamondFound = isMode(DIAMOND);\n@@ -2423,1 +2440,1 @@\n-        mode = oldmode;\n+        setMode(prevmode);\n@@ -2482,1 +2499,1 @@\n-            int oldmode = mode;\n+            int prevmode = mode;\n@@ -2484,1 +2501,1 @@\n-            mode = oldmode;\n+            setMode(prevmode);\n@@ -2823,1 +2840,1 @@\n-            } else if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n+            } else if (wasTypeMode() && LAX_IDENTIFIER.test(token.kind)) {\n@@ -3385,1 +3402,1 @@\n-            if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n+            if (wasTypeMode() && LAX_IDENTIFIER.test(token.kind)) {\n@@ -3390,1 +3407,1 @@\n-            } else if ((lastmode & TYPE) != 0 && token.kind == COLON) {\n+            } else if (wasTypeMode() && token.kind == COLON) {\n@@ -3420,2 +3437,2 @@\n-        lastmode = mode;\n-        mode = prevmode;\n+        setLastMode(mode);\n+        setMode(prevmode);\n@@ -3807,0 +3824,5 @@\n+                } else if (lambdaParameter && type == null) {\n+                    \/\/ we have a lambda parameter that is not an identifier this is a syntax error\n+                    type = pn;\n+                    name = names.empty;\n+                    reportSyntaxError(pos, Errors.Expected(IDENTIFIER));\n@@ -3874,1 +3896,1 @@\n-        if ((lastmode & TYPE) != 0 && LAX_IDENTIFIER.test(token.kind)) {\n+        if (wasTypeMode() && LAX_IDENTIFIER.test(token.kind)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":89,"deletions":67,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -342,3 +342,3 @@\n-# 0: symbol\n-compiler.err.cant.assign.val.to.final.var=\\\n-    cannot assign a value to final variable {0}\n+# 0: set of flag or string, 1: symbol\n+compiler.err.cant.assign.val.to.var=\\\n+    cannot assign a value to {0} variable {1}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_status._flags\", Integer.class, \"u4\");\n+    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_flags._flags\", Integer.class, \"u4\");\n@@ -143,2 +143,2 @@\n-    final int jvmMiscFlagsHasDefaultMethods = getConstant(\"InstanceKlassMiscStatus::_misc_has_nonstatic_concrete_methods\", Integer.class);\n-    final int jvmMiscFlagsDeclaresDefaultMethods = getConstant(\"InstanceKlassMiscStatus::_misc_declares_nonstatic_concrete_methods\", Integer.class);\n+    final int jvmMiscFlagsHasDefaultMethods = getConstant(\"InstanceKlassFlags::_misc_has_nonstatic_concrete_methods\", Integer.class);\n+    final int jvmMiscFlagsDeclaresDefaultMethods = getConstant(\"InstanceKlassFlags::_misc_declares_nonstatic_concrete_methods\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-runtime\/StackGuardPages\/TestStackGuardPages.java 8293452 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -441,1 +441,0 @@\n- -runtime\/cds\/appcds\/javaldr\/HumongousDuringDump.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -133,0 +133,6 @@\n+\n+    public static final String ABS_V = PREFIX + \"ABS_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_V, \"AbsV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -148,0 +154,5 @@\n+    public static final String ADD_V = PREFIX + \"ADD_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_V, \"AddV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -158,0 +169,5 @@\n+    public static final String ADD_REDUCTION_V = PREFIX + \"ADD_REDUCTION_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_REDUCTION_V, \"AddReductionV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -363,0 +379,5 @@\n+    public static final String DIV_V = PREFIX + \"DIV_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_V, \"DivV(F|D)\");\n+    }\n+\n@@ -390,0 +411,5 @@\n+    public static final String FMA_V = PREFIX + \"FMA_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FMA_V, \"FmaV(F|D)\");\n+    }\n+\n@@ -591,0 +617,5 @@\n+    public static final String LSHIFT_V = PREFIX + \"LSHIFT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LSHIFT_V, \"LShiftV(B|S|I|L)\");\n+    }\n+\n@@ -661,0 +692,5 @@\n+    public static final String MUL_V = PREFIX + \"MUL_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_V, \"MulV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -676,0 +712,5 @@\n+    public static final String NEG_V = PREFIX + \"NEG_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(NEG_V, \"NegV(F|D)\");\n+    }\n+\n@@ -712,0 +753,5 @@\n+    public static final String POPCOUNT_VI = PREFIX + \"POPCOUNT_VI\" + POSTFIX;\n+    static {\n+        superWordNodes(POPCOUNT_VI, \"PopCountVI\");\n+    }\n+\n@@ -745,0 +791,48 @@\n+    public static final String REPLICATE_B = PREFIX + \"REPLICATE_B\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateB\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_B, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_S = PREFIX + \"REPLICATE_S\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateS\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_S, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_I = PREFIX + \"REPLICATE_I\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateI\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_I, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_L = PREFIX + \"REPLICATE_L\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateL\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_L, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_F = PREFIX + \"REPLICATE_F\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateF\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_F, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_D = PREFIX + \"REPLICATE_D\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateD\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_D, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n@@ -785,0 +879,15 @@\n+    public static final String ROTATE_LEFT_V = PREFIX + \"ROTATE_LEFT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROTATE_LEFT_V, \"RotateLeftV\");\n+    }\n+\n+    public static final String ROTATE_RIGHT_V = PREFIX + \"ROTATE_RIGHT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROTATE_RIGHT_V, \"RotateRightV\");\n+    }\n+\n+    public static final String ROUND_DOUBLE_MODE_V = PREFIX + \"ROUND_DOUBLE_MODE_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROUND_DOUBLE_MODE_V, \"RoundDoubleModeV\");\n+    }\n+\n@@ -810,0 +919,5 @@\n+    public static final String RSHIFT_V = PREFIX + \"RSHIFT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_V, \"RShiftV(B|S|I|L)\");\n+    }\n+\n@@ -831,0 +945,5 @@\n+    public static final String SQRT_V = PREFIX + \"SQRT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SQRT_V, \"SqrtV(F|D)\");\n+    }\n+\n@@ -967,0 +1086,5 @@\n+    public static final String SUB_V = PREFIX + \"SUB_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_V, \"SubV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -1037,0 +1161,5 @@\n+    public static final String URSHIFT_V = PREFIX + \"URSHIFT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_V, \"URShiftV(B|S|I|L)\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.parser.MethodCompilationParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.TestClassParser;\n@@ -762,3 +762,3 @@\n-                MethodCompilationParser methodCompilationParser = new MethodCompilationParser(testClass);\n-                Matchable testClassMatchable = methodCompilationParser.parse(testVMProcess.getHotspotPidFileName(),\n-                                                                             testVMProcess.getIrEncoding());\n+                TestClassParser testClassParser = new TestClassParser(testClass);\n+                Matchable testClassMatchable = testClassParser.parse(testVMProcess.getHotspotPidFileName(),\n+                                                                     testVMProcess.getIrEncoding());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -526,2 +526,0 @@\n-javax\/management\/remote\/mandatory\/notif\/NotifReconnectDeadlockTest.java 8042215 generic-all\n-\n@@ -553,1 +551,1 @@\n-java\/nio\/channels\/FileChannel\/FileExtensionAndMap.java          8297292 generic-all\n+jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java                     8301183 linux-all\n@@ -588,9 +586,0 @@\n-javax\/net\/ssl\/SSLEngine\/TestAllSuites.java                      8298874 generic-all\n-javax\/net\/ssl\/SSLEngine\/IllegalRecordVersion.java               8298873 generic-all\n-javax\/net\/ssl\/SSLEngine\/EngineCloseOnAlert.java                 8298868 generic-all\n-javax\/net\/ssl\/SSLEngine\/ConnectionTest.java                     8298869 generic-all\n-javax\/net\/ssl\/SSLEngine\/CheckStatus.java                        8298872 generic-all\n-javax\/net\/ssl\/SSLEngine\/Basics.java                             8298867 generic-all\n-\n-sun\/security\/provider\/KeyStore\/DKSTest.sh                       8180266 windows-all\n-\n@@ -623,1 +612,1 @@\n-java\/security\/Policy\/Root\/Root.java                             8299994 generic-all\n+sun\/security\/provider\/certpath\/OCSP\/OCSPNoContentLength.java    8300939 generic-all\n@@ -675,2 +664,0 @@\n-javax\/swing\/JFileChooser\/8046391\/bug8046391.java 8293862 windows-x64\n-javax\/swing\/JFileChooser\/4847375\/bug4847375.java 8293862 windows-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -647,1 +647,2 @@\n-    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java\n+    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java \\\n+    java\/security\/Policy\/Root\/Root.java\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessBoolean\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessBoolean\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessBoolean\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessBoolean\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessBoolean\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessBoolean\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessBoolean\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessBoolean\n@@ -296,3 +300,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessBoolean.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessByte\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessByte\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessByte\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessByte\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessByte\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessByte\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessByte\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessByte\n@@ -296,3 +300,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessByte.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessChar\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessChar\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessChar\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessChar\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessChar\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessChar\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessChar\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessChar\n@@ -296,3 +300,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessChar.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessDouble\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessDouble\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessDouble\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessDouble\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessDouble\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessDouble\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessDouble\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessDouble\n@@ -296,3 +300,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessDouble.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessFloat\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessFloat\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessFloat\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessFloat\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessFloat\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessFloat\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessFloat\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessFloat\n@@ -296,3 +300,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessFloat.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessInt\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessInt\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessInt\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessInt\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessInt\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessInt\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessInt\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessInt\n@@ -296,3 +300,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessInt.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessLong\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessLong\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessLong\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessLong\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessLong\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessLong\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessLong\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessLong\n@@ -296,3 +300,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessLong.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessShort\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessShort\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessShort\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessShort\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessShort\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessShort\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessShort\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessShort\n@@ -296,3 +300,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessShort.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,8 @@\n- * @run testng\/othervm -Diters=10    -Xint                   VarHandleTestAccessString\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccessString\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccessString\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccessString\n+ * @run testng\/othervm -Diters=10   -Xint                                                   VarHandleTestAccessString\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccessString\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccessString\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccessString\n@@ -303,3 +307,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessString.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessBoolean\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessBoolean\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessBoolean.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessByte\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessByte\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessByte.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessChar\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessChar\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessChar.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessDouble\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessDouble\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessDouble.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessFloat\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessFloat\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessFloat.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessInt\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessInt\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessInt.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessLong\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessLong\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessLong.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessShort\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessShort\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessShort.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccessString\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccessString\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessString.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,4 @@\n+ *\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ *\n@@ -31,3 +35,3 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccess$Type$\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Diters=20000                         VarHandleTestAccess$Type$\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccess$Type$\n+ * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccess$Type$\n+ * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccess$Type$\n+ * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccess$Type$\n@@ -36,3 +40,3 @@\n- * @run testng\/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestAccess$Type$\n- * @run testng\/othervm -Diters=20000                         VarHandleTestAccess$Type$\n- * @run testng\/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestAccess$Type$\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:TieredStopAtLevel=1 VarHandleTestAccess$Type$\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1                         VarHandleTestAccess$Type$\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 -XX:-TieredCompilation  VarHandleTestAccess$Type$\n@@ -362,3 +366,0 @@\n-\n-\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestAccess.java.template","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,3 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Diters=2000 VarHandleTestMethodHandleAccess$Type$\n+ * @comment Set CompileThresholdScaling to 0.1 so that the warmup loop sets to 2000 iterations\n+ *          to hit compilation thresholds\n+ * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Diters=200 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccess$Type$\n@@ -32,1 +34,1 @@\n- * @run testng\/othervm -Diters=20000 VarHandleTestMethodHandleAccess$Type$\n+ * @run testng\/othervm -Diters=2000 -XX:CompileThresholdScaling=0.1 VarHandleTestMethodHandleAccess$Type$\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestMethodHandleAccess.java.template","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2031,1 +2031,1 @@\n-        assertFail(\"compiler.err.cant.assign.val.to.final.var\",\n+        assertFail(\"compiler.err.cant.assign.val.to.var\",\n@@ -2040,1 +2040,1 @@\n-        assertFail(\"compiler.err.cant.assign.val.to.final.var\",\n+        assertFail(\"compiler.err.cant.assign.val.to.var\",\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,3 +1,3 @@\n-CheckFinal.java:14:13: compiler.err.cant.assign.val.to.final.var: fi\n-CheckFinal.java:15:13: compiler.err.cant.assign.val.to.final.var: fe\n-CheckFinal.java:17:13: compiler.err.cant.assign.val.to.final.var: xsf\n+CheckFinal.java:14:13: compiler.err.cant.assign.val.to.var: final, fi\n+CheckFinal.java:15:13: compiler.err.cant.assign.val.to.var: final, fe\n+CheckFinal.java:17:13: compiler.err.cant.assign.val.to.var: static final, xsf\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckStaticFinalAssign.java:15:9: compiler.err.cant.assign.val.to.final.var: x\n+CheckStaticFinalAssign.java:15:9: compiler.err.cant.assign.val.to.var: static final, x\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckStaticFinalAssign.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-            assertFail(\"compiler.err.cant.assign.val.to.final.var\", source);\n+            assertFail(\"compiler.err.cant.assign.val.to.var\", source);\n@@ -322,1 +322,1 @@\n-            assertFail(\"compiler.err.cant.assign.val.to.final.var\", source);\n+            assertFail(\"compiler.err.cant.assign.val.to.var\", source);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-        assertFail(\"compiler.err.cant.assign.val.to.final.var\",\n+        assertFail(\"compiler.err.cant.assign.val.to.var\",\n@@ -273,1 +273,1 @@\n-        assertFail(\"compiler.err.cant.assign.val.to.final.var\",\n+        assertFail(\"compiler.err.cant.assign.val.to.var\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,11 +1,11 @@\n-WithFieldNegativeTests.java:16:14: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:17:14: compiler.err.cant.assign.val.to.final.var: sx\n-WithFieldNegativeTests.java:22:16: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:26:10: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:27:12: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:28:11: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:29:9: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:30:13: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:31:15: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:37:10: compiler.err.cant.assign.val.to.final.var: x\n-WithFieldNegativeTests.java:38:10: compiler.err.cant.assign.val.to.final.var: sx\n+WithFieldNegativeTests.java:16:14: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:17:14: compiler.err.cant.assign.val.to.var: static final, sx\n+WithFieldNegativeTests.java:22:16: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:26:10: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:27:12: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:28:11: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:29:9: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:30:13: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:31:15: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:37:10: compiler.err.cant.assign.val.to.var: final, x\n+WithFieldNegativeTests.java:38:10: compiler.err.cant.assign.val.to.var: static final, sx\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldNegativeTests.out","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -725,0 +725,2 @@\n+  public native long hostPhysicalMemory();\n+  public native long hostPhysicalSwap();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}