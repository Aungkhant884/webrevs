[{"commit":{"message":"Two more missing membars"},"files":[{"filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferTearingC1.java"}],"sha":"ed4c8bd2e668547e85ce932ff20ae019b234ad8c"},{"commit":{"message":"8264414: [lworld] [AArch64] TestBufferTearing.java fails with C1\n\nWe see failures like this on AArch64 when MyValue.incrementAndCheck() is\ncompiled with C1:\n\n  java.lang.RuntimeException: Inconsistent field values: expected 0 to equal 675128\n        at jdk.test.lib.Asserts.fail(Asserts.java:594)\n        at jdk.test.lib.Asserts.assertEquals(Asserts.java:205)\n        at jdk.test.lib.Asserts.assertEQ(Asserts.java:178)\n        at compiler.valhalla.inlinetypes.MyValue.incrementAndCheck(TestBufferTearing.java:81)\n        at compiler.valhalla.inlinetypes.TestBufferTearing$Runner.run(TestBufferTearing.java:124)\n\nThe barrier that is usually inserted on return from a method that wrote\nfinal fields should be sufficient to prevent another thread seeing the\nzero-initialised intermediate state.  However this barrier isn't\ninserted at the moment because method()->is_object_constructor() is\nfalse for primitive class constructors.\n\nC2 has a similar guard around the memory barrier in Parse::do_exits().\nI'm not sure if that needs amending as well but I've not seen any\nfailures due to it."},"files":[{"filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp"}],"sha":"afed1e02fd27cd3776de60cc614680d598bc74fa"}]