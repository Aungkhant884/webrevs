{"files":[{"patch":"@@ -1770,0 +1770,3 @@\n+  } else if (_entry_point == NULL) {\n+    \/\/ See CallLeafNoFPIndirect\n+    return 1 * NativeInstruction::instruction_size;\n@@ -3698,0 +3701,11 @@\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic()) {\n+      \/\/ An inline type is returned as fields in multiple registers.\n+      \/\/ R0 either contains an oop if the inline type is buffered or a pointer\n+      \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero r0\n+      \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+      \/\/ r0 &= (r0 & 1) - 1\n+      C2_MacroAssembler _masm(&cbuf);\n+      __ andr(rscratch1, r0, 0x1);\n+      __ sub(rscratch1, rscratch1, 0x1);\n+      __ andr(r0, r0, rscratch1);\n+    }\n@@ -16320,0 +16334,18 @@\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPIndirect(iRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == NULL);\n+\n+  match(CallLeafNoFP target);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, runtime leaf nofp indirect $target\" %}\n+\n+  ins_encode %{\n+    __ blr($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n@@ -16322,0 +16354,2 @@\n+  predicate(n->as_Call()->entry_point() != NULL);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -520,1 +520,1 @@\n-      \/\/ At this point, rax points to the value object (for interpreter or C1 caller).\n+      \/\/ At this point, r0 points to the value object (for interpreter or C1 caller).\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-define_pd_global(bool, InlineTypeReturnedAsFields, false);\n+define_pd_global(bool, InlineTypeReturnedAsFields, true);\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -796,2 +796,2 @@\n-    \/\/ call above kills the value in r1. Reload it.\n-    ldr(r1, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+    \/\/ call above kills sender esp in rscratch2. Reload it.\n+    ldr(rscratch2, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n@@ -801,2 +801,0 @@\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5710,2 +5710,1 @@\n-  cmp(r0, (u1) 1);\n-  br(Assembler::EQ, skip);\n+  tbz(r0, 0, skip);\n@@ -5714,4 +5713,3 @@\n-  Label slow_case;\n-\n-  \/\/ Try to allocate a new buffered inline type (from the heap)\n-  if (UseTLAB) {\n+  \/\/ Be careful not to clobber r1-7 which hold returned fields\n+  \/\/ Also do not use callee-saved registers as these may be live in the interpreter\n+  Register tmp1 = r13, tmp2 = r14, klass = r15, r0_preserved = r12;\n@@ -5719,6 +5717,14 @@\n-    if (vk != NULL) {\n-      \/\/ Called from C1, where the return type is statically known.\n-      mov(r1, (intptr_t)vk->get_InlineKlass());\n-      jint lh = vk->layout_helper();\n-      assert(lh != Klass::_lh_neutral_value, \"inline class in return type must have been resolved\");\n-      mov(r14, lh);\n+  \/\/ The following code is similar to allocate_instance but has some slight differences,\n+  \/\/ e.g. object size is always not zero, sometimes it's constant; storing klass ptr after\n+  \/\/ allocating is not necessary if vk != NULL, etc. allocate_instance is not aware of these.\n+  Label slow_case;\n+  \/\/ 1. Try to allocate a new buffered inline instance either from TLAB or eden space\n+  mov(r0_preserved, r0); \/\/ save r0 for slow_case since *_allocate may corrupt it when allocation failed\n+\n+  if (vk != NULL) {\n+    \/\/ Called from C1, where the return type is statically known.\n+    movptr(klass, (intptr_t)vk->get_InlineKlass());\n+    jint obj_size = vk->layout_helper();\n+    assert(obj_size != Klass::_lh_neutral_value, \"inline class in return type must have been resolved\");\n+    if (UseTLAB) {\n+      tlab_allocate(r0, noreg, obj_size, tmp1, tmp2, slow_case);\n@@ -5726,4 +5732,1 @@\n-       \/\/ Call from interpreter. R0 contains ((the InlineKlass* of the return type) | 0x01)\n-       andr(r1, r0, -2);\n-       \/\/ get obj size\n-       ldrw(r14, Address(rscratch1 \/*klass*\/, Klass::layout_helper_offset()));\n+      eden_allocate(r0, noreg, obj_size, tmp1, slow_case);\n@@ -5731,7 +5734,13 @@\n-\n-    ldr(r13, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));\n-    lea(r14, Address(r13, r14));\n-    ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_end_offset())));\n-    cmp(r14, rscratch1);\n-    br(Assembler::GT, slow_case);\n-    str(r14, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));\n+  } else {\n+    \/\/ Call from interpreter. R0 contains ((the InlineKlass* of the return type) | 0x01)\n+    andr(klass, r0, -2);\n+    ldrw(tmp2, Address(klass, Klass::layout_helper_offset()));\n+    if (UseTLAB) {\n+      tlab_allocate(r0, tmp2, 0, tmp1, tmp2, slow_case);\n+    } else {\n+      eden_allocate(r0, tmp2, 0, tmp1, slow_case);\n+    }\n+  }\n+  if (UseTLAB || Universe::heap()->supports_inline_contig_alloc()) {\n+    \/\/ 2. Initialize buffered inline instance header\n+    Register buffer_obj = r0;\n@@ -5739,4 +5748,8 @@\n-    str(rscratch1, Address(r13, oopDesc::mark_offset_in_bytes()));\n-\n-    store_klass_gap(r13, zr);  \/\/ zero klass gap for compressed oops\n-\n+    str(rscratch1, Address(buffer_obj, oopDesc::mark_offset_in_bytes()));\n+    store_klass_gap(buffer_obj, zr);\n+    if (vk == NULL) {\n+      \/\/ store_klass corrupts klass, so save it for later use (interpreter case only).\n+      mov(tmp1, klass);\n+    }\n+    store_klass(buffer_obj, klass);\n+    \/\/ 3. Initialize its fields with an inline class specific handler\n@@ -5744,2 +5757,0 @@\n-      \/\/ FIXME -- do the packing in-line to avoid the runtime call\n-      mov(r0, r13);\n@@ -5748,7 +5759,4 @@\n-      \/\/ We have our new buffered inline type, initialize its fields with an inline class specific handler\n-      ldr(r1, Address(r0, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n-      ldr(r1, Address(r1, InlineKlass::pack_handler_offset()));\n-\n-      \/\/ Mov new class to r0 and call pack_handler\n-      mov(r0, r13);\n-      blr(r1);\n+      \/\/ tmp1 holds klass preserved above\n+      ldr(tmp1, Address(tmp1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      ldr(tmp1, Address(tmp1, InlineKlass::pack_handler_offset()));\n+      blr(tmp1);\n@@ -5756,0 +5764,2 @@\n+\n+    membar(Assembler::StoreStore);\n@@ -5757,0 +5767,3 @@\n+  } else {\n+    \/\/ Must have already branched to slow_case in eden_allocate() above.\n+    DEBUG_ONLY(should_not_reach_here());\n@@ -5758,1 +5771,0 @@\n-\n@@ -5764,0 +5776,1 @@\n+  mov(r0, r0_preserved);\n@@ -5768,2 +5781,1 @@\n-    ldr(rscratch1, RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));\n-    blr(rscratch1);\n+    far_call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));\n@@ -5772,0 +5784,1 @@\n+  membar(Assembler::StoreStore);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":52,"deletions":39,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -359,2 +359,1 @@\n-\/\/ const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;\n-const uint SharedRuntime::java_return_convention_max_int = 6;\n+const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j;\n@@ -365,3 +364,1 @@\n-  \/\/ Create the mapping between argument positions and\n-  \/\/ registers.\n-  \/\/ r1, r2 used to address klasses and states, exclude it from return convention to avoid colision\n+  \/\/ Create the mapping between argument positions and registers.\n@@ -370,1 +367,1 @@\n-     r0 \/* j_rarg7 *\/, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2\n+    r0 \/* j_rarg7 *\/, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2, j_rarg1, j_rarg0\n@@ -391,1 +388,0 @@\n-        \/\/ Should we have gurantee here?\n@@ -426,1 +422,1 @@\n-      if (fp_args < Argument::n_float_register_parameters_j) {\n+      if (fp_args < SharedRuntime::java_return_convention_max_float) {\n@@ -3392,1 +3388,2 @@\n-  __ ldr(r0, Address(r13, 0));\n+  Register Rresult = r14;  \/\/ See StubGenerator::generate_call_stub().\n+  __ ldr(r0, Address(Rresult));\n@@ -3396,1 +3393,1 @@\n-  __ str(r0, Address(r13, 0));\n+  __ str(r0, Address(Rresult));\n@@ -3461,0 +3458,1 @@\n+    assert(off > 0, \"offset in object should be positive\");\n@@ -3470,2 +3468,2 @@\n-       assert_different_registers(r0, r_1->as_Register());\n-       __ load_heap_oop(r_1->as_Register(), from);\n+      assert_different_registers(r0, r_1->as_Register());\n+      __ load_heap_oop(r_1->as_Register(), from);\n@@ -3483,0 +3481,5 @@\n+  if (StressInlineTypeReturnedAsFields) {\n+    __ load_klass(r0, r0);\n+    __ orr(r0, r0, 1);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -315,1 +315,6 @@\n-    __ ldr(j_rarg2, result);\n+    \/\/ All of j_rargN may be used to return inline type fields so be careful\n+    \/\/ not to clobber those.\n+    \/\/ SharedRuntime::generate_buffered_inline_type_adapter() knows the register\n+    \/\/ assignment of Rresult below.\n+    Register Rresult = r14, Rresult_type = r15;\n+    __ ldr(Rresult, result);\n@@ -317,2 +322,2 @@\n-    __ ldr(j_rarg1, result_type);\n-    __ cmp(j_rarg1, (u1)T_OBJECT);\n+    __ ldr(Rresult_type, result_type);\n+    __ cmp(Rresult_type, (u1)T_OBJECT);\n@@ -320,1 +325,1 @@\n-    __ cmp(j_rarg1, (u1)T_INLINE_TYPE);\n+    __ cmp(Rresult_type, (u1)T_INLINE_TYPE);\n@@ -322,1 +327,1 @@\n-    __ cmp(j_rarg1, (u1)T_LONG);\n+    __ cmp(Rresult_type, (u1)T_LONG);\n@@ -324,1 +329,1 @@\n-    __ cmp(j_rarg1, (u1)T_FLOAT);\n+    __ cmp(Rresult_type, (u1)T_FLOAT);\n@@ -326,1 +331,1 @@\n-    __ cmp(j_rarg1, (u1)T_DOUBLE);\n+    __ cmp(Rresult_type, (u1)T_DOUBLE);\n@@ -330,1 +335,1 @@\n-    __ strw(r0, Address(j_rarg2));\n+    __ strw(r0, Address(Rresult));\n@@ -379,8 +384,6 @@\n-      __ cbz(r0, is_long);\n-      \/\/ Initialize pre-allocated buffer\n-      __ mov(r1, r0);\n-      __ andr(r1, r1, -2);\n-      __ ldr(r1, Address(r1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n-      __ ldr(r1, Address(r1, InlineKlass::pack_handler_offset()));\n-      __ ldr(r0, Address(j_rarg2, 0));\n-      __ blr(r1);\n+      __ tbz(r0, 0, is_long);\n+      \/\/ Load pack handler address\n+      __ andr(rscratch1, r0, -2);\n+      __ ldr(rscratch1, Address(rscratch1, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      __ ldr(rscratch1, Address(rscratch1, InlineKlass::pack_handler_jobject_offset()));\n+      __ blr(rscratch1);\n@@ -391,1 +394,1 @@\n-    __ str(r0, Address(j_rarg2, 0));\n+    __ str(r0, Address(Rresult, 0));\n@@ -395,1 +398,1 @@\n-    __ strs(j_farg0, Address(j_rarg2, 0));\n+    __ strs(j_farg0, Address(Rresult, 0));\n@@ -399,1 +402,1 @@\n-    __ strd(j_farg0, Address(j_rarg2, 0));\n+    __ strd(j_farg0, Address(Rresult, 0));\n@@ -7003,5 +7006,3 @@\n-\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n+    \/\/ We need to save all registers the calling convention may use so\n+    \/\/ the runtime calls read or update those registers. This needs to\n+    \/\/ be in sync with SharedRuntime::java_return_convention().\n@@ -7010,3 +7011,1 @@\n-      rfp_off = 0, rfp_off2,\n-\n-      j_rarg7_off, j_rarg7_2,\n+      j_rarg7_off = 0, j_rarg7_2,    \/\/ j_rarg7 is r0\n@@ -7021,7 +7020,0 @@\n-      j_farg0_off, j_farg0_2,\n-      j_farg1_off, j_farg1_2,\n-      j_farg2_off, j_farg2_2,\n-      j_farg3_off, j_farg3_2,\n-      j_farg4_off, j_farg4_2,\n-      j_farg5_off, j_farg5_2,\n-      j_farg6_off, j_farg6_2,\n@@ -7029,0 +7021,7 @@\n+      j_farg6_off, j_farg6_2,\n+      j_farg5_off, j_farg5_2,\n+      j_farg4_off, j_farg4_2,\n+      j_farg3_off, j_farg3_2,\n+      j_farg2_off, j_farg2_2,\n+      j_farg1_off, j_farg1_2,\n+      j_farg0_off, j_farg0_2,\n@@ -7030,0 +7029,1 @@\n+      rfp_off, rfp_off2,\n@@ -7031,0 +7031,1 @@\n+\n@@ -7034,5 +7035,1 @@\n-    int insts_size = 512;\n-    int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n+    CodeBuffer code(name, 512, 64);\n@@ -7041,19 +7038,4 @@\n-    address start = __ pc();\n-\n-    const Address f7_save       (rfp, j_farg7_off * wordSize);\n-    const Address f6_save       (rfp, j_farg6_off * wordSize);\n-    const Address f5_save       (rfp, j_farg5_off * wordSize);\n-    const Address f4_save       (rfp, j_farg4_off * wordSize);\n-    const Address f3_save       (rfp, j_farg3_off * wordSize);\n-    const Address f2_save       (rfp, j_farg2_off * wordSize);\n-    const Address f1_save       (rfp, j_farg1_off * wordSize);\n-    const Address f0_save       (rfp, j_farg0_off * wordSize);\n-\n-    const Address r0_save      (rfp, j_rarg0_off * wordSize);\n-    const Address r1_save      (rfp, j_rarg1_off * wordSize);\n-    const Address r2_save      (rfp, j_rarg2_off * wordSize);\n-    const Address r3_save      (rfp, j_rarg3_off * wordSize);\n-    const Address r4_save      (rfp, j_rarg4_off * wordSize);\n-    const Address r5_save      (rfp, j_rarg5_off * wordSize);\n-    const Address r6_save      (rfp, j_rarg6_off * wordSize);\n-    const Address r7_save      (rfp, j_rarg7_off * wordSize);\n+    int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+    assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+    int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+    int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n@@ -7061,2 +7043,2 @@\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(frame_size_in_slots, 0);\n@@ -7064,1 +7046,0 @@\n-    map->set_callee_saved(VMRegImpl::stack2reg(rfp_off), rfp->as_VMReg());\n@@ -7083,4 +7064,1 @@\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n+    address start = __ pc();\n@@ -7090,1 +7068,4 @@\n-    assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+    __ stpd(j_farg1, j_farg0, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg3, j_farg2, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg5, j_farg4, Address(__ pre(sp, -2 * wordSize)));\n+    __ stpd(j_farg7, j_farg6, Address(__ pre(sp, -2 * wordSize)));\n@@ -7092,20 +7073,4 @@\n-    \/\/ lr and fp are already in place\n-    __ sub(sp, rfp, ((unsigned)framesize - 4) << LogBytesPerInt); \/\/ prolog\n-\n-    __ strd(j_farg7, f7_save);\n-    __ strd(j_farg6, f6_save);\n-    __ strd(j_farg5, f5_save);\n-    __ strd(j_farg4, f4_save);\n-    __ strd(j_farg3, f3_save);\n-    __ strd(j_farg2, f2_save);\n-    __ strd(j_farg1, f1_save);\n-    __ strd(j_farg0, f0_save);\n-\n-    __ str(j_rarg0, r0_save);\n-    __ str(j_rarg1, r1_save);\n-    __ str(j_rarg2, r2_save);\n-    __ str(j_rarg3, r3_save);\n-    __ str(j_rarg4, r4_save);\n-    __ str(j_rarg5, r5_save);\n-    __ str(j_rarg6, r6_save);\n-    __ str(j_rarg7, r7_save);\n+    __ stp(j_rarg1, j_rarg0, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg3, j_rarg2, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg5, j_rarg4, Address(__ pre(sp, -2 * wordSize)));\n+    __ stp(j_rarg7, j_rarg6, Address(__ pre(sp, -2 * wordSize)));\n@@ -7113,1 +7078,1 @@\n-    int frame_complete = __ pc() - start;\n+    int frame_complete = __ offset();\n@@ -7120,1 +7085,0 @@\n-    __ mov(c_rarg0, rthread);\n@@ -7122,0 +7086,1 @@\n+    __ mov(c_rarg0, rthread);\n@@ -7123,1 +7088,0 @@\n-    BLOCK_COMMENT(\"call runtime_entry\");\n@@ -7131,17 +7095,9 @@\n-    __ ldrd(j_farg7, f7_save);\n-    __ ldrd(j_farg6, f6_save);\n-    __ ldrd(j_farg5, f5_save);\n-    __ ldrd(j_farg4, f4_save);\n-    __ ldrd(j_farg3, f3_save);\n-    __ ldrd(j_farg3, f2_save);\n-    __ ldrd(j_farg1, f1_save);\n-    __ ldrd(j_farg0, f0_save);\n-\n-    __ ldr(j_rarg0, r0_save);\n-    __ ldr(j_rarg1, r1_save);\n-    __ ldr(j_rarg2, r2_save);\n-    __ ldr(j_rarg3, r3_save);\n-    __ ldr(j_rarg4, r4_save);\n-    __ ldr(j_rarg5, r5_save);\n-    __ ldr(j_rarg6, r6_save);\n-    __ ldr(j_rarg7, r7_save);\n+    __ ldp(j_rarg7, j_rarg6, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg5, j_rarg4, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg3, j_rarg2, Address(__ post(sp, 2 * wordSize)));\n+    __ ldp(j_rarg1, j_rarg0, Address(__ post(sp, 2 * wordSize)));\n+\n+    __ ldpd(j_farg7, j_farg6, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg5, j_farg4, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg3, j_farg2, Address(__ post(sp, 2 * wordSize)));\n+    __ ldpd(j_farg1, j_farg0, Address(__ post(sp, 2 * wordSize)));\n@@ -7154,2 +7110,1 @@\n-    __ cmp(rscratch1, (u1)NULL_WORD);\n-    __ br(Assembler::NE, pending);\n+    __ cbnz(rscratch1, pending);\n@@ -7160,0 +7115,1 @@\n+\n@@ -7163,1 +7119,0 @@\n-    __ ldr(r0, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n@@ -7166,0 +7121,3 @@\n+    \/\/ -------------\n+    \/\/ make sure all code is generated\n+    masm->flush();\n@@ -7167,5 +7125,1 @@\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    int frame_size_in_words = (framesize >> (LogBytesPerWord - LogBytesPerInt));\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code, frame_complete, frame_size_in_words, oop_maps, false);\n-\n+    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, frame_size_in_words, oop_maps, false);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":68,"deletions":114,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -2018,1 +2018,1 @@\n-  if (AMD64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {\n+  if (AMD64_ONLY(false &&) AARCH64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}