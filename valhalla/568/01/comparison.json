{"files":[{"patch":"@@ -1603,1 +1603,14 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  if (remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  \/\/ Scalarize inline types in safepoint debug info.\n+  \/\/ Delay this until all inlining is over to avoid getting inconsistent debug info.\n+  if (phase->C->scalarize_in_safepoints() && can_reshape && jvms() != NULL) {\n+    for (uint i = jvms()->debug_start(); i < jvms()->debug_end(); i++) {\n+      Node* n = in(i)->uncast();\n+      if (n->is_InlineTypeBase()) {\n+        n->as_InlineTypeBase()->make_scalar_in_safepoints(phase->is_IterGVN());\n+      }\n+    }\n+  }\n+  return NULL;\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2525,0 +2525,1 @@\n+    Node_List casts;\n@@ -2535,4 +2536,1 @@\n-          if (phase->type(n->in(1))->filter_speculative(n->bottom_type()) == Type::TOP) {\n-            can_optimize = false;\n-            break;\n-          }\n+          casts.push(n);\n@@ -2557,0 +2555,8 @@\n+    \/\/ Check if cast nodes can be pushed through\n+    const Type* t = Type::get_const_type(vk);\n+    while (casts.size() != 0 && can_optimize && t != NULL) {\n+      Node* cast = casts.pop();\n+      if (t->filter(cast->bottom_type()) == Type::TOP) {\n+        can_optimize = false;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1944,0 +1944,6 @@\n+  \/\/ Scalarize inline types in safepoint debug info.\n+  \/\/ Delay this until all inlining is over to avoid getting inconsistent debug info.\n+  set_scalarize_in_safepoints(true);\n+  for (int i = _inline_type_nodes.length()-1; i >= 0; i--) {\n+    _inline_type_nodes.at(i)->as_InlineTypeBase()->make_scalar_in_safepoints(&igvn);\n+  }\n@@ -1989,7 +1995,0 @@\n-  } else {\n-    \/\/ Give inline types a chance to be scalarized in safepoints\n-    \/\/ Delay this until all inlining is over to avoid getting inconsistent debug info\n-    set_scalarize_in_safepoints(true);\n-    for (int i = _inline_type_nodes.length()-1; i >= 0; i--) {\n-      igvn._worklist.push(_inline_type_nodes.at(i));\n-    }\n@@ -2743,3 +2742,0 @@\n-  \/\/ Process inline type nodes again after loop opts\n-  process_inline_types(igvn);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -593,7 +593,0 @@\n-  if (phase->C->scalarize_in_safepoints() && can_reshape) {\n-    PhaseIterGVN* igvn = phase->is_IterGVN();\n-    make_scalar_in_safepoints(igvn);\n-    if (outcnt() == 0) {\n-      return NULL;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,0 +152,8 @@\n+const Type* FastLockNode::Value(PhaseGVN* phase) const {\n+  if (phase->type(in(1))->is_inlinetypeptr()) {\n+    \/\/ Locking on inline types always fails\n+    return TypeInt::CC_GT;\n+  }\n+  return TypeInt::CC;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  virtual const Type* Value(PhaseGVN* phase) const { return TypeInt::CC; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3686,0 +3686,1 @@\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n@@ -3730,0 +3731,1 @@\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}