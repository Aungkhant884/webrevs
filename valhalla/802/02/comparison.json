{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -31,0 +32,2 @@\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n@@ -33,0 +36,5 @@\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n@@ -34,0 +42,4 @@\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n@@ -61,1 +73,3 @@\n-        GetPropertyAction.privilegedGetProperty(\"value.bsm.debug\") != null;\n+            GetPropertyAction.privilegedGetProperty(\"value.bsm.debug\") != null;\n+    private static final int THRESHOLD =\n+            GetIntegerAction.privilegedGetProperty(\"jdk.value.recursion.threshold\", Integer.MAX_VALUE);\n@@ -65,5 +79,1 @@\n-        static MethodHandle[] getters(Class<?> type) {\n-            return getters(type, null);\n-        }\n-\n-        static MethodHandle[] getters(Class<?> type, Comparator<MethodHandle> comparator) {\n+        static Stream<MethodHandle> getterStream(Class<?> type, Comparator<MethodHandle> comparator) {\n@@ -83,1 +93,5 @@\n-            return s.toArray(MethodHandle[]::new);\n+            return s;\n+        }\n+\n+        static List<MethodHandle> getters(Class<?> type, Comparator<MethodHandle> comparator) {\n+            return getterStream(type, comparator).toList();\n@@ -119,0 +133,137 @@\n+        \/**\n+         * A base method for testing substitutability on a recursive data type,\n+         * a value class with cyclic membership.\n+         *\n+         * This method will first invoke a method handle to test the substitutability\n+         * of fields that are not of its own type.  If true, then compares the\n+         * value of the fields whose type is a recursive data type.\n+         * For a field of its own type {@code f}, invoke the method handle for\n+         * this base method on the field value of the given objects.\n+         * For a field of other recursive data type, invoke {@link #isSubstitutable(Object, Object)}\n+         * on the field value of the given objects.\n+         *\n+         * @param type  a value class\n+         * @param mh    a MethodHandle that tests substitutability of all fields that are\n+         *              not of its own type.  The method type is (V, V)boolean\n+         * @param getters all getters for the fields that are of the same value class\n+         * @param recur MethodHandle that is capable of recursively calling itself\n+         *              to test if two objects of the given value class are substitutable\n+         *              The method type is (Object,Object)boolean.\n+         * @param o1    an object\n+         * @param o2    an object to be compared for substitutability\n+         * @param counter an AtomicInteger counter to keep track of the traversal count\n+         * @return\n+         * @param <V>   a value class\n+         *\/\n+        private static <V> boolean base(Class<V> type, MethodHandle mh, MethodHandle[] getters,\n+                                        MethodHandle recur, Object o1, Object o2,\n+                                        AtomicInteger counter) throws Throwable {\n+            assert isValueClass(type) : type.getName() + \" not a value class\";\n+\n+            if (o1 == null && o2 == null) return true;\n+            if (o1 == null || o2 == null) return false;\n+\n+            if (counter.getAndDecrement() == 0) {\n+                throw new StackOverflowError(\"fail to evaluate == for value class \" + type.getName());\n+            }\n+\n+            \/\/ test if all fields that are not of the same value type are substitutable\n+            boolean result = (boolean) mh.invoke(o1, o2);\n+            if (result) {\n+                assert o1.getClass() == type && o2.getClass() == type;\n+\n+                \/\/ test if the fields of a recursive data type are substitutable\n+                for (MethodHandle getter : getters) {\n+                    Class<?> ftype = fieldType(getter);\n+                    Object f1 = getter.invoke(o1);\n+                    Object f2 = getter.invoke(o2);\n+\n+                    boolean substitutable;\n+                    if (ftype == type) {\n+                        substitutable = (boolean)recur.invokeExact(f1, f2, counter);\n+                    } else {\n+                        MethodHandle recur2 = RECUR_METHOD_HANDLES.get(ftype);\n+                        substitutable = (boolean)recur2.invokeExact(f1, f2, counter);\n+                    }\n+                    if (!substitutable) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return result;\n+        }\n+\n+        \/*\n+         * Finds all value class memberships of the given type involved in cycles\n+         *\/\n+        private static Set<Class<?>> recursiveValueTypes(Class<?> type) {\n+            if (!isValueClass(type)) {\n+                return Set.of();\n+            }\n+\n+            Deque<Class<?>> deque = new ArrayDeque<>();\n+            Set<Class<?>> visited = new HashSet<>();\n+            Set<Class<?>> recursiveTypes = new HashSet<>();\n+            Map<Class<?>, List<Class<?>>> unvisitedEdges = new HashMap<>();\n+\n+            Class<?> c;\n+            deque.add(type);\n+            while ((c = deque.peek()) != null) {\n+                if (visited.contains(c)) {\n+                    \/\/ remove the current node being visited\n+                    deque.pop();\n+                    if (deque.contains(c)) {\n+                        \/\/ include all types in the cycle\n+                        for (Class<?> n : deque) {\n+                            recursiveTypes.add(n);\n+                            if (n == c) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ continue the depth-first search from the parent of c\n+                    if ((c = deque.peek()) == null)\n+                        continue;\n+                } else {\n+                    visited.add(c);\n+                }\n+\n+                \/\/ depth-first search on the field types of type c that are value classes\n+                List<Class<?>> nodes = unvisitedEdges.computeIfAbsent(c, (k) -> fieldTypes(k));\n+                if (nodes.isEmpty()) {\n+                    \/\/ all field types are traversed\n+                    deque.pop();\n+                } else {\n+                    Class<?> n = nodes.remove(0);\n+                    deque.push(n);\n+                }\n+            }\n+\n+            if (recursiveTypes.isEmpty())\n+                return Set.of();\n+\n+            return Arrays.stream(type.getDeclaredFields())\n+                         .filter(f -> !Modifier.isStatic(f.getModifiers()))\n+                         .map(f -> f.getType())\n+                         .filter(recursiveTypes::contains)\n+                         .collect(Collectors.toSet());\n+        }\n+\n+        private static List<Class<?>> fieldTypes(Class<?> type) {\n+            List<Class<?>> result = new ArrayList<>();\n+            Arrays.stream(type.getDeclaredFields())\n+                  .filter(f -> !Modifier.isStatic(f.getModifiers()))\n+                  .map(f -> f.getType())\n+                  .filter(ft -> isValueClass(ft) && !result.contains(ft))\n+                  .forEach(result::add);\n+            return result;\n+        }\n+\n+        private static final ConcurrentHashMap<Class<?>, Boolean> inProgress = new ConcurrentHashMap<>();\n+        private static final ClassValue<MethodHandle> RECUR_METHOD_HANDLES = new ClassValue<>() {\n+            @Override protected MethodHandle computeValue(Class<?> type) {\n+                return MethodHandleBuilder.recurValueTypeEquals(type);\n+            }\n+        };\n+\n@@ -121,1 +272,1 @@\n-         * are substitutable.\n+         * are substitutable.  The method type is (V, V)boolean.\n@@ -127,0 +278,26 @@\n+            try {\n+                if (inProgress.putIfAbsent(type, true) != null) {\n+                    throw new StackOverflowError(\"cyclic class membership: \" + type.getName());\n+                }\n+\n+                Set<Class<?>> recursiveTypes = recursiveValueTypes(type);\n+                if (recursiveTypes.isEmpty()) {\n+                    return valueTypeEquals(type, getters(type, TYPE_SORTER));\n+                } else {\n+                    MethodHandle target = recurValueTypeEquals(type, recursiveValueTypes(type));\n+                    return MethodHandles.insertArguments(target, 2, new AtomicInteger(THRESHOLD))\n+                                        .asType(methodType(boolean.class, type, type));\n+                }\n+            } finally {\n+                inProgress.remove(type);\n+            }\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if the given fields\n+         * of the two value objects are substitutable. The method type is (V, V)boolean\n+         *\/\n+        static MethodHandle valueTypeEquals(Class<?> type, List<MethodHandle> getters) {\n+            \/\/ ensure the reference type of a primitive class not used in the method handle\n+            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n+\n@@ -128,5 +305,48 @@\n-            MethodHandle[] getters = getters(type, TYPE_SORTER);\n-            MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);\n-            MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);\n-            MethodHandle accumulator = dropArguments(TRUE, 0, type, type);\n-            for (MethodHandle getter : getters) {\n+                MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);\n+                MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);\n+                MethodHandle accumulator = dropArguments(TRUE, 0, type, type);\n+                for (MethodHandle getter : getters) {\n+                    Class<?> ftype = fieldType(getter);\n+                    MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n+                    MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n+                    accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n+                }\n+\n+                \/\/ if both arguments are null, return true;\n+                \/\/ otherwise return accumulator;\n+                return guardWithTest(IS_NULL.asType(mt),\n+                                     instanceTrue,\n+                                     guardWithTest(IS_SAME_VALUE_CLASS.asType(mt),\n+                                                   accumulator,\n+                                                   instanceFalse));\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if two value objects of\n+         * a recursive data type are substitutable.  This method is invoked by\n+         * the base method.\n+         *\n+         * The method type is (Object, Object, AtomicInteger)boolean.\n+         *\/\n+        static MethodHandle recurValueTypeEquals(Class<?> type) {\n+            try {\n+                if (inProgress.putIfAbsent(type, true) != null) {\n+                    throw new StackOverflowError(\"cyclic class membership: \" + type.getName());\n+                }\n+                return recurValueTypeEquals(type, recursiveValueTypes(type));\n+            } finally {\n+                inProgress.remove(type);\n+            }\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if two value objects of\n+         * a recursive data type are substitutable.\n+         *\n+         * The method type is (Object, Object, AtomicInteger)boolean.\n+         *\/\n+        static MethodHandle recurValueTypeEquals(Class<?> type, Set<Class<?>> recursiveTypes) {\n+            Stream<MethodHandle> getterStream = getterStream(type, TYPE_SORTER);;\n+            List<MethodHandle> nonRecurTypeGetters = new ArrayList<>();\n+            List<MethodHandle> recurTypeGetters = new ArrayList<>();\n+            getterStream.forEach(getter -> {\n@@ -134,3 +354,10 @@\n-                MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n-                MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n-                accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n+                if (recursiveTypes.contains(ftype)) {\n+                    \/\/ skip the value class that is involved in a cyclic membership\n+                    recurTypeGetters.add(getter);\n+                } else {\n+                    nonRecurTypeGetters.add(getter);\n+                }\n+            });\n+\n+            if (recurTypeGetters.isEmpty()) {\n+                throw new InternalError(\"must be a recursive data type: \" + type.getName());\n@@ -138,7 +365,11 @@\n-            \/\/ if both arguments are null, return true;\n-            \/\/ otherwise return accumulator;\n-            return guardWithTest(IS_NULL.asType(mt),\n-                                 instanceTrue,\n-                                 guardWithTest(IS_SAME_VALUE_CLASS.asType(mt),\n-                                               accumulator,\n-                                               instanceFalse));\n+\n+            MethodHandle target = valueTypeEquals(type, nonRecurTypeGetters);\n+            \/\/ This value class contains cyclic membership\n+            \/\/ Create a method handle that is capable of calling itself.\n+            \/\/ - the base method first calls the method handle that tests the substitutability of\n+            \/\/   all fields that are not a recursive data type\n+            \/\/ - for a field of its own type, call the recursive method\n+            \/\/ - for a field of a recursive data type, call isSubstitutable\n+            Object[] arguments = new Object[]{type, target, recurTypeGetters.toArray(MethodHandle[]::new)};\n+            target = MethodHandles.insertArguments(RECUR_EQUALS, 0, arguments);\n+            return recursive(target);\n@@ -160,1 +391,1 @@\n-            MethodHandle[] getters = MethodHandleBuilder.getters(type);\n+            MethodHandle[] getters = getterStream(type, null).toArray(MethodHandle[]::new);\n@@ -257,0 +488,4 @@\n+        private static final MethodHandle RECUR_EQUALS =\n+                findStatic(\"base\", methodType(boolean.class, Class.class, MethodHandle.class, MethodHandle[].class,\n+                                                MethodHandle.class, Object.class, Object.class, AtomicInteger.class));\n+\n@@ -434,1 +669,1 @@\n-    private static ClassValue<MethodHandle> SUBST_TEST_METHOD_HANDLES = new ClassValue<>() {\n+    private static final ClassValue<MethodHandle> SUBST_TEST_METHOD_HANDLES = new ClassValue<>() {\n@@ -470,1 +705,1 @@\n-    private static ClassValue<MethodHandle> HASHCODE_METHOD_HANDLES = new ClassValue<>() {\n+    private static final ClassValue<MethodHandle> HASHCODE_METHOD_HANDLES = new ClassValue<>() {\n@@ -480,0 +715,2 @@\n+        if (t1 == t2) return 0;\n+\n@@ -491,0 +728,158 @@\n+\n+\n+    \/**\n+     * Constructs a method handle that is capable of recursively\n+     * calling itself, whose behavior is determined by a non-recursive\n+     * base method handle which gets both the original arguments and a\n+     * reference to the recursive method handle.\n+     * <p>\n+     * Here is pseudocode for the resulting loop handle, plus a sketch\n+     * of the behavior of the base function. The symbols {@code A},\n+     * {@code a}, and {@code R} represent arguments and return value\n+     * for both the recursive function and the base function.\n+     *\n+     * <blockquote><pre>{@code\n+     * R recursive(A... a) {\n+     *   MethodHandle recur = &recursive;\n+     *   return base(recur, a...);\n+     * }\n+     * R base(MethodHandle recur, A... a) {\n+     *   ... if (no recursion)  return f(a);  ...\n+     *   var r2 = recur.invokeExact(a2...);\n+     *   var r3 = recur.invokeExact(a3...);\n+     *   ... do stuff with r2, r3, etc. ...\n+     * }\n+     * }<\/pre><\/blockquote>\n+     * <p>\n+     * To make several functions mutually recursive, additional base\n+     * arguments can be passed to this combinator.  For each base\n+     * function, a recursive adapter is formed (like {@code recur}\n+     * above).  The sequence of recursive adapters is passed as\n+     * initial arguments to each base function.  Here is pseudocode\n+     * that corresponds to three base functions:\n+     * <blockquote><pre>{@code\n+     * R recursive(A... a) {\n+     *   return base(&recursive, &recursive2, &recursive3, a...);\n+     * }\n+     * R2 recursive2(A2... a2) {\n+     *   return base2(&recursive, &recursive2, &recursive3, a2...);\n+     * }\n+     * R3 recursive3(A3... a3) {\n+     *   return base2(&recursive, &recursive2, &recursive3, a3...);\n+     * }\n+     * R base(MethodHandle recur, MethodHandle recur2,\n+     *        MethodHandle recur3, A... a) {\n+     *   ... if (no recursion)  return f(a);  ...\n+     *   var r2 = recur2.invokeExact(a2...);\n+     *   var r3 = recur3.invokeExact(a3...);\n+     *   ... do stuff with r2, r3, etc. ...\n+     * }\n+     * R2 base2(MethodHandle recur, MethodHandle recur2,\n+     *        MethodHandle recur3, A2... a2) { ... }\n+     * R3 base3(MethodHandle recur, MethodHandle recur2,\n+     *        MethodHandle recur3, A3... a3) { ... }\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @apiNote Example:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ classic recursive implementation of the factorial function\n+     * static int base(MethodHandle recur, int k) throws Throwable {\n+     *   if (k <= 1)  return 1;\n+     *   return k * (int) recur.invokeExact(k - 1);\n+     * }\n+     * \/\/ assume MH_base is a handle to the above method\n+     * MethodHandle recur = MethodHandles.recursive(MH_base);\n+     * assertEquals(120, recur.invoke(5));\n+     * }\n+     * <p>\n+     * A constructed recursive method handle is made varargs\n+     * if its corresponding base method handle is varargs.\n+     * @implSpec\n+     * For a single base function, this produces a result equivalent to:\n+     * <pre>{@code\n+     * class Holder {\n+     *   final MethodHandle recur;\n+     *   static final MH_recur = ...;  \/\/field getter\n+     *   Holder(MethodHandle base) {\n+     *     recur = filterArguments(base, 0, MH_recur).bindTo(this);\n+     *   }\n+     * }\n+     * return new Holder(base).recur;\n+     * }<\/pre>\n+     * @param base the logic of the function to make recursive\n+     * @param moreBases additional base functions to be made mutually recursive\n+     * @throws NullPointerException if any argument is null\n+     * @throws IllegalArgumentException if any base function does not accept\n+     *          the required leading arguments of type {@code MethodHandle}\n+     *\n+     * @return a method handle which invokes the (first) base function\n+     *         on the incoming arguments, with recursive versions of the\n+     *         base function (or functions) prepended as extra arguments\n+     *\n+     * @since Valhalla\n+     *\/\n+    static MethodHandle recursive(MethodHandle base, MethodHandle... moreBases) {\n+        \/\/ freeze the varargs and check for nulls:\n+        List<MethodHandle> bases2 = List.of(moreBases);\n+        int baseCount = 1 + bases2.size();\n+        recursiveChecks(base, baseCount);\n+        for (var base2 : bases2) { recursiveChecks(base2, baseCount); }\n+        class Holder {\n+            final MethodHandle recur;\n+            final List<MethodHandle> recurs2;\n+            MethodHandle recurs2(int i) { return recurs2.get(i); }\n+            Holder() {\n+                \/\/ Feed the first baseCount parameters of each base\n+                \/\/ with a fetch of each recur, so we can bind to this:\n+                var fetchers = new MethodHandle[baseCount];\n+                fetchers[0] = MH_recur;\n+                for (int pos = 1; pos < fetchers.length; pos++) {\n+                    int i = pos-1;  \/\/ index into recurs2\n+                    fetchers[pos] = MethodHandles.insertArguments(MH_recurs2, 1, i);\n+                }\n+                this.recur = makeRecur(base, fetchers);\n+                if (baseCount == 1) {\n+                    this.recurs2 = List.of();\n+                } else {\n+                    var recurs2 = new MethodHandle[baseCount-1];\n+                    for (int i = 0; i < recurs2.length; i++) {\n+                        recurs2[i] = makeRecur(bases2.get(i), fetchers);\n+                    }\n+                    this.recurs2 = List.of(recurs2);\n+                }\n+            }\n+            MethodHandle makeRecur(MethodHandle base, MethodHandle[] fetchers) {\n+                var adapt = filterArguments(base, 0, fetchers);\n+                for (int pos = 0; pos < fetchers.length; pos++) {\n+                    adapt = adapt.bindTo(this);\n+                }\n+                return adapt.withVarargs(base.isVarargsCollector());\n+            }\n+            static final MethodHandle MH_recur, MH_recurs2;\n+            static {\n+                try {\n+                    MH_recur = MethodHandles.lookup()\n+                            .findGetter(Holder.class, \"recur\", MethodHandle.class);\n+                    MH_recurs2 = MethodHandles.lookup()\n+                            .findVirtual(Holder.class, \"recurs2\",\n+                                    methodType(MethodHandle.class, int.class));\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new InternalError(ex);\n+                }\n+            }\n+        }\n+        return new Holder().recur;\n+    }\n+\n+    private static void recursiveChecks(MethodHandle base, int baseCount) {\n+        MethodType mt = base.type();  \/\/ implicit null check\n+        boolean wrong = (mt.parameterCount() < baseCount);\n+        for (int i = 0; i < baseCount && !wrong; i++) {\n+            if (mt.parameterType(i) != MethodHandle.class) {\n+                wrong = true;\n+            }\n+        }\n+        if (!wrong)  return;\n+        throw new IllegalArgumentException(\"missing leading MethodHandle parameters: \" + mt);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":421,"deletions":26,"binary":false,"changes":447,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/java.lang.runtime:open\n+ * @run testng TestRecursive\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.reflect.Method;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestRecursive {\n+    static MethodHandle recursive(MethodHandle base, MethodHandle... moreBases) throws ReflectiveOperationException {\n+        \/\/ temporarily place this API in an internal class\n+        Class<?> c = Class.forName(\"java.lang.runtime.ValueObjectMethods\");\n+        Method m = c.getDeclaredMethod(\"recursive\", MethodHandle.class, MethodHandle[].class);\n+        m.setAccessible(true);\n+        return (MethodHandle) m.invoke(null, base, moreBases);\n+    }\n+\n+    static class Snippet1 {\n+        \/\/ classic recursive implementation of the factorial function\n+        static int base(MethodHandle recur, int k) throws Throwable {\n+            if (k <= 1)  return 1;\n+            return k * (int) recur.invokeExact(k - 1);\n+        }\n+        static void doTest() throws Throwable {\n+            var MT_base = methodType(int.class, MethodHandle.class, int.class);\n+            var MH_base = lookup().findStatic(Snippet1.class, \"base\", MT_base);\n+            \/\/ assume MH_base is a handle to the above method\n+            MethodHandle recur = recursive(MH_base);\n+            assertEquals(120, (int) recur.invoke(5));\n+        }\n+    }\n+\n+    @Test\n+    public void testSingleRecursion() throws Throwable {\n+        Snippet1.doTest();\n+    }\n+\n+    static class DoubleRecursion {\n+        static long entryPoint(MethodHandle entryPoint,\n+                               MethodHandle factorialOdd,\n+                               MethodHandle factorialEven,\n+                               long k) throws Throwable {\n+            if ((k & 1) == 0)\n+                return (long) factorialEven.invokeExact(k, \"even0\", 2.2f);\n+            else\n+                return (long) factorialOdd.invokeExact(k, \"odd0\");\n+        }\n+        static long factorialOdd(MethodHandle entryPoint,\n+                                 MethodHandle factorialOdd,\n+                                 MethodHandle factorialEven,\n+                                 long k,\n+                                 \/\/ change up the signature:\n+                                 String ignore) throws Throwable {\n+            assertEquals(k & 1, 1);\n+            if (k < 3)  return 1;\n+            return k * (long) factorialEven.invokeExact(k - 1, \"even1\", 3.3f);\n+        }\n+        static long factorialEven(MethodHandle entryPoint,\n+                                  MethodHandle factorialOdd,\n+                                  MethodHandle factorialEven,\n+                                  long k,\n+                                 \/\/ change up the signature again:\n+                                  String ignore, float ig2) throws Throwable {\n+            assertEquals(k & 1, 0);\n+            if (k < 2)  return 1;\n+            return k * (long) factorialOdd.invokeExact(k - 1, \"odd1\");\n+        }\n+        static void doTest() throws Throwable {\n+            var mt = methodType(long.class,\n+                                MethodHandle.class,\n+                                MethodHandle.class,\n+                                MethodHandle.class,\n+                                long.class);\n+            var MH_entryPoint = lookup().findStatic(DoubleRecursion.class,\n+                                                    \"entryPoint\", mt);\n+            mt = mt.appendParameterTypes(String.class);\n+            var MH_factorialOdd = lookup().findStatic(DoubleRecursion.class,\n+                                                      \"factorialOdd\", mt);\n+            mt = mt.appendParameterTypes(float.class);\n+            var MH_factorialEven = lookup().findStatic(DoubleRecursion.class,\n+                                                       \"factorialEven\", mt);\n+            MethodHandle recur = recursive(MH_entryPoint,\n+                                           MH_factorialOdd,\n+                                           MH_factorialEven);\n+            long fact = 1;\n+            for (long k = 0; k < 20; k++) {\n+                assertEquals(fact, (long) recur.invoke(k));\n+                fact *= k+1;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDoubleRecursion() throws Throwable {\n+        DoubleRecursion.doTest();\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/TestRecursive.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @compile -XDenablePrimitiveClasses RecursiveValueClass.java\n+ * @run junit\/othervm -Xint -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n+ *\/\n+\n+\/*\n+ * @ignore 8296056\n+ * @test\n+ * @compile -XDenablePrimitiveClasses RecursiveValueClass.java\n+ * @run junit\/othervm -XX:TieredStopAtLevel=1 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n+ *\/\n+\n+\/*\n+ * @ignore 8296056\n+ * @test\n+ * @compile -XDenablePrimitiveClasses RecursiveValueClass.java\n+ * @run junit\/othervm -Xcomp -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class RecursiveValueClass {\n+    static value class Node {\n+        Node left;\n+        Node right;\n+\n+        Node(Node l, Node r) {\n+            this.left = l;\n+            this.right = r;\n+        }\n+    }\n+\n+    static primitive class P {\n+        Node node;\n+        V v;\n+        P(Node node) {\n+            this.node = node;\n+            this.v = null;\n+        }\n+    }\n+\n+    static value class V {\n+        P.ref p;\n+        V() {\n+            this.p = null;\n+        }\n+    }\n+\n+    static value class A {\n+        B b;\n+        E e;\n+        A(B b, E e) {\n+            this.b = b;\n+            this.e = e;\n+        }\n+    }\n+    static value class B {\n+        C c;\n+        D d;\n+        B(C c, D d) {\n+            this.c = c;\n+            this.d = d;\n+        }\n+    }\n+    static value class C {\n+        A a;\n+        C(A a) {\n+            this.a = a;\n+        }\n+    }\n+    static value class D {\n+        int x;\n+        D(int x) {\n+            this.x = x;\n+        }\n+    }\n+    static value class E {\n+        F f;\n+        E(F f) {\n+            this.f = f;\n+        }\n+    }\n+    static value class F {\n+        E e;\n+        F(E e) {\n+            this.e = e;\n+        }\n+    }\n+\n+    static Stream<Arguments> objectsProvider() {\n+        var n1 = Node.default;\n+        var n2 = new Node(n1, null);\n+        var n3 = new Node(n2, n1);\n+        var n4 = new Node(n2, n1);\n+        var p1 = new P(n3);\n+        var p2 = new P(n4);\n+\n+        var e1 = new E(F.default);\n+        var f1 = new F(e1);\n+        var e2 = new E(f1);\n+        var f2 = new F(e2);\n+\n+        var a = new A(B.default, E.default);\n+\n+        var d1 = new D(1);\n+        var d2 = new D(2);\n+        var c1 = new C(a);\n+        var c2 = new C(a);\n+\n+        var b1 = new B(c1, d1);\n+        var b2 = new B(c1, d2);\n+        var b3 = new B(c2, d2);\n+        var a1 = new A(b1, e1);\n+        var a2 = new A(b2, e2);\n+\n+        return Stream.of(\n+                \/\/ Node -> Node left & right\n+                Arguments.of(n1, n1,     true),\n+                Arguments.of(n1, n2,     false),\n+                Arguments.of(n2, n3,     false),\n+                Arguments.of(n3, n4,     true),\n+                Arguments.of(null, n4,   false),\n+                Arguments.of(null, null, true),\n+                Arguments.of(n1, \"foo\",  false),\n+\n+                \/\/ primitive class P -> value class V -> P.ref\n+                Arguments.of(p1, p2,     true),\n+\n+                \/\/ E -> F -> E\n+                Arguments.of(e1, e2,     false),\n+                Arguments.of(e1, e1,     true),\n+                Arguments.of(f1, f2,     false),\n+                Arguments.of(f2, f2,     true),\n+\n+                \/\/ two cyclic memberships from A\n+                \/\/ A -> B -> C -> A and E -> F -> E\n+                Arguments.of(a1, a2,     false),\n+                Arguments.of(a2, a2,     true),\n+                Arguments.of(b1, b2,     false),\n+                Arguments.of(b2, b3,     true),\n+                Arguments.of(c1, c2,     true)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"objectsProvider\")\n+    public void testAcmp(Object o1, Object o2, boolean expected) {\n+        var value = o1 == o2;\n+        assertEquals(expected, value, o1 + \" == \" + o2);\n+    }\n+\n+    static value class N {\n+        N l;\n+        N r;\n+        int id;\n+        N(N l, N r, int id) {\n+            this.l = l;\n+            this.r = r;\n+            this.id = id;\n+        }\n+    }\n+\n+    private static N build() {\n+        N n1 = new N(null, null, 0);\n+        N n2 = new N(null, null, 0);\n+        for (int id = 1; id < 100; ++id) {\n+            N l = new N(n1, n2, id);\n+            N r = new N(n1, n2, id);\n+            n1 = l;\n+            n2 = r;\n+        }\n+        return new N(n1, n2, 100);\n+    }\n+\n+    \/*\n+     * Throw SOE for large graph\n+     *\/\n+    @Test\n+    public void largeGraph() {\n+        N node = build();\n+        long start = System.nanoTime();\n+        assertThrows(StackOverflowError.class, () -> { boolean v = node.l == node.r; });\n+        System.out.format(\"testing large graph: %d ms%n\", (System.nanoTime() - start) \/ 1000);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/valhalla\/valuetypes\/RecursiveValueClass.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"}]}