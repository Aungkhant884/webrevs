{"files":[{"patch":"@@ -44,0 +44,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n@@ -71,1 +73,3 @@\n-        GetPropertyAction.privilegedGetProperty(\"value.bsm.debug\") != null;\n+            GetPropertyAction.privilegedGetProperty(\"value.bsm.debug\") != null;\n+    private static final int THRESHOLD =\n+            GetIntegerAction.privilegedGetProperty(\"jdk.value.threshold\", Integer.MAX_VALUE);\n@@ -75,5 +79,1 @@\n-        static MethodHandle[] getters(Class<?> type) {\n-            return getters(type, null);\n-        }\n-\n-        static MethodHandle[] getters(Class<?> type, Comparator<MethodHandle> comparator) {\n+        static Stream<MethodHandle> getterStream(Class<?> type, Comparator<MethodHandle> comparator) {\n@@ -93,1 +93,5 @@\n-            return s.toArray(MethodHandle[]::new);\n+            return s;\n+        }\n+\n+        static List<MethodHandle> getters(Class<?> type, Comparator<MethodHandle> comparator) {\n+            return getterStream(type, comparator).toList();\n@@ -129,1 +133,0 @@\n-\n@@ -151,0 +154,1 @@\n+         * @param counter an AtomicInteger counter to keep track of the traversal count\n@@ -155,1 +159,2 @@\n-                                        MethodHandle recur, Object o1, Object o2) throws Throwable {\n+                                        MethodHandle recur, Object o1, Object o2,\n+                                        AtomicInteger counter) throws Throwable {\n@@ -161,0 +166,4 @@\n+            if (counter.getAndDecrement() == 0) {\n+                throw new StackOverflowError(\"fail to evaluate == for value class \" + type.getName());\n+            }\n+\n@@ -171,2 +180,8 @@\n-                    boolean substitutable = ftype == type ? (boolean) recur.invokeExact(f1, f2)\n-                                                          : isSubstitutable(f1, f2);\n+\n+                    boolean substitutable;\n+                    if (ftype == type) {\n+                        substitutable = (boolean)recur.invokeExact(f1, f2, counter);\n+                    } else {\n+                        MethodHandle recur2 = RECUR_METHOD_HANDLES.get(ftype);\n+                        substitutable = (boolean)recur2.invokeExact(f1, f2, counter);\n+                    }\n@@ -218,9 +233,1 @@\n-                List<Class<?>> nodes = unvisitedEdges.computeIfAbsent(c, k -> {\n-                    List<Class<?>> fieldTypes = new ArrayList<>();\n-                    Arrays.stream(k.getDeclaredFields())\n-                          .filter(f -> !Modifier.isStatic(f.getModifiers()))\n-                          .map(f -> f.getType())\n-                          .filter(ft -> isValueClass(ft) && !fieldTypes.contains(ft))\n-                          .forEach(fieldTypes::add);\n-                    return fieldTypes;\n-                });\n+                List<Class<?>> nodes = unvisitedEdges.computeIfAbsent(c, (k) -> fieldTypes(k));\n@@ -235,1 +242,19 @@\n-            return recursiveTypes;\n+\n+            if (recursiveTypes.isEmpty())\n+                return Set.of();\n+\n+            return Arrays.stream(type.getDeclaredFields())\n+                         .filter(f -> !Modifier.isStatic(f.getModifiers()))\n+                         .map(f -> f.getType())\n+                         .filter(recursiveTypes::contains)\n+                         .collect(Collectors.toSet());\n+        }\n+\n+        private static List<Class<?>> fieldTypes(Class<?> type) {\n+            List<Class<?>> result = new ArrayList<>();\n+            Arrays.stream(type.getDeclaredFields())\n+                  .filter(f -> !Modifier.isStatic(f.getModifiers()))\n+                  .map(f -> f.getType())\n+                  .filter(ft -> isValueClass(ft) && !result.contains(ft))\n+                  .forEach(result::add);\n+            return result;\n@@ -239,0 +264,5 @@\n+        private static ClassValue<MethodHandle> RECUR_METHOD_HANDLES = new ClassValue<>() {\n+            @Override protected MethodHandle computeValue(Class<?> type) {\n+                return MethodHandleBuilder.recurValueTypeEquals(type);\n+            }\n+        };\n@@ -242,1 +272,1 @@\n-         * are substitutable.\n+         * are substitutable.  The method type is (V, V)boolean.\n@@ -248,2 +278,15 @@\n-            if (inProgress.putIfAbsent(type, true) != null) {\n-                throw new StackOverflowError(\"cyclic class membership: \" + type.getName());\n+            try {\n+                if (inProgress.putIfAbsent(type, true) != null) {\n+                    throw new StackOverflowError(\"cyclic class membership: \" + type.getName());\n+                }\n+\n+                Set<Class<?>> recursiveTypes = recursiveValueTypes(type);\n+                if (recursiveTypes.isEmpty()) {\n+                    return valueTypeEquals(type, getters(type, TYPE_SORTER));\n+                } else {\n+                    MethodHandle target = recurValueTypeEquals(type, recursiveValueTypes(type));\n+                    return MethodHandles.insertArguments(target, 2, new AtomicInteger(THRESHOLD))\n+                                        .asType(methodType(boolean.class, type, type));\n+                }\n+            } finally {\n+                inProgress.remove(type);\n@@ -251,0 +294,9 @@\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if the given fields\n+         * of the two value objects are substitutable. The method type is (V, V)boolean\n+         *\/\n+        static MethodHandle valueTypeEquals(Class<?> type, List<MethodHandle> getters) {\n+            \/\/ ensure the reference type of a primitive class not used in the method handle\n+            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n@@ -253,3 +305,0 @@\n-            MethodHandle[] getters = getters(type, TYPE_SORTER);;\n-            Set<Class<?>> recursiveTypes = recursiveValueTypes(type);\n-            try {\n@@ -259,1 +308,0 @@\n-                List<MethodHandle> recursiveTypeGetters = new ArrayList<>();\n@@ -262,5 +310,0 @@\n-                    if (recursiveTypes.contains(ftype)) {\n-                        \/\/ skip the value class that is involved in a cyclic membership\n-                        recursiveTypeGetters.add(getter);\n-                        continue;\n-                    }\n@@ -274,17 +317,18 @@\n-                MethodHandle target = guardWithTest(IS_NULL.asType(mt),\n-                                                    instanceTrue,\n-                                                    guardWithTest(IS_SAME_VALUE_CLASS.asType(mt),\n-                                                                  accumulator,\n-                                                                  instanceFalse));\n-                if (recursiveTypeGetters.isEmpty()) {\n-                    return target;\n-                } else {\n-                    \/\/ This value class contains cyclic membership\n-                    \/\/ Create a method handle that is capable of calling itself.\n-                    \/\/ - the base method first calls the method handle that tests the substitutability of\n-                    \/\/   all fields that are not a recursive data type\n-                    \/\/ - for a field of its own type, call the recursive method\n-                    \/\/ - for a field of a recursive data type, call isSubstitutable\n-                    Object[] arguments = new Object[] { type, target, recursiveTypeGetters.toArray(MethodHandle[]::new) };\n-                    MethodHandle recur = MethodHandles.insertArguments(RECUR_EQUALS, 0, arguments);\n-                    return recursive(recur).asType(mt);\n+                return guardWithTest(IS_NULL.asType(mt),\n+                                     instanceTrue,\n+                                     guardWithTest(IS_SAME_VALUE_CLASS.asType(mt),\n+                                                   accumulator,\n+                                                   instanceFalse));\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns boolean if two value objects of\n+         * a recursive data type are substitutable.  This method is invoked by\n+         * the base method.\n+         *\n+         * The method type is (Object, Object, AtomicInteger)boolean.\n+         *\/\n+        static MethodHandle recurValueTypeEquals(Class<?> type) {\n+            try {\n+                if (inProgress.putIfAbsent(type, true) != null) {\n+                    throw new StackOverflowError(\"cyclic class membership: \" + type.getName());\n@@ -292,0 +336,1 @@\n+                return recurValueTypeEquals(type, recursiveValueTypes(type));\n@@ -297,0 +342,36 @@\n+        \/*\n+         * Produces a MethodHandle that returns boolean if two value objects of\n+         * a recursive data type are substitutable.\n+         *\n+         * The method type is (Object, Object, AtomicInteger)boolean.\n+         *\/\n+        static MethodHandle recurValueTypeEquals(Class<?> type, Set<Class<?>> recursiveTypes) {\n+            Stream<MethodHandle> getterStream = getterStream(type, TYPE_SORTER);;\n+            List<MethodHandle> nonRecurTypeGetters = new ArrayList<>();\n+            List<MethodHandle> recurTypeGetters = new ArrayList<>();\n+            getterStream.forEach(getter -> {\n+                Class<?> ftype = fieldType(getter);\n+                if (recursiveTypes.contains(ftype)) {\n+                    \/\/ skip the value class that is involved in a cyclic membership\n+                    recurTypeGetters.add(getter);\n+                } else {\n+                    nonRecurTypeGetters.add(getter);\n+                }\n+            });\n+\n+            if (recurTypeGetters.isEmpty()) {\n+                throw new InternalError(\"must be a recursive data type: \" + type.getName());\n+            }\n+\n+            MethodHandle target = valueTypeEquals(type, nonRecurTypeGetters);\n+            \/\/ This value class contains cyclic membership\n+            \/\/ Create a method handle that is capable of calling itself.\n+            \/\/ - the base method first calls the method handle that tests the substitutability of\n+            \/\/   all fields that are not a recursive data type\n+            \/\/ - for a field of its own type, call the recursive method\n+            \/\/ - for a field of a recursive data type, call isSubstitutable\n+            Object[] arguments = new Object[]{type, target, recurTypeGetters.toArray(MethodHandle[]::new)};\n+            target = MethodHandles.insertArguments(RECUR_EQUALS, 0, arguments);\n+            return recursive(target);\n+        }\n+\n@@ -310,1 +391,1 @@\n-            MethodHandle[] getters = MethodHandleBuilder.getters(type);\n+            MethodHandle[] getters = getterStream(type, null).toArray(MethodHandle[]::new);\n@@ -409,1 +490,1 @@\n-                                                MethodHandle.class, Object.class, Object.class));\n+                                                MethodHandle.class, Object.class, Object.class, AtomicInteger.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":133,"deletions":52,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run junit\/othervm -XX:TieredStopAtLevel=1 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses RecursiveValueClass\n+ * @run junit\/othervm -XX:TieredStopAtLevel=1 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Djdk.value.threshold=1000000 RecursiveValueClass\n@@ -34,1 +34,1 @@\n- * @run junit\/othervm -Xcomp -XX:+EnableValhalla -XX:+EnablePrimitiveClasses RecursiveValueClass\n+ * @run junit\/othervm -Xcomp -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Djdk.value.threshold=1000000 RecursiveValueClass\n@@ -37,0 +37,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -174,0 +175,34 @@\n+\n+    static value class N {\n+        N l;\n+        N r;\n+        int id;\n+        N(N l, N r, int id) {\n+            this.l = l;\n+            this.r = r;\n+            this.id = id;\n+        }\n+    }\n+\n+    private static N build() {\n+        N n1 = new N(null, null, 0);\n+        N n2 = new N(null, null, 0);\n+        for (int id = 1; id < 100; ++id) {\n+            N l = new N(n1, n2, id);\n+            N r = new N(n1, n2, id);\n+            n1 = l;\n+            n2 = r;\n+        }\n+        return new N(n1, n2, 100);\n+    }\n+\n+    \/*\n+     * Throw SOE for large graph\n+     *\/\n+    @Test\n+    public void largeGraph() {\n+        N node = build();\n+        long start = System.nanoTime();\n+        assertThrows(StackOverflowError.class, () -> { boolean v = node.l == node.r; });\n+        System.out.format(\"testing large graph: %d ms%n\", (System.nanoTime() - start) \/ 1000);\n+    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/RecursiveValueClass.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"}]}