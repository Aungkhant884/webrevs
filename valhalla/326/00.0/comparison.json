{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/tlab_globals.hpp\"\n@@ -2265,1 +2266,0 @@\n-  Label profile_method;\n@@ -2294,68 +2294,14 @@\n-    if (TieredCompilation) {\n-      Label no_mdo;\n-      int increment = InvocationCounter::count_increment;\n-      if (ProfileInterpreter) {\n-        \/\/ Are we profiling?\n-        __ movptr(rbx, Address(rcx, in_bytes(Method::method_data_offset())));\n-        __ testptr(rbx, rbx);\n-        __ jccb(Assembler::zero, no_mdo);\n-        \/\/ Increment the MDO backedge counter\n-        const Address mdo_backedge_counter(rbx, in_bytes(MethodData::backedge_counter_offset()) +\n-                                           in_bytes(InvocationCounter::counter_offset()));\n-        const Address mask(rbx, in_bytes(MethodData::backedge_mask_offset()));\n-        __ increment_mask_and_jump(mdo_backedge_counter, increment, mask, rax, false, Assembler::zero,\n-                                   UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n-        __ jmp(dispatch);\n-      }\n-      __ bind(no_mdo);\n-      \/\/ Increment backedge counter in MethodCounters*\n-      __ movptr(rcx, Address(rcx, Method::method_counters_offset()));\n-      const Address mask(rcx, in_bytes(MethodCounters::backedge_mask_offset()));\n-      __ increment_mask_and_jump(Address(rcx, be_offset), increment, mask,\n-                                 rax, false, Assembler::zero,\n-                                 UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n-    } else { \/\/ not TieredCompilation\n-      \/\/ increment counter\n-      __ movptr(rcx, Address(rcx, Method::method_counters_offset()));\n-      __ movl(rax, Address(rcx, be_offset));        \/\/ load backedge counter\n-      __ incrementl(rax, InvocationCounter::count_increment); \/\/ increment counter\n-      __ movl(Address(rcx, be_offset), rax);        \/\/ store counter\n-\n-      __ movl(rax, Address(rcx, inv_offset));    \/\/ load invocation counter\n-\n-      __ andl(rax, InvocationCounter::count_mask_value); \/\/ and the status bits\n-      __ addl(rax, Address(rcx, be_offset));        \/\/ add both counters\n-\n-      if (ProfileInterpreter) {\n-        \/\/ Test to see if we should create a method data oop\n-        __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_profile_limit_offset())));\n-        __ jcc(Assembler::less, dispatch);\n-\n-        \/\/ if no method data exists, go to profile method\n-        __ test_method_data_pointer(rax, profile_method);\n-\n-        if (UseOnStackReplacement) {\n-          \/\/ check for overflow against rbx which is the MDO taken count\n-          __ cmp32(rbx, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));\n-          __ jcc(Assembler::below, dispatch);\n-\n-          \/\/ When ProfileInterpreter is on, the backedge_count comes\n-          \/\/ from the MethodData*, which value does not get reset on\n-          \/\/ the call to frequency_counter_overflow().  To avoid\n-          \/\/ excessive calls to the overflow routine while the method is\n-          \/\/ being compiled, add a second test to make sure the overflow\n-          \/\/ function is called only once every overflow_frequency.\n-          const int overflow_frequency = 1024;\n-          __ andl(rbx, overflow_frequency - 1);\n-          __ jcc(Assembler::zero, backedge_counter_overflow);\n-\n-        }\n-      } else {\n-        if (UseOnStackReplacement) {\n-          \/\/ check for overflow against rax, which is the sum of the\n-          \/\/ counters\n-          __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));\n-          __ jcc(Assembler::aboveEqual, backedge_counter_overflow);\n-\n-        }\n-      }\n+    Label no_mdo;\n+    int increment = InvocationCounter::count_increment;\n+    if (ProfileInterpreter) {\n+      \/\/ Are we profiling?\n+      __ movptr(rbx, Address(rcx, in_bytes(Method::method_data_offset())));\n+      __ testptr(rbx, rbx);\n+      __ jccb(Assembler::zero, no_mdo);\n+      \/\/ Increment the MDO backedge counter\n+      const Address mdo_backedge_counter(rbx, in_bytes(MethodData::backedge_counter_offset()) +\n+          in_bytes(InvocationCounter::counter_offset()));\n+      const Address mask(rbx, in_bytes(MethodData::backedge_mask_offset()));\n+      __ increment_mask_and_jump(mdo_backedge_counter, increment, mask, rax, false, Assembler::zero,\n+          UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+      __ jmp(dispatch);\n@@ -2363,0 +2309,6 @@\n+    __ bind(no_mdo);\n+    \/\/ Increment backedge counter in MethodCounters*\n+    __ movptr(rcx, Address(rcx, Method::method_counters_offset()));\n+    const Address mask(rcx, in_bytes(MethodCounters::backedge_mask_offset()));\n+    __ increment_mask_and_jump(Address(rcx, be_offset), increment, mask,\n+        rax, false, Assembler::zero, UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n@@ -2376,8 +2328,1 @@\n-    if (ProfileInterpreter && !TieredCompilation) {\n-      \/\/ Out-of-line code to allocate method data oop.\n-      __ bind(profile_method);\n-      __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));\n-      __ set_method_data_pointer_for_bcp();\n-      __ jmp(dispatch);\n-    }\n-\n+      Label set_mdp;\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":23,"deletions":78,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -969,1 +970,0 @@\n-    x->as_NewInlineTypeInstance()->decrement_on_stack_count();\n@@ -998,1 +998,0 @@\n-  x->set_local_index(index);\n@@ -1002,1 +1001,0 @@\n-    x->as_NewInlineTypeInstance()->decrement_on_stack_count();\n@@ -1034,0 +1032,1 @@\n+    bool can_delay_access = false;\n@@ -1038,0 +1037,8 @@\n+      bool will_link;\n+      ciField* next_field = s.get_field(will_link);\n+      bool next_needs_patching = !next_field->holder()->is_loaded() ||\n+                                 !next_field->will_link(method(), Bytecodes::_getfield) ||\n+                                 PatchALot;\n+      can_delay_access = !next_needs_patching;\n+    }\n+    if (can_delay_access) {\n@@ -1059,6 +1066,6 @@\n-  }\n-  if (profile_array_accesses() && is_reference_type(type) && !array->is_loaded_flattened_array()) {\n-    compilation()->set_would_profile(true);\n-    load_indexed->set_should_profile(true);\n-    load_indexed->set_profiled_method(method());\n-    load_indexed->set_profiled_bci(bci());\n+    if (profile_array_accesses() && is_reference_type(type)) {\n+      compilation()->set_would_profile(true);\n+      load_indexed->set_should_profile(true);\n+      load_indexed->set_profiled_method(method());\n+      load_indexed->set_profiled_bci(bci());\n+    }\n@@ -1067,1 +1074,1 @@\n-  assert(!(profile_array_accesses() && is_reference_type(type)) || load_indexed == result, \"should not be optimized out\");\n+  assert(!load_indexed->should_profile() || load_indexed == result, \"should not be optimized out\");\n@@ -1090,1 +1097,0 @@\n-  value->set_escaped();\n@@ -1110,1 +1116,1 @@\n-  if (profile_array_accesses() && is_reference_type(type)) {\n+  if (profile_array_accesses() && is_reference_type(type) && !array->is_loaded_flattened_array()) {\n@@ -1119,1 +1125,0 @@\n-\n@@ -1766,3 +1771,1 @@\n-void GraphBuilder::copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off,\n-                                       ValueStack* state_before, bool needs_patching) {\n-  assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+void GraphBuilder::copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off, ValueStack* state_before) {\n@@ -1770,1 +1773,0 @@\n-  src->set_escaped();\n@@ -1775,1 +1777,1 @@\n-    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);\n+    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n@@ -1777,1 +1779,1 @@\n-    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);\n+    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n@@ -1822,1 +1824,1 @@\n-  const int offset = !needs_patching ? field->offset() : -1;\n+  int offset = !needs_patching ? field->offset() : -1;\n@@ -1850,1 +1852,0 @@\n-      val->set_escaped();\n@@ -1916,1 +1917,0 @@\n-          LoadField* load;\n@@ -1919,3 +1919,4 @@\n-            load = new LoadField(pending_field_access()->obj(),\n-                                 pending_field_access()->offset() + offset - field->holder()->as_inline_klass()->first_field_offset(),\n-                                 field, false, state_before, needs_patching);\n+            obj = pending_field_access()->obj();\n+            offset += pending_field_access()->offset() - field->holder()->as_inline_klass()->first_field_offset();\n+            field = pending_field_access()->holder()->get_field_by_offset(offset, false);\n+            assert(field != NULL, \"field not found\");\n@@ -1931,2 +1932,1 @@\n-          } else {\n-            load = new LoadField(obj, offset, field, false, state_before, needs_patching);\n+          LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);\n@@ -1966,1 +1966,1 @@\n-                                       !next_field->will_link(method(), code) ||\n+                                       !next_field->will_link(method(), Bytecodes::_getfield) ||\n@@ -1974,1 +1974,1 @@\n-              pending_field_access()->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n+              pending_field_access()->inc_offset(offset - field->holder()->as_inline_klass()->first_field_offset());\n@@ -1977,1 +1977,1 @@\n-              DelayedFieldAccess* dfa = new DelayedFieldAccess(obj, field, field->offset());\n+              DelayedFieldAccess* dfa = new DelayedFieldAccess(obj, field->holder(), field->offset());\n@@ -2004,0 +2004,1 @@\n+              assert(!needs_patching, \"Can't patch flattened inline type field access\");\n@@ -2007,2 +2008,1 @@\n-                                    new_instance, inline_klass->first_field_offset(),\n-                                    state_before, needs_patching);\n+                                    new_instance, inline_klass->first_field_offset(), state_before);\n@@ -2011,2 +2011,1 @@\n-                copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(),\n-                                    state_before, needs_patching);\n+                copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(), state_before);\n@@ -2022,1 +2021,0 @@\n-      val->set_escaped();\n@@ -2047,0 +2045,1 @@\n+        assert(!needs_patching, \"Can't patch flattened inline type field access\");\n@@ -2048,1 +2047,1 @@\n-        copy_inline_content(inline_klass, val, inline_klass->first_field_offset(), obj, offset, state_before, needs_patching);\n+        copy_inline_content(inline_klass, val, inline_klass->first_field_offset(), obj, offset, state_before);\n@@ -2061,0 +2060,4 @@\n+  \/\/ Save the entire state and re-execute on deopt\n+  ValueStack* state_before = copy_state_before();\n+  state_before->set_should_reexecute(true);\n+\n@@ -2066,0 +2069,2 @@\n+  Value val = pop(type);\n+  Value obj = apop();\n@@ -2067,17 +2072,2 @@\n-  \/\/ call will_link again to determine if the field is valid.\n-  const bool needs_patching = !holder->is_loaded() ||\n-                              !field_modify->will_link(method(), Bytecodes::_withfield) ||\n-                              PatchALot;\n-\n-  scope()->set_wrote_final();\n-  scope()->set_wrote_fields();\n-\n-  const int offset = !needs_patching ? field_modify->offset() : -1;\n-\n-  ValueStack* state_before = copy_state_before();\n-  if (!holder->is_loaded()\n-      || needs_patching \/* FIXME: 8228634 - field_modify->will_link() may incorrectly return false *\/\n-      ) {\n-    Value val = pop(type);\n-    Value obj = apop();\n-    apush(append_split(new WithField(state_before)));\n+  if (!holder->is_loaded()) {\n+    apush(append_split(new Deoptimize(state_before)));\n@@ -2087,3 +2077,0 @@\n-  Value val = pop(type);\n-  Value obj = apop();\n-\n@@ -2091,5 +2078,14 @@\n-      CheckCast* c = new CheckCast(field_modify->type()->as_klass(), val, copy_state_before(), field_modify->type()->as_inline_klass() != NULL);\n-      append_split(c);\n-      c->set_incompatible_class_change_check();\n-      c->set_direct_compare(field_modify->type()->as_instance_klass()->is_final());\n-    }\n+    CheckCast* c = new CheckCast(field_modify->type()->as_klass(), val, copy_state_before(), field_modify->type()->as_inline_klass() != NULL);\n+    append_split(c);\n+    c->set_incompatible_class_change_check();\n+    c->set_direct_compare(field_modify->type()->as_instance_klass()->is_final());\n+  }\n+\n+  \/\/ call will_link again to determine if the field is valid.\n+  const bool needs_patching = !field_modify->will_link(method(), Bytecodes::_withfield) ||\n+                              (!field_modify->is_flattened() && PatchALot);\n+  const int offset_modify = !needs_patching ? field_modify->offset() : -1;\n+  assert(holder->is_inlinetype(), \"must be an inline klass\");\n+\n+  scope()->set_wrote_final();\n+  scope()->set_wrote_fields();\n@@ -2097,3 +2093,0 @@\n-  assert(holder->is_inlinetype(), \"must be a value klass\");\n-  \/\/ Save the entire state and re-execute on deopt when executing withfield\n-  state_before->set_should_reexecute(true);\n@@ -2109,0 +2102,1 @@\n+    \/\/ Initialize fields which are not modified\n@@ -2111,3 +2105,3 @@\n-      int off = field->offset();\n-\n-      if (field->offset() != offset) {\n+      int offset = field->offset();\n+      \/\/ Don't use offset_modify here, it might be set to -1 if needs_patching\n+      if (offset != field_modify->offset()) {\n@@ -2117,1 +2111,1 @@\n-            copy_inline_content(vk, obj, off, new_instance, vk->first_field_offset(), state_before, needs_patching);\n+            copy_inline_content(vk, obj, offset, new_instance, vk->first_field_offset(), state_before);\n@@ -2120,2 +2114,1 @@\n-          \/\/ Only load those fields who are not modified\n-          LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);\n+          LoadField* load = new LoadField(obj, offset, field, false, state_before, false);\n@@ -2123,1 +2116,1 @@\n-          StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);\n+          StoreField* store = new StoreField(new_instance, offset, field, replacement, false, state_before, false);\n@@ -2131,1 +2124,1 @@\n-  if (field_modify->type()->basic_type() == T_BOOLEAN) {\n+  if (field_type == T_BOOLEAN) {\n@@ -2136,0 +2129,1 @@\n+    assert(!needs_patching, \"Can't patch flattened inline type field access\");\n@@ -2138,1 +2132,1 @@\n-      copy_inline_content(vk, val, vk->first_field_offset(), new_instance, field_modify->offset(), state_before, needs_patching);\n+      copy_inline_content(vk, val, vk->first_field_offset(), new_instance, offset_modify, state_before);\n@@ -2141,1 +2135,1 @@\n-    StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);\n+    StoreField* store = new StoreField(new_instance, offset_modify, field_modify, val, false, state_before, needs_patching);\n@@ -2485,7 +2479,0 @@\n-  if (recv != NULL) {\n-    recv->set_escaped();\n-  }\n-  for (int i=0; i<args->length(); i++) {\n-    args->at(0)->set_escaped();\n-  }\n-\n@@ -2527,2 +2514,1 @@\n-    ValueStack* state_before = copy_state_before();\n-    apush(append_split(new DefaultValue(state_before)));\n+    apush(append_split(new Deoptimize(copy_state_before())));\n@@ -4161,1 +4147,1 @@\n-  if (CompilationPolicy::policy()->should_not_inline(compilation()->env(), callee)) {\n+  if (CompilationPolicy::should_not_inline(compilation()->env(), callee)) {\n@@ -4232,1 +4218,1 @@\n-    if (callee->name() == ciSymbol::object_initializer_name() &&\n+    if (callee->name() == ciSymbols::object_initializer_name() &&\n@@ -4545,1 +4531,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":73,"deletions":87,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -57,0 +57,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -70,0 +71,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -466,0 +468,4 @@\n+  \/\/ Check if array access profiling is enabled\n+  if (vfst.nm()->comp_level() != CompLevel_full_profile || !C1UpdateMethodData) {\n+    return;\n+  }\n@@ -512,1 +518,1 @@\n-                         SystemDictionary::ValueBootstrapMethods_klass(),\n+                         vmClasses::ValueBootstrapMethods_klass(),\n@@ -589,1 +595,1 @@\n-  osr_nm = CompilationPolicy::policy()->event(enclosing_method, method, branch_bci, bci, level, nm, THREAD);\n+  osr_nm = CompilationPolicy::event(enclosing_method, method, branch_bci, bci, level, nm, THREAD);\n@@ -650,5 +656,14 @@\n-#ifdef ASSERT\n-  \/\/ Check that exception is a subclass of Throwable, otherwise we have a VerifyError\n-  if (!(exception->is_a(SystemDictionary::Throwable_klass()))) {\n-    if (ExitVMOnVerifyError) vm_exit(-1);\n-    ShouldNotReachHere();\n+  \/\/ Check that exception is a subclass of Throwable\n+  assert(exception->is_a(vmClasses::Throwable_klass()),\n+         \"Exception not subclass of Throwable\");\n+\n+  \/\/ debugging support\n+  \/\/ tracing\n+  if (log_is_enabled(Info, exceptions)) {\n+    ResourceMark rm;\n+    stringStream tempst;\n+    assert(nm->method() != NULL, \"Unexpected NULL method()\");\n+    tempst.print(\"C1 compiled method <%s>\\n\"\n+                 \" at PC\" INTPTR_FORMAT \" for thread \" INTPTR_FORMAT,\n+                 nm->method()->print_value_string(), p2i(pc), p2i(thread));\n+    Exceptions::log_exception(exception, tempst.as_string());\n@@ -657,1 +672,2 @@\n-#endif\n+  \/\/ for AbortVMOnException flag\n+  Exceptions::debug_check_abort(exception);\n@@ -705,14 +721,0 @@\n-    \/\/ debugging support\n-    \/\/ tracing\n-    if (log_is_enabled(Info, exceptions)) {\n-      ResourceMark rm;\n-      stringStream tempst;\n-      assert(nm->method() != NULL, \"Unexpected NULL method()\");\n-      tempst.print(\"compiled method <%s>\\n\"\n-                   \" at PC\" INTPTR_FORMAT \" for thread \" INTPTR_FORMAT,\n-                   nm->method()->print_value_string(), p2i(pc), p2i(thread));\n-      Exceptions::log_exception(exception, tempst.as_string());\n-    }\n-    \/\/ for AbortVMOnException flag\n-    Exceptions::debug_check_abort(exception);\n-\n@@ -764,1 +766,1 @@\n-  DEBUG_ONLY(ResetNoHandleMark rnhm);\n+  DEBUG_ONLY(NoHandleMark nhm);\n@@ -1476,1 +1478,0 @@\n-\n@@ -1495,1 +1496,0 @@\n-\n@@ -1514,1 +1514,0 @@\n-\n@@ -1534,5 +1533,6 @@\n-\/\/\n-\/\/ NOTE: we are still in Java\n-\/\/\n-  Thread* THREAD = thread;\n-  debug_only(NoHandleMark nhm;)\n+  \/\/\n+  \/\/ NOTE: we are still in Java\n+  \/\/\n+  \/\/ Handles created in this function will be deleted by the\n+  \/\/ HandleMarkCleaner in the transition to the VM.\n+  NoHandleMark nhm;\n@@ -1541,1 +1541,0 @@\n-\n@@ -1574,2 +1573,0 @@\n-  assert(!TieredCompilation, \"incompatible with tiered compilation\");\n-\n@@ -1593,1 +1590,1 @@\n-      assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n+      assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":34,"deletions":37,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -29,1 +30,2 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -245,1 +248,1 @@\n-  if (holder->name() == ciSymbol::java_lang_System())\n+  if (holder->name() == ciSymbols::java_lang_System())\n@@ -269,1 +272,1 @@\n-  if (holder->name() == ciSymbol::java_lang_String())\n+  if (holder->name() == ciSymbols::java_lang_String())\n@@ -273,4 +276,4 @@\n-  if (holder->name() == ciSymbol::java_util_concurrent_atomic_AtomicIntegerFieldUpdater_Impl() ||\n-      holder->name() == ciSymbol::java_util_concurrent_atomic_AtomicLongFieldUpdater_CASUpdater() ||\n-      holder->name() == ciSymbol::java_util_concurrent_atomic_AtomicLongFieldUpdater_LockedUpdater() ||\n-      holder->name() == ciSymbol::java_util_concurrent_atomic_AtomicReferenceFieldUpdater_Impl()) {\n+  if (holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicIntegerFieldUpdater_Impl() ||\n+      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicLongFieldUpdater_CASUpdater() ||\n+      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicLongFieldUpdater_LockedUpdater() ||\n+      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicReferenceFieldUpdater_Impl()) {\n@@ -310,2 +313,2 @@\n-      assert(SystemDictionary::System_klass() != NULL, \"Check once per vm\");\n-      if (field_holder == SystemDictionary::System_klass()) {\n+      assert(vmClasses::System_klass() != NULL, \"Check once per vm\");\n+      if (field_holder == vmClasses::System_klass()) {\n@@ -329,2 +332,2 @@\n-    assert(SystemDictionary::CallSite_klass() != NULL, \"should be already initialized\");\n-    if (field_holder == SystemDictionary::CallSite_klass() &&\n+    assert(vmClasses::CallSite_klass() != NULL, \"should be already initialized\");\n+    if (field_holder == vmClasses::CallSite_klass() &&\n@@ -458,0 +461,18 @@\n+bool ciField::is_call_site_target() {\n+  ciInstanceKlass* callsite_klass = CURRENT_ENV->CallSite_klass();\n+  if (callsite_klass == NULL)\n+    return false;\n+  return (holder()->is_subclass_of(callsite_klass) && (name() == ciSymbols::target_name()));\n+}\n+\n+bool ciField::is_autobox_cache() {\n+  ciSymbol* klass_name = holder()->name();\n+  return (name() == ciSymbols::cache_field_name() &&\n+          holder()->uses_default_loader() &&\n+          (klass_name == ciSymbols::java_lang_Character_CharacterCache() ||\n+            klass_name == ciSymbols::java_lang_Byte_ByteCache() ||\n+            klass_name == ciSymbols::java_lang_Short_ShortCache() ||\n+            klass_name == ciSymbols::java_lang_Integer_IntegerCache() ||\n+            klass_name == ciSymbols::java_lang_Long_LongCache()));\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -190,6 +190,1 @@\n-  bool is_call_site_target() {\n-    ciInstanceKlass* callsite_klass = CURRENT_ENV->CallSite_klass();\n-    if (callsite_klass == NULL)\n-      return false;\n-    return (holder()->is_subclass_of(callsite_klass) && (name() == ciSymbol::target_name()));\n-  }\n+  bool is_call_site_target();\n@@ -197,10 +192,1 @@\n-  bool is_autobox_cache() {\n-    ciSymbol* klass_name = holder()->name();\n-    return (name() == ciSymbol::cache_field_name() &&\n-            holder()->uses_default_loader() &&\n-            (klass_name == ciSymbol::java_lang_Character_CharacterCache() ||\n-             klass_name == ciSymbol::java_lang_Byte_ByteCache() ||\n-             klass_name == ciSymbol::java_lang_Short_ShortCache() ||\n-             klass_name == ciSymbol::java_lang_Integer_IntegerCache() ||\n-             klass_name == ciSymbol::java_lang_Long_LongCache()));\n-  }\n+  bool is_autobox_cache();\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -141,1 +142,3 @@\n-#define CONSTANT_CLASS_DESCRIPTORS        60\n+#define JAVA_17_VERSION                   61\n+\n+#define CONSTANT_CLASS_DESCRIPTORS        61\n@@ -1143,0 +1146,1 @@\n+    _jdk_internal_ValueBased,\n@@ -1150,1 +1154,1 @@\n-    : _location(location), _annotations_present(0)\n+    : _location(location), _annotations_present(0), _contended_group(0)\n@@ -2306,0 +2310,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_ValueBased_signature): {\n+      if (_location != _in_class)   break;  \/\/ only allow for classes\n+      if (!privileged)              break;  \/\/ only allow in priviledged code\n+      return _jdk_internal_ValueBased;\n+    }\n@@ -2349,1 +2358,10 @@\n-  ik->set_is_contended(is_contended());\n+  if (has_annotation(_jdk_internal_vm_annotation_Contended)) {\n+    ik->set_is_contended(is_contended());\n+  }\n+  if (has_annotation(_jdk_internal_ValueBased)) {\n+    ik->set_has_value_based_class_annotation();\n+    if (DiagnoseSyncOnValueBasedClasses) {\n+      ik->set_is_value_based();\n+      ik->set_prototype_header(markWord::prototype());\n+    }\n+  }\n@@ -2872,1 +2890,1 @@\n-      if (!SystemDictionary::Parameter_klass_loaded())\n+      if (!vmClasses::Parameter_klass_loaded())\n@@ -3561,4 +3579,0 @@\n-  if (length < 1) {\n-    classfile_parse_error(\"PermittedSubclasses attribute is empty in class file %s\", THREAD);\n-    return 0;\n-  }\n@@ -3569,9 +3583,12 @@\n-  int index = 0;\n-  cfs->guarantee_more(2 * length, CHECK_0);\n-  for (int n = 0; n < length; n++) {\n-    const u2 class_info_index = cfs->get_u2_fast();\n-    check_property(\n-      valid_klass_reference_at(class_info_index),\n-      \"Permitted subclass class_info_index %u has bad constant type in class file %s\",\n-      class_info_index, CHECK_0);\n-    permitted_subclasses->at_put(index++, class_info_index);\n+  if (length > 0) {\n+    int index = 0;\n+    cfs->guarantee_more(2 * length, CHECK_0);\n+    for (int n = 0; n < length; n++) {\n+      const u2 class_info_index = cfs->get_u2_fast();\n+      check_property(\n+        valid_klass_reference_at(class_info_index),\n+        \"Permitted subclass class_info_index %u has bad constant type in class file %s\",\n+        class_info_index, CHECK_0);\n+      permitted_subclasses->at_put(index++, class_info_index);\n+    }\n+    assert(index == size, \"wrong size\");\n@@ -3579,1 +3596,0 @@\n-  assert(index == size, \"wrong size\");\n@@ -4523,2 +4539,2 @@\n-  if (SystemDictionary::Cloneable_klass_loaded()) {\n-    if (ik->is_subtype_of(SystemDictionary::Cloneable_klass())) {\n+  if (vmClasses::Cloneable_klass_loaded()) {\n+    if (ik->is_subtype_of(vmClasses::Cloneable_klass())) {\n@@ -4643,1 +4659,1 @@\n-    if (length == 1 && result->at(0) == SystemDictionary::IdentityObject_klass()) {\n+    if (length == 1 && result->at(0) == vmClasses::IdentityObject_klass()) {\n@@ -5222,1 +5238,1 @@\n-          SystemDictionary::Character_klass(),\n+          vmClasses::Character_klass(),\n@@ -5230,1 +5246,1 @@\n-          SystemDictionary::Character_klass(),\n+          vmClasses::Character_klass(),\n@@ -5603,1 +5619,1 @@\n-      for (int id = vmIntrinsics::FIRST_ID; id < (int)vmIntrinsics::ID_LIMIT; ++id) {\n+      for (auto id : EnumRange<vmIntrinsicID>{}) {\n@@ -5611,1 +5627,1 @@\n-        if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {\n+        if (vmIntrinsics::class_for(id) == klass_id) {\n@@ -5627,2 +5643,1 @@\n-                        vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),\n-                                                             buf, sizeof(buf)),\n+                        vmIntrinsics::short_name_as_C_string(id, buf, sizeof(buf)),\n@@ -6632,1 +6647,1 @@\n-  if (_super_class_index > 0 && NULL ==_super_klass) {\n+  if (_super_class_index > 0 && NULL == _super_klass) {\n@@ -6704,1 +6719,1 @@\n-    _temp_local_interfaces->append(SystemDictionary::IdentityObject_klass());\n+    _temp_local_interfaces->append(vmClasses::IdentityObject_klass());\n@@ -6710,1 +6725,1 @@\n-  } else if (itfs_len == 1 && _temp_local_interfaces->at(0) == SystemDictionary::IdentityObject_klass()) {\n+  } else if (itfs_len == 1 && _temp_local_interfaces->at(0) == vmClasses::IdentityObject_klass()) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":46,"deletions":31,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -255,0 +255,1 @@\n+  template(jdk_internal_ValueBased_signature,                                \"Ljdk\/internal\/ValueBased;\") \\\n@@ -357,0 +358,1 @@\n+  template(jdk_incubator_foreign_MemoryAccess,       \"jdk\/incubator\/foreign\/MemoryAccess\")        \\\n@@ -400,0 +402,1 @@\n+  template(refersTo0_name,                            \"refersTo0\")                                \\\n@@ -733,2 +736,0 @@\n-constexpr EnumRange<vmSymbolID> vmSymbolsRange; \/\/ the default range of all valid vmSymbolIDs\n-using vmSymbolsIterator = EnumIterator<vmSymbolID>; \/\/ convenience\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm_io.h\"\n@@ -29,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -49,1 +51,2 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n@@ -525,1 +528,1 @@\n-    if (!PENDING_EXCEPTION->is_a(SystemDictionary::Error_klass())) {\n+    if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n@@ -591,1 +594,1 @@\n-        assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())),\n+        assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())),\n@@ -638,1 +641,1 @@\n-                                 SystemDictionary::StackOverflowError_klass(),\n+                                 vmClasses::StackOverflowError_klass(),\n@@ -647,1 +650,1 @@\n-                                 SystemDictionary::StackOverflowError_klass(),\n+                                 vmClasses::StackOverflowError_klass(),\n@@ -764,7 +767,3 @@\n-#ifdef ASSERT\n-    \/\/ Check that exception is a subclass of Throwable, otherwise we have a VerifyError\n-    if (!(h_exception->is_a(SystemDictionary::Throwable_klass()))) {\n-      if (ExitVMOnVerifyError) vm_exit(-1);\n-      ShouldNotReachHere();\n-    }\n-#endif\n+    \/\/ Check that exception is a subclass of Throwable.\n+    assert(h_exception->is_a(vmClasses::Throwable_klass()),\n+           \"Exception not subclass of Throwable\");\n@@ -914,0 +913,4 @@\n+JRT_ENTRY(void, InterpreterRuntime::throw_NullPointerException(JavaThread* thread))\n+  THROW(vmSymbols::java_lang_NullPointerException());\n+JRT_END\n+\n@@ -1061,1 +1064,1 @@\n-  if (!exception->is_a(SystemDictionary::ThreadDeath_klass())) {\n+  if (!exception->is_a(vmClasses::ThreadDeath_klass())) {\n@@ -1063,1 +1066,1 @@\n-                       SystemDictionary::IllegalMonitorStateException_klass(),\n+                       vmClasses::IllegalMonitorStateException_klass(),\n@@ -1109,0 +1112,2 @@\n+  methodHandle resolved_method;\n+\n@@ -1114,13 +1119,4 @@\n-    if (JvmtiExport::can_hotswap_or_post_breakpoint()) {\n-      int retry_count = 0;\n-      while (info.resolved_method()->is_old()) {\n-        \/\/ It is very unlikely that method is redefined more than 100 times\n-        \/\/ in the middle of resolve. If it is looping here more than 100 times\n-        \/\/ means then there could be a bug here.\n-        guarantee((retry_count++ < 100),\n-                  \"Could not resolve to latest version of redefined method\");\n-        \/\/ method is redefined in the middle of resolve so re-try.\n-        LinkResolver::resolve_invoke(info, receiver, pool,\n-                                     last_frame.get_index_u2_cpcache(bytecode), bytecode,\n-                                     CHECK);\n-      }\n+    if (JvmtiExport::can_hotswap_or_post_breakpoint() && info.resolved_method()->is_old()) {\n+      resolved_method = methodHandle(THREAD, info.resolved_method()->get_new_method());\n+    } else {\n+      resolved_method = methodHandle(THREAD, info.resolved_method());\n@@ -1136,2 +1132,1 @@\n-    if (info.resolved_method()->method_holder() ==\n-                                            SystemDictionary::Object_klass()) {\n+    if (resolved_method->method_holder() == vmClasses::Object_klass()) {\n@@ -1142,2 +1137,1 @@\n-      Method* rm = info.resolved_method();\n-      assert(rm->is_final() || info.has_vtable_index(),\n+      assert(resolved_method->is_final() || info.has_vtable_index(),\n@@ -1145,1 +1139,1 @@\n-    } else if (!info.resolved_method()->has_itable_index()) {\n+    } else if (!resolved_method->has_itable_index()) {\n@@ -1151,1 +1145,1 @@\n-      int index = info.resolved_method()->itable_index();\n+      int index = resolved_method->itable_index();\n@@ -1166,1 +1160,0 @@\n-  methodHandle resolved_method(THREAD, info.resolved_method());\n@@ -1321,1 +1314,1 @@\n-  nmethod* osr_nm = CompilationPolicy::policy()->event(method, method, branch_bci, bci, CompLevel_none, NULL, THREAD);\n+  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, NULL, THREAD);\n@@ -1361,19 +1354,0 @@\n-JRT_ENTRY(void, InterpreterRuntime::profile_method(JavaThread* thread))\n-  \/\/ use UnlockFlagSaver to clear and restore the _do_not_unlock_if_synchronized\n-  \/\/ flag, in case this method triggers classloading which will call into Java.\n-  UnlockFlagSaver fs(thread);\n-\n-  assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  LastFrameAccessor last_frame(thread);\n-  assert(last_frame.is_interpreted_frame(), \"must come from interpreter\");\n-  methodHandle method(thread, last_frame.method());\n-  Method::build_interpreter_method_data(method, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    \/\/ Only metaspace OOM is expected. No Java code executed.\n-    assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n-    CLEAR_PENDING_EXCEPTION;\n-    \/\/ and fall through...\n-  }\n-JRT_END\n-\n-\n@@ -1433,1 +1407,1 @@\n-    assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n+    assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":30,"deletions":56,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+class CodeBuffer;\n+\n@@ -95,0 +97,2 @@\n+  static void    throw_NullPointerException(JavaThread* thread);\n+\n@@ -164,1 +168,0 @@\n-  static void    profile_method(JavaThread* thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -49,0 +51,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -211,1 +214,1 @@\n-        assert(holder->is_interface() || holder == SystemDictionary::Object_klass(), \"unexpected holder class\");\n+        assert(holder->is_interface() || holder == vmClasses::Object_klass(), \"unexpected holder class\");\n@@ -314,1 +317,1 @@\n-                (method->is_final() && method->method_holder() == SystemDictionary::Object_klass())))),\n+                (method->is_final() && method->method_holder() == vmClasses::Object_klass())))),\n@@ -485,1 +488,1 @@\n-  assert(PENDING_EXCEPTION->is_a(SystemDictionary::LinkageError_klass()),\n+  assert(PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass()),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -152,1 +154,1 @@\n-  if (SystemDictionary::ClassLoader_klass_loaded()) {\n+  if (vmClasses::ClassLoader_klass_loaded()) {\n@@ -155,1 +157,1 @@\n-      if (super_klass->is_subtype_of(SystemDictionary::ClassLoader_klass())) {\n+      if (super_klass->is_subtype_of(vmClasses::ClassLoader_klass())) {\n@@ -191,1 +193,1 @@\n-      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),\n+      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass()),\n@@ -209,1 +211,1 @@\n-        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),\n+        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass()),\n@@ -256,2 +258,0 @@\n-  \/\/ Check for a resolved cp entry, else fall back to a name check.\n-  \/\/ We don't want to resolve any class other than the one being checked.\n@@ -260,13 +260,4 @@\n-    if (_constants->tag_at(cp_index).is_klass()) {\n-      Klass* k2 = _constants->klass_at(cp_index, THREAD);\n-      assert(!HAS_PENDING_EXCEPTION, \"Unexpected exception\");\n-      if (k2 == k) {\n-        log_trace(class, sealed)(\"- class is listed at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n-        return true;\n-      }\n-    } else {\n-      Symbol* name = _constants->klass_name_at(cp_index);\n-      if (name == k->name()) {\n-        log_trace(class, sealed)(\"- Found it at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n-        return true;\n-      }\n+    Symbol* name = _constants->klass_name_at(cp_index);\n+    if (name == k->name()) {\n+      log_trace(class, sealed)(\"- Found it at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n+      return true;\n@@ -315,1 +306,1 @@\n-      if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+      if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n@@ -354,1 +345,1 @@\n-            if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+            if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n@@ -795,0 +786,6 @@\n+bool InstanceKlass::is_record() const {\n+  return _record_components != NULL &&\n+         is_final() &&\n+         java_super() == vmClasses::Record_klass();\n+}\n+\n@@ -797,2 +794,1 @@\n-         _permitted_subclasses != Universe::the_empty_short_array() &&\n-         _permitted_subclasses->length() > 0;\n+         _permitted_subclasses != Universe::the_empty_short_array();\n@@ -867,1 +863,1 @@\n-  ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);\n+  ObjectLocker ol(h_init_lock, THREAD);\n@@ -1059,1 +1055,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);\n+    ObjectLocker ol(h_init_lock, THREAD);\n@@ -1185,1 +1181,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);\n+    ObjectLocker ol(h_init_lock, THREAD);\n@@ -1341,1 +1337,1 @@\n-    if (e->is_a(SystemDictionary::Error_klass())) {\n+    if (e->is_a(vmClasses::Error_klass())) {\n@@ -1456,1 +1452,1 @@\n-void InstanceKlass::process_interfaces(Thread *thread) {\n+void InstanceKlass::process_interfaces() {\n@@ -1571,1 +1567,1 @@\n-  if (this == SystemDictionary::Class_klass()) {\n+  if (this == vmClasses::Class_klass()) {\n@@ -2717,1 +2713,1 @@\n-  _package_entry = NULL;\n+  init_shared_package_entry();\n@@ -2730,0 +2726,21 @@\n+void InstanceKlass::init_shared_package_entry() {\n+#if !INCLUDE_CDS_JAVA_HEAP\n+  _package_entry = NULL;\n+#else\n+  if (!MetaspaceShared::use_full_module_graph()) {\n+    _package_entry = NULL;\n+  } else if (DynamicDumpSharedSpaces) {\n+    if (!MetaspaceShared::is_in_shared_metaspace(_package_entry)) {\n+      _package_entry = NULL;\n+    }\n+  } else {\n+    if (is_shared_unregistered_class()) {\n+      _package_entry = NULL;\n+    } else {\n+      _package_entry = PackageEntry::get_archived_entry(_package_entry);\n+    }\n+  }\n+  ArchivePtrMarker::mark_pointer((address**)&_package_entry);\n+#endif\n+}\n+\n@@ -2777,0 +2794,6 @@\n+\n+  \/\/ Initialize @ValueBased class annotation\n+  if (DiagnoseSyncOnValueBasedClasses && has_value_based_class_annotation()) {\n+    set_is_value_based();\n+    set_prototype_header(markWord::prototype());\n+  }\n@@ -3011,0 +3034,9 @@\n+  if (is_shared() && _package_entry == pkg_entry) {\n+    if (MetaspaceShared::use_full_module_graph()) {\n+      \/\/ we can use the saved package\n+      return;\n+    } else {\n+      _package_entry = NULL;\n+    }\n+  }\n+\n@@ -3368,5 +3400,3 @@\n-  if (TieredCompilation) {\n-    nmethod* prev = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), n->comp_level(), true);\n-    assert(prev == NULL || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n-           \"redundant OSR recompilation detected. memory leak in CodeCache!\");\n-  }\n+  nmethod* prev = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), n->comp_level(), true);\n+  assert(prev == NULL || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n+      \"redundant OSR recompilation detected. memory leak in CodeCache!\");\n@@ -3375,10 +3405,5 @@\n-  {\n-    assert(n->is_osr_method(), \"wrong kind of nmethod\");\n-    n->set_osr_link(osr_nmethods_head());\n-    set_osr_nmethods_head(n);\n-    \/\/ Raise the highest osr level if necessary\n-    if (TieredCompilation) {\n-      Method* m = n->method();\n-      m->set_highest_osr_comp_level(MAX2(m->highest_osr_comp_level(), n->comp_level()));\n-    }\n-  }\n+  assert(n->is_osr_method(), \"wrong kind of nmethod\");\n+  n->set_osr_link(osr_nmethods_head());\n+  set_osr_nmethods_head(n);\n+  \/\/ Raise the highest osr level if necessary\n+  n->method()->set_highest_osr_comp_level(MAX2(n->method()->highest_osr_comp_level(), n->comp_level()));\n@@ -3387,6 +3412,4 @@\n-  if (TieredCompilation) {\n-    for (int l = CompLevel_limited_profile; l < n->comp_level(); l++) {\n-      nmethod *inv = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), l, true);\n-      if (inv != NULL && inv->is_in_use()) {\n-        inv->make_not_entrant();\n-      }\n+  for (int l = CompLevel_limited_profile; l < n->comp_level(); l++) {\n+    nmethod *inv = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), l, true);\n+    if (inv != NULL && inv->is_in_use()) {\n+      inv->make_not_entrant();\n@@ -3410,1 +3433,1 @@\n-    if (TieredCompilation && m == cur->method()) {\n+    if (m == cur->method()) {\n@@ -3429,8 +3452,5 @@\n-  if (TieredCompilation) {\n-    cur = next;\n-    while (cur != NULL) {\n-      \/\/ Find max level after n\n-      if (m == cur->method()) {\n-        max_level = MAX2(max_level, cur->comp_level());\n-      }\n-      cur = cur->osr_link();\n+  cur = next;\n+  while (cur != NULL) {\n+    \/\/ Find max level after n\n+    if (m == cur->method()) {\n+      max_level = MAX2(max_level, cur->comp_level());\n@@ -3438,1 +3458,1 @@\n-    m->set_highest_osr_comp_level(max_level);\n+    cur = cur->osr_link();\n@@ -3440,0 +3460,1 @@\n+  m->set_highest_osr_comp_level(max_level);\n@@ -3481,1 +3502,1 @@\n-          if (osr->comp_level() == CompLevel_highest_tier) {\n+          if (osr->comp_level() == CompilationPolicy::highest_compile_level()) {\n@@ -3703,1 +3724,1 @@\n-  if (this == SystemDictionary::String_klass()) {\n+  if (this == vmClasses::String_klass()) {\n@@ -3720,1 +3741,1 @@\n-  if (this == SystemDictionary::Class_klass()) {\n+  if (this == vmClasses::Class_klass()) {\n@@ -3738,1 +3759,1 @@\n-  } else if (this == SystemDictionary::MethodType_klass()) {\n+  } else if (this == vmClasses::MethodType_klass()) {\n@@ -3757,1 +3778,1 @@\n-  if (this == SystemDictionary::String_klass()\n+  if (this == vmClasses::String_klass()\n@@ -3766,1 +3787,1 @@\n-  } else if (this == SystemDictionary::Class_klass()) {\n+  } else if (this == vmClasses::Class_klass()) {\n@@ -3775,1 +3796,1 @@\n-  } else if (this == SystemDictionary::MethodType_klass()) {\n+  } else if (this == vmClasses::MethodType_klass()) {\n@@ -3781,1 +3802,1 @@\n-  } else if (this == SystemDictionary::LambdaForm_klass()) {\n+  } else if (this == vmClasses::LambdaForm_klass()) {\n@@ -3787,1 +3808,1 @@\n-  } else if (this == SystemDictionary::MemberName_klass()) {\n+  } else if (this == vmClasses::MemberName_klass()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":92,"deletions":71,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -592,1 +592,1 @@\n-  bool is_record() const { return _record_components != NULL; }\n+  bool is_record() const;\n@@ -811,19 +811,2 @@\n-  InstanceKlass* unsafe_anonymous_host() const {\n-    InstanceKlass** hk = adr_unsafe_anonymous_host();\n-    if (hk == NULL) {\n-      assert(!is_unsafe_anonymous(), \"Unsafe anonymous classes have host klasses\");\n-      return NULL;\n-    } else {\n-      assert(*hk != NULL, \"host klass should always be set if the address is not null\");\n-      assert(is_unsafe_anonymous(), \"Only unsafe anonymous classes have host klasses\");\n-      return *hk;\n-    }\n-  }\n-  void set_unsafe_anonymous_host(const InstanceKlass* host) {\n-    assert(is_unsafe_anonymous(), \"not unsafe anonymous\");\n-    const InstanceKlass** addr = (const InstanceKlass **)adr_unsafe_anonymous_host();\n-    assert(addr != NULL, \"no reversed space\");\n-    if (addr != NULL) {\n-      *addr = host;\n-    }\n-  }\n+  inline InstanceKlass* unsafe_anonymous_host() const;\n+  inline void set_unsafe_anonymous_host(const InstanceKlass* host);\n@@ -1169,1 +1152,1 @@\n-  void process_interfaces(Thread *thread);\n+  void process_interfaces();\n@@ -1232,7 +1215,4 @@\n-  intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }\n-  intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }\n-\n-  int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }\n-\n-  oop static_field_base_raw() { return java_mirror(); }\n-\n+  inline intptr_t* start_of_itable() const;\n+  inline intptr_t* end_of_itable() const;\n+  inline int itable_offset_in_words() const;\n+  inline oop static_field_base_raw();\n@@ -1241,66 +1221,2 @@\n-  OopMapBlock* start_of_nonstatic_oop_maps() const {\n-    return (OopMapBlock*)(start_of_itable() + itable_length());\n-  }\n-\n-  Klass** end_of_nonstatic_oop_maps() const {\n-    return (Klass**)(start_of_nonstatic_oop_maps() +\n-                     nonstatic_oop_map_count());\n-  }\n-\n-  Klass* volatile* adr_implementor() const {\n-    if (is_interface()) {\n-      return (Klass* volatile*)end_of_nonstatic_oop_maps();\n-    } else {\n-      return NULL;\n-    }\n-  };\n-\n-  InstanceKlass** adr_unsafe_anonymous_host() const {\n-    if (is_unsafe_anonymous()) {\n-      InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();\n-      if (adr_impl != NULL) {\n-        return adr_impl + 1;\n-      } else {\n-        return (InstanceKlass **)end_of_nonstatic_oop_maps();\n-      }\n-    } else {\n-      return NULL;\n-    }\n-  }\n-\n-  address adr_fingerprint() const {\n-    if (has_stored_fingerprint()) {\n-      InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n-      if (adr_host != NULL) {\n-        return (address)(adr_host + 1);\n-      }\n-\n-      Klass* volatile* adr_impl = adr_implementor();\n-      if (adr_impl != NULL) {\n-        return (address)(adr_impl + 1);\n-      }\n-\n-      return (address)end_of_nonstatic_oop_maps();\n-    } else {\n-      return NULL;\n-    }\n-  }\n-\n-  u2* fields_descriptor_type();\n-\n-  address adr_inline_type_field_klasses() const {\n-    if (has_inline_type_fields()) {\n-      address adr_fing = adr_fingerprint();\n-      if (adr_fing != NULL) {\n-        return adr_fingerprint() + sizeof(u8);\n-      }\n-\n-      InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n-      if (adr_host != NULL) {\n-        return (address)(adr_host + 1);\n-      }\n-\n-      Klass* volatile* adr_impl = adr_implementor();\n-      if (adr_impl != NULL) {\n-        return (address)(adr_impl + 1);\n-      }\n+  inline OopMapBlock* start_of_nonstatic_oop_maps() const;\n+  inline Klass** end_of_nonstatic_oop_maps() const;\n@@ -1308,5 +1224,3 @@\n-      return (address)end_of_nonstatic_oop_maps();\n-    } else {\n-      return NULL;\n-    }\n-  }\n+  inline Klass* volatile* adr_implementor() const;\n+  inline InstanceKlass** adr_unsafe_anonymous_host() const;\n+  inline address adr_fingerprint() const;\n@@ -1314,8 +1228,1 @@\n-  Klass* get_inline_type_field_klass(int idx) const {\n-    assert(has_inline_type_fields(), \"Sanity checking\");\n-    assert(idx < java_fields_count(), \"IOOB\");\n-    Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];\n-    assert(k != NULL, \"Should always be set before being read\");\n-    assert(k->is_inline_klass(), \"Must be an inline type\");\n-    return k;\n-  }\n+  inline u2* fields_descriptor_type() const;\n@@ -1323,21 +1230,5 @@\n-  Klass* get_inline_type_field_klass_or_null(int idx) const {\n-    assert(has_inline_type_fields(), \"Sanity checking\");\n-    assert(idx < java_fields_count(), \"IOOB\");\n-    Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];\n-    assert(k == NULL || k->is_inline_klass(), \"Must be an inline type\");\n-    return k;\n-  }\n-\n-  void set_inline_type_field_klass(int idx, Klass* k) {\n-    assert(has_inline_type_fields(), \"Sanity checking\");\n-    assert(idx < java_fields_count(), \"IOOB\");\n-    assert(k != NULL, \"Should not be set to NULL\");\n-    assert(((Klass**)adr_inline_type_field_klasses())[idx] == NULL, \"Should not be set twice\");\n-    ((Klass**)adr_inline_type_field_klasses())[idx] = k;\n-  }\n-\n-  void reset_inline_type_field_klass(int idx) {\n-    assert(has_inline_type_fields(), \"Sanity checking\");\n-    assert(idx < java_fields_count(), \"IOOB\");\n-    ((Klass**)adr_inline_type_field_klasses())[idx] = NULL;\n-  }\n+  inline address adr_inline_type_field_klasses() const;\n+  inline Klass* get_inline_type_field_klass(int idx) const;\n+  inline Klass* get_inline_type_field_klass_or_null(int idx) const;\n+  inline void set_inline_type_field_klass(int idx, Klass* k);\n+  inline void reset_inline_type_field_klass(int idx);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":19,"deletions":128,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -32,1 +34,1 @@\n-#include \"oops\/klass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n@@ -39,0 +41,131 @@\n+inline InstanceKlass* InstanceKlass::unsafe_anonymous_host() const {\n+  InstanceKlass** hk = adr_unsafe_anonymous_host();\n+  if (hk == NULL) {\n+    assert(!is_unsafe_anonymous(), \"Unsafe anonymous classes have host klasses\");\n+    return NULL;\n+  } else {\n+    assert(*hk != NULL, \"host klass should always be set if the address is not null\");\n+    assert(is_unsafe_anonymous(), \"Only unsafe anonymous classes have host klasses\");\n+    return *hk;\n+  }\n+}\n+\n+inline void InstanceKlass::set_unsafe_anonymous_host(const InstanceKlass* host) {\n+  assert(is_unsafe_anonymous(), \"not unsafe anonymous\");\n+  const InstanceKlass** addr = (const InstanceKlass **)adr_unsafe_anonymous_host();\n+  assert(addr != NULL, \"no reversed space\");\n+  if (addr != NULL) {\n+    *addr = host;\n+  }\n+}\n+\n+inline intptr_t* InstanceKlass::start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }\n+inline intptr_t* InstanceKlass::end_of_itable()     const { return start_of_itable() + itable_length(); }\n+\n+inline int InstanceKlass::itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }\n+\n+inline oop InstanceKlass::static_field_base_raw() { return java_mirror(); }\n+\n+inline OopMapBlock* InstanceKlass::start_of_nonstatic_oop_maps() const {\n+  return (OopMapBlock*)(start_of_itable() + itable_length());\n+}\n+\n+inline Klass** InstanceKlass::end_of_nonstatic_oop_maps() const {\n+  return (Klass**)(start_of_nonstatic_oop_maps() +\n+                   nonstatic_oop_map_count());\n+}\n+\n+inline Klass* volatile* InstanceKlass::adr_implementor() const {\n+  if (is_interface()) {\n+    return (Klass* volatile*)end_of_nonstatic_oop_maps();\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+inline InstanceKlass** InstanceKlass::adr_unsafe_anonymous_host() const {\n+  if (is_unsafe_anonymous()) {\n+    InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();\n+    if (adr_impl != NULL) {\n+      return adr_impl + 1;\n+    } else {\n+      return (InstanceKlass **)end_of_nonstatic_oop_maps();\n+    }\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+inline address InstanceKlass::adr_fingerprint() const {\n+  if (has_stored_fingerprint()) {\n+    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n+    if (adr_host != NULL) {\n+      return (address)(adr_host + 1);\n+    }\n+\n+    Klass* volatile* adr_impl = adr_implementor();\n+    if (adr_impl != NULL) {\n+      return (address)(adr_impl + 1);\n+    }\n+\n+    return (address)end_of_nonstatic_oop_maps();\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+inline address InstanceKlass::adr_inline_type_field_klasses() const {\n+  if (has_inline_type_fields()) {\n+    address adr_fing = adr_fingerprint();\n+    if (adr_fing != NULL) {\n+      return adr_fingerprint() + sizeof(u8);\n+    }\n+\n+    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n+    if (adr_host != NULL) {\n+      return (address)(adr_host + 1);\n+    }\n+\n+    Klass* volatile* adr_impl = adr_implementor();\n+    if (adr_impl != NULL) {\n+      return (address)(adr_impl + 1);\n+    }\n+\n+    return (address)end_of_nonstatic_oop_maps();\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+inline Klass* InstanceKlass::get_inline_type_field_klass(int idx) const {\n+  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(idx < java_fields_count(), \"IOOB\");\n+  Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];\n+  assert(k != NULL, \"Should always be set before being read\");\n+  assert(k->is_inline_klass(), \"Must be an inline type\");\n+  return k;\n+}\n+\n+inline Klass* InstanceKlass::get_inline_type_field_klass_or_null(int idx) const {\n+  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(idx < java_fields_count(), \"IOOB\");\n+  Klass* k = ((Klass**)adr_inline_type_field_klasses())[idx];\n+  assert(k == NULL || k->is_inline_klass(), \"Must be an inline type\");\n+  return k;\n+}\n+\n+inline void InstanceKlass::set_inline_type_field_klass(int idx, Klass* k) {\n+  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(idx < java_fields_count(), \"IOOB\");\n+  assert(k != NULL, \"Should not be set to NULL\");\n+  assert(((Klass**)adr_inline_type_field_klasses())[idx] == NULL, \"Should not be set twice\");\n+  ((Klass**)adr_inline_type_field_klasses())[idx] = k;\n+}\n+\n+inline void InstanceKlass::reset_inline_type_field_klass(int idx) {\n+  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(idx < java_fields_count(), \"IOOB\");\n+  ((Klass**)adr_inline_type_field_klasses())[idx] = NULL;\n+}\n+\n+\n@@ -174,1 +307,1 @@\n-inline u2* InstanceKlass::fields_descriptor_type() {\n+inline u2* InstanceKlass::fields_descriptor_type() const {\n@@ -177,1 +310,1 @@\n-      return (u2*)((address)(InlineKlass::cast(this)->inlineklass_static_block()) + sizeof(InlineKlassFixedBlock));\n+      return (u2*)((address)(InlineKlass::cast((Klass*)this)->inlineklass_static_block()) + sizeof(InlineKlassFixedBlock));\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":136,"deletions":3,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"oops\/klass.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -93,0 +95,1 @@\n+#include \"runtime\/osThread.hpp\"\n@@ -102,0 +105,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -105,0 +109,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -273,4 +278,4 @@\n-  nonstatic_field(MethodData,                  _nof_decompiles,                               uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_recompiles,                      uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_traps,                           uint)                                  \\\n-  nonstatic_field(MethodData,                  _trap_hist._array[0],                          u1)                                    \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_decompiles,            uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_recompiles,   uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_traps,        uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._trap_hist._array[0],       u1)                                    \\\n@@ -290,3 +295,0 @@\n-  nonstatic_field(MethodCounters,              _interpreter_invocation_limit,                 int)                                   \\\n-  nonstatic_field(MethodCounters,              _interpreter_backward_branch_limit,            int)                                   \\\n-  nonstatic_field(MethodCounters,              _interpreter_profile_limit,                    int)                                   \\\n@@ -295,1 +297,0 @@\n-  COMPILER2_OR_JVMCI_PRESENT(nonstatic_field(MethodCounters, _interpreter_invocation_count,   int))                                  \\\n@@ -458,8 +459,8 @@\n-     static_field(SystemDictionary,            WK_KLASS(Object_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(String_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(Class_klass),                         InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(ClassLoader_klass),                   InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(System_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(Thread_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(ThreadGroup_klass),                   InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(MethodHandle_klass),                  InstanceKlass*)                        \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Object_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(String_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Class_klass),                         InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(ClassLoader_klass),                   InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(System_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Thread_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(ThreadGroup_klass),                   InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(MethodHandle_klass),                  InstanceKlass*)                     \\\n@@ -859,1 +860,1 @@\n-  nonstatic_field(ciMethodData,                _orig,                                         MethodData)                            \\\n+  nonstatic_field(ciMethodData,                _orig,                                         MethodData::CompilerCounters)          \\\n@@ -892,0 +893,2 @@\n+  static_field(ObjectSynchronizer,             _in_use_list,                                  MonitorList)                           \\\n+  volatile_nonstatic_field(MonitorList,        _head,                                         ObjectMonitor*)                        \\\n@@ -962,1 +965,0 @@\n-  c2_nonstatic_field(MachCallJavaNode,         _bci,                                          int)                                   \\\n@@ -1267,0 +1269,2 @@\n+  declare_toplevel_type(MethodData::CompilerCounters)                     \\\n+                                                                          \\\n@@ -1323,0 +1327,1 @@\n+  declare_toplevel_type(vmClasses)                                        \\\n@@ -1401,0 +1406,1 @@\n+  declare_type(VtableBlob,               BufferBlob)                      \\\n@@ -1467,0 +1473,1 @@\n+  declare_toplevel_type(MonitorList)                                      \\\n@@ -2425,6 +2432,0 @@\n-  \/***************************************************\/                   \\\n-  \/* DEFAULT_CACHE_LINE_SIZE (globalDefinitions.hpp) *\/                   \\\n-  \/***************************************************\/                   \\\n-                                                                          \\\n-  declare_preprocessor_constant(\"DEFAULT_CACHE_LINE_SIZE\", DEFAULT_CACHE_LINE_SIZE) \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -361,1 +361,1 @@\n-    public static final long PREVIEW_ESSENTIAL_API = 1L<<58; \/\/any Symbol kind\n+    public static final long PREVIEW_REFLECTIVE = 1L<<58; \/\/any Symbol kind\n@@ -538,1 +538,1 @@\n-        PREVIEW_ESSENTIAL_API(Flags.PREVIEW_ESSENTIAL_API),\n+        PREVIEW_REFLECTIVE(Flags.PREVIEW_REFLECTIVE),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-    public boolean isLocal() {\n+    public boolean isDirectlyOrIndirectlyLocal() {\n@@ -499,1 +499,1 @@\n-             (owner.kind == TYP && owner.isLocal()));\n+             (owner.kind == TYP && owner.isDirectlyOrIndirectlyLocal()));\n@@ -825,1 +825,1 @@\n-        public boolean isLocal() { return other.isLocal(); }\n+        public boolean isDirectlyOrIndirectlyLocal() { return other.isDirectlyOrIndirectlyLocal(); }\n@@ -1587,1 +1587,1 @@\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var, annotations));\n+                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, annotations));\n@@ -1598,0 +1598,4 @@\n+        public void setRecordComponents(List<RecordComponent> recordComponents) {\n+            this.recordComponents = recordComponents;\n+        }\n+\n@@ -1950,2 +1954,9 @@\n-        public RecordComponent(JCVariableDecl fieldDecl, List<JCAnnotation> annotations) {\n-            super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);\n+        public RecordComponent(Name name, Type type, Symbol owner) {\n+            super(PUBLIC, name, type, owner);\n+            pos = -1;\n+            originalAnnos = List.nil();\n+            isVarargs = false;\n+        }\n+\n+        public RecordComponent(VarSymbol field, List<JCAnnotation> annotations) {\n+            super(PUBLIC, field.name, field.type, field.owner);\n@@ -1953,1 +1964,1 @@\n-            this.pos = fieldDecl.pos;\n+            this.pos = field.pos;\n@@ -2014,2 +2025,2 @@\n-        public BindingSymbol(Name name, Type type, Symbol owner) {\n-            super(Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);\n+        public BindingSymbol(long flags, Name name, Type type, Symbol owner) {\n+            super(flags | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+    public final Type valueBasedType;\n@@ -596,1 +597,1 @@\n-        previewFeatureType = enterClass(\"jdk.internal.PreviewFeature\");\n+        previewFeatureType = enterClass(\"jdk.internal.javac.PreviewFeature\");\n@@ -602,0 +603,1 @@\n+        valueBasedType = enterClass(\"jdk.internal.ValueBased\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -392,1 +392,2 @@\n-                sym.getKind() == ElementKind.EXCEPTION_PARAMETER) {\n+                sym.getKind() == ElementKind.EXCEPTION_PARAMETER ||\n+                sym.getKind() == ElementKind.BINDING_VARIABLE) {\n@@ -1267,0 +1268,5 @@\n+            } else if (tree.sym.getKind() == ElementKind.BINDING_VARIABLE) {\n+                final TypeAnnotationPosition pos =\n+                    TypeAnnotationPosition.localVariable(currentLambda,\n+                                                         tree.pos);\n+                separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1682,1 +1682,1 @@\n-     * Is t is castable to s?<br>\n+     * Is t castable to s?<br>\n@@ -1687,0 +1687,1 @@\n+        \/\/ if same type\n@@ -1689,0 +1690,1 @@\n+        \/\/ if one of the types is primitive\n@@ -1695,0 +1697,1 @@\n+        boolean result;\n@@ -1699,1 +1702,1 @@\n-                return isCastable.visit(t,s);\n+                result = isCastable.visit(t,s);\n@@ -1704,1 +1707,1 @@\n-            return isCastable.visit(t,s);\n+            result = isCastable.visit(t,s);\n@@ -1706,0 +1709,8 @@\n+        if (result && t.hasTag(CLASS) && t.tsym.kind.matches(Kinds.KindSelector.TYP)\n+                && s.hasTag(CLASS) && s.tsym.kind.matches(Kinds.KindSelector.TYP)\n+                && (t.tsym.isSealed() || s.tsym.isSealed())) {\n+            return (t.isCompound() || s.isCompound()) ?\n+                    false :\n+                    !areDisjoint((ClassSymbol)t.tsym, (ClassSymbol)s.tsym);\n+        }\n+        return result;\n@@ -1708,0 +1719,36 @@\n+        private boolean areDisjoint(ClassSymbol ts, ClassSymbol ss) {\n+            \/* The disjointsness checks below are driven by subtyping. At the language level\n+               a reference projection type and its value projection type are not related by\n+               subtyping, thereby necessitating special handling.\n+            *\/\n+            if ((ss.isReferenceProjection() && ss.valueProjection() == ts) ||\n+                (ss.isValue() && ss.referenceProjection() == ts)) {\n+                return false;\n+            }\n+            if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n+                return false;\n+            }\n+            \/\/ if both are classes or both are interfaces, shortcut\n+            if (ts.isInterface() == ss.isInterface() && isSubtype(erasure(ss.type), erasure(ts.type))) {\n+                return false;\n+            }\n+            if (ts.isInterface() && !ss.isInterface()) {\n+                \/* so ts is interface but ss is a class\n+                 * an interface is disjoint from a class if the class is disjoint form the interface\n+                 *\/\n+                return areDisjoint(ss, ts);\n+            }\n+            \/\/ a final class that is not subtype of ss is disjoint\n+            if (!ts.isInterface() && ts.isFinal()) {\n+                return true;\n+            }\n+            \/\/ if at least one is sealed\n+            if (ts.isSealed() || ss.isSealed()) {\n+                \/\/ permitted subtypes have to be disjoint with the other symbol\n+                ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n+                ClassSymbol other = sealedOne == ts ? ss : ts;\n+                return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1007,0 +1007,6 @@\n+                        if (sym.kind == MTH  && sym.name == names.init && sym.owner.isValue()) {\n+                            sym.type = new MethodType(sym.type.getParameterTypes(),\n+                                    syms.voidType,\n+                                    sym.type.getThrownTypes(),\n+                                    syms.methodClass);\n+                        }\n@@ -1246,1 +1252,10 @@\n-                    bp = bp + attrLen;\n+                    int componentCount = nextChar();\n+                    ListBuffer<RecordComponent> components = new ListBuffer<>();\n+                    for (int i = 0; i < componentCount; i++) {\n+                        Name name = poolReader.getName(nextChar());\n+                        Type type = poolReader.getType(nextChar());\n+                        RecordComponent c = new RecordComponent(name, type, sym);\n+                        readAttrs(c, AttributeKind.MEMBER);\n+                        components.add(c);\n+                    }\n+                    ((ClassSymbol) sym).setRecordComponents(components.toList());\n@@ -1518,1 +1533,1 @@\n-                setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);\n+                setFlagIfAttributeTrue(proxy, sym, names.reflective, PREVIEW_REFLECTIVE);\n@@ -1529,1 +1544,1 @@\n-                    setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);\n+                    setFlagIfAttributeTrue(proxy, sym, names.reflective, PREVIEW_REFLECTIVE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1783,1 +1783,1 @@\n-        if (preview.isEnabled()) {\n+        if (preview.isEnabled() && preview.usesPreview(c.sourcefile)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-    public final Name essentialAPI;\n+    public final Name reflective;\n@@ -277,1 +277,1 @@\n-        essentialAPI = fromString(\"essentialAPI\");\n+        reflective = fromString(\"reflective\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -365,1 +365,0 @@\n-        \/\/ Note: due to the use of shared resources, this method is not reentrant.\n@@ -368,4 +367,4 @@\n-            sharedOut.reset();\n-            attr.accept(this, sharedOut);\n-            out.writeInt(sharedOut.size());\n-            sharedOut.writeTo(out);\n+            ClassOutputStream nestedOut = new ClassOutputStream();\n+            attr.accept(this, nestedOut);\n+            out.writeInt(nestedOut.size());\n+            nestedOut.writeTo(out);\n@@ -374,1 +373,0 @@\n-        protected ClassOutputStream sharedOut = new ClassOutputStream();\n@@ -775,2 +773,2 @@\n-        protected void writeAccessFlags(AccessFlags flags, ClassOutputStream p) {\n-            sharedOut.writeShort(flags.flags);\n+        protected void writeAccessFlags(AccessFlags flags, ClassOutputStream out) {\n+            out.writeShort(flags.flags);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"}]}