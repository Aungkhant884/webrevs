{"files":[{"patch":"@@ -3309,0 +3309,14 @@\n+\n+  Label notRestricted;\n+  __ movl(rdx, flags);\n+  __ shrl(rdx, ConstantPoolCacheEntry::has_restricted_type_shift);\n+  __ andl(rdx, 0x1);\n+  __ testl(rdx, rdx);\n+  __ jcc(Assembler::zero, notRestricted);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::check_restricted_type));\n+  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+\n+  __ bind(notRestricted);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1855,0 +1855,6 @@\n+      if (field->has_restricted_type()) {\n+        CheckCast* c = new CheckCast(field->type()->as_klass(), val, copy_state_before(), field->type()->as_inline_klass() != NULL);\n+        append_split(c);\n+        c->set_incompatible_class_change_check();\n+        c->set_direct_compare(field->type()->as_instance_klass()->is_final());\n+      }\n@@ -2019,0 +2025,6 @@\n+      if (field->has_restricted_type()) {\n+        CheckCast* c = new CheckCast(field->type()->as_klass(), val, copy_state_before(), field->type()->as_inline_klass() != NULL);\n+        append_split(c);\n+        c->set_incompatible_class_change_check();\n+        c->set_direct_compare(field->type()->as_instance_klass()->is_final());\n+      }\n@@ -2065,0 +2077,7 @@\n+  if (field_modify->has_restricted_type()) {\n+    CheckCast* c = new CheckCast(field_modify->type()->as_klass(), val, copy_state_before(), field_modify->type()->as_inline_klass() != NULL);\n+    append_split(c);\n+    c->set_incompatible_class_change_check();\n+    c->set_direct_compare(field_modify->type()->as_instance_klass()->is_final());\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1027,0 +1027,2 @@\n+  bool deoptimize_for_flattened_field = false;\n+  bool deoptimize_for_restricted_type = false;\n@@ -1043,1 +1045,20 @@\n-    assert(!result.is_inlined(), \"Can not patch access to flattened field\");\n+\n+    \/\/ With type restrictions, it possible that at compilation time,\n+    \/\/ the holder was unloaded, and C1 didn't know that the field\n+    \/\/ would be flattened, so the generated code is incorrect for a\n+    \/\/ flattened field. The  nmethod has to be deoptimized so that\n+    \/\/ the code can be regnerated correctly.\n+\n+    deoptimize_for_flattened_field = result.is_inlined();\n+\n+    \/\/ Another case caused by type restrictions: if the holder was\n+    \/\/ unloaded at compilation time, C1 didn't know that the field\n+    \/\/ could have type restrictions, and when the field has such\n+    \/\/ restrictions, it means additional checks have to be performed\n+    \/\/ to ensure the value being written satisfies those restrictions.\n+    \/\/ The nmethod has to be deoptimized so that the code can be\n+    \/\/ regenerated with the additional checks.\n+\n+    if ((code == Bytecodes::_putfield || code == Bytecodes::_putstatic) && result.has_restricted_type()) {\n+      deoptimize_for_restricted_type = true;\n+    }\n@@ -1156,1 +1177,2 @@\n-  if (deoptimize_for_volatile || deoptimize_for_atomic) {\n+  if (deoptimize_for_volatile || deoptimize_for_atomic || deoptimize_for_flattened_field ||\n+      deoptimize_for_restricted_type) {\n@@ -1167,0 +1189,6 @@\n+      if (deoptimize_for_flattened_field) {\n+        tty->print_cr(\"Deoptimizing for patching flattened field reference\");\n+      }\n+      if (deoptimize_for_restricted_type) {\n+        tty->print_cr(\"Deoptimizing for patching field with type restriction\");\n+      }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-  _is_flattened(false), _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n+  _descriptor_signature(NULL), _is_flattened(false),\n+  _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n@@ -106,2 +107,0 @@\n-  _name = (ciSymbol*)ciEnv::current(THREAD)->get_symbol(name);\n-\n@@ -201,0 +200,3 @@\n+  if (fd->has_restricted_type()) {\n+    _descriptor_signature = env->get_symbol(fd->descriptor_signature());\n+  }\n@@ -240,0 +242,1 @@\n+  _descriptor_signature = field->_descriptor_signature;\n@@ -283,0 +286,1 @@\n+  ASSERT_IN_VM;\n@@ -290,0 +294,10 @@\n+  if (fd->has_restricted_type()) {\n+    _descriptor_signature = ciEnv::current(CompilerThread::current())->get_symbol(fd->descriptor_signature());\n+    _signature = ciEnv::current(CompilerThread::current())->get_symbol(fd->signature());\n+    \/\/ Only InstanceKlass should have fields\n+    assert(field_holder->is_instance_klass(), \"Sanity check\");\n+    InstanceKlass* field_holder_ik = InstanceKlass::cast(field_holder);\n+    \/\/ resetting the type because field's type has been switched from its descriptor signature\n+    \/\/ to its restricted type. The type will be set lazely wjen invoking the method type().\n+    _type = NULL;\n+  }\n@@ -292,1 +306,0 @@\n-  Klass* k = _holder->get_Klass();\n@@ -301,1 +314,1 @@\n-      if (k == vmClasses::System_klass()) {\n+      if (field_holder == vmClasses::System_klass()) {\n@@ -320,1 +333,1 @@\n-    if (k == vmClasses::CallSite_klass() &&\n+    if (field_holder == vmClasses::CallSite_klass() &&\n@@ -487,0 +500,5 @@\n+  tty->print(\" has_restricted_type=%s\", bool_to_str(_descriptor_signature != NULL));\n+  if (_descriptor_signature != NULL) {\n+    tty->print(\"descriptor signature=\");\n+    _descriptor_signature->print_symbol();\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  ciSymbol*        _descriptor_signature;\n@@ -103,0 +104,3 @@\n+  \/\/ What alternate signature can be used for this field in signature (must have a restricted type)\n+  ciSymbol* descriptor_signature() const { return _descriptor_signature; }\n+\n@@ -180,0 +184,1 @@\n+  bool has_restricted_type     () const { return _holder->is_loaded() && _descriptor_signature != NULL; }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1378,0 +1378,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1473,0 +1475,12 @@\n+      } else if (attribute_name == vmSymbols::tag_restricted_field()) {\n+        check_property(\n+          attribute_length == 2,\n+          \"Invalid RestrictedField field attribute length %u in class file %s\",\n+          attribute_length, CHECK);\n+          const u2 type_index = cfs->get_u2_fast();\n+          check_property(valid_symbol_at(type_index),\n+                         \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                          type_index, CHECK);\n+          *restricted_field_info = type_index;\n+          *has_restricted_type = true;\n+          set_has_restricted_fields();\n@@ -1664,0 +1678,2 @@\n+  _descriptor_signature_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1694,0 +1710,1 @@\n+\n@@ -1726,0 +1743,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1735,0 +1754,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1769,0 +1790,26 @@\n+    \/\/ RestrictedField:\n+    \/\/ The current model for restricted field is that such a field has a descriptor signature used\n+    \/\/ as the normal signature for this field (for instance in field access bytecodes) but it also\n+    \/\/ has a restricted type that will be used internally by the VM as the real type of the field.\n+    \/\/ Current constraints are that the restricted type must be an inline type and the descriptor\n+    \/\/ type must be a super type of the restricted type.\n+    \/\/ The code below verifies that the restricted type is an inline type. The property that the\n+    \/\/ descriptor type is a super type of the restricted type is verified just after the pre-loading\n+    \/\/ of the restricted type (inline type field preloading)\n+    if (has_restricted_type && cp->basic_type_for_signature_at(restricted_type_index) != T_INLINE_TYPE) {\n+      \/\/ Probably not the right error to throw\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Field %s.%s has a RestricteField attribute but its restricted type is not an inline type\",\n+                _class_name->as_C_string(),\n+                _cp->symbol_at(restricted_type_index)->as_C_string()));\n+    }\n+\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1772,1 +1819,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1774,0 +1821,3 @@\n+    _descriptor_signature_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1823,0 +1873,1 @@\n+      _descriptor_signature_info->append(0);\n@@ -1826,0 +1877,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1833,0 +1885,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1835,0 +1888,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1837,0 +1891,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1845,0 +1902,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1847,0 +1905,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -5887,0 +5946,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_descriptor_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _descriptor_signature_info->at(i);\n+    }\n+  }\n+\n@@ -6085,0 +6152,1 @@\n+  _descriptor_signature_info(NULL),\n@@ -6124,0 +6192,1 @@\n+  _has_restricted_fields(false),\n@@ -6702,0 +6771,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6704,1 +6774,0 @@\n-      \/\/ Pre-load inline class\n@@ -6717,0 +6786,13 @@\n+      if (fs.has_restricted_type()) {\n+        \/\/ descriptor type supposed to be a super type of the restricted type, so after the pre-loading\n+        \/\/ of the restricted type above, the descriptor type should be loaded at this point\n+        Symbol* descriptor_name = _cp->symbol_at(_descriptor_signature_info->at(fs.index()));\n+        ResolvingSignatureStream rss(descriptor_name, Handle(THREAD, _loader_data->class_loader()), _protection_domain, false);\n+        Klass* desc_klass = rss.as_klass(SignatureStream::ReturnNull, CHECK);\n+        if (desc_klass == NULL || !klass->is_subtype_of(desc_klass)) {\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Restricted type %s should be a subtype of the descriptor type %s, but it is not\",\n+                    fs.signature()->as_C_string(),\n+                    descriptor_name->as_C_string()));\n+        }\n+      }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":84,"deletions":2,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-                                       Array<u2>* fields, bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,\n+                                       Array<u2>* fields,  bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+  template(tag_restricted_field,                      \"RestrictedField\")                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -345,0 +345,11 @@\n+    oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n+    if (voop == NULL) {\n+      THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);\n+    }\n+    if (vklass->field_has_restricted_type(field_index)) {\n+      Klass* value_klass = voop->klass();\n+      Klass* field_klass = vklass->get_inline_type_field_klass(field_index);\n+      if (!value_klass->is_subtype_of(field_klass)) {\n+        THROW_(vmSymbols::java_lang_IncompatibleClassChangeError(), return_offset);\n+      }\n+    }\n@@ -346,2 +357,1 @@\n-      oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n-      assert(vt_oop != NULL && oopDesc::is_oop(vt_oop) && vt_oop->is_inline_type(),\"argument must be an inline type\");\n+      assert(voop != NULL && oopDesc::is_oop(voop) && voop->is_inline_type(),\"argument must be an inline type\");\n@@ -349,2 +359,2 @@\n-      assert(vt_oop != NULL && field_vk == vt_oop->klass(), \"Must match\");\n-      field_vk->write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));\n+      assert(voop != NULL && field_vk == voop->klass(), \"Must match\");\n+      field_vk->write_inlined_field(new_value_h(), offset, voop, CHECK_(return_offset));\n@@ -352,1 +362,0 @@\n-      oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n@@ -528,0 +537,31 @@\n+JRT_ENTRY(void, InterpreterRuntime::check_restricted_type(JavaThread* thread))\n+  LastFrameAccessor last_frame(thread);\n+  ConstantPoolCacheEntry* cp_entry = last_frame.cache_entry();\n+  int offset = cp_entry->f2_as_offset();\n+  InstanceKlass* holder = InstanceKlass::cast(cp_entry->f1_as_klass());\n+  fieldDescriptor fd;\n+  bool is_static = last_frame.bytecode().code() == Bytecodes::_putstatic;\n+  holder->find_field_from_offset(offset, is_static, &fd);\n+  Klass* field_klass = holder->get_inline_type_field_klass_or_null(fd.index());\n+  if (field_klass == NULL) {\n+    field_klass = SystemDictionary::resolve_or_fail(holder->field_signature(fd.index())->fundamental_name(THREAD),\n+        Handle(THREAD, holder->class_loader()),\n+        Handle(THREAD, holder->protection_domain()),\n+        true, CHECK);\n+    holder->set_inline_type_field_klass(fd.index(), field_klass);\n+  }\n+  assert(field_klass != NULL, \"Must have been set\");\n+  oop value = cast_to_oop(*last_frame.get_frame().interpreter_frame_tos_at(0));\n+  if (value == NULL) {\n+    if (field_klass->is_inline_klass()) {\n+      THROW(vmSymbols::java_lang_NullPointerException());\n+    }\n+    return;\n+  }\n+  assert(value != NULL, \"Inline types cannot be NULL\");\n+  Klass* value_klass = value->klass();\n+  if (!value_klass->is_subtype_of(field_klass)) {\n+    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+  };\n+JRT_END\n+\n@@ -958,0 +998,1 @@\n+    info.has_restricted_type(),\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  static void check_restricted_type(JavaThread* thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+                                       bool has_restricted_type,\n@@ -152,1 +153,2 @@\n-                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),\n+                  ((is_inline_type ? 1 : 0) << is_inline_type_shift) |\n+                  ((has_restricted_type ? 1 : 0) << has_restricted_type_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -476,1 +476,2 @@\n-                                       parser.is_inline_type());\n+                                       parser.is_inline_type(),\n+                                       parser.has_restricted_fields());\n@@ -511,0 +512,4 @@\n+  if (parser.has_restricted_fields()) {\n+    ik->set_has_restricted_fields(); \/\/ required to get the size right when calling size()\n+  }\n+\n@@ -1658,4 +1663,14 @@\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n-      return true;\n+    if (f_name == name) {\n+      Symbol* f_sig = NULL;\n+      f_sig  = fs.signature();\n+      if (f_sig == sig) {\n+        fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+        return true;\n+      }\n+      if (fs.has_restricted_type()) {\n+        f_sig = fs.descriptor_signature();\n+        if (f_sig == sig) {\n+          fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+          return true;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+\/\/    [EMBEDDED restricted_fields_info] only if has_restricted_fields() == true\n@@ -296,1 +297,2 @@\n-    _misc_has_injected_identityObject         = 1 << 22  \/\/ IdentityObject has been injected by the JVM\n+    _misc_has_injected_identityObject         = 1 << 22, \/\/ IdentityObject has been injected by the JVM\n+    _misc_has_restricted_fields               = 1 << 23  \/\/ class has fields with type restrictions\n@@ -480,1 +482,1 @@\n-    return (_misc_flags & _misc_has_injected_identityObject);\n+    return (_misc_flags & _misc_has_injected_identityObject) != 0;\n@@ -487,0 +489,8 @@\n+  bool has_restricted_fields() const {\n+    return (_misc_flags & _misc_has_restricted_fields) != 0;\n+  }\n+\n+  void set_has_restricted_fields() {\n+    _misc_flags |= _misc_has_restricted_fields;\n+  }\n+\n@@ -551,0 +561,1 @@\n+  bool    field_has_restricted_type(int index) const { return field(index)->has_restricted_type(); }\n@@ -1181,1 +1192,1 @@\n-                  int java_fields, bool is_inline_type) {\n+                  int java_fields, bool is_inline_type, bool has_restricted_fields) {\n@@ -1190,1 +1201,2 @@\n-           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0) +\n+           (has_restricted_fields ? (align_up(java_fields * (int)sizeof(u2), wordSize)\/wordSize) : 0));\n@@ -1199,1 +1211,2 @@\n-                                               is_inline_klass());\n+                                               is_inline_klass(),\n+                                               has_restricted_fields());\n@@ -1215,0 +1228,2 @@\n+  inline u2* fields_descriptor_type() const;\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -306,0 +307,29 @@\n+inline u2* InstanceKlass::fields_descriptor_type() const {\n+    assert(has_restricted_fields(), \"Should not be called otherwise\");\n+    if (is_inline_klass()) {\n+      return (u2*)((address)(InlineKlass::cast((Klass*)this)->inlineklass_static_block()) + sizeof(InlineKlassFixedBlock));\n+    }\n+\n+    address adr_jf = adr_inline_type_field_klasses();\n+    if (adr_jf != NULL) {\n+      return (u2*)(adr_jf + this->java_fields_count() * sizeof(Klass*));\n+    }\n+\n+    address adr_fing = adr_fingerprint();\n+    if (adr_fing != NULL) {\n+      return (u2*)(adr_fingerprint() + sizeof(u8));\n+    }\n+\n+    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n+    if (adr_host != NULL) {\n+      return (u2*)(adr_host + 1);\n+    }\n+\n+    Klass* volatile* adr_impl = adr_implementor();\n+    if (adr_impl != NULL) {\n+      return (u2*)(adr_impl + 1);\n+    }\n+\n+    return (u2*)end_of_nonstatic_oop_maps();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -62,0 +62,7 @@\n+Symbol* fieldDescriptor::descriptor_signature() const {\n+  if (!has_restricted_type()) {\n+    return NULL;  \/\/ or the real signature could be returned\n+  }\n+  return _cp->symbol_at(field_holder()->fields_descriptor_type()[_index]);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+inline bool fieldDescriptor::has_restricted_type() const { return field()->has_restricted_type(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2271,0 +2271,3 @@\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_CONTENDED\", FIELDINFO_TAG_CONTENDED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_INLINED\", FIELDINFO_TAG_INLINED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_RESTRICTED\", FIELDINFO_TAG_RESTRICTED) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,0 +142,4 @@\n+    \/** Flag is set for a type restricted field.\n+     *\/\n+    public static final int RESTRICTED_FIELD       = 1<<19;\n+\n@@ -518,0 +522,1 @@\n+        RESTRICTED_FIELD(Flags.RESTRICTED_FIELD),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-            return new MethodType(t.getParameterTypes().prepend(outerThisType),\n+            t = new MethodType(t.getParameterTypes().prepend(outerThisType),\n@@ -364,1 +364,2 @@\n-        } else {\n+        }\n+        if (!types.flattenWithTypeRestrictions) {\n@@ -367,0 +368,26 @@\n+        List<Type> rpt = List.nil();\n+        Type rrt = null;\n+        boolean mutateExternalType = false;\n+        \/\/ Computed restricted parameter types\n+        for (Type pt: t.getParameterTypes()) {\n+            if (pt.isValue()) {\n+                mutateExternalType = true;\n+                rpt = rpt.append(pt.referenceProjection());\n+            } else {\n+                rpt = rpt.append(pt);\n+            }\n+        }\n+        Type rt = t.getReturnType();\n+        if (rt.isValue()) {\n+            mutateExternalType = true;\n+            rrt = rt.referenceProjection();\n+        } else {\n+            rrt = rt;\n+        }\n+        if (mutateExternalType) {\n+            t = new MethodType(rpt,\n+                    rrt,\n+                    t.getThrownTypes(),\n+                    t.tsym);\n+        }\n+        return t;\n@@ -1678,2 +1705,0 @@\n-            if (!isValue())\n-                return null;\n@@ -1695,1 +1720,1 @@\n-            long projectionFlags = (this.flags() & ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;\n+            long projectionFlags = (this.flags_field & ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;\n@@ -1699,14 +1724,17 @@\n-            for (Symbol s : this.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    valMethod.projection = refMethod;\n-                    refMethod.projection = valMethod;\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    valVar.projection = refVar;\n-                    refVar.projection = valVar;\n-                    clone = refVar;\n+            if (this.completer == Completer.NULL_COMPLETER) {\n+                for (Symbol s : this.members().getSymbols(s -> (s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n+                    Symbol clone = null;\n+                    if (s.kind == MTH) {\n+                        MethodSymbol valMethod = (MethodSymbol)s;\n+                        MethodSymbol refMethod = valMethod.clone(projection);\n+                        valMethod.projection = refMethod;\n+                        refMethod.projection = valMethod;\n+                        clone = refMethod;\n+                    } else if (s.kind == VAR) {\n+                        VarSymbol valVar = (VarSymbol)s;\n+                        VarSymbol refVar = valVar.clone(projection);\n+                        valVar.projection = refVar;\n+                        refVar.projection = valVar;\n+                        clone = refVar;\n+                    }\n+                    projection.members_field.enter(clone);\n@@ -1714,2 +1742,13 @@\n-                projection.members_field.enter(clone);\n-            projection.completer = Completer.NULL_COMPLETER;\n+\n+            projection.completer = new Completer() {\n+                @Override\n+                public void complete(Symbol sym) throws CompletionFailure {\n+                    ClassSymbol.this.complete();\n+                }\n+\n+                @Override\n+                public boolean isTerminal() {\n+                    return ClassSymbol.this.completer.isTerminal();\n+                }\n+            };\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":60,"deletions":21,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+    public final Type restrictedTypeType;\n@@ -599,0 +600,1 @@\n+        restrictedTypeType = enterClass(\"java.lang.invoke.RestrictedType\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-                        (enclTr.getKind() == JCTree.Kind.MEMBER_SELECT ||\n+                        ((enclTr.getKind() == JCTree.Kind.MEMBER_SELECT  && !enclTy.isReferenceProjection()) ||  \/\/ .ref is only a pseudo member select.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+    \/** enable alternate code generation to faciliate specialization experiments using type restrictions *\/\n+    public boolean flattenWithTypeRestrictions;\n+\n@@ -129,0 +132,1 @@\n+        flattenWithTypeRestrictions = options.isSet(\"flattenWithTypeRestrictions\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1280,0 +1280,47 @@\n+            new AttributeReader(names.RestrictedField, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowInlineTypes;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind == VAR && sym.owner.kind == TYP) {\n+                        final Type type = poolReader.getType(nextChar());\n+                        if (types.flattenWithTypeRestrictions) {\n+                            Assert.check(((ClassSymbol)((ClassType)sym.type).tsym).projection == type.tsym);\n+                            sym.flags_field |= RESTRICTED_FIELD;\n+                        }\n+                    }\n+                }\n+            },\n+\n+            new AttributeReader(names.RestrictedMethod, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowInlineTypes;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (!types.flattenWithTypeRestrictions) {\n+                        bp = bp + attrLen;\n+                        return;\n+                    }\n+                    int paramCount = nextByte();\n+                    if (sym.name == names.init && sym.owner.hasOuterInstance())\n+                        paramCount --;\n+                    List<Type> paramTypes = List.nil();\n+                    for (int i = 0; i < paramCount; i++) {\n+                        int restrictedParamTypeIndex = nextChar();\n+                        paramTypes = paramTypes.append(\n+                                  restrictedParamTypeIndex == 0 ?\n+                                  sym.type.getParameterTypes().get(i)\n+                                : poolReader.getType(restrictedParamTypeIndex));\n+                    }\n+                    int restrictedReturnTypeIndex = nextChar();\n+                    Type returnType =\n+                            restrictedReturnTypeIndex == 0 || sym.isConstructor() ?\n+                                    sym.type.getReturnType()\n+                                    : poolReader.getType(restrictedReturnTypeIndex);\n+                    if (sym.kind == MTH && sym.owner.kind == TYP) {\n+                        sym.type = new MethodType(paramTypes, returnType, sym.type.getThrownTypes(), sym.type.tsym);\n+                    }\n+                }\n+            },\n@@ -2245,1 +2292,2 @@\n-        return v;\n+        return (v.flags_field & RESTRICTED_FIELD) == RESTRICTED_FIELD ?\n+                new VarSymbol(flags, name, ((ClassSymbol)v.type.tsym).projection.type, currentOwner) : v;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -976,1 +976,18 @@\n-        databuf.appendChar(poolWriter.putDescriptor(v));\n+        boolean emitRestrictedField = false;\n+        int restrictedFieldDescriptor = 0;\n+        if (types.flattenWithTypeRestrictions && v.type.isValue()) {\n+            emitRestrictedField = true;\n+            databuf.appendChar(poolWriter.putDescriptor(v.type.referenceProjection()));\n+        } else {\n+            databuf.appendChar(poolWriter.putDescriptor(v));\n+            for (Attribute.Compound anno : v.type.getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    Attribute member = anno.member(names.value);\n+                    Assert.check(member.type.tsym == syms.stringType.tsym);\n+                    String utf8 = (String) member.getValue();\n+                    restrictedFieldDescriptor = poolWriter.putName(names.fromString(utf8));\n+                    emitRestrictedField = true;\n+                }\n+            }\n+        }\n+\n@@ -985,0 +1002,10 @@\n+        if (emitRestrictedField) {\n+            int alenIdx = writeAttr(names.RestrictedField);\n+            if (types.flattenWithTypeRestrictions && v.type.isValue()) {\n+                databuf.appendChar(poolWriter.putDescriptor(v));\n+            }   else {\n+                databuf.appendChar(restrictedFieldDescriptor);\n+            }\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n@@ -1030,0 +1057,75 @@\n+        \/\/ See if we need to emit a RestrictedMethod attribute\n+        boolean emitRestrictedMethod = false;\n+\n+        if (types.flattenWithTypeRestrictions && m.name == m.name.table.names.init && m.owner.hasOuterInstance()) {\n+            Type outerThisType = types.erasure(m.owner.type.getEnclosingType());\n+            if (outerThisType.isValue()) {\n+                emitRestrictedMethod = true;\n+            }\n+        }\n+        CheckTypeRestrictedParameters:\n+        for (Type pt : m.type.getParameterTypes()) {\n+            if (pt.isValue() && types.flattenWithTypeRestrictions) {\n+                emitRestrictedMethod = true;\n+                break;\n+            }\n+            for (Attribute.Compound anno : pt.getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    emitRestrictedMethod = true;\n+                    break CheckTypeRestrictedParameters;\n+                }\n+            }\n+        }\n+        if (m.type.getReturnType().isValue() && types.flattenWithTypeRestrictions) {\n+            emitRestrictedMethod = true;\n+        } else {\n+            for (Attribute.Compound anno : m.type.getReturnType().getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    emitRestrictedMethod = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (emitRestrictedMethod) {\n+            int alenIdx = writeAttr(names.RestrictedMethod);\n+            databuf.appendByte(m.externalType(types).getParameterTypes().size());\n+            if (types.flattenWithTypeRestrictions) {\n+                if (m.name == names.init && m.owner.hasOuterInstance()) {\n+                    Type outerThisType = types.erasure(m.owner.type.getEnclosingType());\n+                    databuf.appendChar(outerThisType.isValue() ? poolWriter.putDescriptor(outerThisType) : 0);\n+                }\n+                for (Type pt : m.erasure(types).getParameterTypes()) {\n+                    databuf.appendChar(pt.isValue() ? poolWriter.putDescriptor(pt) : 0);\n+                }\n+                Type rt = m.erasure(types).getReturnType();\n+                databuf.appendChar(rt.isValue() ? poolWriter.putDescriptor(rt) : 0);\n+            } else {\n+                int restrictedTypeDescriptor;\n+                for (Type pt : m.type.getParameterTypes()) {\n+                    restrictedTypeDescriptor = 0;\n+                    for (Attribute.Compound anno : pt.getAnnotationMirrors()) {\n+                        if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                            Attribute member = anno.member(names.value);\n+                            Assert.check(member.type.tsym == syms.stringType.tsym);\n+                            String utf8 = (String) member.getValue();\n+                            restrictedTypeDescriptor = poolWriter.putName(names.fromString(utf8));\n+                        }\n+                    }\n+                    databuf.appendChar(restrictedTypeDescriptor);\n+                }\n+                restrictedTypeDescriptor = 0;\n+                Type rt = m.type.getReturnType();\n+                for (Attribute.Compound anno : rt.getAnnotationMirrors()) {\n+                    if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                        Attribute member = anno.member(names.value);\n+                        Assert.check(member.type.tsym == syms.stringType.tsym);\n+                        String utf8 = (String) member.getValue();\n+                        restrictedTypeDescriptor = poolWriter.putName(names.fromString(utf8));\n+                    }\n+                }\n+                databuf.appendChar(restrictedTypeDescriptor);\n+            }\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+    public final Name RestrictedField;\n+    public final Name RestrictedMethod;\n@@ -340,0 +342,2 @@\n+        RestrictedField = fromString(\"RestrictedField\");\n+        RestrictedMethod = fromString(\"RestrictedMethod\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -656,0 +656,16 @@\n+        @Override\n+        public Void visitRestrictedField(RestrictedField_attribute attr, ClassOutputStream out) {\n+            out.writeShort(attr.restricted_type_index);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitRestrictedMethod(RestrictedMethod_attribute attr, ClassOutputStream out) {\n+            out.writeByte(attr.num_params);\n+            for (int i = 0; i < attr.num_params; i++) {\n+                out.writeShort(attr.restricted_param_type[i]);\n+            }\n+            out.writeShort(attr.restricted_return_type);\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}