{"files":[{"patch":"@@ -2276,4 +2276,3 @@\n-            \/* Per our interim inline class translation scheme, the reference projection classes\n-               are completely empty, so we want the methods in the value class to be invoked instead.\n-               As the lambda meta factory isn't clued into this, it will try to invoke the method in\n-               C$ref.class and fail with a NoSuchMethodError. we need to workaround it ourselves.\n+            \/* Workaround to BootstrapMethodError. This workaround should not be required in the unified\n+               class generation model. Todo: Investigate to see if a defect should be reported against\n+               runtime lambda machinery\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1143,3 +1143,0 @@\n-                if (requireReferenceProjection) {\n-                    flatname = flatname.append('$', names.ref);\n-                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,2 +74,0 @@\n-import static com.sun.tools.javac.code.Type.ClassType.Flavor.L_TypeOf_Q;\n-import static com.sun.tools.javac.code.Type.ClassType.Flavor.Q_TypeOf_Q;\n@@ -556,12 +554,6 @@\n-                name = names.fromUtf(signatureBuffer,\n-                        startSbp,\n-                        sbp - startSbp);\n-                if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                    name = name.subName(0, name.length() - 4);\n-                    Assert.check(prefix == 'L');\n-                    flavor = L_TypeOf_Q;\n-                } else {\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                }\n-                ClassSymbol t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                                                         startSbp,\n+                                                         sbp - startSbp));\n+\n+                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -571,6 +563,2 @@\n-                        if (flavor == L_TypeOf_Q) {\n-                            return et.referenceProjection();\n-                        } else {\n-                            \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n-                            return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n-                        }\n+                        \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n@@ -585,12 +573,5 @@\n-                name = names.fromUtf(signatureBuffer,\n-                        startSbp,\n-                        sbp - startSbp);\n-                if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                    name = name.subName(0, name.length() - 4);\n-                    Assert.check(prefix == 'L');\n-                    flavor = L_TypeOf_Q;\n-                } else {\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                }\n-                ClassSymbol t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                                                         startSbp,\n+                                                         sbp - startSbp));\n+                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -657,12 +638,5 @@\n-                    name = names.fromUtf(signatureBuffer,\n-                            startSbp,\n-                            sbp - startSbp);\n-                    if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                        name = name.subName(0, name.length() - 4);\n-                        Assert.check(prefix == 'L');\n-                        flavor = L_TypeOf_Q;\n-                    } else {\n-                        \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                        flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                    }\n-                    t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                    t = enterClass(names.fromUtf(signatureBuffer,\n+                                                 startSbp,\n+                                                 sbp - startSbp));\n+                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -2524,19 +2498,0 @@\n-    \/**\n-     * Special routine to enter a class that we conclude must be a primitive class from naming convention\n-     * E.g, if we see LFoo$ref in descriptors, we discern that to be the reference projection of the primitive\n-     * class Foo\n-     *\/\n-    protected ClassSymbol enterPrimitiveClass(Name name) {\n-        ClassSymbol c = enterClass(name);\n-        noticePrimitiveClass(c);\n-        return c;\n-    }\n-\n-    private void noticePrimitiveClass(ClassSymbol c) {\n-        ClassType ct = (ClassType) c.type;\n-        ct.flavor = ct.flavor.metamorphose(true);\n-        if (c.erasure_field != null) {\n-            ((ClassType) c.erasure_field).flavor = ct.flavor;\n-        }\n-    }\n-\n@@ -2652,3 +2607,0 @@\n-                if ((flags & PRIMITIVE_CLASS) != 0) {\n-                    noticePrimitiveClass(member); \/\/ Do we care to do this ?\n-                }\n@@ -2709,26 +2661,0 @@\n-        readClassFileInternal(c);\n-        if (c.isPrimitiveClass()) {\n-            \/* http:\/\/cr.openjdk.java.net\/~briangoetz\/valhalla\/sov\/04-translation.html\n-               The relationship of value and reference projections differs between the language model\n-               and the VM model. In the language, the value projection is not a subtype of the\n-               reference projection; instead, the two are related by inline narrowing and widening\n-               conversions, whereas in the VM, the two are related by actual subtyping.\n-               Sever the subtyping relationship by rewiring the supertypes here and now.\n-             *\/\n-\n-            Name flatname = TypeSymbol.formFlatName(names.ref, c);\n-            ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);\n-            if (referenceProjection != null) {\n-                if (referenceProjection.name != names.ref && referenceProjection.owner.kind == PCK) {\n-                    referenceProjection.complete();\n-                    ClassType classType = (ClassType) c.type;\n-                    classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;\n-                    classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;\n-                    \/\/ Discard the projection, it will be recomputed on the fly.\n-                    referenceProjection.owner.members().remove(referenceProjection);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void readClassFileInternal(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":18,"deletions":92,"binary":false,"changes":110,"status":"modified"}]}