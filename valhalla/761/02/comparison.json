{"files":[{"patch":"@@ -54,1 +54,1 @@\n- * An Externalizable instance can designate a substitution object via\n+ * An Externalizable object can designate a substitution object via\n@@ -56,1 +56,7 @@\n- * interface.<br>\n+ * interface. To control the serialized form of Records and Externalizable value classes\n+ * the record or class uses {@link Serializable} {@code writeReplace}\n+ * to delegate to another serializable or externalizable class and that delegate\n+ * uses {@code readResolve} to supply the replacement on deserialization.\n+ * Value classes implementing {@link Externalizable}\n+ * and not using {@code writeReplace} are not supported.\n+ * <br>\n","filename":"src\/java.base\/share\/classes\/java\/io\/Externalizable.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -219,0 +219,2 @@\n+ * value objects cannot be `java.io.Externalizable` because value objects are\n+ * immutable and `Externalizable.readExternal` is unable to modify the fields of the value.\n@@ -244,0 +246,5 @@\n+ * <p>Value objects are deserialized differently than ordinary serializable objects or records.\n+ * See <a href=\"{@docRoot}\/..\/specs\/serialization\/serial-arch.html#serialization-of-value-objects\">\n+ * <cite>Java Object Serialization Specification,<\/cite> Section 1.1xx,\n+ * \"Serialization of Value Objects\"<\/a> for additional information.\n+ *\n@@ -2265,1 +2272,2 @@\n-        passHandle = handles.assign(unshared ? unsharedMarker : obj);\n+        \/\/ Assign the handle and initially set to null or the unsharedMarker\n+        passHandle = handles.assign(unshared ? unsharedMarker : null);\n@@ -2278,0 +2286,6 @@\n+            if (desc.isValue()) {\n+                throw new NotSerializableException(\"Externalizable not valid for value class \"\n+                        + cl.getName());\n+            }\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n@@ -2279,0 +2293,7 @@\n+        } else if (desc.isValue()) {\n+            \/\/ For value objects, read the fields and finish the buffer before publishing the ref\n+            assert obj != null : \"obj == null: \" + desc;\n+            readSerialData(obj, desc);\n+            obj = desc.finishValue(obj);\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n@@ -2280,0 +2301,3 @@\n+            \/\/ For all other objects, publish the ref and then read the data\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -131,0 +131,6 @@\n+ * Value classes implementing {@link Externalizable} cannot be serialized\n+ * or deserialized, the value object is immutable and the state cannot be restored.\n+ * Use {@link Serializable} {@code writeReplace} to delegate to another serializable\n+ * object such as a record.\n+ *\n+ * Value objects cannot be `java.io.Externalizable`.\n@@ -1187,2 +1193,0 @@\n-            } else if (cl.isValue()) {\n-                throw new NotSerializableException(cl.getName());\n@@ -1449,0 +1453,3 @@\n+                if (desc.forClass().isValue())\n+                    throw new NotSerializableException(\"Externalizable not valid for value class \"\n+                            + desc.forClass().getName());\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -76,1 +75,1 @@\n- *    <cite>Java Object Serialization Specification,<\/cite> Section 4.6, \"Stream Unique Identifiers\"<\/a>.\n+ *    <cite>Java Object Serialization Specification<\/cite>, Section 4.6, \"Stream Unique Identifiers\"<\/a>.\n@@ -139,0 +138,2 @@\n+    \/** true if represents a value class *\/\n+    private boolean isValue;\n@@ -378,0 +379,1 @@\n+        isValue = cl.isValue();\n@@ -411,0 +413,3 @@\n+                    } else if (isValue) {\n+                        \/\/ Value objects are created using Unsafe.\n+                        cons = null;\n@@ -448,3 +453,1 @@\n-            } else if (cl.isValue() && writeReplaceMethod == null) {\n-                deserializeEx = new ExceptionInfo(name, \"value class\");\n-            } else if (cons == null && !isRecord) {\n+            } else if (cons == null && !(isRecord | isValue)) {\n@@ -644,0 +647,1 @@\n+            isValue = localDesc.isValue;\n@@ -925,0 +929,8 @@\n+    \/**\n+     * {@return {code true} if the class is a value class, {@code false} otherwise}\n+     *\/\n+    boolean isValue() {\n+        requireInitialized();\n+        return isValue;\n+    }\n+\n@@ -947,1 +959,1 @@\n-     * externalizable and defines a public no-arg constructor, or if it is\n+     * externalizable and defines a public no-arg constructor, if it is\n@@ -949,1 +961,2 @@\n-     * accessible no-arg constructor.  Otherwise, returns false.\n+     * accessible no-arg constructor, or if the class is a value class.\n+     * Otherwise, returns false.\n@@ -953,1 +966,1 @@\n-        return (cons != null);\n+        return (cons != null | isValue);\n@@ -1058,1 +1071,4 @@\n-        } else {\n+        } else if (isValue) {\n+            \/\/ Start with a buffered default value.\n+            return FieldReflector.newValueInstance(cl);\n+        }  else {\n@@ -1063,0 +1079,9 @@\n+    \/**\n+     * Finish the initialization of a value object.\n+     * @param obj an object (larval if a value object)\n+     * @return the finished object\n+     *\/\n+    Object finishValue(Object obj) {\n+        return (isValue) ? FieldReflector.finishValueInstance(obj) : obj;\n+    }\n+\n@@ -1930,0 +1955,22 @@\n+        \/**\n+         * Return a new instance of the class using Unsafe.uninitializedDefaultValue\n+         * and buffer it.\n+         * @param clazz The value class\n+         * @return a buffered default value\n+         *\/\n+        static Object newValueInstance(Class<?> clazz) throws InstantiationException{\n+            assert clazz.isValue() : \"Should be a value class\";\n+            Object obj = unsafe.uninitializedDefaultValue(clazz);\n+            return unsafe.makePrivateBuffer(obj);\n+        }\n+\n+        \/**\n+         * Finish a value object, clear the larval state and returning the value object.\n+         * @param obj a buffered value object in a larval state\n+         * @return the finished value object\n+         *\/\n+        static Object finishValueInstance(Object obj) {\n+            assert (obj.getClass().isValue()) : \"Should be a value class\";\n+            return unsafe.finishPrivateBuffer(obj);\n+        }\n+\n@@ -2050,0 +2097,1 @@\n+                Field f = fields[i].getField();\n@@ -2051,1 +2099,4 @@\n-                    case 'L', '[' -> unsafe.getReference(obj, readKeys[i]);\n+                    case 'L', '[' ->\n+                            unsafe.isFlattened(f)\n+                                    ? unsafe.getValue(obj, readKeys[i], f.getType())\n+                                    : unsafe.getReference(obj, readKeys[i]);\n@@ -2088,0 +2139,1 @@\n+                        Field f = fields[i].getField();\n@@ -2092,1 +2144,0 @@\n-                            Field f = fields[i].getField();\n@@ -2101,2 +2152,7 @@\n-                        if (!dryRun)\n-                            unsafe.putReference(obj, key, val);\n+                        if (!dryRun) {\n+                            if (unsafe.isFlattened(f)) {\n+                                unsafe.putValue(obj, key, f.getType(), val);\n+                            } else {\n+                                unsafe.putReference(obj, key, val);\n+                            }\n+                        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":69,"deletions":13,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -146,1 +146,10 @@\n- * handling methods discussed above are ignored for record types.<p>\n+ * handling methods discussed above, except {@code writeReplace},\n+ * are ignored for record types.<p>\n+ *\n+ * Value classes can implement {@code Serializble} and receive the treatment defined\n+ * by the <a href=\"{@docRoot}\/..\/specs\/serialization\/serial-arch.html#serialization-of-value-objects\">\n+ * <cite>Java Object Serialization Specification,<\/cite> Section 1.1xx,\n+ * \"Serialization of Value Objects\"<\/a>. Any declarations of the special\n+ * handling methods discussed above, except {@code writeReplace},\n+ * are ignored for value types. Value classes implementing {@link Externalizable}\n+ * and not using {@code writeReplace} are not supported.<p>\n","filename":"src\/java.base\/share\/classes\/java\/io\/Serializable.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -335,0 +335,3 @@\n+        if (cl.isValue()) {\n+            throw new UnsupportedOperationException(\"newConstructorForSerialization does not support value classes\");\n+        }\n@@ -394,0 +397,4 @@\n+        if (cl.isValue()) {\n+            throw new UnsupportedOperationException(\"newConstructorForSerialization does not support value classes\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,396 @@\n+\/*\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @summary Serialize and deserialize value objects\n+ * @run testng\/othervm  SimpleValueGraphs\n+ *\/\n+\n+import java.lang.StackOverflowError;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutput;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.io.InvalidClassException;\n+import java.io.InvalidObjectException;\n+import java.io.NotSerializableException;\n+\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.Objects;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.ObjectStreamPrinter;\n+\n+@Test\n+public class SimpleValueGraphs implements Serializable {\n+\n+    private static boolean DEBUG = false;\n+\n+    private static SimpleValue foo1 = new SimpleValue(\"One\", 1);\n+    private static SimpleValue foo2 = new SimpleValue(\"Two\", 2);\n+\n+    @DataProvider(name = \"ValueObjects\")\n+    public Object[][] valueObjects() {\n+        return new Object[][] {\n+                {new SimpleValue(new SimpleValue(1))},\n+                {new SimpleValue(new SimpleValue(2), 3)},\n+                {new SimpleValue[] {foo1, foo1, foo2, foo1, foo2 }},\n+        };\n+    }\n+\n+    @Test(enabled = true, dataProvider = \"ValueObjects\")\n+    public void roundTrip(Object expected) throws Exception {\n+        byte[] bytes = serialize(expected);\n+\n+        if (DEBUG)\n+            HexPrinter.simple().dest(System.out).formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+\n+        Object actual = deserialize(bytes);\n+        System.out.println(\"actual: \" + actual.toString());\n+        Assert.assertEquals(actual, expected, \"Mismatch\" + expected.getClass());\n+    }\n+\n+    private static Tree treeI = Tree.makeTree(3, (l, r) -> new TreeI((TreeI)l, (TreeI)l));\n+    private static Tree treeV = Tree.makeTree(3, (l, r) -> new TreeV((TreeV)l, (TreeV)l));\n+\n+    \/\/ Create a tree of identity objects with a cycle; it will serialize ok, but when deserialized as\n+    \/\/ a value class the cycle is broken by replacing the back ref with null.\n+    private static Tree treeCycle(boolean cycle) {\n+        TreeI tree = (TreeI)Tree.makeTree(3, (l, r) -> new TreeI((TreeI)l, (TreeI)l));\n+        tree.setLeft(cycle ? tree : null);     \/\/ force a cycle or null\n+        return tree;\n+    }\n+\n+    @DataProvider(name = \"CompatibleChanges\")\n+    public Object[][] migrationObjects() {\n+        return new Object[][] {\n+                {treeI, \"TreeI\", \"TreeV\", treeV},       \/\/ Serialize as an identity class, deserialize as Value class\n+                {treeCycle(true), \"TreeI\", \"TreeV\", treeCycle(false)},\n+                \/\/ TBD: add cases for serializing TreeV and converting to TreeI:\n+                \/\/ Waiting for:\n+                \/\/ JDK-8293321: [lworld] PrimitiveObjectMethods.substitutableInvoker StackOverFlowError\n+        };\n+    }\n+\n+    \/**\n+     * Test serializing a object graph, and deserialize with a modification of the serialized form.\n+     * The modifications to the stream change the class name being deserialized.\n+     * The cases include serializing an identity class and deserialize the corresponding\n+     * value class.\n+     *\n+     * @param origObj an object to serialize\n+     * @param origName a string in the serialized stream to replace\n+     * @param replName a string to replace the original string\n+     * @param expectedObject the expected object (graph) or an exception if it should fail\n+     * @throws Exception some unexpected exception may be thrown and cause the test to fail\n+     *\/\n+    @Test(enabled = true, dataProvider = \"CompatibleChanges\")\n+    public void treeVTest(Object origObj, String origName, String replName, Object expectedObject) throws Exception {\n+        byte[] bytes = serialize(origObj);\n+        if (DEBUG) {\n+            System.out.println(\"Original serialized \" + origObj.getClass().getName());\n+            HexPrinter.simple().dest(System.out).formatter(ObjectStreamPrinter.formatter()).format(bytes);\n+        }\n+\n+        \/\/ Modify the serialized bytes to change a class name from the serialized name\n+        \/\/ to a different class. The replacement name must be the same length as thr original name.\n+        byte[] replBytes = patchBytes(bytes, origName, replName);\n+        if (DEBUG) {\n+            System.out.println(\"Modified serialized \" + origObj.getClass().getName());\n+            HexPrinter.simple().dest(System.out).formatter(ObjectStreamPrinter.formatter()).format(replBytes);\n+        }\n+        try {\n+            Object actual = deserialize(replBytes);\n+            if (expectedObject instanceof Exception ex) {\n+                Assert.fail(\"Unexpected: \" + expectedObject);\n+            }\n+            \/\/ Compare the shape of the actual and expected trees\n+            Assert.assertEquals(actual.toString(), expectedObject.toString(),\n+                    \"Resulting object not equals: \" + actual.getClass().getName());\n+\n+        } catch (Exception ex) {\n+            Assert.assertEquals(ex.getClass(), expectedObject.getClass(), \"exception type\");\n+            Assert.assertEquals(ex.getMessage(), ((Exception)expectedObject).getMessage(), \"exception message\");\n+        }\n+    }\n+\n+    \/**\n+     * Serialize an object and return the serialized bytes.\n+     *\n+     * @param expected an object to serialize\n+     * @return a byte array containing the serialized object\n+     *\/\n+    private static byte[] serialize(Object expected) throws IOException {\n+        try (ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+             ObjectOutputStream oout = new ObjectOutputStream(bout)) {\n+            oout.writeObject(expected);\n+            oout.flush();\n+            return bout.toByteArray();\n+        }\n+    }\n+\n+    \/**\n+     * Deserialize an object from the byte array.\n+     * @param bytes a byte array\n+     * @return an Object read from the byte array\n+     *\/\n+    private static Object deserialize(byte[] bytes) throws IOException, ClassNotFoundException {\n+        try (ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+             ObjectInputStream oin = new ObjectInputStream(bin)) {\n+            return oin.readObject();\n+        }\n+    }\n+\n+    \/**\n+     * Replace every occurence of the string in the byte array with the replacement.\n+     * The strings are US_ASCII only.\n+     * @param bytes a byte array\n+     * @param orig a string, converted to bytes using US_ASCII, originally exists in the bytes\n+     * @param repl a string, converted to byted using US_ASCII, to replace the original bytes\n+     * @return a new byte array that has been patched\n+     *\/\n+    private byte[] patchBytes(byte[] bytes, String orig, String repl) {\n+        byte[] alt = patchBytes(bytes,\n+                orig.getBytes(StandardCharsets.US_ASCII),\n+                repl.getBytes(StandardCharsets.US_ASCII));\n+        return alt;\n+    }\n+\n+    \/**\n+     * Replace every occurence of the original bytes in the byte array with the replacement bytes.\n+     * @param bytes a byte array\n+     * @param orig a byte array containing existing bytes in the byte array\n+     * @param repl a byte array to replace the original bytes\n+     * @return a copy of the bytes array with each occurence of the orig bytes with the replacement bytes\n+     *\/\n+    static byte[] patchBytes(byte[] bytes, byte[] orig, byte[] repl) {\n+        if (orig.length != repl.length && orig.length > 0)\n+            throw new IllegalArgumentException(\"orig bytes and replacement must be same length\");\n+        byte[] result = Arrays.copyOf(bytes, bytes.length);\n+        for (int i = 0; i < result.length - orig.length; i++) {\n+            if (Arrays.equals(result, i, i + orig.length, orig, 0, orig.length)) {\n+                for (int j = 0; j < orig.length; j++) {\n+                    result[i + j] = repl[j];\n+                }\n+                i = i + orig.length - 1;    \/\/ continue replacing after this occurrence\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public static class SimpleValue implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+\n+        int i;\n+        Serializable obj;\n+\n+        public SimpleValue(Serializable o) {\n+            this.obj = o;\n+            this.i = 0;\n+        }\n+        SimpleValue(int i) {\n+            this.i = i;\n+        }\n+\n+        public SimpleValue(Serializable o, int i) {\n+            this.obj = o;\n+            this.i = i;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (obj instanceof SimpleValue simpleValue) {\n+                return (i == simpleValue.i && Objects.equals(obj, simpleValue));\n+            }\n+            return false;\n+        }\n+\n+        public int hashCode() {\n+            return i;\n+        }\n+\n+        public String toString() {\n+            return \"SimpleValue{\" + \"i=\" + i + \", obj=\" + obj + '}';\n+        }\n+    }\n+\n+    interface Tree {\n+        static Tree makeTree(int depth, BiFunction<Tree, Tree, Tree> genNode) {\n+            if (depth <= 0) return null;\n+            Tree left = makeTree(depth - 1, genNode);\n+            Tree right = makeTree(depth - 1, genNode);\n+            Tree t = genNode.apply(left, right);\n+            return t;\n+        }\n+\n+        Tree left();\n+        Tree right();\n+    }\n+    static identity class TreeI implements Tree, Serializable {\n+\n+        private static final long serialVersionUID = 2L;\n+        private TreeI left;\n+        private TreeI right;\n+\n+        TreeI(TreeI left, TreeI right) {\n+            this.left = left;\n+            this.right = right;\n+        }\n+\n+        public TreeI left() {\n+            return left;\n+        }\n+        public TreeI right() {\n+            return right;\n+        }\n+\n+        public void setLeft(TreeI left) {\n+            this.left = left;\n+        }\n+        public void setRight(TreeI right) {\n+            this.right = right;\n+        }\n+\n+        public boolean equals(Object other) {\n+            \/\/ avoid ==, is substutible check causes stack overflow.\n+            if (other instanceof TreeV tree) {\n+                boolean leftEq = (this.left == null && tree.left == null) ||\n+                        left.equals(tree.left);\n+                boolean rightEq = (this.right == null && tree.right == null) ||\n+                        right.equals(tree.right);\n+                return leftEq == rightEq;\n+            }\n+            return false;\n+        }\n+        public String toString() {\n+            return toString(5);\n+        }\n+        public String toString(int depth) {\n+            if (depth <= 0)\n+                return \"!\";\n+            String l = (left != null) ? left.toString(depth - 1) : Character.toString(126);\n+            String r = (right != null) ? right.toString(depth - 1) : Character.toString(126);\n+            return \"(\" + l + r + \")\";\n+        }\n+    }\n+\n+    static value class TreeV implements Tree, Serializable {\n+\n+        private static final long serialVersionUID = 2L;\n+        private TreeV left;\n+        private TreeV right;\n+\n+        TreeV(TreeV left, TreeV right) {\n+            this.left = left;\n+            this.right = right;\n+        }\n+\n+        public TreeV left() {\n+            return left;\n+        }\n+        public TreeV right() {\n+            return right;\n+        }\n+\n+        public boolean equals(Object other) {\n+            \/\/ avoid ==, is substutible check causes stack overflow.\n+            if (other instanceof TreeV tree) {\n+                return compRef(this.left, tree.left) && compRef(this.right, tree.right);\n+            }\n+            return false;\n+        }\n+\n+        \/\/ Compare references but don't use ==; isSubstutitable may recurse\n+        private static boolean compRef(Object o1, Object o2) {\n+            if (o1 == null && o2 == null)\n+                return true;\n+            if (o1 != null && o2 != null)\n+                return o1.equals(o2);\n+            return false;\n+\n+        }\n+        public String toString() {\n+            return toString(10);\n+        }\n+        public String toString(int depth) {\n+            if (depth <= 0)\n+                return \"!\";\n+            String l = (left != null) ? left.toString(depth - 1) : Character.toString(126);\n+            String r = (right != null) ? right.toString(depth - 1) : Character.toString(126);\n+            return \"(\" + l + r + \")\";\n+        }\n+    }\n+\n+    @Test\n+    void testExternalizableNotSer() {\n+        var obj = new ValueExt();\n+        var ex = Assert.expectThrows(NotSerializableException.class, () -> serialize(obj));\n+        Assert.assertTrue(ex.getMessage().contains(\"Externalizable not valid for value class\"));\n+    }\n+\n+    @Test\n+    void testExternalizableNotDeser() throws IOException {\n+        var obj = new IdentExt();\n+        byte[] bytes = serialize(obj);\n+        byte[] newBytes = patchBytes(bytes, \"IdentExt\", \"ValueExt\");\n+        var ex = Assert.expectThrows(NotSerializableException.class, () -> deserialize(newBytes));\n+        Assert.assertTrue(ex.getMessage().contains(\"Externalizable not valid for value class\"));\n+    }\n+\n+    \/\/ Exception trying to serialize\n+    \/\/ Exception trying to deserialize\n+\n+    static identity class IdentExt implements Externalizable {\n+        public void writeExternal(ObjectOutput is) {\n+\n+        }\n+        public void readExternal(ObjectInput is) {\n+\n+        }\n+        private static final long serialVersionUID = 3L;\n+    }\n+\n+    static value class ValueExt implements Externalizable {\n+        public void writeExternal(ObjectOutput is) {\n+\n+        }\n+        public void readExternal(ObjectInput is) {\n+\n+        }\n+        private static final long serialVersionUID = 3L;\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/valueObjects\/SimpleValueGraphs.java","additions":396,"deletions":0,"binary":false,"changes":396,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary ValueSerialization support of value classes\n+ * @run testng\/othervm ValueSerialization\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.InvalidClassException;\n+import java.io.InvalidObjectException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectInput;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutput;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.io.ObjectStreamConstants.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.expectThrows;\n+\n+public class ValueSerialization {\n+\n+    static final Class<NotSerializableException> NSE = NotSerializableException.class;\n+\n+    @DataProvider(name = \"doesNotImplementSerializable\")\n+    public Object[][] doesNotImplementSerializable() {\n+        return new Object[][] {\n+            new Object[] { new NonSerializablePoint(10, 100) },\n+            \/\/ an array of Points\n+            new Object[] { new NonSerializablePoint[] {new NonSerializablePoint(1, 5)} },\n+            new Object[] { new Object[] {new NonSerializablePoint(3, 7)} },\n+            new Object[] { new ExternalizablePoint(12, 102) },\n+            new Object[] { new ExternalizablePoint[] {\n+                    new ExternalizablePoint(3, 7),\n+                    new ExternalizablePoint(2, 8) } },\n+            new Object[] { new Object[] {\n+                    new ExternalizablePoint(13, 17),\n+                    new ExternalizablePoint(14, 18) } },\n+        };\n+    }\n+\n+    \/\/ value class that DOES NOT implement Serializable should throw NSE\n+    @Test(dataProvider = \"doesNotImplementSerializable\")\n+    public void doesNotImplementSerializable(Object obj) {\n+        assertThrows(NSE, () -> serialize(obj));\n+    }\n+\n+    \/** Non-Serializable point. *\/\n+    public static value class NonSerializablePoint {\n+        public int x;\n+        public int y;\n+\n+        public NonSerializablePoint(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    \/** A Serializable Point *\/\n+    static value class SerializablePoint implements Serializable {\n+        public int x;\n+        public int y;\n+        SerializablePoint(int x, int y) { this.x = x; this.y = y; }\n+        @Override public String toString() {\n+            return \"[SerializablePoint x=\" + x + \" y=\" + y + \"]\"; }\n+    }\n+\n+    \/** An Externalizable Point is not Serializable, readExternal cannot modify fields *\/\n+    static value class ExternalizablePoint implements Externalizable {\n+        public int x;\n+        public int y;\n+        ExternalizablePoint(int x, int y) { this.x = x; this.y = y; }\n+        @Override public void readExternal(ObjectInput in) {  }\n+        @Override public void writeExternal(ObjectOutput out) {  }\n+        @Override public String toString() {\n+            return \"[ExternalizablePoint x=\" + x + \" y=\" + y + \"]\"; }\n+    }\n+\n+    @DataProvider(name = \"doesImplementSerializable\")\n+    public Object[][] doesImplementSerializable() {\n+        return new Object[][] {\n+            new Object[] { new SerializablePoint(11, 101) },\n+            new Object[] { new SerializablePoint[] {\n+                    new SerializablePoint(1, 5),\n+                    new SerializablePoint(2, 6) } },\n+            new Object[] { new Object[] {\n+                    new SerializablePoint(3, 7),\n+                    new SerializablePoint(4, 8) } },\n+        };\n+    }\n+\n+    \/\/ value class that DOES implement Serializable all supported\n+    @Test(dataProvider = \"doesImplementSerializable\")\n+    public void doesImplementSerializable(Object obj) throws IOException {\n+        serialize(obj);\n+    }\n+\n+    \/** A Serializable Foo, with a serial proxy *\/\n+    static value class SerializableFoo implements Serializable {\n+        public int x;\n+        SerializableFoo(int x) { this.x = x; }\n+\n+        Object writeReplace() throws ObjectStreamException {\n+            return new SerialFooProxy(x);\n+        }\n+        private void readObject(ObjectInputStream s) throws InvalidObjectException {\n+            throw new InvalidObjectException(\"Proxy required\");\n+        }\n+        private static class SerialFooProxy implements Serializable {\n+            final int x;\n+            SerialFooProxy(int x) { this.x = x; }\n+            Object readResolve() throws ObjectStreamException {\n+                return new SerializableFoo(this.x);\n+            }\n+        }\n+    }\n+\n+    \/** An Externalizable Foo, with a serial proxy *\/\n+    static value class ExternalizableFoo implements Externalizable {\n+        public String s;\n+        ExternalizableFoo(String s) {  this.s = s; }\n+        Object writeReplace() throws ObjectStreamException {\n+            return new SerialFooProxy(s);\n+        }\n+        private void readObject(ObjectInputStream s) throws InvalidObjectException {\n+            throw new InvalidObjectException(\"Proxy required\");\n+        }\n+        private static class SerialFooProxy implements Serializable {\n+            final String s;\n+            SerialFooProxy(String s) { this.s = s; }\n+            Object readResolve() throws ObjectStreamException {\n+                return new ExternalizableFoo(this.s);\n+            }\n+        }\n+        @Override public void readExternal(ObjectInput in) {  }\n+        @Override public void writeExternal(ObjectOutput out) {  }\n+    }\n+\n+    \/\/ value classes that DO implement Serializable, but have a serial proxy\n+    @Test\n+    public void serializableFooWithProxy() throws Exception {\n+        SerializableFoo foo = new SerializableFoo(45);\n+        SerializableFoo foo1 = serializeDeserialize(foo);\n+        assertEquals(foo.x, foo1.x);\n+    }\n+    @Test\n+    public void serializableFooArrayWithProxy() throws Exception {\n+        SerializableFoo[] fooArray = new SerializableFoo[]{new SerializableFoo(46)};\n+        SerializableFoo[] fooArray1 = serializeDeserialize(fooArray);\n+        assertEquals(fooArray.length, fooArray1.length);\n+        assertEquals(fooArray[0].x, fooArray1[0].x);\n+    }\n+    @Test\n+    public void externalizableFooWithProxy() throws Exception {\n+        ExternalizableFoo foo = new ExternalizableFoo(\"hello\");\n+        ExternalizableFoo foo1 = serializeDeserialize(foo);\n+        assertEquals(foo.s, foo1.s);\n+    }\n+    @Test\n+    public void externalizableFooArrayWithProxy() throws Exception {\n+        ExternalizableFoo[] fooArray = new ExternalizableFoo[] { new ExternalizableFoo(\"there\") };\n+        ExternalizableFoo[] fooArray1 = serializeDeserialize(fooArray);\n+        assertEquals(fooArray.length, fooArray1.length);\n+        assertEquals(fooArray[0].s, fooArray1[0].s);\n+    }\n+\n+    private static byte[] byteStreamFor(String className, long uid, byte flags)\n+        throws Exception\n+    {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream dos = new DataOutputStream(baos);\n+        dos.writeShort(STREAM_MAGIC);\n+        dos.writeShort(STREAM_VERSION);\n+        dos.writeByte(TC_OBJECT);\n+        dos.writeByte(TC_CLASSDESC);\n+        dos.writeUTF(className);\n+        dos.writeLong(uid);\n+        dos.writeByte(flags);\n+        dos.writeShort(0);             \/\/ number of fields\n+        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n+        dos.writeByte(TC_NULL);           \/\/ no superclasses\n+        dos.close();\n+        return baos.toByteArray();\n+    }\n+\n+    private static byte[] serializableByteStreamFor(String className, long uid)\n+        throws Exception\n+    {\n+        return byteStreamFor(className, uid, SC_SERIALIZABLE);\n+    }\n+\n+    private static byte[] externalizableByteStreamFor(String className, long uid)\n+         throws Exception\n+    {\n+        return byteStreamFor(className, uid, SC_EXTERNALIZABLE);\n+    }\n+\n+    @DataProvider(name = \"classes\")\n+    public Object[][] classes() {\n+        return new Object[][] {\n+            new Object[] { NonSerializablePoint.class },\n+            new Object[] { SerializablePoint.class }\n+        };\n+    }\n+\n+    static final Class<InvalidClassException> ICE = InvalidClassException.class;\n+\n+    \/\/ value class read directly from a byte stream, both serializable and externalizable are supported\n+    @Test(dataProvider = \"classes\")\n+    public void deserialize(Class<?> cls) throws Exception {\n+        var clsDesc = ObjectStreamClass.lookup(cls);\n+        long uid = clsDesc == null ? 0L : clsDesc.getSerialVersionUID();\n+\n+        byte[] serialBytes = serializableByteStreamFor(cls.getName(), uid);\n+\n+        byte[] extBytes = externalizableByteStreamFor(cls.getName(), uid);\n+    }\n+\n+    static <T> byte[] serialize(T obj) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(obj);\n+        oos.close();\n+        return baos.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T deserialize(byte[] streamBytes)\n+        throws IOException, ClassNotFoundException\n+    {\n+        ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);\n+        ObjectInputStream ois  = new ObjectInputStream(bais);\n+        return (T) ois.readObject();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T serializeDeserialize(T obj)\n+        throws IOException, ClassNotFoundException\n+    {\n+        return (T) deserialize(serialize(obj));\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/valueObjects\/ValueSerialization.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -1,283 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary No Serialization support of primitive classes, without a proxy\n- * @compile -XDenablePrimitiveClasses Point.java Line.java NonFlattenValue.java Serialization.java\n- * @run testng\/othervm Serialization\n- *\/\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataOutputStream;\n-import java.io.Externalizable;\n-import java.io.IOException;\n-import java.io.InvalidClassException;\n-import java.io.InvalidObjectException;\n-import java.io.NotSerializableException;\n-import java.io.ObjectInput;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutput;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectStreamClass;\n-import java.io.ObjectStreamException;\n-import java.io.Serializable;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static java.io.ObjectStreamConstants.*;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertThrows;\n-import static org.testng.Assert.expectThrows;\n-\n-public class Serialization {\n-\n-    static final Class<NotSerializableException> NSE = NotSerializableException.class;\n-\n-    @DataProvider(name = \"doesNotImplementSerializable\")\n-    public Object[][] doesNotImplementSerializable() {\n-        return new Object[][] {\n-            new Object[] { Point.makePoint(10, 100) },\n-            new Object[] { Line.makeLine(Point.makePoint(99, 99),\n-                                         Point.makePoint(888, 888)) },\n-            new Object[] { NonFlattenValue.make(1001, 10005) },\n-            \/\/ an array of Points\n-            new Object[] { new Point[] {\n-                    Point.makePoint(1, 5),\n-                    Point.makePoint(2, 6) } },\n-            new Object[] { new Object[] {\n-                    Point.makePoint(3, 7),\n-                    Point.makePoint(4, 8) } },\n-        };\n-    }\n-\n-    \/\/ primitive class that DOES NOT implement Serializable should throw NSE\n-    @Test(dataProvider = \"doesNotImplementSerializable\")\n-    public void doesNotImplementSerializable(Object obj) {\n-        assertThrows(NSE, () -> serialize(obj));\n-    }\n-\n-    \/** A Serializable Point *\/\n-    static primitive class SerializablePoint implements Serializable {\n-        public int x;\n-        public int y;\n-        SerializablePoint(int x, int y) { this.x = x; this.y = y; }\n-        static SerializablePoint make(int x, int y) {\n-            return new SerializablePoint(x, y);\n-        }\n-        @Override public String toString() {\n-            return \"[SerializablePoint x=\" + x + \" y=\" + y + \"]\"; }\n-    }\n-\n-    \/** An Externalizable Point *\/\n-    static primitive class ExternalizablePoint implements Externalizable {\n-        public int x;\n-        public int y;\n-        ExternalizablePoint(int x, int y) { this.x = x; this.y = y; }\n-        static ExternalizablePoint make(int x, int y) {\n-            return new ExternalizablePoint(x, y);\n-        }\n-        @Override public void readExternal(ObjectInput in) {  }\n-        @Override public void writeExternal(ObjectOutput out) {  }\n-        @Override public String toString() {\n-            return \"[ExternalizablePoint x=\" + x + \" y=\" + y + \"]\"; }\n-    }\n-\n-    @DataProvider(name = \"doesImplementSerializable\")\n-    public Object[][] doesImplementSerializable() {\n-        return new Object[][] {\n-            new Object[] { SerializablePoint.make(11, 101) },\n-            new Object[] { ExternalizablePoint.make(12, 102) },\n-            new Object[] { new ExternalizablePoint[] {\n-                    ExternalizablePoint.make(3, 7),\n-                    ExternalizablePoint.make(2, 8) } },\n-            new Object[] { new SerializablePoint[] {\n-                    SerializablePoint.make(1, 5),\n-                    SerializablePoint.make(2, 6) } },\n-            new Object[] { new Object[] {\n-                    SerializablePoint.make(3, 7),\n-                    SerializablePoint.make(4, 8) } },\n-            new Object[] { new Object[] {\n-                    ExternalizablePoint.make(13, 17),\n-                    ExternalizablePoint.make(14, 18) } },\n-        };\n-    }\n-\n-    \/\/ primitive class that DOES implement Serializable should throw NSE\n-    @Test(dataProvider = \"doesImplementSerializable\")\n-    public void doesImplementSerializable(Object obj) {\n-        assertThrows(NSE, () -> serialize(obj));\n-    }\n-\n-    \/** A Serializable Foo, with a serial proxy *\/\n-    static primitive class SerializableFoo implements Serializable {\n-        public int x;\n-        SerializableFoo(int x) { this.x = x; }\n-        static SerializableFoo make(int x) {\n-            return new SerializableFoo(x);\n-        }\n-        Object writeReplace() throws ObjectStreamException {\n-            return new SerialFooProxy(x);\n-        }\n-        private void readObject(ObjectInputStream s) throws InvalidObjectException {\n-            throw new InvalidObjectException(\"Proxy required\");\n-        }\n-        private static class SerialFooProxy implements Serializable {\n-            final int x;\n-            SerialFooProxy(int x) { this.x = x; }\n-            Object readResolve() throws ObjectStreamException {\n-                return SerializableFoo.make(this.x);\n-            }\n-        }\n-    }\n-\n-    \/** An Externalizable Foo, with a serial proxy *\/\n-    static primitive class ExternalizableFoo implements Externalizable {\n-        public String s;\n-        ExternalizableFoo(String s) {  this.s = s; }\n-        static ExternalizableFoo make(String s) {\n-            return new ExternalizableFoo(s);\n-        }\n-        Object writeReplace() throws ObjectStreamException {\n-            return new SerialFooProxy(s);\n-        }\n-        private void readObject(ObjectInputStream s) throws InvalidObjectException {\n-            throw new InvalidObjectException(\"Proxy required\");\n-        }\n-        private static class SerialFooProxy implements Serializable {\n-            final String s;\n-            SerialFooProxy(String s) { this.s = s; }\n-            Object readResolve() throws ObjectStreamException {\n-                return ExternalizableFoo.make(this.s);\n-            }\n-        }\n-        @Override public void readExternal(ObjectInput in) {  }\n-        @Override public void writeExternal(ObjectOutput out) {  }\n-    }\n-\n-    \/\/ primitive classes that DO implement Serializable, but have a serial proxy\n-    @Test\n-    public void serializableFooWithProxy() throws Exception {\n-        SerializableFoo foo = SerializableFoo.make(45);\n-        SerializableFoo foo1 = serializeDeserialize(foo);\n-        assertEquals(foo.x, foo1.x);\n-    }\n-    @Test\n-    public void serializableFooArrayWithProxy() throws Exception {\n-        SerializableFoo[] fooArray = new SerializableFoo[]{SerializableFoo.make(46)};\n-        SerializableFoo[] fooArray1 = serializeDeserialize(fooArray);\n-        assertEquals(fooArray.length, fooArray1.length);\n-        assertEquals(fooArray[0].x, fooArray1[0].x);\n-    }\n-    @Test\n-    public void externalizableFooWithProxy() throws Exception {\n-        ExternalizableFoo foo = ExternalizableFoo.make(\"hello\");\n-        ExternalizableFoo foo1 = serializeDeserialize(foo);\n-        assertEquals(foo.s, foo1.s);\n-    }\n-    @Test\n-    public void externalizableFooArrayWithProxy() throws Exception {\n-        ExternalizableFoo[] fooArray = new ExternalizableFoo[] { ExternalizableFoo.make(\"there\") };\n-        ExternalizableFoo[] fooArray1 = serializeDeserialize(fooArray);\n-        assertEquals(fooArray.length, fooArray1.length);\n-        assertEquals(fooArray[0].s, fooArray1[0].s);\n-    }\n-\n-    private static byte[] byteStreamFor(String className, long uid, byte flags)\n-        throws Exception\n-    {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        DataOutputStream dos = new DataOutputStream(baos);\n-        dos.writeShort(STREAM_MAGIC);\n-        dos.writeShort(STREAM_VERSION);\n-        dos.writeByte(TC_OBJECT);\n-        dos.writeByte(TC_CLASSDESC);\n-        dos.writeUTF(className);\n-        dos.writeLong(uid);\n-        dos.writeByte(flags);\n-        dos.writeShort(0);             \/\/ number of fields\n-        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n-        dos.writeByte(TC_NULL);           \/\/ no superclasses\n-        dos.close();\n-        return baos.toByteArray();\n-    }\n-\n-    private static byte[] serializableByteStreamFor(String className, long uid)\n-        throws Exception\n-    {\n-        return byteStreamFor(className, uid, SC_SERIALIZABLE);\n-    }\n-\n-    private static byte[] externalizableByteStreamFor(String className, long uid)\n-         throws Exception\n-    {\n-        return byteStreamFor(className, uid, SC_EXTERNALIZABLE);\n-    }\n-\n-    @DataProvider(name = \"classes\")\n-    public Object[][] classes() {\n-        return new Object[][] {\n-            new Object[] { Point.class             },\n-            new Object[] { SerializablePoint.class }\n-        };\n-    }\n-\n-    static final Class<InvalidClassException> ICE = InvalidClassException.class;\n-\n-    \/\/ primitive class read directly from a byte stream\n-    @Test(dataProvider = \"classes\")\n-    public void deserialize(Class<?> cls) throws Exception {\n-        var clsDesc = ObjectStreamClass.lookup(cls);\n-        long uid = clsDesc == null ? 0L : clsDesc.getSerialVersionUID();\n-\n-        byte[] serialBytes = serializableByteStreamFor(cls.getName(), uid);\n-        expectThrows(ICE, () -> deserialize(serialBytes));\n-\n-        byte[] extBytes = externalizableByteStreamFor(cls.getName(), uid);\n-        expectThrows(ICE, () -> deserialize(extBytes));\n-    }\n-\n-    static <T> byte[] serialize(T obj) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(baos);\n-        oos.writeObject(obj);\n-        oos.close();\n-        return baos.toByteArray();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static <T> T deserialize(byte[] streamBytes)\n-        throws IOException, ClassNotFoundException\n-    {\n-        ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);\n-        ObjectInputStream ois  = new ObjectInputStream(bais);\n-        return (T) ois.readObject();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static <T> T serializeDeserialize(T obj)\n-        throws IOException, ClassNotFoundException\n-    {\n-        return (T) deserialize(serialize(obj));\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/Serialization.java","additions":0,"deletions":283,"binary":false,"changes":283,"status":"deleted"}]}