{"files":[{"patch":"@@ -2934,1 +2934,1 @@\n-    if (!sub_t->isa_klassptr()) {\n+    if (!sub_t->isa_klassptr() && !sub_t->isa_inlinetype()) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2394,1 +2394,1 @@\n-        return TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0));\n+        return TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0), false, tary->is_not_flat(), tary->is_not_null_free());\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,1 +222,0 @@\n-      always_see_exact_class = true;\n@@ -224,12 +223,11 @@\n-      Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));\n-      Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));\n-      Node* ctrl= control();\n-      { BuildCutout unless(this, bol, PROB_MAX);\n-        uncommon_trap(reason,\n-                      Deoptimization::Action_maybe_recompile,\n-                      tak->klass());\n-      }\n-      if (stopped()) {          \/\/ MUST uncommon-trap?\n-        set_control(ctrl);      \/\/ Then Don't Do It, just fall into the normal checking\n-      } else {                  \/\/ Cast array klass to exactness:\n-        \/\/ Use the exact constant value we know it is.\n+      Node* cmp = _gvn.transform(new CmpPNode(array_klass, con));\n+      Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+      \/\/ Only do it if the check does not always pass\/fail\n+      if (!bol->is_Con()) {\n+        always_see_exact_class = true;\n+        { BuildCutout unless(this, bol, PROB_MAX);\n+          uncommon_trap(reason,\n+                        Deoptimization::Action_maybe_recompile,\n+                        tak->klass());\n+        }\n+        \/\/ Cast array klass to exactness\n@@ -245,1 +243,2 @@\n-        array_klass = con;      \/\/ Use cast value moving forward\n+        \/\/ Use cast value moving forward\n+        array_klass = con;\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -980,0 +980,8 @@\n+        } else if ((r0->is_not_flat() && klass1->is_flat_array_klass()) ||\n+                   (r1->is_not_flat() && klass0->is_flat_array_klass())) {\n+          \/\/ One type is a non-flattened array and the other type is a flattened array. Must be unrelated.\n+          unrelated_classes = true;\n+        } else if ((r0->is_not_null_free() && klass1->is_obj_array_klass() && klass1->as_obj_array_klass()->element_klass()->is_inlinetype()) ||\n+                   (r1->is_not_null_free() && klass0->is_obj_array_klass() && klass0->as_obj_array_klass()->element_klass()->is_inlinetype())) {\n+          \/\/ One type is a non-null-free array and the other type is a null-free array. Must be unrelated.\n+          unrelated_classes = true;\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5379,2 +5379,3 @@\n-TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array)\n-  : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flatten_array(flatten_array) {\n+TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array, bool not_flat, bool not_null_free)\n+  : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant),\n+    _flatten_array(flatten_array), _not_flat(not_flat), _not_null_free(not_null_free) {\n@@ -5387,1 +5388,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array, bool not_flat, bool not_null_free) {\n@@ -5391,1 +5392,1 @@\n-  return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flatten_array))->hashcons();\n+  return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flatten_array, not_flat, not_null_free))->hashcons();\n@@ -5398,1 +5399,2 @@\n-  return klass() == p->klass() && TypePtr::eq(p) && flatten_array() == p->flatten_array();\n+  return klass() == p->klass() && TypePtr::eq(p) && flatten_array() == p->flatten_array() &&\n+      is_not_flat() == p->is_not_flat() && is_not_null_free() == p->is_not_null_free();\n@@ -5404,1 +5406,2 @@\n-  return java_add(java_add(klass() != NULL ? klass()->hash() : (jint)0, (jint)TypePtr::hash()), (jint)flatten_array());\n+  return java_add(java_add(java_add(java_add(klass() != NULL ? klass()->hash() : (jint)0, (jint)TypePtr::hash()),\n+      (jint)flatten_array()), (jint)is_not_flat()), (jint)is_not_null_free());\n@@ -5538,1 +5541,1 @@\n-  return make(_ptr, klass(), xadd_offset(offset), flatten_array());\n+  return make(_ptr, klass(), xadd_offset(offset), flatten_array(), is_not_flat(), is_not_null_free());\n@@ -5545,1 +5548,1 @@\n-  return make(ptr, _klass, _offset, _flatten_array);\n+  return make(ptr, _klass, _offset, _flatten_array, _not_flat, _not_null_free);\n@@ -5552,1 +5555,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flatten_array);\n+  return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flatten_array, _not_flat, _not_null_free);\n@@ -5563,1 +5566,0 @@\n-  \/\/return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);\n@@ -5569,0 +5571,4 @@\n+  } else if (is_not_null_free()) {\n+    toop = toop->is_aryptr()->cast_to_not_null_free();\n+  } else if (is_not_flat()) {\n+    toop = toop->is_aryptr()->cast_to_not_flat();\n@@ -5612,1 +5618,1 @@\n-      return make(ptr, klass(), offset, flatten_array());\n+      return make(ptr, klass(), offset, flatten_array(), is_not_flat(), is_not_null_free());\n@@ -5660,2 +5666,2 @@\n-    if (ptr != Constant && tkls->klass()->equals(klass()) && flatten_array() == tkls->flatten_array()) {\n-      return make(ptr, klass(), off, flatten_array());\n+    if (ptr != Constant && tkls->klass()->equals(klass()) && flatten_array() == tkls->flatten_array() && is_not_flat() == tkls->is_not_flat() && is_not_null_free() && tkls->is_not_null_free()) {\n+      return make(ptr, klass(), off, flatten_array(), is_not_flat(), is_not_null_free());\n@@ -5669,3 +5675,3 @@\n-    bool tkls_flatten_array = tkls->flatten_array();\n-    bool this_flatten_array  = this->flatten_array();\n-    bool flatten_array = below_centerline(ptr) ? (this_flatten_array && tkls_flatten_array) : (this_flatten_array || tkls_flatten_array);\n+    bool flatten_array = below_centerline(ptr) ? (this->flatten_array() && tkls->flatten_array()) : (this->flatten_array() || tkls->flatten_array());\n+    bool is_not_flat = this->is_not_flat() && tkls->is_not_flat();\n+    bool is_not_null_free = this->is_not_null_free() && tkls->is_not_null_free();\n@@ -5699,1 +5705,1 @@\n-      return make(ptr, this_klass, off, flatten_array);\n+      return make(ptr, this_klass, off, flatten_array, is_not_flat, is_not_null_free);\n@@ -5708,1 +5714,1 @@\n-    return   make(ptr, k, off);\n+    return make(ptr, k, off, false, is_not_flat, is_not_null_free);\n@@ -5718,1 +5724,1 @@\n-  return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flatten_array());\n+  return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flatten_array(), !is_not_flat(), !is_not_null_free());\n@@ -5766,0 +5772,5 @@\n+  if (Verbose) {\n+    if (_flatten_array) st->print(\":flatten array\");\n+    if (_not_flat) st->print(\":not flat\");\n+    if (_not_null_free) st->print(\":not null free\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1020,0 +1020,2 @@\n+  virtual bool is_not_flat() const { return false; }\n+  virtual bool is_not_null_free() const { return false; }\n@@ -1452,1 +1454,1 @@\n-  TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array);\n+  TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array, bool not_flat, bool not_null_free);\n@@ -1466,1 +1468,3 @@\n-  bool _flatten_array; \/\/ Type is flat in arrays\n+  const bool _flatten_array; \/\/ Type is flat in arrays\n+  const bool _not_flat;      \/\/ Array is never flattened\n+  const bool _not_null_free; \/\/ Array is never null-free\n@@ -1474,0 +1478,2 @@\n+  virtual bool is_not_flat() const { return _not_flat; }\n+  virtual bool is_not_null_free() const { return _not_null_free; }\n@@ -1478,3 +1484,6 @@\n-  static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0)); }\n-  \/\/ ptr to klass 'k' with offset\n-  static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset); }\n+  static const TypeKlassPtr* make(ciKlass* k) {\n+    bool not_null_free = k->is_array_klass() && ( k->as_array_klass()->element_klass() == NULL ||\n+                                                 !k->as_array_klass()->element_klass()->can_be_inline_klass(true));\n+    bool not_flat = k->is_array_klass() && !k->is_flat_array_klass();\n+    return make( TypePtr::Constant, k, Offset(0), false, not_flat, not_null_free);\n+  }\n@@ -1482,1 +1491,1 @@\n-  static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array = false);\n+  static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array = false, bool not_flat = false, bool not_null_free = false);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"}]}