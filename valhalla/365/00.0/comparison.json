{"files":[{"patch":"@@ -543,4 +543,0 @@\n-          --with-toolchain-path=${HOME}\/sysroot-${{ matrix.debian-arch }}\/\n-          --with-freetype-lib=${HOME}\/sysroot-${{ matrix.debian-arch }}\/usr\/lib\/${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}\/\n-          --with-freetype-include=${HOME}\/sysroot-${{ matrix.debian-arch }}\/usr\/include\/freetype2\/\n-          --x-libraries=${HOME}\/sysroot-${{ matrix.debian-arch }}\/usr\/lib\/${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}\/\n","filename":".github\/workflows\/submit.yml","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-JAVADOC_DISABLED_DOCLINT := accessibility html missing syntax reference\n+JAVADOC_DISABLED_DOCLINT := missing\n@@ -265,0 +265,1 @@\n+#   OTHER_VERSIONS - URL for other page listing versions\n@@ -301,0 +302,6 @@\n+  ifneq ($$($1_OTHER_VERSIONS), )\n+    $1_LINKED_SHORT_NAME = <a href=\"$$($1_OTHER_VERSIONS)\">$$($1_SHORT_NAME)<\/a>\n+  else\n+    $1_LINKED_SHORT_NAME = $$($1_SHORT_NAME)\n+  endif\n+\n@@ -304,1 +311,1 @@\n-  $1_HEADER_TITLE := <div $$(HEADER_STYLE)><strong>$$($1_SHORT_NAME)<\/strong> \\\n+  $1_HEADER_TITLE := <div $$(HEADER_STYLE)><strong>$$($1_LINKED_SHORT_NAME)<\/strong> \\\n@@ -442,0 +449,1 @@\n+    OTHER_VERSIONS := $(OTHER_JDK_VERSIONS_URL), \\\n","filename":"make\/Docs.gmk","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1117,1 +1117,1 @@\n-            revision: \"1.21+1.0\"\n+            revision: \"1.28+1.0\"\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+# sun.security.util is required to compile Cache benchmark\n@@ -96,0 +97,1 @@\n+    JAVAC_FLAGS := --add-exports java.base\/sun.security.util=ALL-UNNAMED -XDallowWithFieldOperator --enable-preview, \\\n@@ -97,1 +99,0 @@\n-    JAVAC_FLAGS := -XDallowWithFieldOperator --enable-preview, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -535,0 +535,27 @@\n+  \/\/ AdvSIMD shift by immediate.\n+  \/\/ These are \"user friendly\" variants which allow a shift count of 0.\n+#define WRAP(INSN)                                                                \\\n+  void INSN(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift) {  \\\n+    if (shift == 0) {                                                             \\\n+      SIMD_Arrangement arrange = (T & 1) == 0 ? T8B : T16B;                       \\\n+      Assembler::orr(Vd, arrange, Vn, Vn);                                        \\\n+    } else {                                                                      \\\n+      Assembler::INSN(Vd, T, Vn, shift);                                          \\\n+    }                                                                             \\\n+  }                                                                               \\\n+\n+  WRAP(shl) WRAP(sshr) WRAP(ushr)\n+#undef WRAP\n+\n+#define WRAP(INSN)                                                                \\\n+  void INSN(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift) {  \\\n+    if (shift == 0) {                                                             \\\n+      Assembler::addv(Vd, T, Vd, Vn);                                             \\\n+    } else {                                                                      \\\n+      Assembler::INSN(Vd, T, Vn, shift);                                          \\\n+    }                                                                             \\\n+  }                                                                               \\\n+\n+  WRAP(usra) WRAP(ssra)\n+#undef WRAP\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -244,9 +244,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return 16;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  __ mov(rscratch1, destination);\n-  __ br(rscratch1);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    __ incrementw(Address(r16));\n+    __ increment(Address(r16));\n@@ -145,1 +145,1 @@\n-VtableStub* VtableStubs::create_itable_stub(int itable_index, bool caller_is_c1) { \n+VtableStub* VtableStubs::create_itable_stub(int itable_index, bool caller_is_c1) {\n@@ -153,0 +153,1 @@\n+\n@@ -171,1 +172,1 @@\n-    __ incrementw(Address(r10));\n+    __ increment(Address(r10));\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -374,8 +374,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return 16;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  __ jump(RuntimeAddress(destination));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -427,8 +427,0 @@\n-size_t SharedRuntime::trampoline_size() {\n-  return 16;\n-}\n-\n-void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {\n-  __ jump(RuntimeAddress(destination));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    __ incrementl(ExternalAddress((address) SharedRuntime::nof_megamorphic_calls_addr()));\n+    __ incrementq(ExternalAddress((address) SharedRuntime::nof_megamorphic_calls_addr()));\n@@ -153,0 +153,1 @@\n+\n@@ -168,1 +169,1 @@\n-    __ incrementl(ExternalAddress((address) SharedRuntime::nof_megamorphic_calls_addr()));\n+    __ incrementq(ExternalAddress((address) SharedRuntime::nof_megamorphic_calls_addr()));\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -844,1 +844,1 @@\n-    if (sub->is_instance_klass()) {\n+    if (sub->is_instance_klass() && !sub->is_hidden() && !InstanceKlass::cast(sub)->is_unsafe_anonymous()) {\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1043,0 +1043,1 @@\n+  assert(k != NULL, \"no klass created\");\n@@ -1044,1 +1045,1 @@\n-  if ((cl_info.is_hidden() || is_unsafe_anon_class) && k != NULL) {\n+  if (cl_info.is_hidden() || is_unsafe_anon_class) {\n@@ -1088,1 +1089,2 @@\n-\n+\/\/ This function either returns an InstanceKlass or throws an exception.  It does\n+\/\/ not return NULL without a pending exception.\n@@ -1121,3 +1123,0 @@\n-    if (st->buffer() == NULL) {\n-      return NULL;\n-    }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3231,1 +3231,1 @@\n-        \"Method expects a return value\");\n+        \"Method does not expect a return value\");\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,0 +183,16 @@\n+\n+#ifdef ASSERT\n+void ParCompactionManager::verify_all_marking_stack_empty() {\n+  uint parallel_gc_threads = ParallelGCThreads;\n+  for (uint i = 0; i <= parallel_gc_threads; i++) {\n+    assert(_manager_array[i]->marking_stacks_empty(), \"Marking stack should be empty\");\n+  }\n+}\n+\n+void ParCompactionManager::verify_all_region_stack_empty() {\n+  uint parallel_gc_threads = ParallelGCThreads;\n+  for (uint i = 0; i <= parallel_gc_threads; i++) {\n+    assert(_manager_array[i]->region_stack()->is_empty(), \"Region stack should be empty\");\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#include \"gc\/shared\/weakProcessor.hpp\"\n+#include \"gc\/shared\/weakProcessor.inline.hpp\"\n@@ -784,1 +784,1 @@\n-HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) {\n+HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const {\n@@ -1788,2 +1788,1 @@\n-  ParCompactionManager* const vmthread_cm =\n-    ParCompactionManager::manager_array(ParallelScavengeHeap::heap()->workers().total_workers());\n+  ParCompactionManager* const vmthread_cm = ParCompactionManager::get_vmthread_cm();\n@@ -1792,2 +1791,0 @@\n-    ResourceMark rm;\n-\n@@ -1838,1 +1835,1 @@\n-    adjust_roots(vmthread_cm);\n+    adjust_roots();\n@@ -1843,0 +1840,2 @@\n+    ParCompactionManager::verify_all_region_stack_empty();\n+\n@@ -1939,9 +1938,0 @@\n-#ifdef ASSERT\n-  for (size_t i = 0; i < ParallelGCThreads + 1; ++i) {\n-    ParCompactionManager* const cm =\n-      ParCompactionManager::manager_array(int(i));\n-    assert(cm->marking_stack()->is_empty(),       \"should be empty\");\n-    assert(cm->region_stack()->is_empty(), \"Region stack \" SIZE_FORMAT \" is not empty\", i);\n-  }\n-#endif \/\/ ASSERT\n-\n@@ -2187,1 +2177,1 @@\n-  assert(cm->marking_stacks_empty(), \"Marking should have completed\");\n+  ParCompactionManager::verify_all_marking_stack_empty();\n@@ -2213,3 +2203,12 @@\n-void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {\n-  \/\/ Adjust the pointers to reflect the new locations\n-  GCTraceTime(Info, gc, phases) tm(\"Adjust Roots\", &_gc_timer);\n+#ifdef ASSERT\n+void PCAdjustPointerClosure::verify_cm(ParCompactionManager* cm) {\n+  assert(cm != NULL, \"associate ParCompactionManage should not be NULL\");\n+  auto vmthread_cm = ParCompactionManager::get_vmthread_cm();\n+  if (Thread::current()->is_VM_thread()) {\n+    assert(cm == vmthread_cm, \"VM threads should use ParCompactionManager from get_vmthread_cm()\");\n+  } else {\n+    assert(Thread::current()->is_GC_task_thread(), \"Must be a GC thread\");\n+    assert(cm != vmthread_cm, \"GC threads should use ParCompactionManager from gc_thread_compaction_manager()\");\n+  }\n+}\n+#endif\n@@ -2217,2 +2216,5 @@\n-  \/\/ Need new claim bits when tracing through and adjusting pointers.\n-  ClassLoaderDataGraph::clear_claimed_marks();\n+class PSAdjustTask final : public AbstractGangTask {\n+  SubTasksDone                               _sub_tasks;\n+  WeakProcessor::Task                        _weak_proc_task;\n+  OopStorageSetStrongParState<false, false>  _oop_storage_iter;\n+  uint                                       _nworkers;\n@@ -2220,1 +2222,5 @@\n-  PCAdjustPointerClosure oop_closure(cm);\n+  enum PSAdjustSubTask {\n+    PSAdjustSubTask_code_cache,\n+    PSAdjustSubTask_aot,\n+    PSAdjustSubTask_old_ref_process,\n+    PSAdjustSubTask_young_ref_process,\n@@ -2222,5 +2228,2 @@\n-  \/\/ General strong roots.\n-  Threads::oops_do(&oop_closure, NULL);\n-  OopStorageSet::strong_oops_do(&oop_closure);\n-  CLDToOopClosure cld_closure(&oop_closure, ClassLoaderData::_claim_strong);\n-  ClassLoaderDataGraph::cld_do(&cld_closure);\n+    PSAdjustSubTask_num_elements\n+  };\n@@ -2228,3 +2231,12 @@\n-  \/\/ Now adjust pointers in remaining weak roots.  (All of which should\n-  \/\/ have been cleared if they pointed to non-surviving objects.)\n-  WeakProcessor::oops_do(&oop_closure);\n+public:\n+  PSAdjustTask(uint nworkers) :\n+    AbstractGangTask(\"PSAdjust task\"),\n+    _sub_tasks(PSAdjustSubTask_num_elements),\n+    _weak_proc_task(nworkers),\n+    _nworkers(nworkers) {\n+    \/\/ Need new claim bits when tracing through and adjusting pointers.\n+    ClassLoaderDataGraph::clear_claimed_marks();\n+    if (nworkers > 1) {\n+      Threads::change_thread_claim_token();\n+    }\n+  }\n@@ -2232,3 +2244,3 @@\n-  CodeBlobToOopClosure adjust_from_blobs(&oop_closure, CodeBlobToOopClosure::FixRelocations);\n-  CodeCache::blobs_do(&adjust_from_blobs);\n-  AOT_ONLY(AOTLoader::oops_do(&oop_closure);)\n+  ~PSAdjustTask() {\n+    Threads::assert_all_threads_claimed();\n+  }\n@@ -2236,6 +2248,43 @@\n-  ref_processor()->weak_oops_do(&oop_closure);\n-  \/\/ Roots were visited so references into the young gen in roots\n-  \/\/ may have been scanned.  Process them also.\n-  \/\/ Should the reference processor have a span that excludes\n-  \/\/ young gen objects?\n-  PSScavenge::reference_processor()->weak_oops_do(&oop_closure);\n+  void work(uint worker_id) {\n+    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    PCAdjustPointerClosure adjust(cm);\n+    {\n+      ResourceMark rm;\n+      Threads::possibly_parallel_oops_do(_nworkers > 1, &adjust, nullptr);\n+    }\n+    _oop_storage_iter.oops_do(&adjust);\n+    {\n+      CLDToOopClosure cld_closure(&adjust, ClassLoaderData::_claim_strong);\n+      ClassLoaderDataGraph::cld_do(&cld_closure);\n+    }\n+    {\n+      AlwaysTrueClosure always_alive;\n+      _weak_proc_task.work(worker_id, &always_alive, &adjust);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_code_cache)) {\n+      CodeBlobToOopClosure adjust_code(&adjust, CodeBlobToOopClosure::FixRelocations);\n+      CodeCache::blobs_do(&adjust_code);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_aot)) {\n+      AOT_ONLY(AOTLoader::oops_do(&adjust);)\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_old_ref_process)) {\n+      PSParallelCompact::ref_processor()->weak_oops_do(&adjust);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_young_ref_process)) {\n+      \/\/ Roots were visited so references into the young gen in roots\n+      \/\/ may have been scanned.  Process them also.\n+      \/\/ Should the reference processor have a span that excludes\n+      \/\/ young gen objects?\n+      PSScavenge::reference_processor()->weak_oops_do(&adjust);\n+    }\n+    _sub_tasks.all_tasks_claimed();\n+  }\n+};\n+\n+void PSParallelCompact::adjust_roots() {\n+  \/\/ Adjust the pointers to reflect the new locations\n+  GCTraceTime(Info, gc, phases) tm(\"Adjust Roots\", &_gc_timer);\n+  uint nworkers = ParallelScavengeHeap::heap()->workers().active_workers();\n+  PSAdjustTask task(nworkers);\n+  ParallelScavengeHeap::heap()->workers().run_task(&task);\n@@ -2310,1 +2359,1 @@\n-        ParCompactionManager* cm = ParCompactionManager::manager_array(worker_id);\n+        ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n@@ -2509,1 +2558,0 @@\n-  return;\n@@ -2575,2 +2623,4 @@\n-    \/\/ Update the deferred objects, if any.  Any compaction manager can be used.\n-    ParCompactionManager* cm = ParCompactionManager::manager_array(0);\n+    \/\/ Update the deferred objects, if any. In principle, any compaction\n+    \/\/ manager can be used. However, since the current thread is VM thread, we\n+    \/\/ use the rightful one to keep the verification logic happy.\n+    ParCompactionManager* cm = ParCompactionManager::get_vmthread_cm();\n@@ -3137,1 +3187,1 @@\n-    ParCompactionManager *cm = ParCompactionManager::manager_array(i);\n+    ParCompactionManager *cm = ParCompactionManager::gc_thread_compaction_manager(i);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":95,"deletions":45,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-  \/\/ 3: apply keep-alive barrier if needed\n+  \/\/ 3: apply keep-alive barrier for java.lang.ref.Reference if needed\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-  static address    _cds_entry_table[number_of_method_entries]; \/\/ entry points for methods in the CDS archive\n@@ -139,5 +138,0 @@\n-  \/\/ used by class data sharing\n-  static address    entry_for_cds_method(const methodHandle& m) NOT_CDS_RETURN_(NULL);\n-  static address    entry_for_cds_method(AbstractInterpreter::MethodKind kind) NOT_CDS_RETURN_(NULL);\n-  static void       generate_entry_for_cds_method(MethodKind kind) NOT_CDS_RETURN;\n-\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,1 +185,0 @@\n-    Interpreter::generate_entry_for_cds_method(Interpreter::kind); \\\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,26 +52,0 @@\n-class AdapterHandlerEntry;\n-\n-class MethodTrampolineInfo {\n-  address _c2i_entry_trampoline;\n-  address _c2i_inline_ro_entry_trampoline;\n-  address _c2i_inline_entry_trampoline;\n-  AdapterHandlerEntry** _adapter_trampoline;\n-public:\n-  address c2i_entry_trampoline() { return _c2i_entry_trampoline; }\n-  address c2i_inline_ro_entry_trampoline() { return _c2i_inline_ro_entry_trampoline; }\n-  address c2i_inline_entry_trampoline() { return _c2i_inline_entry_trampoline; }\n-  AdapterHandlerEntry** adapter_trampoline() { return _adapter_trampoline; }\n-  void set_c2i_entry_trampoline(address addr) { _c2i_entry_trampoline = addr; }\n-  void set_c2i_inline_ro_entry_trampoline(address addr) { _c2i_inline_ro_entry_trampoline = addr; }\n-  void set_c2i_inline_entry_trampoline(address addr) { _c2i_inline_entry_trampoline = addr; }\n-  void set_adapter_trampoline(AdapterHandlerEntry** entry) { _adapter_trampoline = entry; }\n-};\n-\n-class AdapterToTrampoline : public ResourceHashtable<\n-  AdapterHandlerEntry*, MethodTrampolineInfo,\n-  primitive_hash<AdapterHandlerEntry*>,\n-  primitive_equals<AdapterHandlerEntry*>,\n-  941, \/\/ prime number\n-  ResourceObj::C_HEAP> {};\n-\n-static AdapterToTrampoline* _adapter_to_trampoline = NULL;\n@@ -183,1 +157,0 @@\n-  _mc_region(\"mc\", MAX_SHARED_DELTA),\n@@ -195,2 +168,1 @@\n-  _estimated_hashtable_bytes(0),\n-  _estimated_trampoline_bytes(0)\n+  _estimated_hashtable_bytes(0)\n@@ -352,2 +324,0 @@\n-  _estimated_trampoline_bytes = collect_method_trampolines();\n-\n@@ -358,1 +328,0 @@\n-  total += _estimated_trampoline_bytes;\n@@ -366,1 +335,0 @@\n-  log_info(cds)(\"_estimated_trampoline_bytes = \" SIZE_FORMAT, _estimated_trampoline_bytes);\n@@ -389,1 +357,1 @@\n-  _current_dump_space = &_mc_region;\n+  _current_dump_space = &_rw_region;\n@@ -430,0 +398,6 @@\n+  if (DumpSharedSpaces) {\n+    \/\/ We don't want any valid object to be at the very bottom of the archive.\n+    \/\/ See ArchivePtrMarker::mark_pointer().\n+    rw_region()->allocate(16);\n+  }\n+\n@@ -603,1 +577,1 @@\n-void ArchiveBuilder::dump_rw_region() {\n+void ArchiveBuilder::dump_rw_metadata() {\n@@ -606,1 +580,0 @@\n-  start_dump_space(&_rw_region);\n@@ -619,1 +592,1 @@\n-void ArchiveBuilder::dump_ro_region() {\n+void ArchiveBuilder::dump_ro_metadata() {\n@@ -1065,1 +1038,0 @@\n-    DumpRegion* mc_region = &builder->_mc_region;\n@@ -1069,5 +1041,0 @@\n-    address mc = address(mc_region->base());\n-    address mc_end = address(mc_region->end());\n-    write_dump_region(\"mc region\", mc_region);\n-    write_data(mc, mc_end, mc + buffer_to_runtime_delta());\n-\n@@ -1096,1 +1063,1 @@\n-  _alloc_stats.print_stats(int(_ro_region.used()), int(_rw_region.used()), int(_mc_region.used()));\n+  _alloc_stats.print_stats(int(_ro_region.used()), int(_rw_region.used()));\n@@ -1104,106 +1071,0 @@\n-void ArchiveBuilder::init_mc_region() {\n-  if (DumpSharedSpaces) { \/\/ these are needed only for static archive\n-    \/\/ We don't want any valid object to be at the very bottom of the archive.\n-    \/\/ See ArchivePtrMarker::mark_pointer().\n-    mc_region()->allocate(16);\n-\n-    size_t trampoline_size = SharedRuntime::trampoline_size();\n-    size_t buf_size = (size_t)AbstractInterpreter::number_of_method_entries * trampoline_size;\n-    MetaspaceShared::set_i2i_entry_code_buffers((address)mc_region()->allocate(buf_size));\n-  }\n-\n-  allocate_method_trampolines();\n-}\n-\n-void ArchiveBuilder::allocate_method_trampolines_for(InstanceKlass* ik) {\n-  if (ik->methods() != NULL) {\n-    for (int j = 0; j < ik->methods()->length(); j++) {\n-      \/\/ Walk the methods in a deterministic order so that the trampolines are\n-      \/\/ created in a deterministic order.\n-      Method* m = ik->methods()->at(j);\n-      AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n-      MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n-      if (info->c2i_entry_trampoline() == NULL) {\n-        info->set_c2i_entry_trampoline(\n-          (address)mc_region()->allocate(SharedRuntime::trampoline_size()));\n-        info->set_c2i_inline_ro_entry_trampoline(\n-         (address)mc_region()->allocate(SharedRuntime::trampoline_size()));\n-        info->set_c2i_inline_entry_trampoline(\n-         (address)mc_region()->allocate(SharedRuntime::trampoline_size()));\n-        info->set_adapter_trampoline(\n-          (AdapterHandlerEntry**)mc_region()->allocate(sizeof(AdapterHandlerEntry*)));\n-      }\n-    }\n-  }\n-}\n-\n-void ArchiveBuilder::allocate_method_trampolines() {\n-  for (int i = 0; i < _klasses->length(); i++) {\n-    Klass* k = _klasses->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      allocate_method_trampolines_for(ik);\n-    }\n-  }\n-}\n-\n-\/\/ Allocate MethodTrampolineInfo for all Methods that will be archived. Also\n-\/\/ return the total number of bytes needed by the method trampolines in the MC\n-\/\/ region.\n-size_t ArchiveBuilder::collect_method_trampolines() {\n-  size_t total = 0;\n-  size_t each_method_bytes =\n-    align_up(SharedRuntime::trampoline_size(), BytesPerWord) * 3 +\n-    align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);\n-\n-  if (_adapter_to_trampoline == NULL) {\n-    _adapter_to_trampoline = new (ResourceObj::C_HEAP, mtClass)AdapterToTrampoline();\n-  }\n-  int count = 0;\n-  for (int i = 0; i < _klasses->length(); i++) {\n-    Klass* k = _klasses->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      if (ik->methods() != NULL) {\n-        for (int j = 0; j < ik->methods()->length(); j++) {\n-          Method* m = ik->methods()->at(j);\n-          AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n-          bool is_created = false;\n-          MethodTrampolineInfo* info = _adapter_to_trampoline->put_if_absent(ent, &is_created);\n-          if (is_created) {\n-            count++;\n-          }\n-        }\n-      }\n-    }\n-  }\n-  if (count == 0) {\n-    \/\/ We have nothing to archive, but let's avoid having an empty region.\n-    total = SharedRuntime::trampoline_size();\n-  } else {\n-    total = count * each_method_bytes;\n-  }\n-  return align_up(total, SharedSpaceObjectAlignment);\n-}\n-\n-void ArchiveBuilder::update_method_trampolines() {\n-  for (int i = 0; i < klasses()->length(); i++) {\n-    Klass* k = klasses()->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      Array<Method*>* methods = ik->methods();\n-      for (int j = 0; j < methods->length(); j++) {\n-        Method* m = methods->at(j);\n-        AdapterHandlerEntry* ent = m->adapter();\n-        MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n-        \/\/ m is the \"copy\" of the original Method, but its adapter() field is still valid because\n-        \/\/ we haven't called make_klasses_shareable() yet.\n-        m->set_from_compiled_entry(info->c2i_entry_trampoline());\n-        m->set_from_compiled_inline_ro_entry(info->c2i_inline_ro_entry_trampoline());\n-        m->set_from_compiled_inline_entry(info->c2i_inline_entry_trampoline());\n-        m->set_adapter_trampoline(info->adapter_trampoline());\n-      }\n-    }\n-  }\n-}\n-\n@@ -1219,3 +1080,0 @@\n-  \/\/ mc contains the trampoline code for method entries, which are patched at run time,\n-  \/\/ so it needs to be read\/write.\n-  write_region(mapinfo, MetaspaceShared::mc, &_mc_region, \/*read_only=*\/false,\/*allow_exec=*\/true);\n@@ -1271,1 +1129,0 @@\n-                                _mc_region.reserved()  +\n@@ -1276,1 +1133,0 @@\n-                             _mc_region.used()  +\n@@ -1282,1 +1138,0 @@\n-  _mc_region.print(total_reserved);\n@@ -1318,1 +1173,0 @@\n-  _mc_region.print_out_of_space_msg(name, needed_bytes);\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":11,"deletions":157,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -54,4 +54,2 @@\n-\/\/ [3] Copy contents of the 3 \"core\" regions (mc\/rw\/ro) into the output buffer.\n-\/\/       - mc region:\n-\/\/         allocate_method_trampolines();\n-\/\/         allocate the cpp vtables (static dump only)\n+\/\/ [3] Copy contents of the 2 \"core\" regions (rw\/ro) into the output buffer.\n+\/\/       - allocate the cpp vtables in rw (static dump only)\n@@ -64,1 +62,1 @@\n-\/\/ [5] Relocate all the pointers in mc\/rw\/ro, so that the archive can be mapped to\n+\/\/ [5] Relocate all the pointers in rw\/ro, so that the archive can be mapped to\n@@ -69,1 +67,1 @@\n-  address _buffer_bottom;                      \/\/ for writing the contents of mc\/rw\/ro regions\n+  address _buffer_bottom;                      \/\/ for writing the contents of rw\/ro regions\n@@ -203,1 +201,0 @@\n-  DumpRegion _mc_region;\n@@ -271,2 +268,1 @@\n-  size_t _estimated_trampoline_bytes;    \/\/ method entry trampolines\n-  static const int _total_dump_regions = 3;\n+  static const int _total_dump_regions = 2;\n@@ -358,1 +354,0 @@\n-  DumpRegion* mc_region() { return &_mc_region; }\n@@ -362,3 +357,0 @@\n-  static char* mc_region_alloc(size_t num_bytes) {\n-    return current()->mc_region()->allocate(num_bytes);\n-  }\n@@ -394,3 +386,2 @@\n-  void init_mc_region();\n-  void dump_rw_region();\n-  void dump_ro_region();\n+  void dump_rw_metadata();\n+  void dump_ro_metadata();\n@@ -452,6 +443,0 @@\n-\n-  \/\/ Method trampolines related functions\n-  size_t collect_method_trampolines();\n-  void allocate_method_trampolines();\n-  void allocate_method_trampolines_for(InstanceKlass* ik);\n-  void update_method_trampolines();\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-      (CppVtableInfo*)ArchiveBuilder::current()->mc_region()->allocate(CppVtableInfo::byte_size(n));\n+      (CppVtableInfo*)ArchiveBuilder::current()->rw_region()->allocate(CppVtableInfo::byte_size(n));\n@@ -219,1 +219,1 @@\n-char* CppVtables::dumptime_init() {\n+char* CppVtables::dumptime_init(ArchiveBuilder* builder) {\n@@ -222,1 +222,1 @@\n-  _index = (CppVtableInfo**)ArchiveBuilder::current()->mc_region()->allocate(vtptrs_bytes);\n+  _index = (CppVtableInfo**)builder->rw_region()->allocate(vtptrs_bytes);\n@@ -226,0 +226,3 @@\n+  size_t cpp_tables_size = builder->rw_region()->top() - builder->rw_region()->base();\n+  builder->alloc_stats()->record_cpp_vtables((int)cpp_tables_size);\n+\n","filename":"src\/hotspot\/share\/memory\/cppVtables.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-address MetaspaceShared::_i2i_entry_code_buffers = NULL;\n@@ -94,1 +93,0 @@\n-\/\/     mc  - misc code (the method entry trampolines, c++ vtables)\n@@ -105,1 +103,1 @@\n-\/\/ The mc, rw, and ro regions are linearly allocated, in the order of mc->rw->ro.\n+\/\/ The rw, and ro regions are linearly allocated, in the order of rw->ro.\n@@ -108,1 +106,1 @@\n-\/\/ These 3 regions are populated in the following steps:\n+\/\/ These 2 regions are populated in the following steps:\n@@ -111,2 +109,2 @@\n-\/\/ [1] We enter a safepoint and allocate a buffer for the mc\/rw\/ro regions.\n-\/\/ [2] C++ vtables and method trampolines are copied into the mc region.\n+\/\/ [1] We enter a safepoint and allocate a buffer for the rw\/ro regions.\n+\/\/ [2] C++ vtables are copied into the rw region.\n@@ -119,1 +117,1 @@\n-\/\/ Their layout is independent of the mc\/rw\/ro regions.\n+\/\/ Their layout is independent of the rw\/ro regions.\n@@ -327,12 +325,0 @@\n-void MetaspaceShared::set_i2i_entry_code_buffers(address b) {\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(_i2i_entry_code_buffers == NULL, \"initialize only once\");\n-  _i2i_entry_code_buffers = b;\n-}\n-\n-address MetaspaceShared::i2i_entry_code_buffers() {\n-  assert(DumpSharedSpaces || UseSharedSpaces, \"must be\");\n-  assert(_i2i_entry_code_buffers != NULL, \"must already been initialized\");\n-  return _i2i_entry_code_buffers;\n-}\n-\n@@ -477,2 +463,1 @@\n-  builder.init_mc_region();\n-  char* cloned_vtables = CppVtables::dumptime_init();\n+  char* cloned_vtables = CppVtables::dumptime_init(&builder);\n@@ -480,2 +465,2 @@\n-  builder.dump_rw_region();\n-  builder.dump_ro_region();\n+  builder.dump_rw_metadata();\n+  builder.dump_ro_metadata();\n@@ -494,3 +479,0 @@\n-  log_info(cds)(\"Update method trampolines\");\n-  builder.update_method_trampolines();\n-\n@@ -505,1 +487,1 @@\n-  \/\/ We don't want to write these addresses into the archive. Same for i2i buffer.\n+  \/\/ We don't want to write these addresses into the archive.\n@@ -517,1 +499,0 @@\n-  mapinfo->set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers());\n@@ -861,7 +842,0 @@\n-bool MetaspaceShared::is_in_trampoline_frame(address addr) {\n-  if (UseSharedSpaces && is_in_shared_region(addr, MetaspaceShared::mc)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -1320,4 +1294,2 @@\n-static int archive_regions[]  = {MetaspaceShared::mc,\n-                                 MetaspaceShared::rw,\n-                                 MetaspaceShared::ro};\n-static int archive_regions_count  = 3;\n+static int archive_regions[]     = { MetaspaceShared::rw, MetaspaceShared::ro };\n+static int archive_regions_count = 2;\n@@ -1370,1 +1342,0 @@\n-  _i2i_entry_code_buffers = static_mapinfo->i2i_entry_code_buffers();\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":11,"deletions":40,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -3021,2 +3021,2 @@\n-  if (is_shared() && _package_entry == pkg_entry) {\n-    if (MetaspaceShared::use_full_module_graph()) {\n+  if (is_shared() && _package_entry != NULL) {\n+    if (MetaspaceShared::use_full_module_graph() && _package_entry == pkg_entry) {\n@@ -3024,0 +3024,1 @@\n+      assert(MetaspaceShared::is_in_shared_metaspace(_package_entry), \"must be\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -363,5 +363,0 @@\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_i2i_entry);\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_from_compiled_entry);\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_from_compiled_inline_ro_entry);\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_from_compiled_inline_entry);\n-  it->push_method_entry(&this_ptr, (intptr_t*)&_from_interpreted_entry);\n@@ -508,0 +503,1 @@\n+  \/\/---<  compose+print method return type, klass, name, and signature  >---\n@@ -522,3 +518,13 @@\n-  tty->print_cr (\"  interpreter_invocation_count: %8d \", interpreter_invocation_count());\n-  tty->print_cr (\"  invocation_counter:           %8d \", invocation_count());\n-  tty->print_cr (\"  backedge_counter:             %8d \", backedge_count());\n+  \/\/ Counting based on signed int counters tends to overflow with\n+  \/\/ longer-running workloads on fast machines. The counters under\n+  \/\/ consideration here, however, are limited in range by counting\n+  \/\/ logic. See InvocationCounter:count_limit for example.\n+  \/\/ No \"overflow precautions\" need to be implemented here.\n+  tty->print_cr (\"  interpreter_invocation_count: \" INT32_FORMAT_W(11), interpreter_invocation_count());\n+  tty->print_cr (\"  invocation_counter:           \" INT32_FORMAT_W(11), invocation_count());\n+  tty->print_cr (\"  backedge_counter:             \" INT32_FORMAT_W(11), backedge_count());\n+\n+  if (method_data() != NULL) {\n+    tty->print_cr (\"  decompile_count:              \" UINT32_FORMAT_W(11), method_data()->decompile_count());\n+  }\n+\n@@ -527,1 +533,1 @@\n-    tty->print_cr (\"  compiled_invocation_count: %8d \", compiled_invocation_count());\n+    tty->print_cr (\"  compiled_invocation_count:    \" INT64_FORMAT_W(11), compiled_invocation_count());\n@@ -1144,14 +1150,7 @@\n-  _code = NULL;\n-\n-  \/\/ Set the values to what they should be at run time. Note that\n-  \/\/ this Method can no longer be executed during dump time.\n-  _i2i_entry = Interpreter::entry_for_cds_method(methodHandle(Thread::current(), this));\n-  _from_interpreted_entry = _i2i_entry;\n-\n-  assert(_from_compiled_entry != NULL, \"sanity\");\n-  assert(*((int*)_from_compiled_entry) == 0,\n-         \"must be NULL during dump time, to be initialized at run time\");\n-  assert(*((int*)_from_compiled_inline_ro_entry) == 0,\n-         \"must be NULL during dump time, to be initialized at run time\");\n-  assert(*((int*)_from_compiled_inline_entry) == 0,\n-         \"must be NULL during dump time, to be initialized at run time\");\n+  _code = NULL;\n+  _adapter = NULL;\n+  _i2i_entry = NULL;\n+  _from_compiled_entry = NULL;\n+  _from_compiled_inline_entry = NULL;\n+  _from_compiled_inline_ro_entry = NULL;\n+  _from_interpreted_entry = NULL;\n@@ -1171,71 +1170,0 @@\n-\/****************************************************************************\n-\/\/ The following illustrates how the entries work for CDS shared Methods:\n-\/\/\n-\/\/ Our goal is to delay writing into a shared Method until it's compiled.\n-\/\/ Hence, we want to determine the initial values for _i2i_entry,\n-\/\/ _from_interpreted_entry and _from_compiled_entry during CDS dump time.\n-\/\/\n-\/\/ In this example, both Methods A and B have the _i2i_entry of \"zero_locals\".\n-\/\/ They also have similar signatures so that they will share the same\n-\/\/ AdapterHandlerEntry.\n-\/\/\n-\/\/ _adapter_trampoline points to a fixed location in the RW section of\n-\/\/ the CDS archive. This location initially contains a NULL pointer. When the\n-\/\/ first of method A or B is linked, an AdapterHandlerEntry is allocated\n-\/\/ dynamically, and its c2i\/i2c entries are generated.\n-\/\/\n-\/\/ _i2i_entry and _from_interpreted_entry initially points to the same\n-\/\/ (fixed) location in the CODE section of the CDS archive. This contains\n-\/\/ an unconditional branch to the actual entry for \"zero_locals\", which is\n-\/\/ generated at run time and may be on an arbitrary address. Thus, the\n-\/\/ unconditional branch is also generated at run time to jump to the correct\n-\/\/ address.\n-\/\/\n-\/\/ Similarly, _from_compiled_entry points to a fixed address in the CODE\n-\/\/ section. This address has enough space for an unconditional branch\n-\/\/ instruction, and is initially zero-filled. After the AdapterHandlerEntry is\n-\/\/ initialized, and the address for the actual c2i_entry is known, we emit a\n-\/\/ branch instruction here to branch to the actual c2i_entry.\n-\/\/\n-\/\/ The effect of the extra branch on the i2i and c2i entries is negligible.\n-\/\/\n-\/\/ The reason for putting _adapter_trampoline in RO is many shared Methods\n-\/\/ share the same AdapterHandlerEntry, so we can save space in the RW section\n-\/\/ by having the extra indirection.\n-\n-\n-[Method A: RW]\n-  _constMethod ----> [ConstMethod: RO]\n-                       _adapter_trampoline -----------+\n-                                                      |\n-  _i2i_entry              (same value as method B)    |\n-  _from_interpreted_entry (same value as method B)    |\n-  _from_compiled_entry    (same value as method B)    |\n-                                                      |\n-                                                      |\n-[Method B: RW]                               +--------+\n-  _constMethod ----> [ConstMethod: RO]       |\n-                       _adapter_trampoline --+--->(AdapterHandlerEntry* ptr: RW)-+\n-                                                                                 |\n-                                                 +-------------------------------+\n-                                                 |\n-                                                 +----> [AdapterHandlerEntry] (allocated at run time)\n-                                                              _fingerprint\n-                                                              _c2i_entry ---------------------------------+->[c2i entry..]\n- _i2i_entry  -------------+                                   _i2c_entry ---------------+-> [i2c entry..] |\n- _from_interpreted_entry  |                                   _c2i_unverified_entry     |                 |\n-         |                |                                   _c2i_no_clinit_check_entry|                 |\n-         |                |  (_cds_entry_table: CODE)                                   |                 |\n-         |                +->[0]: jmp _entry_table[0] --> (i2i_entry_for \"zero_locals\") |                 |\n-         |                |                               (allocated at run time)       |                 |\n-         |                |  ...                           [asm code ...]               |                 |\n-         +-[not compiled]-+  [n]: jmp _entry_table[n]                                   |                 |\n-         |                                                                              |                 |\n-         |                                                                              |                 |\n-         +-[compiled]-------------------------------------------------------------------+                 |\n-                                                                                                          |\n- _from_compiled_entry------------>  (_c2i_entry_trampoline: CODE)                                         |\n-                                    [jmp c2i_entry] ------------------------------------------------------+\n-\n-***\/\n-\n@@ -1247,8 +1175,1 @@\n-  if (is_shared()) {\n-    \/\/ Can't assert that the adapters are sane, because methods get linked before\n-    \/\/ the interpreter is generated, and hence before its adapters are generated.\n-    \/\/ If you messed them up you will notice soon enough though, don't you worry.\n-    if (adapter() != NULL) {\n-      return;\n-    }\n-  } else if (_i2i_entry != NULL) {\n+  if (_i2i_entry != NULL) {\n@@ -1262,7 +1183,5 @@\n-  if (!is_shared()) {\n-    assert(adapter() == NULL, \"init'd to NULL\");\n-    address entry = Interpreter::entry_for_method(h_method);\n-    assert(entry != NULL, \"interpreter entry must be non-null\");\n-    \/\/ Sets both _i2i_entry and _from_interpreted_entry\n-    set_interpreter_entry(entry);\n-  }\n+  assert(adapter() == NULL, \"init'd to NULL\");\n+  address entry = Interpreter::entry_for_method(h_method);\n+  assert(entry != NULL, \"interpreter entry must be non-null\");\n+  \/\/ Sets both _i2i_entry and _from_interpreted_entry\n+  set_interpreter_entry(entry);\n@@ -1288,1 +1207,0 @@\n-\n@@ -1307,11 +1225,4 @@\n-  if (mh->is_shared()) {\n-    assert(mh->adapter() == adapter, \"must be\");\n-    assert(mh->_from_compiled_entry != NULL, \"must be\");\n-    assert(mh->_from_compiled_inline_entry != NULL, \"must be\");\n-    assert(mh->_from_compiled_inline_ro_entry != NULL, \"must be\");\n-  } else {\n-    mh->set_adapter_entry(adapter);\n-    mh->_from_compiled_entry = adapter->get_c2i_entry();\n-    mh->_from_compiled_inline_entry = adapter->get_c2i_inline_entry();\n-    mh->_from_compiled_inline_ro_entry = adapter->get_c2i_inline_ro_entry();\n-  }\n+  mh->set_adapter_entry(adapter);\n+  mh->_from_compiled_entry = adapter->get_c2i_entry();\n+  mh->_from_compiled_inline_entry = adapter->get_c2i_inline_entry();\n+  mh->_from_compiled_inline_ro_entry = adapter->get_c2i_inline_ro_entry();\n@@ -1323,20 +1234,0 @@\n-\n-#if 0\n-  \/*\n-   * CDS:TODO --\n-   * \"Q\" classes in the method signature must be resolved during link_method.\n-   * However, at this point we are still inside method_holder()->restore_unshareable_info.\n-   * If we try to resolve method_holder(), or multually dependent classes, it will\n-   * cause deadlock and other ill effects.\n-   *\n-   * For now, lets do method linking inside InstanceKlass::link_class(). Optimization\n-   * may be possible if we know that resolution will never happen.\n-   *\/\n-\n-  \/\/ Since restore_unshareable_info can be called more than once for a method, don't\n-  \/\/ redo any work.\n-  if (adapter() == NULL) {\n-    methodHandle mh(THREAD, this);\n-    link_method(mh, CHECK);\n-  }\n-#endif\n@@ -2047,1 +1938,1 @@\n-int Method::invocation_count() {\n+int Method::invocation_count() const {\n@@ -2059,1 +1950,1 @@\n-int Method::backedge_count() {\n+int Method::backedge_count() const {\n@@ -2459,1 +2350,3 @@\n-  st->print_cr(\" - compiled entry     \" INTPTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled entry           \" INTPTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled inline entry    \" INTPTR_FORMAT, p2i(from_compiled_inline_entry()));\n+  st->print_cr(\" - compiled inline ro entry \" INTPTR_FORMAT, p2i(from_compiled_inline_ro_entry()));\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":37,"deletions":144,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  AdapterHandlerEntry* _adapter;\n@@ -104,1 +105,1 @@\n-  int               _compiled_invocation_count;  \/\/ Number of nmethod invocations so far (for perf. debugging)\n+  int64_t _compiled_invocation_count;\n@@ -433,2 +434,2 @@\n-  int invocation_count();\n-  int backedge_count();\n+  int invocation_count() const;\n+  int backedge_count() const;\n@@ -446,2 +447,2 @@\n-  int  compiled_invocation_count() const        { return _compiled_invocation_count;  }\n-  void set_compiled_invocation_count(int count) { _compiled_invocation_count = count; }\n+  int64_t  compiled_invocation_count() const    { return _compiled_invocation_count;}\n+  void set_compiled_invocation_count(int count) { _compiled_invocation_count = (int64_t)count; }\n@@ -450,1 +451,1 @@\n-  int  compiled_invocation_count() const        { return 0;  }\n+  int64_t  compiled_invocation_count() const    { return 0; }\n@@ -476,7 +477,1 @@\n-    constMethod()->set_adapter_entry(adapter);\n-  }\n-  void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {\n-    constMethod()->set_adapter_trampoline(trampoline);\n-  }\n-  void update_adapter_trampoline(AdapterHandlerEntry* adapter) {\n-    constMethod()->update_adapter_trampoline(adapter);\n+    _adapter = adapter;\n@@ -501,1 +496,1 @@\n-    return constMethod()->adapter();\n+    return _adapter;\n@@ -536,2 +531,0 @@\n-    assert(!is_shared(),\n-           \"shared method's interpreter entry should not be changed at run time\");\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -928,0 +928,16 @@\n+\n+const Type* XorINode::Value(PhaseGVN* phase) const {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  \/\/ x ^ x ==> 0\n+  if (in1->eqv_uncast(in2)) {\n+    return add_id();\n+  }\n+  return AddNode::Value(phase);\n+}\n+\n@@ -963,0 +979,14 @@\n+const Type* XorLNode::Value(PhaseGVN* phase) const {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  \/\/ x ^ x ==> 0\n+  if (in1->eqv_uncast(in2)) {\n+    return add_id();\n+  }\n+  return AddNode::Value(phase);\n+}\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -204,0 +204,1 @@\n+macro(MachNullCheck)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4634,1 +4634,1 @@\n-Node* Compile::constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl) {\n+Node* Compile::constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl, bool carry_dependency) {\n@@ -4637,1 +4637,1 @@\n-    value = new CastIINode(value, itype, false, true \/* range check dependency *\/);\n+    value = new CastIINode(value, itype, carry_dependency, true \/* range check dependency *\/);\n@@ -5287,0 +5287,24 @@\n+\n+Node* Compile::narrow_value(BasicType bt, Node* value, const Type* type, PhaseGVN* phase, bool transform_res) {\n+  if (type != NULL && phase->type(value)->higher_equal(type)) {\n+    return value;\n+  }\n+  Node* result = NULL;\n+  if (bt == T_BYTE) {\n+    result = phase->transform(new LShiftINode(value, phase->intcon(24)));\n+    result = new RShiftINode(result, phase->intcon(24));\n+  } else if (bt == T_BOOLEAN) {\n+    result = new AndINode(value, phase->intcon(0xFF));\n+  } else if (bt == T_CHAR) {\n+    result = new AndINode(value,phase->intcon(0xFFFF));\n+  } else {\n+    assert(bt == T_SHORT, \"unexpected narrow type\");\n+    result = phase->transform(new LShiftINode(value, phase->intcon(16)));\n+    result = new RShiftINode(result, phase->intcon(16));\n+  }\n+  if (transform_res) {\n+    result = phase->transform(result);\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1182,1 +1182,1 @@\n-  static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);\n+  static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl, bool carry_dependency = false);\n@@ -1219,3 +1219,4 @@\n-  static bool\n-  push_thru_add(PhaseGVN* phase, Node* z, const TypeInteger* tz, const TypeInteger*& rx, const TypeInteger*& ry,\n-                BasicType bt);\n+  static bool push_thru_add(PhaseGVN* phase, Node* z, const TypeInteger* tz, const TypeInteger*& rx, const TypeInteger*& ry,\n+                            BasicType bt);\n+\n+  static Node* narrow_value(BasicType bt, Node* value, const Type* type, PhaseGVN* phase, bool transform_res);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -773,1 +773,18 @@\n-        assert(store->find_edge(load) != -1, \"missing precedence edge\");\n+#ifdef ASSERT\n+        \/\/ We expect an anti-dependence edge from 'load' to 'store', except when\n+        \/\/ implicit_null_check() has hoisted 'store' above its early block to\n+        \/\/ perform an implicit null check, and 'load' is placed in the null\n+        \/\/ block. In this case it is safe to ignore the anti-dependence, as the\n+        \/\/ null block is only reached if 'store' tries to write to null.\n+        Block* store_null_block = NULL;\n+        Node* store_null_check = store->find_out_with(Op_MachNullCheck);\n+        if (store_null_check != NULL) {\n+          Node* if_true = store_null_check->find_out_with(Op_IfTrue);\n+          assert(if_true != NULL, \"null check without null projection\");\n+          Node* null_block_region = if_true->find_out_with(Op_Region);\n+          assert(null_block_region != NULL, \"null check without null region\");\n+          store_null_block = get_block_for_node(null_block_region);\n+        }\n+#endif\n+        assert(LCA == store_null_block || store->find_edge(load) != -1,\n+               \"missing precedence edge\");\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2102,3 +2102,3 @@\n-  Node* cnt  = make_load(ctrl, counter_addr, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-  Node* incr = _gvn.transform(new AddINode(cnt, _gvn.intcon(1)));\n-  store_to_memory(ctrl, counter_addr, incr, T_INT, adr_type, MemNode::unordered);\n+  Node* cnt  = make_load(ctrl, counter_addr, TypeLong::LONG, T_LONG, adr_type, MemNode::unordered);\n+  Node* incr = _gvn.transform(new AddLNode(cnt, _gvn.longcon(1)));\n+  store_to_memory(ctrl, counter_addr, incr, T_LONG, adr_type, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -112,1 +112,3 @@\n-\n+#ifdef ASSERT\n+  Node* ctrl = kit.control();\n+#endif\n@@ -136,0 +138,1 @@\n+  assert(ctrl == kit.control(), \"Control flow was added although the intrinsic bailed out\");\n@@ -2206,3 +2209,0 @@\n-  Node* adr;\n-  Node* offset = top();\n-  Node* val;\n@@ -2214,1 +2214,1 @@\n-  offset = argument(2);  \/\/ type: long\n+  Node* offset = argument(2);  \/\/ type: long\n@@ -2270,1 +2270,6 @@\n-  adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);\n+\n+  \/\/ Save state and restore on bailout\n+  uint old_sp = sp();\n+  SafePointNode* old_map = clone_map();\n+\n+  Node* adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);\n@@ -2276,0 +2281,2 @@\n+      set_map(old_map);\n+      set_sp(old_sp);\n@@ -2289,1 +2296,1 @@\n-  val = is_store ? argument(4 + (type == T_INLINE_TYPE ? 1 : 0)) : NULL;\n+  Node* val = is_store ? argument(4 + (type == T_INLINE_TYPE ? 1 : 0)) : NULL;\n@@ -2293,0 +2300,2 @@\n+    set_map(old_map);\n+    set_sp(old_sp);\n@@ -2302,0 +2311,2 @@\n+    set_map(old_map);\n+    set_sp(old_sp);\n@@ -2344,0 +2355,2 @@\n+      set_map(old_map);\n+      set_sp(old_sp);\n@@ -2372,0 +2385,1 @@\n+  old_map->destruct(&_gvn);\n@@ -2680,0 +2694,3 @@\n+  \/\/ Save state and restore on bailout\n+  uint old_sp = sp();\n+  SafePointNode* old_map = clone_map();\n@@ -2688,0 +2705,2 @@\n+    set_map(old_map);\n+    set_sp(old_sp);\n@@ -2691,0 +2710,2 @@\n+  old_map->destruct(&_gvn);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -738,0 +738,1 @@\n+  virtual int Opcode() const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -460,0 +460,3 @@\n+        if (is_subword_type(ft)) {\n+          n = Compile::narrow_value(ft, n, phi_type, &_igvn, true);\n+        }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2166,1 +2166,1 @@\n-Node *LoadBNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* LoadBNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -2169,3 +2169,5 @@\n-  if( value && !phase->type(value)->higher_equal( _type ) ) {\n-    Node *result = phase->transform( new LShiftINode(value, phase->intcon(24)) );\n-    return new RShiftINode(result, phase->intcon(24));\n+  if (value != NULL) {\n+    Node* narrow = Compile::narrow_value(T_BYTE, value, _type, phase, false);\n+    if (narrow != value) {\n+      return narrow;\n+    }\n@@ -2201,2 +2203,6 @@\n-  if (value && !phase->type(value)->higher_equal(_type))\n-    return new AndINode(value, phase->intcon(0xFF));\n+  if (value != NULL) {\n+    Node* narrow = Compile::narrow_value(T_BOOLEAN, value, _type, phase, false);\n+    if (narrow != value) {\n+      return narrow;\n+    }\n+  }\n@@ -2228,1 +2234,1 @@\n-Node *LoadUSNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* LoadUSNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -2231,2 +2237,6 @@\n-  if( value && !phase->type(value)->higher_equal( _type ) )\n-    return new AndINode(value,phase->intcon(0xFFFF));\n+  if (value != NULL) {\n+    Node* narrow = Compile::narrow_value(T_CHAR, value, _type, phase, false);\n+    if (narrow != value) {\n+      return narrow;\n+    }\n+  }\n@@ -2258,1 +2268,1 @@\n-Node *LoadSNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* LoadSNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -2261,3 +2271,5 @@\n-  if( value && !phase->type(value)->higher_equal( _type ) ) {\n-    Node *result = phase->transform( new LShiftINode(value, phase->intcon(16)) );\n-    return new RShiftINode(result, phase->intcon(16));\n+  if (value != NULL) {\n+    Node* narrow = Compile::narrow_value(T_SHORT, value, _type, phase, false);\n+    if (narrow != value) {\n+      return narrow;\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1273,1 +1273,0 @@\n-  const TypeInt* ikeytype = TypeInt::make(0, num_cases, Type::WidenMin);\n@@ -1276,1 +1275,8 @@\n-  key_val = C->conv_I2X_index(&_gvn, key_val, ikeytype, control());\n+  \/\/ Do not use a narrow int type here to prevent the data path from dying\n+  \/\/ while the control path is not removed. This can happen if the type of key_val\n+  \/\/ is later known to be out of bounds of [0, num_cases] and therefore a narrow cast\n+  \/\/ would be replaced by TOP while C2 is not able to fold the corresponding range checks.\n+  \/\/ Set _carry_dependency for the cast to avoid being removed by IGVN.\n+#ifdef _LP64\n+  key_val = C->constrained_convI2L(&_gvn, key_val, TypeInt::INT, control(), true \/* carry_dependency *\/);\n+#endif\n@@ -3388,3 +3394,2 @@\n-    a = _gvn.transform( new LShiftINode(a,_gvn.intcon(24)) );\n-    a = _gvn.transform( new RShiftINode(a,_gvn.intcon(24)) );\n-    push( a );\n+    a = Compile::narrow_value(T_BYTE, a, NULL, &_gvn, true);\n+    push(a);\n@@ -3394,3 +3399,2 @@\n-    a = _gvn.transform( new LShiftINode(a,_gvn.intcon(16)) );\n-    a = _gvn.transform( new RShiftINode(a,_gvn.intcon(16)) );\n-    push( a );\n+    a = Compile::narrow_value(T_SHORT, a, NULL, &_gvn, true);\n+    push(a);\n@@ -3400,1 +3404,2 @@\n-    push( _gvn.transform( new AndINode(a,_gvn.intcon(0xFFFF)) ) );\n+    a = Compile::narrow_value(T_CHAR, a, NULL, &_gvn, true);\n+    push(a);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  if (log_is_enabled(Debug, class, resolve) && k != NULL) {\n+  if (log_is_enabled(Debug, class, resolve)) {\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -892,1 +892,1 @@\n-  if (log_is_enabled(Debug, class, resolve) && k != NULL) {\n+  if (log_is_enabled(Debug, class, resolve)) {\n@@ -971,1 +971,0 @@\n-  Klass* defined_k;\n@@ -974,8 +973,8 @@\n-    defined_k = SystemDictionary::resolve_from_stream(class_name,\n-                                                      class_loader,\n-                                                      protection_domain,\n-                                                      &st,\n-                                                      CHECK_NULL);\n-\n-    if (log_is_enabled(Debug, class, resolve) && defined_k != NULL) {\n-      trace_class_resolution(defined_k);\n+    ik = SystemDictionary::resolve_from_stream(class_name,\n+                                               class_loader,\n+                                               protection_domain,\n+                                               &st,\n+                                               CHECK_NULL);\n+\n+    if (log_is_enabled(Debug, class, resolve)) {\n+      trace_class_resolution(ik);\n@@ -983,1 +982,0 @@\n-    ik = InstanceKlass::cast(defined_k);\n@@ -994,10 +992,5 @@\n-    defined_k = SystemDictionary::parse_stream(class_name,\n-                                               class_loader,\n-                                               &st,\n-                                               cl_info,\n-                                               CHECK_NULL);\n-    if (defined_k == NULL) {\n-      THROW_MSG_0(vmSymbols::java_lang_Error(), \"Failure to define a hidden class\");\n-    }\n-\n-    ik = InstanceKlass::cast(defined_k);\n+    ik = SystemDictionary::parse_stream(class_name,\n+                                        class_loader,\n+                                        &st,\n+                                        cl_info,\n+                                        CHECK_NULL);\n@@ -1020,1 +1013,1 @@\n-  assert(Reflection::is_same_class_package(lookup_k, defined_k),\n+  assert(Reflection::is_same_class_package(lookup_k, ik),\n@@ -1029,1 +1022,1 @@\n-  return (jclass) JNIHandles::make_local(THREAD, defined_k->java_mirror());\n+  return (jclass) JNIHandles::make_local(THREAD, ik->java_mirror());\n@@ -1112,1 +1105,2 @@\n-  Modules::define_module(module, is_open, version, location, packages, CHECK);\n+  Handle h_module (THREAD, JNIHandles::resolve(module));\n+  Modules::define_module(h_module, is_open, version, location, packages, CHECK);\n@@ -1116,1 +1110,2 @@\n-  Modules::set_bootloader_unnamed_module(module, CHECK);\n+  Handle h_module (THREAD, JNIHandles::resolve(module));\n+  Modules::set_bootloader_unnamed_module(h_module, CHECK);\n@@ -1120,1 +1115,3 @@\n-  Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Handle h_to_module (THREAD, JNIHandles::resolve(to_module));\n+  Modules::add_module_exports_qualified(h_from_module, package, h_to_module, CHECK);\n@@ -1124,1 +1121,2 @@\n-  Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Modules::add_module_exports_to_all_unnamed(h_from_module, package, CHECK);\n@@ -1128,1 +1126,2 @@\n-  Modules::add_module_exports(from_module, package, NULL, CHECK);\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Modules::add_module_exports(h_from_module, package, Handle(), CHECK);\n@@ -1132,1 +1131,3 @@\n-  Modules::add_reads_module(from_module, source_module, CHECK);\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Handle h_source_module (THREAD, JNIHandles::resolve(source_module));\n+  Modules::add_reads_module(h_from_module, h_source_module, CHECK);\n@@ -1136,1 +1137,3 @@\n-  Modules::define_archived_modules(platform_loader, system_loader, CHECK);\n+  Handle h_platform_loader (THREAD, JNIHandles::resolve(platform_loader));\n+  Handle h_system_loader (THREAD, JNIHandles::resolve(system_loader));\n+  Modules::define_archived_modules(h_platform_loader, h_system_loader, CHECK);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1004,9 +1004,6 @@\n-  Klass* anonk = SystemDictionary::parse_stream(no_class_name,\n-                                                host_loader,\n-                                                &st,\n-                                                cl_info,\n-                                                CHECK_NULL);\n-  if (anonk == NULL) {\n-    return NULL;\n-  }\n-\n+  InstanceKlass* anonk = SystemDictionary::parse_stream(no_class_name,\n+                                                        host_loader,\n+                                                        &st,\n+                                                        cl_info,\n+                                                        CHECK_NULL);\n+  assert(anonk != NULL, \"no klass created\");\n@@ -1014,2 +1011,1 @@\n-\n-  return InstanceKlass::cast(anonk);\n+  return anonk;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -259,15 +259,0 @@\n-#ifndef PRODUCT\n-\/\/ Forward declaration\n-void TestReservedSpace_test();\n-void TestReserveMemorySpecial_test();\n-void TestVirtualSpace_test();\n-#endif\n-\n-WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))\n-#ifndef PRODUCT\n-  TestReservedSpace_test();\n-  TestReserveMemorySpecial_test();\n-  TestVirtualSpace_test();\n-#endif\n-WB_END\n-\n@@ -1708,1 +1693,2 @@\n-  Modules::define_module(module, is_open, version, location, packages, CHECK);\n+  Handle h_module (THREAD, JNIHandles::resolve(module));\n+  Modules::define_module(h_module, is_open, version, location, packages, CHECK);\n@@ -1712,1 +1698,3 @@\n-  Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Handle h_to_module (THREAD, JNIHandles::resolve(to_module));\n+  Modules::add_module_exports_qualified(h_from_module, package, h_to_module, CHECK);\n@@ -1716,1 +1704,2 @@\n-  Modules::add_module_exports_to_all_unnamed(module, package, CHECK);\n+  Handle h_module (THREAD, JNIHandles::resolve(module));\n+  Modules::add_module_exports_to_all_unnamed(h_module, package, CHECK);\n@@ -1720,1 +1709,2 @@\n-  Modules::add_module_exports(module, package, NULL, CHECK);\n+  Handle h_module (THREAD, JNIHandles::resolve(module));\n+  Modules::add_module_exports(h_module, package, Handle(), CHECK);\n@@ -1724,1 +1714,3 @@\n-  Modules::add_reads_module(from_module, source_module, CHECK);\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Handle h_source_module (THREAD, JNIHandles::resolve(source_module));\n+  Modules::add_reads_module(h_from_module, h_source_module, CHECK);\n@@ -2441,1 +2433,0 @@\n-  {CC\"runMemoryUnitTests\", CC\"()V\",                   (void*)&WB_RunMemoryUnitTests},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -87,2 +88,0 @@\n-intx   Arguments::_Tier3InvokeNotifyFreqLog     = Tier3InvokeNotifyFreqLog;\n-intx   Arguments::_Tier4InvocationThreshold     = Tier4InvocationThreshold;\n@@ -1460,6 +1459,0 @@\n-  if (FLAG_IS_DEFAULT(Tier3InvokeNotifyFreqLog)) {\n-    Tier3InvokeNotifyFreqLog = Arguments::_Tier3InvokeNotifyFreqLog;\n-  }\n-  if (FLAG_IS_DEFAULT(Tier4InvocationThreshold)) {\n-    Tier4InvocationThreshold = Arguments::_Tier4InvocationThreshold;\n-  }\n@@ -1485,7 +1478,0 @@\n-    \/\/ Be much more aggressive in tiered mode with -Xcomp and exercise C2 more.\n-    \/\/ We will first compile a level 3 version (C1 with full profiling), then do one invocation of it and\n-    \/\/ compile a level 4 (C2) and then continue executing it.\n-    if (CompilerConfig::is_c2_or_jvmci_compiler_enabled()) {\n-      Tier3InvokeNotifyFreqLog = 0;\n-      Tier4InvocationThreshold = 0;\n-    }\n@@ -2148,2 +2134,0 @@\n-  Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;\n-  Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;\n@@ -2283,0 +2267,5 @@\n+  \/\/ Make sure the above values match the range set in globals.hpp\n+  const JVMTypedFlagLimit<intx>* limit = JVMFlagLimit::get_range_at(FLAG_MEMBER_ENUM(ThreadStackSize))->cast<intx>();\n+  assert(min_ThreadStackSize == static_cast<julong>(limit->min()), \"must be\");\n+  assert(max_ThreadStackSize == static_cast<julong>(limit->max()), \"must be\");\n+\n@@ -4119,1 +4108,1 @@\n-  if (!EnableVectorSupport) {\n+  if (!FLAG_IS_DEFAULT(EnableVectorSupport) && !EnableVectorSupport) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -149,10 +149,10 @@\n-int SharedRuntime::_nof_normal_calls = 0;\n-int SharedRuntime::_nof_optimized_calls = 0;\n-int SharedRuntime::_nof_inlined_calls = 0;\n-int SharedRuntime::_nof_megamorphic_calls = 0;\n-int SharedRuntime::_nof_static_calls = 0;\n-int SharedRuntime::_nof_inlined_static_calls = 0;\n-int SharedRuntime::_nof_interface_calls = 0;\n-int SharedRuntime::_nof_optimized_interface_calls = 0;\n-int SharedRuntime::_nof_inlined_interface_calls = 0;\n-int SharedRuntime::_nof_megamorphic_interface_calls = 0;\n+int64_t SharedRuntime::_nof_normal_calls = 0;\n+int64_t SharedRuntime::_nof_optimized_calls = 0;\n+int64_t SharedRuntime::_nof_inlined_calls = 0;\n+int64_t SharedRuntime::_nof_megamorphic_calls = 0;\n+int64_t SharedRuntime::_nof_static_calls = 0;\n+int64_t SharedRuntime::_nof_inlined_static_calls = 0;\n+int64_t SharedRuntime::_nof_interface_calls = 0;\n+int64_t SharedRuntime::_nof_optimized_interface_calls = 0;\n+int64_t SharedRuntime::_nof_inlined_interface_calls = 0;\n+int64_t SharedRuntime::_nof_megamorphic_interface_calls = 0;\n@@ -2276,0 +2276,4 @@\n+inline double percent(int64_t x, int64_t y) {\n+  return 100.0 * x \/ MAX2(y, (int64_t)1);\n+}\n+\n@@ -2280,4 +2284,6 @@\n-  static int _arity_histogram[MAX_ARITY];     \/\/ histogram of #args\n-  static int _size_histogram[MAX_ARITY];      \/\/ histogram of arg size in words\n-  static int _max_arity;                      \/\/ max. arity seen\n-  static int _max_size;                       \/\/ max. arg size seen\n+  static uint64_t _arity_histogram[MAX_ARITY]; \/\/ histogram of #args\n+  static uint64_t _size_histogram[MAX_ARITY];  \/\/ histogram of arg size in words\n+  static uint64_t _total_compiled_calls;\n+  static uint64_t _max_compiled_calls_per_method;\n+  static int _max_arity;                       \/\/ max. arity seen\n+  static int _max_size;                        \/\/ max. arg size seen\n@@ -2293,1 +2299,3 @@\n-      int count = method->compiled_invocation_count();\n+      uint64_t count = (uint64_t)method->compiled_invocation_count();\n+      _max_compiled_calls_per_method = count > _max_compiled_calls_per_method ? count : _max_compiled_calls_per_method;\n+      _total_compiled_calls    += count;\n@@ -2301,3 +2309,2 @@\n-  void print_histogram_helper(int n, int* histo, const char* name) {\n-    const int N = MIN2(5, n);\n-    tty->print_cr(\"\\nHistogram of call arity (incl. rcvr, calls to compiled methods only):\");\n+  void print_histogram_helper(int n, uint64_t* histo, const char* name) {\n+    const int N = MIN2(9, n);\n@@ -2306,7 +2313,14 @@\n-    int i;\n-    for (i = 0; i <= n; i++) { sum += histo[i]; weighted_sum += i*histo[i]; }\n-    double rest = sum;\n-    double percent = sum \/ 100;\n-    for (i = 0; i <= N; i++) {\n-      rest -= histo[i];\n-      tty->print_cr(\"%4d: %7d (%5.1f%%)\", i, histo[i], histo[i] \/ percent);\n+    for (int i = 0; i <= n; i++) { sum += histo[i]; weighted_sum += i*histo[i]; }\n+    if (sum >= 1.0) { \/\/ prevent divide by zero or divide overflow\n+      double rest = sum;\n+      double percent = sum \/ 100;\n+      for (int i = 0; i <= N; i++) {\n+        rest -= histo[i];\n+        tty->print_cr(\"%4d: \" UINT64_FORMAT_W(12) \" (%5.1f%%)\", i, histo[i], histo[i] \/ percent);\n+      }\n+      tty->print_cr(\"rest: \" INT64_FORMAT_W(12) \" (%5.1f%%)\", (int64_t)rest, rest \/ percent);\n+      tty->print_cr(\"(avg. %s = %3.1f, max = %d)\", name, weighted_sum \/ sum, n);\n+      tty->print_cr(\"(total # of compiled calls = \" INT64_FORMAT_W(14) \")\", _total_compiled_calls);\n+      tty->print_cr(\"(max # of compiled calls   = \" INT64_FORMAT_W(14) \")\", _max_compiled_calls_per_method);\n+    } else {\n+      tty->print_cr(\"Histogram generation failed for %s. n = %d, sum = %7.5f\", name, n, sum);\n@@ -2314,2 +2328,0 @@\n-    tty->print_cr(\"rest: %7d (%5.1f%%))\", (int)rest, rest \/ percent);\n-    tty->print_cr(\"(avg. %s = %3.1f, max = %d)\", name, weighted_sum \/ sum, n);\n@@ -2321,1 +2333,1 @@\n-    tty->print_cr(\"\\nSame for parameter size (in words):\");\n+    tty->print_cr(\"\\nHistogram of parameter block size (in words, incl. rcvr):\");\n@@ -2333,0 +2345,2 @@\n+    _total_compiled_calls = 0;\n+    _max_compiled_calls_per_method = 0;\n@@ -2339,2 +2353,4 @@\n-int MethodArityHistogram::_arity_histogram[MethodArityHistogram::MAX_ARITY];\n-int MethodArityHistogram::_size_histogram[MethodArityHistogram::MAX_ARITY];\n+uint64_t MethodArityHistogram::_arity_histogram[MethodArityHistogram::MAX_ARITY];\n+uint64_t MethodArityHistogram::_size_histogram[MethodArityHistogram::MAX_ARITY];\n+uint64_t MethodArityHistogram::_total_compiled_calls;\n+uint64_t MethodArityHistogram::_max_compiled_calls_per_method;\n@@ -2344,1 +2360,1 @@\n-void SharedRuntime::print_call_statistics(int comp_total) {\n+void SharedRuntime::print_call_statistics(uint64_t comp_total) {\n@@ -2346,16 +2362,16 @@\n-  int total  = _nof_normal_calls + _nof_interface_calls + _nof_static_calls;\n-  int mono_c = _nof_normal_calls - _nof_optimized_calls - _nof_megamorphic_calls;\n-  int mono_i = _nof_interface_calls - _nof_optimized_interface_calls - _nof_megamorphic_interface_calls;\n-  tty->print_cr(\"\\t%9d   (%4.1f%%) total non-inlined   \", total, percent(total, total));\n-  tty->print_cr(\"\\t%9d   (%4.1f%%) virtual calls       \", _nof_normal_calls, percent(_nof_normal_calls, total));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   inlined          \", _nof_inlined_calls, percent(_nof_inlined_calls, _nof_normal_calls));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   optimized        \", _nof_optimized_calls, percent(_nof_optimized_calls, _nof_normal_calls));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   monomorphic      \", mono_c, percent(mono_c, _nof_normal_calls));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   megamorphic      \", _nof_megamorphic_calls, percent(_nof_megamorphic_calls, _nof_normal_calls));\n-  tty->print_cr(\"\\t%9d   (%4.1f%%) interface calls     \", _nof_interface_calls, percent(_nof_interface_calls, total));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   inlined          \", _nof_inlined_interface_calls, percent(_nof_inlined_interface_calls, _nof_interface_calls));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   optimized        \", _nof_optimized_interface_calls, percent(_nof_optimized_interface_calls, _nof_interface_calls));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   monomorphic      \", mono_i, percent(mono_i, _nof_interface_calls));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   megamorphic      \", _nof_megamorphic_interface_calls, percent(_nof_megamorphic_interface_calls, _nof_interface_calls));\n-  tty->print_cr(\"\\t%9d   (%4.1f%%) static\/special calls\", _nof_static_calls, percent(_nof_static_calls, total));\n-  tty->print_cr(\"\\t  %9d  (%3.0f%%)   inlined          \", _nof_inlined_static_calls, percent(_nof_inlined_static_calls, _nof_static_calls));\n+  int64_t total  = _nof_normal_calls + _nof_interface_calls + _nof_static_calls;\n+  int64_t mono_c = _nof_normal_calls - _nof_optimized_calls - _nof_megamorphic_calls;\n+  int64_t mono_i = _nof_interface_calls - _nof_optimized_interface_calls - _nof_megamorphic_interface_calls;\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (100%%)  total non-inlined   \", total);\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.1f%%) |- virtual calls       \", _nof_normal_calls, percent(_nof_normal_calls, total));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- inlined          \", _nof_inlined_calls, percent(_nof_inlined_calls, _nof_normal_calls));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- optimized        \", _nof_optimized_calls, percent(_nof_optimized_calls, _nof_normal_calls));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- monomorphic      \", mono_c, percent(mono_c, _nof_normal_calls));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- megamorphic      \", _nof_megamorphic_calls, percent(_nof_megamorphic_calls, _nof_normal_calls));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.1f%%) |- interface calls     \", _nof_interface_calls, percent(_nof_interface_calls, total));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- inlined          \", _nof_inlined_interface_calls, percent(_nof_inlined_interface_calls, _nof_interface_calls));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- optimized        \", _nof_optimized_interface_calls, percent(_nof_optimized_interface_calls, _nof_interface_calls));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- monomorphic      \", mono_i, percent(mono_i, _nof_interface_calls));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- megamorphic      \", _nof_megamorphic_interface_calls, percent(_nof_megamorphic_interface_calls, _nof_interface_calls));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.1f%%) |- static\/special calls\", _nof_static_calls, percent(_nof_static_calls, total));\n+  tty->print_cr(\"\\t\" INT64_FORMAT_W(12) \" (%4.0f%%) |  |- inlined          \", _nof_inlined_static_calls, percent(_nof_inlined_static_calls, _nof_static_calls));\n@@ -2732,31 +2748,0 @@\n-static void generate_trampoline(address trampoline, address destination) {\n-  if (*(int*)trampoline == 0) {\n-    CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());\n-    MacroAssembler _masm(&buffer);\n-    SharedRuntime::generate_trampoline(&_masm, destination);\n-    assert(*(int*)trampoline != 0, \"Instruction(s) for trampoline must not be encoded as zeros.\");\n-      _masm.flush();\n-\n-    if (PrintInterpreter) {\n-      Disassembler::decode(buffer.insts_begin(), buffer.insts_end());\n-    }\n-  }\n-}\n-\n-AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle& method) {\n-  AdapterHandlerEntry* entry = get_adapter0(method);\n-  if (entry != NULL && method->is_shared()) {\n-    \/\/ See comments around Method::link_method()\n-    MutexLocker mu(AdapterHandlerLibrary_lock);\n-    if (method->adapter() == NULL) {\n-      method->update_adapter_trampoline(entry);\n-    }\n-    generate_trampoline(method->from_compiled_entry(),           entry->get_c2i_entry());\n-    generate_trampoline(method->from_compiled_inline_ro_entry(), entry->get_c2i_inline_ro_entry());\n-    generate_trampoline(method->from_compiled_inline_entry(),    entry->get_c2i_inline_entry());\n-  }\n-\n-  return entry;\n-}\n-\n-\n@@ -2903,1 +2888,1 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle& method) {\n+AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle& method) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":64,"deletions":79,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  static int     _nof_megamorphic_calls;         \/\/ total # of megamorphic calls (through vtable)\n+  static int64_t _nof_megamorphic_calls;         \/\/ total # of megamorphic calls (through vtable)\n@@ -417,2 +417,0 @@\n-  static void generate_trampoline(MacroAssembler *masm, address destination);\n-\n@@ -604,5 +602,5 @@\n-  static int     _nof_normal_calls;              \/\/ total # of calls\n-  static int     _nof_optimized_calls;           \/\/ total # of statically-bound calls\n-  static int     _nof_inlined_calls;             \/\/ total # of inlined normal calls\n-  static int     _nof_static_calls;              \/\/ total # of calls to static methods or super methods (invokespecial)\n-  static int     _nof_inlined_static_calls;      \/\/ total # of inlined static calls\n+  static int64_t _nof_normal_calls;               \/\/ total # of calls\n+  static int64_t _nof_optimized_calls;            \/\/ total # of statically-bound calls\n+  static int64_t _nof_inlined_calls;              \/\/ total # of inlined normal calls\n+  static int64_t _nof_static_calls;               \/\/ total # of calls to static methods or super methods (invokespecial)\n+  static int64_t _nof_inlined_static_calls;       \/\/ total # of inlined static calls\n@@ -610,4 +608,4 @@\n-  static int     _nof_interface_calls;           \/\/ total # of compiled calls\n-  static int     _nof_optimized_interface_calls; \/\/ total # of statically-bound interface calls\n-  static int     _nof_inlined_interface_calls;   \/\/ total # of inlined interface calls\n-  static int     _nof_megamorphic_interface_calls;\/\/ total # of megamorphic interface calls\n+  static int64_t _nof_interface_calls;            \/\/ total # of compiled calls\n+  static int64_t _nof_optimized_interface_calls;  \/\/ total # of statically-bound interface calls\n+  static int64_t _nof_inlined_interface_calls;    \/\/ total # of inlined interface calls\n+  static int64_t _nof_megamorphic_interface_calls;\/\/ total # of megamorphic interface calls\n@@ -625,1 +623,1 @@\n-  static void print_call_statistics(int comp_total);\n+  static void print_call_statistics(uint64_t comp_total);\n@@ -750,1 +748,0 @@\n-  static AdapterHandlerEntry* get_adapter0(const methodHandle& method);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/safefetch.hpp\"\n+#include \"runtime\/safefetch.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -944,8 +944,11 @@\n-char java_version[64] = \"\";\n-char java_runtime_name[128] = \"\";\n-char java_runtime_version[128] = \"\";\n-char java_runtime_vendor_version[128] = \"\";\n-char java_runtime_vendor_vm_bug_url[128] = \"\";\n-\n-\/\/ extract the JRE version string from java.lang.VersionProps.java_version\n-static const char* get_java_version(InstanceKlass* ik) {\n+static char java_version[64] = \"\";\n+static char java_runtime_name[128] = \"\";\n+static char java_runtime_version[128] = \"\";\n+static char java_runtime_vendor_version[128] = \"\";\n+static char java_runtime_vendor_vm_bug_url[128] = \"\";\n+\n+\/\/ Extract version and vendor specific information.\n+static const char* get_java_version_info(InstanceKlass* ik,\n+                                         Symbol* field_name,\n+                                         char* buffer,\n+                                         int buffer_size) {\n@@ -954,1 +957,1 @@\n-               ik->find_local_field(vmSymbols::java_version_name(),\n+               ik->find_local_field(field_name,\n@@ -962,82 +965,2 @@\n-                                                        java_version,\n-                                                        sizeof(java_version));\n-    return name;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ extract the JRE name from java.lang.VersionProps.java_runtime_name\n-static const char* get_java_runtime_name(InstanceKlass* ik) {\n-  fieldDescriptor fd;\n-  bool found = ik != NULL &&\n-               ik->find_local_field(vmSymbols::java_runtime_name_name(),\n-                                    vmSymbols::string_signature(), &fd);\n-  if (found) {\n-    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n-    if (name_oop == NULL) {\n-      return NULL;\n-    }\n-    const char* name = java_lang_String::as_utf8_string(name_oop,\n-                                                        java_runtime_name,\n-                                                        sizeof(java_runtime_name));\n-    return name;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ extract the JRE version from java.lang.VersionProps.java_runtime_version\n-static const char* get_java_runtime_version(InstanceKlass* ik) {\n-  fieldDescriptor fd;\n-  bool found = ik != NULL &&\n-               ik->find_local_field(vmSymbols::java_runtime_version_name(),\n-                                    vmSymbols::string_signature(), &fd);\n-  if (found) {\n-    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n-    if (name_oop == NULL) {\n-      return NULL;\n-    }\n-    const char* name = java_lang_String::as_utf8_string(name_oop,\n-                                                        java_runtime_version,\n-                                                        sizeof(java_runtime_version));\n-    return name;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ extract the JRE vendor version from java.lang.VersionProps.VENDOR_VERSION\n-static const char* get_java_runtime_vendor_version(InstanceKlass* ik) {\n-  fieldDescriptor fd;\n-  bool found = ik != NULL &&\n-               ik->find_local_field(vmSymbols::java_runtime_vendor_version_name(),\n-                                    vmSymbols::string_signature(), &fd);\n-  if (found) {\n-    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n-    if (name_oop == NULL) {\n-      return NULL;\n-    }\n-    const char* name = java_lang_String::as_utf8_string(name_oop,\n-                                                        java_runtime_vendor_version,\n-                                                        sizeof(java_runtime_vendor_version));\n-    return name;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ extract the JRE vendor VM bug URL from java.lang.VersionProps.VENDOR_URL_VM_BUG\n-static const char* get_java_runtime_vendor_vm_bug_url(InstanceKlass* ik) {\n-  fieldDescriptor fd;\n-  bool found = ik != NULL &&\n-               ik->find_local_field(vmSymbols::java_runtime_vendor_vm_bug_url_name(),\n-                                    vmSymbols::string_signature(), &fd);\n-  if (found) {\n-    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n-    if (name_oop == NULL) {\n-      return NULL;\n-    }\n-    const char* name = java_lang_String::as_utf8_string(name_oop,\n-                                                        java_runtime_vendor_vm_bug_url,\n-                                                        sizeof(java_runtime_vendor_vm_bug_url));\n+                                                        buffer,\n+                                                        buffer_size);\n@@ -3058,5 +2981,17 @@\n-  JDK_Version::set_java_version(get_java_version(ik));\n-  JDK_Version::set_runtime_name(get_java_runtime_name(ik));\n-  JDK_Version::set_runtime_version(get_java_runtime_version(ik));\n-  JDK_Version::set_runtime_vendor_version(get_java_runtime_vendor_version(ik));\n-  JDK_Version::set_runtime_vendor_vm_bug_url(get_java_runtime_vendor_vm_bug_url(ik));\n+\n+  JDK_Version::set_java_version(get_java_version_info(ik, vmSymbols::java_version_name(),\n+                                                      java_version, sizeof(java_version)));\n+\n+  JDK_Version::set_runtime_name(get_java_version_info(ik, vmSymbols::java_runtime_name_name(),\n+                                                      java_runtime_name, sizeof(java_runtime_name)));\n+\n+  JDK_Version::set_runtime_version(get_java_version_info(ik, vmSymbols::java_runtime_version_name(),\n+                                                         java_runtime_version, sizeof(java_runtime_version)));\n+\n+  JDK_Version::set_runtime_vendor_version(get_java_version_info(ik, vmSymbols::java_runtime_vendor_version_name(),\n+                                                                java_runtime_vendor_version,\n+                                                                sizeof(java_runtime_vendor_version)));\n+\n+  JDK_Version::set_runtime_vendor_vm_bug_url(get_java_version_info(ik, vmSymbols::java_runtime_vendor_vm_bug_url_name(),\n+                                                                   java_runtime_vendor_vm_bug_url,\n+                                                                   sizeof(java_runtime_vendor_vm_bug_url)));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":31,"deletions":96,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -310,1 +310,0 @@\n-  nonproduct_nonstatic_field(Method,           _compiled_invocation_count,                    int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,12 +76,6 @@\n-\/\/ Declare the named class to be noncopyable.  This macro must be used in\n-\/\/ a private part of the class's definition, followed by a semi-colon.\n-\/\/ Doing so provides private declarations for the class's copy constructor\n-\/\/ and assignment operator.  Because these operations are private, most\n-\/\/ potential callers will fail to compile because they are inaccessible.\n-\/\/ The operations intentionally lack a definition, to provoke link-time\n-\/\/ failures for calls from contexts where they are accessible, e.g. from\n-\/\/ within the class or from a friend of the class.\n-\/\/ Note: The lack of definitions is still not completely bullet-proof, as\n-\/\/ an apparent call might be optimized away by copy elision.\n-\/\/ For C++11 the declarations should be changed to deleted definitions.\n-#define NONCOPYABLE(C) C(C const&); C& operator=(C const&) \/* next token must be ; *\/\n+\/\/ Declare the named class to be noncopyable.  This macro must be followed by\n+\/\/ a semi-colon.  The macro provides deleted declarations for the class's copy\n+\/\/ constructor and assignment operator.  Because these operations are deleted,\n+\/\/ they cannot be defined and potential callers will fail to compile.\n+#define NONCOPYABLE(C) C(C const&) = delete; C& operator=(C const&) = delete \/* next token must be ; *\/\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2409,2 +2409,1 @@\n-            if (obj instanceof FieldReflectorKey) {\n-                FieldReflectorKey other = (FieldReflectorKey) obj;\n+            if (obj instanceof FieldReflectorKey other) {\n@@ -2606,2 +2605,1 @@\n-                if (!(obj instanceof Key)) return false;\n-                Key other = (Key) obj;\n+                if (!(obj instanceof Key other)) return false;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1684,1 +1684,1 @@\n-         * <p>\n+         *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3848,1 +3848,1 @@\n-                if (t1 != t2 && types.isSubtypeNoCapture(t2, t1)) {\n+                if (t1 != t2 && !t2.hasTag(ERROR) && types.isSubtypeNoCapture(t2, t1)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -299,1 +299,0 @@\n- -runtime\/memory\/RunUnitTestsConcurrently.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        String unmapRgn0Pattern = \".*Unmapping region #0 at base 0x.*(MiscCode)\";\n+        String unmapRgn0Pattern = \".*Unmapping region #0 at base 0x.*(ReadWrite)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveRelocationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -526,1 +526,0 @@\n-  public native void runMemoryUnitTests();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}