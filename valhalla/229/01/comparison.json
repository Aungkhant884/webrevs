{"files":[{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import java.lang.annotation.*;\n-\n-\/**\n- * An informative annotation type used to indicate that a value type existed in a\n- * prior avatar as a <a href=\"..\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n- * class. Armed with this information, the compiler may choose to treat with leniency \n- * certain constructs which are erroneous when used with value types, thereby easing the\n- * pain of migration.\n- *\/\n-\n-@Documented\n-@Retention(RetentionPolicy.CLASS)\n-@Target(ElementType.TYPE)\n-public @interface ValueBased {}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ValueBased.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,640 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.valhalla.sandbox.corelibs;\n+\n+import java.util.Arrays;\n+import java.util.ConcurrentModificationException;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+\n+\/**\n+ * Resizable-array implementation like {@code ArrayList<int>}.\n+ *\/\n+public class ArrayListInt\n+\/\/        extends AbstractList<E>\n+\/\/        implements List<int>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    @java.io.Serial\n+    private static final long serialVersionUID = 8683452581122892189L;\n+\n+    \/**\n+     * Default initial capacity.\n+     *\/\n+    private static final int DEFAULT_CAPACITY = 10;\n+\n+    \/**\n+     * Shared empty array instance used for empty instances.\n+     *\/\n+    private static final int[] EMPTY_ELEMENTDATA = {};\n+\n+    \/**\n+     * Shared empty array instance used for default sized empty instances. We\n+     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n+     * first element is added.\n+     *\/\n+    private static final int[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = new int[0];\n+\n+    \/**\n+     * The array buffer into which the elements of the ArrayList are stored.\n+     * The capacity of the ArrayList is the length of this array buffer. Any\n+     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n+     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n+     *\/\n+    transient int[] elementData; \/\/ non-private to simplify nested class access\n+\n+    protected transient int modCount = 0;\n+\n+    \/**\n+     * The size of the ArrayList (the number of elements it contains).\n+     *\n+     * @serial\n+     *\/\n+    private int size;\n+\n+    \/**\n+     * Constructs an empty list with the specified initial capacity.\n+     *\n+     * @param  initialCapacity  the initial capacity of the list\n+     * @throws IllegalArgumentException if the specified initial capacity\n+     *         is negative\n+     *\/\n+    public ArrayListInt(int initialCapacity) {\n+        if (initialCapacity > 0) {\n+            this.elementData = new int[initialCapacity];\n+        } else if (initialCapacity == 0) {\n+            this.elementData = EMPTY_ELEMENTDATA;\n+        } else {\n+            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n+                                               initialCapacity);\n+        }\n+    }\n+\n+    \/**\n+     * Constructs an empty list with an initial capacity of ten.\n+     *\/\n+    public ArrayListInt() {\n+        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n+    }\n+\n+    \/**\n+     * Trims the capacity of this {@code ArrayList} instance to be the\n+     * list's current size.  An application can use this operation to minimize\n+     * the storage of an {@code ArrayList} instance.\n+     *\/\n+    public void trimToSize() {\n+        modCount++;\n+        if (size < elementData.length) {\n+            elementData = (size == 0)\n+              ? EMPTY_ELEMENTDATA\n+              : Arrays.copyOf(elementData, size);\n+        }\n+    }\n+\n+    \/**\n+     * Increases the capacity of this {@code ArrayList} instance, if\n+     * necessary, to ensure that it can hold at least the number of elements\n+     * specified by the minimum capacity argument.\n+     *\n+     * @param minCapacity the desired minimum capacity\n+     *\/\n+    public void ensureCapacity(int minCapacity) {\n+        if (minCapacity > elementData.length\n+            && !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n+                 && minCapacity <= DEFAULT_CAPACITY)) {\n+            modCount++;\n+            grow(minCapacity);\n+        }\n+    }\n+\n+    \/**\n+     * Increases the capacity to ensure that it can hold at least the\n+     * number of elements specified by the minimum capacity argument.\n+     *\n+     * @param minCapacity the desired minimum capacity\n+     * @throws OutOfMemoryError if minCapacity is less than zero\n+     *\/\n+    private int[] grow(int minCapacity) {\n+        int oldCapacity = elementData.length;\n+        if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n+            int newCapacity = newLength(oldCapacity,\n+                    minCapacity - oldCapacity, \/* minimum growth *\/\n+                    oldCapacity >> 1           \/* preferred growth *\/);\n+            return elementData = Arrays.copyOf(elementData, newCapacity);\n+        } else {\n+            return elementData = new int[Math.max(DEFAULT_CAPACITY, minCapacity)];\n+        }\n+    }\n+\n+    private int[] grow() {\n+        return grow(size + 1);\n+    }\n+\n+    \/**\n+     * Returns the number of elements in this list.\n+     *\n+     * @return the number of elements in this list\n+     *\/\n+    public int size() {\n+        return size;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this list contains no elements.\n+     *\n+     * @return {@code true} if this list contains no elements\n+     *\/\n+    public boolean isEmpty() {\n+        return size == 0;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this list contains the specified element.\n+     * More formally, returns {@code true} if and only if this list contains\n+     * at least one element {@code e} such that\n+     * {@code Objects.equals(o, e)}.\n+     *\n+     * @param o element whose presence in this list is to be tested\n+     * @return {@code true} if this list contains the specified element\n+     *\/\n+    public boolean contains(int o) {\n+        return indexOf(o) >= 0;\n+    }\n+\n+    \/**\n+     * Returns the index of the first occurrence of the specified element\n+     * in this list, or -1 if this list does not contain the element.\n+     * More formally, returns the lowest index {@code i} such that\n+     * {@code Objects.equals(o, get(i))},\n+     * or -1 if there is no such index.\n+     *\/\n+    public int indexOf(int o) {\n+        return indexOfRange(o, 0, size);\n+    }\n+\n+    int indexOfRange(int o, int start, int end) {\n+        int[] es = elementData;\n+        for (int i = start; i < end; i++) {\n+            if (o == es[i]) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/**\n+     * Returns the index of the last occurrence of the specified element\n+     * in this list, or -1 if this list does not contain the element.\n+     * More formally, returns the highest index {@code i} such that\n+     * {@code Objects.equals(o, get(i))},\n+     * or -1 if there is no such index.\n+     *\/\n+    public int lastIndexOf(int o) {\n+        return lastIndexOfRange(o, 0, size);\n+    }\n+\n+    int lastIndexOfRange(int o, int start, int end) {\n+        int[] es = elementData;\n+            {\n+            for (int i = end - 1; i >= start; i--) {\n+                if (o == es[i]) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/**\n+     * Returns an array containing all of the elements in this list\n+     * in proper sequence (from first to last element).\n+     *\n+     * <p>The returned array will be \"safe\" in that no references to it are\n+     * maintained by this list.  (In other words, this method must allocate\n+     * a new array).  The caller is thus free to modify the returned array.\n+     *\n+     * <p>This method acts as bridge between array-based and collection-based\n+     * APIs.\n+     *\n+     * @return an array containing all of the elements in this list in\n+     *         proper sequence\n+     *\/\n+    public int[] toArray() {\n+        return Arrays.copyOf(elementData, size);\n+    }\n+\n+    \/\/ Positional Access Operations\n+\n+    @SuppressWarnings(\"unchecked\")\n+    int elementData(int index) {\n+        return (int) elementData[index];\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static int elementAt(int[] es, int index) {\n+        return es[index];\n+    }\n+\n+    \/**\n+     * Returns the element at the specified position in this list.\n+     *\n+     * @param  index index of the element to return\n+     * @return the element at the specified position in this list\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    public int get(int index) {\n+        Objects.checkIndex(index, size);\n+        return elementData(index);\n+    }\n+\n+    \/**\n+     * Replaces the element at the specified position in this list with\n+     * the specified element.\n+     *\n+     * @param index index of the element to replace\n+     * @param element element to be stored at the specified position\n+     * @return the element previously at the specified position\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    public int set(int index, int element) {\n+        Objects.checkIndex(index, size);\n+        int oldValue = elementData(index);\n+        elementData[index] = element;\n+        return oldValue;\n+    }\n+\n+    \/**\n+     * This helper method split out from add(int) to keep method\n+     * bytecode size under 35 (the -XX:MaxInlineSize default value),\n+     * which helps when add(int) is called in a C1-compiled loop.\n+     *\/\n+    private void add(int e, int[] elementData, int s) {\n+        if (s == elementData.length)\n+            elementData = grow();\n+        elementData[s] = e;\n+        size = s + 1;\n+    }\n+\n+    \/**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param e element to be appended to this list\n+     * @return {@code true} (as specified by {@link Collection#add})\n+     *\/\n+    public boolean add(int e) {\n+        modCount++;\n+        add(e, elementData, size);\n+        return true;\n+    }\n+\n+    \/**\n+     * Inserts the specified element at the specified position in this\n+     * list. Shifts the element currently at that position (if any) and\n+     * any subsequent elements to the right (adds one to their indices).\n+     *\n+     * @param index index at which the specified element is to be inserted\n+     * @param element element to be inserted\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    public void add(int index, int element) {\n+        rangeCheckForAdd(index);\n+        modCount++;\n+        final int s;\n+        int[] elementData;\n+        if ((s = size) == (elementData = this.elementData).length)\n+            elementData = grow();\n+        System.arraycopy(elementData, index,\n+                         elementData, index + 1,\n+                         s - index);\n+        elementData[index] = element;\n+        size = s + 1;\n+    }\n+\n+    \/**\n+     * Removes the element at the specified position in this list.\n+     * Shifts any subsequent elements to the left (subtracts one from their\n+     * indices).\n+     *\n+     * @param index the index of the element to be removed\n+     * @return the element that was removed from the list\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    public int remove(int index) {\n+        Objects.checkIndex(index, size);\n+        final int[] es = elementData;\n+\n+        int oldValue = (int) es[index];\n+        fastRemove(es, index);\n+\n+        return oldValue;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public boolean equals(Object o) {\n+        if (o == this) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof ArrayListInt)) {\n+            return false;\n+        }\n+\n+        final int expectedModCount = modCount;\n+        \/\/ ArrayList can be subclassed and given arbitrary behavior, but we can\n+        \/\/ still deal with the common case where o is ArrayList precisely\n+        boolean equal = equalsArrayList((ArrayListInt) o);\n+\n+        checkForComodification(expectedModCount);\n+        return equal;\n+    }\n+\n+    private boolean equalsArrayList(ArrayListInt other) {\n+        final int otherModCount = other.modCount;\n+        final int s = size;\n+        boolean equal;\n+        if (equal = (s == other.size)) {\n+            final int[] otherEs = other.elementData;\n+            final int[] es = elementData;\n+            if (s > es.length || s > otherEs.length) {\n+                throw new ConcurrentModificationException();\n+            }\n+            for (int i = 0; i < s; i++) {\n+                if (es[i] != otherEs[i]) {\n+                    equal = false;\n+                    break;\n+                }\n+            }\n+        }\n+        other.checkForComodification(otherModCount);\n+        return equal;\n+    }\n+\n+    private void checkForComodification(final int expectedModCount) {\n+        if (modCount != expectedModCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public int hashCode() {\n+        int expectedModCount = modCount;\n+        int hash = hashCodeRange(0, size);\n+        checkForComodification(expectedModCount);\n+        return hash;\n+    }\n+\n+    int hashCodeRange(int from, int to) {\n+        final int[] es = elementData;\n+        if (to > es.length) {\n+            throw new ConcurrentModificationException();\n+        }\n+        int hashCode = 1;\n+        for (int i = from; i < to; i++) {\n+            int e = es[i];\n+            hashCode = 31 * hashCode + e;\n+        }\n+        return hashCode;\n+    }\n+\n+    \/**\n+     * Removes the first occurrence of the specified element from this list,\n+     * if it is present.  If the list does not contain the element, it is\n+     * unchanged.  More formally, removes the element with the lowest index\n+     * {@code i} such that\n+     * {@code Objects.equals(o, get(i))}\n+     * (if such an element exists).  Returns {@code true} if this list\n+     * contained the specified element (or equivalently, if this list\n+     * changed as a result of the call).\n+     *\n+     * @param o element to be removed from this list, if present\n+     * @return {@code true} if this list contained the specified element\n+     *\/\n+    public boolean removeC(int o) {\n+        final int[] es = elementData;\n+        final int size = this.size;\n+        int i = 0;\n+        found:\n+        {\n+\/\/            if (o == null) {\n+\/\/                for (; i < size; i++)\n+\/\/                    if (es[i] == null)\n+\/\/                        break found;\n+\/\/            } else\n+                {\n+                for (; i < size; i++)\n+                    if (o == es[i])\n+                        break found;\n+            }\n+            return false;\n+        }\n+        fastRemove(es, i);\n+        return true;\n+    }\n+\n+    \/**\n+     * Private remove method that skips bounds checking and does not\n+     * return the value removed.\n+     *\/\n+    private void fastRemove(int[] es, int i) {\n+        modCount++;\n+        final int newSize;\n+        if ((newSize = size - 1) > i)\n+            System.arraycopy(es, i + 1, es, i, newSize - i);\n+        es[size = newSize] = 0;\n+    }\n+\n+    \/**\n+     * Removes all of the elements from this list.  The list will\n+     * be empty after this call returns.\n+     *\/\n+    public void clear() {\n+        modCount++;\n+        final int[] es = elementData;\n+        for (int to = size, i = size = 0; i < to; i++)\n+            es[i] = 0;\n+    }\n+\n+    \/**\n+     * Removes from this list all of the elements whose index is between\n+     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\n+     * Shifts any succeeding elements to the left (reduces their index).\n+     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\n+     * (If {@code toIndex==fromIndex}, this operation has no effect.)\n+     *\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} or\n+     *         {@code toIndex} is out of range\n+     *         ({@code fromIndex < 0 ||\n+     *          toIndex > size() ||\n+     *          toIndex < fromIndex})\n+     *\/\n+    protected void removeRange(int fromIndex, int toIndex) {\n+        if (fromIndex > toIndex) {\n+            throw new IndexOutOfBoundsException(\n+                    outOfBoundsMsg(fromIndex, toIndex));\n+        }\n+        modCount++;\n+        shiftTailOverGap(elementData, fromIndex, toIndex);\n+    }\n+\n+    \/** Erases the gap from lo to hi, by sliding down following elements. *\/\n+    private void shiftTailOverGap(int[] es, int lo, int hi) {\n+        System.arraycopy(es, hi, es, lo, size - hi);\n+        for (int to = size, i = (size -= hi - lo); i < to; i++)\n+            es[i] = 0;\n+    }\n+\n+    \/**\n+     * A version of rangeCheck used by add and addAll.\n+     *\/\n+    private void rangeCheckForAdd(int index) {\n+        if (index > size || index < 0)\n+            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n+    }\n+\n+    \/**\n+     * Constructs an IndexOutOfBoundsException detail message.\n+     * Of the many possible refactorings of the error handling code,\n+     * this \"outlining\" performs best with both server and client VMs.\n+     *\/\n+    private String outOfBoundsMsg(int index) {\n+        return \"Index: \"+index+\", Size: \"+size;\n+    }\n+\n+    \/**\n+     * A version used in checking (fromIndex > toIndex) condition\n+     *\/\n+    private static String outOfBoundsMsg(int fromIndex, int toIndex) {\n+        return \"From Index: \" + fromIndex + \" > To Index: \" + toIndex;\n+    }\n+\n+    \/**\n+     * Returns an iterator over the elements in this list in proper sequence.\n+     *\n+     * <p>The returned iterator is <a href=\"#fail-fast\"><i>fail-fast<\/i><\/a>.\n+     *\n+     * @return an iterator over the elements in this list in proper sequence\n+     *\/\n+    public IntItr iterator() {\n+        return new IntItr();\n+    }\n+\n+    \/**\n+     * An optimized version of AbstractList.Itr\n+     *\/\n+    private class IntItr {\n+        int cursor;       \/\/ index of next element to return\n+        int lastRet = -1; \/\/ index of last element returned; -1 if no such\n+        int expectedModCount = modCount;\n+\n+        \/\/ prevent creating a synthetic constructor\n+        IntItr() {}\n+\n+        public boolean hasNext() {\n+            return cursor != size;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public int next() {\n+            checkForComodification();\n+            int i = cursor;\n+            if (i >= size)\n+                throw new NoSuchElementException();\n+            int[] elementData = ArrayListInt.this.elementData;\n+            if (i >= elementData.length)\n+                throw new ConcurrentModificationException();\n+            cursor = i + 1;\n+            return (int) elementData[lastRet = i];\n+        }\n+\n+        public void remove() {\n+            if (lastRet < 0)\n+                throw new IllegalStateException();\n+            checkForComodification();\n+\n+            try {\n+                ArrayListInt.this.remove(lastRet);\n+                cursor = lastRet;\n+                lastRet = -1;\n+                expectedModCount = modCount;\n+            } catch (IndexOutOfBoundsException ex) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        public void forEachRemaining(IntConsumer action) {\n+            Objects.requireNonNull(action);\n+            final int size = ArrayListInt.this.size;\n+            int i = cursor;\n+            if (i < size) {\n+                final int[] es = elementData;\n+                if (i >= es.length)\n+                    throw new ConcurrentModificationException();\n+                for (; i < size && modCount == expectedModCount; i++)\n+                    action.accept(elementAt(es, i));\n+                \/\/ update once at end to reduce heap write traffic\n+                cursor = i;\n+                lastRet = i - 1;\n+                checkForComodification();\n+            }\n+        }\n+\n+        final void checkForComodification() {\n+            if (modCount != expectedModCount)\n+                throw new ConcurrentModificationException();\n+        }\n+    }\n+\n+    static final int MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n+\n+    static int newLength(int oldLength, int minGrowth, int prefGrowth) {\n+        \/\/ assert oldLength >= 0\n+        \/\/ assert minGrowth > 0\n+\n+        int newLength = Math.max(minGrowth, prefGrowth) + oldLength;\n+        if (newLength - MAX_ARRAY_LENGTH <= 0) {\n+            return newLength;\n+        }\n+        return hugeLength(oldLength, minGrowth);\n+    }\n+\n+    private static int hugeLength(int oldLength, int minGrowth) {\n+        int minLength = oldLength + minGrowth;\n+        if (minLength < 0) { \/\/ overflow\n+            throw new OutOfMemoryError(\"Required array length too large\");\n+        }\n+        if (minLength <= MAX_ARRAY_LENGTH) {\n+            return MAX_ARRAY_LENGTH;\n+        }\n+        return Integer.MAX_VALUE;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/ArrayListInt.java","additions":640,"deletions":0,"binary":false,"changes":640,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.valhalla.sandbox.corelibs;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.TearDown;\n+\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Measure performance of List of Integer operations.\n+ * - Set all of int from a set of random numbers (with a seed)\n+ * - Get all\n+ * - Shuffle the array\n+ * - Sort the array\n+ *\/\n+\n+\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Warmup(iterations = 5, time = 2)\n+@Measurement(iterations = 5, time = 3)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class ArrayListOfIntBench {\n+\n+    @Param({\n+            \"100\",\n+            \"1000000\",\n+    })\n+    public int size;\n+\n+    ArrayListInt arrayListInt;\n+    ArrayListPrimitiveInt arrayListPrimitiveInt;\n+    ArrayList<Integer> arrayListOfInteger;\n+    ArrayList<PrimitiveInt.ref> arrayListOfPrimitiveInt;\n+    Random random;\n+\n+    @Setup\n+    public void setup() {\n+        arrayListInt = new ArrayListInt(size);\n+        for (int i = 0; i < size; i++) {\n+            arrayListInt.add(i, i);\n+        }\n+\n+        arrayListPrimitiveInt = new ArrayListPrimitiveInt(size);\n+        for (int i = 0; i < size; i++) {\n+            arrayListPrimitiveInt.add(i, new PrimitiveInt(i));\n+        }\n+\n+        arrayListOfInteger = new ArrayList<>(size);\n+        for (int i = 0; i < size; i++) {\n+            arrayListOfInteger.add(i, i);\n+        }\n+\n+        arrayListOfPrimitiveInt = new ArrayList<PrimitiveInt.ref>(size);\n+        for (int i = 0; i < size; i++) {\n+            arrayListOfPrimitiveInt.add(i, new PrimitiveInt(i));\n+        }\n+\n+        random = new Random(42);\n+    }\n+\n+    @Benchmark\n+    public Object appendListInt() {\n+        ArrayListInt list = new ArrayListInt(size);\n+        for (int i = 0; i < size; i++) {\n+            list.add(i);\n+        }\n+        return list;\n+    }\n+\n+    @Benchmark\n+    public Object appendListPrimitiveInt() {\n+        ArrayListPrimitiveInt list = new ArrayListPrimitiveInt(size);\n+        for (int i = 0; i < size; i++) {\n+            list.add(new PrimitiveInt(i));\n+        }\n+        return list;\n+    }\n+\n+    @Benchmark\n+    public Object appendListOfInteger() {\n+        ArrayList<Integer> list = new ArrayList<>(size);\n+        for (int i = 0; i < size; i++) {\n+            list.add(i);\n+        }\n+        return list;\n+    }\n+\n+    @Benchmark\n+    public Object appendListOfPrimitiveInt() {\n+        ArrayList<PrimitiveInt.ref> list = new ArrayList<>(size);\n+        for (int i = 0; i < size; i++) {\n+            list.add(new PrimitiveInt(i));\n+        }\n+        return list;\n+    }\n+\n+\n+    @Benchmark\n+    public int sumListInt() {\n+        int sum = 0;\n+        for (int i = 0; i < size; i++) {\n+            sum += arrayListInt.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int sumListOfInteger() {\n+        int sum = 0;\n+        for (int i = 0; i < size; i++) {\n+            sum += arrayListOfInteger.get(i);\n+        }\n+        return sum;\n+    }\n+\n+\n+    @Benchmark\n+    public int sumListPrimitiveInt() {\n+        int sum = 0;\n+        for (int i = 0; i < size; i++) {\n+            sum += arrayListPrimitiveInt.get(i).value();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int sumListOfPrimitiveInt() {\n+        int sum = 0;\n+        for (int i = 0; i < size; i++) {\n+            sum += arrayListOfPrimitiveInt.get(i).value();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int thrashListInt() {\n+        final ArrayListInt list = arrayListInt;\n+\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            int ndx = (random.nextInt() & 0x7fffffff) % list.size();    \/\/ positive\n+            if (list.size() == size) {\n+                list.remove(ndx);\n+            } else {\n+                list.add(ndx);\n+            }\n+            sum += ndx;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int thrashListPrimitiveInt() {\n+        final ArrayListPrimitiveInt list = arrayListPrimitiveInt;\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            int ndx = (random.nextInt() & 0x7fffffff) % list.size();    \/\/ positive\n+            if (list.size() == size) {\n+                list.remove(ndx);\n+            } else {\n+                list.add(ndx, new PrimitiveInt(ndx));\n+            }\n+            sum += ndx;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int thrashListOfInteger() {\n+        final ArrayList<Integer> list = arrayListOfInteger;\n+        int sum = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            int ndx = (random.nextInt() & 0x7fffffff) % list.size();    \/\/ positive\n+            if (list.size() == size) {\n+                list.remove(ndx);\n+            } else {\n+                list.add(ndx);\n+            }\n+            sum += ndx;\n+        }\n+        return sum;\n+    }\n+\n+\n+    @Benchmark\n+    public int thrashListOfPrimitiveInt() {\n+        final ArrayList<PrimitiveInt.ref> list = arrayListOfPrimitiveInt;\n+        int sum = 0;\n+\n+        for (int i = 0; i < 1000; i++) {\n+            int ndx = (random.nextInt() & 0x7fffffff) % list.size();    \/\/ positive\n+            if (list.size() == size) {\n+                list.remove(ndx);\n+            } else {\n+                list.add(ndx, new PrimitiveInt(ndx));\n+            }\n+            sum += ndx;\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/ArrayListOfIntBench.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,678 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.valhalla.sandbox.corelibs;\n+\n+import java.util.Arrays;\n+import java.util.ConcurrentModificationException;\n+import java.util.Objects;\n+import java.util.NoSuchElementException;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+\n+\/**\n+ * Resizable-array implementation like {@code ArrayList<PrimitiveInt>}.\n+ *\/\n+public class ArrayListPrimitiveInt\n+\/\/        extends AbstractList<E>\n+\/\/        implements List<int>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    @java.io.Serial\n+    private static final long serialVersionUID = 8683452581122892189L;\n+\n+    \/**\n+     * Default initial capacity.\n+     *\/\n+    private static final int DEFAULT_CAPACITY = 10;\n+\n+    \/**\n+     * Shared empty array instance used for empty instances.\n+     *\/\n+    private static final PrimitiveInt[] EMPTY_ELEMENTDATA = {};\n+\n+    \/**\n+     * Shared empty array instance used for default sized empty instances. We\n+     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n+     * first element is added.\n+     *\/\n+    private static final PrimitiveInt[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = new PrimitiveInt[0];\n+\n+    \/**\n+     * The array buffer into which the elements of the ArrayList are stored.\n+     * The capacity of the ArrayList is the length of this array buffer. Any\n+     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n+     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n+     *\/\n+    transient PrimitiveInt[] elementData; \/\/ non-private to simplify nested class access\n+\n+    protected transient int modCount = 0;\n+\n+    \/**\n+     * The size of the ArrayList (the number of elements it contains).\n+     *\n+     * @serial\n+     *\/\n+    private int size;\n+\n+    \/**\n+     * Constructs an empty list with the specified initial capacity.\n+     *\n+     * @param  initialCapacity  the initial capacity of the list\n+     * @throws IllegalArgumentException if the specified initial capacity\n+     *         is negative\n+     *\/\n+    public ArrayListPrimitiveInt(int initialCapacity) {\n+        if (initialCapacity > 0) {\n+            this.elementData = new PrimitiveInt[initialCapacity];\n+        } else if (initialCapacity == 0) {\n+            this.elementData = EMPTY_ELEMENTDATA;\n+        } else {\n+            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n+                    initialCapacity);\n+        }\n+    }\n+\n+    \/**\n+     * Constructs an empty list with an initial capacity of ten.\n+     *\/\n+    public ArrayListPrimitiveInt() {\n+        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n+    }\n+\n+    \/**\n+     * Trims the capacity of this {@code ArrayList} instance to be the\n+     * list's current size.  An application can use this operation to minimize\n+     * the storage of an {@code ArrayList} instance.\n+     *\/\n+    public void trimToSize() {\n+        modCount++;\n+        if (size < elementData.length) {\n+            elementData = (size == 0)\n+                    ? EMPTY_ELEMENTDATA\n+                    : (PrimitiveInt[])Arrays.copyOf(elementData, size);\n+        }\n+    }\n+\n+    \/**\n+     * Increases the capacity of this {@code ArrayList} instance, if\n+     * necessary, to ensure that it can hold at least the number of elements\n+     * specified by the minimum capacity argument.\n+     *\n+     * @param minCapacity the desired minimum capacity\n+     *\/\n+    public void ensureCapacity(int minCapacity) {\n+        if (minCapacity > elementData.length\n+                && !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n+                && minCapacity <= DEFAULT_CAPACITY)) {\n+            modCount++;\n+            grow(minCapacity);\n+        }\n+    }\n+\n+    \/**\n+     * Increases the capacity to ensure that it can hold at least the\n+     * number of elements specified by the minimum capacity argument.\n+     *\n+     * @param minCapacity the desired minimum capacity\n+     * @throws OutOfMemoryError if minCapacity is less than zero\n+     *\/\n+    private PrimitiveInt[] grow(int minCapacity) {\n+        int oldCapacity = elementData.length;\n+        if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n+            int newCapacity = newLength(oldCapacity,\n+                    minCapacity - oldCapacity, \/* minimum growth *\/\n+                    oldCapacity >> 1           \/* preferred growth *\/);\n+            return elementData = (PrimitiveInt[])Arrays.copyOf(elementData, newCapacity);\n+        } else {\n+            return elementData = new PrimitiveInt[Math.max(DEFAULT_CAPACITY, minCapacity)];\n+        }\n+    }\n+\n+    private PrimitiveInt[] grow() {\n+        return grow(size + 1);\n+    }\n+\n+    \/**\n+     * Returns the number of elements in this list.\n+     *\n+     * @return the number of elements in this list\n+     *\/\n+    public int size() {\n+        return size;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this list contains no elements.\n+     *\n+     * @return {@code true} if this list contains no elements\n+     *\/\n+    public boolean isEmpty() {\n+        return size == 0;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this list contains the specified element.\n+     * More formally, returns {@code true} if and only if this list contains\n+     * at least one element {@code e} such that\n+     * {@code Objects.equals(o, e)}.\n+     *\n+     * @param o element whose presence in this list is to be tested\n+     * @return {@code true} if this list contains the specified element\n+     *\/\n+    public boolean contains(PrimitiveInt o) {\n+        return indexOf(o) >= 0;\n+    }\n+\n+    \/**\n+     * Returns the index of the first occurrence of the specified element\n+     * in this list, or -1 if this list does not contain the element.\n+     * More formally, returns the lowest index {@code i} such that\n+     * {@code Objects.equals(o, get(i))},\n+     * or -1 if there is no such index.\n+     *\/\n+    public int indexOf(PrimitiveInt o) {\n+        return indexOfRange(o, 0, size);\n+    }\n+\n+    int indexOfRange(PrimitiveInt o, int start, int end) {\n+        PrimitiveInt[] es = elementData;\n+        {\n+            for (int i = start; i < end; i++) {\n+                if (o == es[i]) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/**\n+     * Returns the index of the last occurrence of the specified element\n+     * in this list, or -1 if this list does not contain the element.\n+     * More formally, returns the highest index {@code i} such that\n+     * {@code Objects.equals(o, get(i))},\n+     * or -1 if there is no such index.\n+     *\/\n+    public int lastIndexOf(PrimitiveInt o) {\n+        return lastIndexOfRange(o, 0, size);\n+    }\n+\n+    int lastIndexOfRange(PrimitiveInt o, int start, int end) {\n+        PrimitiveInt[] es = elementData;\n+        {\n+            for (int i = end - 1; i >= start; i--) {\n+                if (o == es[i]) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/**\n+     * Returns an array containing all of the elements in this list\n+     * in proper sequence (from first to last element).\n+     *\n+     * <p>The returned array will be \"safe\" in that no references to it are\n+     * maintained by this list.  (In other words, this method must allocate\n+     * a new array).  The caller is thus free to modify the returned array.\n+     *\n+     * <p>This method acts as bridge between array-based and collection-based\n+     * APIs.\n+     *\n+     * @return an array containing all of the elements in this list in\n+     *         proper sequence\n+     *\/\n+    public PrimitiveInt[] toArray() {\n+        return (PrimitiveInt[])Arrays.copyOf(elementData, size);\n+    }\n+\n+    \/**\n+     * Returns an array containing all of the elements in this list in proper\n+     * sequence (from first to last element); the runtime type of the returned\n+     * array is that of the specified array.  If the list fits in the\n+     * specified array, it is returned therein.  Otherwise, a new array is\n+     * allocated with the runtime type of the specified array and the size of\n+     * this list.\n+     *\n+     * <p>If the list fits in the specified array with room to spare\n+     * (i.e., the array has more elements than the list), the element in\n+     * the array immediately following the end of the collection is set to\n+     * {@code null}.  (This is useful in determining the length of the\n+     * list <i>only<\/i> if the caller knows that the list does not contain\n+     * any null elements.)\n+     *\n+     * @param a the array into which the elements of the list are to\n+     *          be stored, if it is big enough; otherwise, a new array of the\n+     *          same runtime type is allocated for this purpose.\n+     * @return an array containing the elements of the list\n+     * @throws ArrayStoreException if the runtime type of the specified array\n+     *         is not a supertype of the runtime type of every element in\n+     *         this list\n+     * @throws NullPointerException if the specified array is null\n+     *\/\n+\/\/    @SuppressWarnings(\"unchecked\")\n+\/\/    public <T> T[] toArray(T[] a) {\n+\/\/        if (a.length < size)\n+\/\/            \/\/ Make a new array of a's runtime type, but my contents:\n+\/\/            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n+\/\/        System.arraycopy(elementData, 0, a, 0, size);\n+\/\/        if (a.length > size)\n+\/\/            a[size] = null;\n+\/\/        return a;\n+\/\/    }\n+\n+    \/\/ Positional Access Operations\n+\n+    @SuppressWarnings(\"unchecked\")\n+    PrimitiveInt elementData(int index) {\n+        return (PrimitiveInt) elementData[index];\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static PrimitiveInt elementAt(PrimitiveInt[] es, int index) {\n+        return es[index];\n+    }\n+\n+    \/**\n+     * Returns the element at the specified position in this list.\n+     *\n+     * @param  index index of the element to return\n+     * @return the element at the specified position in this list\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    public PrimitiveInt get(int index) {\n+        Objects.checkIndex(index, size);\n+        return elementData(index);\n+    }\n+\n+    \/**\n+     * Replaces the element at the specified position in this list with\n+     * the specified element.\n+     *\n+     * @param index index of the element to replace\n+     * @param element element to be stored at the specified position\n+     * @return the element previously at the specified position\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    public PrimitiveInt set(int index, PrimitiveInt element) {\n+        Objects.checkIndex(index, size);\n+        PrimitiveInt oldValue = elementData(index);\n+        elementData[index] = element;\n+        return oldValue;\n+    }\n+\n+    \/**\n+     * This helper method split out from add(int) to keep method\n+     * bytecode size under 35 (the -XX:MaxInlineSize default value),\n+     * which helps when add(int) is called in a C1-compiled loop.\n+     *\/\n+    private void add(PrimitiveInt e, PrimitiveInt[] elementData, int s) {\n+        if (s == elementData.length)\n+            elementData = grow();\n+        elementData[s] = e;\n+        size = s + 1;\n+    }\n+\n+    \/**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param e element to be appended to this list\n+     * @return {@code true} (as specified by {@link Collection#add})\n+     *\/\n+    public boolean add(PrimitiveInt e) {\n+        modCount++;\n+        add(e, elementData, size);\n+        return true;\n+    }\n+\n+    \/**\n+     * Inserts the specified element at the specified position in this\n+     * list. Shifts the element currently at that position (if any) and\n+     * any subsequent elements to the right (adds one to their indices).\n+     *\n+     * @param index index at which the specified element is to be inserted\n+     * @param element element to be inserted\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    public void add(int index, PrimitiveInt element) {\n+        rangeCheckForAdd(index);\n+        modCount++;\n+        final int s;\n+        PrimitiveInt[] elementData;\n+        if ((s = size) == (elementData = this.elementData).length)\n+            elementData = grow();\n+        System.arraycopy(elementData, index,\n+                elementData, index + 1,\n+                s - index);\n+        elementData[index] = element;\n+        size = s + 1;\n+    }\n+\n+    \/**\n+     * Removes the element at the specified position in this list.\n+     * Shifts any subsequent elements to the left (subtracts one from their\n+     * indices).\n+     *\n+     * @param index the index of the element to be removed\n+     * @return the element that was removed from the list\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     *\/\n+    public PrimitiveInt remove(int index) {\n+        Objects.checkIndex(index, size);\n+        final PrimitiveInt[] es = elementData;\n+\n+        PrimitiveInt oldValue = (PrimitiveInt) es[index];\n+        fastRemove(es, index);\n+\n+        return oldValue;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public boolean equals(Object o) {\n+        if (o == this) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof ArrayListPrimitiveInt)) {\n+            return false;\n+        }\n+\n+        final int expectedModCount = modCount;\n+        \/\/ ArrayList can be subclassed and given arbitrary behavior, but we can\n+        \/\/ still deal with the common case where o is ArrayList precisely\n+        boolean equal = equalsArrayList((ArrayListPrimitiveInt) o);\n+\n+        checkForComodification(expectedModCount);\n+        return equal;\n+    }\n+\n+    private boolean equalsArrayList(ArrayListPrimitiveInt other) {\n+        final int otherModCount = other.modCount;\n+        final int s = size;\n+        boolean equal;\n+        if (equal = (s == other.size)) {\n+            final PrimitiveInt[] otherEs = other.elementData;\n+            final PrimitiveInt[] es = elementData;\n+            if (s > es.length || s > otherEs.length) {\n+                throw new ConcurrentModificationException();\n+            }\n+            for (int i = 0; i < s; i++) {\n+                if (es[i] != otherEs[i]) {\n+                    equal = false;\n+                    break;\n+                }\n+            }\n+        }\n+        other.checkForComodification(otherModCount);\n+        return equal;\n+    }\n+\n+    private void checkForComodification(final int expectedModCount) {\n+        if (modCount != expectedModCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    public int hashCode() {\n+        int expectedModCount = modCount;\n+        int hash = hashCodeRange(0, size);\n+        checkForComodification(expectedModCount);\n+        return hash;\n+    }\n+\n+    int hashCodeRange(int from, int to) {\n+        final PrimitiveInt[] es = elementData;\n+        if (to > es.length) {\n+            throw new ConcurrentModificationException();\n+        }\n+        int hashCode = 1;\n+        for (int i = from; i < to; i++) {\n+            PrimitiveInt e = es[i];\n+            hashCode = 31 * hashCode + e.hashCode();\n+        }\n+        return hashCode;\n+    }\n+\n+    \/**\n+     * Removes the first occurrence of the specified element from this list,\n+     * if it is present.  If the list does not contain the element, it is\n+     * unchanged.  More formally, removes the element with the lowest index\n+     * {@code i} such that\n+     * {@code Objects.equals(o, get(i))}\n+     * (if such an element exists).  Returns {@code true} if this list\n+     * contained the specified element (or equivalently, if this list\n+     * changed as a result of the call).\n+     *\n+     * @param o element to be removed from this list, if present\n+     * @return {@code true} if this list contained the specified element\n+     *\/\n+    public boolean removeC(PrimitiveInt o) {\n+        final PrimitiveInt[] es = elementData;\n+        final int size = this.size;\n+        int i = 0;\n+        found:\n+        {\n+\/\/            if (o == null) {\n+\/\/                for (; i < size; i++)\n+\/\/                    if (es[i] == null)\n+\/\/                        break found;\n+\/\/            } else\n+            {\n+                for (; i < size; i++)\n+                    if (o == es[i])\n+                        break found;\n+            }\n+            return false;\n+        }\n+        fastRemove(es, i);\n+        return true;\n+    }\n+\n+    \/**\n+     * Private remove method that skips bounds checking and does not\n+     * return the value removed.\n+     *\/\n+    private void fastRemove(PrimitiveInt[] es, int i) {\n+        modCount++;\n+        final int newSize;\n+        if ((newSize = size - 1) > i)\n+            System.arraycopy(es, i + 1, es, i, newSize - i);\n+        es[size = newSize] = PrimitiveInt.default;\n+    }\n+\n+    \/**\n+     * Removes all of the elements from this list.  The list will\n+     * be empty after this call returns.\n+     *\/\n+    public void clear() {\n+        modCount++;\n+        final PrimitiveInt[] es = elementData;\n+        for (int to = size, i = size = 0; i < to; i++)\n+            es[i] = PrimitiveInt.default;\n+    }\n+\n+    \/**\n+     * Removes from this list all of the elements whose index is between\n+     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\n+     * Shifts any succeeding elements to the left (reduces their index).\n+     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\n+     * (If {@code toIndex==fromIndex}, this operation has no effect.)\n+     *\n+     * @throws IndexOutOfBoundsException if {@code fromIndex} or\n+     *         {@code toIndex} is out of range\n+     *         ({@code fromIndex < 0 ||\n+     *          toIndex > size() ||\n+     *          toIndex < fromIndex})\n+     *\/\n+    protected void removeRange(int fromIndex, int toIndex) {\n+        if (fromIndex > toIndex) {\n+            throw new IndexOutOfBoundsException(\n+                    outOfBoundsMsg(fromIndex, toIndex));\n+        }\n+        modCount++;\n+        shiftTailOverGap(elementData, fromIndex, toIndex);\n+    }\n+\n+    \/** Erases the gap from lo to hi, by sliding down following elements. *\/\n+    private void shiftTailOverGap(PrimitiveInt[] es, int lo, int hi) {\n+        System.arraycopy(es, hi, es, lo, size - hi);\n+        for (int to = size, i = (size -= hi - lo); i < to; i++)\n+            es[i] = PrimitiveInt.default;\n+    }\n+\n+    \/**\n+     * A version of rangeCheck used by add and addAll.\n+     *\/\n+    private void rangeCheckForAdd(int index) {\n+        if (index > size || index < 0)\n+            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n+    }\n+\n+    \/**\n+     * Constructs an IndexOutOfBoundsException detail message.\n+     * Of the many possible refactorings of the error handling code,\n+     * this \"outlining\" performs best with both server and client VMs.\n+     *\/\n+    private String outOfBoundsMsg(int index) {\n+        return \"Index: \"+index+\", Size: \"+size;\n+    }\n+\n+    \/**\n+     * A version used in checking (fromIndex > toIndex) condition\n+     *\/\n+    private static String outOfBoundsMsg(int fromIndex, int toIndex) {\n+        return \"From Index: \" + fromIndex + \" > To Index: \" + toIndex;\n+    }\n+\n+    \/**\n+     * Returns an iterator over the elements in this list in proper sequence.\n+     *\n+     * <p>The returned iterator is <a href=\"#fail-fast\"><i>fail-fast<\/i><\/a>.\n+     *\n+     * @return an iterator over the elements in this list in proper sequence\n+     *\/\n+    public PrimitiveIntItr iterator() {\n+        return new PrimitiveIntItr();\n+    }\n+\n+    \/**\n+     * An optimized version of AbstractList.Itr\n+     *\/\n+    private class PrimitiveIntItr {\n+        int cursor;       \/\/ index of next element to return\n+        int lastRet = -1; \/\/ index of last element returned; -1 if no such\n+        int expectedModCount = modCount;\n+\n+        \/\/ prevent creating a synthetic constructor\n+        PrimitiveIntItr() {}\n+\n+        public boolean hasNext() {\n+            return cursor != size;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public PrimitiveInt next() {\n+            checkForComodification();\n+            int i = cursor;\n+            if (i >= size)\n+                throw new NoSuchElementException();\n+            PrimitiveInt[] elementData = ArrayListPrimitiveInt.this.elementData;\n+            if (i >= elementData.length)\n+                throw new ConcurrentModificationException();\n+            cursor = i + 1;\n+            return (PrimitiveInt) elementData[lastRet = i];\n+        }\n+\n+        public void remove() {\n+            if (lastRet < 0)\n+                throw new IllegalStateException();\n+            checkForComodification();\n+\n+            try {\n+                ArrayListPrimitiveInt.this.remove(lastRet);\n+                cursor = lastRet;\n+                lastRet = -1;\n+                expectedModCount = modCount;\n+            } catch (IndexOutOfBoundsException ex) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        public void forEachRemaining(Consumer<? super PrimitiveInt.ref> action) {\n+            Objects.requireNonNull(action);\n+            final int size = ArrayListPrimitiveInt.this.size;\n+            int i = cursor;\n+            if (i < size) {\n+                final PrimitiveInt[] es = elementData;\n+                if (i >= es.length)\n+                    throw new ConcurrentModificationException();\n+                for (; i < size && modCount == expectedModCount; i++)\n+                    action.accept(elementAt(es, i));\n+                \/\/ update once at end to reduce heap write traffic\n+                cursor = i;\n+                lastRet = i - 1;\n+                checkForComodification();\n+            }\n+        }\n+\n+        final void checkForComodification() {\n+            if (modCount != expectedModCount)\n+                throw new ConcurrentModificationException();\n+        }\n+    }\n+\n+    static final int MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n+\n+    static int newLength(int oldLength, int minGrowth, int prefGrowth) {\n+        \/\/ assert oldLength >= 0\n+        \/\/ assert minGrowth > 0\n+\n+        int newLength = Math.max(minGrowth, prefGrowth) + oldLength;\n+        if (newLength - MAX_ARRAY_LENGTH <= 0) {\n+            return newLength;\n+        }\n+        return hugeLength(oldLength, minGrowth);\n+    }\n+\n+    private static int hugeLength(int oldLength, int minGrowth) {\n+        int minLength = oldLength + minGrowth;\n+        if (minLength < 0) { \/\/ overflow\n+            throw new OutOfMemoryError(\"Required array length too large\");\n+        }\n+        if (minLength <= MAX_ARRAY_LENGTH) {\n+            return MAX_ARRAY_LENGTH;\n+        }\n+        return Integer.MAX_VALUE;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/ArrayListPrimitiveInt.java","additions":678,"deletions":0,"binary":false,"changes":678,"status":"added"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/InlineCursor.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/InlineCursor.java","status":"renamed"},{"patch":"@@ -0,0 +1,17 @@\n+package org.openjdk.bench.valhalla.sandbox.corelibs;\n+\n+public inline class PrimitiveInt {\n+    int value;\n+\n+    PrimitiveInt(int value) {\n+        this.value = value;\n+    }\n+\n+    int value() {\n+        return value;\n+    }\n+\n+    public String toString() {\n+        return Integer.toString(value);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/PrimitiveInt.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/XArrayList.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/XArrayList.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/XArrayListCursorTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/XArrayListCursorTest.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/GetX.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/GetX.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/HashMap.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/HashMap.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/HashMapBench.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/HashMapBench.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/HashMapToArray.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/HashMapToArray.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/MapBase.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/MapBase.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/PutX.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/PutX.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/README.md","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/README.md","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/ReplX.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/ReplX.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/WalkX.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/WalkX.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/XAbstractMap.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/XAbstractMap.java","status":"renamed"},{"patch":"","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/mapprotos\/XHashMap.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/sandbox\/corelibs\/corelibs\/mapprotos\/XHashMap.java","status":"renamed"}]}