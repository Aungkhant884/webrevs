{"files":[{"patch":"@@ -14,1 +14,1 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.md|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,1 @@\n-    common.boot_jdk_version = \"18\";\n+    common.boot_jdk_version = \"19\";\n@@ -1150,1 +1150,1 @@\n-            revision: \"3.0-12-jdk-asm+1.0\",\n+            revision: \"3.0-13-jdk-asm+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"18 19 20\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+    \/\/ Governing predicates for load\/store and arithmetic\n@@ -470,1 +471,1 @@\n-    P7,\n+    \/\/ Extra predicates\n@@ -480,0 +481,3 @@\n+\n+    \/\/ Preserved for all-true predicate\n+    P7,\n@@ -5581,0 +5585,1 @@\n+  match(pReg);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1002,1 +1002,1 @@\n-\/\/ Clobbers: rscratch1 if hardware doesn't support FEAT_BITPERM.\n+\/\/ Clobbers: rscratch1, if UseSVE=1 or the hardware doesn't support FEAT_BITPERM.\n@@ -1020,15 +1020,2 @@\n-  if (UseSVE > 0 && !VM_Version::supports_svebitperm()) {\n-    \/\/ Compress the lowest 8 bytes.\n-    fmovd(dst, vtmp1);\n-    bytemask_compress(dst);\n-    if (lane_cnt <= 8) return;\n-\n-    \/\/ Repeat on higher bytes and join the results.\n-    \/\/ Compress 8 bytes in each iteration.\n-    for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n-      sve_extract_integral(rscratch1, T_LONG, vtmp1, idx, vtmp2);\n-      bytemask_compress(rscratch1);\n-      orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n-    }\n-  } else if (UseSVE == 2 && VM_Version::supports_svebitperm()) {\n-    \/\/ Given by the vector with value 0x00 or 0x01 in each byte, the basic idea\n+  if (UseSVE > 1 && VM_Version::supports_svebitperm()) {\n+    \/\/ Given a vector with the value 0x00 or 0x01 in each byte, the basic idea\n@@ -1036,3 +1023,3 @@\n-    \/\/ to the lack of cross-lane bit-compress instruction, here we use BEXT\n-    \/\/ (bit-compress in each lane) with the biggest lane size (T = D) and\n-    \/\/ concatenates the results then.\n+    \/\/ to the lack of a cross-lane bit-compress instruction, we use BEXT\n+    \/\/ (bit-compress in each lane) with the biggest lane size (T = D) then\n+    \/\/ concatenate the results.\n@@ -1067,0 +1054,13 @@\n+  } else if (UseSVE > 0) {\n+    \/\/ Compress the lowest 8 bytes.\n+    fmovd(dst, vtmp1);\n+    bytemask_compress(dst);\n+    if (lane_cnt <= 8) return;\n+\n+    \/\/ Repeat on higher bytes and join the results.\n+    \/\/ Compress 8 bytes in each iteration.\n+    for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n+      sve_extract_integral(rscratch1, T_LONG, vtmp1, idx, vtmp2);\n+      bytemask_compress(rscratch1);\n+      orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                                  Register start, Register end, Register tmp, RegSet saved_regs) {}\n+                                  Register start, Register count, Register tmp, RegSet saved_regs) {}\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-  load_heap_oop(result, Address(result, index, Address::uxtw(LogBytesPerHeapOop)));\n+  load_heap_oop(result, Address(result, index, Address::uxtw(LogBytesPerHeapOop)), tmp, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2056,18 +2056,0 @@\n-void MacroAssembler::atomic_incw(Register counter_addr, Register tmp, Register tmp2) {\n-  if (UseLSE) {\n-    mov(tmp, 1);\n-    ldadd(Assembler::word, tmp, zr, counter_addr);\n-    return;\n-  }\n-  Label retry_load;\n-  prfm(Address(counter_addr), PSTL1STRM);\n-  bind(retry_load);\n-  \/\/ flush and load exclusive from the memory location\n-  ldxrw(tmp, counter_addr);\n-  addw(tmp, tmp, 1);\n-  \/\/ if we store+flush with no intervening write tmp will be zero\n-  stxrw(tmp2, tmp, counter_addr);\n-  cbnzw(tmp2, retry_load);\n-}\n-\n-\n@@ -2242,1 +2224,1 @@\n-void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {\n+void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed) {\n@@ -2252,1 +2234,1 @@\n-void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {\n+void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes) {\n@@ -2560,1 +2542,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2562,1 +2544,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -2597,1 +2579,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2599,1 +2581,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -3103,1 +3085,1 @@\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_registers; i++) {\n@@ -3112,1 +3094,1 @@\n-    for (int i = PRegister::number_of_saved_registers - 1; i >= 0; i--) {\n+    for (int i = PRegister::number_of_registers - 1; i >= 0; i--) {\n@@ -4590,1 +4572,1 @@\n-                                     Address dst, Register src,\n+                                     Address dst, Register val,\n@@ -4596,1 +4578,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -4598,1 +4580,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -4652,1 +4634,1 @@\n-void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,\n+void MacroAssembler::store_heap_oop(Address dst, Register val, Register tmp1,\n@@ -4654,1 +4636,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, val, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":13,"deletions":31,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -118,7 +118,0 @@\n-  \/\/ Helper functions for statistics gathering.\n-  \/\/ Unconditional atomic increment.\n-  void atomic_incw(Register counter_addr, Register tmp, Register tmp2);\n-  void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {\n-    lea(tmp1, counter_addr);\n-    atomic_incw(tmp1, tmp2, tmp3);\n-  }\n@@ -696,2 +689,2 @@\n-  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);\n-  void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);\n+  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed);\n+  void store_sized_value(Address dst, Register src, size_t size_in_bytes);\n@@ -891,1 +884,1 @@\n-  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -903,2 +896,2 @@\n-  void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,\n-                     Register tmp2 = noreg, DecoratorSet decorators = 0);\n+  void load_heap_oop(Register dst, Address src, Register tmp1,\n+                     Register tmp2, DecoratorSet decorators = 0);\n@@ -906,4 +899,4 @@\n-  void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,\n-                              Register tmp2 = noreg, DecoratorSet decorators = 0);\n-  void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,\n-                      Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);\n+  void load_heap_oop_not_null(Register dst, Address src, Register tmp1,\n+                              Register tmp2, DecoratorSet decorators = 0);\n+  void store_heap_oop(Address dst, Register val, Register tmp1,\n+                      Register tmp2, Register tmp3, DecoratorSet decorators = 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset())), temp2, rscratch2);\n@@ -145,1 +145,1 @@\n-  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())), temp2, rscratch2);\n@@ -147,1 +147,1 @@\n-  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset())), temp2, rscratch2);\n@@ -344,1 +344,1 @@\n-        __ load_heap_oop(temp2_defc, member_clazz, temp3);\n+        __ load_heap_oop(temp2_defc, member_clazz, temp3, rscratch2);\n@@ -372,1 +372,1 @@\n-      __ load_heap_oop(rmethod, member_vmtarget);\n+      __ load_heap_oop(rmethod, member_vmtarget, temp3, rscratch2);\n@@ -380,1 +380,1 @@\n-      __ load_heap_oop(rmethod, member_vmtarget);\n+      __ load_heap_oop(rmethod, member_vmtarget, temp3, rscratch2);\n@@ -422,1 +422,1 @@\n-      __ load_heap_oop(temp3_intf, member_clazz);\n+      __ load_heap_oop(temp3_intf, member_clazz, temp2, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -165,5 +165,2 @@\n-    \/\/ The number of total predicate bytes is unlikely to be a multiple\n-    \/\/ of 16 bytes so we manually align it up.\n-    return align_up(Matcher::scalable_predicate_reg_slots() *\n-                    VMRegImpl::stack_slot_size *\n-                    PRegister::number_of_saved_registers, 16);\n+    return (Matcher::scalable_vector_reg_size(T_BYTE) >> LogBitsPerByte) *\n+           PRegister::number_of_registers;\n@@ -255,8 +252,0 @@\n-  if (_save_vectors && use_sve) {\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n-      PRegister r = as_PRegister(i);\n-      int sp_offset = sve_predicate_size_in_slots * i;\n-      oop_map->set_callee_saved(VMRegImpl::stack2reg(sp_offset), r->as_VMReg());\n-    }\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -651,0 +651,1 @@\n+    \/\/ B\n@@ -653,0 +654,15 @@\n+    \/\/ H\n+    __ emit_data64(0x0003000200010000, relocInfo::none);\n+    __ emit_data64(0x0007000600050004, relocInfo::none);\n+    \/\/ S\n+    __ emit_data64(0x0000000100000000, relocInfo::none);\n+    __ emit_data64(0x0000000300000002, relocInfo::none);\n+    \/\/ D\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none);\n+    \/\/ S - FP\n+    __ emit_data64(0x3F80000000000000, relocInfo::none); \/\/ 0.0f, 1.0f\n+    __ emit_data64(0x4040000040000000, relocInfo::none); \/\/ 2.0f, 3.0f\n+    \/\/ D - FP\n+    __ emit_data64(0x0000000000000000, relocInfo::none); \/\/ 0.0d\n+    __ emit_data64(0x3FF0000000000000, relocInfo::none); \/\/ 1.0d\n@@ -8010,1 +8026,3 @@\n-    StubRoutines::aarch64::_vector_iota_indices    = generate_iota_indices(\"iota_indices\");\n+    if (UseSVE == 0) {\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1988,9 +1988,2 @@\n-  Register rscratch3 = r0;\n-  __ push(rscratch1);\n-  __ push(rscratch2);\n-  __ push(rscratch3);\n-  __ mov(rscratch3, (address) &BytecodeCounter::_counter_value);\n-  __ atomic_add(noreg, 1, rscratch3);\n-  __ pop(rscratch3);\n-  __ pop(rscratch2);\n-  __ pop(rscratch1);\n+  __ mov(r10, (address) &BytecodeCounter::_counter_value);\n+  __ atomic_addw(noreg, 1, r10);\n@@ -1999,3 +1992,4 @@\n-void TemplateInterpreterGenerator::histogram_bytecode(Template* t) { ; }\n-\n-void TemplateInterpreterGenerator::histogram_bytecode_pair(Template* t) { ; }\n+void TemplateInterpreterGenerator::histogram_bytecode(Template* t) {\n+  __ mov(r10, (address) &BytecodeHistogram::_counters[t->bytecode()]);\n+  __ atomic_addw(noreg, 1, r10);\n+}\n@@ -2003,0 +1997,21 @@\n+void TemplateInterpreterGenerator::histogram_bytecode_pair(Template* t) {\n+  \/\/ Calculate new index for counter:\n+  \/\/   _index = (_index >> log2_number_of_codes) |\n+  \/\/            (bytecode << log2_number_of_codes);\n+  Register index_addr = rscratch1;\n+  Register index = rscratch2;\n+  __ mov(index_addr, (address) &BytecodePairHistogram::_index);\n+  __ ldrw(index, index_addr);\n+  __ mov(r10,\n+         ((int)t->bytecode()) << BytecodePairHistogram::log2_number_of_codes);\n+  __ orrw(index, r10, index, Assembler::LSR,\n+          BytecodePairHistogram::log2_number_of_codes);\n+  __ strw(index, index_addr);\n+\n+  \/\/ Bump bucket contents:\n+  \/\/   _counters[_index] ++;\n+  Register counter_addr = rscratch1;\n+  __ mov(r10, (address) &BytecodePairHistogram::_counters);\n+  __ lea(counter_addr, Address(r10, index, Address::lsl(LogBytesPerInt)));\n+  __ atomic_addw(noreg, 1, counter_addr);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1723,13 +1723,5 @@\n-void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes) {\n-  ExternalAddress addr(StubRoutines::x86::vector_iota_indices());\n-  if (vlen_in_bytes <= 4) {\n-    movdl(dst, addr);\n-  } else if (vlen_in_bytes == 8) {\n-    movq(dst, addr);\n-  } else if (vlen_in_bytes == 16) {\n-    movdqu(dst, addr, noreg);\n-  } else if (vlen_in_bytes == 32) {\n-    vmovdqu(dst, addr, noreg);\n-  } else {\n-    assert(vlen_in_bytes == 64, \"%d\", vlen_in_bytes);\n-    evmovdqub(dst, k0, addr, false \/*merge*\/, Assembler::AVX_512bit, noreg);\n+void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes, BasicType bt) {\n+  \/\/ The iota indices are ordered by type B\/S\/I\/L\/F\/D, and the offset between two types is 64.\n+  int offset = exact_log2(type2aelembytes(bt)) << 6;\n+  if (is_floating_point_type(bt)) {\n+    offset += 128;\n@@ -1737,0 +1729,2 @@\n+  ExternalAddress addr(StubRoutines::x86::vector_iota_indices() + offset);\n+  load_vector(dst, addr, vlen_in_bytes);\n@@ -1789,1 +1783,1 @@\n-                            vpmullq(dst, dst, src, vector_len); break;\n+                            evpmullq(dst, dst, src, vector_len); break;\n@@ -1837,1 +1831,1 @@\n-    case Op_MulReductionVL: vpmullq(dst, src1, src2, vector_len); break;\n+    case Op_MulReductionVL: evpmullq(dst, src1, src2, vector_len); break;\n@@ -4391,3 +4385,5 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                                            XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                                            Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                   XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                                                   Register rscratch, AddressLiteral float_sign_flip,\n+                                                                   int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4419,4 +4415,5 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                                             XMMRegister xtmp1, XMMRegister xtmp2,\n-                                                             KRegister ktmp1, KRegister ktmp2,\n-                                                             Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                    Register rscratch, AddressLiteral float_sign_flip,\n+                                                                    int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4440,5 +4437,4 @@\n-void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src,\n-                                                                     AddressLiteral double_sign_flip, int vec_enc,\n-                                                                     XMMRegister xtmp1, XMMRegister xtmp2,\n-                                                                     KRegister ktmp1, KRegister ktmp2,\n-                                                                     Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                     XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                     Register rscratch, AddressLiteral double_sign_flip,\n+                                                                     int vec_enc) {\n@@ -4464,0 +4460,22 @@\n+void C2_MacroAssembler::vector_cast_double_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                     XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                     Register rscratch, AddressLiteral float_sign_flip,\n+                                                                     int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+  Label done;\n+  evmovdquq(xtmp1, k0, float_sign_flip, false, vec_enc, rscratch);\n+  Assembler::evpcmpeqd(ktmp1, k0, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmppd(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdqul(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmppd(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdqul(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n@@ -4472,4 +4490,4 @@\n-void C2_MacroAssembler::vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src,\n-                                                              AddressLiteral double_sign_flip, int vec_enc,\n-                                                              XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                              Register rscratch) {\n+void C2_MacroAssembler::vector_cast_double_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                      XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                      Register rscratch, AddressLiteral double_sign_flip,\n+                                                                      int vec_enc) {\n@@ -4495,0 +4513,76 @@\n+void C2_MacroAssembler::vector_crosslane_doubleword_pack_avx(XMMRegister dst, XMMRegister src, XMMRegister zero,\n+                                                             XMMRegister xtmp, int index, int vec_enc) {\n+   assert(vec_enc < Assembler::AVX_512bit, \"\");\n+   if (vec_enc == Assembler::AVX_256bit) {\n+     vextractf128_high(xtmp, src);\n+     vshufps(dst, src, xtmp, index, vec_enc);\n+   } else {\n+     vshufps(dst, src, zero, index, vec_enc);\n+   }\n+}\n+\n+void C2_MacroAssembler::vector_cast_double_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                                    XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5, Register rscratch,\n+                                                                    AddressLiteral float_sign_flip, int src_vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+\n+  Label done;\n+  \/\/ Compare the destination lanes with float_sign_flip\n+  \/\/ value to get mask for all special values.\n+  movdqu(xtmp1, float_sign_flip, rscratch);\n+  vpcmpeqd(xtmp2, dst, xtmp1, Assembler::AVX_128bit);\n+  ptest(xtmp2, xtmp2);\n+  jccb(Assembler::equal, done);\n+\n+  \/\/ Flip float_sign_flip to get max integer value.\n+  vpcmpeqd(xtmp4, xtmp4, xtmp4, Assembler::AVX_128bit);\n+  pxor(xtmp1, xtmp4);\n+\n+  \/\/ Set detination lanes corresponding to unordered source lanes as zero.\n+  vpxor(xtmp4, xtmp4, xtmp4, src_vec_enc);\n+  vcmppd(xtmp3, src, src, Assembler::UNORD_Q, src_vec_enc);\n+\n+  \/\/ Shuffle mask vector and pack lower doubles word from each quadword lane.\n+  vector_crosslane_doubleword_pack_avx(xtmp3, xtmp3, xtmp4, xtmp5, 0x88, src_vec_enc);\n+  vblendvps(dst, dst, xtmp4, xtmp3, Assembler::AVX_128bit);\n+\n+  \/\/ Recompute the mask for remaining special value.\n+  pxor(xtmp2, xtmp3);\n+  \/\/ Extract mask corresponding to non-negative source lanes.\n+  vcmppd(xtmp3, src, xtmp4, Assembler::NLT_UQ, src_vec_enc);\n+\n+  \/\/ Shuffle mask vector and pack lower doubles word from each quadword lane.\n+  vector_crosslane_doubleword_pack_avx(xtmp3, xtmp3, xtmp4, xtmp5, 0x88, src_vec_enc);\n+  pand(xtmp3, xtmp2);\n+\n+  \/\/ Replace destination lanes holding special value(0x80000000) with max int\n+  \/\/ if corresponding source lane holds a +ve value.\n+  vblendvps(dst, dst, xtmp1, xtmp3, Assembler::AVX_128bit);\n+  bind(done);\n+}\n+\n+\n+void C2_MacroAssembler::vector_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n+                                                   XMMRegister xtmp, Register rscratch, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_SHORT:\n+      assert(rscratch != noreg || always_reachable(ExternalAddress(StubRoutines::x86::vector_int_to_short_mask())), \"missing\");\n+      vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_short_mask()), vec_enc, rscratch);\n+      vpackusdw(dst, dst, zero, vec_enc);\n+      if (vec_enc == Assembler::AVX_256bit) {\n+        vector_crosslane_doubleword_pack_avx(dst, dst, zero, xtmp, 0x44, vec_enc);\n+      }\n+      break;\n+    case  T_BYTE:\n+      assert(rscratch != noreg || always_reachable(ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask())), \"missing\");\n+      vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask()), vec_enc, rscratch);\n+      vpackusdw(dst, dst, zero, vec_enc);\n+      if (vec_enc == Assembler::AVX_256bit) {\n+        vector_crosslane_doubleword_pack_avx(dst, dst, zero, xtmp, 0x44, vec_enc);\n+      }\n+      vpackuswb(dst, dst, zero, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n@@ -4505,13 +4599,5 @@\n-void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-\n-  evcvttpd2qq(dst, src, vec_enc);\n-  vector_cast_double_special_cases_evex(dst, src, double_sign_flip, vec_enc,\n-                                        xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-}\n-\n-void C2_MacroAssembler::vector_castF2I_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                           XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                           AddressLiteral float_sign_flip, Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz <= 4, \"\");\n@@ -4519,2 +4605,5 @@\n-  vector_cast_float_special_cases_avx(dst, src, float_sign_flip, vec_enc,\n-                                      xtmp1, xtmp2, xtmp3, xtmp4, rscratch);\n+  vector_cast_float_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, rscratch, float_sign_flip, vec_enc);\n+  if (to_elem_sz < 4) {\n+    vpxor(xtmp4, xtmp4, xtmp4, vec_enc);\n+    vector_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp3, rscratch, vec_enc);\n+  }\n@@ -4523,4 +4612,5 @@\n-void C2_MacroAssembler::vector_castF2I_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                            XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                                            Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz <= 4, \"\");\n@@ -4528,2 +4618,12 @@\n-  vector_cast_float_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                       xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n+  vector_cast_float_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, float_sign_flip, vec_enc);\n+  switch(to_elem_bt) {\n+    case T_INT:\n+      break;\n+    case T_SHORT:\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n@@ -4532,4 +4632,3 @@\n-void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                            Register rscratch, int vec_enc) {\n@@ -4537,11 +4636,25 @@\n-  vector_cast_float_to_long_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                               xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-}\n-\n-void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-\n-  vector_castD2L_evex(dst, src, double_sign_flip, vec_enc,\n-                      xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-  if (to_elem_bt != T_LONG) {\n+  vector_cast_float_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, double_sign_flip, vec_enc);\n+}\n+\n+\/\/ Handling for downcasting from double to integer or sub-word types on AVX2.\n+void C2_MacroAssembler::vector_castD2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                                           AddressLiteral float_sign_flip, Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz < 8, \"\");\n+  vcvttpd2dq(dst, src, vec_enc);\n+  vector_cast_double_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, xtmp5, rscratch,\n+                                              float_sign_flip, vec_enc);\n+  if (to_elem_sz < 4) {\n+    \/\/ xtmp4 holds all zero lanes.\n+    vector_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp5, rscratch, Assembler::AVX_128bit);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src,\n+                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1,\n+                                            KRegister ktmp2, AddressLiteral sign_flip,\n+                                            Register rscratch, int vec_enc) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evcvttpd2qq(dst, src, vec_enc);\n+    vector_cast_double_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, sign_flip, vec_enc);\n@@ -4549,0 +4662,2 @@\n+      case T_LONG:\n+        break;\n@@ -4562,0 +4677,15 @@\n+  } else {\n+    assert(type2aelembytes(to_elem_bt) <= 4, \"\");\n+    vcvttpd2dq(dst, src, vec_enc);\n+    vector_cast_double_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, sign_flip, vec_enc);\n+    switch(to_elem_bt) {\n+      case T_INT:\n+        break;\n+      case T_SHORT:\n+        evpmovdw(dst, dst, vec_enc);\n+        break;\n+      case T_BYTE:\n+        evpmovdb(dst, dst, vec_enc);\n+        break;\n+      default: assert(false, \"%s\", type2name(to_elem_bt));\n+    }\n@@ -4577,2 +4707,2 @@\n-  vector_cast_double_special_cases_evex(dst, src, double_sign_flip, vec_enc,\n-                                        xtmp1, xtmp2, ktmp1, ktmp2, tmp);\n+  vector_cast_double_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n+                                                double_sign_flip, vec_enc);;\n@@ -4595,2 +4725,2 @@\n-  vector_cast_float_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                       xtmp1, xtmp2, ktmp1, ktmp2, tmp);\n+  vector_cast_float_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n+                                              float_sign_flip, vec_enc);\n@@ -4613,2 +4743,1 @@\n-  vector_cast_float_special_cases_avx(dst, src, float_sign_flip, vec_enc,\n-                                      xtmp1, xtmp2, xtmp3, xtmp4, tmp);\n+  vector_cast_float_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, tmp \/*rscratch*\/, float_sign_flip, vec_enc);\n@@ -4647,0 +4776,55 @@\n+void C2_MacroAssembler::vector_mask_cast(XMMRegister dst, XMMRegister src,\n+                                         BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(src_bt), type2aelembytes(dst_bt)) * vlen);\n+  assert(vlen_enc != AVX_512bit, \"\");\n+\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2: vpmovsxbw(dst, src, vlen_enc); break;\n+      case 4: vpmovsxbd(dst, src, vlen_enc); break;\n+      case 8: vpmovsxbq(dst, src, vlen_enc); break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpacksswb(dst, src, src, vlen_enc);\n+        } else {\n+          vpacksswb(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+        }\n+        break;\n+      }\n+      case 4: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      case 8: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, AVX_128bit);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":257,"deletions":73,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  void load_iota_indices(XMMRegister dst, int vlen_in_bytes);\n+  void load_iota_indices(XMMRegister dst, int vlen_in_bytes, BasicType bt);\n@@ -312,2 +312,2 @@\n-  void vector_castF2I_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                          XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, Register rscratch = noreg);\n+  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                            BasicType from_elem_bt, BasicType to_elem_bt);\n@@ -315,2 +315,2 @@\n-  void vector_castF2I_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n+                                  XMMRegister xtmp, Register rscratch, int vec_enc);\n@@ -318,2 +318,3 @@\n-  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_castF2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                          AddressLiteral float_sign_flip, Register rscratch, int vec_enc);\n@@ -321,2 +322,3 @@\n-  void vector_castD2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg );\n+  void vector_castF2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                           XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -324,2 +326,3 @@\n-  void vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -327,1 +330,3 @@\n-  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc, BasicType from_elem_bt, BasicType to_elem_bt);\n+  void vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                           XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -329,2 +334,3 @@\n-  void vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg );\n+  void vector_castD2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                          AddressLiteral float_sign_flip, Register rscratch, int vec_enc);\n@@ -332,5 +338,3 @@\n-  void vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n-  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                                    XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                    Register rscratch = noreg);\n+  void vector_cast_double_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                   XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5, Register rscratch,\n+                                                   AddressLiteral float_sign_flip, int vec_enc);\n@@ -339,3 +343,24 @@\n-  void vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                           XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                           Register rscratch = noreg);\n+  void vector_cast_double_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                    KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n+                                                    int vec_enc);\n+\n+  void vector_cast_double_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                     KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n+                                                     int vec_enc);\n+\n+  void vector_cast_float_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                   KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n+                                                   int vec_enc);\n+\n+  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                    KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n+                                                    int vec_enc);\n+\n+  void vector_cast_float_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                  XMMRegister xtmp4, Register rscratch, AddressLiteral float_sign_flip,\n+                                                  int vec_enc);\n+\n+  void vector_crosslane_doubleword_pack_avx(XMMRegister dst, XMMRegister src, XMMRegister zero,\n+                                            XMMRegister xtmp, int index, int vec_enc);\n+\n+  void vector_mask_cast(XMMRegister dst, XMMRegister src, BasicType dst_bt, BasicType src_bt, int vlen);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":47,"deletions":22,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -5442,1 +5442,1 @@\n-void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -5448,1 +5448,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -5450,1 +5450,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -5505,1 +5505,1 @@\n-void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,\n+void MacroAssembler::store_heap_oop(Address dst, Register val, Register tmp1,\n@@ -5507,1 +5507,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, val, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -407,1 +407,1 @@\n-  void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,\n+  void store_heap_oop(Address dst, Register val, Register tmp1 = noreg,\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -832,1 +832,1 @@\n-\n+  \/\/ B\n@@ -841,1 +841,45 @@\n-\n+  \/\/ W\n+  __ emit_data64(0x0003000200010000, relocInfo::none);\n+  __ emit_data64(0x0007000600050004, relocInfo::none);\n+  __ emit_data64(0x000B000A00090008, relocInfo::none);\n+  __ emit_data64(0x000F000E000D000C, relocInfo::none);\n+  __ emit_data64(0x0013001200110010, relocInfo::none);\n+  __ emit_data64(0x0017001600150014, relocInfo::none);\n+  __ emit_data64(0x001B001A00190018, relocInfo::none);\n+  __ emit_data64(0x001F001E001D001C, relocInfo::none);\n+  \/\/ D\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000300000002, relocInfo::none);\n+  __ emit_data64(0x0000000500000004, relocInfo::none);\n+  __ emit_data64(0x0000000700000006, relocInfo::none);\n+  __ emit_data64(0x0000000900000008, relocInfo::none);\n+  __ emit_data64(0x0000000B0000000A, relocInfo::none);\n+  __ emit_data64(0x0000000D0000000C, relocInfo::none);\n+  __ emit_data64(0x0000000F0000000E, relocInfo::none);\n+  \/\/ Q\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0x0000000000000001, relocInfo::none);\n+  __ emit_data64(0x0000000000000002, relocInfo::none);\n+  __ emit_data64(0x0000000000000003, relocInfo::none);\n+  __ emit_data64(0x0000000000000004, relocInfo::none);\n+  __ emit_data64(0x0000000000000005, relocInfo::none);\n+  __ emit_data64(0x0000000000000006, relocInfo::none);\n+  __ emit_data64(0x0000000000000007, relocInfo::none);\n+  \/\/ D - FP\n+  __ emit_data64(0x3F80000000000000, relocInfo::none); \/\/ 0.0f, 1.0f\n+  __ emit_data64(0x4040000040000000, relocInfo::none); \/\/ 2.0f, 3.0f\n+  __ emit_data64(0x40A0000040800000, relocInfo::none); \/\/ 4.0f, 5.0f\n+  __ emit_data64(0x40E0000040C00000, relocInfo::none); \/\/ 6.0f, 7.0f\n+  __ emit_data64(0x4110000041000000, relocInfo::none); \/\/ 8.0f, 9.0f\n+  __ emit_data64(0x4130000041200000, relocInfo::none); \/\/ 10.0f, 11.0f\n+  __ emit_data64(0x4150000041400000, relocInfo::none); \/\/ 12.0f, 13.0f\n+  __ emit_data64(0x4170000041600000, relocInfo::none); \/\/ 14.0f, 15.0f\n+  \/\/ Q - FP\n+  __ emit_data64(0x0000000000000000, relocInfo::none); \/\/ 0.0d\n+  __ emit_data64(0x3FF0000000000000, relocInfo::none); \/\/ 1.0d\n+  __ emit_data64(0x4000000000000000, relocInfo::none); \/\/ 2.0d\n+  __ emit_data64(0x4008000000000000, relocInfo::none); \/\/ 3.0d\n+  __ emit_data64(0x4010000000000000, relocInfo::none); \/\/ 4.0d\n+  __ emit_data64(0x4014000000000000, relocInfo::none); \/\/ 5.0d\n+  __ emit_data64(0x4018000000000000, relocInfo::none); \/\/ 6.0d\n+  __ emit_data64(0x401c000000000000, relocInfo::none); \/\/ 7.0d\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2886,0 +2886,2 @@\n+    if (_cpuid_info.std_cpuid1_ecx.bits.f16c != 0)\n+      result |= CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1395,0 +1395,2 @@\n+  static address vector_float_signflip() { return StubRoutines::x86::vector_float_sign_flip();}\n+  static address vector_double_signflip() { return StubRoutines::x86::vector_double_sign_flip();}\n@@ -1481,0 +1483,1 @@\n+    case Op_VectorMaskCast:\n@@ -1681,0 +1684,6 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1728,1 +1737,0 @@\n-    case Op_MulVL:\n@@ -1852,0 +1860,1 @@\n+    case Op_VectorMaskCast:\n@@ -1880,8 +1889,6 @@\n-    case Op_VectorCastD2X:\n-      \/\/ Conversion to integral type is only supported on AVX-512 platforms with avx512dq.\n-      \/\/ Need avx512vl for size_in_bits < 512\n-      if (is_integral_type(bt)) {\n-        if (!VM_Version::supports_avx512dq()) {\n-          return false;\n-        }\n-        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+    case Op_VectorCastF2X: {\n+        \/\/ As per JLS section 5.1.3 narrowing conversion to sub-word types\n+        \/\/ happen after intermediate conversion to integer and special handling\n+        \/\/ code needs AVX2 vpcmpeqd instruction for 256 bit vectors.\n+        int src_size_in_bits = type2aelembytes(T_FLOAT) * vlen * BitsPerByte;\n+        if (is_integral_type(bt) && src_size_in_bits == 256 && UseAVX < 2) {\n@@ -1891,0 +1898,5 @@\n+      \/\/ fallthrough\n+    case Op_VectorCastD2X:\n+      if (bt == T_LONG && !VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n@@ -1897,17 +1909,0 @@\n-    case Op_VectorCastF2X:\n-      \/\/ F2I is supported on all AVX and above platforms\n-      \/\/ For conversion to other integral types need AVX512:\n-      \/\/     Conversion to long in addition needs avx512dq\n-      \/\/     Need avx512vl for size_in_bits < 512\n-      if (is_integral_type(bt) && (bt != T_INT)) {\n-        if (UseAVX <= 2) {\n-          return false;\n-        }\n-        if ((bt == T_LONG) && !VM_Version::supports_avx512dq()) {\n-          return false;\n-        }\n-        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n-          return false;\n-        }\n-      }\n-      break;\n@@ -3691,0 +3686,35 @@\n+instruct convF2HF_reg_reg(rRegI dst, regF src, regF tmp) %{\n+  effect(TEMP tmp);\n+  match(Set dst (ConvF2HF src));\n+  ins_cost(125);\n+  format %{ \"vcvtps2ph $dst,$src \\t using $tmp as TEMP\"%}\n+  ins_encode %{\n+    __ vcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+    __ movdl($dst$$Register, $tmp$$XMMRegister);\n+    __ movswl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convF2HF_mem_reg(memory mem, regF src, kReg ktmp, rRegI rtmp) %{\n+  predicate((UseAVX > 2) && VM_Version::supports_avx512vl());\n+  effect(TEMP ktmp, TEMP rtmp);\n+  match(Set mem (StoreC mem (ConvF2HF src)));\n+  format %{ \"evcvtps2ph $mem,$src \\t using $ktmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    __ movl($rtmp$$Register, 0x1);\n+    __ kmovwl($ktmp$$KRegister, $rtmp$$Register);\n+    __ evcvtps2ph($mem$$Address, $ktmp$$KRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convHF2F_reg_reg(regF dst, rRegI src) %{\n+  match(Set dst (ConvHF2F src));\n+  format %{ \"vcvtph2ps $dst,$src\" %}\n+  ins_encode %{\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ vcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -5648,3 +5678,2 @@\n-instruct mulB_reg(vec dst, vec src1, vec src2, vec tmp) %{\n-  predicate(Matcher::vector_length(n) == 4 ||\n-            Matcher::vector_length(n) == 8);\n+instruct vmul8B(vec dst, vec src1, vec src2, vec xtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 8);\n@@ -5652,2 +5681,2 @@\n-  effect(TEMP dst, TEMP tmp);\n-  format %{\"vector_mulB $dst,$src1,$src2\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"mulVB   $dst, $src1, $src2\\t! using $xtmp as TEMP\" %}\n@@ -5656,5 +5685,5 @@\n-    __ pmovsxbw($tmp$$XMMRegister, $src1$$XMMRegister);\n-    __ pmovsxbw($dst$$XMMRegister, $src2$$XMMRegister);\n-    __ pmullw($tmp$$XMMRegister, $dst$$XMMRegister);\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ pand($dst$$XMMRegister, $tmp$$XMMRegister);\n+    __ pmovsxbw($dst$$XMMRegister, $src1$$XMMRegister);\n+    __ pmovsxbw($xtmp$$XMMRegister, $src2$$XMMRegister);\n+    __ pmullw($dst$$XMMRegister, $xtmp$$XMMRegister);\n+    __ psllw($dst$$XMMRegister, 8);\n+    __ psrlw($dst$$XMMRegister, 8);\n@@ -5666,2 +5695,2 @@\n-instruct mul16B_reg(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n-  predicate(Matcher::vector_length(n) == 16 && UseAVX <= 1);\n+instruct vmulB(vec dst, vec src1, vec src2, vec xtmp) %{\n+  predicate(UseAVX == 0 && Matcher::vector_length_in_bytes(n) > 8);\n@@ -5669,2 +5698,2 @@\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n-  format %{\"vector_mulB $dst,$src1,$src2\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"mulVB   $dst, $src1, $src2\\t! using $xtmp as TEMP\" %}\n@@ -5673,18 +5702,20 @@\n-    __ pmovsxbw($tmp1$$XMMRegister, $src1$$XMMRegister);\n-    __ pmovsxbw($tmp2$$XMMRegister, $src2$$XMMRegister);\n-    __ pmullw($tmp1$$XMMRegister, $tmp2$$XMMRegister);\n-    __ pshufd($tmp2$$XMMRegister, $src1$$XMMRegister, 0xEE);\n-    __ pshufd($dst$$XMMRegister, $src2$$XMMRegister, 0xEE);\n-    __ pmovsxbw($tmp2$$XMMRegister, $tmp2$$XMMRegister);\n-    __ pmovsxbw($dst$$XMMRegister, $dst$$XMMRegister);\n-    __ pmullw($tmp2$$XMMRegister, $dst$$XMMRegister);\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ pand($tmp2$$XMMRegister, $dst$$XMMRegister);\n-    __ pand($dst$$XMMRegister, $tmp1$$XMMRegister);\n-    __ packuswb($dst$$XMMRegister, $tmp2$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vmul16B_reg_avx(vec dst, vec src1, vec src2, vec tmp) %{\n-  predicate(Matcher::vector_length(n) == 16 && UseAVX > 1);\n+    \/\/ Odd-index elements\n+    __ movdqu($dst$$XMMRegister, $src1$$XMMRegister);\n+    __ psrlw($dst$$XMMRegister, 8);\n+    __ movdqu($xtmp$$XMMRegister, $src2$$XMMRegister);\n+    __ psrlw($xtmp$$XMMRegister, 8);\n+    __ pmullw($dst$$XMMRegister, $xtmp$$XMMRegister);\n+    __ psllw($dst$$XMMRegister, 8);\n+    \/\/ Even-index elements\n+    __ movdqu($xtmp$$XMMRegister, $src1$$XMMRegister);\n+    __ pmullw($xtmp$$XMMRegister, $src2$$XMMRegister);\n+    __ psllw($xtmp$$XMMRegister, 8);\n+    __ psrlw($xtmp$$XMMRegister, 8);\n+    \/\/ Combine\n+    __ por($dst$$XMMRegister, $xtmp$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmulB_reg(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2) %{\n+  predicate(UseAVX > 0 && Matcher::vector_length_in_bytes(n) > 8);\n@@ -5692,20 +5723,2 @@\n-  effect(TEMP dst, TEMP tmp);\n-  format %{\"vector_mulB $dst,$src1,$src2\" %}\n-  ins_encode %{\n-  int vlen_enc = Assembler::AVX_256bit;\n-    __ vpmovsxbw($tmp$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp$$XMMRegister, $tmp$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, vlen_enc);\n-    __ vextracti128_high($tmp$$XMMRegister, $dst$$XMMRegister);\n-    __ vpackuswb($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, 0);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vmul32B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n-  predicate(Matcher::vector_length(n) == 32);\n-  match(Set dst (MulVB src1 src2));\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n-  format %{\"vector_mulB $dst,$src1,$src2\" %}\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vmulVB  $dst, $src1, $src2\\t! using $xtmp1, $xtmp2 as TEMP\" %}\n@@ -5713,43 +5726,12 @@\n-    assert(UseAVX > 1, \"required\");\n-    int vlen_enc = Assembler::AVX_256bit;\n-    __ vextracti128_high($tmp1$$XMMRegister, $src1$$XMMRegister);\n-    __ vextracti128_high($dst$$XMMRegister, $src2$$XMMRegister);\n-    __ vpmovsxbw($tmp1$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($tmp2$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpand($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister, vlen_enc);\n-    __ vpackuswb($dst$$XMMRegister, $dst$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n-    __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 0xD8, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vmul64B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n-  predicate(Matcher::vector_length(n) == 64);\n-  match(Set dst (MulVB src1 src2));\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n-  format %{\"vector_mulB $dst,$src1,$src2\\n\\t\" %}\n-  ins_encode %{\n-    assert(UseAVX > 2, \"required\");\n-    int vlen_enc = Assembler::AVX_512bit;\n-    __ vextracti64x4_high($tmp1$$XMMRegister, $src1$$XMMRegister);\n-    __ vextracti64x4_high($dst$$XMMRegister, $src2$$XMMRegister);\n-    __ vpmovsxbw($tmp1$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($tmp2$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpand($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpand($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpackuswb($dst$$XMMRegister, $tmp1$$XMMRegister, $tmp2$$XMMRegister, vlen_enc);\n-    __ evmovdquq($tmp2$$XMMRegister, ExternalAddress(vector_byte_perm_mask()), vlen_enc, noreg);\n-    __ vpermq($dst$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    int vlen_enc = vector_length_encoding(this);\n+    \/\/ Odd-index elements\n+    __ vpsrlw($xtmp2$$XMMRegister, $src1$$XMMRegister, 8, vlen_enc);\n+    __ vpsrlw($xtmp1$$XMMRegister, $src2$$XMMRegister, 8, vlen_enc);\n+    __ vpmullw($xtmp2$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+    __ vpsllw($xtmp2$$XMMRegister, $xtmp2$$XMMRegister, 8, vlen_enc);\n+    \/\/ Even-index elements\n+    __ vpmullw($xtmp1$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ vpsllw($xtmp1$$XMMRegister, $xtmp1$$XMMRegister, 8, vlen_enc);\n+    __ vpsrlw($xtmp1$$XMMRegister, $xtmp1$$XMMRegister, 8, vlen_enc);\n+    \/\/ Combine\n+    __ vpor($dst$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n@@ -5764,1 +5746,1 @@\n-  format %{ \"pmullw $dst,$src\\t! mul packedS\" %}\n+  format %{ \"pmullw  $dst,$src\\t! mul packedS\" %}\n@@ -5830,2 +5812,4 @@\n-instruct vmulL_reg(vec dst, vec src1, vec src2) %{\n-  predicate(VM_Version::supports_avx512dq());\n+instruct evmulL_reg(vec dst, vec src1, vec src2) %{\n+  predicate((Matcher::vector_length_in_bytes(n) == 64 &&\n+             VM_Version::supports_avx512dq()) ||\n+            VM_Version::supports_avx512vldq());\n@@ -5833,1 +5817,1 @@\n-  format %{ \"vpmullq $dst,$src1,$src2\\t! mul packedL\" %}\n+  format %{ \"evpmullq $dst,$src1,$src2\\t! mul packedL\" %}\n@@ -5837,1 +5821,1 @@\n-    __ vpmullq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ evpmullq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n@@ -5842,3 +5826,5 @@\n-instruct vmulL_mem(vec dst, vec src, memory mem) %{\n-  predicate(VM_Version::supports_avx512dq() &&\n-              (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n+instruct evmulL_mem(vec dst, vec src, memory mem) %{\n+  predicate((Matcher::vector_length_in_bytes(n) == 64 &&\n+             VM_Version::supports_avx512dq()) ||\n+            (Matcher::vector_length_in_bytes(n) > 8 &&\n+             VM_Version::supports_avx512vldq()));\n@@ -5846,1 +5832,1 @@\n-  format %{ \"vpmullq $dst,$src,$mem\\t! mul packedL\" %}\n+  format %{ \"evpmullq $dst,$src,$mem\\t! mul packedL\" %}\n@@ -5850,1 +5836,1 @@\n-    __ vpmullq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vlen_enc);\n+    __ evpmullq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -5855,12 +5841,5 @@\n-instruct mul2L_reg(vec dst, vec src2, legVec tmp) %{\n-  predicate(Matcher::vector_length(n) == 2 && !VM_Version::supports_avx512dq());\n-  match(Set dst (MulVL dst src2));\n-  effect(TEMP dst, TEMP tmp);\n-  format %{ \"pshufd $tmp,$src2, 177\\n\\t\"\n-            \"pmulld $tmp,$dst\\n\\t\"\n-            \"phaddd $tmp,$tmp\\n\\t\"\n-            \"pmovzxdq $tmp,$tmp\\n\\t\"\n-            \"psllq $tmp, 32\\n\\t\"\n-            \"pmuludq $dst,$src2\\n\\t\"\n-            \"paddq $dst,$tmp\\n\\t! mul packed2L\" %}\n-\n+instruct vmulL(vec dst, vec src1, vec src2, vec xtmp) %{\n+  predicate(UseAVX == 0);\n+  match(Set dst (MulVL src1 src2));\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"mulVL   $dst, $src1, $src2\\t! using $xtmp as TEMP\" %}\n@@ -5869,8 +5848,10 @@\n-    int vlen_enc = Assembler::AVX_128bit;\n-    __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 177);\n-    __ pmulld($tmp$$XMMRegister, $dst$$XMMRegister);\n-    __ phaddd($tmp$$XMMRegister, $tmp$$XMMRegister);\n-    __ pmovzxdq($tmp$$XMMRegister, $tmp$$XMMRegister);\n-    __ psllq($tmp$$XMMRegister, 32);\n-    __ pmuludq($dst$$XMMRegister, $src2$$XMMRegister);\n-    __ paddq($dst$$XMMRegister, $tmp$$XMMRegister);\n+    \/\/ Get the lo-hi products, only the lower 32 bits is in concerns\n+    __ pshufd($xtmp$$XMMRegister, $src2$$XMMRegister, 0xB1);\n+    __ pmulld($xtmp$$XMMRegister, $src1$$XMMRegister);\n+    __ pshufd($dst$$XMMRegister, $xtmp$$XMMRegister, 0xB1);\n+    __ paddd($dst$$XMMRegister, $xtmp$$XMMRegister);\n+    __ psllq($dst$$XMMRegister, 32);\n+    \/\/ Get the lo-lo products\n+    __ movdqu($xtmp$$XMMRegister, $src1$$XMMRegister);\n+    __ pmuludq($xtmp$$XMMRegister, $src2$$XMMRegister);\n+    __ paddq($dst$$XMMRegister, $xtmp$$XMMRegister);\n@@ -5881,2 +5862,6 @@\n-instruct vmul4L_reg_avx(vec dst, vec src1, vec src2, legVec tmp, legVec tmp1) %{\n-  predicate(Matcher::vector_length(n) == 4 && !VM_Version::supports_avx512dq());\n+instruct vmulL_reg(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2) %{\n+  predicate(UseAVX > 0 &&\n+            ((Matcher::vector_length_in_bytes(n) == 64 &&\n+              !VM_Version::supports_avx512dq()) ||\n+             (Matcher::vector_length_in_bytes(n) < 64 &&\n+              !VM_Version::supports_avx512vldq())));\n@@ -5884,8 +5869,2 @@\n-  effect(TEMP tmp1, TEMP tmp);\n-  format %{ \"vpshufd $tmp,$src2\\n\\t\"\n-            \"vpmulld $tmp,$src1,$tmp\\n\\t\"\n-            \"vphaddd $tmp,$tmp,$tmp\\n\\t\"\n-            \"vpmovzxdq $tmp,$tmp\\n\\t\"\n-            \"vpsllq $tmp,$tmp\\n\\t\"\n-            \"vpmuludq $tmp1,$src1,$src2\\n\\t\"\n-            \"vpaddq $dst,$tmp,$tmp1\\t! mul packed4L\" %}\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vmulVL  $dst, $src1, $src2\\t! using $xtmp1, $xtmp2 as TEMP\" %}\n@@ -5893,9 +5872,10 @@\n-    int vlen_enc = Assembler::AVX_256bit;\n-    __ vpshufd($tmp$$XMMRegister, $src2$$XMMRegister, 177, vlen_enc);\n-    __ vpmulld($tmp$$XMMRegister, $src1$$XMMRegister, $tmp$$XMMRegister, vlen_enc);\n-    __ vextracti128_high($tmp1$$XMMRegister, $tmp$$XMMRegister);\n-    __ vphaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n-    __ vpmovzxdq($tmp$$XMMRegister, $tmp$$XMMRegister, vlen_enc);\n-    __ vpsllq($tmp$$XMMRegister, $tmp$$XMMRegister, 32, vlen_enc);\n-    __ vpmuludq($tmp1$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n-    __ vpaddq($dst$$XMMRegister, $tmp$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n+    int vlen_enc = vector_length_encoding(this);\n+    \/\/ Get the lo-hi products, only the lower 32 bits is in concerns\n+    __ vpshufd($xtmp1$$XMMRegister, $src2$$XMMRegister, 0xB1, vlen_enc);\n+    __ vpmulld($xtmp1$$XMMRegister, $src1$$XMMRegister, $xtmp1$$XMMRegister, vlen_enc);\n+    __ vpshufd($xtmp2$$XMMRegister, $xtmp1$$XMMRegister, 0xB1, vlen_enc);\n+    __ vpaddd($xtmp2$$XMMRegister, $xtmp2$$XMMRegister, $xtmp1$$XMMRegister, vlen_enc);\n+    __ vpsllq($xtmp2$$XMMRegister, $xtmp2$$XMMRegister, 32, vlen_enc);\n+    \/\/ Get the lo-lo products\n+    __ vpmuludq($xtmp1$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ vpaddq($dst$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n@@ -7374,6 +7354,3 @@\n-instruct castFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{\n-  \/\/ F2I conversion for < 64 byte vector using AVX instructions\n-  \/\/ AVX512 platforms that dont support avx512vl also use AVX instructions to support F2I\n-  predicate(!VM_Version::supports_avx512vl() &&\n-            Matcher::vector_length_in_bytes(n) < 64 &&\n-            Matcher::vector_element_basic_type(n) == T_INT);\n+instruct castFtoX_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4);\n@@ -7382,17 +7359,1 @@\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_castF2I_avx($dst$$XMMRegister, $src$$XMMRegister,\n-                          ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                          $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n-  predicate((VM_Version::supports_avx512vl() ||\n-             Matcher::vector_length_in_bytes(n) == 64) &&\n-             Matcher::vector_element_basic_type(n) == T_INT);\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, KILL cr);\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n@@ -7400,4 +7361,12 @@\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                           ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    \/\/ JDK-8292878 removed the need for an explicit scratch register needed to load greater than\n+    \/\/ 32 bit addresses for register indirect addressing mode since stub constants\n+    \/\/ are part of code cache and there is a cap of 2G on ReservedCodeCacheSize currently.\n+    \/\/ However, targets are free to increase this limit, but having a large code cache size\n+    \/\/ greater than 2G looks unreasonable in practical scenario, on the hind side with given\n+    \/\/ cap we save a temporary register allocation which in limiting case can prevent\n+    \/\/ spilling in high register pressure blocks.\n+    __ vector_castF2X_avx(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n+                          ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n@@ -7409,4 +7378,2 @@\n-  \/\/ F2X conversion for integral non T_INT target using AVX512 instructions\n-  \/\/ Platforms that dont support avx512vl can only support 64 byte vectors\n-  predicate(is_integral_type(Matcher::vector_element_basic_type(n)) &&\n-            Matcher::vector_element_basic_type(n) != T_INT);\n+  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7415,1 +7382,1 @@\n-  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n@@ -7420,3 +7387,3 @@\n-      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                             ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vlen_enc,\n-                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_double_signflip()), noreg, vlen_enc);\n@@ -7425,9 +7392,3 @@\n-      __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                             ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n-      if (to_elem_bt == T_SHORT) {\n-        __ evpmovdw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      } else {\n-        assert(to_elem_bt == T_BYTE, \"required\");\n-        __ evpmovdb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      }\n+      __ vector_castF2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n@@ -7450,0 +7411,16 @@\n+instruct castDtoX_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, vec xtmp5, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP xtmp5, KILL cr);\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 and $xtmp5 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_castD2X_avx(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, $xtmp5$$XMMRegister,\n+                          ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7451,1 +7428,2 @@\n-  predicate(is_integral_type(Matcher::vector_element_basic_type(n)));\n+  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7454,1 +7432,1 @@\n-  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n@@ -7458,3 +7436,4 @@\n-    __ vector_castD2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister,\n-                           ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vlen_enc,\n-                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    AddressLiteral signflip = VM_Version::supports_avx512dq() ? ExternalAddress(vector_double_signflip()) :\n+                              ExternalAddress(vector_float_signflip());\n+    __ vector_castD2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister, signflip, noreg, vlen_enc);\n@@ -8424,1 +8403,0 @@\n-  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)));\n@@ -8435,2 +8413,1 @@\n-  predicate((Matcher::vector_length(n) == Matcher::vector_length(n->in(1))) &&\n-            (Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1))));\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n@@ -8446,0 +8423,13 @@\n+instruct vmaskcast_avx(vec dst, vec src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vector_mask_cast $dst, $src\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8449,1 +8439,0 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -8454,1 +8443,2 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes);\n+     BasicType bt = Matcher::vector_element_basic_type(this);\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, bt);\n@@ -8466,1 +8456,1 @@\n-     int vlen = Matcher::vector_length(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -8470,4 +8460,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen);\n-     if (elem_bt != T_BYTE) {\n-       __ vconvert_b2x(elem_bt, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, elem_bt);\n@@ -8485,1 +8472,1 @@\n-     int vlen = Matcher::vector_length(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -8489,4 +8476,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen);\n-     if (elem_bt != T_BYTE) {\n-       __ vconvert_b2x(elem_bt, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":218,"deletions":234,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -657,2 +657,2 @@\n-    st->print(\"CMPL     rsp, poll_offset[thread]  \\n\\t\"\n-              \"JA       #safepoint_stub\\t\"\n+    st->print(\"CMPL    rsp, poll_offset[thread]  \\n\\t\"\n+              \"JA      #safepoint_stub\\t\"\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -322,0 +322,8 @@\n+\n+source_hpp %{\n+\n+#include \"peephole_x86_64.hpp\"\n+\n+%}\n+\n+\/\/ Register masks\n@@ -953,2 +961,2 @@\n-    st->print_cr(\"cmpq     rsp, poll_offset[r15_thread] \\n\\t\"\n-                 \"ja       #safepoint_stub\\t\"\n+    st->print_cr(\"cmpq    rsp, poll_offset[r15_thread] \\n\\t\"\n+                 \"ja      #safepoint_stub\\t\"\n@@ -9038,0 +9046,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2(rRegI dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9272,0 +9293,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2(rRegL dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -13806,0 +13840,3 @@\n+\/\/ peeppredicate ( rule_predicate );\n+\/\/ \/\/ the predicate unless which the peephole rule will be ignored\n+\/\/\n@@ -13808,0 +13845,10 @@\n+\/\/ peepprocedure ( procedure_name );\n+\/\/ \/\/ provide a procedure name to perform the optimization, the procedure should\n+\/\/ \/\/ reside in the architecture dependent peephole file, the method has the\n+\/\/ \/\/ signature of MachNode* (Block*, int, PhaseRegAlloc*, (MachNode*)(*)(), int...)\n+\/\/ \/\/ with the arguments being the basic block, the current node index inside the\n+\/\/ \/\/ block, the register allocator, the functions upon invoked return a new node\n+\/\/ \/\/ defined in peepreplace, and the rules of the nodes appearing in the\n+\/\/ \/\/ corresponding peepmatch, the function return true if successful, else\n+\/\/ \/\/ return false\n+\/\/\n@@ -13828,4 +13875,1 @@\n-\/\/ Only match adjacent instructions in same basic block\n-\/\/ Only equality constraints\n-\/\/ Only constraints between operands, not (0.dest_reg == RAX_enc)\n-\/\/ Only one replacement instruction\n+\/\/ Only transformations inside a basic block (do we need more for peephole)\n@@ -13847,0 +13891,11 @@\n+\/\/ instruct leaI_rReg_immI(rRegI dst, immI_1 src)\n+\/\/ %{\n+\/\/   match(Set dst (AddI dst src));\n+\/\/ %}\n+\/\/\n+\/\/ 1. Simple replacement\n+\/\/ - Only match adjacent instructions in same basic block\n+\/\/ - Only equality constraints\n+\/\/ - Only constraints between operands, not (0.dest_reg == RAX_enc)\n+\/\/ - Only one replacement instruction\n+\/\/\n@@ -13849,0 +13904,2 @@\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n@@ -13859,3 +13916,6 @@\n-\n-\/\/ Implementation no longer uses movX instructions since\n-\/\/ machine-independent system no longer uses CopyX nodes.\n+\/\/ 2. Procedural replacement\n+\/\/ - More flexible finding relevent nodes\n+\/\/ - More flexible constraints\n+\/\/ - More flexible transformations\n+\/\/ - May utilise architecture-dependent API more effectively\n+\/\/ - Currently only one replacement instruction due to adlc parsing capabilities\n@@ -13863,5 +13923,11 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n+\/\/ \/\/ Change (inc mov) to lea\n+\/\/ peephole %{\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n+\/\/   \/\/ the rule numbers of these nodes inside are passed into the function below\n+\/\/   peepmatch ( incI_rReg movI );\n+\/\/   \/\/ the method that takes the responsibility of transformation\n+\/\/   peepprocedure ( inc_mov_to_lea );\n+\/\/   \/\/ the replacement is a leaI_rReg_immI, a lambda upon invoked creating this\n+\/\/   \/\/ node is passed into the function above\n+\/\/   peepreplace ( leaI_rReg_immI() );\n@@ -13870,6 +13936,19 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+\/\/ These instructions is not matched by the matcher but used by the peephole\n+instruct leaI_rReg_rReg_peep(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leal(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leal(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13877,6 +13956,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addI_rReg_imm movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI_peep(rRegI dst, rRegI src1, immI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leal($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13884,6 +13967,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI2_peep(rRegI dst, rRegI src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftI src shift));\n+  format %{ \"leal    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leal($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leal($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13891,6 +13984,18 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_rReg_peep(rRegL dst, rRegL src1, rRegL src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leaq(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leaq(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13898,6 +14003,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addL_rReg_imm movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immL32_peep(rRegL dst, rRegL src1, immL32 src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13905,6 +14014,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addP_rReg_imm movP);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immI2_peep(rRegL dst, rRegL src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftL src shift));\n+  format %{ \"leaq    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leaq($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leaq($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13912,11 +14031,63 @@\n-\/\/ \/\/ Change load of spilled value to only a spill\n-\/\/ instruct storeI(memory mem, rRegI src)\n-\/\/ %{\n-\/\/   match(Set mem (StoreI mem src));\n-\/\/ %}\n-\/\/\n-\/\/ instruct loadI(rRegI dst, memory mem)\n-\/\/ %{\n-\/\/   match(Set dst (LoadI mem));\n-\/\/ %}\n-\/\/\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaI_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salI_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI2_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaL_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n@@ -13926,3 +14097,4 @@\n-  peepmatch (loadI storeI);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeI(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n@@ -13933,3 +14105,4 @@\n-  peepmatch (loadL storeL);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeL(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salL_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immI2_peep());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":240,"deletions":67,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -89,1 +89,5 @@\n-          \"Use fast method entry code for accessor methods\")\n+          \"Use fast method entry code for accessor methods\")                \\\n+                                                                            \\\n+  product(bool, DecodeErrorContext, false, DIAGNOSTIC,                      \\\n+          \"Try to decode the architecture-specific context for better \"     \\\n+          \"diagnostics\")\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1180,2 +1180,2 @@\n-                                   GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n-                                   GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps) {\n+                                   GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_bitmaps,\n+                                   GrowableArray<ArchiveHeapBitmapInfo>* open_heap_bitmaps) {\n@@ -1190,1 +1190,1 @@\n-  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_oopmaps, open_heap_oopmaps,\n+  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_bitmaps, open_heap_bitmaps,\n@@ -1196,1 +1196,1 @@\n-                                        closed_heap_oopmaps,\n+                                        closed_heap_bitmaps,\n@@ -1201,1 +1201,1 @@\n-                                        open_heap_oopmaps,\n+                                        open_heap_bitmaps,\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-struct ArchiveHeapOopmapInfo;\n+struct ArchiveHeapBitmapInfo;\n@@ -416,2 +416,2 @@\n-                     GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n-                     GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps);\n+                     GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_oopmaps,\n+                     GrowableArray<ArchiveHeapBitmapInfo>* open_heap_oopmaps);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,3 @@\n-ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+  log_info(cds)(\"Parsing %s%s\", file,\n+                (parse_mode == _parse_lambda_forms_invokers_only) ? \" (lambda form invokers only)\" : \"\");\n@@ -76,0 +78,1 @@\n+  _parse_mode = parse_mode;\n@@ -107,0 +110,4 @@\n+    if (_parse_mode == _parse_lambda_forms_invokers_only) {\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1566,0 +1566,23 @@\n+void FileMapRegion::init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap) {\n+  _oopmap_offset = oopmap._bm_region_offset;\n+  _oopmap_size_in_bits = oopmap._size_in_bits;\n+\n+  _ptrmap_offset = ptrmap._bm_region_offset;\n+  _ptrmap_size_in_bits = ptrmap._size_in_bits;\n+}\n+\n+BitMapView FileMapRegion::bitmap_view(bool is_oopmap) {\n+  char* bitmap_base = FileMapInfo::current_info()->map_bitmap_region();\n+  bitmap_base += is_oopmap ? _oopmap_offset : _ptrmap_offset;\n+  size_t size_in_bits = is_oopmap ? _oopmap_size_in_bits : _ptrmap_size_in_bits;\n+  return BitMapView((BitMap::bm_word_t*)(bitmap_base), size_in_bits);\n+}\n+\n+BitMapView FileMapRegion::oopmap_view() {\n+  return bitmap_view(true);\n+}\n+\n+BitMapView FileMapRegion::ptrmap_view() {\n+  assert(has_ptrmap(), \"must be\");\n+  return bitmap_view(false);\n+}\n@@ -1640,4 +1663,4 @@\n-size_t FileMapInfo::set_oopmaps_offset(GrowableArray<ArchiveHeapOopmapInfo>* oopmaps, size_t curr_size) {\n-  for (int i = 0; i < oopmaps->length(); i++) {\n-    oopmaps->at(i)._offset = curr_size;\n-    curr_size += oopmaps->at(i)._oopmap_size_in_bytes;\n+size_t FileMapInfo::set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_size) {\n+  for (int i = 0; i < bitmaps->length(); i++) {\n+    bitmaps->at(i)._bm_region_offset = curr_size;\n+    curr_size += bitmaps->at(i)._size_in_bytes;\n@@ -1648,4 +1671,4 @@\n-size_t FileMapInfo::write_oopmaps(GrowableArray<ArchiveHeapOopmapInfo>* oopmaps, size_t curr_offset, char* buffer) {\n-  for (int i = 0; i < oopmaps->length(); i++) {\n-    memcpy(buffer + curr_offset, oopmaps->at(i)._oopmap, oopmaps->at(i)._oopmap_size_in_bytes);\n-    curr_offset += oopmaps->at(i)._oopmap_size_in_bytes;\n+size_t FileMapInfo::write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_offset, char* buffer) {\n+  for (int i = 0; i < bitmaps->length(); i++) {\n+    memcpy(buffer + curr_offset, bitmaps->at(i)._map, bitmaps->at(i)._size_in_bytes);\n+    curr_offset += bitmaps->at(i)._size_in_bytes;\n@@ -1657,2 +1680,2 @@\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n@@ -1663,3 +1686,3 @@\n-  if (closed_oopmaps != NULL && open_oopmaps != NULL) {\n-    size_in_bytes = set_oopmaps_offset(closed_oopmaps, size_in_bytes);\n-    size_in_bytes = set_oopmaps_offset(open_oopmaps, size_in_bytes);\n+  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+    size_in_bytes = set_bitmaps_offset(closed_bitmaps, size_in_bytes);\n+    size_in_bytes = set_bitmaps_offset(open_bitmaps, size_in_bytes);\n@@ -1672,3 +1695,3 @@\n-  if (closed_oopmaps != NULL && open_oopmaps != NULL) {\n-    size_t curr_offset = write_oopmaps(closed_oopmaps, ptrmap->size_in_bytes(), buffer);\n-    write_oopmaps(open_oopmaps, curr_offset, buffer);\n+  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+    size_t curr_offset = write_bitmaps(closed_bitmaps, ptrmap->size_in_bytes(), buffer);\n+    write_bitmaps(open_bitmaps, curr_offset, buffer);\n@@ -1713,1 +1736,1 @@\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* oopmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n@@ -1739,2 +1762,4 @@\n-      space_at(region_idx)->init_oopmap(oopmaps->at(i)._offset,\n-                                        oopmaps->at(i)._oopmap_size_in_bits);\n+      int oopmap_idx = i * 2;\n+      int ptrmap_idx = i * 2 + 1;\n+      space_at(region_idx)->init_bitmaps(bitmaps->at(oopmap_idx),\n+                                         bitmaps->at(ptrmap_idx));\n@@ -2381,0 +2406,2 @@\n+\n+    si->set_mapped_base(base);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class BitMapView;\n@@ -106,5 +107,5 @@\n-struct ArchiveHeapOopmapInfo {\n-  address _oopmap;               \/\/ bitmap for relocating embedded oops\n-  size_t  _offset;               \/\/ this oopmap is stored at this offset from the bottom of the BM region\n-  size_t  _oopmap_size_in_bits;\n-  size_t  _oopmap_size_in_bytes;\n+struct ArchiveHeapBitmapInfo {\n+  address _map;               \/\/ bitmap for relocating embedded oops\n+  size_t  _bm_region_offset;  \/\/ this bitmap is stored at this offset from the bottom of the BM region\n+  size_t  _size_in_bits;\n+  size_t  _size_in_bytes;\n@@ -141,0 +142,1 @@\n+  BitMapView bitmap_view(bool is_oopmap);\n@@ -160,1 +162,1 @@\n-  char*  mapped_base()              const { assert_is_not_heap_region(); return _mapped_base; }\n+  char*  mapped_base()              const { return _mapped_base; }\n@@ -174,5 +176,4 @@\n-\n-  void init_oopmap(size_t oopmap_offset, size_t size_in_bits) {\n-    _oopmap_offset = oopmap_offset;\n-    _oopmap_size_in_bits = size_in_bits;\n-  }\n+  void init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap);\n+  BitMapView oopmap_view();\n+  BitMapView ptrmap_view();\n+  bool has_ptrmap()                  { return _ptrmap_size_in_bits != 0; }\n@@ -481,2 +482,2 @@\n-                            GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,\n-                            GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n@@ -485,1 +486,1 @@\n-                            GrowableArray<ArchiveHeapOopmapInfo>* oopmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n@@ -610,2 +611,2 @@\n-  static size_t set_oopmaps_offset(GrowableArray<ArchiveHeapOopmapInfo> *oopmaps, size_t curr_size);\n-  static size_t write_oopmaps(GrowableArray<ArchiveHeapOopmapInfo> *oopmaps, size_t curr_offset, char* buffer);\n+  static size_t set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_size);\n+  static size_t write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_offset, char* buffer);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = NULL;\n@@ -325,0 +326,1 @@\n+    mark_native_pointers(obj, archived_oop);\n@@ -358,0 +360,26 @@\n+void HeapShared::mark_native_pointers(oop orig_obj, oop archived_obj) {\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    mark_one_native_pointer(archived_obj, java_lang_Class::klass_offset());\n+    mark_one_native_pointer(archived_obj, java_lang_Class::array_klass_offset());\n+  }\n+}\n+\n+void HeapShared::mark_one_native_pointer(oop archived_obj, int offset) {\n+  Metadata* ptr = archived_obj->metadata_field_acquire(offset);\n+  if (ptr != NULL) {\n+    \/\/ Set the native pointer to the requested address (at runtime, if the metadata\n+    \/\/ is mapped at the default location, it will be at this address).\n+    address buffer_addr = ArchiveBuilder::current()->get_buffered_addr((address)ptr);\n+    address requested_addr = ArchiveBuilder::current()->to_requested(buffer_addr);\n+    archived_obj->metadata_field_put(offset, (Metadata*)requested_addr);\n+\n+    \/\/ Remember this pointer. At runtime, if the metadata is mapped at a non-default\n+    \/\/ location, the pointer needs to be patched (see ArchiveHeapLoader::patch_native_pointers()).\n+    _native_pointers->append(archived_obj->field_addr<Metadata*>(offset));\n+\n+    log_debug(cds, heap, mirror)(\n+        \"Marked metadata field at %d: \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+         offset, p2i(ptr), p2i(requested_addr));\n+  }\n+}\n+\n@@ -1637,0 +1665,1 @@\n+    _native_pointers = new GrowableArrayCHeap<Metadata**, mtClassShared>(2048);\n@@ -1802,0 +1831,29 @@\n+\n+ResourceBitMap HeapShared::calculate_ptrmap(MemRegion region) {\n+  size_t num_bits = region.byte_size() \/ sizeof(Metadata*);\n+  ResourceBitMap oopmap(num_bits);\n+\n+  Metadata** start = (Metadata**)region.start();\n+  Metadata** end   = (Metadata**)region.end();\n+\n+  int num_non_null_ptrs = 0;\n+  int len = _native_pointers->length();\n+  for (int i = 0; i < len; i++) {\n+    Metadata** p = _native_pointers->at(i);\n+    if (start <= p && p < end) {\n+      assert(*p != NULL, \"must be non-null\");\n+      num_non_null_ptrs ++;\n+      size_t idx = p - start;\n+      oopmap.set_bit(idx);\n+    }\n+  }\n+\n+  log_info(cds, heap)(\"calculate_ptrmap: marked %d non-null native pointers out of \"\n+                      SIZE_FORMAT \" possible locations\", num_non_null_ptrs, num_bits);\n+  if (num_non_null_ptrs > 0) {\n+    return oopmap;\n+  } else {\n+    return ResourceBitMap(0);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -443,2 +443,2 @@\n-  GrowableArray<ArchiveHeapOopmapInfo> *_closed_heap_oopmaps;\n-  GrowableArray<ArchiveHeapOopmapInfo> *_open_heap_oopmaps;\n+  GrowableArray<ArchiveHeapBitmapInfo> *_closed_heap_bitmaps;\n+  GrowableArray<ArchiveHeapBitmapInfo> *_open_heap_bitmaps;\n@@ -447,3 +447,5 @@\n-  void dump_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;\n-  void dump_heap_oopmaps(GrowableArray<MemRegion>* regions,\n-                                 GrowableArray<ArchiveHeapOopmapInfo>* oopmaps);\n+  void dump_heap_bitmaps() NOT_CDS_JAVA_HEAP_RETURN;\n+  void dump_heap_bitmaps(GrowableArray<MemRegion>* regions,\n+                         GrowableArray<ArchiveHeapBitmapInfo>* bitmaps);\n+  void dump_one_heap_bitmap(MemRegion region, GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n+                            ResourceBitMap bitmap, bool is_oopmap);\n@@ -462,2 +464,2 @@\n-    _closed_heap_oopmaps(NULL),\n-    _open_heap_oopmaps(NULL) {}\n+    _closed_heap_bitmaps(NULL),\n+    _open_heap_bitmaps(NULL) {}\n@@ -509,1 +511,1 @@\n-  dump_heap_oopmaps();\n+  dump_heap_bitmaps();\n@@ -571,2 +573,2 @@\n-                        _closed_heap_oopmaps,\n-                        _open_heap_oopmaps);\n+                        _closed_heap_bitmaps,\n+                        _open_heap_bitmaps);\n@@ -738,0 +740,27 @@\n+void MetaspaceShared::get_default_classlist(char* default_classlist, const size_t buf_size) {\n+  \/\/ Construct the path to the class list (in jre\/lib)\n+  \/\/ Walk up two directories from the location of the VM and\n+  \/\/ optionally tack on \"lib\" (depending on platform)\n+  os::jvm_path(default_classlist, (jint)(buf_size));\n+  for (int i = 0; i < 3; i++) {\n+    char *end = strrchr(default_classlist, *os::file_separator());\n+    if (end != NULL) *end = '\\0';\n+  }\n+  size_t classlist_path_len = strlen(default_classlist);\n+  if (classlist_path_len >= 3) {\n+    if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n+      if (classlist_path_len < buf_size - 4) {\n+        jio_snprintf(default_classlist + classlist_path_len,\n+                     buf_size - classlist_path_len,\n+                     \"%slib\", os::file_separator());\n+        classlist_path_len += 4;\n+      }\n+    }\n+  }\n+  if (classlist_path_len < buf_size - 10) {\n+    jio_snprintf(default_classlist + classlist_path_len,\n+                 buf_size - classlist_path_len,\n+                 \"%sclasslist\", os::file_separator());\n+  }\n+}\n+\n@@ -742,0 +771,1 @@\n+  get_default_classlist(default_classlist, sizeof(default_classlist));\n@@ -743,24 +773,0 @@\n-    \/\/ Construct the path to the class list (in jre\/lib)\n-    \/\/ Walk up two directories from the location of the VM and\n-    \/\/ optionally tack on \"lib\" (depending on platform)\n-    os::jvm_path(default_classlist, sizeof(default_classlist));\n-    for (int i = 0; i < 3; i++) {\n-      char *end = strrchr(default_classlist, *os::file_separator());\n-      if (end != NULL) *end = '\\0';\n-    }\n-    int classlist_path_len = (int)strlen(default_classlist);\n-    if (classlist_path_len >= 3) {\n-      if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n-        if (classlist_path_len < JVM_MAXPATHLEN - 4) {\n-          jio_snprintf(default_classlist + classlist_path_len,\n-                       sizeof(default_classlist) - classlist_path_len,\n-                       \"%slib\", os::file_separator());\n-          classlist_path_len += 4;\n-        }\n-      }\n-    }\n-    if (classlist_path_len < JVM_MAXPATHLEN - 10) {\n-      jio_snprintf(default_classlist + classlist_path_len,\n-                   sizeof(default_classlist) - classlist_path_len,\n-                   \"%sclasslist\", os::file_separator());\n-    }\n@@ -774,1 +780,2 @@\n-  int class_count = parse_classlist(classlist_path, CHECK);\n+  int class_count = ClassListParser::parse_classlist(classlist_path,\n+                                                     ClassListParser::_parse_all, CHECK);\n@@ -776,1 +783,10 @@\n-    class_count += parse_classlist(ExtraSharedClassListFile, CHECK);\n+    class_count += ClassListParser::parse_classlist(ExtraSharedClassListFile,\n+                                                    ClassListParser::_parse_all, CHECK);\n+  }\n+  if (classlist_path != default_classlist) {\n+    struct stat statbuf;\n+    if (os::stat(default_classlist, &statbuf) == 0) {\n+      \/\/ File exists, let's use it.\n+      class_count += ClassListParser::parse_classlist(default_classlist,\n+                                                      ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n+    }\n@@ -819,6 +835,0 @@\n-\n-int MetaspaceShared::parse_classlist(const char* classlist_path, TRAPS) {\n-  ClassListParser parser(classlist_path);\n-  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n-}\n-\n@@ -896,1 +906,1 @@\n-void VM_PopulateDumpSharedSpace::dump_heap_oopmaps() {\n+void VM_PopulateDumpSharedSpace::dump_heap_bitmaps() {\n@@ -898,2 +908,7 @@\n-    _closed_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n-    dump_heap_oopmaps(_closed_heap_regions, _closed_heap_oopmaps);\n+    _closed_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n+    dump_heap_bitmaps(_closed_heap_regions, _closed_heap_bitmaps);\n+\n+    _open_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n+    dump_heap_bitmaps(_open_heap_regions, _open_heap_bitmaps);\n+  }\n+}\n@@ -901,2 +916,8 @@\n-    _open_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n-    dump_heap_oopmaps(_open_heap_regions, _open_heap_oopmaps);\n+void VM_PopulateDumpSharedSpace::dump_heap_bitmaps(GrowableArray<MemRegion>* regions,\n+                                                   GrowableArray<ArchiveHeapBitmapInfo>* bitmaps) {\n+  for (int i = 0; i < regions->length(); i++) {\n+    MemRegion region = regions->at(i);\n+    ResourceBitMap oopmap = HeapShared::calculate_oopmap(region);\n+    ResourceBitMap ptrmap = HeapShared::calculate_ptrmap(region);\n+    dump_one_heap_bitmap(region, bitmaps, oopmap, true);\n+    dump_one_heap_bitmap(region, bitmaps, ptrmap, false);\n@@ -906,18 +927,14 @@\n-void VM_PopulateDumpSharedSpace::dump_heap_oopmaps(GrowableArray<MemRegion>* regions,\n-                                                   GrowableArray<ArchiveHeapOopmapInfo>* oopmaps) {\n-  for (int i=0; i<regions->length(); i++) {\n-    ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions->at(i));\n-    size_t size_in_bits = oopmap.size();\n-    size_t size_in_bytes = oopmap.size_in_bytes();\n-    uintptr_t* buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n-    oopmap.write_to(buffer, size_in_bytes);\n-    log_info(cds, heap)(\"Oopmap = \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for heap region \"\n-                        INTPTR_FORMAT \" (\" SIZE_FORMAT_W(8) \" bytes)\",\n-                        p2i(buffer), size_in_bytes,\n-                        p2i(regions->at(i).start()), regions->at(i).byte_size());\n-\n-    ArchiveHeapOopmapInfo info;\n-    info._oopmap = (address)buffer;\n-    info._oopmap_size_in_bits = size_in_bits;\n-    info._oopmap_size_in_bytes = size_in_bytes;\n-    oopmaps->append(info);\n+void VM_PopulateDumpSharedSpace::dump_one_heap_bitmap(MemRegion region,\n+                                                      GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n+                                                      ResourceBitMap bitmap, bool is_oopmap) {\n+  size_t size_in_bits = bitmap.size();\n+  size_t size_in_bytes;\n+  uintptr_t* buffer;\n+\n+  if (size_in_bits > 0) {\n+    size_in_bytes = bitmap.size_in_bytes();\n+    buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n+    bitmap.write_to(buffer, size_in_bytes);\n+  } else {\n+    size_in_bytes = 0;\n+    buffer = NULL;\n@@ -925,0 +942,12 @@\n+\n+  log_info(cds, heap)(\"%s = \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for heap region \"\n+                      INTPTR_FORMAT \" (\" SIZE_FORMAT_W(8) \" bytes)\",\n+                      is_oopmap ? \"Oopmap\" : \"Ptrmap\",\n+                      p2i(buffer), size_in_bytes,\n+                      p2i(region.start()), region.byte_size());\n+\n+  ArchiveHeapBitmapInfo info;\n+  info._map = (address)buffer;\n+  info._size_in_bits = size_in_bits;\n+  info._size_in_bytes = size_in_bytes;\n+  bitmaps->append(info);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":94,"deletions":65,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -287,0 +287,6 @@\n+#ifdef ASSERT\n+void ClassLoaderData::verify_not_claimed(int claim) {\n+  assert((_claim & claim) == 0, \"Found claim: %d bits in _claim: %d\", claim, _claim);\n+}\n+#endif\n+\n@@ -614,1 +620,0 @@\n-  bool resizable = false;\n@@ -617,1 +622,0 @@\n-    resizable = true;\n@@ -622,1 +626,0 @@\n-    resizable = true;\n@@ -625,5 +628,1 @@\n-    resizable = true;\n-  }\n-  if (!DynamicallyResizeSystemDictionaries || DumpSharedSpaces) {\n-    resizable = false;\n-  return new Dictionary(this, size, resizable);\n+  return new Dictionary(this, size);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+  void verify_not_claimed(int claim) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1160,15 +1160,0 @@\n-static void set_klass_field_in_archived_mirror(oop mirror_obj, int offset, Klass* k) {\n-  assert(java_lang_Class::is_instance(mirror_obj), \"must be\");\n-  \/\/ this is the copy of k in the output buffer\n-  Klass* copy = ArchiveBuilder::get_buffered_klass(k);\n-\n-  \/\/ This is the address of k, if the archive is loaded at the requested location\n-  Klass* def = ArchiveBuilder::current()->to_requested(copy);\n-\n-  log_debug(cds, heap, mirror)(\n-      \"Relocate mirror metadata field at %d from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-      offset, p2i(k), p2i(def));\n-\n-  mirror_obj->metadata_field_put(offset, def);\n-}\n-\n@@ -1185,5 +1170,0 @@\n-      Klass *ak = (Klass*)(archived_m->metadata_field(_array_klass_offset));\n-      assert(ak != NULL || t == T_VOID, \"should not be NULL\");\n-      if (ak != NULL) {\n-        set_klass_field_in_archived_mirror(archived_m, _array_klass_offset, ak);\n-      }\n@@ -1309,11 +1289,0 @@\n-  \/\/ The archived mirror's field at _klass_offset is still pointing to the original\n-  \/\/ klass. Updated the field in the archived mirror to point to the relocated\n-  \/\/ klass in the archive.\n-  set_klass_field_in_archived_mirror(archived_mirror, _klass_offset, as_Klass(mirror));\n-\n-  \/\/ The field at _array_klass_offset is pointing to the original one dimension\n-  \/\/ higher array klass if exists. Relocate the pointer.\n-  Klass *arr = array_klass_acquire(mirror);\n-  if (arr != NULL) {\n-    set_klass_field_in_archived_mirror(archived_mirror, _array_klass_offset, arr);\n-  }\n@@ -1323,27 +1292,0 @@\n-void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {\n-  if (MetaspaceShared::relocation_delta() != 0) {\n-    assert(archived_mirror->metadata_field(_klass_offset) == NULL, \"must be for primitive class\");\n-\n-    Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-    if (ak != NULL) {\n-      archived_mirror->metadata_field_put(_array_klass_offset,\n-          (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-    }\n-  }\n-}\n-\n-void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {\n-  assert(MetaspaceShared::relocation_delta() != 0, \"must be\");\n-\n-  Klass* k = ((Klass*)archived_mirror->metadata_field(_klass_offset));\n-  archived_mirror->metadata_field_put(_klass_offset,\n-      (Klass*)(address(k) + MetaspaceShared::relocation_delta()));\n-\n-  Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-  if (ak != NULL) {\n-    archived_mirror->metadata_field_put(_array_klass_offset,\n-        (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":58,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-  static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;\n-  static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -664,1 +664,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -227,0 +227,6 @@\n+  do_intrinsic(_float16ToFloat,           java_lang_Float,        float16ToFloat_name,      f16_float_signature, F_S)   \\\n+   do_name(     float16ToFloat_name,                             \"float16ToFloat\")                                      \\\n+   do_signature(f16_float_signature,                             \"(S)F\")                                                \\\n+  do_intrinsic(_floatToFloat16,           java_lang_Float,        floatToFloat16_name,      float_f16_signature, F_S)   \\\n+   do_name(     floatToFloat16_name,                             \"floatToFloat16\")                                      \\\n+   do_signature(float_f16_signature,                             \"(F)S\")                                                \\\n@@ -1191,0 +1197,12 @@\n+                                                                                                                                               \\\n+  do_intrinsic(_IndexVector, jdk_internal_vm_vector_VectorSupport, index_vector_op_name, index_vector_op_sig, F_S)                             \\\n+    do_signature(index_vector_op_sig, \"(Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"I\"                                                                                                     \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                         \\\n+                                       \"I\"                                                                                                     \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                                  \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)\"                                                \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                        \\\n+    do_name(index_vector_op_name, \"indexVector\")                                                                                               \\\n+                                                                                                                                               \\\n@@ -1299,1 +1317,1 @@\n-  LAST_COMPILER_INLINE = _VectorCompressExpand,\n+  LAST_COMPILER_INLINE = _IndexVector,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1963,1 +1963,1 @@\n-        CompileLog* log = new(ResourceObj::C_HEAP, mtCompiler) CompileLog(file_name, fp, thread_id);\n+        CompileLog* log = new(mtCompiler) CompileLog(file_name, fp, thread_id);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,4 @@\n-  \/\/ This function clears the memory of the object\n+  \/\/ Initialization provided by subclasses.\n+  virtual oop initialize(HeapWord* mem) const = 0;\n+\n+  \/\/ This function clears the memory of the object.\n@@ -61,0 +64,1 @@\n+\n@@ -64,1 +68,1 @@\n-  virtual oop finish(HeapWord* mem) const;\n+  oop finish(HeapWord* mem) const;\n@@ -75,0 +79,1 @@\n+  \/\/ Allocate and fully construct the object, and perform various instrumentation. Could safepoint.\n@@ -77,1 +82,0 @@\n-  virtual oop initialize(HeapWord* mem) const = 0;\n@@ -96,0 +100,1 @@\n+protected:\n@@ -98,1 +103,1 @@\n-protected:\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -31,2 +32,2 @@\n-ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, Thread* thread) :\n-    ObjArrayAllocator(klass, word_size, length, false \/* do_zero *\/, thread) {}\n+ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, bool do_zero, Thread* thread) :\n+    ObjArrayAllocator(klass, word_size, length, do_zero, thread) {}\n@@ -34,3 +35,3 @@\n-oop ZObjArrayAllocator::finish(HeapWord* mem) const {\n-  \/\/ Initialize object header and length field\n-  ObjArrayAllocator::finish(mem);\n+void ZObjArrayAllocator::yield_for_safepoint() const {\n+  ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n+}\n@@ -38,4 +39,8 @@\n-  \/\/ Keep the array alive across safepoints through an invisible\n-  \/\/ root. Invisible roots are not visited by the heap itarator\n-  \/\/ and the marking logic will not attempt to follow its elements.\n-  ZThreadLocalData::set_invisible_root(_thread, (oop*)&mem);\n+oop ZObjArrayAllocator::initialize(HeapWord* mem) const {\n+  \/\/ ZGC specializes the initialization by performing segmented clearing\n+  \/\/ to allow shorter time-to-safepoints.\n+\n+  if (!_do_zero) {\n+    \/\/ No need for ZGC specialization\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n@@ -47,2 +52,30 @@\n-  const size_t skip = arrayOopDesc::header_size(ArrayKlass::cast(_klass)->element_type());\n-  size_t remaining = _word_size - skip;\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t header = arrayOopDesc::header_size(element_type);\n+  const size_t payload_size = _word_size - header;\n+\n+  if (payload_size <= segment_max) {\n+    \/\/ To small to use segmented clearing\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n+\n+  \/\/ Segmented clearing\n+\n+  \/\/ The array is going to be exposed before it has been completely\n+  \/\/ cleared, therefore we can't expose the header at the end of this\n+  \/\/ function. Instead explicitly initialize it according to our needs.\n+  arrayOopDesc::set_mark(mem, Klass::default_prototype_header(_klass));\n+  arrayOopDesc::release_set_klass(mem, _klass);\n+  assert(_length >= 0, \"length should be non-negative\");\n+  arrayOopDesc::set_length(mem, _length);\n+\n+  \/\/ Keep the array alive across safepoints through an invisible\n+  \/\/ root. Invisible roots are not visited by the heap itarator\n+  \/\/ and the marking logic will not attempt to follow its elements.\n+  \/\/ Relocation knows how to dodge iterating over such objects.\n+  ZThreadLocalData::set_invisible_root(_thread, (oop*)&mem);\n+\n+  for (size_t processed = 0; processed < payload_size; processed += segment_max) {\n+    \/\/ Calculate segment\n+    HeapWord* const start = (HeapWord*)(mem + header + processed);\n+    const size_t remaining = payload_size - processed;\n+    const size_t segment_size = MIN2(remaining, segment_max);\n@@ -50,4 +83,1 @@\n-  while (remaining > 0) {\n-    const size_t segment = MIN2(remaining, segment_max);\n-    Copy::zero_to_words(mem + (_word_size - remaining), segment);\n-    remaining -= segment;\n+    Copy::zero_to_words(start, segment_size);\n@@ -56,4 +86,2 @@\n-    if (remaining > 0) {\n-      \/\/ Safepoint\n-      ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n-    }\n+    \/\/ Safepoint\n+    yield_for_safepoint();\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":47,"deletions":19,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-#if defined(AMD64) || defined(AARCH64)\n+#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n@@ -360,1 +360,0 @@\n-  if (PrintBytecodeHistogram)                                    histogram_bytecode(t);\n@@ -364,0 +363,1 @@\n+  if (PrintBytecodeHistogram)                                    histogram_bytecode(t);\n@@ -437,1 +437,1 @@\n-#if defined(AMD64) || defined(AARCH64)\n+#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -265,3 +265,0 @@\n-      if (mirror_oop != NULL) { \/\/ may be null if archived heap is disabled\n-        java_lang_Class::update_archived_primitive_mirror_native_pointers(mirror_oop);\n-      }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -367,9 +367,0 @@\n-  \/\/ Convert (~x+c) into (c-1)-x. Note there isn't a bitwise not\n-  \/\/ bytecode, \"~x\" would typically represented as \"x^(-1)\", so (~x+c)\n-  \/\/ will be (x^(-1))+c.\n-  if (op1 == Op_Xor(bt) &&\n-      (in2->Opcode() == Op_ConI || in2->Opcode() == Op_ConL) &&\n-      phase->type(in1->in(2)) == TypeInteger::minus_1(bt)) {\n-    Node* c_minus_one = phase->makecon(add_ring(phase->type(in(2)), TypeInteger::minus_1(bt)));\n-    return SubNode::make(c_minus_one, in1->in(1), bt);\n-  }\n@@ -877,0 +868,13 @@\n+\/\/---------------------------Helper -------------------------------------------\n+\/* Decide if the given node is used only in arithmetic expressions(add or sub).\n+ *\/\n+static bool is_used_in_only_arithmetic(Node* n, BasicType bt) {\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* u = n->fast_out(i);\n+    if (u->Opcode() != Op_Add(bt) && u->Opcode() != Op_Sub(bt)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -882,9 +886,14 @@\n-  int op1 = in1->Opcode();\n-  \/\/ Convert ~(x+c) into (-c-1)-x. Note there isn't a bitwise not\n-  \/\/ bytecode, \"~x\" would typically represented as \"x^(-1)\", so ~(x+c)\n-  \/\/ will eventually be (x+c)^-1.\n-  if (op1 == Op_AddI && phase->type(in2) == TypeInt::MINUS_1 &&\n-      in1->in(2)->Opcode() == Op_ConI) {\n-    jint c = phase->type(in1->in(2))->isa_int()->get_con();\n-    Node* neg_c_minus_one = phase->intcon(java_add(-c, -1));\n-    return new SubINode(neg_c_minus_one, in1->in(1));\n+\n+  \/\/ Convert ~x into -1-x when ~x is used in an arithmetic expression\n+  \/\/ or x itself is an expression.\n+  if (phase->type(in2) == TypeInt::MINUS_1) { \/\/ follows LHS^(-1), i.e., ~LHS\n+    if (phase->is_IterGVN()) {\n+      if (is_used_in_only_arithmetic(this, T_INT)\n+          \/\/ LHS is arithmetic\n+          || (in1->Opcode() == Op_AddI || in1->Opcode() == Op_SubI)) {\n+        return new SubINode(in2, in1);\n+      }\n+    } else {\n+      \/\/ graph could be incomplete in GVN so we postpone to IGVN\n+      phase->record_for_igvn(this);\n+    }\n@@ -962,9 +971,14 @@\n-  int op1 = in1->Opcode();\n-  \/\/ Convert ~(x+c) into (-c-1)-x. Note there isn't a bitwise not\n-  \/\/ bytecode, \"~x\" would typically represented as \"x^(-1)\", so ~(x+c)\n-  \/\/ will eventually be (x+c)^-1.\n-  if (op1 == Op_AddL && phase->type(in2) == TypeLong::MINUS_1 &&\n-      in1->in(2)->Opcode() == Op_ConL) {\n-    jlong c = phase->type(in1->in(2))->isa_long()->get_con();\n-    Node* neg_c_minus_one = phase->longcon(java_add(-c, (jlong)-1));\n-    return new SubLNode(neg_c_minus_one, in1->in(1));\n+\n+  \/\/ Convert ~x into -1-x when ~x is used in an arithmetic expression\n+  \/\/ or x itself is an arithmetic expression.\n+  if (phase->type(in2) == TypeLong::MINUS_1) { \/\/ follows LHS^(-1), i.e., ~LHS\n+    if (phase->is_IterGVN()) {\n+      if (is_used_in_only_arithmetic(this, T_LONG)\n+          \/\/ LHS is arithmetic\n+          || (in1->Opcode() == Op_AddL || in1->Opcode() == Op_SubL)) {\n+        return new SubLNode(in2, in1);\n+      }\n+    } else {\n+      \/\/ graph could be incomplete in GVN so we postpone to IGVN\n+      phase->record_for_igvn(this);\n+    }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":41,"deletions":27,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -303,0 +303,6 @@\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!Matcher::match_rule_supported(Op_ConvHF2F)) return false;\n+    break;\n+  case vmIntrinsics::_floatToFloat16:\n+    if (!Matcher::match_rule_supported(Op_ConvF2HF)) return false;\n+    break;\n@@ -781,0 +787,1 @@\n+  case vmIntrinsics::_IndexVector:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+macro(ConvF2HF)\n+macro(ConvHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -654,1 +655,1 @@\n-                  _print_inlining_stream(new stringStream()),\n+                  _print_inlining_stream(new (mtCompiler) stringStream()),\n@@ -935,1 +936,1 @@\n-    _print_inlining_stream(new stringStream()),\n+    _print_inlining_stream(new (mtCompiler) stringStream()),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1084,0 +1084,4 @@\n+  ~Compile() {\n+    delete _print_inlining_stream;\n+  };\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,0 +175,15 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvF2HFNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == Type::FLOAT ) return TypeInt::SHORT;\n+  const TypeF *tf = t->is_float_constant();\n+  return TypeInt::make( SharedRuntime::f2hf( tf->getf() ) );\n+}\n+\n+\/\/------------------------------Identity---------------------------------------\n+Node* ConvF2HFNode::Identity(PhaseGVN* phase) {\n+  return (in(1)->Opcode() == Op_ConvHF2F) ? in(1)->in(1) : this;\n+}\n+\n@@ -233,0 +248,12 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvHF2FNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == TypeInt::SHORT ) return Type::FLOAT;\n+  const TypeInt *ti = t->is_int();\n+  if ( ti->is_con() ) return TypeF::make( SharedRuntime::hf2f( ti->get_con() ) );\n+\n+  return bottom_type();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -104,0 +104,12 @@\n+\/\/------------------------------ConvF2HFNode------------------------------------\n+\/\/ Convert Float to Halffloat\n+class ConvF2HFNode : public Node {\n+  public:\n+  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n@@ -131,0 +143,11 @@\n+\/\/------------------------------ConvHF2FNode------------------------------------\n+\/\/ Convert Halffloat to float\n+class ConvHF2FNode : public Node {\n+  public:\n+  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -527,1 +527,3 @@\n-  case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());\n+  case vmIntrinsics::_longBitsToDouble:\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:           return inline_fp_conversions(intrinsic_id());\n@@ -727,0 +729,2 @@\n+  case vmIntrinsics::_IndexVector:\n+    return inline_index_vector();\n@@ -4788,0 +4792,2 @@\n+  case vmIntrinsics::_floatToFloat16:       result = new ConvF2HFNode(arg); break;\n+  case vmIntrinsics::_float16ToFloat:       result = new ConvHF2FNode(arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -374,0 +374,1 @@\n+  bool inline_index_vector();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -448,2 +448,2 @@\n-MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted) {\n-  return NULL;\n+int MachNode::peephole(Block *block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc *ra_) {\n+  return -1;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-  virtual MachNode *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted);\n+  virtual int peephole(Block *block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc *ra_);\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1792,1 +1792,1 @@\n-  assert(t->meet(t0) == t, \"Not monotonic\");\n+  assert(t->meet(t0) == t->remove_speculative(), \"Not monotonic\");\n@@ -2218,11 +2218,11 @@\n-    \/\/ and each instruction within a block\n-    uint end_index = block->number_of_nodes();\n-    \/\/ block->end_idx() not valid after PhaseRegAlloc\n-    for( uint instruction_index = 1; instruction_index < end_index; ++instruction_index ) {\n-      Node     *n = block->get_node(instruction_index);\n-      if( n->is_Mach() ) {\n-        MachNode *m = n->as_Mach();\n-        int deleted_count = 0;\n-        \/\/ check for peephole opportunities\n-        MachNode *m2 = m->peephole(block, instruction_index, _regalloc, deleted_count);\n-        if( m2 != NULL ) {\n+    for (bool progress = true; progress;) {\n+      progress = false;\n+      \/\/ block->end_idx() not valid after PhaseRegAlloc\n+      uint end_index = block->number_of_nodes();\n+      for( uint instruction_index = end_index - 1; instruction_index > 0; --instruction_index ) {\n+        Node     *n = block->get_node(instruction_index);\n+        if( n->is_Mach() ) {\n+          MachNode *m = n->as_Mach();\n+          \/\/ check for peephole opportunities\n+          int result = m->peephole(block, instruction_index, &_cfg, _regalloc);\n+          if( result != -1 ) {\n@@ -2230,15 +2230,14 @@\n-          if( PrintOptoPeephole ) {\n-            \/\/ Print method, first time only\n-            if( C->method() && method_name_not_printed ) {\n-              C->method()->print_short_name(); tty->cr();\n-              method_name_not_printed = false;\n-            }\n-            \/\/ Print this block\n-            if( Verbose && block_not_printed) {\n-              tty->print_cr(\"in block\");\n-              block->dump();\n-              block_not_printed = false;\n-            }\n-            \/\/ Print instructions being deleted\n-            for( int i = (deleted_count - 1); i >= 0; --i ) {\n-              block->get_node(instruction_index-i)->as_Mach()->format(_regalloc); tty->cr();\n+            if( PrintOptoPeephole ) {\n+              \/\/ Print method, first time only\n+              if( C->method() && method_name_not_printed ) {\n+                C->method()->print_short_name(); tty->cr();\n+                method_name_not_printed = false;\n+              }\n+              \/\/ Print this block\n+              if( Verbose && block_not_printed) {\n+                tty->print_cr(\"in block\");\n+                block->dump();\n+                block_not_printed = false;\n+              }\n+              \/\/ Print the peephole number\n+              tty->print_cr(\"peephole number: %d\", result);\n@@ -2246,5 +2245,1 @@\n-            tty->print_cr(\"replaced with\");\n-            \/\/ Print new instruction\n-            m2->format(_regalloc);\n-            tty->print(\"\\n\\n\");\n-          }\n+            inc_peepholes();\n@@ -2252,7 +2247,3 @@\n-          \/\/ Remove old nodes from basic block and update instruction_index\n-          \/\/ (old nodes still exist and may have edges pointing to them\n-          \/\/  as register allocation info is stored in the allocator using\n-          \/\/  the node index to live range mappings.)\n-          uint safe_instruction_index = (instruction_index - deleted_count);\n-          for( ; (instruction_index > safe_instruction_index); --instruction_index ) {\n-            block->remove_node( instruction_index );\n+            \/\/ Set progress, start again\n+            progress = true;\n+            break;\n@@ -2260,4 +2251,0 @@\n-          \/\/ install new node after safe_instruction_index\n-          block->insert_node(m2, safe_instruction_index + 1);\n-          end_index = block->number_of_nodes() - 1; \/\/ Recompute new block size\n-          NOT_PRODUCT( inc_peepholes(); )\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":30,"deletions":43,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2249,0 +2249,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2250,2 +2259,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2254,1 +2261,1 @@\n-                                     current_thread, depth, slot);\n+                                     current_thread, depth, slot, self);\n@@ -2262,7 +2269,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, current_thread, depth, slot);\n+    VM_GetOrSetLocal op(java_thread, current_thread, depth, slot, self);\n@@ -2289,0 +2290,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2290,2 +2300,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2294,1 +2302,1 @@\n-                                   current_thread, depth);\n+                                   current_thread, depth, self);\n@@ -2302,7 +2310,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetReceiver op(java_thread, current_thread, depth);\n+    VM_GetReceiver op(java_thread, current_thread, depth, self);\n@@ -2330,0 +2332,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2331,2 +2342,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2335,1 +2344,1 @@\n-                                     depth, slot, T_INT);\n+                                     depth, slot, T_INT, self);\n@@ -2343,7 +2352,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, self);\n@@ -2371,0 +2374,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2372,2 +2384,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2376,1 +2386,1 @@\n-                                     depth, slot, T_LONG);\n+                                     depth, slot, T_LONG, self);\n@@ -2384,7 +2394,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, self);\n@@ -2412,0 +2416,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2413,2 +2426,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2417,1 +2428,1 @@\n-                                     depth, slot, T_FLOAT);\n+                                     depth, slot, T_FLOAT, self);\n@@ -2425,7 +2436,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, self);\n@@ -2453,0 +2458,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2454,2 +2468,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2458,1 +2470,1 @@\n-                                     depth, slot, T_DOUBLE);\n+                                     depth, slot, T_DOUBLE, self);\n@@ -2466,7 +2478,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, self);\n@@ -2493,0 +2499,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2496,2 +2511,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2500,1 +2513,1 @@\n-                                     depth, slot, T_OBJECT, val);\n+                                     depth, slot, T_OBJECT, val, self);\n@@ -2505,7 +2518,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_OBJECT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_OBJECT, val, self);\n@@ -2529,0 +2536,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2532,2 +2548,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2536,1 +2550,1 @@\n-                                     depth, slot, T_INT, val);\n+                                     depth, slot, T_INT, val, self);\n@@ -2541,7 +2555,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, val, self);\n@@ -2565,0 +2573,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2568,2 +2585,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2572,1 +2587,1 @@\n-                                     depth, slot, T_LONG, val);\n+                                     depth, slot, T_LONG, val, self);\n@@ -2577,7 +2592,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, val, self);\n@@ -2601,0 +2610,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2604,2 +2622,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2608,1 +2624,1 @@\n-                                     depth, slot, T_FLOAT, val);\n+                                     depth, slot, T_FLOAT, val, self);\n@@ -2613,7 +2629,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, val, self);\n@@ -2637,0 +2647,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2640,2 +2659,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2644,1 +2661,1 @@\n-                                     depth, slot, T_DOUBLE, val);\n+                                     depth, slot, T_DOUBLE, val, self);\n@@ -2649,7 +2666,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, val, self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":121,"deletions":110,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-                                           jint index, BasicType type, jvalue value, bool set)\n+                                           jint index, BasicType type, jvalue value, bool set, bool self)\n@@ -443,0 +443,1 @@\n+  , _self(self)\n@@ -750,2 +751,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false, self),\n@@ -758,2 +759,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true, self),\n@@ -766,2 +767,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth, int index)\n-  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth, int index, bool self)\n+  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false, self),\n@@ -792,0 +793,4 @@\n+  if (!(_self || _thread->is_carrier_thread_suspended())) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return NULL;\n+  }\n@@ -806,2 +811,2 @@\n-    JavaThread* thread, JavaThread* caller_thread, jint depth)\n-    : VM_GetOrSetLocal(thread, caller_thread, depth, 0) {}\n+    JavaThread* thread, JavaThread* caller_thread, jint depth, bool self)\n+    : VM_GetOrSetLocal(thread, caller_thread, depth, 0, self) {}\n@@ -817,2 +822,2 @@\n-                                                             jint index, BasicType type)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false)\n+                                                             jint index, BasicType type, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false, self)\n@@ -826,2 +831,2 @@\n-                                                             jint index, BasicType type, jvalue value)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true)\n+                                                             jint index, BasicType type, jvalue value, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true, self)\n@@ -835,2 +840,2 @@\n-                                                             jint depth, int index)\n-  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false)\n+                                                             jint depth, int index, bool self)\n+  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false, self)\n@@ -851,0 +856,5 @@\n+  if (!(_self || JvmtiVTSuspender::is_vthread_suspended(_vthread_h()))) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return NULL;\n+  }\n+\n@@ -885,2 +895,2 @@\n-    JvmtiEnv* env, Handle vthread_h, JavaThread* caller_thread, jint depth)\n-    : VM_VirtualThreadGetOrSetLocal(env, vthread_h, caller_thread, depth, 0) {}\n+    JvmtiEnv* env, Handle vthread_h, JavaThread* caller_thread, jint depth, bool self)\n+    : VM_VirtualThreadGetOrSetLocal(env, vthread_h, caller_thread, depth, 0, self) {}\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -4370,11 +4370,3 @@\n-  \/\/ The class file bytes from before any retransformable agents mucked\n-  \/\/ with them was cached on the scratch class, move to the_class.\n-  \/\/ Note: we still want to do this if nothing needed caching since it\n-  \/\/ should get cleared in the_class too.\n-  if (the_class->get_cached_class_file() == 0) {\n-    \/\/ the_class doesn't have a cache yet so copy it\n-    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n-  }\n-  else if (scratch_class->get_cached_class_file() !=\n-           the_class->get_cached_class_file()) {\n-    \/\/ The same class can be present twice in the scratch classes list or there\n+  if (scratch_class->get_cached_class_file() != the_class->get_cached_class_file()) {\n+    \/\/ 1. the_class doesn't have a cache yet, scratch_class does have a cache.\n+    \/\/ 2. The same class can be present twice in the scratch classes list or there\n@@ -4382,2 +4374,8 @@\n-    \/\/ In such cases we have to deallocate scratch_class cached_class_file.\n-    os::free(scratch_class->get_cached_class_file());\n+    \/\/ the_class and scratch_class have the same cached bytes, but different buffers.\n+    \/\/ In such cases we need to deallocate one of the buffers.\n+    \/\/ 3. RedefineClasses and the_class has cached bytes from a previous transformation.\n+    \/\/ In the case we need to use class bytes from scratch_class.\n+    if (the_class->get_cached_class_file() != nullptr) {\n+      os::free(the_class->get_cached_class_file());\n+    }\n+    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -900,1 +900,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n@@ -748,109 +748,0 @@\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n-  \/\/ so the range tests could be tautological and might cause compiler warnings.\n-  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  long long v = strtoll(s, endptr, base);\n-  if (errno != 0 || v < min_jint || v > max_jint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  \/\/ Don't use strtoul -- same reason as above.\n-  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  unsigned long long v = strtoull(s, endptr, base);\n-  if (errno != 0 || v > max_juint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoll(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoull(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template<typename T>\n-static bool multiply_by_1k(T& n) {\n-  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n-      n <= std::numeric_limits<T>::max() \/ 1024) {\n-    n *= 1024;\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ All of the integral types that can be used for command line options:\n-\/\/   int, uint, intx, uintx, uint64_t, size_t\n-\/\/\n-\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n-\/\/    {signed, unsigned} x {32-bit, 64-bit}\n-\/\/\n-\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n-template<typename T>\n-static bool parse_integer(const char *s, T* result) {\n-  if (!isdigit(s[0]) && s[0] != '-') {\n-    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n-    return false;\n-  }\n-\n-  T n = 0;\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n-                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n-  char* remainder;\n-\n-  if (!parse_integer_impl(s, &remainder, (is_hex ? 16 : 10), &n)) {\n-    return false;\n-  }\n-\n-  \/\/ Fail if no number was read at all or if the remainder contains more than a single non-digit character.\n-  if (remainder == s || strlen(remainder) > 1) {\n-    return false;\n-  }\n-\n-  switch (*remainder) {\n-    case 'T': case 't':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'G': case 'g':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'M': case 'm':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'K': case 'k':\n-      if (!multiply_by_1k(n)) return false;\n-      break;\n-    case '\\0':\n-      break;\n-    default:\n-      return false;\n-  }\n-\n-  *result = n;\n-  return true;\n-}\n-\n@@ -3171,6 +3062,0 @@\n-\n-  \/\/ Zero runs without compilers. Do not let compiler selection code\n-  \/\/ to force it into Serial GC, let the GC ergonomics decide.\n-  if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {\n-    FLAG_SET_ERGO(NeverActAsServerClassMachine, false);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":116,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -596,2 +596,2 @@\n-    st->print(\" - obj    [\");\n-    current->obj()->print_value_on(st);\n+    st->print(\" - obj    [%s\", current->obj() == nullptr ? \"null\" : \"\");\n+    if (current->obj() != nullptr) current->obj()->print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -679,3 +679,0 @@\n-  product(bool, DynamicallyResizeSystemDictionaries, true, DIAGNOSTIC,      \\\n-          \"Dynamically resize system dictionaries as needed\")               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -277,0 +277,4 @@\n+JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n+  return (jfloat)x;\n+JRT_END\n+\n@@ -310,4 +314,0 @@\n-JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n-  return (jfloat)x;\n-JRT_END\n-\n@@ -454,0 +454,80 @@\n+\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:floatToFloat16\n+JRT_LEAF(jshort, SharedRuntime::f2hf(jfloat  x))\n+  jint doppel = SharedRuntime::f2i(x);\n+  jshort sign_bit = (jshort) ((doppel & 0x80000000) >> 16);\n+  if (g_isnan(x))\n+    return (jshort)(sign_bit | 0x7c00 | (doppel & 0x007fe000) >> 13 | (doppel & 0x00001ff0) >> 4 | (doppel & 0x0000000f));\n+\n+  jfloat abs_f = (x >= 0.0f) ? x : (x * -1.0f);\n+\n+  \/\/ Overflow threshold is halffloat max value + 1\/2 ulp\n+  if (abs_f >= (65504.0f + 16.0f)) {\n+    return (jshort)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+  }\n+\n+  \/\/ Smallest magnitude of Halffloat is 0x1.0p-24, half-way or smaller rounds to zero\n+  if (abs_f <= (pow(2, -24) * 0.5f)) { \/\/ Covers float zeros and subnormals.\n+    return sign_bit; \/\/ Positive or negative zero\n+  }\n+\n+  jint exp = 0x7f800000 & doppel;\n+\n+  \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+  \/\/ the difference exp_delta = E_min - exp.  This is the excess\n+  \/\/ shift value, in addition to 13, to be used in the\n+  \/\/ computations below. Further the (hidden) msb with value 1\n+  \/\/ in f must be involved as well\n+  jint exp_delta = 0;\n+  jint msb = 0x00000000;\n+  if (exp < -14) {\n+    exp_delta = -14 - exp;\n+    exp = -15;\n+    msb = 0x00800000;\n+  }\n+  jint f_signif_bits = ((doppel & 0x007fffff) | msb);\n+\n+  \/\/ Significand bits as if using rounding to zero\n+  jshort signif_bits = (jshort)(f_signif_bits >> (13 + exp_delta));\n+\n+  jint lsb = f_signif_bits & (1 << (13 + exp_delta));\n+  jint round  = f_signif_bits & (1 << (12 + exp_delta));\n+  jint sticky = f_signif_bits & ((1 << (12 + exp_delta)) - 1);\n+\n+  if (round != 0 && ((lsb | sticky) != 0 )) {\n+    signif_bits++;\n+  }\n+\n+  return (jshort)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+JRT_END\n+\n+\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:float16ToFloat\n+JRT_LEAF(jfloat, SharedRuntime::hf2f(jshort x))\n+  \/\/ Halffloat format has 1 signbit, 5 exponent bits and\n+  \/\/ 10 significand bits\n+  jint hf_arg = (jint)x;\n+  jint hf_sign_bit = 0x8000 & hf_arg;\n+  jint hf_exp_bits = 0x7c00 & hf_arg;\n+  jint hf_significand_bits = 0x03ff & hf_arg;\n+\n+  jint significand_shift = 13; \/\/difference between float and halffloat precision\n+\n+  jfloat sign = (hf_sign_bit != 0) ? -1.0f : 1.0f;\n+\n+  \/\/ Extract halffloat exponent, remove its bias\n+  jint hf_exp = (hf_exp_bits >> 10) - 15;\n+\n+  if (hf_exp == -15) {\n+    \/\/ For subnormal values, return 2^-24 * significand bits\n+    return (sign * (pow(2,-24)) * hf_significand_bits);\n+  }else if (hf_exp == 16) {\n+    return (hf_significand_bits == 0) ? sign * float_infinity : (SharedRuntime::i2f((hf_sign_bit << 16) | 0x7f800000 |\n+           (hf_significand_bits << significand_shift)));\n+  }\n+\n+  \/\/ Add the bias of float exponent and shift\n+  int float_exp_bits = (hf_exp + 127) << (24 - 1);\n+\n+  \/\/ Combine sign, exponent and significand bits\n+  return SharedRuntime::i2f((hf_sign_bit << 16) | float_exp_bits | (hf_significand_bits << significand_shift));\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":84,"deletions":4,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+  static jfloat  hf2f(jshort  x);\n+  static jshort  f2hf(jfloat  x);\n+  static jfloat  i2f (jint    x);\n@@ -135,1 +138,0 @@\n-  static jfloat  i2f (jint    x);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1235,1 +1235,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+#define INT32_FORMAT_X           \"0x%\"        PRIx32\n@@ -116,0 +117,1 @@\n+#define UINT32_FORMAT_X          \"0x%\"        PRIx32\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-import static java.io.ObjectStreamField.*;\n@@ -1596,1 +1595,1 @@\n-            appendClassSignature(sb, paramTypes[i]);\n+            sb.append(paramTypes[i].descriptorString());\n@@ -1599,1 +1598,1 @@\n-        appendClassSignature(sb, retType);\n+        sb.append(retType.descriptorString());\n@@ -1913,1 +1912,1 @@\n-            signature = getClassSignature(field.getType());\n+            signature = field.getType().descriptorString();\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1888,3 +1888,4 @@\n-     * Terminates the currently running Java Virtual Machine. The\n-     * argument serves as a status code; by convention, a nonzero status\n-     * code indicates abnormal termination.\n+     * Initiates the <a href=\"Runtime.html#shutdown\">shutdown sequence<\/a> of the\n+     * Java Virtual Machine. This method always blocks indefinitely. The argument\n+     * serves as a status code; by convention, a nonzero status code indicates\n+     * abnormal termination.\n@@ -1892,2 +1893,2 @@\n-     * This method calls the {@code exit} method in class\n-     * {@code Runtime}. This method never returns normally.\n+     * This method calls the {@code exit} method in class {@code Runtime}. This\n+     * method never returns normally.\n@@ -1895,2 +1896,1 @@\n-     * The call {@code System.exit(n)} is effectively equivalent to\n-     * the call:\n+     * The call {@code System.exit(n)} is effectively equivalent to the call:\n@@ -1901,5 +1901,5 @@\n-     * @param      status   exit status.\n-     * @throws  SecurityException\n-     *        if a security manager exists and its {@code checkExit}\n-     *        method doesn't allow exit with the specified status.\n-     * @see        java.lang.Runtime#exit(int)\n+     * @param  status exit status.\n+     * @throws SecurityException\n+     *         if a security manager exists and its {@code checkExit} method\n+     *         doesn't allow exit with the specified status.\n+     * @see    java.lang.Runtime#exit(int)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n- *      {@link java.nio.file.FileSystems#newFileSystem\n- *      FileSystems.newFileSystem(URI.create(\"jrt:\/\"))}.\n+ *      {@link java.nio.file.FileSystems#getFileSystem\n+ *      FileSystems.getFileSystem(URI.create(\"jrt:\/\"))}.\n@@ -167,0 +167,1 @@\n+        jdk.jfr,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3972,1 +3972,2 @@\n-        Map<Symbol,Symbol> callMap = new HashMap<>();\n+        \/\/ use LinkedHashMap so we generate errors deterministically\n+        Map<Symbol,Symbol> callMap = new LinkedHashMap<>();\n@@ -4001,1 +4002,1 @@\n-                log.error(TreeInfo.diagnosticPositionFor(ctor, tree),\n+                log.error(TreeInfo.diagnosticPositionFor(ctor, tree, false, t -> t.hasTag(IDENT)),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2316,1 +2316,2 @@\n-                    return isIntersectionOrUnionType(pt);\n+                    if (isIntersectionOrUnionType(pt))\n+                        return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+    private final TransTypes transTypes;\n@@ -120,0 +121,1 @@\n+        transTypes = TransTypes.instance(context);\n@@ -3551,4 +3553,2 @@\n-            Type eType = types.skipTypeVars(tree.expr.type, false);\n-            tree.expr.type = types.erasure(eType);\n-            if (eType.isCompound())\n-                tree.expr = make.TypeCast(types.erasure(iterableType), tree.expr);\n+            tree.expr.type = types.erasure(types.skipTypeVars(tree.expr.type, false));\n+            tree.expr = transTypes.coerce(attrEnv, tree.expr, types.erasure(iterableType));\n@@ -3557,1 +3557,1 @@\n-                                           eType,\n+                                           tree.expr.type,\n@@ -3559,0 +3559,1 @@\n+            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n@@ -3560,1 +3561,1 @@\n-                                            types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)),\n+                                            types.erasure(syms.iteratorType),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.function.Predicate;\n@@ -730,0 +731,5 @@\n+        return diagnosticPositionFor(sym, tree, returnNullIfNotFound, null);\n+    }\n+\n+    public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree, boolean returnNullIfNotFound,\n+            Predicate<? super JCTree> filter) {\n@@ -731,2 +737,2 @@\n-            DiagScanner(Symbol sym) {\n-                super(sym);\n+            DiagScanner(Symbol sym, Predicate<? super JCTree> filter) {\n+                super(sym, filter);\n@@ -736,2 +742,2 @@\n-                if (that.sym == sym) result = that;\n-                else super.visitIdent(that);\n+                if (!checkMatch(that, that.sym))\n+                    super.visitIdent(that);\n@@ -740,2 +746,2 @@\n-                if (that.sym == sym) result = that;\n-                else super.visitSelect(that);\n+                if (!checkMatch(that, that.sym))\n+                    super.visitSelect(that);\n@@ -744,1 +750,1 @@\n-        DiagScanner s = new DiagScanner(sym);\n+        DiagScanner s = new DiagScanner(sym, filter);\n@@ -757,0 +763,1 @@\n+        final Predicate<? super JCTree> filter;\n@@ -759,0 +766,3 @@\n+            this(sym, null);\n+        }\n+        DeclScanner(final Symbol sym, Predicate<? super JCTree> filter) {\n@@ -760,0 +770,1 @@\n+            this.filter = filter;\n@@ -768,2 +779,2 @@\n-            if (that.packge == sym) result = that;\n-            else super.visitTopLevel(that);\n+            if (!checkMatch(that, that.packge))\n+                super.visitTopLevel(that);\n@@ -772,1 +783,1 @@\n-            if (that.sym == sym) result = that;\n+            checkMatch(that, that.sym);\n@@ -776,2 +787,2 @@\n-            if (that.packge == sym) result = that;\n-            else super.visitPackageDef(that);\n+            if (!checkMatch(that, that.packge))\n+                super.visitPackageDef(that);\n@@ -780,2 +791,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitClassDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitClassDef(that);\n@@ -784,2 +795,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitMethodDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitMethodDef(that);\n@@ -788,2 +799,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitVarDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitVarDef(that);\n@@ -792,2 +803,10 @@\n-            if (that.type != null && that.type.tsym == sym) result = that;\n-            else super.visitTypeParameter(that);\n+            if (that.type == null || !checkMatch(that, that.type.tsym))\n+                super.visitTypeParameter(that);\n+        }\n+\n+        protected boolean checkMatch(JCTree that, Symbol thatSym) {\n+            if (thatSym == this.sym && (filter == null || filter.test(that))) {\n+                result = that;\n+                return true;\n+            }\n+            return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":39,"deletions":20,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -446,0 +446,1 @@\n+ -runtime\/cds\/appcds\/lambdaForm\/DefaultClassListLFInvokers.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        String logArg = \"-Xlog:cds=debug,cds+reloc=debug\";\n+        String logArg = \"-Xlog:cds=debug,cds+reloc=debug,cds+heap\";\n@@ -79,0 +79,6 @@\n+                        if (output.getOutput().contains(\"Trying to map heap\") || output.getOutput().contains(\"Loaded heap\")) {\n+                          \/\/ The native data in the RO\/RW regions have been relocated. If the CDS heap is\n+                          \/\/ mapped\/loaded, we must patch all the native pointers. (CDS heap is\n+                          \/\/ not supported on all platforms)\n+                          output.shouldContain(\"Patching native pointers in heap region\");\n+                        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ArchiveRelocationTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -622,2 +622,1 @@\n-    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java \\\n-    sun\/security\/tools\/keytool\/i18n.java\n+    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java\n@@ -627,1 +626,2 @@\n-    java\/util\/TimeZone\/DefaultTimeZoneTest.java\n+    java\/util\/TimeZone\/DefaultTimeZoneTest.java \\\n+    sun\/security\/tools\/keytool\/i18n.java\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}