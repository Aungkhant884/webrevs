{"files":[{"patch":"@@ -269,5 +269,1 @@\n-        if (getClass().isPrimitiveClass()) {\n-            return SharedSecrets.getJavaLangInvokeAccess().inlineObjectToString(this);\n-        } else {\n-            return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n-        }\n+        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1486,4 +1486,0 @@\n-            @Override\n-            public String inlineObjectToString(Object o) {\n-                return ValueBootstrapMethods.inlineObjectToString(o);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,2 +98,0 @@\n-            case \"toString\":\n-                return inlineTypeToString(valType);\n@@ -219,34 +217,0 @@\n-        static MethodHandle inlineTypeToString(Class<?> type) {\n-            assert type.isValueType();\n-            MethodHandle[] getters = MethodHandleBuilder.getters(type);\n-            int length = getters.length;\n-            StringBuilder format = new StringBuilder();\n-            Class<?>[] parameterTypes = new Class<?>[length];\n-            \/\/ append the value class name\n-            format.append(\"[\").append(type.getName());\n-            String separator = \" \";\n-            Lookup lookup = new MethodHandles.Lookup(type.asPrimaryType());\n-            for (int i = 0; i < length; i++) {\n-                MethodHandle getter = getters[i];\n-                Class<?> ftype = fieldType(getter);\n-                MethodHandleInfo fieldInfo = lookup.revealDirect(getter);\n-                format.append(separator)\n-                      .append(fieldInfo.getName())\n-                      .append(\"=\\1\");\n-                getters[i]= filterReturnValue(getter, MethodHandleBuilder.toString(ftype));\n-                parameterTypes[i] = String.class;\n-            }\n-            format.append(\"]\");\n-            try {\n-                MethodHandle target = StringConcatFactory.makeConcatWithConstants(lookup, \"toString\",\n-                        methodType(String.class, parameterTypes), format.toString()).dynamicInvoker();\n-                \/\/ apply getters\n-                target = filterArguments(target, 0, getters);\n-                \/\/ duplicate \"this\" argument from o::toString for each getter invocation\n-                target = permuteArguments(target, methodType(String.class, type), new int[length]);\n-                return target;\n-            } catch (StringConcatException e) {\n-                throw newLinkageError(e);\n-            }\n-\n-        }\n@@ -304,21 +268,0 @@\n-        private static String toString(Object o) {\n-            return o != null ? o.toString() : \"null\";\n-        }\n-\n-        private static MethodHandle toString(Class<?> type) {\n-            if (type.isArray()) {\n-                Class<?> componentType = type.getComponentType();\n-                if (componentType.isPrimitiveClass()) {\n-                    componentType = componentType.asValueType();\n-                }\n-                if (componentType.isPrimitive()) {\n-                    int index = Wrapper.forPrimitiveType(componentType).ordinal();\n-                    return ARRAYS_TO_STRING[index];\n-                } else {\n-                    return ARRAYS_TO_STRING[Wrapper.OBJECT.ordinal()].asType(methodType(String.class, type));\n-                }\n-            } else {\n-                return TO_STRING.asType(methodType(String.class, type));\n-            }\n-        }\n-\n@@ -341,1 +284,0 @@\n-        private static final MethodHandle[] ARRAYS_TO_STRING = initArraysToString();\n@@ -348,2 +290,0 @@\n-        static final MethodHandle TO_STRING =\n-            findStatic(\"toString\", methodType(String.class, Object.class));\n@@ -369,11 +309,0 @@\n-        private static MethodHandle[] initArraysToString() {\n-            MethodHandle[] mhs = new MethodHandle[Wrapper.COUNT];\n-            for (Wrapper wrapper : Wrapper.values()) {\n-                if (wrapper == Wrapper.VOID) continue;\n-\n-                Class<?> arrayType = wrapper.arrayType();\n-                mhs[wrapper.ordinal()] = findStatic(Arrays.class, \"toString\", methodType(String.class, arrayType));\n-            }\n-            return mhs;\n-        }\n-\n@@ -594,27 +523,0 @@\n-    \/**\n-     * Invoke the bootstrap methods hashCode for the given primitive class object.\n-     * @param o the instance to hash.\n-     * @return the string representation of the given primitive class object.\n-     *\/\n-    static String inlineObjectToString(Object o) {\n-        try {\n-            \/\/ Note: javac disallows user to call super.hashCode if user implementated\n-            \/\/ risk for recursion for experts crafting byte-code\n-            if (!o.getClass().isPrimitiveClass())\n-                throw new InternalError(\"must be primitive type: \" + o.getClass().getName());\n-            Class<?> type = o.getClass().asValueType();\n-            return (String) TOSTRING_METHOD_HANDLES.get(type).invoke(o);\n-        } catch (Error|RuntimeException e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            if (VERBOSE) e.printStackTrace();\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private static ClassValue<MethodHandle> TOSTRING_METHOD_HANDLES = new ClassValue<>() {\n-        @Override protected MethodHandle computeValue(Class<?> type) {\n-            return MethodHandleBuilder.inlineTypeToString(type.asValueType());\n-        }\n-    };\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ValueBootstrapMethods.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -125,2 +125,0 @@\n-    String inlineObjectToString(Object o);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-        Asserts.assertEQ(n.toString(), \"[MyValue6 foo=124]\");\n+        Asserts.assertEQ(n.toString(), \"MyValue6@\" + Integer.toHexString(n.hashCode()));\n@@ -406,1 +406,1 @@\n-        Asserts.assertEQ(n.toString(), \"[MyValue6Box foo=124]\");\n+        Asserts.assertEQ(n.toString(), \"MyValue6Box@\" + Integer.toHexString(n.hashCode()));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeArray.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        if (!v.toString().equals(\"[WithFieldAccessorTest$V c=b l=5 i=10]\")) {\n+        if (!v.toString().equals(\"WithFieldAccessorTest$V@\" + Integer.toHexString(v.hashCode()))) {\n@@ -61,1 +61,1 @@\n-        if (!v.toString().equals(\"[WithFieldAccessorTest$V c=a l=25 i=10]\")) {\n+        if (!v.toString().equals(\"WithFieldAccessorTest$V@\" + Integer.toHexString(v.hashCode()))) {\n@@ -65,1 +65,1 @@\n-        if (!v.toString().equals(\"[WithFieldAccessorTest$V c=a l=5 i=20]\")) {\n+        if (!v.toString().equals(\"WithFieldAccessorTest$V@\" + Integer.toHexString(v.hashCode()))) {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldAccessorTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @run testng\/othervm -Xcomp -Dvalue.bsm.salt=1 ObjectMethods\n@@ -32,0 +31,4 @@\n+\n+\/* To be enabled by JDK-8267932\n+ * @run testng\/othervm -Xcomp -Dvalue.bsm.salt=1 ObjectMethods\n+ *\/\n@@ -131,0 +134,1 @@\n+\n@@ -134,9 +138,4 @@\n-            { Point.makePoint(100, 200), \"[Point x=100 y=200]\" },\n-            { Line.makeLine(1, 2, 3, 4), \"[Line p1=[Point x=1 y=2] p2=[Point x=3 y=4]]\"},\n-            { VALUE,\n-              \"[Value char_v=z byte_v=1 boolean_v=false int_v=0 short_v=3 long_v=4 double_v=0.0 \" +\n-              \"float_v=0.0 number_v=[Value$IntValue i=10] point_v=[Point x=200 y=200] point_ref=null ref_v=null]\" },\n-            { VALUE1,\n-              \"[Value char_v=z byte_v=1 boolean_v=false int_v=0 short_v=3 long_v=4 double_v=0.0 \" +\n-              \"float_v=0.0 number_v=[Value$IntValue i=20] point_v=[Point x=100 y=100] \" +\n-              \"point_ref=[Point x=200 y=200] ref_v=[Point x=300 y=300]]\" },\n+            { Point.makePoint(100, 200)  },\n+            { Line.makeLine(1, 2, 3, 4) },\n+            { VALUE },\n+            { VALUE1 },\n@@ -145,3 +144,1 @@\n-                        .setNumber(new Value.IntNumber(99)).build(),\n-              \"[Value char_v=\\u0000 byte_v=0 boolean_v=false int_v=0 short_v=0 long_v=0 double_v=0.0 \" +\n-              \"float_v=0.0 number_v=99 point_v=[Point x=0 y=0] point_ref=null ref_v=[ref]]\" },\n+                        .setNumber(new Value.IntNumber(99)).build() },\n@@ -149,3 +146,3 @@\n-            { MyValue1.default, \"[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=null]\" },\n-            { new MyValue1(0,0, null), \"[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=null]\" },\n-            { new MyValue1(0,0, P1), \"[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=[Point x=1 y=2]]\" },\n+            { MyValue1.default },\n+            { new MyValue1(0,0, null) },\n+            { new MyValue1(0,0, P1) },\n@@ -156,2 +153,3 @@\n-    public void testToString(Object o, String s) {\n-        assertTrue(o.toString().equals(s), o.toString());\n+    public void testToString(Object o) {\n+        String expected = String.format(\"%s@%s\", o.getClass().getName(), Integer.toHexString(o.hashCode()));\n+        assertEquals(o.toString(), expected);\n@@ -178,0 +176,1 @@\n+        assertEquals(System.identityHashCode(o), hash);\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -63,5 +63,0 @@\n-        Method toString = test.getMethod(\"toString\", valueClass);\n-        String s = (String)toString.invoke(null, value);\n-        assertEquals(s, value.localToString());\n-        assertEquals(s, value.toString());\n-\n@@ -94,6 +89,0 @@\n-\n-        public String localToString() {\n-            System.out.println(l);\n-            return String.format(\"[%s i=%s d=%s s=%s l=%s]\", Value.class.getName(),\n-                                 i, String.valueOf(d), s, l.toString());\n-        }\n@@ -168,15 +157,0 @@\n-        mv = cw.visitMethod(\n-            ACC_PUBLIC + ACC_STATIC + ACC_FINAL,\n-            \"toString\",\n-            Type.getMethodDescriptor(Type.getType(String.class), type),\n-            null,\n-            null);\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInvokeDynamicInsn(\"toString\",\n-            Type.getMethodDescriptor(Type.getType(String.class), type),\n-            bootstrap,  type);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueBootstrapMethods.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        if (!o.toString().equals(\"[AnonymousValueType$1 x=10]\"))\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AnonymousValueType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        if (!p.toString().equals(\"[ChainedAssignmentTest$Point x=1234 y=1234]\"))\n+        if (!p.toString().equals(\"ChainedAssignmentTest$Point@\" + Integer.toHexString(p.hashCode())))\n@@ -54,1 +54,1 @@\n-        if (!lp.toString().equals(\"[ChainedAssignmentTest$LongPoint x=1234 y=1234]\"))\n+        if (!lp.toString().equals(\"ChainedAssignmentTest$LongPoint@\" + Integer.toHexString(lp.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ChainedAssignmentTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-\t\tString s = new CheckSeparateCompile0().new O().new M().new I().foo();\n-        if (!s.equals(\"[CheckSeparateCompile0$O$M$I i=0]\"))\n+        String s = new CheckSeparateCompile0().new O().new M().new I().foo();\n+        if (!s.startsWith(\"CheckSeparateCompile0$O$M$I@\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckSeparateCompile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-        String o = new CtorChain().toString();\n-        if (!o.equals(\"[CtorChain x1=10 x2=20 x3=30 x4=40 x5=50]\"))\n+        CtorChain o = new CtorChain();\n+        if (!o.toString().equals(\"CtorChain@\" + Integer.toHexString(o.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CtorChain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-        if (!new InlineClassTest().toString().equals(\"[InlineClassTest x=42]\"))\n+        Object o = new InlineClassTest();\n+        if (!o.toString().equals(\"InlineClassTest@\" + Integer.toHexString(o.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InlineClassTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        if (!toString.equals(\"[InlineDiamondTest$Y x=42]\"))\n+        if (!toString.equals(\"InlineDiamondTest$Y@\" + Integer.toHexString(is.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InlineDiamondTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        if (!i.toString().equals(\"[LubWithInlines$XNodeWrapper i=42]\"))\n+        if (!i.toString().equals(\"LubWithInlines$XNodeWrapper@\" + Integer.toHexString(i.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/LubWithInlines.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+        int aDotThisHash;\n@@ -37,0 +38,1 @@\n+            aDotThisHash = A.this.hashCode();\n@@ -42,0 +44,2 @@\n+\n+        int getADotThisHash() { return aDotThisHash; }\n@@ -51,2 +55,3 @@\n-        if (!new QualifiedSuperCtor(new A()).getADotThis().equals(\"[A x=1000000]\"))\n-            throw new AssertionError(\"Broken\");\n+        QualifiedSuperCtor o = new QualifiedSuperCtor(new A());\n+        if (!o.getADotThis().equals(\"A@\" + Integer.toHexString(o.getADotThisHash())))\n+            throw new AssertionError(\"Broken\" + o.getADotThis() + \" \" + o.getADotThisHash());\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/QualifiedSuperCtor.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        if (!v.toString().equals(\"[SideEffectTest$V x=1234]\"))\n+        if (!v.toString().equals(\"SideEffectTest$V@\" + Integer.toHexString(v.hashCode())))\n@@ -63,1 +63,1 @@\n-        if (!v.toString().equals(\"[SideEffectTest$V x=8765]\"))\n+        if (!v.toString().equals(\"SideEffectTest$V@\" + Integer.toHexString(v.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SideEffectTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        if (!testValue1.toString().equals(\"[TestValue1 x=42]\"))\n+        if (!testValue1.toString().equals(\"TestValue1@\" + Integer.toHexString(testValue1.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TestQualifierOnInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-            return String.format(\"[%s i=%s d=%s s=%s l=%s]\", Value.class.getName(),\n-                                 i, String.valueOf(d), s, l.toString());\n+            return String.format(\"%s@%s\", Value.class.getName(), Integer.toHexString(localHashCode()));\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ValueBootstrapMethodsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        if (!x.toString().equals(\"[ValueConstructorRef x=1234 y=5678]\"))\n+        if (!x.toString().equals(\"ValueConstructorRef@\" + Integer.toHexString(x.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ValueConstructorRef.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        if (!v.toString().equals(\"[WithFieldAccessorTest$V i=20]\"))\n+        if (!v.toString().equals(\"WithFieldAccessorTest$V@\" + Integer.toHexString(v.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/WithFieldAccessorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-     if (!w.toString().equals(\"[WithFieldOfGenericType value=true]\"))\n+     if (!w.toString().equals(\"WithFieldOfGenericType@\" + Integer.toHexString(w.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/WithFieldOfGenericType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}