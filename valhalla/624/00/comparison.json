{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,68 +70,5 @@\n-    \/*\n-     * VarHandle of Object[].class\n-     *\/\n-    @Test\n-    public void testObjectArrayVarHandle() throws Throwable {\n-        \/\/ Point[] <: Point.ref[] <: Object\n-        Object[] array1 = newArray(Object[].class, POINTS.length);\n-        setElements(array1, POINTS);\n-        setElements(array1, NULL_POINTS);\n-        setElements(array1, new Object[] { \"abc\", Point.makePoint(1, 2) });\n-\n-        Point.ref[] array2 = new Point.ref[NULL_POINTS.length];\n-        setElements(array2, POINTS);\n-        setElements(array2, NULL_POINTS);\n-\n-        Point[] array3 = new Point[POINTS.length];\n-        setElements(array3, POINTS);\n-    }\n-\n-    \/*\n-     * VarHandle of Point.ref[].class\n-     *\/\n-    @Test\n-    public void testPointRefVarHandle() throws Throwable {\n-        \/\/ Point[] <: Point.ref[] <: Object\n-        Point.ref[] array1 = (Point.ref[])newArray(Point.ref[].class, POINTS.length);\n-        assertTrue(array1.getClass().componentType() == Point.ref.class);\n-\n-        setElements(array1, POINTS);\n-        setElements(array1, NULL_POINTS);\n-\n-        Point.ref[] array2 = new Point.ref[NULL_POINTS.length];\n-        setElements(array2, POINTS);\n-        setElements(array2, NULL_POINTS);\n-\n-        Point[] array3 = new Point[POINTS.length];\n-        setElements(array3, POINTS);\n-    }\n-\n-    \/*\n-     * VarHandle of Point[].class\n-     *\/\n-    @Test\n-    public void testPointArrayVarHandle()  throws Throwable {\n-        \/\/ Point[] <: Point.ref[] <: Object\n-        Point[] array1 = (Point[]) newArray(Point[].class, POINTS.length);\n-        assertTrue(array1.getClass().componentType() == Point.class.asValueType());\n-        setElements(array1, POINTS);\n-\n-        Point[] array3 = new Point[POINTS.length];\n-        setElements(array3, POINTS);\n-    }\n-\n-    \/*\n-     * VarHandle of Line.ref[].class\n-     *\/\n-    @Test\n-    public void testLineRefVarHandle() throws Throwable {\n-        \/\/ Line[] <: Line.ref[]\n-        Line.ref[] array1 = (Line.ref[])newArray(Line.ref[].class, LINES.length);\n-        assertTrue(array1.getClass().componentType() == Line.ref.class);\n-\n-        setElements(array1, LINES);\n-        setElements(array1, NULL_LINES);\n-\n-        Line.ref[] array2 = new Line.ref[LINES.length];\n-        setElements(array2, LINES);\n-        setElements(array2, NULL_LINES);\n+    private static final ValueOptional[] VALUES = new ValueOptional[]{\n+            new ValueOptional(null),\n+            new ValueOptional(P),\n+            null\n+    };\n@@ -139,2 +76,35 @@\n-        Line[] array3 = new Line[LINES.length];\n-        setElements(array3, LINES);\n+    @DataProvider(name=\"data\")\n+    static Object[][] data() throws Throwable {\n+        int plen = POINTS.length;\n+        int llen = LINES.length;\n+        int vlen = VALUES.length;\n+        return new Object[][]{\n+                \/\/ Point[] <: Point.ref[] <: Object[]\n+                new Object[] { newArray(Object[].class, plen),    POINTS },\n+                new Object[] { newArray(Object[].class, plen),    NULL_POINTS },\n+                new Object[] { newArray(Object[].class, plen),    new Object[] { \"abc\", Point.makePoint(1, 2) } },\n+                new Object[] { newArray(Point.ref[].class, plen), NULL_POINTS },\n+                new Object[] { newArray(Point[].class, plen),     POINTS },\n+                new Object[] { new Point.ref[plen],               POINTS },\n+                new Object[] { new Point.ref[plen],               NULL_POINTS },\n+                new Object[] { new Point[plen],                   POINTS },\n+\n+                \/\/ Line[] <: Line.ref[]\n+                new Object[] { newArray(Object[].class, llen),    LINES },\n+                new Object[] { newArray(Object[].class, llen),    NULL_LINES },\n+                new Object[] { newArray(Object[].class, llen),    LINES },\n+                new Object[] { newArray(Line.ref[].class, llen),  NULL_LINES },\n+                new Object[] { newArray(Line[].class, llen),      LINES },\n+                new Object[] { new Line.ref[llen],                LINES },\n+                new Object[] { new Line.ref[llen],                NULL_LINES },\n+                new Object[] { new Line[llen],                    LINES },\n+\n+                \/\/ value class\n+                new Object[] { newArray(Object[].class, vlen),        VALUES },\n+                new Object[] { newArray(ValueOptional[].class, vlen), VALUES },\n+                new Object[] { new ValueOptional[vlen],               VALUES },\n+\n+                \/\/ non flattened values\n+                new Object[] { newArray(NonFlattenValue[].class, NFV_ARRAY.length), NFV_ARRAY },\n+                new Object[] { new NonFlattenValue[NFV_ARRAY.length], NFV_ARRAY }\n+        };\n@@ -144,1 +114,2 @@\n-     * VarHandle of Line[].class\n+     * Test VarHandle to set elements of the given array with\n+     * various access mode.\n@@ -146,8 +117,3 @@\n-    @Test\n-    public void testLineVarHandle() throws Throwable {\n-        Line[] array1 = (Line[])newArray(Line[].class, LINES.length);\n-        assertTrue(array1.getClass().componentType() == Line.class.asValueType());\n-        setElements(array1, LINES);\n-\n-        Line[] array3 = new Line[LINES.length];\n-        setElements(array3, LINES);\n+    @Test(dataProvider = \"data\")\n+    public void testSetArrayElements(Object[] array, Object[] data) throws Throwable {\n+        setElements(array, data);\n@@ -157,1 +123,2 @@\n-     * VarHandle of NonFlattenValue[].class\n+     * Constructs a new array of the specified type and size using\n+     * MethodHandle.\n@@ -159,11 +126,1 @@\n-    @Test\n-    public void testNonFlattenedValueVarHandle() throws Throwable {\n-        NonFlattenValue[] array1 = (NonFlattenValue[])newArray(NonFlattenValue[].class, NFV_ARRAY.length);\n-        assertTrue(array1.getClass().componentType() == NonFlattenValue.class.asValueType());\n-        setElements(array1, NFV_ARRAY);\n-\n-        NonFlattenValue[] array3 = new NonFlattenValue[POINTS.length];\n-        setElements(array3, NFV_ARRAY);\n-    }\n-\n-    Object[] newArray(Class<?> arrayType, int size) throws Throwable {\n+    static Object[] newArray(Class<?> arrayType, int size) throws Throwable {\n@@ -174,0 +131,4 @@\n+    \/*\n+     * Sets the given array with the given elements.\n+     * This tests several VarHandle access mode.\n+     *\/\n@@ -270,2 +231,0 @@\n-\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/ArrayElementVarHandleTest.java","additions":53,"deletions":94,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -59,1 +59,3 @@\n-                new Object[] { \"MixedValues\", mv, new String[] {\"p\", \"l\", \"mutablePath\", \"list\", \"nfp\"} },\n+                \/\/ identity class whose non-final fields are of primitive value type,\n+                \/\/ primitive reference type, reference type and value class\n+                new Object[] { \"MixedValues\", mv, new String[] {\"p\", \"l\", \"mutablePath\", \"list\", \"nfp\", \"voptional\"} },\n@@ -83,1 +85,1 @@\n-            if (c.isPrimitiveClass())\n+            if (c.isValue())\n@@ -108,0 +110,1 @@\n+        ValueOptional v = new ValueOptional(P);\n@@ -116,0 +119,2 @@\n+        setField(MixedValues.class, \"voptional\", mv, v, false);\n+        \/\/ static fields of reference type\n@@ -118,0 +123,1 @@\n+        setField(MixedValues.class, \"staticValue\", null, v, false);\n@@ -229,1 +235,1 @@\n-    static void setField(Class<?> c, String name, Object obj, Object value, boolean isValue) throws Throwable {\n+    static void setField(Class<?> c, String name, Object obj, Object value, boolean isPrimitiveValue) throws Throwable {\n@@ -232,2 +238,2 @@\n-        assertTrue(f.getType().isPrimitiveClass());\n-        assertTrue(f.getType().isPrimitiveValueType() == isValue);\n+        assertTrue(f.getType().isValue());\n+        assertTrue(f.getType().isPrimitiveValueType() == isPrimitiveValue);\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+    static ValueOptional staticValue;\n@@ -34,0 +35,1 @@\n+    ValueOptional voptional;\n@@ -41,0 +43,1 @@\n+        this.voptional = new ValueOptional(p);\n","filename":"test\/jdk\/valhalla\/valuetypes\/MixedValues.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,0 +103,3 @@\n+            { new ValueRecord(50, \"fifty\"), new ValueRecord(50, \"fifty\"), true},\n+            { new ValueOptional(LINE1), new ValueOptional(LINE1), true},\n+            { new ValueOptional(List.of(P1)), new ValueOptional(List.of(P1)), false},\n@@ -146,0 +149,2 @@\n+            { ValueOptional.default },\n+            { new ValueOptional(P1) },\n@@ -173,0 +178,1 @@\n+            { new ValueOptional(P1), hash(ValueOptional.class, P1) },\n@@ -268,0 +274,2 @@\n+    static value record ValueRecord(int i, String name) {}\n+\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,0 +85,22 @@\n+    @Test\n+    public static void testValueOptionalClass() throws Exception  {\n+        Point point = Point.makePoint(10,20);\n+        Constructor<ValueOptional> ctor = ValueOptional.class.getDeclaredConstructor(Object.class);\n+        ValueOptional o = ctor.newInstance(point);\n+        assertEquals(o.getClass(), ValueOptional.class);\n+\n+        Field field = ValueOptional.class.getDeclaredField(\"o\");\n+        \/\/ accessible but no write access\n+        field.trySetAccessible();\n+        assertTrue(field.isAccessible());\n+\n+        if (field.get(o) != point) {\n+            fail(\"Unexpected ValueOptional.o value: \" +  field.get(o));\n+        }\n+        try {\n+            field.set(o, point);\n+            fail(\"IllegalAccessException not thrown\");\n+        } catch (IllegalAccessException e) {}\n+\n+        checkToString(field);\n+    }\n@@ -104,0 +126,3 @@\n+        if (Modifier.isPrivate(mods)) {\n+            sb.append(\"private\").append(\" \");\n+        }\n","filename":"test\/jdk\/valhalla\/valuetypes\/Reflection.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm StaticFactoryMethodHandleTest\n+ * @run testng\/othervm StaticFactoryMethodHandleTest\n@@ -40,0 +40,6 @@\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.invoke.MethodType.*;\n+import static org.testng.Assert.*;\n+\n@@ -64,0 +70,55 @@\n+    static value class Value implements Cons {\n+        int x;\n+        public Value(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    \/*\n+     * Test no-arg static factory\n+     *\/\n+    @Test\n+    public void testNoArgStaticFactory() throws Throwable {\n+        \/\/ test default static init factory\n+        Class<? extends Cons> cls = (Class<? extends Cons>)DefaultConstructor.class.asValueType();\n+        MethodHandle mh = staticInitFactory(cls, methodType(cls));\n+        DefaultConstructor o = (DefaultConstructor)mh.invokeExact();\n+        assertEquals(o, new DefaultConstructor());\n+        assertEquals(o, newInstance(cls, 0, new Class<?>[0]));\n+    }\n+\n+    @DataProvider(name=\"ctorWithArgs\")\n+    static Object[][] ctorWithArgs() {\n+        Class<? extends Cons> cls = (Class<? extends Cons>)ConstructorWithArgs.class.asValueType();\n+        return new Object[][]{\n+                new Object[] { cls, methodType(cls, int.class), Modifier.PUBLIC, new ConstructorWithArgs(1) },\n+                new Object[] { cls, methodType(cls, int.class, int.class), 0, new ConstructorWithArgs(1, 2) },\n+                new Object[] { cls, methodType(cls, int.class, int.class, int.class), Modifier.PRIVATE, new ConstructorWithArgs(1, 2, 3) },\n+        };\n+    }\n+\n+    \/*\n+     * Test static factory with args\n+     *\/\n+    @Test(dataProvider=\"ctorWithArgs\")\n+    public void testStaticFactoryWithArgs(Class<? extends Cons> c, MethodType mtype, int modifiers, ConstructorWithArgs o) throws Throwable {\n+        MethodHandle mh = staticInitFactory(c, mtype);\n+        ConstructorWithArgs o1;\n+        Object o2;\n+        switch (mtype.parameterCount()) {\n+            case 1: o1 = (ConstructorWithArgs)mh.invokeExact(1);\n+                    o2 = newInstance(c, modifiers, mtype.parameterArray(), 1);\n+                    break;\n+            case 2: o1 = (ConstructorWithArgs)mh.invokeExact(1, 2);\n+                    o2 = newInstance(c, modifiers, mtype.parameterArray(), 1, 2);\n+                    break;\n+            case 3: o1 = (ConstructorWithArgs)mh.invokeExact(1, 2, 3);\n+                    o2 = newInstance(c, modifiers, mtype.parameterArray(), 1, 2, 3);\n+                    break;\n+            default:\n+                    throw new IllegalArgumentException(c + \" \" + mtype);\n+        }\n+\n+        assertEquals(o1, o);\n+        assertEquals(o1, o2);\n+    }\n@@ -65,1 +126,2 @@\n-    public static void main(String... args) throws Throwable {\n+    @Test\n+    public void testValueClasstaticFactory() throws Throwable {\n@@ -67,28 +129,5 @@\n-        MethodType mtype0 = MethodType.methodType(DefaultConstructor.class.asValueType());\n-        MethodHandle mh0 = staticInitFactory(DefaultConstructor.val.class, mtype0);\n-        DefaultConstructor o0 = (DefaultConstructor)mh0.invokeExact();\n-        assertEquals(o0, new DefaultConstructor());\n-        assertEquals(o0, newInstance(DefaultConstructor.val.class, 0, mh0.type().parameterArray()));\n-\n-        \/\/ test 1-arg static init factory\n-        MethodType mtype1 = MethodType.methodType(ConstructorWithArgs.class.asValueType(), int.class);\n-        MethodHandle mh1 = staticInitFactory(ConstructorWithArgs.val.class, mtype1);\n-        ConstructorWithArgs o1 = (ConstructorWithArgs)mh1.invokeExact(1);\n-        assertEquals(o1, new ConstructorWithArgs(1));\n-        assertEquals(o1, newInstance(ConstructorWithArgs.val.class, Modifier.PUBLIC, mh1.type().parameterArray(), 1));\n-\n-\n-        \/\/ test 2-arg static init factory\n-        MethodType mtype2 = MethodType.methodType(ConstructorWithArgs.class.asValueType(), int.class, int.class);\n-        MethodHandle mh2 = staticInitFactory(ConstructorWithArgs.val.class, mtype2);\n-        ConstructorWithArgs o2 = (ConstructorWithArgs)mh2.invokeExact(1, 2);\n-        assertEquals(o2, new ConstructorWithArgs(1, 2));\n-        assertEquals(o2, newInstance(ConstructorWithArgs.val.class, 0, mh2.type().parameterArray(), 1, 2));\n-\n-\n-        \/\/ test 3-arg static init factory\n-        MethodType mtype3 = MethodType.methodType(ConstructorWithArgs.class.asValueType(), int.class, int.class, int.class);\n-        MethodHandle mh3 = staticInitFactory(ConstructorWithArgs.val.class, mtype3);\n-        ConstructorWithArgs o3 = (ConstructorWithArgs)mh3.invokeExact(1, 2, 3);\n-        assertEquals(o3, new ConstructorWithArgs(1, 2, 3));\n-        assertEquals(o3, newInstance(ConstructorWithArgs.val.class, Modifier.PRIVATE, mh3.type().parameterArray(), 1, 2, 3));\n+        MethodType mtype = methodType(Value.class, int.class);\n+        MethodHandle mh = staticInitFactory(Value.class, mtype);\n+        Value o = (Value)mh.invokeExact(10);\n+        assertEquals(o, new Value(10));\n+        assertEquals(o, newInstance(Value.class, Modifier.PUBLIC, mtype.parameterArray(), 10));\n@@ -164,14 +203,0 @@\n-\n-    static void assertTrue(boolean v) {\n-        if (!v) {\n-            throw new AssertionError(\"expected true\");\n-        }\n-    }\n-\n-    static void assertEquals(Object o1, Object o2) {\n-        if (o1 == o2) return;\n-\n-        if (!o1.equals(o2)) {\n-            throw new AssertionError(o1 + \" != \" + o2);\n-        }\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryMethodHandleTest.java","additions":70,"deletions":45,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary Test reflection of constructors for primitive classes\n+ * @summary Test reflection of constructors for value classes\n@@ -30,1 +30,0 @@\n- * @run testng\/othervm -Dsun.reflect.noInflation=true StaticFactoryTest\n@@ -41,0 +40,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -58,1 +58,2 @@\n-    static final Class<?> PRIMITIVE_TYPE = SimplePrimitive.class.asValueType();\n+    static value class SimpleValue {\n+        private final SimplePrimitive v;\n@@ -60,4 +61,8 @@\n-    @Test\n-    public static void testPrimitiveClassConstructor() throws Exception {\n-        String cn = PRIMITIVE_TYPE.getName();\n-        Class<?> c = Class.forName(cn).asValueType();\n+        SimpleValue() {\n+            this.v = SimplePrimitive.default;\n+        }\n+\n+        public SimpleValue(SimplePrimitive v) {\n+            this.v = v;\n+        }\n+    }\n@@ -65,2 +70,6 @@\n-        assertTrue(c.isPrimitiveClass());\n-        assertTrue(c == PRIMITIVE_TYPE);\n+    @DataProvider\n+    static Object[][] classes() {\n+        return new Object[][]{\n+                new Object[] { SimplePrimitive.class, true },\n+                new Object[] { SimpleValue.class, false },\n+        };\n@@ -69,3 +78,9 @@\n-    @Test\n-    public static void constructor() throws Exception {\n-        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n+    @Test(dataProvider = \"classes\")\n+    public void testConstructor(Class<?> c, boolean isPrimitiveClass) throws ReflectiveOperationException {\n+        String cn = c.getName();\n+        Class<?> clz = Class.forName(cn);\n+\n+        assertTrue(clz.isValue());\n+        assertTrue(clz.isPrimitiveClass() == isPrimitiveClass);\n+\n+        Constructor<?> ctor = clz.getDeclaredConstructor();\n@@ -73,1 +88,23 @@\n-        assertTrue(o.getClass() == PRIMITIVE_TYPE.asPrimaryType());\n+        assertTrue(o.getClass() == c);\n+\n+        \/\/ Verify that the constructor and field can be set accessible\n+        ctor.setAccessible(true);\n+        assertTrue(ctor.trySetAccessible());\n+\n+        \/\/ Check that getDeclaredMethods does not include the static factory method\n+        Method[] methods = clz.getDeclaredMethods();\n+        for (Method m : methods) {\n+            if (Modifier.isStatic(m.getModifiers())) {\n+                assertFalse(m.getName().equals(\"<init>\"));\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] ctors() {\n+        return new Object[][]{\n+                new Object[] { SimplePrimitive.class, Set.of(\"public StaticFactoryTest$SimplePrimitive(int)\",\n+                                                             \"StaticFactoryTest$SimplePrimitive()\")},\n+                new Object[] { SimpleValue.class, Set.of(\"public StaticFactoryTest$SimpleValue(StaticFactoryTest$SimplePrimitive)\",\n+                                                         \"StaticFactoryTest$SimpleValue()\") },\n+        };\n@@ -77,5 +114,3 @@\n-    @Test\n-    public static void constructors() throws Exception {\n-        Set<String> expectedSig = Set.of(\"public StaticFactoryTest$SimplePrimitive(int)\",\n-                                         \"StaticFactoryTest$SimplePrimitive()\");\n-        Constructor<? extends Object>[] cons = PRIMITIVE_TYPE.getDeclaredConstructors();\n+    @Test(dataProvider = \"ctors\")\n+    public static void constructors(Class<?> c, Set<String> signatures) throws ReflectiveOperationException {\n+        Constructor<?>[] cons = c.getDeclaredConstructors();\n@@ -84,1 +119,1 @@\n-        boolean ok = expectedSig.equals(actualSig);\n+        boolean ok = signatures.equals(actualSig);\n@@ -86,1 +121,1 @@\n-            System.out.printf(\"expected: %s%n\", expectedSig);\n+            System.out.printf(\"expected: %s%n\", signatures);\n@@ -92,18 +127,6 @@\n-    \/\/ Check that the constructor and field can be set accessible\n-    @Test\n-    public static void setAccessible() throws Exception {\n-        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n-        ctor.setAccessible(true);\n-\n-        Field field = PRIMITIVE_TYPE.getField(\"x\");\n-        field.setAccessible(true);\n-    }\n-\n-    \/\/ Check that the constructor and field can be set accessible\n-    @Test\n-    public static void trySetAccessible() throws Exception {\n-        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n-        assertTrue(ctor.trySetAccessible());\n-\n-        Field field = PRIMITIVE_TYPE.getField(\"x\");\n-        assertTrue(field.trySetAccessible());\n+    @DataProvider\n+    static Object[][] fields() throws ReflectiveOperationException {\n+        return new Object[][]{\n+                new Object[] { SimplePrimitive.class.getDeclaredField(\"x\"), new SimplePrimitive(), 200},\n+                new Object[] { SimpleValue.class.getDeclaredField(\"v\"), new SimpleValue(), new SimplePrimitive(10) },\n+        };\n@@ -113,3 +136,3 @@\n-    @Test(expectedExceptions = IllegalAccessException.class)\n-    public static void setFinalField() throws Exception {\n-        Field field = PRIMITIVE_TYPE.getField(\"x\");\n+    @Test(dataProvider = \"fields\", expectedExceptions = IllegalAccessException.class)\n+    public static void readOnlyFields(Field field, Object obj, Object newValue) throws ReflectiveOperationException {\n+        \/\/ succeeds to set accessible flag\n@@ -117,3 +140,1 @@\n-        field.setInt(new SimplePrimitive(100), 200);\n-    }\n-\n+        assertTrue(field.trySetAccessible());\n@@ -121,8 +142,5 @@\n-    \/\/ Check that the class does not have a static method with the name <init>\n-    @Test\n-    public static void initFactoryNotMethods() {\n-        Method[] methods = PRIMITIVE_TYPE.getDeclaredMethods();\n-        for (Method m : methods) {\n-            if (Modifier.isStatic(m.getModifiers())) {\n-                assertFalse(m.getName().equals(\"<init>\"));\n-            }\n+        \/\/ value class' final fields cannot be modified\n+        if (field.getType() == int.class) {\n+            field.setInt(obj, ((Integer) newValue).intValue());\n+        } else {\n+            field.set(obj, newValue);\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryTest.java","additions":70,"deletions":52,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -43,1 +44,2 @@\n-            values[i] = new Value(i, new Point(i,i*2), (i%2) == 0 ? null : new Point(i*10, i*20));\n+            values[i] = new Value(i, new Point(i,i*2), (i%2) == 0 ? null : new Point(i*10, i*20),\n+                                  List.of(new X(i), new X(i*10)));\n@@ -76,0 +78,11 @@\n+    @Test\n+    public void testValue() {\n+        long count = Arrays.stream(values)\n+                           .map(Value.ref::list)\n+                           .flatMap(List::stream)\n+                           .map(X::x)\n+                           .filter(x -> x >= 10)\n+                           .count();\n+        assertEquals(count, values.length-1);\n+    }\n+\n@@ -80,1 +93,2 @@\n-        Value(int i, Point p, Point.ref np) {\n+        List<X> list;\n+        Value(int i, Point p, Point.ref np, List<X> list) {\n@@ -84,0 +98,1 @@\n+            this.list = list;\n@@ -95,0 +110,12 @@\n+\n+        List<X> list() { return list; }\n+    }\n+\n+    static value class X {\n+        private int x;\n+        X(int x) {\n+            this.x = x;\n+        }\n+        int x() {\n+            return x;\n+        }\n","filename":"test\/jdk\/valhalla\/valuetypes\/StreamTest.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            new Object[] { Point.class.asValueType(), new Point(0,0) },\n+            new Object[] { Point.class.asValueType(), Point.default },\n@@ -44,0 +44,1 @@\n+            new Object[] { ValueOptional.class, null },\n@@ -46,0 +47,4 @@\n+\n+    \/*\n+     * Test an array created from the given element type via Array::newInstance\n+     *\/\n@@ -47,2 +52,2 @@\n-    public void testPrimitiveElementType(Class<?> elementType, Object defaultValue) {\n-        assertTrue(elementType.isPrimitiveClass());\n+    public void testElementType(Class<?> elementType, Object defaultValue) {\n+        assertTrue(elementType.isValue());\n@@ -91,0 +96,1 @@\n+            new Object[] { ValueOptional[].class,  new ValueOptional[0] },\n@@ -94,0 +100,6 @@\n+    \/*\n+     * Test the following properties of an array of value class:\n+     * - class name\n+     * - array element can be null or not\n+     * - array covariance if the element type is a primitive value type\n+     *\/\n@@ -124,1 +136,1 @@\n-     * NPE will be thrown if null is set on an element in an array of value type\n+     * NPE will be thrown if null is set on an element in an array of primitive value type\n@@ -225,1 +237,1 @@\n-    static void testPointArray() {\n+    static void testInstanceOf() {\n@@ -228,0 +240,1 @@\n+        ValueOptional[] vArray = new ValueOptional[0];\n@@ -232,0 +245,1 @@\n+        assertTrue(vArray instanceof ValueOptional[]);\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueArray.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+            new Object[] { ValueOptional.class, ClassDesc.ofDescriptor(\"LValueOptional;\"), \"ValueOptional\"},\n+            new Object[] { ValueOptional[].class, ClassDesc.ofDescriptor(\"[LValueOptional;\"), \"ValueOptional[]\"},\n+            new Object[] { ValueOptional[][].class, ClassDesc.ofDescriptor(\"[[LValueOptional;\"), \"ValueOptional[][]\"},\n@@ -72,1 +75,2 @@\n-            new Object[] { Point.ref.class }\n+            new Object[] { Point.ref.class },\n+            new Object[] { ValueOptional.class }\n@@ -95,0 +99,2 @@\n+                new Object[] { ValueOptional.class, \"LValueOptional;\"},\n+                new Object[] { ValueOptional[].class, \"[LValueOptional;\"},\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueConstantDesc.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}