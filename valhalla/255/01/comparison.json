{"files":[{"patch":"@@ -3361,0 +3361,14 @@\n+\n+  Label notRestricted;\n+  __ movl(rdx, flags);\n+  __ shrl(rdx, ConstantPoolCacheEntry::has_restricted_type_shift);\n+  __ andl(rdx, 0x1);\n+  __ testl(rdx, rdx);\n+  __ jcc(Assembler::zero, notRestricted);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::check_restricted_type));\n+  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+\n+  __ bind(notRestricted);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -1373,0 +1373,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1468,0 +1470,12 @@\n+      } else if (attribute_name == vmSymbols::tag_restricted_field()) {\n+        check_property(\n+          attribute_length == 2,\n+          \"Invalid RestrictedField field attribute length %u in class file %s\",\n+          attribute_length, CHECK);\n+          const u2 type_index = cfs->get_u2_fast();\n+          check_property(valid_symbol_at(type_index),\n+                         \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                          type_index, CHECK);\n+          *restricted_field_info = type_index;\n+          *has_restricted_type = true;\n+          set_has_restricted_fields();\n@@ -1660,0 +1674,2 @@\n+  _restricted_field_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1690,0 +1706,1 @@\n+\n@@ -1722,0 +1739,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1731,0 +1750,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1765,0 +1786,9 @@\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1768,1 +1798,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1770,0 +1800,3 @@\n+    _restricted_field_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1772,3 +1805,2 @@\n-    \/\/ Remember how many oops we encountered and compute allocation type\n-    const FieldAllocationType atype = fac->update(is_static, type, type == T_INLINE_TYPE);\n-    field->set_allocation_type(atype);\n+    \/\/ \/\/ Remember how many oops we encountered\n+    fac->update(is_static, type, type == T_INLINE_TYPE);\n@@ -1817,3 +1849,2 @@\n-      \/\/ Remember how many oops we encountered and compute allocation type\n-      const FieldAllocationType atype = fac->update(false, type, false);\n-      field->set_allocation_type(atype);\n+      \/\/ Remember how many oops we encountered\n+      fac->update(false, type, false);\n@@ -1821,0 +1852,1 @@\n+      _restricted_field_info->append(0);\n@@ -1824,0 +1856,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1831,2 +1864,2 @@\n-    const FieldAllocationType atype = fac->update(true, type, false);\n-    field->set_allocation_type(atype);\n+    \/\/ Remember how many oops we encountered\n+    fac->update(true, type, false);\n@@ -1834,0 +1867,1 @@\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1836,0 +1870,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1844,2 +1881,2 @@\n-    const FieldAllocationType atype = fac->update(false, type, false);\n-    field->set_allocation_type(atype);\n+    \/\/ Remember how many oops we encountered\n+    fac->update(false, type, false);\n@@ -1847,0 +1884,1 @@\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -5869,0 +5907,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_erased_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _restricted_field_info->at(i);\n+    }\n+  }\n+\n@@ -6067,0 +6113,1 @@\n+  _restricted_field_info(NULL),\n@@ -6106,0 +6153,1 @@\n+  _has_restricted_fields(false),\n@@ -6684,0 +6732,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6686,1 +6735,0 @@\n-      \/\/ Pre-load inline class\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":61,"deletions":13,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  GrowableArray<u2>* _restricted_field_info;\n@@ -216,0 +217,1 @@\n+  bool _has_restricted_fields;\n@@ -285,0 +287,2 @@\n+                              u2* restricted_field_info,\n+                              bool* has_restricted_type,\n@@ -630,0 +634,2 @@\n+  void set_has_restricted_fields() { _has_restricted_fields = true; }\n+  bool has_restricted_fields() const { return _has_restricted_fields; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -536,1 +536,1 @@\n-                                       Array<u2>* fields, bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,\n+                                       Array<u2>* fields,  bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+  template(tag_restricted_field,                      \"RestrictedField\")                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -525,0 +525,23 @@\n+JRT_ENTRY(void, InterpreterRuntime::check_restricted_type(JavaThread* thread))\n+  LastFrameAccessor last_frame(thread);\n+  ConstantPoolCacheEntry* cp_entry = last_frame.cache_entry();\n+  int offset = cp_entry->f2_as_offset();\n+  InstanceKlass* holder = InstanceKlass::cast(cp_entry->f1_as_klass());\n+  fieldDescriptor fd;\n+  bool is_static = last_frame.bytecode().code() == Bytecodes::_putstatic;\n+  holder->find_field_from_offset(offset, is_static, &fd);\n+  Klass* field_klass = holder->get_inline_type_field_klass_or_null(fd.index());\n+  if (field_klass == NULL) {\n+    field_klass = SystemDictionary::resolve_or_fail(holder->field_signature(fd.index())->fundamental_name(THREAD),\n+        Handle(THREAD, holder->class_loader()),\n+        Handle(THREAD, holder->protection_domain()),\n+        true, CHECK);\n+    holder->set_inline_type_field_klass(fd.index(), field_klass);\n+  }\n+  assert(field_klass != NULL, \"Must have been set\");\n+  oop value = cast_to_oop(*last_frame.get_frame().interpreter_frame_tos_at(0));\n+  assert(value != NULL, \"Inline types cannot be NULL\");\n+  Klass* value_klass = value->klass();\n+  assert(value_klass->is_subtype_of(field_klass), \"Just checking\");\n+JRT_END\n+\n@@ -955,0 +978,1 @@\n+    info.has_restricted_type(),\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  static void check_restricted_type(JavaThread* thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+                                       bool has_restricted_type,\n@@ -149,1 +150,2 @@\n-                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),\n+                  ((is_inline_type ? 1 : 0) << is_inline_type_shift) |\n+                  ((has_restricted_type ? 1 : 0) << has_restricted_type_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-\/\/ _flags     [tos|0|F=1|0|I|i|f|v|0 |0000|field_index] (for field entries)\n+\/\/ _flags     [tos|0|F=1|R|I|i|f|v|0 |0000|field_index] (for field entries)\n@@ -188,0 +188,1 @@\n+    has_restricted_type_shift  = 25,  \/\/ (R) does the field have a restricted type?\n@@ -233,0 +234,1 @@\n+    bool            has_restricted_type,         \/\/ field has a restricted type\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,8 +49,5 @@\n-#define FIELDINFO_TAG_SIZE             3\n-#define FIELDINFO_TAG_BLANK            0\n-#define FIELDINFO_TAG_OFFSET           1\n-#define FIELDINFO_TAG_TYPE_PLAIN       2\n-#define FIELDINFO_TAG_TYPE_CONTENDED   3\n-#define FIELDINFO_TAG_TYPE_MASK        3\n-#define FIELDINFO_TAG_MASK             7\n-#define FIELDINFO_TAG_INLINED          4\n+#define FIELDINFO_TAG_SIZE             4\n+#define FIELDINFO_TAG_OFFSET           1 << 0\n+#define FIELDINFO_TAG_CONTENDED        1 << 1\n+#define FIELDINFO_TAG_INLINED          1 << 2\n+#define FIELDINFO_TAG_RESTRICTED       1 << 3\n@@ -61,6 +58,10 @@\n-  \/\/    ..........................................00  - blank\n-  \/\/    [------------------offset---------------]I01  - real field offset\n-  \/\/    ......................[-------type------]I10  - plain field with type\n-  \/\/    [--contention_group--][-------type------]I11  - contended field with type and contention group\n-  \/\/\n-  \/\/ Bit I indicates if the field has been inlined  (I=1) or nor (I=0)\n+  \/\/    ........................................RICO\n+  \/\/    ........................................RI00  - non-contended field\n+  \/\/    [--contention_group--]..................RI10  - contended field with type and contention group\n+  \/\/    [------------------offset--------------]RI01  - real field offset\n+\n+  \/\/ Bit O indicates if the packed field contains an offset (O=1) or not (O=1)\n+  \/\/ Bit C indicates if the field is contended (C=1) or not (C=1)\n+  \/\/       (if it is contended, the high packed field contains the contention group)\n+  \/\/ Bit I indicates if the field has been inlined  (I=1) or not (I=0)\n+  \/\/ Bit R indicates if the field has a type restriction (R=1) ot not (R=0)\n@@ -111,15 +112,2 @@\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_OFFSET:\n-        return build_int_from_shorts(_shorts[low_packed_offset], _shorts[high_packed_offset]) >> FIELDINFO_TAG_SIZE;\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-        fatal(\"Asking offset for the plain type field\");\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        fatal(\"Asking offset for the contended type field\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Asking offset for the blank field\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n-    return 0;\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) != 0, \"Offset must have been set\");\n+    return build_int_from_shorts(_shorts[low_packed_offset], _shorts[high_packed_offset]) >> FIELDINFO_TAG_SIZE;\n@@ -129,15 +117,1 @@\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-        return false;\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        return true;\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Asking contended flag for the field with offset\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Asking contended flag for the blank field\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n-    return false;\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) != 0;\n@@ -147,15 +121,3 @@\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-        return 0;\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        return _shorts[high_packed_offset];\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Asking the contended group for the field with offset\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Asking the contended group for the blank field\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n-    return 0;\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) == 0, \"Offset must not have been set\");\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) != 0, \"Field must be contended\");\n+    return _shorts[high_packed_offset];\n@@ -164,17 +126,0 @@\n-  u2 allocation_type() const {\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        return (lo >> FIELDINFO_TAG_SIZE);\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Asking the field type for field with offset\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Asking the field type for the blank field\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n-    return 0;\n-  }\n-\n@@ -182,1 +127,1 @@\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_TYPE_MASK) == FIELDINFO_TAG_OFFSET;\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET)!= 0;\n@@ -202,0 +147,1 @@\n+\n@@ -204,3 +150,3 @@\n-    bool inlined = is_inlined();\n-    _shorts[low_packed_offset] = extract_low_short_from_int(val) | FIELDINFO_TAG_OFFSET;\n-    if (inlined) set_inlined(true);\n+    int inline_tag = is_inlined() ? FIELDINFO_TAG_INLINED : 0;\n+    int restricted_tag = has_restricted_type() ? FIELDINFO_TAG_RESTRICTED : 0;\n+    _shorts[low_packed_offset] = extract_low_short_from_int(val) | restricted_tag | inline_tag | FIELDINFO_TAG_OFFSET;\n@@ -208,21 +154,0 @@\n-    assert(is_inlined() || !inlined, \"just checking\");\n-  }\n-\n-  void set_allocation_type(int type) {\n-    bool b = is_inlined();\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_BLANK:\n-        _shorts[low_packed_offset] |= ((type << FIELDINFO_TAG_SIZE)) & 0xFFFF;\n-        _shorts[low_packed_offset] &= ~FIELDINFO_TAG_TYPE_MASK;\n-        _shorts[low_packed_offset] |= FIELDINFO_TAG_TYPE_PLAIN;\n-        assert(is_inlined() || !b, \"Just checking\");\n-        return;\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Setting the field type with overwriting\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n@@ -239,1 +164,1 @@\n-  bool is_inlined() {\n+  bool is_inlined() const {\n@@ -243,15 +168,5 @@\n-  void set_contended_group(u2 val) {\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-        _shorts[low_packed_offset] |= FIELDINFO_TAG_TYPE_CONTENDED;\n-        _shorts[high_packed_offset] = val;\n-        return;\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        fatal(\"Overwriting contended group\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Setting contended group for the blank field\");\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Setting contended group for field with offset\");\n-#endif\n+  void set_has_rectricted_type(bool b) {\n+    if (b) {\n+      _shorts[low_packed_offset] |= FIELDINFO_TAG_RESTRICTED;\n+    } else {\n+      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_RESTRICTED;\n@@ -259,1 +174,11 @@\n-    ShouldNotReachHere();\n+  }\n+\n+  bool has_restricted_type() const {\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_RESTRICTED) != 0;\n+  }\n+\n+  void set_contended_group(u2 val) {\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) == 0, \"Offset must not have been set\");\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) == 0, \"Overwritting contended group\");\n+    _shorts[low_packed_offset] |= FIELDINFO_TAG_CONTENDED;\n+    _shorts[high_packed_offset] = val;\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":43,"deletions":118,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -124,0 +125,10 @@\n+  Symbol* secondary_signature() const {\n+    assert(field()->has_restricted_type(), \"Must have\");\n+    int sig_index = field_holder()->fields_erased_type()[index()];\n+    if (access_flags().is_internal()) {\n+      return vmSymbols::symbol_at(vmSymbols::as_SID(sig_index));\n+    } else {\n+      return _constants->symbol_at(sig_index);\n+    }\n+  }\n+\n@@ -138,4 +149,0 @@\n-  int allocation_type() const {\n-    return field()->allocation_type();\n-  }\n-\n@@ -166,0 +173,8 @@\n+  bool has_restricted_type() const {\n+    return field()->has_restricted_type();\n+  }\n+\n+  void set_has_restricted_type(bool b) {\n+    field()->set_has_rectricted_type(b);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -485,1 +485,2 @@\n-                                       parser.is_inline_type());\n+                                       parser.is_inline_type(),\n+                                       parser.has_restricted_fields());\n@@ -1662,4 +1663,13 @@\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n-      return true;\n+    if (f_name == name) {\n+      Symbol* f_sig  = fs.signature();\n+      if (f_sig == sig) {\n+        fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+        return true;\n+      }\n+      if (fs.has_restricted_type()) {\n+        Symbol* f_sig2 = fs.secondary_signature();\n+        if (f_name == name && f_sig2 == sig) {\n+          fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+          return true;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+\/\/    [EMBEDDED restricted_fields_info] only if has_restricted_fields() == true\n@@ -296,1 +297,2 @@\n-    _misc_has_injected_identityObject         = 1 << 22  \/\/ IdentityObject has been injected by the JVM\n+    _misc_has_injected_identityObject         = 1 << 22, \/\/ IdentityObject has been injected by the JVM\n+    _misc_has_restricted_fields               = 1 << 23  \/\/ class has fields with type restrictions\n@@ -487,0 +489,8 @@\n+  bool has_restricted_fields() const {\n+    return (_misc_flags & _misc_has_restricted_fields);\n+  }\n+\n+  void set_has_restricted_fields() {\n+    _misc_flags |= _misc_has_restricted_fields;\n+  }\n+\n@@ -1201,1 +1211,1 @@\n-                  int java_fields, bool is_inline_type) {\n+                  int java_fields, bool is_inline_type, bool has_restricted_fields) {\n@@ -1210,1 +1220,2 @@\n-           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0) +\n+           (has_restricted_fields ? java_fields * (int)sizeof(u2)\/wordSize : 0));\n@@ -1219,1 +1230,2 @@\n-                                               is_inline_klass());\n+                                               is_inline_klass(),\n+                                               has_restricted_fields());\n@@ -1279,0 +1291,2 @@\n+  u2* fields_erased_type();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -173,0 +174,29 @@\n+inline u2* InstanceKlass::fields_erased_type() {\n+    assert(has_restricted_fields(), \"Should not be called otherwise\");\n+    if (is_inline_klass()) {\n+      return (u2*)((address)(InlineKlass::cast(this)->inlineklass_static_block()) + sizeof(InlineKlassFixedBlock));\n+    }\n+\n+    address adr_jf = adr_inline_type_field_klasses();\n+    if (adr_jf != NULL) {\n+      return (u2*)(adr_jf + this->java_fields_count() * sizeof(Klass*));\n+    }\n+\n+    address adr_fing = adr_fingerprint();\n+    if (adr_fing != NULL) {\n+      return (u2*)(adr_fingerprint() + sizeof(u8));\n+    }\n+\n+    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n+    if (adr_host != NULL) {\n+      return (u2*)(adr_host + 1);\n+    }\n+\n+    Klass* volatile* adr_impl = adr_implementor();\n+    if (adr_impl != NULL) {\n+      return (u2*)(adr_impl + 1);\n+    }\n+\n+    return (u2*)end_of_nonstatic_oop_maps();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  inline bool is_inlined() const;\n+  inline bool is_inlined()        const;\n@@ -98,0 +98,1 @@\n+  inline bool has_restricted_type() const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+inline bool fieldDescriptor::has_restricted_type() const { return field()->has_restricted_type(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2261,1 +2261,0 @@\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_MASK\", FIELDINFO_TAG_MASK) \\\n@@ -2263,0 +2262,3 @@\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_CONTENDED\", FIELDINFO_TAG_CONTENDED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_INLINED\", FIELDINFO_TAG_INLINED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_RESTRICTED\", FIELDINFO_TAG_RESTRICTED) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -389,0 +389,3 @@\n+                if (c.isValue() && c.projection != null) {\n+                    c.projection.flags_field = (c.flags_field & ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,0 +142,4 @@\n+    \/** Flag is set for a type restricted field.\n+     *\/\n+    public static final int RESTRICTED_FIELD       = 1<<19;\n+\n@@ -517,0 +521,1 @@\n+        RESTRICTED_FIELD(Flags.RESTRICTED_FIELD),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1674,2 +1674,0 @@\n-            if (!isValue())\n-                return null;\n@@ -1691,1 +1689,1 @@\n-            long projectionFlags = (this.flags() & ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;\n+            long projectionFlags = (this.flags_field & ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;\n@@ -1695,14 +1693,17 @@\n-            for (Symbol s : this.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    valMethod.projection = refMethod;\n-                    refMethod.projection = valMethod;\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    valVar.projection = refVar;\n-                    refVar.projection = valVar;\n-                    clone = refVar;\n+            if (this.completer == Completer.NULL_COMPLETER) {\n+                for (Symbol s : this.members().getSymbols(s -> (s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n+                    Symbol clone = null;\n+                    if (s.kind == MTH) {\n+                        MethodSymbol valMethod = (MethodSymbol)s;\n+                        MethodSymbol refMethod = valMethod.clone(projection);\n+                        valMethod.projection = refMethod;\n+                        refMethod.projection = valMethod;\n+                        clone = refMethod;\n+                    } else if (s.kind == VAR) {\n+                        VarSymbol valVar = (VarSymbol)s;\n+                        VarSymbol refVar = valVar.clone(projection);\n+                        valVar.projection = refVar;\n+                        refVar.projection = valVar;\n+                        clone = refVar;\n+                    }\n+                    projection.members_field.enter(clone);\n@@ -1710,1 +1711,0 @@\n-                projection.members_field.enter(clone);\n@@ -1712,1 +1712,13 @@\n-            projection.completer = Completer.NULL_COMPLETER;\n+\n+            projection.completer = new Completer() {\n+                @Override\n+                public void complete(Symbol sym) throws CompletionFailure {\n+                    ClassSymbol.this.complete();\n+                }\n+\n+                @Override\n+                public boolean isTerminal() {\n+                    return ClassSymbol.this.completer.isTerminal();\n+                }\n+            };\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+    \/** enable alternate code generation to faciliate specialization experiments using type restrictions *\/\n+    public boolean flattenWithTypeRestrictions;\n+\n@@ -129,0 +132,1 @@\n+        flattenWithTypeRestrictions = options.isSet(\"flattenWithTypeRestrictions\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1265,0 +1265,13 @@\n+            new AttributeReader(names.RestrictedField, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowInlineTypes;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind == VAR && sym.owner.kind == TYP) {\n+                        final Type type = poolReader.getType(nextChar());\n+                        Assert.check(((ClassSymbol)((ClassType)sym.type).tsym).projection == type.tsym);\n+                        sym.flags_field |= RESTRICTED_FIELD;\n+                    }\n+                }\n+            },\n@@ -2230,1 +2243,2 @@\n-        return v;\n+        return (v.flags_field & RESTRICTED_FIELD) == RESTRICTED_FIELD ?\n+                new VarSymbol(flags, name, ((ClassSymbol)v.type.tsym).projection.type, currentOwner) : v;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -976,1 +976,8 @@\n-        databuf.appendChar(poolWriter.putDescriptor(v));\n+        boolean emitRestrictedField = false;\n+        if (types.flattenWithTypeRestrictions && v.type.isValue()) {\n+            emitRestrictedField = true;\n+            databuf.appendChar(poolWriter.putDescriptor(v.type.referenceProjection()));\n+        } else {\n+            databuf.appendChar(poolWriter.putDescriptor(v));\n+        }\n+\n@@ -985,0 +992,6 @@\n+        if (emitRestrictedField) {\n+            int alenIdx = writeAttr(names.RestrictedField);\n+            databuf.appendChar(poolWriter.putDescriptor(v));\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -37,0 +38,2 @@\n+import java.util.HashMap;\n+\n@@ -148,1 +151,5 @@\n-        return new StaticItem(member);\n+        if (this.types.flattenWithTypeRestrictions && member.kind == Kind.VAR && member.type.isValue()) {\n+            return new StaticItem(getFlattenedField(member));\n+        } else {\n+            return new StaticItem(member);\n+        }\n@@ -157,1 +164,5 @@\n-        return new MemberItem(member, nonvirtual);\n+        if (this.types.flattenWithTypeRestrictions && member.kind == Kind.VAR && member.type.isValue()) {\n+            return new MemberItem(getFlattenedField(member), nonvirtual);\n+        } else {\n+            return new MemberItem(member, nonvirtual);\n+        }\n@@ -159,0 +170,15 @@\n+        \/\/ where\n+        private Symbol getFlattenedField(Symbol member) {\n+            if (flatFieldsMap == null)\n+                flatFieldsMap = new HashMap<>();\n+            Symbol flatField = flatFieldsMap.get(member);\n+            if (flatField == null) {\n+                flatFieldsMap.put(member, flatField = new VarSymbol(member.flags(),\n+                                                        member.name,\n+                                                        member.type.referenceProjection(),\n+                                                        member.owner));\n+            }\n+            return flatField;\n+        }\n+\n+     private HashMap<Symbol, Symbol> flatFieldsMap;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Items.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+    public final Name RestrictedField;\n@@ -340,0 +341,1 @@\n+        RestrictedField = fromString(\"RestrictedField\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  private static short FIELDINFO_TAG_MASK;\n@@ -120,1 +119,0 @@\n-    FIELDINFO_TAG_MASK             = db.lookupIntConstant(\"FIELDINFO_TAG_MASK\").shortValue();\n@@ -400,1 +398,1 @@\n-    if ((lo & FIELDINFO_TAG_MASK) == FIELDINFO_TAG_OFFSET) {\n+    if ((lo & FIELDINFO_TAG_OFFSET) == FIELDINFO_TAG_OFFSET) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+    public static final String RestrictedField          = \"RestrictedField\";\n@@ -140,0 +141,1 @@\n+            standardAttributes.put(RestrictedField, RestrictedField_attribute.class);\n@@ -207,0 +209,1 @@\n+        R visitRestrictedField(RestrictedField_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -658,0 +658,6 @@\n+        @Override\n+        public Void visitRestrictedField(RestrictedField_attribute attr, ClassOutputStream out) {\n+            out.writeShort(attr.restricted_type_index);\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * See JVMS, section 4.8.9.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+\n+public class RestrictedField_attribute extends Attribute {\n+    RestrictedField_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        restricted_type_index = cr.readUnsignedShort();\n+    }\n+    public RestrictedField_attribute(ConstantPool constant_pool, int restricted_type_index)\n+            throws ConstantPoolException {\n+        this(constant_pool.getUTF8Index(Attribute.RestrictedField), restricted_type_index);\n+    }\n+    public RestrictedField_attribute(int name_index, int restricted_type_index) {\n+        super(name_index, 2);\n+        this.restricted_type_index = restricted_type_index;\n+    }\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitRestrictedField(this, data);\n+    }\n+\n+    public String getRestrictedType(ConstantPool constant_pool) throws ConstantPoolException {\n+        return constant_pool.getUTF8Value(restricted_type_index);\n+    }\n+\n+    public final int restricted_type_index;\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RestrictedField_attribute.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.classfile.RestrictedField_attribute;\n@@ -768,0 +769,16 @@\n+    @Override\n+    public Void visitRestrictedField(RestrictedField_attribute attr, Void p) {\n+        print(\"RestrictedField: #\" + attr.restricted_type_index);\n+        tab();\n+        println(\"\/\/ \" + getRestrictedType(attr));\n+        return null;\n+    }\n+\n+    String getRestrictedType(RestrictedField_attribute info) {\n+        try {\n+            return info.getRestrictedType(constant_pool);\n+        } catch (ConstantPoolException e) {\n+            return report(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @summary Simple test about type restrictions\n+ * @library \/test\/lib\n+ * @compile  -XDflattenWithTypeRestrictions SimpleTest.java\n+ * @run main\/othervm -Xint runtime.valhalla.typerestrictions.SimpleTest\n+ *\/\n+public class SimpleTest {\n+\n+    static inline class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public Point p;\n+\n+    public static void main(String... args) {\n+        SimpleTest b = new SimpleTest();\n+        if (b.p != new Point(0,0)) throw new RuntimeException();\n+        b.p = new Point(1.0, 2.0);\n+        if (b.p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/SimpleTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -1374,0 +1374,5 @@\n+\n+        @Override\n+        public Void visitRestrictedField(RestrictedField_attribute attr, T p) {\n+            return null;\n+        }\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    public R visitRestrictedField(RestrictedField_attribute attr, P p) { return null; }\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AttributeVisitor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253312\n+ * @summary Enable JVM experiments in specialization under an opt-in mode\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions RestrictedFieldCodegenTest.java\n+ * @run main\/othervm -Xverify:none RestrictedFieldCodegenTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+class PointBox {\n+\n+    static inline class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public Point p;\n+\n+    public static void main(String... args) {\n+        PointBox b = new PointBox();\n+        if (b.p != new Point(0,0)) throw new RuntimeException();\n+        b.p = new Point(1.0, 2.0);\n+        if (b.p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n+\n+public class RestrictedFieldCodegenTest {\n+\n+    public static void main(String [] args) {\n+        new RestrictedFieldCodegenTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"PointBox.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+         \"public PointBox$Point$ref p;\",\n+         \"descriptor: LPointBox$Point$ref;\",\n+         \"RestrictedField: #25                    \/\/ QPointBox$Point;\",\n+         \" 9: getfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         \"36: putfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         \"40: getfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         });\n+\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        System.out.println(\"Checking javap\");\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        System.out.println(\"Javap = \" + out);\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldCodegenTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8253312\n+ * @summary Enable JVM experiments in specialization under an opt-in mode\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions -XDrawDiagnostics RestrictedFieldCodegenTest.java\n+ * @compile\/fail\/ref=RestrictedFieldTypeTest.out -XDflattenWithTypeRestrictions -XDrawDiagnostics RestrictedFieldTypeTest.java\n+ *\/\n+\n+public class RestrictedFieldTypeTest {\n+    PointBox rft = new PointBox();\n+    void foo() {\n+        rft.p = null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldTypeTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+RestrictedFieldTypeTest.java:13:17: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, PointBox.Point)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldTypeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253760\n+ * @summary [type-restrictions] Static inline fields are not \"erased\" to the ref type\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions RestrictedStaticFieldCodegenTest.java\n+ * @run main\/othervm -Xverify:none RestrictedStaticFieldCodegenTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+class PointBox {\n+\n+    static inline class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public static Point p;\n+\n+    public static void main(String... args) {\n+        if (p != new Point(0,0)) throw new RuntimeException();\n+        p = new Point(1.0, 2.0);\n+        if (p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n+\n+public class RestrictedStaticFieldCodegenTest {\n+\n+    public static void main(String [] args) {\n+        new RestrictedStaticFieldCodegenTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"PointBox.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+         \"public static PointBox$Point$ref p;\",\n+         \"descriptor: LPointBox$Point$ref;\",\n+         \"RestrictedField: #24                    \/\/ QPointBox$Point;\",\n+         \" 0: getstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         \"26: putstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         \"29: getstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         });\n+\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        System.out.println(\"Checking javap\");\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        System.out.println(\"Javap = \" + out);\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedStaticFieldCodegenTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}