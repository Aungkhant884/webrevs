{"files":[{"patch":"@@ -2726,0 +2726,12 @@\n+  if (_desc->bytecode() == Bytecodes::_areturn) {  \/\/ or should the test be state == atos ?\n+    Label not_restricted;\n+    __ get_method(rscratch1);\n+    __ movzwl(rscratch1, Address(rscratch1, Method::flags_offset()));\n+    __ andl(rscratch1, Method::_restricted_method);\n+    __ jcc(Assembler::zero, not_restricted);\n+    Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+    __ movptr(robj, aaddress(0));\n+    __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::restricted_return_value_check), robj);\n+    __ bind(not_restricted);\n+  }\n+\n@@ -3310,0 +3322,14 @@\n+\n+  Label notRestricted;\n+  __ movl(rdx, flags);\n+  __ shrl(rdx, ConstantPoolCacheEntry::has_restricted_type_shift);\n+  __ andl(rdx, 0x1);\n+  __ testl(rdx, rdx);\n+  __ jcc(Assembler::zero, notRestricted);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::check_restricted_type));\n+  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+\n+  __ bind(notRestricted);\n+\n@@ -3906,0 +3932,13 @@\n+void TemplateTable::restricted_method_check(Register method) {\n+    Label not_restricted;\n+  __ movptr(rscratch1, method);\n+  __ movzwl(rscratch1, Address(rscratch1, Method::flags_offset()));\n+  __ andl(rscratch1, Method::_restricted_method);\n+  __ jcc(Assembler::zero, not_restricted);\n+  __ restore_bcp();\n+  __ push(method);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::restricted_parameter_checks));\n+  __ pop(method);\n+  __ bind(not_restricted);\n+}\n+\n@@ -4019,1 +4058,1 @@\n-\n+  restricted_method_check(method);\n@@ -4033,1 +4072,0 @@\n-\n@@ -4035,0 +4073,1 @@\n+  restricted_method_check(method);\n@@ -4063,0 +4102,1 @@\n+  restricted_method_check(rbx);\n@@ -4073,0 +4113,1 @@\n+  restricted_method_check(rbx);\n@@ -4135,1 +4176,1 @@\n-\n+  restricted_method_check(rbx);\n@@ -4187,0 +4228,2 @@\n+  restricted_method_check(rbx);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+  static void restricted_method_check(Register method);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1855,0 +1855,6 @@\n+      if (field->has_restricted_type()) {\n+        CheckCast* c = new CheckCast(field->type()->as_klass(), val, copy_state_before(), field->type()->as_inline_klass() != NULL);\n+        append_split(c);\n+        c->set_incompatible_class_change_check();\n+        c->set_direct_compare(field->type()->as_instance_klass()->is_final());\n+      }\n@@ -2019,0 +2025,6 @@\n+      if (field->has_restricted_type()) {\n+        CheckCast* c = new CheckCast(field->type()->as_klass(), val, copy_state_before(), field->type()->as_inline_klass() != NULL);\n+        append_split(c);\n+        c->set_incompatible_class_change_check();\n+        c->set_direct_compare(field->type()->as_instance_klass()->is_final());\n+      }\n@@ -2065,0 +2077,7 @@\n+  if (field_modify->has_restricted_type()) {\n+    CheckCast* c = new CheckCast(field_modify->type()->as_klass(), val, copy_state_before(), field_modify->type()->as_inline_klass() != NULL);\n+    append_split(c);\n+    c->set_incompatible_class_change_check();\n+    c->set_direct_compare(field_modify->type()->as_instance_klass()->is_final());\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1027,0 +1027,2 @@\n+  bool deoptimize_for_flattened_field = false;\n+  bool deoptimize_for_restricted_type = false;\n@@ -1043,1 +1045,20 @@\n-    assert(!result.is_inlined(), \"Can not patch access to flattened field\");\n+\n+    \/\/ With type restrictions, it possible that at compilation time,\n+    \/\/ the holder was unloaded, and C1 didn't know that the field\n+    \/\/ would be flattened, so the generated code is incorrect for a\n+    \/\/ flattened field. The  nmethod has to be deoptimized so that\n+    \/\/ the code can be regnerated correctly.\n+\n+    deoptimize_for_flattened_field = result.is_inlined();\n+\n+    \/\/ Another case caused by type restrictions: if the holder was\n+    \/\/ unloaded at compilation time, C1 didn't know that the field\n+    \/\/ could have type restrictions, and when the field has such\n+    \/\/ restrictions, it means additional checks have to be performed\n+    \/\/ to ensure the value being written satisfies those restrictions.\n+    \/\/ The nmethod has to be deoptimized so that the code can be\n+    \/\/ regenerated with the additional checks.\n+\n+    if ((code == Bytecodes::_putfield || code == Bytecodes::_putstatic) && result.has_restricted_type()) {\n+      deoptimize_for_restricted_type = true;\n+    }\n@@ -1156,1 +1177,2 @@\n-  if (deoptimize_for_volatile || deoptimize_for_atomic) {\n+  if (deoptimize_for_volatile || deoptimize_for_atomic || deoptimize_for_flattened_field ||\n+      deoptimize_for_restricted_type) {\n@@ -1167,0 +1189,6 @@\n+      if (deoptimize_for_flattened_field) {\n+        tty->print_cr(\"Deoptimizing for patching flattened field reference\");\n+      }\n+      if (deoptimize_for_restricted_type) {\n+        tty->print_cr(\"Deoptimizing for patching field with type restriction\");\n+      }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-  _is_flattened(false), _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n+  _descriptor_signature(NULL), _is_flattened(false),\n+  _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n@@ -106,2 +107,0 @@\n-  _name = (ciSymbol*)ciEnv::current(THREAD)->get_symbol(name);\n-\n@@ -201,0 +200,3 @@\n+  if (fd->has_restricted_type()) {\n+    _descriptor_signature = env->get_symbol(fd->descriptor_signature());\n+  }\n@@ -240,0 +242,1 @@\n+  _descriptor_signature = field->_descriptor_signature;\n@@ -283,0 +286,1 @@\n+  ASSERT_IN_VM;\n@@ -290,0 +294,10 @@\n+  if (fd->has_restricted_type()) {\n+    _descriptor_signature = ciEnv::current(CompilerThread::current())->get_symbol(fd->descriptor_signature());\n+    _signature = ciEnv::current(CompilerThread::current())->get_symbol(fd->signature());\n+    \/\/ Only InstanceKlass should have fields\n+    assert(field_holder->is_instance_klass(), \"Sanity check\");\n+    InstanceKlass* field_holder_ik = InstanceKlass::cast(field_holder);\n+    \/\/ resetting the type because field's type has been switched from its descriptor signature\n+    \/\/ to its restricted type. The type will be set lazely wjen invoking the method type().\n+    _type = NULL;\n+  }\n@@ -292,1 +306,0 @@\n-  Klass* k = _holder->get_Klass();\n@@ -301,1 +314,1 @@\n-      if (k == vmClasses::System_klass()) {\n+      if (field_holder == vmClasses::System_klass()) {\n@@ -320,1 +333,1 @@\n-    if (k == vmClasses::CallSite_klass() &&\n+    if (field_holder == vmClasses::CallSite_klass() &&\n@@ -487,0 +500,5 @@\n+  tty->print(\" has_restricted_type=%s\", bool_to_str(_descriptor_signature != NULL));\n+  if (_descriptor_signature != NULL) {\n+    tty->print(\"descriptor signature=\");\n+    _descriptor_signature->print_symbol();\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  ciSymbol*        _descriptor_signature;\n@@ -103,0 +104,3 @@\n+  \/\/ What alternate signature can be used for this field in signature (must have a restricted type)\n+  ciSymbol* descriptor_signature() const { return _descriptor_signature; }\n+\n@@ -180,0 +184,1 @@\n+  bool has_restricted_type     () const { return _holder->is_loaded() && _descriptor_signature != NULL; }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1383,0 +1383,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1515,0 +1517,16 @@\n+      } else if (_major_version >= JAVA_17_VERSION) {\n+        if (attribute_name == vmSymbols::tag_restricted_field()) {\n+          check_property(\n+            attribute_length == 2,\n+            \"Invalid RestrictedField field attribute length %u in class file %s\",\n+            attribute_length, CHECK);\n+            const u2 type_index = cfs->get_u2_fast();\n+            check_property(valid_symbol_at(type_index),\n+                          \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                            type_index, CHECK);\n+            *restricted_field_info = type_index;\n+            *has_restricted_type = true;\n+            set_has_restricted_fields();\n+        } else {\n+          cfs->skip_u1(attribute_length, CHECK);  \/\/ Skip unknown attributes\n+        }\n@@ -1669,0 +1687,2 @@\n+  _descriptor_signature_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1699,0 +1719,1 @@\n+\n@@ -1731,0 +1752,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1740,0 +1763,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1774,0 +1799,26 @@\n+    \/\/ RestrictedField:\n+    \/\/ The current model for restricted field is that such a field has a descriptor signature used\n+    \/\/ as the normal signature for this field (for instance in field access bytecodes) but it also\n+    \/\/ has a restricted type that will be used internally by the VM as the real type of the field.\n+    \/\/ Current constraints are that the restricted type must be an inline type and the descriptor\n+    \/\/ type must be a super type of the restricted type.\n+    \/\/ The code below verifies that the restricted type is an inline type. The property that the\n+    \/\/ descriptor type is a super type of the restricted type is verified just after the pre-loading\n+    \/\/ of the restricted type (inline type field preloading)\n+    if (has_restricted_type && cp->basic_type_for_signature_at(restricted_type_index) != T_INLINE_TYPE) {\n+      \/\/ Probably not the right error to throw\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Field %s.%s has a RestricteField attribute but its restricted type is not an inline type\",\n+                _class_name->as_C_string(),\n+                _cp->symbol_at(restricted_type_index)->as_C_string()));\n+    }\n+\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1777,1 +1828,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1779,0 +1830,3 @@\n+    _descriptor_signature_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1828,0 +1882,1 @@\n+      _descriptor_signature_info->append(0);\n@@ -1831,0 +1886,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1838,0 +1894,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1840,0 +1897,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1842,0 +1900,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1850,0 +1911,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1852,0 +1914,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -2630,0 +2693,4 @@\n+  bool has_restricted_method_attribute = false;\n+  const u1* restricted_param_types_start = NULL;\n+  u2 restricted_return_type_index = 0;\n+  u1 restricted_num_params = 0;\n@@ -2966,0 +3033,23 @@\n+      } else if (method_attribute_name == vmSymbols::tag_restricted_method()) {\n+        const u1* const current_start = cfs->current();\n+\n+        \/\/ RestrictedMethod_attribute {\n+        \/\/   u2 name_index;\n+        \/\/   u4 length;\n+        \/\/   u1 num_params;\n+        \/\/   u2 restricted_param_type[num_params];\n+        \/\/   u2 restricted_return_type;\n+        \/\/ }\n+\n+        has_restricted_method_attribute = true;\n+        cfs->guarantee_more(1, CHECK_NULL);  \/\/ num_params\n+        restricted_num_params = cfs->get_u1_fast();\n+        guarantee_property((int)method_attribute_length == restricted_num_params * 2 + 3,\n+                          \"Invalid RestrictedMethod attribute length %u in class file %s\",\n+                          method_attribute_length,\n+                          CHECK_NULL);\n+\n+        restricted_param_types_start = cfs->current();\n+        cfs->skip_u2_fast(restricted_num_params);\n+        cfs->guarantee_more(2, CHECK_NULL);  \/\/ restricted_return_type\n+        restricted_return_type_index = cfs->get_u2_fast();\n@@ -3005,0 +3095,4 @@\n+      \/\/ RestrictedMethod atribute requires a more complex protocol because num_params can be zeo\n+      \/\/ but the attribute still be there because of a restricted return value\n+      \/\/ So -1 is passed if the attribute is absent, otherwise num_params is passed\n+      has_restricted_method_attribute ? restricted_num_params : -1 ,\n@@ -3108,0 +3202,12 @@\n+  \/\/ Copy RestrictedMethod attribute if present\n+  if (has_restricted_method_attribute) {\n+    m->set_restricted_method(true);\n+    *(m->constMethod()->restricted_num_params_addr()) = restricted_num_params;\n+    *(m->constMethod()->restricted_return_type_index_addr()) = restricted_return_type_index;\n+    u2* cursor = m->constMethod()->restricted_param_type_start();\n+    for (int i = 0; i < restricted_num_params; i++) {\n+      cursor[i] = Bytes::get_Java_u2((address)restricted_param_types_start);\n+      restricted_param_types_start +=2;\n+    }\n+  }\n+\n@@ -5898,0 +6004,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_descriptor_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _descriptor_signature_info->at(i);\n+    }\n+  }\n+\n@@ -6102,0 +6216,1 @@\n+  _descriptor_signature_info(NULL),\n@@ -6143,0 +6258,1 @@\n+  _has_restricted_fields(false),\n@@ -6728,0 +6844,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6730,1 +6847,0 @@\n-      \/\/ Pre-load inline class\n@@ -6743,0 +6859,13 @@\n+      if (fs.has_restricted_type()) {\n+        \/\/ descriptor type supposed to be a super type of the restricted type, so after the pre-loading\n+        \/\/ of the restricted type above, the descriptor type should be loaded at this point\n+        Symbol* descriptor_name = _cp->symbol_at(_descriptor_signature_info->at(fs.index()));\n+        ResolvingSignatureStream rss(descriptor_name, Handle(THREAD, _loader_data->class_loader()), _protection_domain, false);\n+        Klass* desc_klass = rss.as_klass(SignatureStream::ReturnNull, CHECK);\n+        if (desc_klass == NULL || !klass->is_subtype_of(desc_klass)) {\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Restricted type %s should be a subtype of the descriptor type %s, but it is not\",\n+                    fs.signature()->as_C_string(),\n+                    descriptor_name->as_C_string()));\n+        }\n+      }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":131,"deletions":2,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  GrowableArray<u2>* _descriptor_signature_info;\n@@ -218,0 +219,1 @@\n+  bool _has_restricted_fields;\n@@ -286,0 +288,2 @@\n+                              u2* restricted_field_info,\n+                              bool* has_restricted_type,\n@@ -631,0 +635,2 @@\n+  void set_has_restricted_fields() { _has_restricted_fields = true; }\n+  bool has_restricted_fields() const { return _has_restricted_fields; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-                                       Array<u2>* fields, bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,\n+                                       Array<u2>* fields,  bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,0 +194,2 @@\n+  template(tag_restricted_field,                      \"RestrictedField\")                          \\\n+  template(tag_restricted_method,                     \"RestrictedMethod\")                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -345,0 +345,11 @@\n+    oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n+    if (voop == NULL) {\n+      THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);\n+    }\n+    if (vklass->field_has_restricted_type(field_index)) {\n+      Klass* value_klass = voop->klass();\n+      Klass* field_klass = vklass->get_inline_type_field_klass(field_index);\n+      if (!value_klass->is_subtype_of(field_klass)) {\n+        THROW_(vmSymbols::java_lang_IncompatibleClassChangeError(), return_offset);\n+      }\n+    }\n@@ -346,2 +357,1 @@\n-      oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n-      assert(vt_oop != NULL && oopDesc::is_oop(vt_oop) && vt_oop->is_inline_type(),\"argument must be an inline type\");\n+      assert(voop != NULL && oopDesc::is_oop(voop) && voop->is_inline_type(),\"argument must be an inline type\");\n@@ -349,2 +359,2 @@\n-      assert(vt_oop != NULL && field_vk == vt_oop->klass(), \"Must match\");\n-      field_vk->write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));\n+      assert(voop != NULL && field_vk == voop->klass(), \"Must match\");\n+      field_vk->write_inlined_field(new_value_h(), offset, voop, CHECK_(return_offset));\n@@ -352,1 +362,0 @@\n-      oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n@@ -528,0 +537,76 @@\n+JRT_ENTRY(void, InterpreterRuntime::restricted_parameter_checks(JavaThread* thread))\n+  LastFrameAccessor last_frame(thread);\n+  Method* caller = last_frame.method();\n+  constantPoolHandle cph(THREAD, caller->constants());\n+  Method* callee = last_frame.cache_entry()->method_if_resolved(cph);\n+  assert(callee != NULL, \"Something bad happened\");\n+  if (callee->has_restricted_method()) {\n+    ResourceMark rm(THREAD);\n+    Symbol* signature = callee->signature();\n+    ArgumentCount args(signature);\n+    int arg_count = args.size();\n+    ResourceArea *area = Thread::current()->resource_area();\n+    int* sizes = NEW_ARENA_ARRAY(area, int, arg_count);\n+    int i = 0;\n+    for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {\n+      sizes[i] = parameter_type_word_count(ss.type());\n+      i++;\n+    }\n+    int tos_idx = (int)last_frame.get_frame().interpreter_frame_expression_stack_size() - 3;\n+    for (int i = arg_count - 1; i >=0; --i) {\n+      Klass* k = callee->restricted_param_type_at(i);\n+      if (k != NULL) {\n+        oop arg = *(oop*)last_frame.get_frame().interpreter_frame_expression_stack_at(tos_idx);\n+        if (!arg->klass()->is_subtype_of(k)) {\n+          THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+        }\n+      }\n+      tos_idx -= sizes[i];\n+    }\n+  }\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::restricted_return_value_check(JavaThread* thread, oopDesc* obj))\n+  LastFrameAccessor last_frame(thread);\n+  assert(last_frame.bytecode().code() == Bytecodes::_areturn, \"Only areturn should have such checks\");\n+  Method* method = last_frame.method();\n+  constantPoolHandle cph(THREAD, method->constants());\n+  if (method->constMethod()->has_restricted_method()) {\n+    Klass* k = method->restricted_return_value();\n+    if (k != NULL && !obj->klass()->is_subtype_of(k)) {\n+      THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+    }\n+  }\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::check_restricted_type(JavaThread* thread))\n+  LastFrameAccessor last_frame(thread);\n+  ConstantPoolCacheEntry* cp_entry = last_frame.cache_entry();\n+  int offset = cp_entry->f2_as_offset();\n+  InstanceKlass* holder = InstanceKlass::cast(cp_entry->f1_as_klass());\n+  fieldDescriptor fd;\n+  bool is_static = last_frame.bytecode().code() == Bytecodes::_putstatic;\n+  holder->find_field_from_offset(offset, is_static, &fd);\n+  Klass* field_klass = holder->get_inline_type_field_klass_or_null(fd.index());\n+  if (field_klass == NULL) {\n+    field_klass = SystemDictionary::resolve_or_fail(holder->field_signature(fd.index())->fundamental_name(THREAD),\n+        Handle(THREAD, holder->class_loader()),\n+        Handle(THREAD, holder->protection_domain()),\n+        true, CHECK);\n+    holder->set_inline_type_field_klass(fd.index(), field_klass);\n+  }\n+  assert(field_klass != NULL, \"Must have been set\");\n+  oop value = cast_to_oop(*last_frame.get_frame().interpreter_frame_tos_at(0));\n+  if (value == NULL) {\n+    if (field_klass->is_inline_klass()) {\n+      THROW(vmSymbols::java_lang_NullPointerException());\n+    }\n+    return;\n+  }\n+  assert(value != NULL, \"Inline types cannot be NULL\");\n+  Klass* value_klass = value->klass();\n+  if (!value_klass->is_subtype_of(field_klass)) {\n+    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+  };\n+JRT_END\n+\n@@ -958,0 +1043,1 @@\n+    info.has_restricted_type(),\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":91,"deletions":5,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+  static void check_restricted_type(JavaThread* thread);\n+\n+  static void restricted_parameter_checks(JavaThread* thread);\n+  static void restricted_return_value_check(JavaThread* thread, oopDesc* obj);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,0 +132,10 @@\n+  \/\/ Protocol for RestrictedMethod attribute\n+  \/\/ if sizes->restricted_method_length() == -1 => attribute is not present\n+  \/\/ if sizes->restricted_method_length() ==  0 => attribute is present but restricted_param_types array is empty\n+  \/\/ otherwise the attribute is present and the restricted_param_types array contains sizes->restricted_method_length() elements\n+  if (sizes->restricted_method_length() >= 0) {\n+    extra_bytes += sizeof(u2); \/\/ restricted_return_type\n+    extra_bytes += sizeof(u1); \/\/ num param\n+    extra_bytes += sizes->restricted_method_length() * sizeof(u2);  \/\/ restricted_param_types array\n+  }\n+\n@@ -177,0 +187,15 @@\n+u1* ConstMethod::restricted_num_params_addr() const {\n+  assert(has_restricted_method(), \"called only if method has a RestrictedMethod attribute\");\n+  return (u1*)last_u2_element();\n+}\n+\n+u2* ConstMethod::restricted_return_type_index_addr() const {\n+  assert(has_restricted_method(), \"called only if method has a RestrictedMethod attribute\");\n+  return last_u2_element() - 1;\n+}\n+\n+u2* ConstMethod::restricted_param_type_start() const {\n+  assert(has_restricted_method(), \"called only if method has a RestrictedMethod attribute\");\n+  return last_u2_element() - 1 - *restricted_num_params_addr();\n+}\n+\n@@ -180,1 +205,5 @@\n-  return last_u2_element();\n+  if (has_restricted_method()) {\n+    return restricted_param_type_start() - 1;\n+  } else {\n+    return last_u2_element();\n+  }\n@@ -185,2 +214,9 @@\n-  return has_generic_signature() ? (last_u2_element() - 1) :\n-                                    last_u2_element();\n+  if (has_generic_signature()) {\n+    return generic_signature_index_addr() - 1;\n+  } else {\n+    if (has_restricted_method()) {\n+      return restricted_param_type_start() - 1;\n+    } else {\n+      return last_u2_element();\n+    }\n+  }\n@@ -196,3 +232,9 @@\n-    \/\/ Else, the exception table is at the end of the constMethod.\n-    return has_generic_signature() ? (last_u2_element() - 1) :\n-                                     last_u2_element();\n+    if (has_generic_signature()) {\n+      return generic_signature_index_addr() - 1;\n+    } else {\n+      if (has_restricted_method()) {\n+        return restricted_param_type_start() - 1;\n+      } else {\n+        return last_u2_element();\n+      }\n+    }\n@@ -212,3 +254,9 @@\n-      \/\/ Else, the exception table is at the end of the constMethod.\n-      return has_generic_signature() ? (last_u2_element() - 1) :\n-                                        last_u2_element();\n+      if (has_generic_signature()) {\n+        return generic_signature_index_addr() - 1;\n+      } else {\n+        if (has_restricted_method()) {\n+          return restricted_param_type_start() - 1;\n+        } else {\n+          return last_u2_element();\n+        }\n+      }\n@@ -233,3 +281,9 @@\n-        \/\/ Else, the exception table is at the end of the constMethod.\n-      return has_generic_signature() ? (last_u2_element() - 1) :\n-                                        last_u2_element();\n+        if (has_generic_signature()) {\n+          return generic_signature_index_addr() - 1;\n+        } else {\n+          if (has_restricted_method()) {\n+            return restricted_param_type_start() - 1;\n+          } else {\n+            return last_u2_element();\n+          }\n+        }\n@@ -267,0 +321,2 @@\n+  if (sizes->restricted_method_length() > 0)\n+    _flags |= _has_restricted_method;\n","filename":"src\/hotspot\/share\/oops\/constMethod.cpp","additions":68,"deletions":12,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -83,0 +83,3 @@\n+\/\/    [EMBEDDED] restricted parameter types + restricted return type + num param (in this order)\n+\/\/     (restricted parameter types are u2, restricted return type is u2)\n+\/\/     (num param is u1)\n@@ -137,1 +140,2 @@\n-  do_element(default_annotations_length)\n+  do_element(default_annotations_length)        \\\n+  do_element(restricted_method_length)\n@@ -189,1 +193,2 @@\n-    _has_default_annotations = 0x0400\n+    _has_default_annotations = 0x0400,\n+    _has_restricted_method = 0x800\n@@ -359,0 +364,15 @@\n+  \/\/ RestrictedMethod support\n+  int restricted_return_value_index() {\n+    assert(has_restricted_method(), \"\");\n+    return *(restricted_return_type_index_addr());\n+  }\n+  int restricted_num_param() {\n+    assert(has_restricted_method(), \"\");\n+    return *(restricted_num_params_addr());\n+  }\n+  int restricted_param_type_index_at(u1 index){\n+    assert(has_restricted_method(), \"\");\n+    u2* array = restricted_param_type_start();\n+    return array[index];\n+  }\n+\n@@ -385,0 +405,3 @@\n+  u1* restricted_num_params_addr() const;\n+  u2* restricted_return_type_index_addr() const;\n+  u2* restricted_param_type_start() const;\n@@ -390,0 +413,1 @@\n+  u2* restricted_method_length_addr() const;\n@@ -425,0 +449,2 @@\n+  bool has_restricted_method() const\n+    { return (_flags & _has_restricted_method) != 0; }\n","filename":"src\/hotspot\/share\/oops\/constMethod.hpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+                                       bool has_restricted_type,\n@@ -151,1 +152,2 @@\n-                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),\n+                  ((is_inline_type ? 1 : 0) << is_inline_type_shift) |\n+                  ((has_restricted_type ? 1 : 0) << has_restricted_type_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-\/\/ _flags     [tos|0|F=1|0|I|i|f|v|0 |0000|field_index] (for field entries)\n+\/\/ _flags     [tos|0|F=1|R|I|i|f|v|0 |0000|field_index] (for field entries)\n@@ -188,0 +188,1 @@\n+    has_restricted_type_shift  = 25,  \/\/ (R) does the field have a restricted type?\n@@ -233,0 +234,1 @@\n+    bool            has_restricted_type,         \/\/ field has a restricted type\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-#define FIELDINFO_TAG_SIZE             3\n+#define FIELDINFO_TAG_SIZE             4\n@@ -53,0 +53,1 @@\n+#define FIELDINFO_TAG_RESTRICTED       1 << 3\n@@ -57,4 +58,4 @@\n-  \/\/    ..........................................CO\n-  \/\/    ..........................................00  - non-contended field\n-  \/\/    [--contention_group--]...................I10  - contended field with contention group\n-  \/\/    [------------------offset---------------]I01  - real field offset\n+  \/\/    ........................................RICO\n+  \/\/    ........................................RI00  - non-contended field\n+  \/\/    [--contention_group--]..................RI10  - contended field with type and contention group\n+  \/\/    [------------------offset--------------]RI01  - real field offset\n@@ -62,2 +63,2 @@\n-  \/\/ Bit O indicates if the packed field contains an offset (O=1) or not (O=0)\n-  \/\/ Bit C indicates if the field is contended (C=1) or not (C=0)\n+  \/\/ Bit O indicates if the packed field contains an offset (O=1) or not (O=1)\n+  \/\/ Bit C indicates if the field is contended (C=1) or not (C=1)\n@@ -66,0 +67,1 @@\n+  \/\/ Bit R indicates if the field has a type restriction (R=1) ot not (R=0)\n@@ -145,0 +147,1 @@\n+\n@@ -147,3 +150,3 @@\n-    bool inlined = is_inlined();\n-    _shorts[low_packed_offset] = extract_low_short_from_int(val) | FIELDINFO_TAG_OFFSET;\n-    if (inlined) set_inlined(true);\n+    int inline_tag = is_inlined() ? FIELDINFO_TAG_INLINED : 0;\n+    int restricted_tag = has_restricted_type() ? FIELDINFO_TAG_RESTRICTED : 0;\n+    _shorts[low_packed_offset] = extract_low_short_from_int(val) | restricted_tag | inline_tag | FIELDINFO_TAG_OFFSET;\n@@ -151,1 +154,0 @@\n-    assert(is_inlined() || !inlined, \"just checking\");\n@@ -162,1 +164,1 @@\n-  bool is_inlined() {\n+  bool is_inlined() const {\n@@ -166,0 +168,12 @@\n+  void set_has_rectricted_type(bool b) {\n+    if (b) {\n+      _shorts[low_packed_offset] |= FIELDINFO_TAG_RESTRICTED;\n+    } else {\n+      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_RESTRICTED;\n+    }\n+  }\n+\n+  bool has_restricted_type() const {\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_RESTRICTED) != 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -124,0 +125,10 @@\n+  Symbol* descriptor_signature() const {\n+    assert(field()->has_restricted_type(), \"Must have\");\n+    int sig_index = field_holder()->fields_descriptor_type()[index()];\n+    if (access_flags().is_internal()) {\n+      return vmSymbols::symbol_at(vmSymbols::as_SID(sig_index));\n+    } else {\n+      return _constants->symbol_at(sig_index);\n+    }\n+  }\n+\n@@ -162,0 +173,8 @@\n+  bool has_restricted_type() const {\n+    return field()->has_restricted_type();\n+  }\n+\n+  void set_has_restricted_type(bool b) {\n+    field()->set_has_rectricted_type(b);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -476,1 +476,2 @@\n-                                       parser.is_inline_type());\n+                                       parser.is_inline_type(),\n+                                       parser.has_restricted_fields());\n@@ -511,0 +512,4 @@\n+  if (parser.has_restricted_fields()) {\n+    ik->set_has_restricted_fields(); \/\/ required to get the size right when calling size()\n+  }\n+\n@@ -1031,0 +1036,4 @@\n+      \/\/ Loadding classes of restricted parameters\n+      if (m->constMethod()->has_restricted_method()) {\n+        m->resolve_restricted_types(CHECK_false);\n+      }\n@@ -1256,0 +1265,1 @@\n+\n@@ -1660,4 +1670,14 @@\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n-      return true;\n+    if (f_name == name) {\n+      Symbol* f_sig = NULL;\n+      f_sig  = fs.signature();\n+      if (f_sig == sig) {\n+        fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+        return true;\n+      }\n+      if (fs.has_restricted_type()) {\n+        f_sig = fs.descriptor_signature();\n+        if (f_sig == sig) {\n+          fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+          return true;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\/\/    [EMBEDDED restricted_fields_info] only if has_restricted_fields() == true\n@@ -296,1 +297,2 @@\n-    _misc_has_injected_primitiveObject        = 1 << 23  \/\/ PrimitiveObject has been injected by the JVM\n+    _misc_has_injected_primitiveObject        = 1 << 23, \/\/ PrimitiveObject has been injected by the JVM\n+    _misc_has_restricted_fields               = 1 << 24  \/\/ class has fields with type restrictions\n@@ -480,1 +482,1 @@\n-    return (_misc_flags & _misc_has_injected_identityObject);\n+    return (_misc_flags & _misc_has_injected_identityObject) != 0;\n@@ -495,0 +497,8 @@\n+  bool has_restricted_fields() const {\n+    return (_misc_flags & _misc_has_restricted_fields) != 0;\n+  }\n+\n+  void set_has_restricted_fields() {\n+    _misc_flags |= _misc_has_restricted_fields;\n+  }\n+\n@@ -559,0 +569,1 @@\n+  bool    field_has_restricted_type(int index) const { return field(index)->has_restricted_type(); }\n@@ -1189,1 +1200,1 @@\n-                  int java_fields, bool is_inline_type) {\n+                  int java_fields, bool is_inline_type, bool has_restricted_fields) {\n@@ -1198,1 +1209,2 @@\n-           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0) +\n+           (has_restricted_fields ? (align_up(java_fields * (int)sizeof(u2), wordSize)\/wordSize) : 0));\n@@ -1207,1 +1219,2 @@\n-                                               is_inline_klass());\n+                                               is_inline_klass(),\n+                                               has_restricted_fields());\n@@ -1223,0 +1236,2 @@\n+  inline u2* fields_descriptor_type() const;\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -306,0 +307,29 @@\n+inline u2* InstanceKlass::fields_descriptor_type() const {\n+    assert(has_restricted_fields(), \"Should not be called otherwise\");\n+    if (is_inline_klass()) {\n+      return (u2*)((address)(InlineKlass::cast((Klass*)this)->inlineklass_static_block()) + sizeof(InlineKlassFixedBlock));\n+    }\n+\n+    address adr_jf = adr_inline_type_field_klasses();\n+    if (adr_jf != NULL) {\n+      return (u2*)(adr_jf + this->java_fields_count() * sizeof(Klass*));\n+    }\n+\n+    address adr_fing = adr_fingerprint();\n+    if (adr_fing != NULL) {\n+      return (u2*)(adr_fingerprint() + sizeof(u8));\n+    }\n+\n+    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n+    if (adr_host != NULL) {\n+      return (u2*)(adr_host + 1);\n+    }\n+\n+    Klass* volatile* adr_impl = adr_implementor();\n+    if (adr_impl != NULL) {\n+      return (u2*)(adr_impl + 1);\n+    }\n+\n+    return (u2*)end_of_nonstatic_oop_maps();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  int size = Method::size(access_flags.is_native());\n+  int size = Method::size(access_flags.is_native(), sizes);\n@@ -179,0 +179,33 @@\n+\n+void  Method::resolve_restricted_types(TRAPS) {\n+  int idx = constMethod()->restricted_return_value_index();\n+  Handle loader_h(THREAD, constants()->pool_holder()->class_loader());\n+  Handle protdom_h(THREAD, constants()->pool_holder()->protection_domain());\n+  if (idx != 0) {\n+    Symbol* ret = constants()->symbol_at(idx);\n+    Klass* k = SystemDictionary::resolve_or_fail(ret, loader_h, protdom_h, true, CHECK);\n+    *restricted_return_value_addr() = k;\n+  } else {\n+    *restricted_return_value_addr() = NULL;\n+  }\n+  Klass** param_array = restricted_param_type_start();\n+  for (int i = 0; i < restricted_num_param(); i++) {\n+    int idx = constMethod()->restricted_param_type_index_at(i);\n+    if (idx != 0) {\n+      Symbol* ret = constants()->symbol_at(idx);\n+      Klass* k = SystemDictionary::resolve_or_fail(ret, loader_h, protdom_h, true, CHECK);\n+      param_array[i] = k;\n+    } else {\n+      param_array[i] = NULL;\n+    }\n+  }\n+}\n+\n+Klass* Method::restricted_return_value() const {\n+  return *restricted_return_value_addr();\n+}\n+\n+Klass* Method::restricted_param_type_at(int index) const {\n+  return restricted_param_type_start()[index];\n+}\n+\n@@ -344,1 +377,1 @@\n-int Method::size(bool is_native) {\n+int Method::size(bool is_native, InlineTableSizes* sizes) {\n@@ -347,0 +380,3 @@\n+  if (sizes->restricted_method_length() != -1) {\n+    extra_bytes += (sizes->restricted_method_length() + 1) * sizeof(Klass*); \/\/ +1 is for the return value type\n+  }\n@@ -1618,0 +1654,1 @@\n+  int restricted_method_len = 0;\n@@ -1630,0 +1667,1 @@\n+      restricted_method_len,\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+ friend class TemplateTable;\n@@ -97,1 +98,2 @@\n-    _scoped                = 1 << 11\n+    _scoped                = 1 << 11,\n+    _restricted_method     = 1 << 12\n@@ -175,0 +177,6 @@\n+  \/\/ RestrictedMethod support\n+  void resolve_restricted_types(TRAPS);\n+  Klass* restricted_return_value() const;\n+  u1 restricted_num_param() const                { return constMethod()->restricted_num_param(); }\n+  Klass* restricted_param_type_at(int index) const;\n+\n@@ -711,1 +719,1 @@\n-  static int size(bool is_native);\n+  static int size(bool is_native, InlineTableSizes* sizes);\n@@ -956,0 +964,8 @@\n+  void set_restricted_method(bool x) {\n+    _flags = x ? (_flags | _restricted_method) : ( _flags & ~_restricted_method);\n+  }\n+\n+  bool has_restricted_method() const {\n+    return (_flags & _restricted_method) != 0;\n+  }\n+\n@@ -1080,0 +1096,2 @@\n+  Klass** restricted_return_value_addr() const   { return is_native() ? (Klass**)(signature_handler_addr() + 1) : (Klass**) (this+1); }\n+  Klass** restricted_param_type_start() const    { return restricted_return_value_addr() + 1; }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -62,0 +62,7 @@\n+Symbol* fieldDescriptor::descriptor_signature() const {\n+  if (!has_restricted_type()) {\n+    return NULL;  \/\/ or the real signature could be returned\n+  }\n+  return _cp->symbol_at(field_holder()->fields_descriptor_type()[_index]);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  Symbol* descriptor_signature()  const;\n@@ -96,1 +97,1 @@\n-  inline bool is_inlined() const;\n+  inline bool is_inlined()        const;\n@@ -98,0 +99,1 @@\n+  inline bool has_restricted_type() const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+inline bool fieldDescriptor::has_restricted_type() const { return field()->has_restricted_type(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2272,0 +2272,3 @@\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_CONTENDED\", FIELDINFO_TAG_CONTENDED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_INLINED\", FIELDINFO_TAG_INLINED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_RESTRICTED\", FIELDINFO_TAG_RESTRICTED) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.invoke;\n+\n+import java.lang.annotation.*;\n+import static java.lang.annotation.ElementType.*;\n+\n+\/**\n+ * Annotation to facilitate type-restrictions experiments.\n+ *\n+ * When javac generates code for a field whose type is annotated by @RestrictedType(\"QFoo;\"),\n+ * it generates a RestrictedField attribute pointing to a Utf8 constant representing\n+ * the given String.\n+\n+ * The @RestrictedType annotation supports ad hoc attribute generation,\n+ * for more fine-grained control.\n+ *\n+*\/\n+@Retention(RetentionPolicy.SOURCE)\n+@Target(ElementType.TYPE_USE)\n+public @interface RestrictedType {\n+    \/**\n+     * @return the type descriptor string to be encoded in the RestrictedField attribute as a Utf8 constant\n+     *\/\n+    String value();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/RestrictedType.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -389,0 +389,3 @@\n+                if (c.isPrimitiveClass() && c.projection != null) {\n+                    c.projection.flags_field = (c.flags_field & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | SEALED;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,0 +142,4 @@\n+    \/** Flag is set for a type restricted field.\n+     *\/\n+    public static final int RESTRICTED_FIELD       = 1<<19;\n+\n@@ -518,0 +522,1 @@\n+        RESTRICTED_FIELD(Flags.RESTRICTED_FIELD),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-            return new MethodType(t.getParameterTypes().prepend(outerThisType),\n+            t = new MethodType(t.getParameterTypes().prepend(outerThisType),\n@@ -364,1 +364,2 @@\n-        } else {\n+        }\n+        if (!types.flattenWithTypeRestrictions) {\n@@ -367,0 +368,26 @@\n+        List<Type> rpt = List.nil();\n+        Type rrt = null;\n+        boolean mutateExternalType = false;\n+        \/\/ Computed restricted parameter types\n+        for (Type pt: t.getParameterTypes()) {\n+            if (pt.isPrimitiveClass()) {\n+                mutateExternalType = true;\n+                rpt = rpt.append(pt.referenceProjection());\n+            } else {\n+                rpt = rpt.append(pt);\n+            }\n+        }\n+        Type rt = t.getReturnType();\n+        if (rt.isPrimitiveClass()) {\n+            mutateExternalType = true;\n+            rrt = rt.referenceProjection();\n+        } else {\n+            rrt = rt;\n+        }\n+        if (mutateExternalType) {\n+            t = new MethodType(rpt,\n+                    rrt,\n+                    t.getThrownTypes(),\n+                    t.tsym);\n+        }\n+        return t;\n@@ -1678,3 +1705,0 @@\n-            if (!isPrimitiveClass())\n-                return null;\n-\n@@ -1695,1 +1719,1 @@\n-            long projectionFlags = (this.flags() & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | SEALED;\n+            long projectionFlags = (this.flags_field & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | SEALED;\n@@ -1699,14 +1723,17 @@\n-            for (Symbol s : this.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    valMethod.projection = refMethod;\n-                    refMethod.projection = valMethod;\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    valVar.projection = refVar;\n-                    refVar.projection = valVar;\n-                    clone = refVar;\n+            if (this.completer == Completer.NULL_COMPLETER) {\n+                for (Symbol s : this.members().getSymbols(s -> (s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n+                    Symbol clone = null;\n+                    if (s.kind == MTH) {\n+                        MethodSymbol valMethod = (MethodSymbol)s;\n+                        MethodSymbol refMethod = valMethod.clone(projection);\n+                        valMethod.projection = refMethod;\n+                        refMethod.projection = valMethod;\n+                        clone = refMethod;\n+                    } else if (s.kind == VAR) {\n+                        VarSymbol valVar = (VarSymbol)s;\n+                        VarSymbol refVar = valVar.clone(projection);\n+                        valVar.projection = refVar;\n+                        refVar.projection = valVar;\n+                        clone = refVar;\n+                    }\n+                    projection.members_field.enter(clone);\n@@ -1714,1 +1741,0 @@\n-                projection.members_field.enter(clone);\n@@ -1716,1 +1742,13 @@\n-            projection.completer = Completer.NULL_COMPLETER;\n+\n+            projection.completer = new Completer() {\n+                @Override\n+                public void complete(Symbol sym) throws CompletionFailure {\n+                    ClassSymbol.this.complete();\n+                }\n+\n+                @Override\n+                public boolean isTerminal() {\n+                    return ClassSymbol.this.completer.isTerminal();\n+                }\n+            };\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":60,"deletions":22,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+    public final Type restrictedTypeType;\n@@ -600,0 +601,1 @@\n+        restrictedTypeType = enterClass(\"java.lang.invoke.RestrictedType\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-                        (enclTr.getKind() == JCTree.Kind.MEMBER_SELECT ||\n+                        ((enclTr.getKind() == JCTree.Kind.MEMBER_SELECT  && !enclTy.isReferenceProjection()) ||  \/\/ .ref is only a pseudo member select.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+    \/** enable alternate code generation to faciliate specialization experiments using type restrictions *\/\n+    public boolean flattenWithTypeRestrictions;\n+\n@@ -129,0 +132,1 @@\n+        flattenWithTypeRestrictions = options.isSet(\"flattenWithTypeRestrictions\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1280,0 +1280,47 @@\n+            new AttributeReader(names.RestrictedField, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowPrimitiveClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind == VAR && sym.owner.kind == TYP) {\n+                        final Type type = poolReader.getType(nextChar());\n+                        if (types.flattenWithTypeRestrictions) {\n+                            Assert.check(((ClassSymbol)((ClassType)sym.type).tsym).projection == type.tsym);\n+                            sym.flags_field |= RESTRICTED_FIELD;\n+                        }\n+                    }\n+                }\n+            },\n+\n+            new AttributeReader(names.RestrictedMethod, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowPrimitiveClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (!types.flattenWithTypeRestrictions) {\n+                        bp = bp + attrLen;\n+                        return;\n+                    }\n+                    int paramCount = nextByte();\n+                    if (sym.name == names.init && sym.owner.hasOuterInstance())\n+                        paramCount --;\n+                    List<Type> paramTypes = List.nil();\n+                    for (int i = 0; i < paramCount; i++) {\n+                        int restrictedParamTypeIndex = nextChar();\n+                        paramTypes = paramTypes.append(\n+                                  restrictedParamTypeIndex == 0 ?\n+                                  sym.type.getParameterTypes().get(i)\n+                                : poolReader.getType(restrictedParamTypeIndex));\n+                    }\n+                    int restrictedReturnTypeIndex = nextChar();\n+                    Type returnType =\n+                            restrictedReturnTypeIndex == 0 || sym.isConstructor() ?\n+                                    sym.type.getReturnType()\n+                                    : poolReader.getType(restrictedReturnTypeIndex);\n+                    if (sym.kind == MTH && sym.owner.kind == TYP) {\n+                        sym.type = new MethodType(paramTypes, returnType, sym.type.getThrownTypes(), sym.type.tsym);\n+                    }\n+                }\n+            },\n@@ -2245,1 +2292,2 @@\n-        return v;\n+        return (v.flags_field & RESTRICTED_FIELD) == RESTRICTED_FIELD ?\n+                new VarSymbol(flags, name, ((ClassSymbol)v.type.tsym).projection.type, currentOwner) : v;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -976,1 +976,18 @@\n-        databuf.appendChar(poolWriter.putDescriptor(v));\n+        boolean emitRestrictedField = false;\n+        int restrictedFieldDescriptor = 0;\n+        if (types.flattenWithTypeRestrictions && v.type.isPrimitiveClass()) {\n+            emitRestrictedField = true;\n+            databuf.appendChar(poolWriter.putDescriptor(v.type.referenceProjection()));\n+        } else {\n+            databuf.appendChar(poolWriter.putDescriptor(v));\n+            for (Attribute.Compound anno : v.type.getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    Attribute member = anno.member(names.value);\n+                    Assert.check(member.type.tsym == syms.stringType.tsym);\n+                    String utf8 = (String) member.getValue();\n+                    restrictedFieldDescriptor = poolWriter.putName(names.fromString(utf8));\n+                    emitRestrictedField = true;\n+                }\n+            }\n+        }\n+\n@@ -985,0 +1002,10 @@\n+        if (emitRestrictedField) {\n+            int alenIdx = writeAttr(names.RestrictedField);\n+            if (types.flattenWithTypeRestrictions && v.type.isPrimitiveClass()) {\n+                databuf.appendChar(poolWriter.putDescriptor(v));\n+            }   else {\n+                databuf.appendChar(restrictedFieldDescriptor);\n+            }\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n@@ -1030,0 +1057,75 @@\n+        \/\/ See if we need to emit a RestrictedMethod attribute\n+        boolean emitRestrictedMethod = false;\n+\n+        if (types.flattenWithTypeRestrictions && m.name == m.name.table.names.init && m.owner.hasOuterInstance()) {\n+            Type outerThisType = types.erasure(m.owner.type.getEnclosingType());\n+            if (outerThisType.isPrimitiveClass()) {\n+                emitRestrictedMethod = true;\n+            }\n+        }\n+        CheckTypeRestrictedParameters:\n+        for (Type pt : m.type.getParameterTypes()) {\n+            if (pt.isPrimitiveClass() && types.flattenWithTypeRestrictions) {\n+                emitRestrictedMethod = true;\n+                break;\n+            }\n+            for (Attribute.Compound anno : pt.getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    emitRestrictedMethod = true;\n+                    break CheckTypeRestrictedParameters;\n+                }\n+            }\n+        }\n+        if (m.type.getReturnType().isPrimitiveClass() && types.flattenWithTypeRestrictions) {\n+            emitRestrictedMethod = true;\n+        } else {\n+            for (Attribute.Compound anno : m.type.getReturnType().getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    emitRestrictedMethod = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (emitRestrictedMethod) {\n+            int alenIdx = writeAttr(names.RestrictedMethod);\n+            databuf.appendByte(m.externalType(types).getParameterTypes().size());\n+            if (types.flattenWithTypeRestrictions) {\n+                if (m.name == names.init && m.owner.hasOuterInstance()) {\n+                    Type outerThisType = types.erasure(m.owner.type.getEnclosingType());\n+                    databuf.appendChar(outerThisType.isPrimitiveClass() ? poolWriter.putDescriptor(outerThisType) : 0);\n+                }\n+                for (Type pt : m.erasure(types).getParameterTypes()) {\n+                    databuf.appendChar(pt.isPrimitiveClass() ? poolWriter.putDescriptor(pt) : 0);\n+                }\n+                Type rt = m.erasure(types).getReturnType();\n+                databuf.appendChar(rt.isPrimitiveClass() ? poolWriter.putDescriptor(rt) : 0);\n+            } else {\n+                int restrictedTypeDescriptor;\n+                for (Type pt : m.type.getParameterTypes()) {\n+                    restrictedTypeDescriptor = 0;\n+                    for (Attribute.Compound anno : pt.getAnnotationMirrors()) {\n+                        if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                            Attribute member = anno.member(names.value);\n+                            Assert.check(member.type.tsym == syms.stringType.tsym);\n+                            String utf8 = (String) member.getValue();\n+                            restrictedTypeDescriptor = poolWriter.putName(names.fromString(utf8));\n+                        }\n+                    }\n+                    databuf.appendChar(restrictedTypeDescriptor);\n+                }\n+                restrictedTypeDescriptor = 0;\n+                Type rt = m.type.getReturnType();\n+                for (Attribute.Compound anno : rt.getAnnotationMirrors()) {\n+                    if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                        Attribute member = anno.member(names.value);\n+                        Assert.check(member.type.tsym == syms.stringType.tsym);\n+                        String utf8 = (String) member.getValue();\n+                        restrictedTypeDescriptor = poolWriter.putName(names.fromString(utf8));\n+                    }\n+                }\n+                databuf.appendChar(restrictedTypeDescriptor);\n+            }\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -37,0 +38,2 @@\n+import java.util.HashMap;\n+\n@@ -148,1 +151,5 @@\n-        return new StaticItem(member);\n+        if (this.types.flattenWithTypeRestrictions && member.kind == Kind.VAR && member.type.isPrimitiveClass()) {\n+            return new StaticItem(getFlattenedField(member));\n+        } else {\n+            return new StaticItem(member);\n+        }\n@@ -157,1 +164,5 @@\n-        return new MemberItem(member, nonvirtual);\n+        if (this.types.flattenWithTypeRestrictions && member.kind == Kind.VAR && member.type.isPrimitiveClass()) {\n+            return new MemberItem(getFlattenedField(member), nonvirtual);\n+        } else {\n+            return new MemberItem(member, nonvirtual);\n+        }\n@@ -159,0 +170,15 @@\n+        \/\/ where\n+        private Symbol getFlattenedField(Symbol member) {\n+            if (flatFieldsMap == null)\n+                flatFieldsMap = new HashMap<>();\n+            Symbol flatField = flatFieldsMap.get(member);\n+            if (flatField == null) {\n+                flatFieldsMap.put(member, flatField = new VarSymbol(member.flags(),\n+                                                        member.name,\n+                                                        member.type.referenceProjection(),\n+                                                        member.owner));\n+            }\n+            return flatField;\n+        }\n+\n+     private HashMap<Symbol, Symbol> flatFieldsMap;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Items.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+    public final Name RestrictedField;\n+    public final Name RestrictedMethod;\n@@ -340,0 +342,2 @@\n+        RestrictedField = fromString(\"RestrictedField\");\n+        RestrictedMethod = fromString(\"RestrictedMethod\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+    public static final String RestrictedField          = \"RestrictedField\";\n+    public static final String RestrictedMethod          = \"RestrictedMethod\";\n@@ -140,0 +142,2 @@\n+            standardAttributes.put(RestrictedField, RestrictedField_attribute.class);\n+            standardAttributes.put(RestrictedMethod, RestrictedMethod_attribute.class);\n@@ -207,0 +211,2 @@\n+        R visitRestrictedField(RestrictedField_attribute attr, P p);\n+        R visitRestrictedMethod(RestrictedMethod_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -656,0 +656,16 @@\n+        @Override\n+        public Void visitRestrictedField(RestrictedField_attribute attr, ClassOutputStream out) {\n+            out.writeShort(attr.restricted_type_index);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitRestrictedMethod(RestrictedMethod_attribute attr, ClassOutputStream out) {\n+            out.writeByte(attr.num_params);\n+            for (int i = 0; i < attr.num_params; i++) {\n+                out.writeShort(attr.restricted_param_type[i]);\n+            }\n+            out.writeShort(attr.restricted_return_type);\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * See JVMS, section 4.8.9.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+\n+public class RestrictedField_attribute extends Attribute {\n+    RestrictedField_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        restricted_type_index = cr.readUnsignedShort();\n+    }\n+    public RestrictedField_attribute(ConstantPool constant_pool, int restricted_type_index)\n+            throws ConstantPoolException {\n+        this(constant_pool.getUTF8Index(Attribute.RestrictedField), restricted_type_index);\n+    }\n+    public RestrictedField_attribute(int name_index, int restricted_type_index) {\n+        super(name_index, 2);\n+        this.restricted_type_index = restricted_type_index;\n+    }\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitRestrictedField(this, data);\n+    }\n+\n+    public String getRestrictedType(ConstantPool constant_pool) throws ConstantPoolException {\n+        return constant_pool.getUTF8Value(restricted_type_index);\n+    }\n+\n+    public final int restricted_type_index;\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RestrictedField_attribute.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+\n+public class RestrictedMethod_attribute extends Attribute {\n+\n+    RestrictedMethod_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        num_params = cr.readUnsignedByte();\n+        restricted_param_type = new int [num_params];\n+        for (int i = 0; i < num_params; i++) {\n+            restricted_param_type[i] = cr.readUnsignedShort();\n+        }\n+        restricted_return_type = cr.readUnsignedShort();\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitRestrictedMethod(this, data);\n+    }\n+\n+    public int getParameterCount() {\n+        return num_params;\n+    }\n+\n+    public int getRestrictedParameterType(int i) {\n+        return restricted_param_type[i];\n+    }\n+\n+    public int getRestrictedReturnType() {\n+        return restricted_return_type;\n+    }\n+\n+    int num_params;\n+    int restricted_param_type[];\n+    int restricted_return_type;\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RestrictedMethod_attribute.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -64,0 +64,2 @@\n+import com.sun.tools.classfile.RestrictedField_attribute;\n+import com.sun.tools.classfile.RestrictedMethod_attribute;\n@@ -768,0 +770,16 @@\n+    @Override\n+    public Void visitRestrictedField(RestrictedField_attribute attr, Void p) {\n+        print(\"RestrictedField: #\" + attr.restricted_type_index);\n+        tab();\n+        println(\"\/\/ \" + getRestrictedType(attr));\n+        return null;\n+    }\n+\n+    String getRestrictedType(RestrictedField_attribute info) {\n+        try {\n+            return info.getRestrictedType(constant_pool);\n+        } catch (ConstantPoolException e) {\n+            return report(e);\n+        }\n+    }\n+\n@@ -804,0 +822,25 @@\n+    @Override\n+    public Void visitRestrictedMethod(RestrictedMethod_attribute attr, Void aVoid) {\n+        print(\"RestrictedMethod: (\");\n+        int tidx;\n+        String type;\n+        String unrestricted = \"<unrestricted>\";\n+        for (int i = 0, count = attr.getParameterCount(); i < count; i++) {\n+            tidx = attr.getRestrictedParameterType(i);\n+            try {\n+                type = tidx == 0 ? unrestricted : constant_pool.getUTF8Value(tidx);\n+            } catch (ConstantPoolException e) {\n+                    type = report(e);\n+            }\n+            print((i == 0 ? \"\" : \", \") + \"#\" + tidx + \" \" + type);\n+        }\n+        tidx = attr.getRestrictedReturnType();\n+        try {\n+            type = tidx == 0 ? unrestricted : constant_pool.getUTF8Value(tidx);\n+        } catch (ConstantPoolException e) {\n+            type = report(e);\n+        }\n+        println(\")#\" + tidx + \" \" + type);\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\n+\/*\n+ * @test\n+ * @summary Testing accessing flattened field from class with no knowledge of the type restriction\n+ * @library \/test\/lib\n+ * @compile SimpleTest.java IncompleteKnowledgeTest.java\n+ * @run main\/othervm -Xverify:none -Xcomp runtime.valhalla.typerestrictions.IncompleteKnowledgeTest\n+ *\/\n+public class IncompleteKnowledgeTest {\n+    public static void main(String[] args) {\n+\n+        double x = 0.0D;\n+        for (int i = 0; i < 100; i++) {\n+            SimpleTest st = new SimpleTest();\n+            x = st.p.x;\n+        }\n+        System.out.println(x);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/IncompleteKnowledgeTest.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+class PointBox {\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    static public Point.ref p84;\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    static public Object p71;\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    static primitive class Rec {\n+        @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+        public Point.ref p37;\n+\n+        @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+        public Object p23;\n+\n+        public Rec() { this.p37 = new Point(0.0, 0.0); this.p23 = new Point(0.0, 0.0);}\n+\n+        Rec setp37(Point.ref p) {\n+            Rec r = Rec.default;\n+            r = __WithField(r.p37, p);\n+            r = __WithField(r.p23, this.p23);\n+            return r;\n+        }\n+\n+        Rec setp23(Object o) {\n+            Rec r = Rec.default;\n+            r = __WithField(r.p37, this.p37);\n+            r = __WithField(r.p23, o);\n+            return r;\n+        }\n+    }\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    public Point.ref p368;\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    public Object p397;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/PointBox.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2021, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import java.lang.invoke.RestrictedType;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @summary Testing type restrictions on method arguments and return value\n+ * @library \/test\/lib\n+ * @compile RestrictedMethodTest.java\n+ * @run main\/othervm -Xint runtime.valhalla.typerestrictions.RestrictedMethodTest\n+ *\/\n+\n+interface RMInterface {\n+  default public void imethod(@RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o) {\n+    System.out.println(\"imethod says \"+o);\n+  }\n+}\n+\n+public class RestrictedMethodTest implements RMInterface {\n+  static primitive class Point {\n+    int x = 0;\n+    int y = 0;\n+  }\n+\n+  void oneRestrictedArgument(@RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o) {\n+    System.out.println(\"oneRestrictedArgument says \" + o);\n+  }\n+\n+  void twoRestrictedArguments(@RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o0,\n+                             @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o1) {\n+    System.out.println(\"twoRestrictedArguments says \" + o0 + \" \" + o1);\n+  }\n+\n+  void secondArgumentRestricted(long l, @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o) {\n+    System.out.println(\"secondArgumentRestricted says \" + l + \" \" + o);\n+  }\n+\n+  static void staticWithOneRestrictedArgument(@RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o) {\n+    System.out.println(\"staticWithOneRestrictedArgument says \" + o);\n+  }\n+\n+  static @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object restrictedReturnValue(Object o) {\n+    System.out.println(\"Returning \"+o);\n+    return o;\n+  }\n+\n+  static void testRMInterface(RMInterface i) {\n+    Point p = new Point();\n+    Throwable result = null;\n+    try {\n+      i.imethod(p);\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+      i.imethod(new Object());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+  }\n+  static void expectICC(Throwable t) {\n+    Asserts.assertNotNull(t, \"An error should have been thrown\");\n+    Asserts.assertTrue(t instanceof java.lang.IncompatibleClassChangeError, \"Wrong error type\");\n+  }\n+\n+  static void expectNoError(Throwable t) {\n+    Asserts.assertNull(t, \"No Error should have been thrown\");\n+  }\n+  public static void main(String[] args) {\n+    Point p = new Point();\n+    RestrictedMethodTest test = new RestrictedMethodTest();\n+    Throwable result = null;\n+    try {\n+      test.oneRestrictedArgument(p);\n+    }  catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+        test.oneRestrictedArgument(new Object());\n+    } catch(Throwable t) {\n+        result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    try {\n+      test.twoRestrictedArguments(p, new Point());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+      test.twoRestrictedArguments(new Object(), new Point());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    try {\n+      test.twoRestrictedArguments(p, new Object());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    try {\n+      test.secondArgumentRestricted(42L, p);\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+      test.secondArgumentRestricted(42L, new String(\"Duke\"));\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    \/\/ Is code robust againt null receiver?\n+    RestrictedMethodTest test2 = null;\n+    try {\n+        test2.oneRestrictedArgument(new Object());\n+    } catch(Throwable t) {\n+        result = t;\n+    }\n+    Asserts.assertNotNull(result, \"An NPE should have been thrown\");\n+    Asserts.assertTrue(result instanceof java.lang.NullPointerException, \"Wrong exception type\");\n+    result = null;\n+    try {\n+      staticWithOneRestrictedArgument(p);\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+        staticWithOneRestrictedArgument(new Object());\n+    } catch(Throwable t) {\n+        result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    testRMInterface(test);\n+    try {\n+      restrictedReturnValue(new Point());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+        restrictedReturnValue(new Object());\n+    } catch(Throwable t) {\n+        result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/RestrictedMethodTest.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+\n+\/*\n+ * @test RestrictedTypeAnnotationTest\n+ * @summary check that code can operate on a field with a restricted type only known by the JVM\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile -XDallowWithFieldOperator RestrictedTypeAnnotationTest.java PointBox.java\n+ * @run main\/othervm -XX:+TieredCompilation -XX:TieredStopAtLevel=1 -XX:CompileThreshold=100 runtime.valhalla.typerestrictions.RestrictedTypeAnnotationTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.*;\n+\n+public class RestrictedTypeAnnotationTest {\n+    static final int ITERATIONS = 500;\n+    static final Unsafe U = Unsafe.getUnsafe();\n+    static double d;\n+\n+    public static void main(String[] args) {\n+        PointBox pb = new PointBox();\n+        Class<?> c = PointBox.class;\n+        Field p368 = null;\n+        try {\n+            p368 = c.getDeclaredField(\"p368\");\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+            return;\n+        }\n+        Asserts.assertTrue(U.isFlattened(p368), \"field PointBox.p369 should be flattened\");\n+        Class<?> testClass = RestrictedTypeAnnotationTest.class;\n+        Method[] methods = testClass.getDeclaredMethods();\n+        for (Method m : methods) {\n+            if (Modifier.isStatic(m.getModifiers()) &&\n+                m.getName().startsWith(\"test\") &&\n+                m.getParameterCount() == 0) {\n+                    System.out.println(\"Invoking \" + m.getName());\n+                    try {\n+                        m.invoke(null);\n+                    } catch(Throwable t) {\n+                        t.printStackTrace();\n+                        return;\n+                    }\n+                }\n+        }\n+    }\n+\n+\n+    \/\/ Reading field x from flattened field p368 without knowing p368 is flattened (getfield)\n+    static void test1() {\n+        PointBox pb = new PointBox();\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            d = pb.p368.x;\n+        }\n+    }\n+\n+    \/\/ Writting to field p368 without knowning p368 is flattened (putfield)\n+    static void test2() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox pb = new PointBox();\n+            PointBox.Point p = new PointBox.Point(2.0, 3.0);\n+            pb.p368 = p;\n+            Asserts.assertEquals(pb.p368, p);\n+        }\n+    }\n+\n+    static PointBox.Point.ref spoint = new PointBox.Point(1.0, 2.0);\n+\n+    \/\/ Trying to write null to field p368 without knowing it is null-free (putfield)\n+    static void test3() {\n+        spoint = null;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox pb = new PointBox();\n+            Exception e = null;\n+            try {\n+                pb.p368 = spoint;\n+            } catch(NullPointerException npe) {\n+                e = npe;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing NPE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Trying to write a value from the wrong type (pufield)\n+    static void test4() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox pb = new PointBox();\n+            Error e = null;\n+            try {\n+                pb.p397 = new String(\"hello\");\n+            } catch(IncompatibleClassChangeError icce) {\n+                e = icce;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing ICCE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Writting to field p368 without knowning p368 is flattened (withfield)\n+    static void test5() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox.Rec rec = new PointBox.Rec();\n+            PointBox.Point p = new PointBox.Point(2.0, 3.0);\n+            rec = rec.setp37(p);\n+            Asserts.assertEquals(rec.p37, p);\n+        }\n+    }\n+\n+    \/\/ Trying to write null to field p368 without knowing it is null-free (withfield)\n+    static void test6() {\n+        spoint = null;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox.Rec rec = new PointBox.Rec();\n+            Exception e = null;\n+            try {\n+                rec.setp37(spoint);\n+            } catch(NullPointerException npe) {\n+                e = npe;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing NPE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Trying to write a value from the wrong type (withield)\n+    static void test7() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox.Rec rec = new PointBox.Rec();\n+            Error e = null;\n+            try {\n+                rec.setp23(new String(\"hello\"));\n+            } catch(IncompatibleClassChangeError icce) {\n+                e = icce;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing ICCE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Trying to write null to field p368 without knowing it is null-free (putstatic)\n+    static void test8() {\n+        spoint = null;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            Exception e = null;\n+            try {\n+                PointBox.p84 = spoint;\n+            } catch(NullPointerException npe) {\n+                e = npe;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing NPE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Trying to write a value from the wrong type (putstatic)\n+    static void test9() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            Error e = null;\n+            try {\n+                PointBox.p71 = new String(\"hello\");\n+            } catch(IncompatibleClassChangeError icce) {\n+                e = icce;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing ICCE\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/RestrictedTypeAnnotationTest.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @summary Simple test about type restrictions\n+ * @library \/test\/lib\n+ * @compile SimpleTest.java\n+ * @run main\/othervm -Xint runtime.valhalla.typerestrictions.SimpleTest\n+ *\/\n+public class SimpleTest {\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public Point p;\n+\n+    public static void main(String... args) {\n+        SimpleTest b = new SimpleTest();\n+        if (b.p != new Point(0,0)) throw new RuntimeException();\n+        b.p = new Point(1.0, 2.0);\n+        if (b.p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/SimpleTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -1374,0 +1374,10 @@\n+\n+        @Override\n+        public Void visitRestrictedField(RestrictedField_attribute attr, T p) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitRestrictedMethod(RestrictedMethod_attribute attr, T p) {\n+            return null;\n+        }\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+    public R visitRestrictedField(RestrictedField_attribute attr, P p) { return null; }\n+    public R visitRestrictedMethod(RestrictedMethod_attribute attr, P p) { return null; }\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AttributeVisitor.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260870\n+ * @summary Generate RestrictedMethod attributes from annotations\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @run main AnnotatedRestrictedMethodTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+public class AnnotatedRestrictedMethodTest {\n+\n+    primitive class Point {}\n+    primitive class Line {}\n+\n+    Point foo(int x, Point p, int y, Line l) {\n+        return p;\n+    }\n+\n+    @RestrictedType(\"QAnnotatedRestrictedMethodTest$Point;\")\n+    Object goo(int x,\n+               @RestrictedType(\"QAnnotatedRestrictedMethodTest$Point;\") Object p,\n+               int y,\n+               @RestrictedType(\"QAnnotatedRestrictedMethodTest$Line;\") Object l) {\n+        return p;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(AnnotatedRestrictedMethodTest.class.getResourceAsStream(\"AnnotatedRestrictedMethodTest.class\"));\n+\n+        for (Method meth: cls.methods) {\n+            if (meth.getName(cls.constant_pool).equals(\"foo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(IQAnnotatedRestrictedMethodTest$Point;IQAnnotatedRestrictedMethodTest$Line;)QAnnotatedRestrictedMethodTest$Point;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method\");\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma != null) {\n+                    throw new AssertionError(\"Unexpected restricted method attribute\");\n+                }\n+            } else if (meth.getName(cls.constant_pool).equals(\"goo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(ILjava\/lang\/Object;ILjava\/lang\/Object;)Ljava\/lang\/Object;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method \" + desc);\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma == null) {\n+                    throw new AssertionError(\"Missing restricted method attribute\");\n+                }\n+\n+                if (rma.getParameterCount() != 4) {\n+                    throw new AssertionError(\"Wrong parameter count\");\n+                }\n+                int typeindex;\n+                String type;\n+                for (int i = 0; i < 4; i++) {\n+                    typeindex = rma.getRestrictedParameterType(i);\n+                    switch(i) {\n+                        case 0:\n+                        case 2:\n+                            if (typeindex != 0) {\n+                                throw new AssertionError(\"Unexpected type restriction\");\n+                            }\n+                            break;\n+                        case 1:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Point;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                        case 3:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Line;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                    }\n+                }\n+                typeindex = rma.getRestrictedReturnType();\n+                if (typeindex == 0) {\n+                    throw new AssertionError(\"Missing type restriction\");\n+                }\n+                if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Point;\")) {\n+                    throw new AssertionError(\"Unexpected type restriction \" + type);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AnnotatedRestrictedMethodTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260870\n+ * @summary Generate RestrictedMethod attributes triggered via compile time flag\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDflattenWithTypeRestrictions FlaggedRestrictedMethodTest.java\n+ * @run main FlaggedRestrictedMethodTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+public class FlaggedRestrictedMethodTest {\n+\n+    primitive class Point {}\n+    primitive class Line {}\n+\n+    static Point foo(int x, Point p, int y, Line l) {\n+        return p;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(FlaggedRestrictedMethodTest.class.getResourceAsStream(\"FlaggedRestrictedMethodTest.class\"));\n+\n+        for (Method meth: cls.methods) {\n+            if (meth.getName(cls.constant_pool).equals(\"foo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(ILFlaggedRestrictedMethodTest$Point$ref;ILFlaggedRestrictedMethodTest$Line$ref;)LFlaggedRestrictedMethodTest$Point$ref;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method\" + desc);\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma == null) {\n+                    throw new AssertionError(\"Missing restricted method attribute\");\n+                }\n+\n+                if (rma.getParameterCount() != 4) {\n+                    throw new AssertionError(\"Wrong parameter count\");\n+                }\n+                int typeindex;\n+                String type;\n+                for (int i = 0; i < 4; i++) {\n+                    typeindex = rma.getRestrictedParameterType(i);\n+                    switch(i) {\n+                        case 0:\n+                        case 2:\n+                            if (typeindex != 0) {\n+                                throw new AssertionError(\"Unexpected type restriction\");\n+                            }\n+                            break;\n+                        case 1:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Point;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                        case 3:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Line;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                    }\n+                }\n+                typeindex = rma.getRestrictedReturnType();\n+                if (typeindex == 0) {\n+                    throw new AssertionError(\"Missing type restriction\");\n+                }\n+                if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Point;\")) {\n+                    throw new AssertionError(\"Unexpected type restriction \" + type);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/FlaggedRestrictedMethodTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.RestrictedType;\n+\n+class PointBox {\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    @RestrictedType(\"QPoint;\")\n+    public Object p368;\n+\n+    public static void main(String... args) {\n+        PointBox b = new PointBox();\n+        if (b.p368 != new Point(0,0)) throw new RuntimeException();\n+        b.p368 = new Point(1.0, 2.0);\n+        if (b.p368 != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PointBox.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8257028\n+ * @summary Javac crashes on separate compilation.\n+ * @compile PointBox.java PointBoxTest.java\n+ * @compile PointBoxTest.java\n+ *\/\n+\n+public class PointBoxTest {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 1000; i++) {\n+            test1();\n+            test2();\n+            test3();\n+        }\n+    }\n+\n+    static void test1() {\n+        double x = 0.0D;\n+        for (int i = 0; i < 50000; i++) {\n+            PointBox pb = new PointBox();\n+            x = ((PointBox.Point)(pb.p368)).x;\n+            pb.p368 = new PointBox.Point(2.0, 3.0);\n+        }\n+    }\n+\n+    static void test2() {\n+        for (int i = 0; i < 50000; i++) {\n+            PointBox pb = new PointBox();\n+            pb.p368 = new PointBox.Point(2.0, 3.0);\n+        }\n+    }\n+\n+    static PointBox.Point.ref spoint = new PointBox.Point(1.0, 2.0);\n+\n+    static void test3() {\n+        spoint = null;\n+        for (int i = 0; i < 50000; i++) {\n+            PointBox pb = new PointBox();\n+            pb.p368 = spoint;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PointBoxTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253312\n+ * @summary Enable JVM experiments in specialization under an opt-in mode\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions RestrictedFieldCodegenTest.java\n+ * @run main\/othervm -Xverify:none RestrictedFieldCodegenTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+class PointBox {\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public Point p;\n+\n+    public static void main(String... args) {\n+        PointBox b = new PointBox();\n+        if (b.p != new Point(0,0)) throw new RuntimeException();\n+        b.p = new Point(1.0, 2.0);\n+        if (b.p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n+\n+public class RestrictedFieldCodegenTest {\n+\n+    public static void main(String [] args) {\n+        new RestrictedFieldCodegenTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"PointBox.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+         \"public PointBox$Point$ref p;\",\n+         \"descriptor: LPointBox$Point$ref;\",\n+         \"RestrictedField: #25                    \/\/ QPointBox$Point;\",\n+         \" 9: getfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         \"36: putfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         \"40: getfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         });\n+\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        System.out.println(\"Checking javap\");\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        System.out.println(\"Javap = \" + out);\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldCodegenTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8253312\n+ * @summary Enable JVM experiments in specialization under an opt-in mode\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions -XDrawDiagnostics RestrictedFieldCodegenTest.java\n+ * @compile\/fail\/ref=RestrictedFieldTypeTest.out -XDflattenWithTypeRestrictions -XDrawDiagnostics RestrictedFieldTypeTest.java\n+ *\/\n+\n+public class RestrictedFieldTypeTest {\n+    PointBox rft = new PointBox();\n+    void foo() {\n+        rft.p = null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldTypeTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+RestrictedFieldTypeTest.java:13:17: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, PointBox.Point)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldTypeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260870\n+ * @summary Flatten with type restrictions separate compilation test\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDflattenWithTypeRestrictions FlaggedRestrictedMethodTest.java\n+ * @compile\/fail\/ref=RestrictedMethodTest.out -XDrawDiagnostics -XDflattenWithTypeRestrictions RestrictedMethodTest.java\n+ *\/\n+\n+public class RestrictedMethodTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        FlaggedRestrictedMethodTest.foo(10, null, 20, null);\n+        FlaggedRestrictedMethodTest.foo(10, new FlaggedRestrictedMethodTest.Point(), 20, null);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedMethodTest.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+RestrictedMethodTest.java:38:36: compiler.err.cant.apply.symbol: kindname.method, foo, int,FlaggedRestrictedMethodTest.Point,int,FlaggedRestrictedMethodTest.Line, int,compiler.misc.type.null,int,compiler.misc.type.null, kindname.class, FlaggedRestrictedMethodTest, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlaggedRestrictedMethodTest.Point))\n+RestrictedMethodTest.java:39:45: compiler.err.encl.class.required: FlaggedRestrictedMethodTest.Point\n+RestrictedMethodTest.java:39:36: compiler.err.cant.apply.symbol: kindname.method, foo, int,FlaggedRestrictedMethodTest.Point,int,FlaggedRestrictedMethodTest.Line, int,FlaggedRestrictedMethodTest.Point,int,compiler.misc.type.null, kindname.class, FlaggedRestrictedMethodTest, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlaggedRestrictedMethodTest.Line))\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedMethodTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253760\n+ * @summary [type-restrictions] Static primitive value type fields are not \"erased\" to the ref type\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions RestrictedStaticFieldCodegenTest.java\n+ * @run main\/othervm -Xverify:none RestrictedStaticFieldCodegenTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+class PointBox {\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public static Point p;\n+\n+    public static void main(String... args) {\n+        if (p != new Point(0,0)) throw new RuntimeException();\n+        p = new Point(1.0, 2.0);\n+        if (p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n+\n+public class RestrictedStaticFieldCodegenTest {\n+\n+    public static void main(String [] args) {\n+        new RestrictedStaticFieldCodegenTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"PointBox.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+         \"public static PointBox$Point$ref p;\",\n+         \"descriptor: LPointBox$Point$ref;\",\n+         \"RestrictedField: #24                    \/\/ QPointBox$Point;\",\n+         \" 0: getstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         \"26: putstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         \"29: getstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         });\n+\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        System.out.println(\"Checking javap\");\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        System.out.println(\"Javap = \" + out);\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedStaticFieldCodegenTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255856 8257028\n+ * @summary Generate RestrictedField attributes from annotations\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDallowWithFieldOperator Point.java\n+ * @run main RestrictedTypeAnnotationCodegenTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+public class RestrictedTypeAnnotationCodegenTest {\n+\n+    primitive class Point {}\n+    primitive class Line {}\n+\n+    @RestrictedType(\"QRestrictedTypeAnnotationCodegenTest$Line;\")\n+    public Object jloFld = null;\n+\n+    @RestrictedType(\"QRestrictedTypeAnnotationCodegenTest$Point;\")\n+    public Point.ref refProjFld = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(InlineNestingAttributesTest.class.getResourceAsStream(\"RestrictedTypeAnnotationCodegenTest.class\"));\n+\n+        int goodFlds = 0;\n+        for (Field fld: cls.fields) {\n+            if (fld.getName(cls.constant_pool).equals(\"jloFld\")) {\n+               String desc = fld.descriptor.getValue(cls.constant_pool);\n+               RestrictedField_attribute rfa =\n+                    (RestrictedField_attribute) fld.attributes.get(Attribute.RestrictedField);\n+               if (rfa.getRestrictedType(cls.constant_pool).equals(\"QRestrictedTypeAnnotationCodegenTest$Line;\") && desc.equals(\"Ljava\/lang\/Object;\"))\n+                    goodFlds++;\n+            } else if (fld.getName(cls.constant_pool).equals(\"refProjFld\")) {\n+               String desc = fld.descriptor.getValue(cls.constant_pool);\n+               RestrictedField_attribute rfa =\n+                    (RestrictedField_attribute) fld.attributes.get(Attribute.RestrictedField);\n+               if (rfa.getRestrictedType(cls.constant_pool).equals(\"QRestrictedTypeAnnotationCodegenTest$Point;\") && desc.equals(\"LRestrictedTypeAnnotationCodegenTest$Point$ref;\"))\n+                    goodFlds++;\n+            }\n+        }\n+        if (goodFlds != 2) {\n+            throw new AssertionError(\"Lookup for 2 fields failed: Found only \" + goodFlds);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedTypeAnnotationCodegenTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}