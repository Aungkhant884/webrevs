{"files":[{"patch":"@@ -1383,0 +1383,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1515,0 +1517,16 @@\n+      } else if (_major_version >= JAVA_17_VERSION) {\n+        if (attribute_name == vmSymbols::tag_restricted_field()) {\n+          check_property(\n+            attribute_length == 2,\n+            \"Invalid RestrictedField field attribute length %u in class file %s\",\n+            attribute_length, CHECK);\n+            const u2 type_index = cfs->get_u2_fast();\n+            check_property(valid_symbol_at(type_index),\n+                          \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                            type_index, CHECK);\n+            *restricted_field_info = type_index;\n+            *has_restricted_type = true;\n+            set_has_restricted_fields();\n+        } else {\n+          cfs->skip_u1(attribute_length, CHECK);  \/\/ Skip unknown attributes\n+        }\n@@ -1669,0 +1687,2 @@\n+  _descriptor_signature_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1699,0 +1719,1 @@\n+\n@@ -1731,0 +1752,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1740,0 +1763,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1774,0 +1799,26 @@\n+    \/\/ RestrictedField:\n+    \/\/ The current model for restricted field is that such a field has a descriptor signature used\n+    \/\/ as the normal signature for this field (for instance in field access bytecodes) but it also\n+    \/\/ has a restricted type that will be used internally by the VM as the real type of the field.\n+    \/\/ Current constraints are that the restricted type must be an inline type and the descriptor\n+    \/\/ type must be a super type of the restricted type.\n+    \/\/ The code below verifies that the restricted type is an inline type. The property that the\n+    \/\/ descriptor type is a super type of the restricted type is verified just after the pre-loading\n+    \/\/ of the restricted type (inline type field preloading)\n+    if (has_restricted_type && cp->basic_type_for_signature_at(restricted_type_index) != T_INLINE_TYPE) {\n+      \/\/ Probably not the right error to throw\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Field %s.%s has a RestricteField attribute but its restricted type is not an inline type\",\n+                _class_name->as_C_string(),\n+                _cp->symbol_at(restricted_type_index)->as_C_string()));\n+    }\n+\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1777,1 +1828,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1779,0 +1830,3 @@\n+    _descriptor_signature_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1828,0 +1882,1 @@\n+      _descriptor_signature_info->append(0);\n@@ -1831,0 +1886,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1838,0 +1894,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1840,0 +1897,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1842,0 +1900,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1850,0 +1911,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1852,0 +1914,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -2630,0 +2693,4 @@\n+  bool has_restricted_method_attribute = false;\n+  const u1* restricted_param_types_start = NULL;\n+  u2 restricted_return_type_index = 0;\n+  u1 restricted_num_params = 0;\n@@ -2966,0 +3033,23 @@\n+      } else if (method_attribute_name == vmSymbols::tag_restricted_method()) {\n+        const u1* const current_start = cfs->current();\n+\n+        \/\/ RestrictedMethod_attribute {\n+        \/\/   u2 name_index;\n+        \/\/   u4 length;\n+        \/\/   u1 num_params;\n+        \/\/   u2 restricted_param_type[num_params];\n+        \/\/   u2 restricted_return_type;\n+        \/\/ }\n+\n+        has_restricted_method_attribute = true;\n+        cfs->guarantee_more(1, CHECK_NULL);  \/\/ num_params\n+        restricted_num_params = cfs->get_u1_fast();\n+        guarantee_property((int)method_attribute_length == restricted_num_params * 2 + 3,\n+                          \"Invalid RestrictedMethod attribute length %u in class file %s\",\n+                          method_attribute_length,\n+                          CHECK_NULL);\n+\n+        restricted_param_types_start = cfs->current();\n+        cfs->skip_u2_fast(restricted_num_params);\n+        cfs->guarantee_more(2, CHECK_NULL);  \/\/ restricted_return_type\n+        restricted_return_type_index = cfs->get_u2_fast();\n@@ -3005,0 +3095,4 @@\n+      \/\/ RestrictedMethod atribute requires a more complex protocol because num_params can be zeo\n+      \/\/ but the attribute still be there because of a restricted return value\n+      \/\/ So -1 is passed if the attribute is absent, otherwise num_params is passed\n+      has_restricted_method_attribute ? restricted_num_params : -1 ,\n@@ -3108,0 +3202,12 @@\n+  \/\/ Copy RestrictedMethod attribute if present\n+  if (has_restricted_method_attribute) {\n+    m->set_restricted_method(true);\n+    *(m->constMethod()->restricted_num_params_addr()) = restricted_num_params;\n+    *(m->constMethod()->restricted_return_type_index_addr()) = restricted_return_type_index;\n+    u2* cursor = m->constMethod()->restricted_param_type_start();\n+    for (int i = 0; i < restricted_num_params; i++) {\n+      cursor[i] = Bytes::get_Java_u2((address)restricted_param_types_start);\n+      restricted_param_types_start +=2;\n+    }\n+  }\n+\n@@ -5898,0 +6004,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_descriptor_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _descriptor_signature_info->at(i);\n+    }\n+  }\n+\n@@ -6102,0 +6216,1 @@\n+  _descriptor_signature_info(NULL),\n@@ -6143,0 +6258,1 @@\n+  _has_restricted_fields(false),\n@@ -6728,0 +6844,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6730,1 +6847,0 @@\n-      \/\/ Pre-load inline class\n@@ -6743,0 +6859,13 @@\n+      if (fs.has_restricted_type()) {\n+        \/\/ descriptor type supposed to be a super type of the restricted type, so after the pre-loading\n+        \/\/ of the restricted type above, the descriptor type should be loaded at this point\n+        Symbol* descriptor_name = _cp->symbol_at(_descriptor_signature_info->at(fs.index()));\n+        ResolvingSignatureStream rss(descriptor_name, Handle(THREAD, _loader_data->class_loader()), _protection_domain, false);\n+        Klass* desc_klass = rss.as_klass(SignatureStream::ReturnNull, CHECK);\n+        if (desc_klass == NULL || !klass->is_subtype_of(desc_klass)) {\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Restricted type %s should be a subtype of the descriptor type %s, but it is not\",\n+                    fs.signature()->as_C_string(),\n+                    descriptor_name->as_C_string()));\n+        }\n+      }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":131,"deletions":2,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  GrowableArray<u2>* _descriptor_signature_info;\n@@ -218,0 +219,1 @@\n+  bool _has_restricted_fields;\n@@ -286,0 +288,2 @@\n+                              u2* restricted_field_info,\n+                              bool* has_restricted_type,\n@@ -631,0 +635,2 @@\n+  void set_has_restricted_fields() { _has_restricted_fields = true; }\n+  bool has_restricted_fields() const { return _has_restricted_fields; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,0 +194,2 @@\n+  template(tag_restricted_field,                      \"RestrictedField\")                          \\\n+  template(tag_restricted_method,                     \"RestrictedMethod\")                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -476,1 +476,2 @@\n-                                       parser.is_inline_type());\n+                                       parser.is_inline_type(),\n+                                       parser.has_restricted_fields());\n@@ -511,0 +512,4 @@\n+  if (parser.has_restricted_fields()) {\n+    ik->set_has_restricted_fields(); \/\/ required to get the size right when calling size()\n+  }\n+\n@@ -1031,0 +1036,4 @@\n+      \/\/ Loadding classes of restricted parameters\n+      if (m->constMethod()->has_restricted_method()) {\n+        m->resolve_restricted_types(CHECK_false);\n+      }\n@@ -1256,0 +1265,1 @@\n+\n@@ -1660,4 +1670,14 @@\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n-      return true;\n+    if (f_name == name) {\n+      Symbol* f_sig = NULL;\n+      f_sig  = fs.signature();\n+      if (f_sig == sig) {\n+        fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+        return true;\n+      }\n+      if (fs.has_restricted_type()) {\n+        f_sig = fs.descriptor_signature();\n+        if (f_sig == sig) {\n+          fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+          return true;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\/\/    [EMBEDDED restricted_fields_info] only if has_restricted_fields() == true\n@@ -296,1 +297,2 @@\n-    _misc_has_injected_primitiveObject        = 1 << 23  \/\/ PrimitiveObject has been injected by the JVM\n+    _misc_has_injected_primitiveObject        = 1 << 23, \/\/ PrimitiveObject has been injected by the JVM\n+    _misc_has_restricted_fields               = 1 << 24  \/\/ class has fields with type restrictions\n@@ -480,1 +482,1 @@\n-    return (_misc_flags & _misc_has_injected_identityObject);\n+    return (_misc_flags & _misc_has_injected_identityObject) != 0;\n@@ -495,0 +497,8 @@\n+  bool has_restricted_fields() const {\n+    return (_misc_flags & _misc_has_restricted_fields) != 0;\n+  }\n+\n+  void set_has_restricted_fields() {\n+    _misc_flags |= _misc_has_restricted_fields;\n+  }\n+\n@@ -559,0 +569,1 @@\n+  bool    field_has_restricted_type(int index) const { return field(index)->has_restricted_type(); }\n@@ -1189,1 +1200,1 @@\n-                  int java_fields, bool is_inline_type) {\n+                  int java_fields, bool is_inline_type, bool has_restricted_fields) {\n@@ -1198,1 +1209,2 @@\n-           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0) +\n+           (has_restricted_fields ? (align_up(java_fields * (int)sizeof(u2), wordSize)\/wordSize) : 0));\n@@ -1207,1 +1219,2 @@\n-                                               is_inline_klass());\n+                                               is_inline_klass(),\n+                                               has_restricted_fields());\n@@ -1223,0 +1236,2 @@\n+  inline u2* fields_descriptor_type() const;\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+    public final Type restrictedTypeType;\n@@ -600,0 +601,1 @@\n+        restrictedTypeType = enterClass(\"java.lang.invoke.RestrictedType\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+    \/** enable alternate code generation to faciliate specialization experiments using type restrictions *\/\n+    public boolean flattenWithTypeRestrictions;\n+\n@@ -129,0 +132,1 @@\n+        flattenWithTypeRestrictions = options.isSet(\"flattenWithTypeRestrictions\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}