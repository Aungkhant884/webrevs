{"files":[{"patch":"@@ -608,2 +608,2 @@\n-        boolean tValue = t.isPrimitiveClass() || t.isValueClass();\n-        boolean sValue = s.isPrimitiveClass() || s.isValueClass();\n+        boolean tValue = t.isPrimitiveClass();\n+        boolean sValue = s.isPrimitiveClass();\n@@ -612,2 +612,2 @@\n-                    isSubtype(t.referenceProjectionOrSelf(), s) :\n-                    !t.hasTag(BOT) && isSubtype(t, s.referenceProjectionOrSelf());\n+                    isSubtype(t.referenceProjection(), s) :\n+                    !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-                if (env.info.inWithField && v.getKind() == ElementKind.FIELD && (v.flags() & STATIC) == 0 && (v.owner.type.isPrimitiveClass() || v.owner.type.isValueClass())) {\n+                if (env.info.inWithField && v.getKind() == ElementKind.FIELD && (v.flags() & STATIC) == 0 && v.owner.type.isValueClass()) {\n@@ -1537,2 +1537,2 @@\n-                        (sym.flags() & STATIC) != 0 || !(sym.owner.type.isPrimitiveClass() || sym.owner.type.isValueClass())) {\n-                    log.error(tree.field.pos(), Errors.PrimitiveOrValueClassInstanceFieldExpectedHere);\n+                        (sym.flags() & STATIC) != 0 || !sym.owner.type.isValueClass()) {\n+                    log.error(tree.field.pos(), Errors.ValueClassInstanceFieldExpectedHere);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-            if ((v.flags_field & FINAL) != 0 && ((v.flags_field & STATIC) != 0 || !(v.owner.isPrimitiveClass() || v.owner.isValueClass())) &&\n+            if ((v.flags_field & FINAL) != 0 && ((v.flags_field & STATIC) != 0 || !v.owner.isValueClass()) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3940,2 +3940,2 @@\n-compiler.err.primitive.or.value.class.instance.field.expected.here=\\\n-    withfield operator requires an instance field of a primitive or a value class here\n+compiler.err.value.class.instance.field.expected.here=\\\n+    withfield operator requires an instance field of a value class here\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/\/ key: compiler.err.primitive.or.value.class.instance.field.expected.here\n+\/\/ key: compiler.err.value.class.instance.field.expected.here\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveClassInstanceFieldExpectedHere.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-            x = __WithField(x.v, null); \/\/ null cannot be assigned to value\n+            x = __WithField(x.v, null); \/\/ null cannot be assigned to primitive class instance\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/WithFieldOperatorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,3 +2,3 @@\n-WithFieldOperatorTest.java:26:33: compiler.err.primitive.or.value.class.instance.field.expected.here\n-WithFieldOperatorTest.java:27:33: compiler.err.primitive.or.value.class.instance.field.expected.here\n-WithFieldOperatorTest.java:28:29: compiler.err.primitive.or.value.class.instance.field.expected.here\n+WithFieldOperatorTest.java:26:33: compiler.err.value.class.instance.field.expected.here\n+WithFieldOperatorTest.java:27:33: compiler.err.value.class.instance.field.expected.here\n+WithFieldOperatorTest.java:28:29: compiler.err.value.class.instance.field.expected.here\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/WithFieldOperatorTest.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8197911\n- * @summary Test Javac's treatment of null assignment to value instances\n- * @compile\/fail\/ref=FlattenableNegativeTest.out -XDallowWithFieldOperator -XDrawDiagnostics -XDdev FlattenableNegativeTest.java\n- *\/\n-\n-public class FlattenableNegativeTest {\n-    value final class V {\n-        final int x = 10;\n-\n-        value final class X {\n-            final V v = null;  \/\/ Error: initialization illegal\n-            final V v2 = v;    \/\/ OK, null not constant propagated.\n-\n-            V foo(X x) {\n-                x = __WithField(x.v, null);  \/\/ Error: withfield attempt is illegal.\n-                return x.v;\n-            }\n-        }\n-        V foo(X x) {\n-            x = __WithField(x.v, null); \/\/ withfield attempt is illegal\n-            return x.v;\n-        }\n-\n-        class Y {\n-            V v;\n-            V [] va = { null }; \/\/ Illegal array initialization\n-            V [] va2 = new V[] { null }; \/\/ Illegal array initialization\n-            void foo(X x) {\n-                x = __WithField(x.v, null); \/\/ illegal withfield attempt\n-                v = null; \/\/ illegal assignment.\n-                va[0] = null; \/\/ Illegal.\n-                va = new V[] { null }; \/\/ Illegal\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FlattenableNegativeTest.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,10 +0,0 @@\n-FlattenableNegativeTest.java:13:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:17:38: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:22:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:28:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:29:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:31:38: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:32:21: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:33:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-FlattenableNegativeTest.java:34:32: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableNegativeTest.V)\n-9 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FlattenableNegativeTest.out","additions":0,"deletions":10,"binary":false,"changes":10,"status":"deleted"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8197911\n+ * @summary Test Javac's treatment of null assignment to value instances\n+ * @compile -XDallowWithFieldOperator -XDrawDiagnostics -XDdev FlattenableTest.java\n+ *\/\n+\n+public class FlattenableTest {\n+    value final class V {\n+        final int x = 10;\n+\n+        value final class X {\n+            final V v = null;  \/\/ OK: initialization for value classes\n+            final V v2 = v;    \/\/ OK, null not constant propagated.\n+\n+            V foo(X x) {\n+                x = __WithField(x.v, null);  \/\/ OK: withfield is permitted here.\n+                return x.v;\n+            }\n+        }\n+        V foo(X x) {\n+            x = __WithField(x.v, null); \/\/ OK: withfield is permitted here.\n+            return x.v;\n+        }\n+\n+        class Y {\n+            V v;\n+            V [] va = { null }; \/\/ OK: array initialization\n+            V [] va2 = new V[] { null }; \/\/ OK: array initialization\n+            void foo(X x) {\n+                x = __WithField(x.v, null); \/\/ OK: withfield is permitted here.\n+                v = null; \/\/ legal assignment.\n+                va[0] = null; \/\/ legal.\n+                va = new V[] { null }; \/\/ legal\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FlattenableTest.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-            x = __WithField(x.v, null); \/\/ null cannot be assigned to value\n+            x = __WithField(x.v, null);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldOperatorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,3 +2,3 @@\n-WithFieldOperatorTest.java:26:33: compiler.err.primitive.or.value.class.instance.field.expected.here\n-WithFieldOperatorTest.java:27:33: compiler.err.primitive.or.value.class.instance.field.expected.here\n-WithFieldOperatorTest.java:28:29: compiler.err.primitive.or.value.class.instance.field.expected.here\n+WithFieldOperatorTest.java:26:33: compiler.err.value.class.instance.field.expected.here\n+WithFieldOperatorTest.java:27:33: compiler.err.value.class.instance.field.expected.here\n+WithFieldOperatorTest.java:28:29: compiler.err.value.class.instance.field.expected.here\n@@ -8,1 +8,0 @@\n-WithFieldOperatorTest.java:32:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, WithFieldOperatorTest.V)\n@@ -10,1 +9,1 @@\n-9 errors\n+8 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldOperatorTest.out","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}