{"files":[{"patch":"@@ -248,0 +248,9 @@\n+    \/\/ Does this type need to be preloaded in the context of the referring class ??\n+    public boolean requiresPreload(Symbol referringClass) {\n+        if (this.tsym == referringClass)\n+            return false; \/\/ pointless\n+        if (this.isReferenceProjection())\n+            return true;\n+        return this.isValueClass() && !this.isPrimitiveClass();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -855,1 +855,1 @@\n-     \/** Write out \"Preload\" attribute by enumerating the value classes encountered during this compilation.\n+     \/** Write out \"Preload\" attribute by enumerating the value classes encountered in field\/method descriptors during this compilation.\n@@ -857,1 +857,1 @@\n-     void writeValueClasses() {\n+     void writePreloadAttribute() {\n@@ -859,2 +859,2 @@\n-        databuf.appendChar(poolWriter.valueClasses.size());\n-        for (ClassSymbol c : poolWriter.valueClasses) {\n+        databuf.appendChar(poolWriter.preloadClasses.size());\n+        for (ClassSymbol c : poolWriter.preloadClasses) {\n@@ -979,0 +979,4 @@\n+        Type fldType = v.erasure(types);\n+        if (fldType.requiresPreload(v.owner)) {\n+            poolWriter.enterPreloadClass((ClassSymbol) fldType.tsym);\n+        }\n@@ -1004,0 +1008,10 @@\n+        MethodType mtype = (MethodType) m.externalType(types);\n+        for (Type t : mtype.getParameterTypes()) {\n+            if (t.requiresPreload(m.owner)) {\n+                poolWriter.enterPreloadClass((ClassSymbol) t.tsym);\n+            }\n+        }\n+        Type returnType = mtype.getReturnType();\n+        if (returnType.requiresPreload(m.owner)) {\n+            poolWriter.enterPreloadClass((ClassSymbol) returnType.tsym);\n+        }\n@@ -1596,1 +1610,1 @@\n-            case TYP: poolWriter.enterInnerAndValueClass((ClassSymbol)sym); break;\n+            case TYP: poolWriter.enterInnerClass((ClassSymbol)sym); break;\n@@ -1603,1 +1617,1 @@\n-                poolWriter.enterInnerAndValueClass(local);\n+                poolWriter.enterInnerClass(local);\n@@ -1694,2 +1708,2 @@\n-        if (!poolWriter.valueClasses.isEmpty()) {\n-            writeValueClasses();\n+        if (!poolWriter.preloadClasses.isEmpty()) {\n+            writePreloadAttribute();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1109,0 +1109,4 @@\n+        Type localType = v.erasure(types);\n+        if (localType.requiresPreload(env.enclClass.sym)) {\n+            poolWriter.enterPreloadClass((ClassSymbol) localType.tsym);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-    Set<ClassSymbol> valueClasses = new HashSet<>();\n+    Set<ClassSymbol> preloadClasses = new HashSet<>();\n@@ -253,1 +253,1 @@\n-    \/** Enter a value class into the `valueClasses' set.\n+    \/** Enter a value class into the `preloadClasses' set.\n@@ -255,1 +255,1 @@\n-    void enterValueClass(ClassSymbol c) {\n+    void enterPreloadClass(ClassSymbol c) {\n@@ -260,12 +260,1 @@\n-        if (c.isValueClass() && !c.isPrimitiveClass()) {\n-            valueClasses.add(c);\n-        }\n-        if (c.owner.enclClass() != null) {\n-            enterValueClass(c.owner.enclClass());\n-        }\n-    }\n-\n-\n-    void enterInnerAndValueClass(ClassSymbol c) {\n-        enterInnerClass(c);\n-        enterValueClass(c);\n+        preloadClasses.add(c);\n@@ -359,1 +348,1 @@\n-            enterInnerAndValueClass(c);\n+            enterInnerClass(c);\n@@ -412,1 +401,1 @@\n-                        enterInnerAndValueClass((ClassSymbol)ct.tsym);\n+                        enterInnerClass((ClassSymbol)ct.tsym);\n@@ -551,1 +540,1 @@\n-        valueClasses.clear();\n+        preloadClasses.clear();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280942\n+ * @summary Preload attribute should mention primitive classes when reference projection is used in descriptors\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @run main PreloadAttributeTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+public class PreloadAttributeTest {\n+\n+    public primitive class P1 {}\n+    public primitive class P2 {}\n+    public primitive class P3 {}\n+    public primitive class P4 {}\n+    public primitive class P5 {}\n+    public primitive class P6 {}\n+    public primitive class P7 {}\n+    public primitive class P8 {}\n+\n+    \/\/ We expect NO Preload Entries for ANY of P1 .. P4\n+    P1 p1;\n+    P2 foo(P3 p3) {\n+        P4 p4;\n+        return new P2();\n+    }\n+\n+    \/\/ We expect Preload Entries for ALL of P5 .. P8\n+    P5.ref p5;\n+    P6.ref foo(P7.ref p7) {\n+        P8.ref p8;\n+        return null;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(PreloadAttributeTest.class.getResourceAsStream(\"PreloadAttributeTest.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of Preload attribute *\/\n+        Preload_attribute preloads = (Preload_attribute) cls.attributes.get(Attribute.Preload);\n+        if (preloads == null) {\n+            throw new AssertionError(\"Missing Preload attribute!\");\n+        }\n+        if (preloads.number_of_classes != 4) {\n+            throw new AssertionError(\"Incorrect number of Preload classes\");\n+        }\n+\n+        int mask = 0xF0;\n+        for (int i = 0; i < preloads.number_of_classes; i++) {\n+            CONSTANT_Class_info clsInfo = cls.constant_pool.getClassInfo(\n+                                  preloads.value_class_info_index[i]);\n+            switch (clsInfo.getName()) {\n+                case \"PreloadAttributeTest$P5\":\n+                    mask &= ~16; break;\n+                case \"PreloadAttributeTest$P6\":\n+                    mask &= ~32; break;\n+                case \"PreloadAttributeTest$P7\":\n+                    mask &= ~64; break;\n+                case \"PreloadAttributeTest$P8\" :\n+                    mask &= ~128; break;\n+                default:\n+                    throw new AssertionError(\"Unexpected Preload class entry: \" + clsInfo.getName());\n+            }\n+        }\n+        if (mask != 0) {\n+          throw new AssertionError(\"Some Preload class entries are missing!\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PreloadAttributeTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-final value class V1 {}\n-final value class V2 {}\n-final value class V3 {}\n-final value class V4 {}\n-final value class V5 {}\n-final value class V6 {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/MultiValues.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8281323\n+ * @summary Check emission of Preload attribute to make sure javac does not emit unneeded entries.\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @run main NoUnnecessaryPreloadsTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+public class NoUnnecessaryPreloadsTest {\n+\n+    public value class PreLoadTest1 {\n+        byte b;\n+        public PreLoadTest1(byte b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    public class PreLoadTest2 {\n+        static class Inner1 {\n+            static value class Inner2 {}\n+            Inner2 inner;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ There should be no Preload attribute in NoUnnecessaryPreloadsTest.class\n+        ClassFile cls = ClassFile.read(NoUnnecessaryPreloadsTest.class.getResourceAsStream(\"NoUnnecessaryPreloadsTest.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of Preload attribute *\/\n+        Preload_attribute preloads = (Preload_attribute) cls.attributes.get(Attribute.Preload);\n+        if (preloads != null) {\n+            throw new AssertionError(\"Unexpected Preload attribute!\");\n+        }\n+\n+        \/\/ There should be no Preload attribute in NoUnnecessaryPreloadsTest$PreloadTest1.class\n+        cls = ClassFile.read(NoUnnecessaryPreloadsTest.class.getResourceAsStream(\"NoUnnecessaryPreloadsTest$PreLoadTest1.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of Preload attribute *\/\n+        preloads = (Preload_attribute) cls.attributes.get(Attribute.Preload);\n+        if (preloads != null) {\n+            throw new AssertionError(\"Unexpected Preload attribute!\");\n+        }\n+\n+        \/\/ There should be no Preload attribute in NoUnnecessaryPreloadsTest$PreloadTest2.class\n+        cls = ClassFile.read(NoUnnecessaryPreloadsTest.class.getResourceAsStream(\"NoUnnecessaryPreloadsTest$PreLoadTest2.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of Preload attribute *\/\n+        preloads = (Preload_attribute) cls.attributes.get(Attribute.Preload);\n+        if (preloads != null) {\n+            throw new AssertionError(\"Unexpected Preload attribute!\");\n+        }\n+\n+        \/\/ There should be no Preload attribute in NoUnnecessaryPreloadsTest$PreloadTest2$Inner2.class\n+        cls = ClassFile.read(NoUnnecessaryPreloadsTest.class.getResourceAsStream(\"NoUnnecessaryPreloadsTest$PreLoadTest2$Inner1$Inner2.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of Preload attribute *\/\n+        preloads = (Preload_attribute) cls.attributes.get(Attribute.Preload);\n+        if (preloads != null) {\n+            throw new AssertionError(\"Unexpected Preload attribute!\");\n+        }\n+\n+        \/\/ There should be ONE Preload attribute entry in NoUnnecessaryPreloadsTest$PreloadTest2$Inner1.class\n+        cls = ClassFile.read(NoUnnecessaryPreloadsTest.class.getResourceAsStream(\"NoUnnecessaryPreloadsTest$PreLoadTest2$Inner1.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of Preload attribute *\/\n+        preloads = (Preload_attribute) cls.attributes.get(Attribute.Preload);\n+        if (preloads == null) {\n+            throw new AssertionError(\"Missing Preload attribute!\");\n+        }\n+\n+        if (preloads.number_of_classes != 1) {\n+            throw new AssertionError(\"Incorrect number of Preload classes\");\n+        }\n+\n+        CONSTANT_Class_info clsInfo = cls.constant_pool.getClassInfo(preloads.value_class_info_index[0]);\n+        if (!clsInfo.getName().equals(\"NoUnnecessaryPreloadsTest$PreLoadTest2$Inner1$Inner2\")) {\n+            throw new AssertionError(\"Expected Preload class entry is missing, but found \" + clsInfo.getName());\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NoUnnecessaryPreloadsTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -29,2 +29,0 @@\n- * @compile MultiValues.java\n- * @compile -g PreloadAttributeTest.java\n@@ -39,0 +37,10 @@\n+    final value class V1 {}\n+    final value class V2 {}\n+    final value class V3 {}\n+    final value class V4 {}\n+    final value class V5 {}\n+    final value class V6 {}\n+    final value class V7 {}\n+    final value class V8 {}\n+    final value class V9 {}\n+\n@@ -40,2 +48,2 @@\n-        final V1 [] v1 = null; \/\/ field descriptor\n-        V2[] foo() {  \/\/ method descriptor encoding value type\n+        final V1 [] v1 = null; \/\/ field descriptor, encoding array type - no preload.\n+        V2 foo() {  \/\/ method descriptor encoding value type, to be preloaded\n@@ -44,1 +52,1 @@\n-        void foo(V3 v3) { \/\/ method descriptor encoding value type\n+        void foo(V3 v3) { \/\/ method descriptor encoding value type, to be preloaded\n@@ -47,1 +55,1 @@\n-            V4 [] v4 = null; \/\/ local variable.\n+            V4 [] v4 = null; \/\/ local variable encoding array type - no preload.\n@@ -49,2 +57,2 @@\n-        void goo() {\n-            V5 [] v5 = null;\n+        void goo(V6[] v6) { \/\/ parameter uses value type but as array component - no preload.\n+            V5 v5 = null;  \/\/ preload value type used for local type.\n@@ -57,0 +65,4 @@\n+        final V7 v7 = null; \/\/ field descriptor uses value type - to be preloaded.\n+        V8 [] goo(V9 [] v9) { \/\/ neither V8 nor V9 call for preload being array component types\n+            return null;\n+        }\n@@ -58,0 +70,1 @@\n+    \/\/ So we expect ONLY V2, V3 V5, V7 to be in Preload list\n@@ -71,1 +84,1 @@\n-        if (preloads.number_of_classes != 6) {\n+        if (preloads.number_of_classes != 4) {\n@@ -75,1 +88,1 @@\n-        int mask = 0x3F;\n+        int mask = 0x56;\n@@ -80,3 +93,1 @@\n-                case \"V1\":\n-                    mask &= ~1; break;\n-                case \"V2\":\n+                case \"PreloadAttributeTest$V2\":\n@@ -84,1 +95,1 @@\n-                case \"V3\":\n+                case \"PreloadAttributeTest$V3\":\n@@ -86,3 +97,1 @@\n-                case \"V4\":\n-                    mask &= ~8; break;\n-                case \"V5\":\n+                case \"PreloadAttributeTest$V5\":\n@@ -90,2 +99,4 @@\n-                case \"PreloadAttributeTest$X\":\n-                    mask &= ~32; break;\n+                case \"PreloadAttributeTest$V7\" :\n+                    mask &= ~64; break;\n+                default:\n+                    throw new AssertionError(\"Unexpected Preload class entry!\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/PreloadAttributeTest.java","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"}]}