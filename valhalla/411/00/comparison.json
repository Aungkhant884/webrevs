{"files":[{"patch":"@@ -321,4 +321,8 @@\n-      if ((class_name->is_Q_array_signature() && !k->is_inline_klass())) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n-          }\n-      k = k->array_klass(ndims, CHECK_NULL);\n+      if (class_name->is_Q_array_signature()) {\n+        if (!k->is_inline_klass()) {\n+          THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n+        }\n+        k = InlineKlass::cast(k)->null_free_inline_array_klass(ndims, CHECK_NULL);\n+      } else {\n+        k = k->array_klass(ndims, CHECK_NULL);\n+      }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -130,2 +130,2 @@\n-arrayOop oopFactory::new_flatArray(Klass* klass, int length, TRAPS) {\n-  assert(klass->is_inline_klass(), \"Klass must be inline type\");\n+arrayOop oopFactory::new_flatArray(Klass* k, int length, TRAPS) {\n+  InlineKlass* klass = InlineKlass::cast(k);\n@@ -133,1 +133,1 @@\n-  Klass* array_klass = klass->array_klass(1, CHECK_NULL);\n+  Klass* array_klass = klass->null_free_inline_array_klass(CHECK_NULL);\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {\n+Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS) {\n@@ -106,1 +106,0 @@\n-  bool is_qtype = element_klass->is_inline_klass();\n@@ -113,1 +112,1 @@\n-    if (is_qtype) {\n+    if (qdesc) {\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  static Symbol* create_element_klass_array_name(Klass* element_klass, TRAPS);\n+  static Symbol* create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {\n+FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* eklass, TRAPS) {\n@@ -90,1 +90,3 @@\n-  assert(InlineKlass::cast(element_klass)->is_naturally_atomic() || (!InlineArrayAtomicAccess), \"Atomic by-default\");\n+\n+  InlineKlass* element_klass = InlineKlass::cast(eklass);\n+  assert(element_klass->is_naturally_atomic() || (!InlineArrayAtomicAccess), \"Atomic by-default\");\n@@ -126,1 +128,1 @@\n-        ek = element_klass->array_klass(CHECK_NULL);\n+        ek = element_klass->null_free_inline_array_klass(CHECK_NULL);\n@@ -132,1 +134,1 @@\n-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, true, CHECK_NULL);\n@@ -351,1 +353,1 @@\n-        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n+        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, true, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  *((address*)adr_null_free_inline_array_klasses()) = NULL;\n@@ -167,18 +168,2 @@\n-void InlineKlass::remove_unshareable_info() {\n-  InstanceKlass::remove_unshareable_info();\n-\n-  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n-  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n-  *((address*)adr_pack_handler()) = NULL;\n-  *((address*)adr_pack_handler_jobject()) = NULL;\n-  *((address*)adr_unpack_handler()) = NULL;\n-  assert(pack_handler() == NULL, \"pack handler not null\");\n-}\n-\n-void InlineKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS) {\n-  InstanceKlass::restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK);\n-}\n-\n-Klass* InlineKlass::array_klass(int n, TRAPS) {\n-  \/\/ Need load-acquire for lock-free read\n-  if (array_klasses_acquire() == NULL) {\n+Klass* InlineKlass::null_free_inline_array_klass(int n, TRAPS) {\n+  if (Atomic::load_acquire(adr_null_free_inline_array_klasses()) == NULL) {\n@@ -192,1 +177,1 @@\n-      if (array_klasses() == NULL) {\n+      if (null_free_inline_array_klasses() == NULL) {\n@@ -197,1 +182,2 @@\n-          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, true, CHECK_NULL);\n+\n@@ -200,1 +186,1 @@\n-        release_set_array_klasses(k);\n+        Atomic::release_store(adr_null_free_inline_array_klasses(), k);\n@@ -204,2 +190,1 @@\n-  \/\/ array_klasses() will always be set at this point\n-  ArrayKlass* ak = array_klasses();\n+  ArrayKlass* ak = null_free_inline_array_klasses();\n@@ -209,1 +194,1 @@\n-Klass* InlineKlass::array_klass_or_null(int n) {\n+Klass* InlineKlass::null_free_inline_array_klass_or_null(int n) {\n@@ -211,1 +196,1 @@\n-  ArrayKlass* ak = array_klasses_acquire();\n+  ArrayKlass* ak = Atomic::load_acquire(adr_null_free_inline_array_klasses());\n@@ -219,2 +204,6 @@\n-Klass* InlineKlass::array_klass(TRAPS) {\n-  return array_klass(1, THREAD);\n+Klass* InlineKlass::null_free_inline_array_klass(TRAPS) {\n+  return null_free_inline_array_klass(1, THREAD);\n+}\n+\n+Klass* InlineKlass::null_free_inline_array_klass_or_null() {\n+  return null_free_inline_array_klass_or_null(1);\n@@ -223,2 +212,10 @@\n-Klass* InlineKlass::array_klass_or_null() {\n-  return array_klass_or_null(1);\n+\n+void InlineKlass::remove_unshareable_info() {\n+  InstanceKlass::remove_unshareable_info();\n+\n+  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n+  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n+  *((address*)adr_pack_handler()) = NULL;\n+  *((address*)adr_pack_handler_jobject()) = NULL;\n+  *((address*)adr_unpack_handler()) = NULL;\n+  assert(pack_handler() == NULL, \"pack handler not null\");\n@@ -227,0 +224,3 @@\n+void InlineKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS) {\n+  InstanceKlass::restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK);\n+}\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -78,0 +78,9 @@\n+  ArrayKlass* volatile* adr_null_free_inline_array_klasses() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return (ArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _null_free_inline_array_klasses));\n+  }\n+\n+  ArrayKlass* null_free_inline_array_klasses() const {\n+    return *adr_null_free_inline_array_klasses();\n+  }\n+\n@@ -132,9 +141,0 @@\n-  \/\/ Returns the array class for the n'th dimension\n-  virtual Klass* array_klass(int n, TRAPS);\n-  virtual Klass* array_klass_or_null(int n);\n-\n-  \/\/ Returns the array class with this class as element type\n-  virtual Klass* array_klass(TRAPS);\n-  virtual Klass* array_klass_or_null();\n-\n-\n@@ -171,0 +171,13 @@\n+  \/\/ null free inline arrays...\n+  \/\/\n+\n+  \/\/ null free inline array klass, akin to InstanceKlass::array_klass()\n+  \/\/ Returns the array class for the n'th dimension\n+  Klass* null_free_inline_array_klass(int n, TRAPS);\n+  Klass* null_free_inline_array_klass_or_null(int n);\n+\n+  \/\/ Returns the array class with this class as element type\n+  Klass* null_free_inline_array_klass(TRAPS);\n+  Klass* null_free_inline_array_klass_or_null();\n+\n+\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1577,1 +1577,2 @@\n-        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this,\n+                                                                  false, false, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+  ArrayKlass** _null_free_inline_array_klasses;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,3 @@\n-ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {\n+ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n,\n+                                       Klass* k, Symbol* name, bool null_free,\n+                                       TRAPS) {\n@@ -55,1 +57,1 @@\n-  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);\n+  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name, null_free);\n@@ -59,1 +61,3 @@\n-                                                      int n, Klass* element_klass, TRAPS) {\n+                                                      int n, Klass* element_klass,\n+                                                      bool null_free, bool qdesc, TRAPS) {\n+  assert(!null_free || (n == 1 && element_klass->is_inline_klass() && qdesc), \"null-free unsupported\");\n@@ -90,1 +94,5 @@\n-          ek = element_klass->array_klass(n, CHECK_NULL);\n+          if (null_free) {\n+            ek = InlineKlass::cast(element_klass)->null_free_inline_array_klass(CHECK_NULL);\n+          } else {\n+            ek = element_klass->array_klass(n, CHECK_NULL);\n+          }\n@@ -101,1 +109,1 @@\n-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, qdesc, CHECK_NULL);\n@@ -104,1 +112,1 @@\n-  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, null_free, CHECK_NULL);\n@@ -122,1 +130,1 @@\n-ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {\n+ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free) : ArrayKlass(name, ID) {\n@@ -138,2 +146,3 @@\n-  jint lh = array_layout_helper(T_OBJECT);\n-  if (element_klass->is_inline_klass()) {\n+  int lh = array_layout_helper(T_OBJECT);\n+  if (null_free) {\n+    assert(n == 1, \"Bytecode does not support null-free multi-dim\");\n@@ -179,1 +188,1 @@\n-    if (element_klass()->is_inline_klass()) {\n+    if (name()->is_Q_array_signature()) {\n@@ -341,1 +350,2 @@\n-        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n+        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n+                                                          false, this->name()->is_Q_array_signature(), CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-  ObjArrayKlass(int n, Klass* element_klass, Symbol* name);\n-  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);\n+  ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free);\n+  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, bool null_free, TRAPS);\n@@ -70,1 +70,2 @@\n-                                                int n, Klass* element_klass, TRAPS);\n+                                                int n, Klass* element_klass,\n+                                                bool null_free, bool qdesc, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-              class_loader_data(), dim + 1, this, CHECK_NULL);\n+              class_loader_data(), dim + 1, this, false, false, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}