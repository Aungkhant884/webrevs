{"files":[{"patch":"@@ -258,1 +258,1 @@\n-                                       CodeEmitInfo* info, bool is_inline_type) {\n+                                       CodeEmitInfo* info, bool is_null_free) {\n@@ -263,1 +263,1 @@\n-  _is_inline_type = is_inline_type;\n+  _is_null_free = is_null_free;\n@@ -273,1 +273,1 @@\n-  if (_is_inline_type) {\n+  if (_is_null_free) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -514,4 +514,2 @@\n-\n-  ciType* return_type = method->return_type();\n-  if (InlineTypeReturnedAsFields && return_type->is_inlinetype()) {\n-    ciInlineKlass* vk = return_type->as_inline_klass();\n+  if (InlineTypeReturnedAsFields && method->signature()->returns_null_free_inline_type()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n@@ -1632,1 +1630,1 @@\n-    __ tst(tmp, markWord::nullfree_array_bit_in_place);\n+    __ tst(tmp, markWord::null_free_array_bit_in_place);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1602,1 +1602,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, true, is_null_free_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n@@ -1606,1 +1606,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, false, is_non_null_free_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-                                       CodeEmitInfo* info, bool is_inline_type) {\n+                                       CodeEmitInfo* info, bool is_null_free) {\n@@ -318,1 +318,1 @@\n-  _is_inline_type = is_inline_type;\n+  _is_null_free = is_null_free;\n@@ -327,1 +327,1 @@\n-  if (_is_inline_type) {\n+  if (_is_null_free) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -534,3 +534,2 @@\n-  ciType* return_type = method->return_type();\n-  if (InlineTypeReturnedAsFields && return_type->is_inlinetype()) {\n-    ciInlineKlass* vk = return_type->as_inline_klass();\n+  if (InlineTypeReturnedAsFields && method->signature()->returns_null_free_inline_type()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n@@ -2033,1 +2032,1 @@\n-    __ testl(tmp, markWord::nullfree_array_bit_in_place);\n+    __ testl(tmp, markWord::null_free_array_bit_in_place);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2957,1 +2957,1 @@\n-void MacroAssembler::test_field_is_inline_type(Register flags, Register temp_reg, Label& is_inline_type) {\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n@@ -2959,1 +2959,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_inline_type_shift);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n@@ -2962,1 +2962,1 @@\n-  jcc(Assembler::notZero, is_inline_type);\n+  jcc(Assembler::notZero, is_null_free_inline_type);\n@@ -2965,1 +2965,1 @@\n-void MacroAssembler::test_field_is_not_inline_type(Register flags, Register temp_reg, Label& not_inline_type) {\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n@@ -2967,1 +2967,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_inline_type_shift);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n@@ -2970,1 +2970,1 @@\n-  jcc(Assembler::zero, not_inline_type);\n+  jcc(Assembler::zero, not_null_free_inline_type);\n@@ -3022,1 +3022,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, true, is_null_free_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n@@ -3032,1 +3032,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, false, is_non_null_free_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-  void test_field_is_inline_type(Register flags, Register temp_reg, Label& is_inline);\n-  void test_field_is_not_inline_type(Register flags, Register temp_reg, Label& not_inline);\n+  void test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free);\n+  void test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2995,1 +2995,1 @@\n-        Label is_inline_type, uninitialized;\n+        Label is_null_free_inline_type, uninitialized;\n@@ -2997,2 +2997,2 @@\n-        __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n-          \/\/ field is not an inline type\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n+          \/\/ field is not a null free inline type\n@@ -3001,2 +3001,2 @@\n-        \/\/ field is an inline type, must not return null even if uninitialized\n-        __ bind(is_inline_type);\n+        \/\/ field is a null free inline type, must not return null even if uninitialized\n+        __ bind(is_null_free_inline_type);\n@@ -3029,1 +3029,1 @@\n-        __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n@@ -3031,1 +3031,1 @@\n-      \/\/ field is not an inline type\n+      \/\/ field is not a null free inline type\n@@ -3382,1 +3382,1 @@\n-          __ test_field_is_not_inline_type(flags2, rscratch1, is_inline_type);\n+          __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n@@ -3391,1 +3391,1 @@\n-          __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n+          __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -679,1 +679,1 @@\n-      if (!is_interface && klass->is_subtype_of(x->klass())) {\n+      if (!is_interface && klass->is_subtype_of(x->klass()) && (!x->is_null_free() || obj->is_null_free())) {\n@@ -685,2 +685,2 @@\n-    \/\/ checkcast of null returns null for non-inline klasses\n-    if (!x->klass()->is_inlinetype() && obj->as_Constant() && obj->type()->as_ObjectType()->constant_value()->is_null_object()) {\n+    \/\/ checkcast of null returns null for non null-free klasses\n+    if (!x->is_null_free() && obj->is_null_obj()) {\n@@ -700,1 +700,1 @@\n-    if (obj->as_Constant() && obj->type()->as_ObjectType()->constant_value()->is_null_object()) {\n+    if (obj->as_Constant() && obj->is_null_obj()) {\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-  bool           _is_inline_type;\n+  bool           _is_null_free;\n@@ -389,1 +389,1 @@\n-  NewObjectArrayStub(LIR_Opr klass_reg, LIR_Opr length, LIR_Opr result, CodeEmitInfo* info, bool is_inline_type);\n+  NewObjectArrayStub(LIR_Opr klass_reg, LIR_Opr length, LIR_Opr result, CodeEmitInfo* info, bool is_null_free);\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1843,1 +1843,1 @@\n-      } else if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      } else if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1868,1 +1868,1 @@\n-      if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1886,1 +1886,1 @@\n-        if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+        if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1895,1 +1895,1 @@\n-              if (field->signature()->is_Q_signature() && field_value.is_null_or_zero()) {\n+              if (field->is_null_free() && field_value.is_null_or_zero()) {\n@@ -2041,1 +2041,1 @@\n-      if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -2473,1 +2473,1 @@\n-                              declared_signature->return_type()->is_inlinetype());\n+                              declared_signature->returns_null_free_inline_type());\n@@ -2517,1 +2517,1 @@\n-  bool null_free = stream()->is_inline_klass();\n+  bool null_free = stream()->has_Q_signature();\n@@ -2544,1 +2544,1 @@\n-  bool null_free = stream()->is_inline_klass();\n+  bool null_free = stream()->has_Q_signature();\n@@ -3572,1 +3572,1 @@\n-    state->store_local(idx, new Local(type, vt, idx, false, type->is_inlinetype()));\n+    state->store_local(idx, new Local(type, vt, idx, false, sig->is_null_free_at(i)));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  ciType* t =  declared_type();\n+  ciType* t = declared_type();\n@@ -141,2 +141,2 @@\n-      if (type->is_obj_array_klass()) {\n-        \/\/ Due to array covariance, the runtime type might be a flattened array.\n+      if (type->is_obj_array_klass() && !type->as_obj_array_klass()->is_elem_null_free()) {\n+        \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue.\n@@ -148,2 +148,0 @@\n-        ciKlass* element_klass = type->as_flat_array_klass()->element_klass();\n-        assert(!element_klass->is_loaded() || element_klass->flatten_array(), \"must be flattened\");\n@@ -169,2 +167,1 @@\n-      ciKlass* element_klass = type->as_obj_array_klass()->element_klass();\n-      if (element_klass->can_be_inline_klass()) {\n+      if (type->as_obj_array_klass()->can_be_inline_array_klass()) {\n@@ -293,1 +290,1 @@\n-  return ciArrayKlass::make(klass());\n+  return ciArrayKlass::make(klass(), is_null_free());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -864,1 +864,1 @@\n-    set_null_free(field->signature()->is_Q_signature());\n+    set_null_free(field->is_null_free());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1073,1 +1073,1 @@\n-      (method()->signature()->returns_inline_type() ||\n+      (method()->signature()->returns_null_free_inline_type() ||\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1741,1 +1741,1 @@\n-  if (field->signature()->is_Q_signature()) {\n+  if (field->is_null_free()) {\n@@ -2040,1 +2040,1 @@\n-  if (!field->signature()->is_Q_signature()) {\n+  if (!field->is_null_free()) {\n@@ -2128,1 +2128,1 @@\n-  if (field->signature()->is_Q_signature()) {\n+  if (field->is_null_free()) {\n@@ -3078,5 +3078,0 @@\n-  \/\/ Inline types can't be null\n-  if (exact_klass != NULL && exact_klass->is_inlinetype()) {\n-    do_null = false;\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -104,1 +105,1 @@\n-ciArrayKlass* ciArrayKlass::make(ciType* element_type) {\n+ciArrayKlass* ciArrayKlass::make(ciType* element_type, bool null_free) {\n@@ -107,2 +108,0 @@\n-  } else if (element_type->flatten_array()) {\n-    return ciFlatArrayKlass::make(element_type->as_klass());\n@@ -110,1 +109,13 @@\n-    return ciObjArrayKlass::make(element_type->as_klass());\n+    ciKlass* klass = element_type->as_klass();\n+    if (null_free && klass->is_loaded()) {\n+      GUARDED_VM_ENTRY(\n+        EXCEPTION_CONTEXT;\n+        Klass* ak = InlineKlass::cast(klass->get_Klass())->null_free_inline_array_klass(THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION;\n+        } else if (ak != NULL && ak->is_flatArray_klass()) {\n+          return ciFlatArrayKlass::make(klass);\n+        }\n+      )\n+    }\n+    return ciObjArrayKlass::make(klass, null_free);\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  static ciArrayKlass* make(ciType* element_type);\n+  static ciArrayKlass* make(ciType* klass, bool null_free = false);\n@@ -66,0 +66,2 @@\n+\n+  virtual bool is_elem_null_free() const { return false; }\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+class    ciWrapper;\n@@ -119,0 +120,1 @@\n+friend class  ciWrapper;               \\\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,2 @@\n-      return ciArrayKlass::make(elem_klass);\n+      bool null_free_array = sym->is_Q_array_signature() && sym->char_at(1) == JVM_SIGNATURE_INLINE_TYPE;\n+      return ciArrayKlass::make(elem_klass, null_free_array);\n@@ -605,1 +606,1 @@\n-bool ciEnv::is_inline_klass(const constantPoolHandle& cpool, int index) {\n+bool ciEnv::has_Q_signature(const constantPoolHandle& cpool, int index) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  bool       is_inline_klass(const constantPoolHandle& cpool,\n+  bool       has_Q_signature(const constantPoolHandle& cpool,\n@@ -475,0 +475,4 @@\n+\n+  ciWrapper* make_null_free_wrapper(ciType* type) {\n+    return _factory->make_null_free_wrapper(type);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,0 +108,3 @@\n+  \/\/ this is needed if the field class is not yet loaded.\n+  _is_null_free = _signature->is_Q_signature();\n+\n@@ -240,0 +243,1 @@\n+  _is_null_free = field->is_null_free();\n@@ -289,0 +293,1 @@\n+  _is_null_free = fd->signature()->is_Q_signature();\n@@ -486,0 +491,1 @@\n+  tty->print(\" is_null_free=%s\", bool_to_str(_is_null_free));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  bool             _is_null_free;\n@@ -180,0 +181,1 @@\n+  bool is_null_free            () const { return _is_null_free; }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -132,1 +133,0 @@\n-  assert(element_klass->is_inlinetype(), \"element type must be an inline type\");\n@@ -134,0 +134,1 @@\n+  assert(element_klass->is_inlinetype(), \"element type must be an inline type\");\n@@ -136,1 +137,1 @@\n-    Klass* array = element_klass->get_Klass()->array_klass(THREAD);\n+    Klass* array = InlineKlass::cast(element_klass->get_Klass())->null_free_inline_array_klass(THREAD);\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+\n+  virtual bool is_elem_null_free() const { return true; }\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  friend class ciArrayKlass;\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  virtual bool is_wrapper() const           { return false; }\n@@ -114,0 +115,4 @@\n+  ciWrapper*               as_wrapper() {\n+    assert(is_wrapper(), \"bad cast\");\n+    return (ciWrapper*)this;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -56,0 +57,1 @@\n+  _null_free = k->name()->is_Q_array_signature() && k->name()->char_at(1) == JVM_SIGNATURE_INLINE_TYPE;\n@@ -67,9 +69,10 @@\n-    _base_element_klass = base_element_klass;\n-    assert(_base_element_klass->is_instance_klass() ||\n-           _base_element_klass->is_type_array_klass() ||\n-           _base_element_klass->is_flat_array_klass(), \"bad base klass\");\n-    if (dimension == 1) {\n-      _element_klass = base_element_klass;\n-    } else {\n-      _element_klass = NULL;\n-    }\n+  _base_element_klass = base_element_klass;\n+  assert(_base_element_klass->is_instance_klass() ||\n+         _base_element_klass->is_type_array_klass() ||\n+         _base_element_klass->is_flat_array_klass(), \"bad base klass\");\n+  if (dimension == 1) {\n+    _element_klass = base_element_klass;\n+  } else {\n+    _element_klass = NULL;\n+  }\n+  _null_free = array_name->is_Q_array_signature() && array_name->char_at(1) == JVM_SIGNATURE_INLINE_TYPE;\n@@ -138,1 +141,1 @@\n-ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass) {\n+ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool null_free) {\n@@ -142,1 +145,7 @@\n-    Klass* array = element_klass->get_Klass()->array_klass(THREAD);\n+    Klass* array;\n+    if (null_free) {\n+      assert(element_klass->get_Klass()->is_inline_klass(), \"Only inline classes can have null free arrays\");\n+      array = InlineKlass::cast(element_klass->get_Klass())->null_free_inline_array_klass(THREAD);\n+    } else {\n+      array = element_klass->get_Klass()->array_klass(THREAD);\n+    }\n@@ -165,2 +174,2 @@\n-ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass) {\n-  GUARDED_VM_ENTRY(return make_impl(element_klass);)\n+ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool null_free) {\n+  GUARDED_VM_ENTRY(return make_impl(element_klass, null_free);)\n@@ -170,0 +179,4 @@\n+  \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+  if (!is_elem_null_free() && (!is_loaded() || element_klass()->is_inlinetype())) {\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  bool     _null_free;\n@@ -52,1 +53,1 @@\n-  static ciObjArrayKlass* make_impl(ciKlass* element_klass);\n+  static ciObjArrayKlass* make_impl(ciKlass* element_klass, bool null_free);\n@@ -75,1 +76,1 @@\n-  static ciObjArrayKlass* make(ciKlass* element_klass);\n+  static ciObjArrayKlass* make(ciKlass* element_klass, bool null_free = false);\n@@ -82,0 +83,2 @@\n+\n+  virtual bool is_elem_null_free() const { return _null_free; }\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -632,0 +632,6 @@\n+ciWrapper* ciObjectFactory::make_null_free_wrapper(ciType* type) {\n+  ciWrapper* wrapper = new (arena()) ciWrapper(type, \/* null_free *\/ true);\n+  init_ident_of(wrapper);\n+  return wrapper;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+  ciWrapper* make_null_free_wrapper(ciType* type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+    if (type->is_inlinetype() && ss.has_Q_descriptor()) {\n+      type = env->make_null_free_wrapper(type);\n+    }\n@@ -74,2 +77,2 @@\n-\/\/ ciSignature::returns_inline_type\n-bool ciSignature::returns_inline_type() const {\n+\/\/ ciSignature::returns_null_free_inline_type\n+bool ciSignature::returns_null_free_inline_type() const {\n@@ -79,0 +82,8 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciSignature::is_null_free_at\n+\/\/\n+\/\/ True if we know that the argument at 'index' is null-free.\n+bool ciSignature::is_null_free_at(int index) const {\n+  return _types.at(index)->is_null_free();\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciSignature.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciType.hpp\"\n@@ -59,2 +60,3 @@\n-  ciType*   type_at(int index) const             { return _types.at(index); }\n-  bool      returns_inline_type() const;\n+  ciType*   type_at(int index) const             { return _types.at(index)->unwrap(); }\n+  bool      returns_null_free_inline_type() const;\n+  bool      is_null_free_at(int index) const;\n","filename":"src\/hotspot\/share\/ci\/ciSignature.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-bool ciBytecodeStream::is_inline_klass() const {\n+bool ciBytecodeStream::has_Q_signature() const {\n@@ -202,1 +202,1 @@\n-  return CURRENT_ENV->is_inline_klass(cpool, get_klass_index());\n+  return CURRENT_ENV->has_Q_signature(cpool, get_klass_index());\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-  bool is_inline_klass() const;\n+  bool has_Q_signature() const;\n@@ -294,0 +294,8 @@\n+  bool is_null_free() {\n+    if (at_return_type()) {\n+      return _sig->returns_null_free_inline_type();\n+    } else {\n+      return _sig->is_null_free_at(_pos);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-bool ciSymbol::is_Q_signature() {\n+bool ciSymbol::is_Q_signature() const {\n@@ -122,0 +122,6 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciSymbol::is_Q_array_signature\n+bool ciSymbol::is_Q_array_signature() const {\n+  GUARDED_VM_ENTRY(return get_symbol()->is_Q_array_signature();)\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-  bool        is_Q_signature();\n+  bool is_Q_signature() const;\n+  bool is_Q_array_signature() const;\n","filename":"src\/hotspot\/share\/ci\/ciSymbol.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  friend class ciWrapper;\n@@ -74,0 +75,3 @@\n+  virtual ciType*     unwrap()              { return this; }\n+  virtual bool is_null_free() const         { return false; }\n+\n@@ -109,0 +113,31 @@\n+\/\/ ciWrapper\n+\/\/\n+\/\/ This class wraps another type to carry additional information like nullability.\n+\/\/ Should only be instantiated and used by ciTypeFlow and ciSignature.\n+class ciWrapper : public ciType {\n+  CI_PACKAGE_ACCESS\n+\n+private:\n+  ciType* _type;\n+  bool _null_free;\n+\n+  ciWrapper(ciType* type, bool null_free) : ciType(type->basic_type()) {\n+    assert(type->is_inlinetype()\n+          \/\/ An unloaded inline type is an instance_klass (see ciEnv::get_klass_by_name_impl())\n+          || (type->is_instance_klass() && !type->is_loaded()),\n+          \"should only be used for inline types\");\n+    _type = type;\n+    _null_free = null_free;\n+  }\n+\n+  const char* type_string() { return \"ciWrapper\"; }\n+\n+  void print_impl(outputStream* st) { _type->print_impl(st); }\n+\n+public:\n+  bool    is_wrapper() const { return true; }\n+\n+  ciType*     unwrap()       { return _type; }\n+  bool is_null_free() const { return _null_free; }\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -278,1 +278,11 @@\n-  } else if (t1->is_primitive_type() || t2->is_primitive_type()) {\n+  }\n+  \/\/ Unwrap after saving nullness information and handling top meets\n+  bool null_free1 = t1->is_null_free();\n+  bool null_free2 = t2->is_null_free();\n+  if (t1->unwrap() == t2->unwrap() && null_free1 == null_free2) {\n+    return t1;\n+  }\n+  t1 = t1->unwrap();\n+  t2 = t2->unwrap();\n+\n+  if (t1->is_primitive_type() || t2->is_primitive_type()) {\n@@ -280,1 +290,1 @@\n-    \/\/ is T (except for inline types).  null_type meet null_type is null_type.\n+    \/\/ is T. null_type meet null_type is null_type.\n@@ -282,4 +292,1 @@\n-      if (t2->is_inlinetype()) {\n-        \/\/ Inline types are null-free, return the super type\n-        return t2->as_inline_klass()->super();\n-      } else if (!t2->is_primitive_type() || t2->equals(null_type())) {\n+      if (!t2->is_primitive_type() || t2->equals(null_type())) {\n@@ -289,4 +296,1 @@\n-      if (t1->is_inlinetype()) {\n-        \/\/ Inline types are null-free, return the super type\n-        return t1->as_inline_klass()->super();\n-      } else if (!t1->is_primitive_type()) {\n+      if (!t1->is_primitive_type()) {\n@@ -323,0 +327,2 @@\n+      bool null_free = k1->as_array_klass()->is_elem_null_free() &&\n+                       k2->as_array_klass()->is_elem_null_free();\n@@ -330,2 +336,2 @@\n-      if (elem == elem1) {\n-        assert(k1 == ciArrayKlass::make(elem), \"shortcut is OK\");\n+      if (elem == elem1 && !elem->is_inlinetype()) {\n+        assert(k1 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n@@ -333,2 +339,2 @@\n-      } else if (elem == elem2) {\n-        assert(k2 == ciArrayKlass::make(elem), \"shortcut is OK\");\n+      } else if (elem == elem2 && !elem->is_inlinetype()) {\n+        assert(k2 == ciArrayKlass::make(elem, null_free), \"shortcut is OK\");\n@@ -337,1 +343,1 @@\n-        return ciArrayKlass::make(elem);\n+        return ciArrayKlass::make(elem, null_free);\n@@ -346,1 +352,5 @@\n-    return k1->least_common_ancestor(k2);\n+    ciType* result = k1->least_common_ancestor(k2);\n+    if (null_free1 && null_free2) {\n+      result = analyzer->mark_as_null_free(result);\n+    }\n+    return result;\n@@ -408,1 +418,6 @@\n-    state->push(method()->holder());\n+    ciType* holder = method()->holder();\n+    if (holder->is_inlinetype()) {\n+      \/\/ The receiver is null-free\n+      holder = mark_as_null_free(holder);\n+    }\n+    state->push(holder);\n@@ -414,1 +429,5 @@\n-    state->push_translate(str.type());\n+    ciType* arg = str.type();\n+    if (str.is_null_free()) {\n+      arg = mark_as_null_free(arg);\n+    }\n+    state->push_translate(arg);\n@@ -590,1 +609,5 @@\n-    push_object(element_klass);\n+    if (array_klass->is_elem_null_free()) {\n+      push(outer()->mark_as_null_free(element_klass));\n+    } else {\n+      push_object(element_klass);\n+    }\n@@ -600,0 +623,1 @@\n+  bool null_free = str->has_Q_signature();\n@@ -601,1 +625,1 @@\n-    if (str->is_inline_klass()) {\n+    if (null_free) {\n@@ -615,2 +639,6 @@\n-    pop_object();\n-    push_object(klass);\n+    ciType* type = pop_value();\n+    if (klass->is_inlinetype() && (null_free || type->is_null_free())) {\n+      push(outer()->mark_as_null_free(klass));\n+    } else {\n+      push_object(klass);\n+    }\n@@ -658,0 +686,3 @@\n+      if (field->is_null_free()) {\n+        field_type = outer()->mark_as_null_free(field_type);\n+      }\n@@ -725,0 +756,3 @@\n+        if (sigstr.is_null_free()) {\n+          return_type = outer()->mark_as_null_free(return_type);\n+        }\n@@ -749,1 +783,5 @@\n-        push_object(obj->klass());\n+        ciType* type = obj->klass();\n+        if (type->is_inlinetype()) {\n+          type = outer()->mark_as_null_free(type);\n+        }\n+        push(type);\n@@ -802,1 +840,1 @@\n-    push_object(klass);\n+    push(outer()->mark_as_null_free(klass));\n@@ -823,2 +861,1 @@\n-    assert(klass->is_inlinetype(), \"should be inline type\");\n-    push_object(klass);\n+    push(outer()->mark_as_null_free(klass));\n@@ -961,1 +998,2 @@\n-        push_object(ciArrayKlass::make(element_klass));\n+        bool null_free = str->has_Q_signature();\n+        push_object(ciArrayKlass::make(element_klass, null_free));\n@@ -3039,0 +3077,5 @@\n+ciType* ciTypeFlow::mark_as_null_free(ciType* type) {\n+  \/\/ Wrap the type to carry the information that it is null-free\n+  return env()->make_null_free_wrapper(type);\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":70,"deletions":27,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -842,0 +842,2 @@\n+  ciType* mark_as_null_free(ciType* type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5753,1 +5753,1 @@\n-      if (ik->field_is_inline_type(i)) {\n+      if (ik->field_is_null_free_inline_type(i)) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -779,0 +779,2 @@\n+int java_lang_Class::_primary_mirror_offset;\n+int java_lang_Class::_secondary_mirror_offset;\n@@ -1015,2 +1017,2 @@\n-        InlineKlass* vk = InlineKlass::cast(InstanceKlass::cast(element_klass));\n-        comp_mirror = Handle(THREAD, vk->java_mirror());\n+        InlineKlass* vk = InlineKlass::cast(element_klass);\n+        comp_mirror = Handle(THREAD, vk->val_mirror());\n@@ -1024,1 +1026,6 @@\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+        oop comp_oop = element_klass->java_mirror();\n+        if (element_klass->is_inline_klass()) {\n+          InlineKlass* ik = InlineKlass::cast(element_klass);\n+          comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+        }\n+        comp_mirror = Handle(THREAD, comp_oop);\n@@ -1064,0 +1071,6 @@\n+\n+    if (k->is_inline_klass()) {\n+      oop secondary_mirror = create_secondary_mirror(k, mirror, CHECK);\n+      set_primary_mirror(mirror(), mirror());\n+      set_secondary_mirror(mirror(), secondary_mirror);\n+    }\n@@ -1069,0 +1082,21 @@\n+\/\/ Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class\n+\/\/ instance with the same value as the primary mirror\n+oop java_lang_Class::create_secondary_mirror(Klass* k, Handle mirror, TRAPS) {\n+  assert(k->is_inline_klass(), \"primitive class\");\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK_0);\n+  Handle secondary_mirror(THREAD, mirror_oop);\n+\n+  java_lang_Class::set_klass(secondary_mirror(), k);\n+  java_lang_Class::set_static_oop_field_count(secondary_mirror(), static_oop_field_count(mirror()));\n+  \/\/ ## do we need to set init lock?\n+  java_lang_Class::set_init_lock(secondary_mirror(), init_lock(mirror()));\n+\n+  set_protection_domain(secondary_mirror(), protection_domain(mirror()));\n+  set_class_loader(secondary_mirror(), class_loader(mirror()));\n+  \/\/ ## handle if java.base is not yet defined\n+  set_module(secondary_mirror(), module(mirror()));\n+  set_primary_mirror(secondary_mirror(), mirror());\n+  set_secondary_mirror(secondary_mirror(), secondary_mirror());\n+  return secondary_mirror();\n+}\n@@ -1215,1 +1249,1 @@\n-    \/\/ Inline types have a val type mirror and a ref type mirror. Don't handle this for now. TODO:CDS\n+    \/\/ Inline types have a primary mirror and a secondary mirror. Don't handle this for now. TODO:CDS\n@@ -1435,0 +1469,20 @@\n+oop java_lang_Class::primary_mirror(oop java_class) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_primary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_primary_mirror(oop java_class, oop mirror) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_primary_mirror_offset, mirror);\n+}\n+\n+oop java_lang_Class::secondary_mirror(oop java_class) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_secondary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_secondary_mirror(oop java_class, oop mirror) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_secondary_mirror_offset, mirror);\n+}\n+\n@@ -1538,1 +1592,1 @@\n-  bool is_value = false;\n+  bool is_Q_descriptor = false;\n@@ -1544,1 +1598,1 @@\n-    is_value = k->is_inline_klass();\n+    is_Q_descriptor = k->is_inline_klass() && is_secondary_mirror(java_class);\n@@ -1552,5 +1606,1 @@\n-    if (is_value) {\n-      st->print(\"Q\");\n-    } else {\n-      st->print(\"L\");\n-    }\n+    st->print(is_Q_descriptor ? \"Q\" : \"L\");\n@@ -1578,1 +1628,6 @@\n-      const char* sigstr = k->signature_name();\n+      const char* sigstr;\n+      if (k->is_inline_klass() && is_secondary_mirror(java_class)) {\n+        sigstr = InlineKlass::cast(k)->val_signature_name();\n+      } else {\n+        sigstr = k->signature_name();\n+      }\n@@ -1659,0 +1714,2 @@\n+  macro(_primary_mirror_offset,      k, \"primaryType\",         class_signature,       false); \\\n+  macro(_secondary_mirror_offset,    k, \"secondaryType\",       class_signature,       false); \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":69,"deletions":12,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -279,0 +279,3 @@\n+  static int _primary_mirror_offset;\n+  static int _secondary_mirror_offset;\n+\n@@ -293,0 +296,3 @@\n+  static void set_primary_mirror(oop java_class, oop comp_mirror);\n+  static void set_secondary_mirror(oop java_class, oop comp_mirror);\n+\n@@ -305,0 +311,1 @@\n+  static oop  create_secondary_mirror(Klass* k, Handle mirror, TRAPS);\n@@ -352,0 +359,5 @@\n+  static oop  primary_mirror(oop java_class);\n+  static oop  secondary_mirror(oop java_class);\n+  static bool is_primary_mirror(oop java_class);\n+  static bool is_secondary_mirror(oop java_class);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -264,0 +264,18 @@\n+inline bool java_lang_Class::is_primary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == primary_mirror(java_class);\n+  } else {\n+    return true;\n+  }\n+}\n+\n+inline bool java_lang_Class::is_secondary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == secondary_mirror(java_class);\n+  } else {\n+    return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -321,5 +321,8 @@\n-      if ((class_name->is_Q_array_signature() && !k->is_inline_klass()) ||\n-          (!class_name->is_Q_array_signature() && k->is_inline_klass())) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n-          }\n-      k = k->array_klass(ndims, CHECK_NULL);\n+      if (class_name->is_Q_array_signature()) {\n+        if (!k->is_inline_klass()) {\n+          THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n+        }\n+        k = InlineKlass::cast(k)->null_free_inline_array_klass(ndims, CHECK_NULL);\n+      } else {\n+        k = k->array_klass(ndims, CHECK_NULL);\n+      }\n@@ -862,1 +865,5 @@\n-      k = k->array_klass_or_null(ndims);\n+      if (class_name->is_Q_array_signature()) {\n+        k = InlineKlass::cast(k)->null_free_inline_array_klass_or_null(ndims);\n+      } else {\n+        k = k->array_klass_or_null(ndims);\n+      }\n@@ -1856,1 +1863,5 @@\n-      klass = klass->array_klass_or_null(ndims);\n+      if (class_name->is_Q_array_signature()) {\n+        klass = InlineKlass::cast(klass)->null_free_inline_array_klass_or_null(ndims);\n+      } else {\n+        klass = klass->array_klass_or_null(ndims);\n+      }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -692,0 +692,2 @@\n+  template(primaryType_name,                           \"primaryType\")                                             \\\n+  template(secondaryType_name,                         \"secondaryType\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,3 @@\n-  oop java_class = klass->java_mirror();\n+  oop java_class = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(klass)->val_mirror()\n+                      : klass->java_mirror();\n@@ -353,1 +355,1 @@\n-      if (voop == NULL && cp_entry->is_inline_type()) {\n+      if (voop == NULL && cp_entry->is_null_free_inline_type()) {\n@@ -383,0 +385,1 @@\n+  assert(klass->field_signature(index)->is_Q_signature(), \"Sanity check\");\n@@ -959,1 +962,1 @@\n-    info.is_inline_type()\n+    info.signature()->is_Q_signature() && info.is_inline_type()\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -130,2 +130,2 @@\n-arrayOop oopFactory::new_flatArray(Klass* klass, int length, TRAPS) {\n-  assert(klass->is_inline_klass(), \"Klass must be inline type\");\n+arrayOop oopFactory::new_flatArray(Klass* k, int length, TRAPS) {\n+  InlineKlass* klass = InlineKlass::cast(k);\n@@ -133,1 +133,1 @@\n-  Klass* array_klass = klass->array_klass(1, CHECK_NULL);\n+  Klass* array_klass = klass->null_free_inline_array_klass(CHECK_NULL);\n@@ -145,1 +145,1 @@\n-  assert(oop == NULL || oop->is_nullfreeArray(), \"sanity\");\n+  assert(oop == NULL || oop->is_null_free_array(), \"sanity\");\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {\n+Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS) {\n@@ -106,1 +106,0 @@\n-  bool is_qtype = element_klass->is_inline_klass();\n@@ -113,1 +112,1 @@\n-    if (is_qtype) {\n+    if (qdesc) {\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  static Symbol* create_element_klass_array_name(Klass* element_klass, TRAPS);\n+  static Symbol* create_element_klass_array_name(Klass* element_klass, bool qdesc, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1025,1 +1025,3 @@\n-      result_oop = resolved->java_mirror();\n+      result_oop = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(resolved)->val_mirror()\n+                      : resolved->java_mirror();\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-                                       bool is_inline_type) {\n+                                       bool is_null_free_inline_type) {\n@@ -145,1 +145,1 @@\n-  assert(!is_inlined || is_inline_type, \"Sanity check\");\n+  assert(!is_inlined || is_null_free_inline_type, \"Sanity check\");\n@@ -150,1 +150,1 @@\n-                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),\n+                  ((is_null_free_inline_type ? 1 : 0) << is_null_free_inline_type_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-\/\/ I  flag true if field is an inline type (must never be null)\n+\/\/ I  flag true if field is a null free inline type (must never be null)\n@@ -189,1 +189,1 @@\n-    is_inline_type_shift       = 24,  \/\/ (I) is the type of the field an inline type (must never be null)\n+    is_null_free_inline_type_shift = 24,  \/\/ (I) is the field a null free inline type (must never be null)\n@@ -232,1 +232,1 @@\n-    bool            is_inline_type               \/\/ the field is an inline type (must never be null)\n+    bool            is_null_free_inline_type     \/\/ the field is an inline type (must never be null)\n@@ -365,1 +365,1 @@\n-  bool is_inline_type() const                    { return (_flags & (1 << is_inline_type_shift))       != 0; }\n+  bool is_null_free_inline_type() const          { return (_flags & (1 << is_null_free_inline_type_shift)) != 0; }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* element_klass, TRAPS) {\n+FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* eklass, TRAPS) {\n@@ -90,1 +90,3 @@\n-  assert(InlineKlass::cast(element_klass)->is_naturally_atomic() || (!InlineArrayAtomicAccess), \"Atomic by-default\");\n+\n+  InlineKlass* element_klass = InlineKlass::cast(eklass);\n+  assert(element_klass->is_naturally_atomic() || (!InlineArrayAtomicAccess), \"Atomic by-default\");\n@@ -103,1 +105,1 @@\n-    super_klass = element_super->array_klass_or_null();\n+    super_klass = element_klass->array_klass_or_null();\n@@ -120,1 +122,1 @@\n-        super_klass = element_super->array_klass(CHECK_NULL);\n+        super_klass = element_klass->array_klass(CHECK_NULL);\n@@ -126,1 +128,1 @@\n-        ek = element_klass->array_klass(CHECK_NULL);\n+        ek = element_klass->null_free_inline_array_klass(CHECK_NULL);\n@@ -132,1 +134,1 @@\n-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, true, CHECK_NULL);\n@@ -150,0 +152,5 @@\n+void FlatArrayKlass::metaspace_pointers_do(MetaspaceClosure* it) {\n+  ArrayKlass::metaspace_pointers_do(it);\n+  it->push(&_element_klass);\n+}\n+\n@@ -351,1 +358,1 @@\n-        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n+        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, true, CHECK_NULL);\n@@ -410,0 +417,1 @@\n+  assert(elem_supers->length() > 0, \"Must at least include the PrimitiveObject interface\");\n@@ -412,16 +420,10 @@\n-  if (num_secondaries == 2) {\n-    \/\/ Must share this for correct bootstrapping!\n-    set_secondary_supers(Universe::the_array_interfaces_array());\n-    return NULL;\n-  } else {\n-    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+3);\n-    secondaries->push(vmClasses::Cloneable_klass());\n-    secondaries->push(vmClasses::Serializable_klass());\n-    secondaries->push(vmClasses::IdentityObject_klass());\n-    for (int i = 0; i < num_elem_supers; i++) {\n-      Klass* elem_super = (Klass*) elem_supers->at(i);\n-      Klass* array_super = elem_super->array_klass_or_null();\n-      assert(array_super != NULL, \"must already have been created\");\n-      secondaries->push(array_super);\n-    }\n-    return secondaries;\n+  GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+4);\n+\n+  secondaries->push(vmClasses::Cloneable_klass());\n+  secondaries->push(vmClasses::Serializable_klass());\n+  secondaries->push(vmClasses::IdentityObject_klass());\n+  for (int i = 0; i < num_elem_supers; i++) {\n+    Klass* elem_super = (Klass*) elem_supers->at(i);\n+    Klass* array_super = elem_super->array_klass_or_null();\n+    assert(array_super != NULL, \"must already have been created\");\n+    secondaries->push(array_super);\n@@ -429,0 +431,9 @@\n+  return secondaries;\n+}\n+\n+jint FlatArrayKlass::compute_modifier_flags() const {\n+  \/\/ The modifier for an flatArray is the same as its element\n+  jint element_flags = element_klass()->compute_modifier_flags();\n+\n+  return (element_flags & (JVM_ACC_PUBLIC | JVM_ACC_PRIVATE | JVM_ACC_PROTECTED))\n+                        | (JVM_ACC_ABSTRACT | JVM_ACC_FINAL);\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+  virtual void metaspace_pointers_do(MetaspaceClosure* iter);\n+\n@@ -143,0 +145,2 @@\n+  jint compute_modifier_flags() const;\n+\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  *((address*)adr_null_free_inline_array_klasses()) = NULL;\n@@ -167,18 +168,2 @@\n-void InlineKlass::remove_unshareable_info() {\n-  InstanceKlass::remove_unshareable_info();\n-\n-  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n-  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n-  *((address*)adr_pack_handler()) = NULL;\n-  *((address*)adr_pack_handler_jobject()) = NULL;\n-  *((address*)adr_unpack_handler()) = NULL;\n-  assert(pack_handler() == NULL, \"pack handler not null\");\n-}\n-\n-void InlineKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS) {\n-  InstanceKlass::restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK);\n-}\n-\n-Klass* InlineKlass::array_klass(int n, TRAPS) {\n-  \/\/ Need load-acquire for lock-free read\n-  if (array_klasses_acquire() == NULL) {\n+Klass* InlineKlass::null_free_inline_array_klass(int n, TRAPS) {\n+  if (Atomic::load_acquire(adr_null_free_inline_array_klasses()) == NULL) {\n@@ -192,1 +177,1 @@\n-      if (array_klasses() == NULL) {\n+      if (null_free_inline_array_klasses() == NULL) {\n@@ -197,1 +182,2 @@\n-          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, true, CHECK_NULL);\n+\n@@ -200,1 +186,1 @@\n-        release_set_array_klasses(k);\n+        Atomic::release_store(adr_null_free_inline_array_klasses(), k);\n@@ -204,2 +190,1 @@\n-  \/\/ array_klasses() will always be set at this point\n-  ArrayKlass* ak = array_klasses();\n+  ArrayKlass* ak = null_free_inline_array_klasses();\n@@ -209,1 +194,1 @@\n-Klass* InlineKlass::array_klass_or_null(int n) {\n+Klass* InlineKlass::null_free_inline_array_klass_or_null(int n) {\n@@ -211,1 +196,1 @@\n-  ArrayKlass* ak = array_klasses_acquire();\n+  ArrayKlass* ak = Atomic::load_acquire(adr_null_free_inline_array_klasses());\n@@ -219,2 +204,2 @@\n-Klass* InlineKlass::array_klass(TRAPS) {\n-  return array_klass(1, THREAD);\n+Klass* InlineKlass::null_free_inline_array_klass(TRAPS) {\n+  return null_free_inline_array_klass(1, THREAD);\n@@ -223,2 +208,2 @@\n-Klass* InlineKlass::array_klass_or_null() {\n-  return array_klass_or_null(1);\n+Klass* InlineKlass::null_free_inline_array_klass_or_null() {\n+  return null_free_inline_array_klass_or_null(1);\n@@ -227,0 +212,13 @@\n+void InlineKlass::array_klasses_do(void f(Klass* k)) {\n+  InstanceKlass::array_klasses_do(f);\n+  if (null_free_inline_array_klasses() != NULL) {\n+    null_free_inline_array_klasses()->array_klasses_do(f);\n+  }\n+}\n+\n+void InlineKlass::array_klasses_do(void f(Klass* k, TRAPS), TRAPS) {\n+  InstanceKlass::array_klasses_do(f, THREAD);\n+  if (null_free_inline_array_klasses() != NULL) {\n+    null_free_inline_array_klasses()->array_klasses_do(f, THREAD);\n+  }\n+}\n@@ -523,0 +521,40 @@\n+\/\/ CDS support\n+\n+void InlineKlass::metaspace_pointers_do(MetaspaceClosure* it) {\n+  InstanceKlass::metaspace_pointers_do(it);\n+\n+  InlineKlass* this_ptr = this;\n+  it->push_internal_pointer(&this_ptr, (intptr_t*)&_adr_inlineklass_fixed_block);\n+  it->push((Klass**)adr_null_free_inline_array_klasses());\n+}\n+\n+void InlineKlass::remove_unshareable_info() {\n+  InstanceKlass::remove_unshareable_info();\n+\n+  *((Array<SigEntry>**)adr_extended_sig()) = NULL;\n+  *((Array<VMRegPair>**)adr_return_regs()) = NULL;\n+  *((address*)adr_pack_handler()) = NULL;\n+  *((address*)adr_pack_handler_jobject()) = NULL;\n+  *((address*)adr_unpack_handler()) = NULL;\n+  assert(pack_handler() == NULL, \"pack handler not null\");\n+  if (null_free_inline_array_klasses() != NULL) {\n+    null_free_inline_array_klasses()->remove_unshareable_info();\n+  }\n+}\n+\n+void InlineKlass::remove_java_mirror() {\n+  InstanceKlass::remove_java_mirror();\n+  if (null_free_inline_array_klasses() != NULL) {\n+    null_free_inline_array_klasses()->remove_java_mirror();\n+  }\n+}\n+\n+void InlineKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS) {\n+  InstanceKlass::restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK);\n+  if (null_free_inline_array_klasses() != NULL) {\n+    null_free_inline_array_klasses()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n+  }\n+}\n+\n+\/\/ oop verify\n+\n@@ -532,7 +570,0 @@\n-\n-void InlineKlass::metaspace_pointers_do(MetaspaceClosure* it) {\n-  InstanceKlass::metaspace_pointers_do(it);\n-\n-  InlineKlass* this_ptr = this;\n-  it->push_internal_pointer(&this_ptr, (intptr_t*)&_adr_inlineklass_fixed_block);\n-}\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":67,"deletions":36,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -78,0 +78,9 @@\n+  ArrayKlass* volatile* adr_null_free_inline_array_klasses() const {\n+    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n+    return (ArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _null_free_inline_array_klasses));\n+  }\n+\n+  ArrayKlass* null_free_inline_array_klasses() const {\n+    return *adr_null_free_inline_array_klasses();\n+  }\n+\n@@ -123,0 +132,1 @@\n+  virtual void remove_java_mirror();\n@@ -132,3 +142,2 @@\n-  \/\/ Returns the array class for the n'th dimension\n-  virtual Klass* array_klass(int n, TRAPS);\n-  virtual Klass* array_klass_or_null(int n);\n+  \/\/ Type testing\n+  bool is_inline_klass_slow() const        { return true; }\n@@ -136,3 +145,3 @@\n-  \/\/ Returns the array class with this class as element type\n-  virtual Klass* array_klass(TRAPS);\n-  virtual Klass* array_klass_or_null();\n+  \/\/ ref and val mirror\n+  oop ref_mirror() const { return java_mirror(); }\n+  oop val_mirror() const { return java_lang_Class::secondary_mirror(java_mirror()); }\n@@ -140,0 +149,7 @@\n+  \/\/ naming\n+  const char* ref_signature_name() const {\n+    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+  }\n+  const char* val_signature_name() const {\n+    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_INLINE_TYPE);\n+  }\n@@ -141,2 +157,3 @@\n-  \/\/ Type testing\n-  bool is_inline_klass_slow() const        { return true; }\n+  \/\/ Iterators\n+  virtual void array_klasses_do(void f(Klass* k));\n+  virtual void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);\n@@ -171,0 +188,13 @@\n+  \/\/ null free inline arrays...\n+  \/\/\n+\n+  \/\/ null free inline array klass, akin to InstanceKlass::array_klass()\n+  \/\/ Returns the array class for the n'th dimension\n+  Klass* null_free_inline_array_klass(int n, TRAPS);\n+  Klass* null_free_inline_array_klass_or_null(int n);\n+\n+  \/\/ Returns the array class with this class as element type\n+  Klass* null_free_inline_array_klass(TRAPS);\n+  Klass* null_free_inline_array_klass_or_null();\n+\n+\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-bool InstanceKlass::field_is_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_INLINE_TYPE; }\n+bool InstanceKlass::field_is_null_free_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_INLINE_TYPE; }\n@@ -1545,1 +1545,2 @@\n-        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this,\n+                                                                  false, false, CHECK_NULL);\n@@ -2871,0 +2872,4 @@\n+  return signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+}\n+\n+const char* InstanceKlass::signature_name_of_carrier(char c) const {\n@@ -2882,1 +2887,1 @@\n-  dest[dest_index++] = is_inline_klass() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;\n+  dest[dest_index++] = c;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  ArrayKlass** _null_free_inline_array_klasses;\n@@ -558,1 +559,1 @@\n-  bool    field_is_inline_type(int index) const;\n+  bool    field_is_null_free_inline_type(int index) const;\n@@ -1249,0 +1250,1 @@\n+  const char* signature_name_of_carrier(char c) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -594,2 +594,0 @@\n-  \/\/ For value classes, this returns the name with a leading 'Q' and a trailing ';'\n-  \/\/     and the package separators as '\/'.\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-\/\/  unused:1 | <-- hash:31 -->| unused:22 larval:1 age:4 flat_array:1 nullfree_array:1 inline_type:1 lock:2\n+\/\/  unused:1 | <-- hash:31 -->| unused:22 larval:1 age:4 flat_array:1 null_free_array:1 inline_type:1 lock:2\n@@ -142,1 +142,1 @@\n-\/\/  The \"fast\" static type bits (flat_array, nullfree_array, and inline_type)\n+\/\/  The \"fast\" static type bits (flat_array, null_free_array, and inline_type)\n@@ -202,1 +202,1 @@\n-  static const int nullfree_array_bits            = LP64_ONLY(1) NOT_LP64(0);\n+  static const int null_free_array_bits           = LP64_ONLY(1) NOT_LP64(0);\n@@ -207,1 +207,1 @@\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - inline_type_bits - larval_bits - flat_array_bits - nullfree_array_bits;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - inline_type_bits - larval_bits - flat_array_bits - null_free_array_bits;\n@@ -217,2 +217,2 @@\n-  static const int nullfree_array_shift           = inline_type_shift + inline_type_bits;\n-  static const int flat_array_shift               = nullfree_array_shift + nullfree_array_bits;\n+  static const int null_free_array_shift          = inline_type_shift + inline_type_bits;\n+  static const int flat_array_shift               = null_free_array_shift + null_free_array_bits;\n@@ -233,3 +233,3 @@\n-  static const uintptr_t nullfree_array_mask      = right_n_bits(nullfree_array_bits);\n-  static const uintptr_t nullfree_array_mask_in_place = (nullfree_array_mask << nullfree_array_shift) | lock_mask_in_place;\n-  static const uintptr_t nullfree_array_bit_in_place = (1 << nullfree_array_shift);\n+  static const uintptr_t null_free_array_mask     = right_n_bits(null_free_array_bits);\n+  static const uintptr_t null_free_array_mask_in_place = (null_free_array_mask << null_free_array_shift) | lock_mask_in_place;\n+  static const uintptr_t null_free_array_bit_in_place  = (1 << null_free_array_shift);\n@@ -237,1 +237,1 @@\n-  static const uintptr_t flat_array_mask_in_place = (flat_array_mask << flat_array_shift) | nullfree_array_mask_in_place | lock_mask_in_place;\n+  static const uintptr_t flat_array_mask_in_place = (flat_array_mask << flat_array_shift) | null_free_array_mask_in_place | lock_mask_in_place;\n@@ -263,3 +263,3 @@\n-  static const uintptr_t nullfree_array_pattern   = nullfree_array_bit_in_place | unlocked_value;\n-  static const uintptr_t flat_array_pattern       = flat_array_bit_in_place | nullfree_array_pattern;\n-  static const uintptr_t static_prototype_mask    = LP64_ONLY(right_n_bits(inline_type_bits + flat_array_bits + nullfree_array_bits)) NOT_LP64(right_n_bits(inline_type_bits));\n+  static const uintptr_t null_free_array_pattern  = null_free_array_bit_in_place | unlocked_value;\n+  static const uintptr_t flat_array_pattern       = flat_array_bit_in_place | null_free_array_pattern;\n+  static const uintptr_t static_prototype_mask    = LP64_ONLY(right_n_bits(inline_type_bits + flat_array_bits + null_free_array_bits)) NOT_LP64(right_n_bits(inline_type_bits));\n@@ -472,2 +472,2 @@\n-  bool is_nullfree_array() const {\n-    return (mask_bits(value(), nullfree_array_mask_in_place) == nullfree_array_pattern);\n+  bool is_null_free_array() const {\n+    return (mask_bits(value(), null_free_array_mask_in_place) == null_free_array_pattern);\n@@ -490,2 +490,2 @@\n-  static markWord nullfree_array_prototype() {\n-    return markWord(nullfree_array_pattern);\n+  static markWord null_free_array_prototype() {\n+    return markWord(null_free_array_pattern);\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-         prototype_header.is_nullfree_array(), \"corrupt prototype header\");\n+         prototype_header.is_null_free_array(), \"corrupt prototype header\");\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,3 @@\n-ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {\n+ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n,\n+                                       Klass* k, Symbol* name, bool null_free,\n+                                       TRAPS) {\n@@ -55,1 +57,1 @@\n-  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);\n+  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name, null_free);\n@@ -59,1 +61,3 @@\n-                                                      int n, Klass* element_klass, TRAPS) {\n+                                                      int n, Klass* element_klass,\n+                                                      bool null_free, bool qdesc, TRAPS) {\n+  assert(!null_free || (n == 1 && element_klass->is_inline_klass() && qdesc), \"null-free unsupported\");\n@@ -67,1 +71,5 @@\n-      super_klass = element_super->array_klass_or_null();\n+      if (null_free) {\n+        super_klass = element_klass->array_klass_or_null();\n+      } else {\n+        super_klass = element_super->array_klass_or_null();\n+      }\n@@ -79,0 +87,5 @@\n+      if (null_free) {\n+        if (element_klass->array_klass_or_null() == NULL) {\n+          supers_exist = false;\n+        }\n+      }\n@@ -84,1 +97,5 @@\n-          super_klass = element_super->array_klass(CHECK_NULL);\n+          if (null_free) {\n+            element_klass->array_klass(CHECK_NULL);\n+          } else {\n+            element_super->array_klass(CHECK_NULL);\n+          }\n@@ -90,1 +107,5 @@\n-          ek = element_klass->array_klass(n, CHECK_NULL);\n+          if (null_free) {\n+            ek = InlineKlass::cast(element_klass)->null_free_inline_array_klass(CHECK_NULL);\n+          } else {\n+            ek = element_klass->array_klass(n, CHECK_NULL);\n+          }\n@@ -101,1 +122,1 @@\n-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, qdesc, CHECK_NULL);\n@@ -104,1 +125,1 @@\n-  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, null_free, CHECK_NULL);\n@@ -122,1 +143,1 @@\n-ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {\n+ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free) : ArrayKlass(name, ID) {\n@@ -126,0 +147,2 @@\n+  assert(!null_free || name->is_Q_array_signature(), \"sanity check\");\n+\n@@ -138,2 +161,3 @@\n-  jint lh = array_layout_helper(T_OBJECT);\n-  if (element_klass->is_inline_klass()) {\n+  int lh = array_layout_helper(T_OBJECT);\n+  if (null_free) {\n+    assert(n == 1, \"Bytecode does not support null-free multi-dim\");\n@@ -141,2 +165,2 @@\n-    set_prototype_header(markWord::nullfree_array_prototype());\n-    assert(prototype_header().is_nullfree_array(), \"sanity\");\n+    set_prototype_header(markWord::null_free_array_prototype());\n+    assert(prototype_header().is_null_free_array(), \"sanity\");\n@@ -179,1 +203,1 @@\n-    if (element_klass()->is_inline_klass()) {\n+    if (name()->char_at(1) != JVM_SIGNATURE_ARRAY &&  name()->is_Q_array_signature()) {\n@@ -341,1 +365,2 @@\n-        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n+        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n+                                                          false, this->name()->is_Q_array_signature(), CHECK_NULL);\n@@ -521,1 +546,1 @@\n-  guarantee(obj->is_nullfreeArray() || (!is_null_free_array_klass()), \"null-free klass but not object\");\n+  guarantee(obj->is_null_free_array() || (!is_null_free_array_klass()), \"null-free klass but not object\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-  ObjArrayKlass(int n, Klass* element_klass, Symbol* name);\n-  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);\n+  ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free);\n+  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, bool null_free, TRAPS);\n@@ -70,1 +70,2 @@\n-                                                int n, Klass* element_klass, TRAPS);\n+                                                int n, Klass* element_klass,\n+                                                bool null_free, bool qdesc, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -140,1 +140,0 @@\n-bool oopDesc::is_value_noinline()             const { return is_inline_type();         }\n@@ -142,1 +141,1 @@\n-bool oopDesc::is_nullfreeArray_noinline()     const { return is_nullfreeArray();       }\n+bool oopDesc::is_null_free_array_noinline()   const { return is_null_free_array();     }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  inline bool is_nullfreeArray()       const;\n+  inline bool is_null_free_array()     const;\n@@ -125,1 +125,0 @@\n-  bool is_value_noinline()             const;\n@@ -127,1 +126,1 @@\n-  bool is_nullfreeArray_noinline()     const;\n+  bool is_null_free_array_noinline()   const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-bool oopDesc::is_nullfreeArray() const {\n+bool oopDesc::is_null_free_array() const {\n@@ -217,1 +217,1 @@\n-  return (mrk.is_unlocked()) ? mrk.is_nullfree_array() : klass()->is_null_free_array_klass();\n+  return (mrk.is_unlocked()) ? mrk.is_null_free_array() : klass()->is_null_free_array_klass();\n@@ -220,2 +220,2 @@\n-bool oopDesc::is_flatArray()     const { return klass()->is_flatArray_klass(); }\n-bool oopDesc::is_nullfreeArray() const { return klass()->is_null_free_array_klass(); }\n+bool oopDesc::is_flatArray()       const { return klass()->is_flatArray_klass(); }\n+bool oopDesc::is_null_free_array() const { return klass()->is_null_free_array_klass(); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-              class_loader_data(), dim + 1, this, CHECK_NULL);\n+              class_loader_data(), dim + 1, this, false, false, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1172,1 +1172,1 @@\n-static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit) {\n+static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit, bool null_free) {\n@@ -1177,1 +1177,1 @@\n-  if (t->as_klass()->is_inlinetype()) {\n+  if (t->as_klass()->is_inlinetype() && null_free) {\n@@ -1285,1 +1285,1 @@\n-          cast_argument(nargs, 0, signature->accessing_klass(), kit);\n+          cast_argument(nargs, 0, signature->accessing_klass(), kit, false);\n@@ -1291,1 +1291,2 @@\n-            cast_argument(nargs, receiver_skip + j, t, kit);\n+            bool null_free = signature->is_null_free_at(i);\n+            cast_argument(nargs, receiver_skip + j, t, kit, null_free);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4594,0 +4594,7 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Perform a full test.\n+  if (superk->is_obj_array_klass() && !superk->as_array_klass()->is_elem_null_free() &&\n+      superk->as_array_klass()->element_klass()->is_inlinetype()) {\n+    return SSC_full_test;\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -702,1 +702,1 @@\n-            if (ct == T_INLINE_TYPE) {\n+            if (declared_signature->returns_null_free_inline_type()) {\n@@ -731,1 +731,2 @@\n-    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType()) {\n+    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType() &&\n+        !gvn().type(peek())->maybe_null() && rtype->as_inline_klass()->is_scalarizable()) {\n@@ -733,4 +734,1 @@\n-      assert(!gvn().type(retnode)->maybe_null(), \"should never be null\");\n-      if (rtype->as_inline_klass()->is_scalarizable()) {\n-        retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass());\n-      }\n+      retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3442,1 +3442,1 @@\n-Node* GraphKit::gen_checkcast(Node *obj, Node* superklass, Node* *failure_control) {\n+Node* GraphKit::gen_checkcast(Node *obj, Node* superklass, Node* *failure_control, bool null_free) {\n@@ -3446,2 +3446,0 @@\n-\n-  \/\/ Check if inline types are involved\n@@ -3449,1 +3447,1 @@\n-  bool to_inline = tk->klass()->is_inlinetype();\n+  assert(!null_free || toop->is_inlinetypeptr(), \"must be an inline type pointer\");\n@@ -3475,1 +3473,1 @@\n-          if (to_inline) {\n+          if (null_free) {\n@@ -3477,3 +3475,3 @@\n-            if (toop->inline_klass()->is_scalarizable()) {\n-              obj = InlineTypeNode::make_from_oop(this, obj, toop->inline_klass());\n-            }\n+          }\n+          if (toop->is_inlinetypeptr() && toop->inline_klass()->is_scalarizable() && !gvn().type(obj)->maybe_null()) {\n+            obj = InlineTypeNode::make_from_oop(this, obj, toop->inline_klass());\n@@ -3484,1 +3482,1 @@\n-        if (from_inline || to_inline) {\n+        if (from_inline || null_free) {\n@@ -3488,1 +3486,1 @@\n-          \/\/ Inline type is never null. Always throw an exception.\n+          \/\/ Inline type is null-free. Always throw an exception.\n@@ -3537,1 +3535,1 @@\n-  } else if (to_inline) {\n+  } else if (null_free) {\n@@ -3669,2 +3667,1 @@\n-    if (to_inline && toop->inline_klass()->is_scalarizable()) {\n-      assert(!gvn().type(res)->maybe_null(), \"Inline types are null-free\");\n+    if (toop->is_inlinetypeptr() && toop->inline_klass()->is_scalarizable() && !gvn().type(res)->maybe_null()) {\n@@ -3733,2 +3730,1 @@\n-  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n-  if (val_t == TypePtr::NULL_PTR && !ary_t->is_not_null_free()) {\n+  if (val_t == TypePtr::NULL_PTR) {\n@@ -3736,0 +3732,1 @@\n+    const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n@@ -3928,1 +3925,2 @@\n-    if (UseFlatArray && klass->is_obj_array_klass()) {\n+    if (UseFlatArray && klass->is_obj_array_klass() && !klass->as_obj_array_klass()->is_elem_null_free()) {\n+      \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue.\n@@ -3932,1 +3930,1 @@\n-    if (xklass || (klass->is_array_klass() && !can_be_flattened)) {\n+    if (!can_be_flattened && (xklass || klass->is_array_klass())) {\n@@ -4316,3 +4314,3 @@\n-  \/\/ - null-ok:              MyValue.ref[] (ciObjArrayKlass \"[LMyValue$ref\")\n-  \/\/ - null-free:            MyValue.val[] (ciObjArrayKlass \"[QMyValue$val\")\n-  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue$val\")\n+  \/\/ - null-ok:              MyValue.ref[] (ciObjArrayKlass \"[LMyValue\")\n+  \/\/ - null-free:            MyValue.val[] (ciObjArrayKlass \"[QMyValue\")\n+  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n@@ -4325,3 +4323,2 @@\n-    ciKlass* elem_klass = ary_ptr->klass()->as_array_klass()->element_klass();\n-    if (elem_klass != NULL && elem_klass->is_inlinetype()) {\n-      ciInlineKlass* vk = elem_klass->as_inline_klass();\n+    if (ary_ptr->klass()->as_array_klass()->is_elem_null_free()) {\n+      ciInlineKlass* vk = ary_ptr->klass()->as_array_klass()->element_klass()->as_inline_klass();\n@@ -4701,1 +4698,1 @@\n-    } else if (con_type->is_zero_type() && field->type()->is_inlinetype()) {\n+    } else if (con_type->is_zero_type() && field->is_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = NULL);\n+  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = NULL, bool null_free = false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,0 +195,7 @@\n+bool InlineTypeBaseNode::field_is_null_free(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  ciField* field = inline_klass()->declared_nonstatic_field_at(index);\n+  assert(!field->is_flattened() || field->type()->is_inlinetype(), \"must be an inline type\");\n+  return field->is_null_free();\n+}\n+\n@@ -276,0 +283,1 @@\n+    bool is_null_free = field_is_null_free(i);\n@@ -296,2 +304,1 @@\n-        if (con_type->is_inlinetypeptr()) {\n-          assert(!con_type->is_zero_type(), \"Inline types are null-free\");\n+        if (con_type->is_inlinetypeptr() && !con_type->is_zero_type()) {\n@@ -299,0 +306,1 @@\n+          is_null_free = true;\n@@ -312,1 +320,1 @@\n-      if (ft->is_inlinetype()) {\n+      if (is_null_free) {\n@@ -542,1 +550,1 @@\n-    if (field_type->is_inlinetype()) {\n+    if (vt->field_is_null_free(i)) {\n@@ -798,1 +806,1 @@\n-      if (type->is_inlinetype()) {\n+      if (field_is_null_free(i)) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  bool          field_is_null_free(uint index) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2400,1 +2400,6 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          if (t->is_inlinetype()) {\n+            \/\/ TODO fix with JDK-8267932\n+            return LoadNode::Value(phase);\n+          } else {\n+            return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          }\n@@ -2452,1 +2457,3 @@\n-          if (!ik->is_interface() && !ik->has_subklass()) {\n+          \/\/ Do not fold klass loads from [LMyValue. The runtime type might be [QMyValue due to [QMyValue <: [LMyValue\n+          \/\/ and the klass for [QMyValue is not equal to the klass for [LMyValue.\n+          if (!ik->is_interface() && !ik->has_subklass() && (!ik->is_inlinetype() || ak->is_elem_null_free())) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    if (tp->klass()->is_inlinetype()) {\n+    if (tp->is_inlinetypeptr() && !tp->maybe_null()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-        ciArrayKlass* array_klass = ciArrayKlass::make(vk);\n+        ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n@@ -347,1 +347,1 @@\n-          ciArrayKlass* array_klass = ciArrayKlass::make(vk);\n+          ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  if (bt == T_INLINE_TYPE && field_klass->as_inline_klass()->is_empty()) {\n+  if (field->is_null_free() && field_klass->as_inline_klass()->is_empty()) {\n@@ -170,1 +170,1 @@\n-        if (bt == T_INLINE_TYPE && field->is_static()) {\n+        if (field->is_null_free() && field->is_static()) {\n@@ -187,1 +187,1 @@\n-    if (bt == T_INLINE_TYPE) {\n+    if (field->is_null_free()) {\n@@ -234,2 +234,2 @@\n-  assert(bt != T_INLINE_TYPE || val->is_InlineType() || !gvn().type(val)->maybe_null(), \"Null store to inline type field\");\n-  if (bt == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+  assert(!field->is_null_free() || val->is_InlineType() || !gvn().type(val)->maybe_null(), \"Null store to inline type field\");\n+  if (field->is_null_free() && field->type()->as_inline_klass()->is_empty()) {\n@@ -299,0 +299,1 @@\n+  bool null_free = iter().has_Q_signature();\n@@ -305,1 +306,1 @@\n-  ciArrayKlass* array_klass = ciArrayKlass::make(klass);\n+  ciArrayKlass* array_klass = ciArrayKlass::make(klass, null_free);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  bool null_free = iter().has_Q_signature();\n@@ -79,1 +80,1 @@\n-    assert(!iter().is_inline_klass(), \"Inline type should be loaded\");\n+    assert(!null_free, \"Inline type should be loaded\");\n@@ -96,1 +97,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)), NULL, null_free);\n@@ -260,2 +261,1 @@\n-  \/\/ Handle inline type arrays\n-  if (elemtype->isa_inlinetype() != NULL || (elemtype->is_inlinetypeptr() && !elemtype->maybe_null())) {\n+  if (elemtype->isa_inlinetype() != NULL || elemtype->is_inlinetypeptr()) {\n@@ -349,1 +349,1 @@\n-  if (!val->is_InlineType() && field->type()->is_inlinetype()) {\n+  if (!val->is_InlineType() && field->is_null_free()) {\n@@ -353,1 +353,1 @@\n-  } else if (val->is_InlineType() && !field->type()->is_inlinetype()) {\n+  } else if (val->is_InlineType() && !field->is_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -984,2 +984,2 @@\n-        } else if ((r0->is_not_null_free() && klass1->is_obj_array_klass() && klass1->as_obj_array_klass()->element_klass()->is_inlinetype()) ||\n-                   (r1->is_not_null_free() && klass0->is_obj_array_klass() && klass0->as_obj_array_klass()->element_klass()->is_inlinetype())) {\n+        } else if ((r0->is_not_null_free() && klass1->is_array_klass() && klass1->as_array_klass()->is_elem_null_free()) ||\n+                   (r1->is_not_null_free() && klass0->is_array_klass() && klass0->as_array_klass()->is_elem_null_free())) {\n@@ -1147,0 +1147,8 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Do not bypass the klass load from the primary supertype array.\n+  if (superklass->is_obj_array_klass() && !superklass->as_array_klass()->is_elem_null_free() &&\n+      superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                 superk->is_obj_array_klass() && superk->as_obj_array_klass()->element_klass()->is_inlinetype()) {\n+                 superk->is_array_klass() && superk->as_array_klass()->is_elem_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,2 +271,3 @@\n-    ciInlineKlass* vk = type->as_inline_klass();\n-    if (vk->is_scalarizable()) {\n+    bool is_null_free = type->is_null_free();\n+    ciInlineKlass* vk = type->unwrap()->as_inline_klass();\n+    if (vk->is_scalarizable() && is_null_free) {\n@@ -275,1 +276,1 @@\n-      return TypeOopPtr::make_from_klass(vk)->join_speculative(TypePtr::NOTNULL);\n+      return TypeOopPtr::make_from_klass(vk)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2089,1 +2090,1 @@\n-      field_array[TypeFunc::Parms] = get_const_type(return_type)->join_speculative(TypePtr::NOTNULL);\n+      field_array[TypeFunc::Parms] = get_const_type(return_type)->join_speculative(sig->returns_null_free_inline_type() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2149,1 +2150,2 @@\n-      if (vt_fields_as_args && type->as_inline_klass()->can_be_passed_as_fields()) {\n+      bool is_null_free = sig->is_null_free_at(i);\n+      if (vt_fields_as_args && type->as_inline_klass()->can_be_passed_as_fields() && is_null_free) {\n@@ -2152,1 +2154,1 @@\n-        field_array[pos++] = get_const_type(type)->join_speculative(TypePtr::NOTNULL);\n+        field_array[pos++] = get_const_type(type)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2450,2 +2452,10 @@\n-  if (tinst)\n-    return tklass->as_instance_klass()->is_final();\n+  if (tinst) {\n+    if (tklass->as_instance_klass()->is_final()) {\n+      \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+      if (tinst->is_inlinetypeptr() && (tinst->ptr() == TypePtr::BotPTR || tinst->ptr() == TypePtr::TopPTR)) {\n+        return false;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n@@ -3567,1 +3577,2 @@\n-    if (etype->is_inlinetypeptr()) {\n+    bool null_free = klass->as_array_klass()->is_elem_null_free();\n+    if (null_free) {\n@@ -3579,1 +3590,2 @@\n-    bool xk = etype->klass_is_exact();\n+    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+    bool xk = etype->klass_is_exact() && (!etype->is_inlinetypeptr() || null_free);\n@@ -3625,1 +3637,1 @@\n-    if (etype->is_inlinetypeptr()) {\n+    if (klass->as_array_klass()->is_elem_null_free()) {\n@@ -5513,1 +5525,2 @@\n-    k_ary = ciArrayKlass::make(el->is_oopptr()->klass());\n+    bool null_free = el->is_inlinetypeptr() && el->isa_instptr()->ptr() != TypePtr::TopPTR && !el->isa_instptr()->maybe_null();\n+    k_ary = ciArrayKlass::make(el->is_oopptr()->klass(), null_free);\n@@ -5517,1 +5530,1 @@\n-      k_ary = ciArrayKlass::make(el->inline_klass());\n+      k_ary = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n@@ -5876,1 +5889,2 @@\n-  bool has_scalar_ret = sig->return_type()->is_inlinetype() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n+  bool has_scalar_ret = sig->returns_null_free_inline_type() && sig->return_type()->is_inlinetype() &&\n+                        sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1354,1 +1354,1 @@\n-  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr()); }\n+  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr() && !_ary->_elem->make_ptr()->maybe_null()); }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jni.h\"\n@@ -501,2 +502,12 @@\n-  jboolean ret = sub_klass->is_subtype_of(super_klass) ?\n-                   JNI_TRUE : JNI_FALSE;\n+  jboolean ret;\n+  if (sub_klass == super_klass && sub_klass->is_inline_klass()) {\n+    \/\/ val type is a subtype of ref type\n+    InlineKlass* ik = InlineKlass::cast(sub_klass);\n+    if (sub_mirror == super_mirror || (ik->val_mirror() == sub_mirror && ik->ref_mirror() == super_mirror)) {\n+      ret = JNI_TRUE;\n+    } else {\n+      ret = JNI_FALSE;\n+    }\n+  } else {\n+    ret = sub_klass->is_subtype_of(super_klass) ? JNI_TRUE : JNI_FALSE;\n+  }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1176,1 +1176,1 @@\n-    assert(klass->is_objArray_klass() || klass->is_typeArray_klass(), \"Illegal mirror klass\");\n+    assert(klass->is_objArray_klass() || klass->is_typeArray_klass() || klass->is_flatArray_klass(), \"Illegal mirror klass\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1338,1 +1338,1 @@\n-        if (field._type == T_INLINE_TYPE) {\n+        if (fs.signature()->is_Q_signature()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-    if (k->is_inline_klass()) {\n+    if (k->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n@@ -397,1 +397,5 @@\n-  klass = klass->array_klass(dim, CHECK_NULL);\n+  if (klass->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+    klass = InlineKlass::cast(klass)->null_free_inline_array_klass(dim, CHECK_NULL);\n+  } else {\n+    klass = klass->array_klass(dim, CHECK_NULL);\n+  }\n@@ -1152,1 +1156,1 @@\n-    rtype = T_INLINE_TYPE;\n+    rtype = java_lang_Class::is_primary_mirror(return_type_mirror) ? T_OBJECT : T_INLINE_TYPE;\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -439,1 +439,2 @@\n-  return klass->java_mirror();\n+  return has_Q_descriptor() ? InlineKlass::cast(klass)->val_mirror()\n+                            : klass->java_mirror();\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -526,0 +526,4 @@\n+  bool has_Q_descriptor() const {\n+    return has_envelope() && (_signature->char_at(_begin) == JVM_SIGNATURE_INLINE_TYPE);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  switch (_tag) {\n+  switch (value()) {\n","filename":"src\/hotspot\/share\/utilities\/constantTag.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-               + getName();\n+               + getName() + (isPrimitiveClass() && isPrimaryType() ? \".ref\" : \"\");\n@@ -556,0 +556,5 @@\n+    \/\/ set by VM if this class is an exotic type such as primitive class\n+    \/\/ otherwise, these two fields are null\n+    private transient Class<T> primaryType;\n+    private transient Class<T> secondaryType;\n+\n@@ -558,0 +563,8 @@\n+     * <p>\n+     * Each primitive class has a {@linkplain #isPrimaryType() primary type}\n+     * representing the <em>primitive reference type<\/em> and a\n+     * {@linkplain #isValueType() secondary type} representing\n+     * the <em>primitive value type<\/em>.  The primitive reference type\n+     * and primitive value type can be obtained by calling the\n+     * {@link #asPrimaryType()} and {@link #asValueType} method\n+     * of a primitive class respectively.\n@@ -567,24 +580,2 @@\n-     * Returns an {@code Optional<Class>} object representing the <em>primitive value type<\/em>\n-     * of this class if this {@code Class} represents the <em>reference type<\/em>\n-     * of a {@linkplain #isPrimitiveClass() primitive class}.\n-     * If this {@code Class} represents the value type of a primitive class,\n-     * then this method returns this class.\n-     * Otherwise an empty {@link Optional} is returned.\n-     *\n-     * @return the {@code Optional<Class>} representing the primitive value type of\n-     *         this class if this class is either the value type\n-     *         or the reference type of a primitive class;\n-     *         an empty {@link Optional} otherwise\n-     * @since Valhalla\n-     *\/\n-    public Optional<Class<?>> valueType() {\n-        if (isPrimitive() || isInterface() || isArray())\n-            return Optional.empty();\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length > 0 ? Optional.of(valRefTypes[0]) : Optional.empty();\n-    }\n-\n-    \/**\n-     * Returns a {@code Class} object representing the reference type\n-     * of this class.\n+     * Returns a {@code Class} object representing the primary type\n+     * of this class or interface.\n@@ -592,3 +583,2 @@\n-     * If this {@code Class} represents a {@linkplain #isPrimitiveClass()\n-     * primitive reference type}, then this method\n-     * returns the <em>primitive reference type<\/em> type of this primitive class.\n+     * If this {@code Class} object represents a reference type, then\n+     * this method returns this class.\n@@ -596,2 +586,3 @@\n-     * If this {@code Class} represents the reference type\n-     * of a primitive class, then this method returns this class.\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive class}, then this method returns the <em>primitive reference type<\/em>\n+     * type of this primitive class.\n@@ -599,3 +590,1 @@\n-     * If this class is an identity class, then this method returns this class.\n-     * <p>\n-     * Otherwise this method returns an empty {@code Optional}.\n+     * If this is a primitive type, then this method returns this class.\n@@ -603,2 +592,2 @@\n-     * @return the {@code Optional<Class>} object representing the reference type for\n-     *         this class, if present; an empty {@link Optional} otherwise.\n+     * @return the {@code Class} representing the primary type of\n+     *         this class or interface\n@@ -607,7 +596,2 @@\n-    public Optional<Class<?>> referenceType() {\n-        if (isPrimitive()) return Optional.empty();\n-        if (isInterface() || isArray()) return Optional.of(this);\n-        if (!isPrimitiveClass()) return Optional.of(this);\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length == 2 ? Optional.of(valRefTypes[1]) : Optional.empty();\n+    public Class<?> asPrimaryType() {\n+        return isPrimitiveClass() ? primaryType : this;\n@@ -616,3 +600,3 @@\n-    \/*\n-     * Returns true if this Class object represents a primitive reference\n-     * type for a primitive class.\n+    \/**\n+     * Returns a {@code Class} object representing the <em>primitive value type<\/em>\n+     * of this class if this class is a {@linkplain #isPrimitiveClass() primitive class}.\n@@ -620,3 +604,5 @@\n-     * A primitive reference type must be a sealed abstract class that\n-     * permits the primitive value type to extend.  The primitive value type\n-     * and primitive reference type for a primitive type must be of the same package.\n+     * @return the {@code Class} representing the primitive value type of\n+     *         this class if this class is a primitive class\n+     * @throws UnsupportedOperationException if this class or interface\n+     *         is not a primitive class\n+     * @since Valhalla\n@@ -624,17 +610,3 @@\n-    private boolean isPrimitiveReferenceType() {\n-        if (isPrimitive() || isArray() || isInterface() || isPrimitiveClass())\n-            return false;\n-\n-        int mods = getModifiers();\n-        if (!Modifier.isAbstract(mods)) {\n-            return false;\n-        }\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length == 2 && valRefTypes[1] == this;\n-    }\n-\n-    private transient Class<?>[] primitiveTypes;\n-    private Class<?>[] getPrimitiveTypes() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n+    public Class<?> asValueType() {\n+        if (isPrimitiveClass())\n+            return secondaryType;\n@@ -642,15 +614,1 @@\n-        Class<?>[] valRefTypes = primitiveTypes;\n-        if (valRefTypes == null) {\n-            \/\/ So newPrimitiveTypeArray is called without holding any lock to\n-            \/\/ avoid potential deadlock when multiple threads attempt to\n-            \/\/ initialize the primitive types for C and E where D is\n-            \/\/ the superclass of both C and E (which is an error case)\n-            valRefTypes = newTypeArrayForPrimitiveClass();\n-        }\n-        synchronized (this) {\n-            \/\/ set the value and reference types if not set\n-            if (primitiveTypes == null) {\n-                primitiveTypes = valRefTypes;\n-            }\n-        }\n-        return primitiveTypes;\n+        throw new UnsupportedOperationException(this.getName() + \" is not a primitive class\");\n@@ -659,4 +617,12 @@\n-    \/*\n-     * Returns an array of Class objects whose element at index 0 represents the\n-     * primitive value type and element at index 1 represents the\n-     * primitive reference type, if present.\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents the primary type\n+     * of this class or interface.\n+     * <p>\n+     * If this is a primitive type, then this method returns {@code true}.\n+     * <p>\n+     * If this {@code Class} object represents a reference type, then\n+     * this method returns {@code true}.\n+     * <p>\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive} reference type, then this method returns {@code true};\n+     * otherwise, this method returns {@code false}.\n@@ -664,3 +630,3 @@\n-     * If this Class object is neither a primitive value type nor\n-     * a primitive reference type for a primitive class, then an empty array\n-     * is returned.\n+     * @return {@code true} if this {@code Class} object represents\n+     * the primary type of this class or interface\n+     * @since Valhalla\n@@ -668,4 +634,1 @@\n-    private Class<?>[] newTypeArrayForPrimitiveClass() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n-\n+    public boolean isPrimaryType() {\n@@ -673,13 +636,1 @@\n-            Class<?> superClass = getSuperclass();\n-            if (superClass != Object.class && superClass.isPrimitiveReferenceType()) {\n-                return new Class<?>[] { this, superClass };\n-            } else {\n-                return new Class<?>[] { this };\n-            }\n-        } else {\n-            Class<?> valType = primitiveValueType();\n-            if (valType != null) {\n-                return new Class<?>[] { valType, this};\n-            } else {\n-                return EMPTY_CLASS_ARRAY;\n-            }\n+            return this == primaryType;\n@@ -687,0 +638,1 @@\n+        return true;\n@@ -689,4 +641,7 @@\n-    \/*\n-     * Returns the primitive value type if this Class represents\n-     * a primitive reference type.  If this class is a primitive class\n-     * then this method returns this class.  Otherwise, returns null.\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents\n+     * a {@linkplain #isPrimitiveClass() primitive} value type.\n+     *\n+     * @return {@code true} if this {@code Class} object represents the\n+     * value type of a primitive class\n+     * @since Valhalla\n@@ -694,23 +649,2 @@\n-    private Class<?> primitiveValueType() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n-\n-        if (isPrimitiveClass())\n-            return this;\n-\n-        int mods = getModifiers();\n-        if (!Modifier.isAbstract(mods)) {\n-            return null;\n-        }\n-\n-        \/\/ A primitive reference type must be a sealed abstract class\n-        \/\/ that permits the primitive class type to extend.\n-        \/\/ The primitive class project type and primitive reference type for\n-        \/\/ a primitive class type must be of the same package.\n-        Class<?>[] subclasses = getPermittedSubclasses0();\n-        if ((subclasses.length == 1) &&\n-                (subclasses[0].isPrimitiveClass()) &&\n-                (getPackageName().equals(subclasses[0].getPackageName()))) {\n-            return subclasses[0];\n-        }\n-        return null;\n+    public boolean isValueType() {\n+        return isPrimitiveClass() && this == secondaryType;\n@@ -863,0 +797,4 @@\n+     * object represents the {@linkplain #isPrimaryType() reference type}\n+     * of a {@linkplain #isPrimitiveClass() primitive class}, this method\n+     * return {@code true} if the specified {@code Class} parameter represents\n+     * the same primitive class. If this {@code Class}\n@@ -871,3 +809,3 @@\n-     * or via a widening reference conversion. See <cite>The Java Language\n-     * Specification<\/cite>, sections {@jls 5.1.1} and {@jls 5.1.4},\n-     * for details.\n+     * or via a widening reference conversion or via a primitive widening\n+     * conversion. See <cite>The Java Language Specification<\/cite>,\n+     * sections {@jls 5.1.1} and {@jls 5.1.4}, for details.\n@@ -1028,1 +966,1 @@\n-     *     returns \"[[LPoint$ref;\"\n+     *     returns \"[[LPoint;\"\n@@ -1862,1 +1800,6 @@\n-        return getName();\n+        if (isPrimitiveClass()) {\n+            \/\/ TODO: null-default\n+            return isPrimaryType() ? getName() + \".ref\" : getName();\n+        } else {\n+            return getName();\n+        }\n@@ -4056,2 +3999,2 @@\n-     * @throws NullPointerException if this is an {@linkplain #isPrimitiveClass()\n-     * primitive class} and the object is {@code null}\n+     * @throws NullPointerException if this is an {@linkplain #isValueType()\n+     * primitive value type} and the object is {@code null}\n@@ -4064,2 +4007,2 @@\n-        if (isPrimitiveClass() && obj == null)\n-            throw new NullPointerException(getName() + \" is a primitive class\");\n+        if (isValueType() && obj == null)\n+            throw new NullPointerException(getName() + \" is a primitive value type\");\n@@ -4578,1 +4521,1 @@\n-        char typeDesc = isPrimitiveClass() ? 'Q' : 'L';\n+        char typeDesc = isValueType() ? 'Q' : 'L';\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":84,"deletions":141,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -269,5 +269,1 @@\n-        if (getClass().isPrimitiveClass()) {\n-            return SharedSecrets.getJavaLangInvokeAccess().inlineObjectToString(this);\n-        } else {\n-            return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n-        }\n+        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -388,6 +388,2 @@\n-     * If {@code fromType} is a primitive class, this method returns {@code true}\n-     * if {@code toType} is the {@linkplain Class#referenceType() primitive reference type}\n-     * of {@code fromType}.\n-     * If {@code toType} is a primitive class, this method returns {@code true}\n-     * if {@code toType} is the {@linkplain Class#valueType() primitive value type}\n-     * of {@code fromType}.\n+     * If {@code fromType} and {@code toType} is of the same primitive class,\n+     * this method returns {@code true}.\n@@ -406,2 +402,3 @@\n-        if (!fromType.isPrimitiveClass() && !toType.isPrimitiveClass()) {\n-            return false;\n+        if (fromType.isPrimitiveClass() && toType.isPrimitiveClass()) {\n+            \/\/ val projection can be converted to ref projection; or vice verse\n+            return fromType.asPrimaryType() == toType.asPrimaryType();\n@@ -410,1 +407,1 @@\n-        return fromType.valueType().equals(toType.valueType());\n+        return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-            mtype = mtype.insertParameterTypes(0, refc);\n+            Class<?> receiverType = refc.isPrimitiveClass() ? refc.asValueType() : refc;\n+            mtype = mtype.insertParameterTypes(0, receiverType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,1 +119,2 @@\n-                       methodType.returnType() != defc) {\n+                       methodType.returnType() != defc.asValueType()) {\n+                \/\/ TODO: allow to return Object or perhaps one of the supertypes of that class\n@@ -121,1 +122,1 @@\n-                throw new IllegalArgumentException(\"static constructor must be of \" + getDeclaringClass().getName());\n+                throw new IllegalArgumentException(\"static constructor must be of \" + defc.getName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+        Class<?> c = clazz.isPrimitiveClass() ? clazz.asValueType() : clazz;\n@@ -195,1 +196,1 @@\n-            return itype.changeReturnType(clazz);\n+            return itype.changeReturnType(c);\n@@ -197,1 +198,1 @@\n-            return itype.insertParameterTypes(0, clazz);\n+            return itype.insertParameterTypes(0, c);\n@@ -482,1 +483,1 @@\n-            return type.isPrimitiveClass();\n+            return type.isValueType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1506,4 +1506,0 @@\n-            @Override\n-            public String inlineObjectToString(Object o) {\n-                return ValueBootstrapMethods.inlineObjectToString(o);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1619,0 +1619,1 @@\n+            assert lookupClass.isPrimaryType();\n@@ -3443,0 +3444,1 @@\n+            Class<?> defc = c.getDeclaringClass();\n@@ -3445,1 +3447,1 @@\n-                return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n+                return lookup.getDirectConstructorNoSecurityManager(defc, ctor);\n@@ -3448,1 +3450,1 @@\n-                assert(ctor.isMethod() && ctor.getReturnType() == ctor.getDeclaringClass() && ctor.getReferenceKind() == REF_invokeStatic);\n+                assert(ctor.isMethod() && ctor.getReturnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n@@ -3450,1 +3452,1 @@\n-                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);\n+                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), defc, ctor, lookup);\n@@ -3824,1 +3826,1 @@\n-            if (!fullPrivilegeLookup && defc != refc) {\n+            if (!fullPrivilegeLookup && defc.asPrimaryType() != refc.asPrimaryType()) {\n@@ -3907,1 +3909,1 @@\n-                               (defc == refc ||\n+                               (defc.asPrimaryType() == refc.asPrimaryType() ||\n@@ -3912,1 +3914,1 @@\n-                           (defc == refc ||\n+                           (defc.asPrimaryType() == refc.asPrimaryType() ||\n@@ -3989,1 +3991,0 @@\n-\n@@ -4312,1 +4313,3 @@\n-     * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be\n+     * is {@code null} or if the array's element type is a {@link Class#isValueType()\n+     * a primitive value type} and attempts to set {@code null} in the\n+     * array element.  An {@code ArrayIndexOutOfBoundsException} will be\n@@ -4323,3 +4326,0 @@\n-        if (arrayClass.isPrimitiveClass()) {\n-            throw new UnsupportedOperationException();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -892,1 +893,1 @@\n-                \")\" + rtype.getSimpleName());\n+                \")\" + toSimpleName(rtype));\n@@ -894,1 +895,1 @@\n-            sj.add(ptypes[i].getSimpleName());\n+            sj.add(toSimpleName(ptypes[i]));\n@@ -899,0 +900,7 @@\n+    static String toSimpleName(Class<?> c) {\n+        if (c.isPrimitiveClass() && c.isPrimaryType()) {\n+            return c.getSimpleName() + \".ref\";\n+        } else {\n+            return c.getSimpleName();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+        Class<?> valType = lookup.lookupClass().asValueType();\n@@ -94,1 +95,1 @@\n-                return inlineTypeHashCode(lookup.lookupClass());\n+                return inlineTypeHashCode(valType);\n@@ -96,3 +97,1 @@\n-                return substitutableInvoker(lookup.lookupClass()).asType(methodType);\n-            case \"toString\":\n-                return inlineTypeToString(lookup.lookupClass());\n+                return substitutableInvoker(valType).asType(methodType);\n@@ -110,2 +109,2 @@\n-            Lookup lookup = new MethodHandles.Lookup(type);\n-            \/\/ filter static fields and synthetic fields\n+            Lookup lookup = new MethodHandles.Lookup(type.asPrimaryType());\n+            \/\/ filter static fields\n@@ -113,1 +112,1 @@\n-                .filter(f -> !Modifier.isStatic(f.getModifiers()) && !f.isSynthetic())\n+                .filter(f -> !Modifier.isStatic(f.getModifiers()))\n@@ -156,0 +155,4 @@\n+        static Class<?> fieldType(MethodHandle getter) {\n+            Class<?> ftype = getter.type().returnType();\n+            return ftype;\n+        }\n@@ -162,1 +165,1 @@\n-            assert type.isPrimitiveClass();\n+            assert type.isValueType();\n@@ -169,1 +172,1 @@\n-                Class<?> ftype = getter.type().returnType();\n+                Class<?> ftype = fieldType(getter);\n@@ -184,1 +187,1 @@\n-            assert type.isPrimitiveClass();\n+            assert type.isValueType();\n@@ -196,0 +199,2 @@\n+                Class<?> ftype = fieldType(getter);\n+\n@@ -200,1 +205,1 @@\n-                MethodHandle hasher = hashCodeForType(getter.type().returnType());\n+                MethodHandle hasher = hashCodeForType(ftype);\n@@ -212,34 +217,0 @@\n-        static MethodHandle inlineTypeToString(Class<?> type) {\n-            assert type.isPrimitiveClass();\n-            MethodHandle[] getters = MethodHandleBuilder.getters(type);\n-            int length = getters.length;\n-            StringBuilder format = new StringBuilder();\n-            Class<?>[] parameterTypes = new Class<?>[length];\n-            \/\/ append the value class name\n-            format.append(\"[\").append(type.getName());\n-            String separator = \" \";\n-            Lookup lookup = new MethodHandles.Lookup(type);\n-            for (int i = 0; i < length; i++) {\n-                MethodHandle getter = getters[i];\n-                MethodHandleInfo fieldInfo = lookup.revealDirect(getter);\n-                Class<?> ftype = fieldInfo.getMethodType().returnType();\n-                format.append(separator)\n-                      .append(fieldInfo.getName())\n-                      .append(\"=\\1\");\n-                getters[i]= filterReturnValue(getter, MethodHandleBuilder.toString(ftype));\n-                parameterTypes[i] = String.class;\n-            }\n-            format.append(\"]\");\n-            try {\n-                MethodHandle target = StringConcatFactory.makeConcatWithConstants(lookup, \"toString\",\n-                        methodType(String.class, parameterTypes), format.toString()).dynamicInvoker();\n-                \/\/ apply getters\n-                target = filterArguments(target, 0, getters);\n-                \/\/ duplicate \"this\" argument from o::toString for each getter invocation\n-                target = permuteArguments(target, methodType(String.class, type), new int[length]);\n-                return target;\n-            } catch (StringConcatException e) {\n-                throw newLinkageError(e);\n-            }\n-\n-        }\n@@ -268,1 +239,1 @@\n-                Class<?> type = a.getClass();\n+                Class<?> type = a.getClass().asValueType();\n@@ -297,18 +268,0 @@\n-        private static String toString(Object o) {\n-            return o != null ? o.toString() : \"null\";\n-        }\n-\n-        private static MethodHandle toString(Class<?> type) {\n-            if (type.isArray()) {\n-                Class<?> componentType = type.getComponentType();\n-                if (componentType.isPrimitive()) {\n-                    int index = Wrapper.forPrimitiveType(componentType).ordinal();\n-                    return ARRAYS_TO_STRING[index];\n-                } else {\n-                    return ARRAYS_TO_STRING[Wrapper.OBJECT.ordinal()].asType(methodType(String.class, type));\n-                }\n-            } else {\n-                return TO_STRING.asType(methodType(String.class, type));\n-            }\n-        }\n-\n@@ -331,1 +284,0 @@\n-        private static final MethodHandle[] ARRAYS_TO_STRING = initArraysToString();\n@@ -338,2 +290,0 @@\n-        static final MethodHandle TO_STRING =\n-            findStatic(\"toString\", methodType(String.class, Object.class));\n@@ -359,11 +309,0 @@\n-        private static MethodHandle[] initArraysToString() {\n-            MethodHandle[] mhs = new MethodHandle[Wrapper.COUNT];\n-            for (Wrapper wrapper : Wrapper.values()) {\n-                if (wrapper == Wrapper.VOID) continue;\n-\n-                Class<?> arrayType = wrapper.arrayType();\n-                mhs[wrapper.ordinal()] = findStatic(Arrays.class, \"toString\", methodType(String.class, arrayType));\n-            }\n-            return mhs;\n-        }\n-\n@@ -498,0 +437,3 @@\n+            if (type.isPrimitiveClass()) {\n+                type = type.asValueType();\n+            }\n@@ -541,1 +483,1 @@\n-        if (type.isPrimitiveClass())\n+        if (type.isValueType())\n@@ -550,1 +492,1 @@\n-            return MethodHandleBuilder.inlineTypeEquals(type);\n+            return MethodHandleBuilder.inlineTypeEquals(type.asValueType());\n@@ -561,1 +503,0 @@\n-            Class<?> type = o.getClass();\n@@ -564,2 +505,3 @@\n-            if (!type.isPrimitiveClass())\n-                throw new InternalError(\"must be primitive type: \" + type.getName());\n+            if (!o.getClass().isPrimitiveClass())\n+                throw new InternalError(\"must be primitive type: \" + o.getClass().getName());\n+            Class<?> type = o.getClass().asValueType();\n@@ -577,28 +519,1 @@\n-            return MethodHandleBuilder.inlineTypeHashCode(type);\n-        }\n-    };\n-\n-    \/**\n-     * Invoke the bootstrap methods hashCode for the given primitive class object.\n-     * @param o the instance to hash.\n-     * @return the string representation of the given primitive class object.\n-     *\/\n-    static String inlineObjectToString(Object o) {\n-        try {\n-            Class<?> type = o.getClass();\n-            \/\/ Note: javac disallows user to call super.hashCode if user implementated\n-            \/\/ risk for recursion for experts crafting byte-code\n-            if (!type.isPrimitiveClass())\n-                throw new InternalError(\"must be primitive type: \" + type.getName());\n-            return (String) TOSTRING_METHOD_HANDLES.get(type).invoke(o);\n-        } catch (Error|RuntimeException e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            if (VERBOSE) e.printStackTrace();\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private static ClassValue<MethodHandle> TOSTRING_METHOD_HANDLES = new ClassValue<>() {\n-        @Override protected MethodHandle computeValue(Class<?> type) {\n-            return MethodHandleBuilder.inlineTypeToString(type);\n+            return MethodHandleBuilder.inlineTypeHashCode(type.asValueType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ValueBootstrapMethods.java","additions":26,"deletions":111,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -1656,0 +1656,6 @@\n+            \/\/ the field type (value) is mapped to the return type of MethodType\n+            \/\/ the receiver type is mapped to a parameter type of MethodType\n+            \/\/ So use the value type if it's a primitive class\n+            if (receiver != null && receiver.isPrimitiveClass()) {\n+                receiver = receiver.asValueType();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-            return maybeAdapt(componentType.isPrimitiveClass() && UNSAFE.isFlattenedArray(arrayClass)\n+            return maybeAdapt(componentType.isValueType() && UNSAFE.isFlattenedArray(arrayClass)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-            if (handle.fieldType.isPrimitiveClass())\n+            if (handle.fieldType.isValueType())\n@@ -504,1 +504,1 @@\n-            if (handle.fieldType.isPrimitiveClass())\n+            if (handle.fieldType.isValueType())\n@@ -747,1 +747,1 @@\n-        assert componentType.isPrimitiveClass() && UNSAFE.isFlattenedArray(arrayClass);\n+        assert componentType.isValueType() && UNSAFE.isFlattenedArray(arrayClass);\n@@ -806,1 +806,1 @@\n-            if (handle.componentType.isPrimitiveClass())\n+            if (handle.componentType.isValueType())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -362,1 +363,1 @@\n-        sb.append(getDeclaringClass().getTypeName());\n+        sb.append(getDeclaringClassTypeName());\n@@ -368,1 +369,1 @@\n-        sb.append(getDeclaringClass().getTypeName());\n+        sb.append(getDeclaringClassTypeName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -781,0 +781,8 @@\n+\n+    String getDeclaringClassTypeName() {\n+        Class<?> c = getDeclaringClass();\n+        if (c.isPrimitiveClass()) {\n+            c = c.asValueType();\n+        }\n+        return c.getTypeName();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -331,1 +332,1 @@\n-            + getDeclaringClass().getTypeName() + \".\"\n+            + getDeclaringClassTypeName() + \".\"\n@@ -337,1 +338,9 @@\n-        return \"field \" + getDeclaringClass().getTypeName() + \".\" + getName();\n+        return \"field \" + getDeclaringClassTypeName() + \".\" + getName();\n+    }\n+\n+    String getDeclaringClassTypeName() {\n+        Class<?> c = getDeclaringClass();\n+        if (c.isPrimitiveClass()) {\n+            c = c.asValueType();\n+        }\n+        return c.getTypeName();\n@@ -365,1 +374,1 @@\n-            + getDeclaringClass().getTypeName() + \".\"\n+            + getDeclaringClassTypeName() + \".\"\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -421,1 +422,1 @@\n-        sb.append(getDeclaringClass().getTypeName()).append('.');\n+        sb.append(getDeclaringClassTypeName()).append('.');\n@@ -427,1 +428,1 @@\n-        return \"method \" + getDeclaringClass().getTypeName() +\n+        return \"method \" + getDeclaringClassTypeName() +\n@@ -490,1 +491,1 @@\n-        sb.append(getDeclaringClass().getTypeName()).append('.');\n+        sb.append(getDeclaringClassTypeName()).append('.');\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -878,1 +878,1 @@\n-            if (type != c) {\n+            if (type.asPrimaryType() != c.asPrimaryType()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -869,1 +869,1 @@\n-                if (type.isPrimitiveClass()) {\n+                if (type.isValueType()) {\n@@ -924,1 +924,1 @@\n-         * to invoke Class.asPrimaryType if the class is regular value type.\n+         * to invoke Class::asValueType if the class is a primitive value type.\n@@ -934,0 +934,5 @@\n+            if (cl.isValueType()) {\n+              mv.visitMethodInsn(INVOKEVIRTUAL,\n+                                 JL_CLASS,\n+                                 \"asValueType\", \"()Ljava\/lang\/Class;\", false);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,2 +125,0 @@\n-    String inlineObjectToString(Object o);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-        if (ref == null && pc.isPrimitiveClass()) {\n+        if (ref == null && pc.isValueType()) {\n@@ -278,1 +278,1 @@\n-        if (ref == null && pc.isPrimitiveClass()) {\n+        if (ref == null && pc.isValueType()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        return !field.getType().isPrimitiveClass();\n+        return !field.getType().isPrimitiveClass() || field.getType().isPrimaryType();\n@@ -75,1 +75,5 @@\n-            if (!field.getType().isAssignableFrom(value.getClass())) {\n+            Class<?> type = value.getClass();\n+            if (type.isPrimitiveClass()) {\n+                type = type.asValueType();\n+            }\n+            if (!field.getType().isAssignableFrom(type)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeFieldAccessorImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-                return Class.forName(name, false, loader);\n+                Class<?> clz = Class.forName(name, false, loader);\n+                return c == 'Q' ? clz.asValueType() : clz.asPrimaryType();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        if (defc == lookupClass  &&\n+        if (defc.asPrimaryType() == lookupClass  &&\n@@ -143,1 +143,1 @@\n-            assert (canAccess && refc == defc) || !canAccess;\n+            assert (canAccess && refc.asPrimaryType() == defc.asPrimaryType()) || !canAccess;\n@@ -151,1 +151,1 @@\n-        return (refc == lookupClass ||\n+        return (refc.asPrimaryType() == lookupClass.asPrimaryType() ||\n@@ -276,1 +276,1 @@\n-        if (type == refc) {\n+        if (type.asPrimaryType() == refc.asPrimaryType()) {\n@@ -337,1 +337,1 @@\n-        return (type == res);\n+        return (type.asPrimaryType() == res);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -423,15 +423,0 @@\n-    \/**\n-     * Is this a *derived* reference projection symbol ??\n-     *\/\n-    public boolean isReferenceProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * If this is the symbol for a reference projection class, what is the class for which\n-     * this is a projection ??\n-     *\/\n-    public ClassSymbol valueProjection() {\n-        return null;\n-    }\n-\n@@ -548,2 +533,0 @@\n-     * 'outermost' being a lexical construct, should transcend\n-     *  projections\n@@ -558,1 +541,1 @@\n-        return (ClassSymbol) (prev!= null && prev.isReferenceProjection() ? prev.valueProjection() : prev);\n+        return (ClassSymbol) prev;\n@@ -1434,8 +1417,0 @@\n-        \/**\n-         * Does `this' symbolize a primitive class that would, under the translation\n-         * scheme in effect be lowered into two class files on a bifurcased basis ??\n-         *\/\n-        public boolean isSplitPrimitiveClass(Types types) {\n-            return types.splitPrimitiveClass && this.isPrimitiveClass();\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -105,12 +105,0 @@\n-    \/**\n-     * If true, the ClassWriter will split a primitive class declaration into two class files\n-     * P.ref.class and P.val.class (P.class for pure primitive classes)\n-     *\n-     * This is the default behavior, can be eoverridden with -XDunifiedValRefClass\n-     *\n-     * If false, we emit a single class for a primtive class 'P' and the reference projection and\n-     * value projection types are encoded in descriptors as LP; and QP; resperctively.\n-     *\/\n-\n-    public boolean splitPrimitiveClass;\n-\n@@ -142,1 +130,0 @@\n-        splitPrimitiveClass = options.isUnset(\"unifiedValRefClass\");\n@@ -1883,1 +1870,1 @@\n-                            return (dynamicTypeMayImplementAdditionalInterfaces(t.tsym))\n+                            return ((t.tsym.flags() & FINAL) == 0)\n@@ -4735,1 +4722,1 @@\n-        Assert.check(!dynamicTypeMayImplementAdditionalInterfaces(from.tsym));\n+        Assert.check((from.tsym.flags() & FINAL) != 0);\n@@ -4747,4 +4734,0 @@\n-    private boolean dynamicTypeMayImplementAdditionalInterfaces(TypeSymbol tsym) {\n-        return (tsym.flags() & FINAL) == 0 && !tsym.isReferenceProjection();\n-    }\n-\n@@ -5429,4 +5412,0 @@\n-            if (types.splitPrimitiveClass && ct.isReferenceProjection()) {\n-                append('$');\n-                append(types.names.ref);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2276,4 +2276,3 @@\n-            \/* Per our interim inline class translation scheme, the reference projection classes\n-               are completely empty, so we want the methods in the value class to be invoked instead.\n-               As the lambda meta factory isn't clued into this, it will try to invoke the method in\n-               C$ref.class and fail with a NoSuchMethodError. we need to workaround it ourselves.\n+            \/* Workaround to BootstrapMethodError. This workaround should not be required in the unified\n+               class generation model. Todo: Investigate to see if a defect should be reported against\n+               runtime lambda machinery\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1143,3 +1143,0 @@\n-                if (types.splitPrimitiveClass && requireReferenceProjection) {\n-                    flatname = flatname.append('$', names.ref);\n-                }\n@@ -3109,6 +3106,0 @@\n-        if (haveValue) {\n-            \/\/ widening coversion is a NOP for the VM due to subtyping relationship at class file level\n-            \/\/ where we bifurcate a primitive class into two class files.\n-            if (types.splitPrimitiveClass)\n-                return tree;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -74,2 +74,0 @@\n-import static com.sun.tools.javac.code.Type.ClassType.Flavor.L_TypeOf_Q;\n-import static com.sun.tools.javac.code.Type.ClassType.Flavor.Q_TypeOf_Q;\n@@ -560,12 +558,6 @@\n-                name = names.fromUtf(signatureBuffer,\n-                        startSbp,\n-                        sbp - startSbp);\n-                if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                    name = name.subName(0, name.length() - 4);\n-                    Assert.check(prefix == 'L');\n-                    flavor = L_TypeOf_Q;\n-                } else {\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                }\n-                ClassSymbol t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                                                         startSbp,\n+                                                         sbp - startSbp));\n+\n+                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -575,6 +567,2 @@\n-                        if (flavor == L_TypeOf_Q) {\n-                            return et.referenceProjection();\n-                        } else {\n-                            \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n-                            return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n-                        }\n+                        \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n@@ -589,12 +577,5 @@\n-                name = names.fromUtf(signatureBuffer,\n-                        startSbp,\n-                        sbp - startSbp);\n-                if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                    name = name.subName(0, name.length() - 4);\n-                    Assert.check(prefix == 'L');\n-                    flavor = L_TypeOf_Q;\n-                } else {\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                }\n-                ClassSymbol t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                                                         startSbp,\n+                                                         sbp - startSbp));\n+                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -661,12 +642,5 @@\n-                    name = names.fromUtf(signatureBuffer,\n-                            startSbp,\n-                            sbp - startSbp);\n-                    if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                        name = name.subName(0, name.length() - 4);\n-                        Assert.check(prefix == 'L');\n-                        flavor = L_TypeOf_Q;\n-                    } else {\n-                        \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                        flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                    }\n-                    t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                    t = enterClass(names.fromUtf(signatureBuffer,\n+                                                 startSbp,\n+                                                 sbp - startSbp));\n+                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -2536,19 +2510,0 @@\n-    \/**\n-     * Special routine to enter a class that we conclude must be a primitive class from naming convention\n-     * E.g, if we see LFoo$ref in descriptors, we discern that to be the reference projection of the primitive\n-     * class Foo\n-     *\/\n-    protected ClassSymbol enterPrimitiveClass(Name name) {\n-        ClassSymbol c = enterClass(name);\n-        noticePrimitiveClass(c);\n-        return c;\n-    }\n-\n-    private void noticePrimitiveClass(ClassSymbol c) {\n-        ClassType ct = (ClassType) c.type;\n-        ct.flavor = ct.flavor.metamorphose(true);\n-        if (c.erasure_field != null) {\n-            ((ClassType) c.erasure_field).flavor = ct.flavor;\n-        }\n-    }\n-\n@@ -2677,3 +2632,0 @@\n-                if ((flags & PRIMITIVE_CLASS) != 0) {\n-                    noticePrimitiveClass(member); \/\/ Do we care to do this ?\n-                }\n@@ -2734,26 +2686,0 @@\n-        readClassFileInternal(c);\n-        if (c.isPrimitiveClass()) {\n-            \/* http:\/\/cr.openjdk.java.net\/~briangoetz\/valhalla\/sov\/04-translation.html\n-               The relationship of value and reference projections differs between the language model\n-               and the VM model. In the language, the value projection is not a subtype of the\n-               reference projection; instead, the two are related by inline narrowing and widening\n-               conversions, whereas in the VM, the two are related by actual subtyping.\n-               Sever the subtyping relationship by rewiring the supertypes here and now.\n-             *\/\n-\n-            Name flatname = TypeSymbol.formFlatName(names.ref, c);\n-            ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);\n-            if (referenceProjection != null) {\n-                if (referenceProjection.name != names.ref && referenceProjection.owner.kind == PCK) {\n-                    referenceProjection.complete();\n-                    ClassType classType = (ClassType) c.type;\n-                    classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;\n-                    classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;\n-                    \/\/ Discard the projection, it will be recomputed on the fly.\n-                    referenceProjection.owner.members().remove(referenceProjection);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void readClassFileInternal(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":18,"deletions":92,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -826,2 +826,1 @@\n-    \/** Write \"inner classes\" attribute. If a primitive class happens to be an inner class,\n-     *  the reference projection class will also be an inner class.\n+    \/** Write \"inner classes\" attribute.\n@@ -831,2 +830,1 @@\n-        int icCountIdx = beginAttrs();\n-        int icCount = 0;\n+        databuf.appendChar(poolWriter.innerClasses.size());\n@@ -849,11 +847,0 @@\n-            icCount++;\n-            if (inner.isSplitPrimitiveClass(types)) {\n-                databuf.appendChar(poolWriter.putClass(inner.type.referenceProjection()));\n-                databuf.appendChar(\n-                        inner.owner.kind == TYP && !inner.name.isEmpty() ? poolWriter.putClass((ClassSymbol)inner.owner) : 0);\n-                databuf.appendChar(\n-                        !inner.name.isEmpty() ? poolWriter.putName(inner.name.append('$', names.ref)) : 0);\n-                flags = (char) ((flags & ~(ACC_PRIMITIVE | FINAL)) | ABSTRACT);\n-                databuf.appendChar(flags);\n-                icCount++;\n-            }\n@@ -861,1 +848,0 @@\n-        endAttrs(icCountIdx, icCount);\n@@ -886,26 +872,8 @@\n-        Set<ClassSymbol> nestedUnique = new LinkedHashSet<>();\n-        if (csym.owner.kind == PCK) {\n-            if (csym.isSplitPrimitiveClass(types)) {\n-                \/\/ reference projection is the host\n-            } else if (csym.isReferenceProjection()) {\n-                ClassSymbol valueProjection = csym.valueProjection();\n-                nestedUnique.add(valueProjection);\n-                listNested(valueProjection, nestedUnique);\n-            } else {\n-                listNested(csym, nestedUnique);\n-            }\n-            if (!nestedUnique.isEmpty()) {\n-                int alenIdx = writeAttr(names.NestMembers);\n-                int nmcIdx = beginAttrs();\n-                int nmc = 0;\n-                for (ClassSymbol s : nestedUnique) {\n-                    databuf.appendChar(poolWriter.putClass(s));\n-                    nmc++;\n-                    if (s.isSplitPrimitiveClass(types) && s.owner.kind != PCK) {\n-                        databuf.appendChar(poolWriter.putClass(s.type.referenceProjection()));\n-                        nmc++;\n-                    }\n-                }\n-                endAttrs(nmcIdx, nmc);\n-                endAttr(alenIdx);\n-                return 1;\n+        ListBuffer<ClassSymbol> nested = new ListBuffer<>();\n+        listNested(csym, nested);\n+        Set<ClassSymbol> nestedUnique = new LinkedHashSet<>(nested);\n+        if (csym.owner.kind == PCK && !nestedUnique.isEmpty()) {\n+            int alenIdx = writeAttr(names.NestMembers);\n+            databuf.appendChar(nestedUnique.size());\n+            for (ClassSymbol s : nestedUnique) {\n+                databuf.appendChar(poolWriter.putClass(s));\n@@ -913,0 +881,2 @@\n+            endAttr(alenIdx);\n+            return 1;\n@@ -921,1 +891,1 @@\n-        if (csym.owner.kind != PCK || csym.isSplitPrimitiveClass(types)) {\n+        if (csym.owner.kind != PCK) {\n@@ -923,6 +893,1 @@\n-            ClassSymbol outerMost = csym.outermostClass();\n-            if (outerMost.isSplitPrimitiveClass(types)) {\n-                databuf.appendChar(poolWriter.putClass(outerMost.type.referenceProjection()));\n-            } else {\n-                databuf.appendChar(poolWriter.putClass(outerMost));\n-            }\n+            databuf.appendChar(poolWriter.putClass(csym.outermostClass()));\n@@ -935,1 +900,1 @@\n-    private void listNested(Symbol sym, Set<ClassSymbol> seen) {\n+    private void listNested(Symbol sym, ListBuffer<ClassSymbol> seen) {\n@@ -1535,3 +1500,0 @@\n-        if (c.isSplitPrimitiveClass(types)) {\n-            writeClassInternal(getReferenceProjection(c));\n-        }\n@@ -1541,55 +1503,0 @@\n-        \/\/ where\n-        private static ClassSymbol getReferenceProjection(ClassSymbol c) {\n-\n-            ClassSymbol projection;\n-            ClassType projectedType;\n-\n-            ClassType ct = (ClassType) c.type;\n-            \/* Note, the class type associated with the Primitive$ref.class is NOT a reference projection type. A reference projection\n-             * type gets created by using Primitive.ref notation in the source file or while reading in a descriptor of such a type\n-             * from the class file. Here we are generating the Primitive$ref.class for the VM's benefit and it is a reference class.\n-             *\/\n-            projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null, ct.getMetadata(), Flavor.L_TypeOf_L);\n-            projectedType.allparams_field = ct.allparams_field;\n-            projectedType.supertype_field = ct.supertype_field;\n-\n-            projectedType.interfaces_field = ct.interfaces_field;\n-            projectedType.all_interfaces_field = ct.all_interfaces_field;\n-            projectedType.projection = null;\n-\n-            Name projectionName = c.name.append('$', c.name.table.names.ref);\n-            long projectionFlags = (c.flags() & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | (ABSTRACT | SEALED);\n-\n-            projection = new ClassSymbol(projectionFlags, projectionName, projectedType, c.owner) {\n-                @Override\n-                public boolean isReferenceProjection() {\n-                    return true;\n-                }\n-\n-                @Override\n-                public ClassSymbol valueProjection() {\n-                    return c;\n-                }\n-            };\n-            projection.members_field = WriteableScope.create(projection);\n-            for (Symbol s : c.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    clone = refVar;\n-                }\n-                projection.members_field.enter(clone);\n-            }\n-            projection.completer = Completer.NULL_COMPLETER;\n-            projection.sourcefile = c.sourcefile;\n-            projection.flatname = c.flatname.append('$', c.name.table.names.ref);\n-            projection.permitted = List.of(c);\n-            projectedType.tsym = projection;\n-            return projection;\n-        }\n-\n@@ -1640,2 +1547,2 @@\n-        Type supertype = c.isSplitPrimitiveClass(types) ? c.type.referenceProjection() : types.supertype(c.type);\n-        List<Type> interfaces = c.isSplitPrimitiveClass(types) ? List.nil() : types.interfaces(c.type);\n+        Type supertype = types.supertype(c.type);\n+        List<Type> interfaces = types.interfaces(c.type);\n@@ -1674,16 +1581,14 @@\n-        boolean referenceProjection = c.isReferenceProjection();\n-        if (!referenceProjection) {\n-            for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {\n-                switch (sym.kind) {\n-                    case VAR:\n-                        fieldsCount++;\n-                        break;\n-                    case MTH:\n-                        if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n-                        break;\n-                    case TYP:\n-                        poolWriter.enterInner((ClassSymbol)sym);\n-                        break;\n-                    default:\n-                        Assert.error();\n-                }\n+\n+        for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {\n+            switch (sym.kind) {\n+                case VAR:\n+                    fieldsCount++;\n+                    break;\n+                case MTH:\n+                    if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n+                    break;\n+                case TYP:\n+                    poolWriter.enterInner((ClassSymbol)sym);\n+                    break;\n+                default:\n+                    Assert.error();\n@@ -1691,0 +1596,1 @@\n+        }\n@@ -1692,4 +1598,3 @@\n-            if (c.trans_local != null) {\n-                for (ClassSymbol local : c.trans_local) {\n-                    poolWriter.enterInner(local);\n-                }\n+        if (c.trans_local != null) {\n+            for (ClassSymbol local : c.trans_local) {\n+                poolWriter.enterInner(local);\n@@ -1700,2 +1605,1 @@\n-        if (!referenceProjection)\n-            writeFields(c.members());\n+        writeFields(c.members());\n@@ -1703,2 +1607,1 @@\n-        if (!referenceProjection)\n-            writeMethods(c.members());\n+        writeMethods(c.members());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":37,"deletions":134,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -2282,1 +2282,1 @@\n-        \/\/ inline widening conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n+        \/\/ inline widening conversion should not require a checkcast but we issue one per VM's request as of now (see || true below)\n@@ -2285,1 +2285,1 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.splitPrimitiveClass || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type)) &&\n+            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n@@ -2355,1 +2355,1 @@\n-            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, !types.splitPrimitiveClass && tree.selected.type.isPrimitiveClass()));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -233,3 +233,0 @@\n-        if (c.isReferenceProjection()) {\n-            c = c.valueProjection();\n-        }\n@@ -381,3 +378,0 @@\n-                    if (types.splitPrimitiveClass && ct.isReferenceProjection()) {\n-                        name = name.append('$', names.ref);\n-                    }\n@@ -517,5 +511,4 @@\n-        signatureGen.assembleSig(t.isPrimitiveClass() && types.splitPrimitiveClass ? t.referenceProjection() : types.supertype(t));\n-        if (!t.isPrimitiveClass() || !types.splitPrimitiveClass) {\n-            for (Type i : types.interfaces(t))\n-                signatureGen.assembleSig(i);\n-        }\n+        signatureGen.assembleSig(types.supertype(t));\n+        for (Type i : types.interfaces(t))\n+            signatureGen.assembleSig(i);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -325,2 +325,1 @@\n-        \/* Rewrite any accesses of the form V.ref.member to ((V) V.ref).member OR\n-           if a static member is being selected via a V.ref as a TYP, rewrite\n+        \/* If a static member is being selected via a V.ref as a TYP, rewrite\n@@ -340,5 +339,0 @@\n-                        } else {\n-                            if (types.splitPrimitiveClass) {\n-                                fieldAccess.selected =\n-                                        make.TypeCast(types.erasure(selectedType.valueProjection()), fieldAccess.selected);\n-                            } \/\/ else members of Foo can be accessed via LFoo or QFoo at the VM level without a cast.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  EXPECT_FALSE(mark.is_nullfree_array());\n+  EXPECT_FALSE(mark.is_null_free_array());\n@@ -186,1 +186,1 @@\n-  EXPECT_FALSE(mark.is_nullfree_array());\n+  EXPECT_FALSE(mark.is_null_free_array());\n@@ -219,1 +219,1 @@\n-  EXPECT_TRUE(mark.is_nullfree_array());\n+  EXPECT_TRUE(mark.is_null_free_array());\n@@ -237,1 +237,1 @@\n-static void assert_nullfree_array_type(markWord mark) {\n+static void assert_null_free_array_type(markWord mark) {\n@@ -241,1 +241,1 @@\n-  EXPECT_TRUE(mark.is_nullfree_array());\n+  EXPECT_TRUE(mark.is_null_free_array());\n@@ -244,2 +244,2 @@\n-TEST_VM(markWord, nullfree_array_prototype) {\n-  markWord mark = markWord::nullfree_array_prototype();\n+TEST_VM(markWord, null_free_array_prototype) {\n+  markWord mark = markWord::null_free_array_prototype();\n@@ -249,1 +249,1 @@\n-  assert_nullfree_array_type(mark);\n+  assert_null_free_array_type(mark);\n@@ -256,1 +256,1 @@\n-  assert_nullfree_array_type(mark);\n+  assert_null_free_array_type(mark);\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-        Asserts.assertEQ(n.toString(), \"[MyValue6 foo=124]\");\n+        Asserts.assertEQ(n.toString(), \"MyValue6@\" + Integer.toHexString(n.hashCode()));\n@@ -406,1 +406,1 @@\n-        Asserts.assertEQ(n.toString(), \"[MyValue6Box foo=124]\");\n+        Asserts.assertEQ(n.toString(), \"MyValue6Box@\" + Integer.toHexString(n.hashCode()));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeArray.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        Asserts.assertEquals(emptyField.empty.getClass(), EmptyInline.class);\n+        Asserts.assertEquals(emptyField.empty.getClass(), EmptyInline.ref.class);\n@@ -79,1 +79,1 @@\n-        Asserts.assertEquals(w.empty.getClass(), EmptyInline.class);\n+        Asserts.assertEquals(w.empty.getClass(), EmptyInline.ref.class);\n@@ -82,1 +82,1 @@\n-        Asserts.assertEquals(w.empty.getClass(), EmptyInline.class);\n+        Asserts.assertEquals(w.empty.getClass(), EmptyInline.ref.class);\n@@ -88,1 +88,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n@@ -97,1 +97,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n@@ -103,1 +103,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n@@ -109,1 +109,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n@@ -133,1 +133,1 @@\n-            Asserts.assertEquals(e.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(e.getClass(), EmptyInline.ref.class);\n@@ -137,1 +137,1 @@\n-            Asserts.assertEquals(e.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(e.getClass(), EmptyInline.ref.class);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/EmptyInlineTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        String arrayClsName = \"[Lruntime.valhalla.inlinetypes.Point$ref;\";\n+        String arrayClsName = \"[Lruntime.valhalla.inlinetypes.Point;\";\n@@ -289,1 +289,1 @@\n-        assertTrue(myInts instanceof MyInt.ref[]);\n+        assertTrue(myInts instanceof MyInt[]);\n@@ -292,1 +292,1 @@\n-        assertTrue(cls.isPrimitiveClass());\n+        assertTrue(cls.isValueType());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-        final String fieldLSignature = \"L\" + inlineClass.getName().replace('.', '\/') + \"$ref;\";\n+        final String fieldLSignature = \"L\" + inlineClass.getName().replace('.', '\/') + \";\";\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-        Asserts.assertNotNull(ex, \"An ICCE should have been thrown\");\n-        Asserts.assertEquals(ex.getClass(), IncompatibleClassChangeError.class, \"Error is not an ICCE\");\n+        Asserts.assertNull(ex, \"No error should have been thrown\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/MultiANewArrayTest\/MultiANewArrayTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        checkGetClass(val, MyInt.class);\n+        checkGetClass(val, MyInt.ref.class);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ObjectMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        if (!v.toString().equals(\"[WithFieldAccessorTest$V c=b l=5 i=10]\")) {\n+        if (!v.toString().equals(\"WithFieldAccessorTest$V@\" + Integer.toHexString(v.hashCode()))) {\n@@ -61,1 +61,1 @@\n-        if (!v.toString().equals(\"[WithFieldAccessorTest$V c=a l=25 i=10]\")) {\n+        if (!v.toString().equals(\"WithFieldAccessorTest$V@\" + Integer.toHexString(v.hashCode()))) {\n@@ -65,1 +65,1 @@\n-        if (!v.toString().equals(\"[WithFieldAccessorTest$V c=a l=5 i=20]\")) {\n+        if (!v.toString().equals(\"WithFieldAccessorTest$V@\" + Integer.toHexString(v.hashCode()))) {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldAccessorTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-                    return (aClass.isPrimitiveClass() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n+                    return (aClass.isValueType() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n@@ -273,1 +273,1 @@\n-                return aClass != null && aClass.isPrimitiveClass();\n+                return aClass != null && aClass.isValueType();\n@@ -282,1 +282,2 @@\n-                        return Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        Class<?> c = Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        return basicTypeHelper.isInlineClass(desc) ? c.asValueType() : c.asPrimaryType();\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test VarHandle on inline class array\n+ * @summary test VarHandle on primitive class array\n@@ -39,7 +39,115 @@\n-    private final Class<?> varHandleArrayType;\n-    private final Class<?> componentType;\n-    private final VarHandle vh;\n-    ArrayElementVarHandleTest() {\n-        this.varHandleArrayType = null;\n-        this.componentType = null;\n-        this.vh = null;\n+    private static final Point P = Point.makePoint(10, 20);\n+    private static final Line L = Line.makeLine(10, 20, 30, 40);\n+    private static final MutablePath PATH = MutablePath.makePath(10, 20, 30, 40);\n+\n+    private static final Point[] POINTS = new Point[]{\n+            Point.makePoint(1, 2),\n+            Point.makePoint(10, 20),\n+            Point.makePoint(100, 200)\n+    };\n+\n+    private static final Point.ref[] NULL_POINTS = new Point.ref[]{\n+            Point.makePoint(11, 22),\n+            Point.makePoint(110, 220),\n+            null\n+    };\n+\n+    private static final Line[] LINES = new Line[]{\n+            Line.makeLine(1, 2, 3, 4),\n+            Line.makeLine(10, 20, 30, 40),\n+            Line.makeLine(15, 25, 35, 45),\n+            Line.makeLine(20, 30, 40, 50)\n+    };\n+\n+    private static final Line.ref[] NULL_LINES = new Line.ref[] { null, null };\n+\n+    private static final NonFlattenValue[] NFV_ARRAY = new NonFlattenValue[]{\n+            NonFlattenValue.make(1, 2),\n+            NonFlattenValue.make(10, 20),\n+            NonFlattenValue.make(100, 200)\n+    };\n+\n+    \/*\n+     * VarHandle of Object[].class\n+     *\/\n+    @Test\n+    public void testObjectArrayVarHandle() throws Throwable {\n+        \/\/ Point[] <: Point.ref[] <: Object\n+        Object[] array1 = newArray(Object[].class, POINTS.length);\n+        setElements(array1, POINTS);\n+        setElements(array1, NULL_POINTS);\n+        setElements(array1, new Object[] { \"abc\", Point.makePoint(1, 2) });\n+\n+        Point.ref[] array2 = new Point.ref[NULL_POINTS.length];\n+        setElements(array2, POINTS);\n+        setElements(array2, NULL_POINTS);\n+\n+        Point[] array3 = new Point[POINTS.length];\n+        setElements(array3, POINTS);\n+    }\n+\n+    \/*\n+     * VarHandle of Point.ref[].class\n+     *\/\n+    @Test\n+    public void testPointRefVarHandle() throws Throwable {\n+        \/\/ Point[] <: Point.ref[] <: Object\n+        Point.ref[] array1 = (Point.ref[])newArray(Point.ref[].class, POINTS.length);\n+        assertTrue(array1.getClass().componentType() == Point.ref.class);\n+\n+        setElements(array1, POINTS);\n+        setElements(array1, NULL_POINTS);\n+\n+        Point.ref[] array2 = new Point.ref[NULL_POINTS.length];\n+        setElements(array2, POINTS);\n+        setElements(array2, NULL_POINTS);\n+\n+        Point[] array3 = new Point[POINTS.length];\n+        setElements(array3, POINTS);\n+    }\n+\n+    \/*\n+     * VarHandle of Point[].class\n+     *\/\n+    @Test\n+    public void testPointArrayVarHandle()  throws Throwable {\n+        \/\/ Point[] <: Point.ref[] <: Object\n+        Point[] array1 = (Point[]) newArray(Point[].class, POINTS.length);\n+        assertTrue(array1.getClass().componentType() == Point.class);\n+        setElements(array1, POINTS);\n+\n+        Point[] array3 = new Point[POINTS.length];\n+        setElements(array3, POINTS);\n+    }\n+\n+    \/*\n+     * VarHandle of Line.ref[].class\n+     *\/\n+    @Test\n+    public void testLineRefVarHandle() throws Throwable {\n+        \/\/ Line[] <: Line.ref[]\n+        Line.ref[] array1 = (Line.ref[])newArray(Line.ref[].class, LINES.length);\n+        assertTrue(array1.getClass().componentType() == Line.ref.class);\n+\n+        setElements(array1, LINES);\n+        setElements(array1, NULL_LINES);\n+\n+        Line.ref[] array2 = new Line.ref[LINES.length];\n+        setElements(array2, LINES);\n+        setElements(array2, NULL_LINES);\n+\n+        Line[] array3 = new Line[LINES.length];\n+        setElements(array3, LINES);\n+    }\n+\n+    \/*\n+     * VarHandle of Line[].class\n+     *\/\n+    @Test\n+    public void testLineVarHandle() throws Throwable {\n+        Line[] array1 = (Line[])newArray(Line[].class, LINES.length);\n+        assertTrue(array1.getClass().componentType() == Line.class);\n+        setElements(array1, LINES);\n+\n+        Line[] array3 = new Line[LINES.length];\n+        setElements(array3, LINES);\n@@ -47,4 +155,12 @@\n-    ArrayElementVarHandleTest(Class<?> arrayType) {\n-        this.varHandleArrayType = arrayType;\n-        this.componentType = arrayType.getComponentType();\n-        this.vh = MethodHandles.arrayElementVarHandle(arrayType);\n+\n+    \/*\n+     * VarHandle of NonFlattenValue[].class\n+     *\/\n+    @Test\n+    public void testNonFlattenedValueVarHandle() throws Throwable {\n+        NonFlattenValue[] array1 = (NonFlattenValue[])newArray(NonFlattenValue[].class, NFV_ARRAY.length);\n+        assertTrue(array1.getClass().componentType() == NonFlattenValue.class);\n+        setElements(array1, NFV_ARRAY);\n+\n+        NonFlattenValue[] array3 = new NonFlattenValue[POINTS.length];\n+        setElements(array3, NFV_ARRAY);\n@@ -53,2 +169,2 @@\n-    Object[] newArray(int size) throws Throwable {\n-        MethodHandle ctor = MethodHandles.arrayConstructor(varHandleArrayType);\n+    Object[] newArray(Class<?> arrayType, int size) throws Throwable {\n+        MethodHandle ctor = MethodHandles.arrayConstructor(arrayType);\n@@ -60,1 +176,0 @@\n-        assertTrue(varHandleArrayType.isAssignableFrom(arrayType));\n@@ -62,7 +177,9 @@\n-        set(array.clone(), elements);\n-        setVolatile(array.clone(), elements);\n-        setOpaque(array.clone(), elements);\n-        setRelease(array.clone(), elements);\n-        getAndSet(array.clone(), elements);\n-        compareAndSet(array.clone(), elements);\n-        compareAndExchange(array.clone(), elements);\n+\n+        VarHandle vh = MethodHandles.arrayElementVarHandle(arrayType);\n+        set(vh, array.clone(), elements);\n+        setVolatile(vh, array.clone(), elements);\n+        setOpaque(vh, array.clone(), elements);\n+        setRelease(vh, array.clone(), elements);\n+        getAndSet(vh, array.clone(), elements);\n+        compareAndSet(vh, array.clone(), elements);\n+        compareAndExchange(vh, array.clone(), elements);\n@@ -72,1 +189,1 @@\n-    void set(Object[] array, Object[] elements) {\n+    void set(VarHandle vh, Object[] array, Object[] elements) {\n@@ -83,1 +200,1 @@\n-    void setVolatile(Object[] array, Object[] elements) {\n+    void setVolatile(VarHandle vh, Object[] array, Object[] elements) {\n@@ -94,1 +211,1 @@\n-    void setOpaque(Object[] array, Object[] elements) {\n+    void setOpaque(VarHandle vh, Object[] array, Object[] elements) {\n@@ -105,1 +222,1 @@\n-    void setRelease(Object[] array, Object[] elements) {\n+    void setRelease(VarHandle vh, Object[] array, Object[] elements) {\n@@ -115,1 +232,1 @@\n-    void getAndSet(Object[] array, Object[] elements) {\n+    void getAndSet(VarHandle vh, Object[] array, Object[] elements) {\n@@ -127,1 +244,1 @@\n-    void compareAndSet(Object[] array, Object[] elements) {\n+    void compareAndSet(VarHandle vh, Object[] array, Object[] elements) {\n@@ -134,1 +251,1 @@\n-            Object v = elements[i+1 < elements.length ? i+1 : 0];\n+            Object v = elements[i + 1 < elements.length ? i + 1 : 0];\n@@ -141,1 +258,2 @@\n-    void compareAndExchange(Object[] array, Object[] elements) {\n+\n+    void compareAndExchange(VarHandle vh, Object[] array, Object[] elements) {\n@@ -148,1 +266,1 @@\n-            Object v = elements[i+1 < elements.length ? i+1 : 0];\n+            Object v = elements[i + 1 < elements.length ? i + 1 : 0];\n@@ -153,46 +271,0 @@\n-    private static final Point P = Point.makePoint(10, 20);\n-    private static final Line L = Line.makeLine(10, 20, 30, 40);\n-    private static final MutablePath PATH = MutablePath.makePath(10, 20, 30, 40);\n-\n-    private static final Point[] POINTS = new Point[]{\n-            Point.makePoint(1, 2),\n-            Point.makePoint(10, 20),\n-            Point.makePoint(100, 200)\n-    };\n-\n-    private static final Point.ref[] NULL_POINTS = new Point.ref[]{\n-        Point.makePoint(11, 22),\n-                Point.makePoint(110, 220),\n-                null\n-    };\n-\n-    private static final Line[] LINES = new Line[]{\n-            Line.makeLine(1, 2, 3, 4),\n-            Line.makeLine(10, 20, 30, 40),\n-            Line.makeLine(15, 25, 35, 45),\n-            Line.makeLine(20, 30, 40, 50)\n-    };\n-\n-    private static final Line.ref[] NULL_LINES = new Line.ref[] { null, null };\n-\n-    private static final NonFlattenValue[] NFV_ARRAY = new NonFlattenValue[]{\n-            NonFlattenValue.make(1, 2),\n-            NonFlattenValue.make(10, 20),\n-            NonFlattenValue.make(100, 200)\n-    };\n-\n-    \/*\n-     * VarHandle of Object[].class\n-     *\/\n-    @Test\n-    public static void testObjectArrayVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Object[].class);\n-        \/\/ Point[] <: Point.ref[] <: Object\n-        Object[] array1 = test.newArray(POINTS.length);\n-        test.setElements(array1, POINTS);\n-        test.setElements(array1, NULL_POINTS);\n-        test.setElements(array1, new Object[] { \"abc\", Point.makePoint(1, 2) });\n-\n-        Point.ref []array2 = new Point.ref [NULL_POINTS.length];\n-        test.setElements(array2, POINTS);\n-        test.setElements(array2, NULL_POINTS);\n@@ -200,91 +272,0 @@\n-        Point[] array3 = new Point[POINTS.length];\n-        test.setElements(array3, POINTS);\n-    }\n-\n-    \/*\n-     * VarHandle of Point.ref[].class\n-     *\/\n-    @Test\n-    public static void testPointRefVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Point.ref[].class);\n-        assertTrue(test.componentType == Point.ref.class);\n-\n-        \/\/ Point[] <: Point.ref[] <: Object\n-        Point.ref[] array1 = (Point.ref[])test.newArray(POINTS.length);\n-        test.setElements(array1, POINTS);\n-        test.setElements(array1, NULL_POINTS);\n-\n-        Point.ref[] array2 = new Point.ref[NULL_POINTS.length];\n-        test.setElements(array2, POINTS);\n-        test.setElements(array2, NULL_POINTS);\n-\n-        Point[] array3 = new Point[POINTS.length];\n-        test.setElements(array3, POINTS);\n-    }\n-\n-    \/*\n-     * VarHandle of Point[].class\n-     *\/\n-    @Test\n-    public static void testPointArrayVarHandle()  throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Point[].class);\n-        assertTrue(test.componentType == Point.class);\n-\n-        \/\/ Point[] <: Point.ref[] <: Object\n-        Point[] array1 = (Point[]) test.newArray(POINTS.length);\n-        test.setElements(array1, POINTS);\n-\n-        Point[] array3 = new Point[POINTS.length];\n-        test.setElements(array3, POINTS);\n-    }\n-\n-    \/*\n-     * VarHandle of Line.ref[].class\n-     *\/\n-    @Test\n-    public static void testLineRefVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Line.ref[].class);\n-        assertTrue(test.componentType == Line.ref.class);\n-\n-        \/\/ Line[] <: Line.ref[]\n-        Line.ref[] array1 = (Line.ref[])test.newArray(LINES.length);\n-        test.setElements(array1, LINES);\n-        test.setElements(array1, NULL_LINES);\n-\n-        Line.ref[] array2 = new Line.ref[LINES.length];\n-        test.setElements(array2, LINES);\n-        test.setElements(array2, NULL_LINES);\n-\n-        Line[] array3 = new Line[LINES.length];\n-        test.setElements(array3, LINES);\n-    }\n-\n-    \/*\n-     * VarHandle of Line[].class\n-     *\/\n-    @Test\n-    public static void testLineVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(Line[].class);\n-        assertTrue(test.componentType == Line.class);\n-\n-        Line[] array1 = (Line[]) test.newArray(LINES.length);\n-        test.setElements(array1, LINES);\n-\n-        Line[] array3 = new Line[LINES.length];\n-        test.setElements(array3, LINES);\n-    }\n-\n-    \/*\n-     * VarHandle of NonFlattenValue[].class\n-     *\/\n-    @Test\n-    public static void testNonFlattenedValueVarHandle() throws Throwable {\n-        ArrayElementVarHandleTest test = new ArrayElementVarHandleTest(NonFlattenValue[].class);\n-        assertTrue(test.componentType == NonFlattenValue.class);\n-\n-        NonFlattenValue[] array1 = (NonFlattenValue[]) test.newArray(NFV_ARRAY.length);\n-        test.setElements(array1, NFV_ARRAY);\n-\n-        NonFlattenValue[] array3 = new NonFlattenValue[POINTS.length];\n-        test.setElements(array3, NFV_ARRAY);\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/ArrayElementVarHandleTest.java","additions":150,"deletions":169,"binary":false,"changes":319,"status":"modified"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary test reflection on primitive classes\n+ * @compile --enable-preview --source ${jdk.version} BasicTest.java\n+ * @run testng\/othervm --enable-preview BasicTest\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.*;\n+\n+public class BasicTest {\n+    static primitive class Point {\n+        int x;\n+        int y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        int x() {\n+            return x;\n+        }\n+\n+        int y() {\n+            return y;\n+        }\n+        static Point.val newVal(int x, int y) {\n+            return new Point(x, y);\n+        }\n+        static Point.ref toRef(Object o) {\n+            return (Point.ref) o;\n+        }\n+        static Point.val toVal(Point.ref o) {\n+            return (Point.val) o;\n+        }\n+    }\n+\n+    @DataProvider(name=\"constants\")\n+    static Object[][] constants() {\n+        return new Object[][]{\n+            new Object[] { Point.class, Point.class.asValueType()},\n+            new Object[] { Point.val.class, Point.class.asValueType()},\n+            new Object[] { Point.ref.class, Point.class.asPrimaryType()},\n+        };\n+    }\n+\n+    @Test(dataProvider=\"constants\")\n+    public void ldc(Class<?> type, Class<?> expected) {\n+        assertTrue(type == expected);\n+    }\n+\n+    @DataProvider(name=\"refTypes\")\n+    static Object[][] refTypes() {\n+        return new Object[][]{\n+                new Object[] { int.class, true},\n+                new Object[] { Integer.class, true},\n+                new Object[] { Object.class, true},\n+                new Object[] { Point.ref.class, true},\n+                new Object[] { Point.val.class, false},\n+                new Object[] { Point.class.asPrimaryType(), true},\n+                new Object[] { Point.class.asValueType(), false},\n+        };\n+    }\n+    @Test(dataProvider=\"refTypes\")\n+    public void isPrimaryType(Class<?> type, boolean isRefType) {\n+        assertTrue(type.isPrimaryType() == isRefType);\n+    }\n+\n+    \/*\n+     * Tests the primary and secondary mirror.\n+     *\/\n+    @Test\n+    public void testMirrors() {\n+        Class<?> refType = Point.class.asPrimaryType();\n+        Class<?> valType = Point.class.asValueType();\n+\n+        assertTrue(refType == Point.ref.class);\n+        assertTrue(valType == Point.val.class);\n+        assertTrue(refType != valType);\n+\n+        assertTrue(refType.isPrimitiveClass());\n+        assertTrue(valType.isPrimitiveClass());\n+\n+        assertTrue(refType.isPrimaryType());\n+        assertFalse(refType.isValueType());\n+\n+        assertTrue(valType.isValueType());\n+        assertFalse(valType.isPrimaryType());\n+\n+        assertEquals(refType.getName(), valType.getName());\n+        assertEquals(refType.getName(), \"BasicTest$Point\");\n+        assertEquals(refType.getSimpleName(),\"Point\");\n+        assertEquals(valType.getSimpleName(),\"Point\");\n+\n+        assertEquals(valType.getTypeName(), \"BasicTest$Point\");\n+        assertEquals(refType.getTypeName(), \"BasicTest$Point.ref\");\n+\n+        assertEquals(valType.descriptorString(), \"QBasicTest$Point;\");\n+        assertEquals(refType.descriptorString(), \"LBasicTest$Point;\");\n+    }\n+\n+    \/*\n+     * Tests subtyping relationship: Point <: Point.ref and Point <: Object\n+     *\n+     * Class:isAssignableFrom\n+     * Class::isInstance\n+     * Class::asSubclass\n+     *\/\n+    @Test\n+    public void testSubtypes() {\n+        \/\/ Point <: Point.ref and Point <: Object\n+        assertTrue(Point.ref.class.isAssignableFrom(Point.class));\n+        assertTrue(Object.class.isAssignableFrom(Point.class));\n+        assertFalse(Point.class.isAssignableFrom(Point.ref.class));\n+        assertTrue(Object.class.isAssignableFrom(Point.ref.class));\n+\n+        assertTrue(Point.class.asSubclass(Point.ref.class) == Point.class);\n+        try {\n+            Class<?> c = Point.ref.class.asSubclass(Point.class);\n+            fail(\"Point.ref cannot be cast to Point.class\");\n+        } catch (ClassCastException e) { }\n+\n+        Point o = new Point(10, 20);\n+        assertTrue(Point.class.isInstance(o));\n+        assertTrue(Point.ref.class.isInstance(o));\n+        assertFalse(Point.class.isInstance(null));\n+        assertFalse(Point.ref.class.isInstance(null));\n+    }\n+\n+    @DataProvider(name=\"names\")\n+    static Object[][] names() {\n+        return new Object[][]{\n+                new Object[] { \"BasicTest$Point\", Point.class.asPrimaryType()},\n+                new Object[] { \"[QBasicTest$Point;\", Point[].class},\n+                new Object[] { \"[[LBasicTest$Point;\", Point.ref[][].class},\n+        };\n+    }\n+    @Test(dataProvider=\"names\")\n+    public void classForName(String name, Class<?> expected) throws ClassNotFoundException {\n+        Class<?> type = Class.forName(name);\n+        assertTrue(type == expected);\n+        assertEquals(type.getName(), name);\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        Point.ref ref = Point.toRef(null);\n+        assertTrue(ref == null);\n+        try {\n+            Point.toVal(null);\n+            throw new RuntimeException(\"expected NPE thrown\");\n+        } catch (NullPointerException e) {}\n+    }\n+\n+    @Test\n+    public void testConversion() {\n+        Point p = new Point(10,20);\n+        Point.ref ref = Point.toRef(p);\n+        Point.val val = Point.toVal(ref);\n+        assertEquals(ref, p);\n+        assertEquals(val, p);\n+    }\n+\n+    @Test\n+    public void testMembers() {\n+        Method[] refMethods = Point.ref.class.getDeclaredMethods();\n+        Method[] valMethods = Point.val.class.getDeclaredMethods();\n+        assertEquals(refMethods, valMethods);\n+        assertTrue(valMethods.length == 5);\n+\n+        Field[] refFields = Point.ref.class.getDeclaredFields();\n+        Field[] valFields = Point.val.class.getDeclaredFields();\n+        assertEquals(refFields, valFields);\n+        assertTrue(valFields.length == 2);\n+\n+        Constructor[] refCtors = Point.ref.class.getDeclaredConstructors();\n+        Constructor[] valCtors = Point.val.class.getDeclaredConstructors();\n+        assertEquals(refCtors, valCtors);\n+        assertTrue(valCtors.length == 1);\n+        assertTrue(Modifier.isStatic(valCtors[0].getModifiers()));\n+    }\n+\n+    @DataProvider(name=\"methods\")\n+    static Object[][] methods() {\n+        return new Object[][]{\n+                new Object[] { \"toVal\", Point.val.class, new Class<?>[] { Point.ref.class }},\n+                new Object[] { \"toRef\", Point.ref.class, new Class<?>[] { Object.class }},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methods\")\n+    public void testMethod(String name, Class<?> returnType, Class<?>[] paramTypes) throws ReflectiveOperationException {\n+        Method m = Point.class.getDeclaredMethod(name, paramTypes);\n+        System.out.print(m.toString() + \"  \");\n+        System.out.println(m.getReturnType().descriptorString());\n+        assertTrue(m.getDeclaringClass() == Point.class.asPrimaryType());\n+        assertTrue(m.getReturnType() == returnType);\n+        assertEquals(m.getParameterTypes(), paramTypes);\n+    }\n+\n+    @Test\n+    public void testConstructor() throws ReflectiveOperationException {\n+        Constructor<?> ctor = Point.class.getDeclaredConstructor(int.class, int.class);\n+        assertTrue(ctor.getDeclaringClass() == Point.class.asPrimaryType());\n+    }\n+\n+    class C implements IdentityObject { }\n+    primitive class T implements PrimitiveObject { }\n+\n+    @DataProvider(name=\"intfs\")\n+    Object[][] intfs() {\n+        Point point = new Point(10, 20);\n+        Point[] array = new Point[] { point };\n+        return new Object[][]{\n+                new Object[]{ new BasicTest(), new Class<?>[] { IdentityObject.class }},\n+                new Object[]{ point, new Class<?>[] { PrimitiveObject.class }},\n+                new Object[]{ new T(), new Class<?>[] { PrimitiveObject.class }},\n+                new Object[]{ new C(), new Class<?>[] { IdentityObject.class }},\n+                new Object[]{ Objects.newIdentity(), new Class<?>[] { IdentityObject.class }},\n+                new Object[]{ array, new Class<?>[] { Cloneable.class, Serializable.class, IdentityObject.class }},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"intfs\")\n+    public void testGetInterfaces(Object o, Class<?>[] expectedInterfaces) {\n+        Class<?> type = o.getClass();\n+        assertEquals(type.getInterfaces(), expectedInterfaces);\n+        if (type.isPrimitiveClass()) {\n+            assertTrue(PrimitiveObject.class.isAssignableFrom(type));\n+            assertTrue(o instanceof PrimitiveObject);\n+        } else {\n+            assertTrue(IdentityObject.class.isAssignableFrom(type));\n+            assertTrue(o instanceof IdentityObject);\n+        }\n+    }\n+\n+    @Test\n+    public void testNestMembership() {\n+        assertTrue(Point.class.getNestHost() == BasicTest.class);\n+        assertTrue(T.class.getNestHost() == BasicTest.class);\n+        assertTrue(C.class.getNestHost() == BasicTest.class);\n+\n+        Class<?>[] members = BasicTest.class.getNestMembers();\n+        assertEquals(Point.class.getNestMembers(), members);\n+        assertEquals(T.class.getNestMembers(), members);\n+        assertEquals(C.class.getNestMembers(), members);\n+        assertEquals(Arrays.stream(members).collect(Collectors.toSet()),\n+                     Set.of(BasicTest.class,\n+                            Point.class.asPrimaryType(),\n+                            C.class.asPrimaryType(),\n+                            T.class.asPrimaryType()));\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/BasicTest.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary Test reflection of constructors for inline classes\n- * @run testng\/othervm InlineConstructorTest\n- *\/\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class InlineConstructorTest {\n-\n-    \/\/ Target test class\n-    static primitive class SimpleInline {\n-        public final int x;\n-\n-        SimpleInline() {\n-            x = -1;\n-        }\n-\n-        public SimpleInline(int x) {\n-            this.x = x;\n-        }\n-    }\n-\n-    static final Class<?> INLINE_TYPE = SimpleInline.class;\n-\n-    @Test\n-    public static void testInlineClassConstructor() throws Exception {\n-        String cn = INLINE_TYPE.getName();\n-        Class<?> c = Class.forName(cn);\n-\n-        assertTrue(c.isPrimitiveClass());\n-        assertEquals(c, INLINE_TYPE);\n-    }\n-\n-    @Test\n-    public static void constructor() throws Exception {\n-        Constructor<?> ctor = INLINE_TYPE.getDeclaredConstructor();\n-        Object o = ctor.newInstance();\n-        assertEquals(o.getClass(), INLINE_TYPE);\n-    }\n-\n-    \/\/ Check that the class has the expected Constructors\n-    @Test\n-    public static void constructors() throws Exception {\n-        Set<String> expectedSig = Set.of(\"public InlineConstructorTest$SimpleInline(int)\",\n-                                         \"InlineConstructorTest$SimpleInline()\");\n-        Constructor<? extends Object>[] cons = INLINE_TYPE.getDeclaredConstructors();\n-        Set<String> actualSig = Arrays.stream(cons).map(Constructor::toString)\n-                                      .collect(Collectors.toSet());\n-        boolean ok = expectedSig.equals(actualSig);\n-        if (!ok) {\n-            System.out.printf(\"expected: %s%n\", expectedSig);\n-            System.out.printf(\"declared: %s%n\", actualSig);\n-            assertTrue(ok);\n-        }\n-    }\n-\n-    \/\/ Check that the constructor and field can be set accessible\n-    @Test\n-    public static void setAccessible() throws Exception {\n-        Constructor<?> ctor = INLINE_TYPE.getDeclaredConstructor();\n-        ctor.setAccessible(true);\n-\n-        Field field = INLINE_TYPE.getField(\"x\");\n-        field.setAccessible(true);\n-    }\n-\n-    \/\/ Check that the constructor and field can be set accessible\n-    @Test\n-    public static void trySetAccessible() throws Exception {\n-        Constructor<?> ctor = INLINE_TYPE.getDeclaredConstructor();\n-        assertTrue(ctor.trySetAccessible());\n-\n-        Field field = INLINE_TYPE.getField(\"x\");\n-        assertTrue(field.trySetAccessible());\n-    }\n-\n-    \/\/ Check that the final field cannot be modified\n-    @Test(expectedExceptions = IllegalAccessException.class)\n-    public static void setFinalField() throws Exception {\n-        Field field = INLINE_TYPE.getField(\"x\");\n-        field.setAccessible(true);\n-        field.setInt(new SimpleInline(100), 200);\n-    }\n-\n-\n-    \/\/ Check that the class does not have a static method with the name <init>\n-    @Test\n-    public static void initFactoryNotMethods() {\n-        Method[] methods = INLINE_TYPE.getDeclaredMethods();\n-        for (Method m : methods) {\n-            if (Modifier.isStatic(m.getModifiers())) {\n-                assertFalse(m.getName().equals(\"<init>\"));\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/InlineConstructorTest.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary test method handles with inline type conversion\n- * @run testng\/othervm InlineTypeConversionTest\n- *\/\n-\n-import java.lang.invoke.*;\n-\n-import static java.lang.invoke.MethodType.*;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class InlineTypeConversionTest {\n-    static primitive class Value {\n-        Point val;\n-        Point.ref ref;\n-        Value(Point p1, Point.ref p2) {\n-            this.val = p1;\n-            this.ref = p2;\n-        }\n-    }\n-\n-    static Value narrow(Value.ref v) {\n-        return v;\n-    }\n-\n-    static Value.ref widen(Value v) {\n-        if (((Object)v) == null) {\n-            throw new Error(\"should never reach here: should be caught by runtime\");\n-        }\n-        return null;\n-    }\n-\n-    static final Value VALUE = new Value(new Point(10,10), new Point(20, 20));\n-\n-    @Test\n-    public static void inlineWidening() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findStatic(InlineTypeConversionTest.class, \"narrow\", methodType(Value.class, Value.ref.class));\n-        MethodHandle mh2 = mh1.asType(methodType(Value.class, Value.class));\n-        Object v = mh1.invoke(VALUE);\n-        assertEquals(v, VALUE);\n-        try {\n-            Object v1 = mh1.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-\n-        try {\n-            Object v2 = mh2.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-    }\n-\n-    @Test\n-    public static void inlineNarrowing() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh = lookup.findStatic(InlineTypeConversionTest.class, \"widen\", methodType(Value.ref.class, Value.class));\n-        Object v = mh.invoke(VALUE);\n-        assertTrue(v == null);\n-        try {\n-            Object v1 = mh.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {\n-            e.printStackTrace();\n-        }\n-        MethodHandle mh2 = mh.asType(methodType(Value.class, Value.ref.class));\n-        try {\n-            Value v2 = (Value) mh2.invoke((Value.ref)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Test\n-    public static void valToRef() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findGetter(Value.class, \"val\", Point.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.class));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point p1 = (Point) mh1.invokeExact(VALUE);\n-        Point.ref p2 = (Point.ref) mh2.invokeExact(VALUE);\n-        assertEquals(p1, p2);\n-    }\n-\n-    @Test\n-    public static void refToVal() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.class));\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(VALUE);\n-        Point p2 = (Point) mh2.invokeExact(VALUE);\n-        assertEquals(p1, p2);\n-    }\n-\n-    @Test\n-    public static void valToRef1() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findGetter(Value.class, \"val\", Point.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.ref.class));\n-\n-        Point p1 = (Point) mh1.invokeExact(VALUE);\n-        Point p2 = (Point) mh2.invoke(VALUE);\n-        Point p3 = (Point) mh2.invokeExact((Value.ref)VALUE);\n-        assertEquals(p1, p2);\n-        assertEquals(p1, p3);\n-    }\n-\n-    @Test\n-    public static void refToVal1() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.ref.class));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n-        Point.ref p2 = (Point.ref) mh2.invoke(v);\n-        Point.ref p3 = (Point.ref) mh2.invokeExact((Value.ref)v);\n-        assertEquals(p1, p2);\n-        assertEquals(p1, p3);\n-    }\n-\n-    @Test\n-    public static void refToVal2() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.class));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n-        try {\n-            Point p2 = (Point) mh2.invokeExact(v);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/InlineTypeConversionTest.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test lambda type conversion of inline type\n+ * @summary test lambda type conversion of primitive class\n@@ -30,1 +30,0 @@\n-import java.util.List;\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaConversion.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test MethodHandle\/VarHandle on inline types\n+ * @summary test MethodHandle\/VarHandle o primitive classes\n@@ -41,0 +41,1 @@\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n@@ -45,4 +46,15 @@\n-    @Test\n-    public static void testPointClass() throws Throwable  {\n-        MethodHandleTest test = new MethodHandleTest(\"Point\", P, \"x\", \"y\");\n-        test.run();\n+    @DataProvider(name=\"fields\")\n+    static Object[][] fields() {\n+        MutablePath path = MutablePath.makePath(1, 2, 3, 4);\n+        MixedValues mv = new MixedValues(P, L, PATH, \"mixed\", \"types\");\n+        return new Object[][]{\n+                \/\/ primitive class with int fields\n+                new Object[] { \"Point\", P, new String[] { \"x\", \"y\"} },\n+                \/\/ primitive class whose fields are of primitive value type\n+                new Object[] { \"Line\", L, new String[] { \"p1\", \"p2\"} },\n+                \/\/ non-primitive class whose non-final fields are of primitive value type\n+                new Object[] { \"MutablePath\", PATH, new String[] {\"p1\", \"p2\"} },\n+                new Object[] { \"Point\", path.p1, new String[] {\"x\", \"y\"} },\n+                new Object[] { \"Point\", path.p2, new String[] {\"x\", \"y\"} },\n+                new Object[] { \"MixedValues\", mv, new String[] {\"p\", \"l\", \"mutablePath\", \"list\", \"nfp\"} },\n+        };\n@@ -51,5 +63,10 @@\n-    @Test\n-    public static void testLineClass() throws Throwable {\n-        MethodHandleTest test = new MethodHandleTest(\"Line\", L, \"p1\", \"p2\");\n-        test.run();\n-    }\n+    \/**\n+     * Test MethodHandle invocation on the fields of a given class.\n+     * MethodHandle produced by Lookup::unreflectGetter, Lookup::findGetter,\n+     * Lookup::findVarHandle.\n+     *\/\n+    @Test(dataProvider = \"fields\")\n+    public void testFieldGetterAndSetter(String cn, Object o, String[] fieldNames) throws Throwable  {\n+        Class<?> c = Class.forName(cn);\n+        for (String name : fieldNames) {\n+            Field f = c.getDeclaredField(name);\n@@ -57,4 +74,2 @@\n-    @Test\n-    public static void testMutablePath() throws Throwable {\n-        MethodHandleTest test = new MethodHandleTest(\"MutablePath\", PATH, \"p1\", \"p2\");\n-        test.run();\n+            MethodHandle mh = LOOKUP.findGetter(c, f.getName(), f.getType());\n+            Object v1 = mh.invoke(o);\n@@ -62,5 +77,11 @@\n-        \/\/ set the mutable fields\n-        MutablePath path = MutablePath.makePath(1, 2, 3, 44);\n-        Point p = Point.makePoint(100, 200);\n-        test.setValueField(\"p1\", path, p);\n-        test.setValueField(\"p2\", path, p);\n+            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n+            Object v2 = vh.get(o);\n+\n+            MethodHandle mh3 = LOOKUP.unreflectGetter(f);\n+            Object v3 = mh.invoke(o);\n+\n+            if (c.isPrimitiveClass())\n+                ensureImmutable(f, o);\n+            else\n+                ensureNullable(f, o);\n+        }\n@@ -70,8 +91,6 @@\n-    public static void testValueFields() throws Throwable {\n-        MutablePath path = MutablePath.makePath(1, 2, 3, 4);\n-        \/\/ p1 and p2 are a non-final field of inline type in a reference\n-        MethodHandleTest test1 = new MethodHandleTest(\"Point\", path.p1, \"x\", \"y\");\n-        test1.run();\n-\n-        MethodHandleTest test2 = new MethodHandleTest(\"Point\", path.p2, \"x\", \"y\");\n-        test2.run();\n+    public void testValueFields() throws Throwable {\n+        \/\/ set the mutable value fields\n+        MutablePath path = MutablePath.makePath(1, 2, 3, 44);\n+        Point p = Point.makePoint(100, 200);\n+        setValueField(MutablePath.class, \"p1\", path, p);\n+        setValueField(MutablePath.class, \"p2\", path, p);\n@@ -80,0 +99,2 @@\n+    \/\/ Test writing to a field of primitive value type and of primitive\n+    \/\/ reference type\n@@ -81,1 +102,3 @@\n-    public static void testMixedValues() throws Throwable {\n+    public void testMixedValues() throws Throwable {\n+        \/\/ set the mutable fields\n+        MutablePath path = MutablePath.makePath(1, 2, 3, 44);\n@@ -83,4 +106,0 @@\n-        MethodHandleTest test =\n-            new MethodHandleTest(\"MixedValues\", mv, \"p\", \"l\", \"mutablePath\", \"list\", \"nfp\");\n-        test.run();\n-\n@@ -89,8 +108,10 @@\n-        test.setValueField(\"p\", mv, p);\n-        test.setValueField(\"nfp\", mv, p);\n-        test.setValueField(\"l\", mv, l);\n-        test.setValueField(\"l\", mv, l);\n-        test.setValueField(\"staticPoint\", null, p);\n-        test.setValueField(\"staticLine\", null, l);\n-        \/\/ staticLine is a nullable field\n-        test.setValueField(\"staticLine\", null, null);\n+\n+        setValueField(MutablePath.class, \"p1\", path, p);\n+        setValueField(MutablePath.class, \"p2\", path, p);\n+        setValueField(MixedValues.class, \"p\", mv, p);\n+        setValueField(MixedValues.class, \"l\", mv, l);\n+        setValueField(MixedValues.class, \"staticPoint\", null, p);\n+        \/\/ the following are nullable fields\n+        setField(MixedValues.class, \"nfp\", mv, p, false);\n+        setField(MixedValues.class, \"staticLine\", null, l, false);\n+        setField(MixedValues.class, \"staticLine\", null, null, false);\n@@ -99,5 +120,8 @@\n-    @Test\n-    public static void testArrayElementSetterAndGetter() throws Throwable {\n-        testArray(Point[].class, P);\n-        testArray(Line[].class, L);\n-        testArray(MutablePath[].class, PATH);\n+    @DataProvider(name=\"arrays\")\n+    static Object[][] arrays() {\n+        return new Object[][]{\n+                new Object[] { Point[].class, P },\n+                new Object[] { Point.ref[].class, P },\n+                new Object[] { Line[].class, L },\n+                new Object[] { MutablePath[].class, PATH },\n+        };\n@@ -106,4 +130,6 @@\n-    static void testArray(Class<?> c, Object o) throws Throwable {\n-        MethodHandle setter = MethodHandles.arrayElementSetter(c);\n-        MethodHandle getter = MethodHandles.arrayElementGetter(c);\n-        MethodHandle ctor = MethodHandles.arrayConstructor(c);\n+    @Test(dataProvider = \"arrays\")\n+    public void testArrayElementSetterAndGetter(Class<?> arrayClass, Object o) throws Throwable {\n+        Class<?> elementType = arrayClass.getComponentType();\n+        MethodHandle setter = MethodHandles.arrayElementSetter(arrayClass);\n+        MethodHandle getter = MethodHandles.arrayElementGetter(arrayClass);\n+        MethodHandle ctor = MethodHandles.arrayConstructor(arrayClass);\n@@ -119,5 +145,0 @@\n-\n-        Class<?> elementType = c.getComponentType();\n-        if (elementType.isPrimitiveClass()) {\n-            assertTrue(elementType == elementType.valueType().get());\n-        }\n@@ -126,2 +147,3 @@\n-            Object v = (Object)setter.invoke(array, 0, null);\n-            assertFalse(elementType.isPrimitiveClass(), \"should fail to set an inline class array element to null\");\n+            Object v = (Object)setter.invoke(array, 1, null);\n+            assertFalse(elementType.isValueType(), \"should fail to set a primitive class array element to null\");\n+            assertNull((Object)getter.invoke(array, 1));\n@@ -129,1 +151,1 @@\n-            assertTrue(elementType.isPrimitiveClass(), \"should only fail to set an inline class array element to null\");\n+            assertTrue(elementType.isValueType(), \"should only fail to set a primitive class array element to null\");\n@@ -133,40 +155,31 @@\n-    @Test\n-    public static void testNullableArray() throws Throwable {\n-        Class<?> arrayClass = (new Point.ref[0]).getClass();\n-        Class<?> elementType = arrayClass.getComponentType();\n-        assertTrue(elementType == Point.ref.class, arrayClass.getComponentType().toString());\n-\n-        MethodHandle setter = MethodHandles.arrayElementSetter(arrayClass);\n-        MethodHandle getter = MethodHandles.arrayElementGetter(arrayClass);\n-        MethodHandle ctor = MethodHandles.arrayConstructor(arrayClass);\n-        Object[] array = (Object[]) ctor.invoke(2);\n-        setter.invoke(array, 0, P);\n-        setter.invoke(array, 1, null);\n-        assertEquals((Point)getter.invoke(array, 0), P);\n-        assertNull((Object)getter.invoke(array, 1));\n-    }\n-\n-    private final Class<?> c;\n-    private final Object o;\n-    private final List<String> names;\n-    public MethodHandleTest() {\n-        this.c = null;\n-        this.o = null;\n-        this.names = null;\n-    }\n-    public MethodHandleTest(String cn, Object o, String... fields) throws Exception {\n-        this.c = Class.forName(cn);\n-        this.o = o;\n-        this.names = List.of(fields);\n-    }\n-\n-    public void run() throws Throwable {\n-        for (String name : names) {\n-            Field f = c.getDeclaredField(name);\n-            unreflectField(f);\n-            findGetter(f);\n-            varHandle(f);\n-            if (c.isPrimitiveClass())\n-                ensureImmutable(f);\n-            else\n-                ensureNullable(f);\n+    \/*\n+     * Test setting the given field to null via reflection, method handle\n+     * and var handle.\n+     *\/\n+    static void ensureNullable(Field f, Object o) throws Throwable {\n+        Class<?> c = f.getDeclaringClass();\n+        assertFalse(Modifier.isFinal(f.getModifiers()));\n+        assertFalse(Modifier.isStatic(f.getModifiers()));\n+        boolean canBeNull = f.getType().isPrimaryType();\n+        \/\/ test reflection\n+        try {\n+            f.set(o, null);\n+            assertTrue(canBeNull, f + \" cannot be set to null\");\n+        } catch (NullPointerException e) {\n+            assertFalse(canBeNull, f + \" should allow be set to null\");\n+        }\n+        \/\/ test method handle, i.e. putfield bytecode behavior\n+        try {\n+            MethodHandle mh = LOOKUP.findSetter(c, f.getName(), f.getType());\n+            mh.invoke(o, null);\n+            assertTrue(canBeNull, f + \" cannot be set to null\");\n+        } catch (NullPointerException e) {\n+            assertFalse(canBeNull, f + \" should allow be set to null\");\n+        }\n+        \/\/ test var handle\n+        try {\n+            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n+            vh.set(o, null);\n+            assertTrue(canBeNull, f + \" cannot be set to null\");\n+        } catch (NullPointerException e) {\n+            assertFalse(canBeNull, f + \" should allow be set to null\");\n@@ -176,8 +189,11 @@\n-    public List<String> names() {\n-        return names;\n-    }\n-\n-    void findGetter(Field f) throws Throwable {\n-        MethodHandle mh = MethodHandles.lookup().findGetter(c, f.getName(), f.getType());\n-        Object value = mh.invoke(o);\n-    }\n+    static void ensureImmutable(Field f, Object o) throws Throwable {\n+        Class<?> c = f.getDeclaringClass();\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        assertFalse(Modifier.isStatic(f.getModifiers()));\n+        Object v = f.get(o);\n+        \/\/ test Field::set\n+        try {\n+            f.set(o, v);\n+            throw new RuntimeException(f + \" should be immutable\");\n+        } catch (IllegalAccessException e) {\n+        }\n@@ -185,3 +201,14 @@\n-    void varHandle(Field f) throws Throwable {\n-        VarHandle vh = MethodHandles.lookup().findVarHandle(c, f.getName(), f.getType());\n-        Object value = vh.get(o);\n+        \/\/ test method handle, i.e. putfield bytecode behavior\n+        try {\n+            MethodHandle mh = LOOKUP.findSetter(c, f.getName(), f.getType());\n+            mh.invoke(o, v);\n+            throw new RuntimeException(f + \" should be immutable\");\n+        } catch (IllegalAccessException e) {\n+        }\n+        \/\/ test var handle\n+        try {\n+            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n+            vh.set(o, v);\n+            throw new RuntimeException(f + \" should be immutable\");\n+        } catch (UnsupportedOperationException e) {\n+        }\n@@ -190,3 +217,6 @@\n-    void unreflectField(Field f) throws Throwable {\n-        MethodHandle mh = MethodHandles.lookup().unreflectGetter(f);\n-        Object value = mh.invoke(o);\n+    \/*\n+     * Test setting a field of a primitive class to a new value.\n+     * The field must be flattenable but may or may not be flattened.\n+     *\/\n+    static void setValueField(Class<?> c, String name, Object obj, Object value) throws Throwable {\n+        setField(c, name, obj, value, true);\n@@ -196,2 +226,2 @@\n-     * Test setting a field of an inline type to a new value.\n-     * The field must be flattenable but may or may not be flattened.\n+     * Test Field::set, MethodHandle::set on a method handle of a field\n+     * and VarHandle::compareAndSet and compareAndExchange.\n@@ -199,1 +229,1 @@\n-    void setValueField(String name, Object obj, Object value) throws Throwable {\n+    static void setField(Class<?> c, String name, Object obj, Object value, boolean isValue) throws Throwable {\n@@ -202,1 +232,2 @@\n-        assertTrue(f.getType().isPrimitiveClass() || f.getType().valueType().isPresent());\n+        assertTrue(f.getType().isPrimitiveClass());\n+        assertTrue(f.getType().isValueType() == isValue);\n@@ -214,1 +245,0 @@\n-\n@@ -222,1 +252,1 @@\n-    private void setInstanceField(Field f, Object obj, Object value) throws Throwable {\n+    static void setInstanceField(Field f, Object obj, Object value) throws Throwable {\n@@ -226,1 +256,1 @@\n-            MethodHandle mh = MethodHandles.lookup().findSetter(c, f.getName(), f.getType());\n+            MethodHandle mh = LOOKUP.findSetter(f.getDeclaringClass(), f.getName(), f.getType());\n@@ -234,1 +264,1 @@\n-        VarHandle vh = MethodHandles.lookup().findVarHandle(c, f.getName(), f.getType());\n+        VarHandle vh = LOOKUP.findVarHandle(f.getDeclaringClass(), f.getName(), f.getType());\n@@ -257,1 +287,1 @@\n-    private void setStaticField(Field f, Object value) throws Throwable {\n+    static void setStaticField(Field f, Object value) throws Throwable {\n@@ -261,1 +291,1 @@\n-            MethodHandle mh = MethodHandles.lookup().findStaticSetter(c, f.getName(), f.getType());\n+            MethodHandle mh = LOOKUP.findStaticSetter(f.getDeclaringClass(), f.getName(), f.getType());\n@@ -268,1 +298,1 @@\n-        VarHandle vh = MethodHandles.lookup().findStaticVarHandle(c, f.getName(), f.getType());\n+        VarHandle vh = LOOKUP.findStaticVarHandle(f.getDeclaringClass(), f.getName(), f.getType());\n@@ -290,59 +320,0 @@\n-\n-    \/*\n-     * Test setting the given field to null via reflection, method handle\n-     * and var handle.\n-     *\/\n-    void ensureNullable(Field f) throws Throwable {\n-        assertFalse(Modifier.isStatic(f.getModifiers()));\n-        boolean canBeNull = !f.getType().isPrimitiveClass();\n-        \/\/ test reflection\n-        try {\n-            f.set(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n-        }\n-        \/\/ test method handle, i.e. putfield bytecode behavior\n-        try {\n-            MethodHandle mh = MethodHandles.lookup().findSetter(c, f.getName(), f.getType());\n-            mh.invoke(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n-        }\n-        \/\/ test var handle\n-        try {\n-            VarHandle vh = MethodHandles.lookup().findVarHandle(c, f.getName(), f.getType());\n-            vh.set(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n-        }\n-    }\n-\n-    void ensureImmutable(Field f) throws Throwable {\n-        assertFalse(Modifier.isStatic(f.getModifiers()));\n-        Object v = f.get(o);\n-        \/\/ test reflection\n-        try {\n-            f.set(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (IllegalAccessException e) {}\n-\n-        \/\/ test method handle, i.e. putfield bytecode behavior\n-        try {\n-            MethodHandle mh = MethodHandles.lookup().findSetter(c, f.getName(), f.getType());\n-            mh.invoke(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (IllegalAccessException e) { }\n-        \/\/ test var handle\n-        try {\n-            VarHandle vh = MethodHandles.lookup().findVarHandle(c, f.getName(), f.getType());\n-            vh.set(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (UnsupportedOperationException e) {}\n-    }\n-\n-    boolean isFlattened(Field f) {\n-        return (f.getModifiers() & 0x00008000) == 0x00008000;\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":153,"deletions":182,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main MethodReference\n+ * @summary test method reference and primitive reference type as the parameter type\n+ *\/\n+\n+import java.util.function.Supplier;\n+\n+public primitive class MethodReference {\n+    final int x;\n+    final int y;\n+    MethodReference() {\n+        this.x = 1234;\n+        this.y = 5678;\n+    }\n+\n+    public static void main(String... args) {\n+        Supplier<MethodReference.ref> supplier = MethodReference::new;\n+        MethodReference o = (MethodReference) supplier.get();\n+        if (o.x != 1234 || o.y != 5678)\n+            throw new AssertionError(o);\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodReference.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main Nest\n+ * @summary Test substitutability of inner class and anonymous class that\n+ * has the enclosing instance and possibly other captured outer locals\n+ *\/\n+\n+public interface Nest {\n+    public static void main(String... args) {\n+        assertEquals(Nest.of(1, null), Nest.of(1, null));\n+        assertNotEquals(Nest.of(1, null), Nest.of(2, null));\n+\n+        Outer n = new Outer(1);\n+        Outer.Inner inner = n.new Inner(10);\n+        Outer n1 = new Outer(1);\n+        Outer n2 = new Outer(2);\n+        assertEquals(n1.new Inner(10), inner);\n+        assertEquals(n2.new Inner(10), new Outer(2).new Inner(10));\n+    }\n+\n+    \/\/ o1.new Inner(1) == o2.new Inner(1) iff o1 == o2\n+    static primitive class Outer {\n+        final int i;\n+        Outer(int i) {\n+            this.i = i;\n+        }\n+\n+        primitive class Inner {\n+            final int ic;\n+            Inner(int ic) {\n+                this.ic = ic;\n+            }\n+        }\n+    }\n+\n+    String toString();\n+\n+    static Nest of(int value, Object next) {\n+        \/\/ anonymous class capturing outer locals\n+        return new primitive Nest() {\n+            public String toString() {\n+                return value + \" -> \" + next;\n+            }\n+        };\n+    }\n+\n+    static void assertEquals(Object o1, Object o2) {\n+        if (o1 != o2) {\n+            throw new RuntimeException(o1 + \" != \" + o2);\n+        }\n+    }\n+    static void assertNotEquals(Object o1, Object o2) {\n+        if (o1 == o2) {\n+            throw new RuntimeException(o1 + \" == \" + o2);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/Nest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test Object methods on inline types\n+ * @summary test Object methods on primitive classes\n@@ -29,1 +29,0 @@\n- * @run testng\/othervm -Xcomp -Dvalue.bsm.salt=1 ObjectMethods\n@@ -33,0 +32,3 @@\n+\/* To be enabled by JDK-8267932\n+ * @run testng\/othervm -Xcomp -Dvalue.bsm.salt=1 ObjectMethods\n+ *\/\n@@ -36,1 +38,0 @@\n-import java.util.Objects;\n@@ -90,1 +91,1 @@\n-            \/\/ reference classes containing fields of inline type\n+            \/\/ reference classes containing fields of primitive class\n@@ -98,7 +99,7 @@\n-            { new IndirectType0(10), new IndirectType0(10), true},\n-            { new InlineType1(10),   new InlineType1(10), true},\n-            { new InlineType2(10),   new InlineType2(10), true},\n-            { new InlineType1(20),   new InlineType2(20), false},\n-            { new InlineType2(20),   new InlineType1(20), true},\n-            { new IndirectType0(30), new InlineType1(30), true},\n-            { new IndirectType0(30), new InlineType2(30), true},\n+            { new ReferenceType0(10), new ReferenceType0(10), true},\n+            { new ValueType1(10),   new ValueType1(10), true},\n+            { new ValueType2(10),   new ValueType2(10), true},\n+            { new ValueType1(20),   new ValueType2(20), false},\n+            { new ValueType2(20),   new ValueType1(20), true},\n+            { new ReferenceType0(30), new ValueType1(30), true},\n+            { new ReferenceType0(30), new ValueType2(30), true},\n@@ -116,7 +117,7 @@\n-                { new IndirectType0(10), new IndirectType0(10), false, true},\n-                { new InlineType1(10),   new InlineType1(10),   true,  true},\n-                { new InlineType2(10),   new InlineType2(10),   true,  true},\n-                { new InlineType1(20),   new InlineType2(20),   false, false},\n-                { new InlineType2(20),   new InlineType1(20),   false, true},\n-                { new IndirectType0(30), new InlineType1(30),   false, true},\n-                { new IndirectType0(30), new InlineType2(30),   false, true},\n+                { new ReferenceType0(10), new ReferenceType0(10), false, true},\n+                { new ValueType1(10),   new ValueType1(10),   true,  true},\n+                { new ValueType2(10),   new ValueType2(10),   true,  true},\n+                { new ValueType1(20),   new ValueType2(20),   false, false},\n+                { new ValueType2(20),   new ValueType1(20),   false, true},\n+                { new ReferenceType0(30), new ValueType1(30),   false, true},\n+                { new ReferenceType0(30), new ValueType2(30),   false, true},\n@@ -133,0 +134,1 @@\n+\n@@ -136,9 +138,4 @@\n-            { Point.makePoint(100, 200), \"[Point x=100 y=200]\" },\n-            { Line.makeLine(1, 2, 3, 4), \"[Line p1=[Point x=1 y=2] p2=[Point x=3 y=4]]\"},\n-            { VALUE,\n-              \"[Value char_v=z byte_v=1 boolean_v=false int_v=0 short_v=3 long_v=4 double_v=0.0 \" +\n-              \"float_v=0.0 number_v=[Value$IntValue i=10] point_v=[Point x=200 y=200] point_ref=null ref_v=null]\" },\n-            { VALUE1,\n-              \"[Value char_v=z byte_v=1 boolean_v=false int_v=0 short_v=3 long_v=4 double_v=0.0 \" +\n-              \"float_v=0.0 number_v=[Value$IntValue i=20] point_v=[Point x=100 y=100] \" +\n-              \"point_ref=[Point x=200 y=200] ref_v=[Point x=300 y=300]]\" },\n+            { Point.makePoint(100, 200)  },\n+            { Line.makeLine(1, 2, 3, 4) },\n+            { VALUE },\n+            { VALUE1 },\n@@ -147,3 +144,1 @@\n-                        .setNumber(new Value.IntNumber(99)).build(),\n-              \"[Value char_v=\\u0000 byte_v=0 boolean_v=false int_v=0 short_v=0 long_v=0 double_v=0.0 \" +\n-              \"float_v=0.0 number_v=99 point_v=[Point x=0 y=0] point_ref=null ref_v=[ref]]\" },\n+                        .setNumber(new Value.IntNumber(99)).build() },\n@@ -151,3 +146,3 @@\n-            { MyValue1.default, \"[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=null]\" },\n-            { new MyValue1(0,0, null), \"[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=null]\" },\n-            { new MyValue1(0,0, P1), \"[ObjectMethods$MyValue1 p=[Point x=0 y=0] np=[Point x=1 y=2]]\" },\n+            { MyValue1.default },\n+            { new MyValue1(0,0, null) },\n+            { new MyValue1(0,0, P1) },\n@@ -158,2 +153,3 @@\n-    public void testToString(Object o, String s) {\n-        assertTrue(o.toString().equals(s), o.toString());\n+    public void testToString(Object o) {\n+        String expected = String.format(\"%s@%s\", o.getClass().getName(), Integer.toHexString(o.hashCode()));\n+        assertEquals(o.toString(), expected);\n@@ -169,1 +165,1 @@\n-            { VALUE1,                hash(hashCodeComponents(VALUE1))},\n+            { VALUE1,               hash(hashCodeComponents(VALUE1))},\n@@ -180,0 +176,1 @@\n+        assertEquals(System.identityHashCode(o), hash);\n@@ -184,1 +181,1 @@\n-        \/\/ filter static fields and synthetic fields\n+        \/\/ filter static fields\n@@ -186,1 +183,1 @@\n-            .filter(f -> !Modifier.isStatic(f.getModifiers()) && !f.isSynthetic())\n+            .filter(f -> !Modifier.isStatic(f.getModifiers()))\n@@ -194,0 +191,3 @@\n+        if (type.isPrimitiveClass()) {\n+            type = type.asValueType();\n+        }\n@@ -220,1 +220,1 @@\n-    static class IndirectType0 implements Number {\n+    static class ReferenceType0 implements Number {\n@@ -222,1 +222,1 @@\n-        public IndirectType0(int i) {\n+        public ReferenceType0(int i) {\n@@ -237,1 +237,1 @@\n-    static primitive class InlineType1 implements Number {\n+    static primitive class ValueType1 implements Number {\n@@ -239,1 +239,1 @@\n-        public InlineType1(int i) {\n+        public ValueType1(int i) {\n@@ -247,1 +247,1 @@\n-    static primitive class InlineType2 implements Number {\n+    static primitive class ValueType2 implements Number {\n@@ -249,1 +249,1 @@\n-        public InlineType2(int i) {\n+        public ValueType2(int i) {\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":45,"deletions":45,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary test method handles with primitive narrowing\/widening conversion\n+ * @run testng\/othervm PrimitiveTypeConversionTest\n+ *\/\n+\n+import java.lang.invoke.*;\n+\n+import static java.lang.invoke.MethodType.*;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class PrimitiveTypeConversionTest {\n+    static primitive class Value {\n+        Point val;\n+        Point.ref ref;\n+        Value(Point p1, Point.ref p2) {\n+            this.val = p1;\n+            this.ref = p2;\n+        }\n+    }\n+\n+    static Value narrow(Value.ref v) {\n+        return v;\n+    }\n+\n+    static Value.ref widen(Value v) {\n+        if (((Object)v) == null) {\n+            throw new Error(\"should never reach here: should be caught by runtime\");\n+        }\n+        return null;\n+    }\n+\n+    static final Value VALUE = new Value(new Point(10,10), new Point(20, 20));\n+\n+    @Test\n+    public static void primitiveWidening() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh1 = lookup.findStatic(PrimitiveTypeConversionTest.class, \"narrow\", methodType(Value.class, Value.ref.class));\n+        MethodHandle mh2 = mh1.asType(methodType(Value.class, Value.class));\n+        Object v = mh1.invoke(VALUE);\n+        assertEquals(v, VALUE);\n+        try {\n+            Object v1 = mh1.invoke((Object)null);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {}\n+\n+        try {\n+            Object v2 = mh2.invoke((Object)null);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {}\n+    }\n+\n+    @Test\n+    public static void primitiveNarrowing() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh = lookup.findStatic(PrimitiveTypeConversionTest.class, \"widen\", methodType(Value.ref.class, Value.class));\n+        Object v = mh.invoke(VALUE);\n+        assertTrue(v == null);\n+        try {\n+            Object v1 = mh.invoke((Object)null);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {\n+            e.printStackTrace();\n+        }\n+        MethodHandle mh2 = mh.asType(methodType(Value.class, Value.ref.class));\n+        try {\n+            Value v2 = (Value) mh2.invoke((Value.ref)null);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Test\n+    public static void valToRef() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh1 = lookup.findGetter(Value.class, \"val\", Point.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.class));\n+        Value v = new Value(new Point(10,10), null);\n+\n+        Point p1 = (Point) mh1.invokeExact(VALUE);\n+        Point.ref p2 = (Point.ref) mh2.invokeExact(VALUE);\n+        assertEquals(p1, p2);\n+    }\n+\n+    @Test\n+    public static void refToVal() throws Throwable {\n+        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.class));\n+        Point.ref p1 = (Point.ref) mh1.invokeExact(VALUE);\n+        Point p2 = (Point) mh2.invokeExact(VALUE);\n+        assertEquals(p1, p2);\n+    }\n+\n+    @Test\n+    public static void valToRef1() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle mh1 = lookup.findGetter(Value.class, \"val\", Point.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.ref.class));\n+\n+        Point p1 = (Point) mh1.invokeExact(VALUE);\n+        Point p2 = (Point) mh2.invoke(VALUE);\n+        Point p3 = (Point) mh2.invokeExact((Value.ref)VALUE);\n+        assertEquals(p1, p2);\n+        assertEquals(p1, p3);\n+    }\n+\n+    @Test\n+    public static void refToVal1() throws Throwable {\n+        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.ref.class));\n+        Value v = new Value(new Point(10,10), null);\n+\n+        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n+        Point.ref p2 = (Point.ref) mh2.invoke(v);\n+        Point.ref p3 = (Point.ref) mh2.invokeExact((Value.ref)v);\n+        assertEquals(p1, p2);\n+        assertEquals(p1, p3);\n+    }\n+\n+    @Test\n+    public static void refToVal2() throws Throwable {\n+        MethodHandle mh1 = MethodHandles.lookup().findGetter(Value.class, \"ref\", Point.ref.class);\n+        MethodHandle mh2 = mh1.asType(methodType(Point.class, Value.class));\n+        Value v = new Value(new Point(10,10), null);\n+\n+        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n+        try {\n+            Point p2 = (Point) mh2.invokeExact(v);\n+            fail(\"Expected NullPointerException but not thrown\");\n+        } catch (NullPointerException e) {}\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/PrimitiveTypeConversionTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    public static void testLambda() {\n+    public void testLambda() {\n@@ -61,1 +61,1 @@\n-    public static void testMethodInvoke() throws Exception {\n+    public void testMethodInvoke() throws Exception {\n@@ -80,2 +80,2 @@\n-    public static void testStaticMethod() throws Throwable {\n-        \/\/ static method in an inline type with no parameter and void return type\n+    public void testStaticMethod() throws Throwable {\n+        \/\/ static method in a primitive class with no parameter and void return type\n@@ -99,1 +99,1 @@\n-    public static void testConstructor() throws Exception {\n+    public void testConstructor() throws Exception {\n@@ -108,1 +108,1 @@\n-    public static void testProxy() throws Exception {\n+    public void testProxy() throws Exception {\n@@ -140,1 +140,1 @@\n-    public static void testDescriptors(Class<?> defc, String name, Class<?>[] params, boolean found) throws Exception {\n+    public void testDescriptors(Class<?> defc, String name, Class<?>[] params, boolean found) throws Exception {\n@@ -142,3 +142,1 @@\n-            \/\/ TODO: methods are in the reference projection\n-            Class<?> declaringClass = defc \/* defc.referenceType().get() *\/;\n-            declaringClass.getDeclaredMethod(name, params);\n+            defc.getDeclaredMethod(name, params);\n@@ -155,12 +153,12 @@\n-            { \"point\",      MethodType.methodType(Point.ref.class),                                     true },\n-            { \"pointValue\", MethodType.methodType(Point.class),                                         true },\n-            { \"has\",        MethodType.methodType(boolean.class, Point.class, Point.ref.class),         true },\n-            { \"point\",      MethodType.methodType(Point.class),                                         false },\n-            { \"pointValue\", MethodType.methodType(Point.ref.class),                                     false },\n-            { \"has\",        MethodType.methodType(boolean.class, Point.ref.class, Point.class),         false },\n-            { \"point\",      MethodType.fromMethodDescriptorString(\"()LPoint$ref;\", loader),             true },\n-            { \"point\",      MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),                 false },\n-            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),                 true },\n-            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()LPoint$ref;\", loader),             false },\n-            { \"has\",        MethodType.fromMethodDescriptorString(\"(QPoint;LPoint$ref;)Z\", loader),     true },\n-            { \"has\",        MethodType.fromMethodDescriptorString(\"(LPoint$ref;LPoint$ref;)Z\", loader), false },\n+            { \"point\",      MethodType.methodType(Point.ref.class),                                      true },\n+            { \"pointValue\", MethodType.methodType(Point.class),                                          true },\n+            { \"has\",        MethodType.methodType(boolean.class, Point.class, Point.ref.class),          true },\n+            { \"point\",      MethodType.methodType(Point.class),                                          false },\n+            { \"pointValue\", MethodType.methodType(Point.ref.class),                                      false },\n+            { \"has\",        MethodType.methodType(boolean.class, Point.ref.class, Point.class),          false },\n+            { \"point\",      MethodType.fromMethodDescriptorString(\"()LPoint;\", loader),        true },\n+            { \"point\",      MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),        false },\n+            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),        true },\n+            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()LPoint;\", loader),        false },\n+            { \"has\",        MethodType.fromMethodDescriptorString(\"(QPoint;LPoint;)Z\", loader),true },\n+            { \"has\",        MethodType.fromMethodDescriptorString(\"(LPoint;LPoint;)Z\", loader),false },\n@@ -171,1 +169,1 @@\n-    public static void methodHandleLookup(String name, MethodType mtype, boolean found) throws Throwable {\n+    public void methodHandleLookup(String name, MethodType mtype, boolean found) throws Throwable {\n","filename":"test\/jdk\/valhalla\/valuetypes\/QTypeDescriptorTest.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test reflection on inline types\n+ * @summary test reflection on primitive classes\n@@ -33,1 +33,0 @@\n-import java.lang.reflect.Array;\n@@ -43,7 +42,0 @@\n-    @Test\n-    public static void sanityTest() {\n-        assertTrue(Point.ref.class.getPermittedSubclasses().length == 1);\n-        assertTrue(Line.ref.class.getPermittedSubclasses().length == 1);\n-        assertTrue(NonFlattenValue.ref.class.getPermittedSubclasses().length == 1);\n-    }\n-\n@@ -52,107 +44,2 @@\n-        Point o = Point.makePoint(10, 20);\n-        Reflection test = new Reflection(Point.class, \"Point\", o);\n-        test.newInstance();\n-        test.constructor();\n-        test.accessFieldX(o.x);\n-        test.checkStaticField(\"STATIC_FIELD\", Object.class);\n-        \/\/ TODO: static field is in the reference projection\n-        Class<?> declaringClass = Point.class;\n-        test.testSetAccessible(declaringClass.getDeclaredField(\"STATIC_FIELD\"));\n-    }\n-\n-    @Test\n-    public static void testLineClass() throws Exception {\n-        Line l = Line.makeLine(10, 20, 30, 40);\n-        Reflection test = new Reflection(Line.class, \"Line\", l);\n-        test.checkInstanceField(\"p1\", Point.class);\n-        test.checkInstanceField(\"p2\", Point.class);\n-        test.checkInstanceMethod(\"p1\", Point.class);\n-        test.checkInstanceMethod(\"p2\", Point.class);\n-    }\n-\n-    @Test\n-    public static void testNonFlattenValue() throws Exception {\n-        NonFlattenValue nfv = NonFlattenValue.make(10, 20);\n-        Reflection test = new Reflection(NonFlattenValue.class, \"NonFlattenValue\", nfv);\n-        test.checkInstanceField(\"nfp\", Point.ref.class);\n-        test.checkInstanceMethod(\"pointValue\", Point.class);\n-        test.checkInstanceMethod(\"point\", Point.ref.class);\n-        test.checkInstanceMethod(\"has\", boolean.class, Point.class, Point.ref.class);\n-    }\n-\n-    \/*\n-     * Tests reflection APIs with the value and reference projection type\n-     *\/\n-    @Test\n-    public static void testMirrors() throws Exception {\n-        Class<?> inlineClass = Point.class;\n-        assertTrue(inlineClass.isPrimitiveClass());\n-        assertFalse(Point.ref.class.isPrimitiveClass());\n-        assertEquals(inlineClass.valueType().get(), Point.class);\n-        assertEquals(inlineClass.referenceType().get(), Point.ref.class);\n-        assertEquals(Point.ref.class.valueType().get(), Point.class);\n-        assertEquals(Point.ref.class.referenceType().get(), Point.ref.class);\n-\n-        Point o = Point.makePoint(10, 20);\n-        assertTrue(Point.class.isInstance(o));\n-        assertTrue(Point.ref.class.isInstance(o));\n-\n-    }\n-\n-    @Test\n-    public static void testAssignableFrom() {\n-        \/\/ V <: V? and V <: Object\n-        assertTrue(Point.ref.class.isAssignableFrom(Point.class));\n-        assertTrue(Object.class.isAssignableFrom(Point.class));\n-        assertFalse(Point.class.isAssignableFrom(Point.ref.class));\n-        assertTrue(Object.class.isAssignableFrom(Point.ref.class));\n-\n-        assertEquals(Point.class, Point.class.asSubclass(Point.ref.class));\n-        try {\n-            Class<?> c = Point.ref.class.asSubclass(Point.class);\n-            assertTrue(false);\n-        } catch (ClassCastException e) { }\n-    }\n-\n-    @Test\n-    public static void testClassName() {\n-        assertEquals(Point.class.getName(), \"Point\");\n-        assertEquals(Point.ref.class.getName(), \"Point$ref\");\n-        assertEquals(Line.class.getName(), \"Line\");\n-        assertEquals((new Point[0]).getClass().getName(), \"[QPoint;\");\n-        assertEquals((new Point.ref[0][0]).getClass().getName(), \"[[LPoint$ref;\");\n-    }\n-\n-    private final Class<?> c;\n-    private final Constructor<?> ctor;\n-    private final Object o;\n-    Reflection() throws Exception {\n-        this.c = null;\n-        this.ctor = null;\n-        this.o = null;\n-    }\n-    Reflection(Class<?> type, String cn, Object o) throws Exception {\n-        this.c = Class.forName(cn);\n-        if (!c.isPrimitiveClass() || c != type) {\n-            throw new RuntimeException(cn + \" is not an inline class\");\n-        }\n-\n-        \/\/ V.class, Class.forName, and the type of the object return the primary mirror\n-        assertEquals(type, o.getClass());\n-        assertEquals(type, c.valueType().get());\n-        assertEquals(c, c.valueType().get());\n-\n-        this.ctor = c.getDeclaredConstructor();\n-        this.o = o;\n-\n-\n-        \/\/ test the primary mirror and secondary mirror\n-        testMirrors(this.c);\n-        \/\/ test array of Q-type and L-type\n-        testArray(c.valueType().get());\n-        testArray(c.referenceType().get());\n-    }\n-\n-    private static void testMirrors(Class<?> c) {\n-        Class<?> valType = c.valueType().get();\n-        Class<?> refType = c.referenceType().get();\n+        Object o = Point.class.newInstance();\n+        assertEquals(o.getClass(), Point.class.asPrimaryType());\n@@ -160,3 +47,3 @@\n-        assertTrue(valType != null);\n-        assertEquals(refType.getTypeName(), c.getTypeName() + \"$ref\");\n-        assertEquals(refType.getSimpleName(), c.getSimpleName() + \"$ref\");\n+        Constructor<?> ctor = Point.class.getDeclaredConstructor(int.class, int.class);\n+        o = ctor.newInstance(20, 30);\n+        assertEquals(o.getClass(), Point.class.asPrimaryType());\n@@ -164,21 +51,3 @@\n-        assertEquals(refType.getName(), valType.getName() + \"$ref\");\n-        assertEquals(refType.getTypeName(), valType.getTypeName() + \"$ref\");\n-        assertEquals(refType.getSimpleName(), valType.getSimpleName() + \"$ref\");\n-\n-        assertEquals(valType.referenceType().get(), refType);\n-        assertEquals(refType.valueType().get(), valType);\n-    }\n-\n-    void testArray(Class<?> elementType) {\n-        Object[] array = (Object[])Array.newInstance(elementType, 1);\n-        Class<?> arrayType = array.getClass();\n-        assertTrue(arrayType.isArray());\n-        Class<?> componentType = arrayType.getComponentType();\n-        assertTrue(componentType.isPrimitiveClass() || componentType.valueType().isPresent());\n-        assertEquals(componentType, elementType);\n-        \/\/ Array is a reference type\n-        assertEquals(arrayType.referenceType().get(), arrayType);\n-        if (array[0] == null) {\n-            System.out.println(\"array[0] = null\");\n-        } else {\n-            System.out.println(\"array[0] = \" + array[0]);\n+        Field field = Point.class.getField(\"x\");\n+        if (field.getInt(o) != 20) {\n+            fail(\"Unexpected Point.x value: \" +  field.getInt(o));\n@@ -186,8 +55,0 @@\n-    }\n-\n-    void accessFieldX(int x) throws Exception {\n-        Field field = c.getField(\"x\");\n-        if (field.getInt(o) != x) {\n-            throw new RuntimeException(\"Unexpected Point.x value: \" +  field.getInt(o));\n-        }\n-\n@@ -196,1 +57,1 @@\n-            throw new RuntimeException(\"IllegalAccessException not thrown\");\n+            fail(\"IllegalAccessException not thrown\");\n@@ -198,1 +59,0 @@\n-    }\n@@ -200,4 +60,7 @@\n-    @SuppressWarnings(\"deprecation\")\n-    void newInstance() throws Exception {\n-        Object o = c.newInstance();\n-        assertEquals(o.getClass(), c);\n+        \/\/ final static field in a primitive class\n+        Field f = Point.class.getDeclaredField(\"STATIC_FIELD\");\n+        assertTrue(f.getType() == Object.class);\n+        \/\/ accessible but no write access\n+        f.trySetAccessible();\n+        assertTrue(f.isAccessible());\n+        checkToString(f);\n@@ -206,3 +69,6 @@\n-    void constructor() throws Exception {\n-        Object o = ctor.newInstance();\n-        assertEquals(o.getClass(), c);\n+    @Test\n+    public static void testLineClass() throws Exception {\n+        checkInstanceField(Line.class, \"p1\", Point.class);\n+        checkInstanceField(Line.class, \"p2\", Point.class);\n+        checkInstanceMethod(Line.class, \"p1\", Point.class);\n+        checkInstanceMethod(Line.class, \"p2\", Point.class);\n@@ -211,3 +77,6 @@\n-    void testSetAccessible(Field f) throws Exception {\n-        f.trySetAccessible();\n-        assertTrue(f.isAccessible());\n+    @Test\n+    public static void testNonFlattenValue() throws Exception {\n+        checkInstanceField(NonFlattenValue.class, \"nfp\", Point.ref.class);\n+        checkInstanceMethod(NonFlattenValue.class, \"pointValue\", Point.class);\n+        checkInstanceMethod(NonFlattenValue.class, \"point\", Point.ref.class);\n+        checkInstanceMethod(NonFlattenValue.class, \"has\", boolean.class, Point.class, Point.ref.class);\n@@ -216,8 +85,0 @@\n-    \/*\n-     * Fields are in the value projection\n-     *\/\n-    void checkInstanceField(String name, Class<?> type) throws Exception {\n-        Field f = c.getDeclaredField(name);\n-        assertTrue(f.getType() == type);\n-        checkToString(f);\n-    }\n@@ -225,7 +86,1 @@\n-    \/*\n-     * Static members are in the reference projection\n-     *\/\n-    void checkStaticField(String name, Class<?> type) throws Exception {\n-        Class<?> declaringClass = c;\n-        \/\/ TODO: methods are in the reference projection\n-        \/\/ Class<?> declaringClass = c.referenceType().get();\n+    static void checkInstanceField(Class<?> declaringClass, String name, Class<?> type) throws Exception {\n@@ -237,7 +92,1 @@\n-    \/*\n-     * Methods are in the reference projection\n-     *\/\n-    void checkInstanceMethod(String name, Class<?> returnType, Class<?>... params) throws Exception {\n-        Class<?> declaringClass = c;\n-        \/\/ TODO: methods are in the reference projection\n-        \/\/ Class<?> declaringClass = c.referenceType().get();\n+    static void checkInstanceMethod(Class<?> declaringClass,String name, Class<?> returnType, Class<?>... params) throws Exception {\n@@ -249,1 +98,1 @@\n-    void checkToString(Field f) {\n+    static void checkToString(Field f) {\n@@ -261,7 +110,0 @@\n-        \/\/ instance fields are in the value projection\n-        \/\/ whereas static fields are in the reference projection\n-        Class<?> declaringClass = c;\n-        \/\/ TODO: static members are in the reference projection\n-        \/\/ if (Modifier.isStatic(mods)) {\n-        \/\/    declaringClass = c.referenceType().get();\n-        \/\/ }\n@@ -269,1 +111,1 @@\n-        sb.append(declaringClass.getName()).append(\".\").append(f.getName());\n+        sb.append(f.getDeclaringClass().getName()).append(\".\").append(f.getName());\n@@ -273,1 +115,1 @@\n-    void checkToString(Method m) {\n+    static void checkToString(Method m) {\n@@ -286,4 +128,1 @@\n-        \/\/ TODO: methods are in the reference projection\n-        \/\/ Class<?> declaringClass = c.referenceType().get();\n-        Class<?> declaringClass = c;\n-        sb.append(declaringClass.getName()).append(\".\").append(m.getName());\n+        sb.append(m.getDeclaringClass().getName()).append(\".\").append(m.getName());\n@@ -307,1 +146,1 @@\n-        return type.getName();\n+        return type.getTypeName();\n","filename":"test\/jdk\/valhalla\/valuetypes\/Reflection.java","additions":37,"deletions":198,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary No Serialization support of inline value classes, without a proxy\n+ * @summary No Serialization support of primitive classes, without a proxy\n@@ -74,1 +74,1 @@\n-    \/\/ inline class that DOES NOT implement Serializable should throw NSE\n+    \/\/ primitive class that DOES NOT implement Serializable should throw NSE\n@@ -126,1 +126,1 @@\n-    \/\/ inline class that DOES implement Serializable should throw NSE\n+    \/\/ primitive class that DOES implement Serializable should throw NSE\n@@ -178,1 +178,1 @@\n-    \/\/ inline classes that DO implement Serializable, but have a serial proxy\n+    \/\/ primitive classes that DO implement Serializable, but have a serial proxy\n@@ -237,2 +237,2 @@\n-    @DataProvider(name = \"inlineClasses\")\n-    public Object[][] inlineClasses() {\n+    @DataProvider(name = \"classes\")\n+    public Object[][] classes() {\n@@ -247,2 +247,2 @@\n-    \/\/ inline class read directly from a byte stream\n-    @Test(dataProvider = \"inlineClasses\")\n+    \/\/ primitive class read directly from a byte stream\n+    @Test(dataProvider = \"classes\")\n","filename":"test\/jdk\/valhalla\/valuetypes\/Serialization.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm StaticInitFactoryTest\n+ * @run main\/othervm StaticFactoryMethodHandleTest\n@@ -40,1 +40,1 @@\n-public class StaticInitFactoryTest {\n+public class StaticFactoryMethodHandleTest {\n@@ -118,1 +118,1 @@\n-        assertEquals(minfo.getDeclaringClass(), c);\n+        assertEquals(minfo.getDeclaringClass(), c.asPrimaryType());\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryMethodHandleTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/valhalla\/valuetypes\/StaticInitFactoryTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary Test reflection of constructors for primitive classes\n+ * @run testng\/othervm StaticFactoryTest\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class StaticFactoryTest {\n+    \/\/ Target test class\n+    static primitive class SimplePrimitive {\n+        public final int x;\n+\n+        SimplePrimitive() {\n+            x = -1;\n+        }\n+\n+        public SimplePrimitive(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static final Class<?> PRIMITIVE_TYPE = SimplePrimitive.class;\n+\n+    @Test\n+    public static void testPrimitiveClassConstructor() throws Exception {\n+        String cn = PRIMITIVE_TYPE.getName();\n+        Class<?> c = Class.forName(cn).asValueType();\n+\n+        assertTrue(c.isPrimitiveClass());\n+        assertTrue(c == PRIMITIVE_TYPE);\n+    }\n+\n+    @Test\n+    public static void constructor() throws Exception {\n+        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n+        Object o = ctor.newInstance();\n+        assertTrue(o.getClass() == PRIMITIVE_TYPE.asPrimaryType());\n+    }\n+\n+    \/\/ Check that the class has the expected Constructors\n+    @Test\n+    public static void constructors() throws Exception {\n+        Set<String> expectedSig = Set.of(\"public StaticFactoryTest$SimplePrimitive(int)\",\n+                                         \"StaticFactoryTest$SimplePrimitive()\");\n+        Constructor<? extends Object>[] cons = PRIMITIVE_TYPE.getDeclaredConstructors();\n+        Set<String> actualSig = Arrays.stream(cons).map(Constructor::toString)\n+                                      .collect(Collectors.toSet());\n+        boolean ok = expectedSig.equals(actualSig);\n+        if (!ok) {\n+            System.out.printf(\"expected: %s%n\", expectedSig);\n+            System.out.printf(\"declared: %s%n\", actualSig);\n+            assertTrue(ok);\n+        }\n+    }\n+\n+    \/\/ Check that the constructor and field can be set accessible\n+    @Test\n+    public static void setAccessible() throws Exception {\n+        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n+        ctor.setAccessible(true);\n+\n+        Field field = PRIMITIVE_TYPE.getField(\"x\");\n+        field.setAccessible(true);\n+    }\n+\n+    \/\/ Check that the constructor and field can be set accessible\n+    @Test\n+    public static void trySetAccessible() throws Exception {\n+        Constructor<?> ctor = PRIMITIVE_TYPE.getDeclaredConstructor();\n+        assertTrue(ctor.trySetAccessible());\n+\n+        Field field = PRIMITIVE_TYPE.getField(\"x\");\n+        assertTrue(field.trySetAccessible());\n+    }\n+\n+    \/\/ Check that the final field cannot be modified\n+    @Test(expectedExceptions = IllegalAccessException.class)\n+    public static void setFinalField() throws Exception {\n+        Field field = PRIMITIVE_TYPE.getField(\"x\");\n+        field.setAccessible(true);\n+        field.setInt(new SimplePrimitive(100), 200);\n+    }\n+\n+\n+    \/\/ Check that the class does not have a static method with the name <init>\n+    @Test\n+    public static void initFactoryNotMethods() {\n+        Method[] methods = PRIMITIVE_TYPE.getDeclaredMethods();\n+        for (Method m : methods) {\n+            if (Modifier.isStatic(m.getModifiers())) {\n+                assertFalse(m.getName().equals(\"<init>\"));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Basic test for Array::get, Array::set, Arrays::setAll on inline class array\n+ * @summary Basic test for Array::get, Array::set, Arrays::setAll on primitive class array\n@@ -56,1 +56,1 @@\n-    public void testInlineType() {\n+    public void testValueType() {\n","filename":"test\/jdk\/valhalla\/valuetypes\/StreamTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary test MethodHandle\/VarHandle on inline types\n+ * @summary test MethodHandle\/VarHandle on primitive classes\n@@ -182,1 +182,1 @@\n-     * non-null and of the same inline class.\n+     * non-null and of the same primitive class.\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @compile --enable-preview --source ${jdk.version} UninitializedInlineValueTest.java\n- * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=128 UninitializedInlineValueTest\n- * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=0 UninitializedInlineValueTest\n- * @summary Test reflection and method handle on accessing a field of inline type\n- *          that may be flattened or non-flattened\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class UninitializedInlineValueTest {\n-    static primitive class EmptyInline {\n-        public boolean isEmpty() {\n-            return true;\n-        }\n-    }\n-\n-    static primitive class InlineValue {\n-        Object o;\n-        EmptyInline empty;\n-        InlineValue() {\n-            this.o = null;\n-            this.empty = new EmptyInline();\n-        }\n-    }\n-\n-    static class MutableValue {\n-        Object o;\n-        EmptyInline empty;\n-        volatile EmptyInline vempty;\n-    }\n-\n-    @Test\n-    public void emptyInlineClass() throws ReflectiveOperationException {\n-        EmptyInline e = new EmptyInline();\n-        Field[] fields = e.getClass().getDeclaredFields();\n-        assertTrue(fields.length == 0);\n-    }\n-\n-    @Test\n-    public void testInlineValue() throws ReflectiveOperationException {\n-        InlineValue v = new InlineValue();\n-        Field f0 = v.getClass().getDeclaredField(\"o\");\n-        Object o = f0.get(v);\n-        assertTrue(o == null);\n-\n-        \/\/ field of inline type must be non-null\n-        Field f1 = v.getClass().getDeclaredField(\"empty\");\n-        assertTrue(f1.getType() == EmptyInline.class);\n-        EmptyInline empty = (EmptyInline)f1.get(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-    }\n-\n-    @Test\n-    public void testMutableValue() throws ReflectiveOperationException {\n-        MutableValue v = new MutableValue();\n-        Field f0 = v.getClass().getDeclaredField(\"o\");\n-        f0.set(v, null);\n-        assertTrue( f0.get(v) == null);\n-\n-        \/\/ field of inline type must be non-null\n-        Field f1 = v.getClass().getDeclaredField(\"empty\");\n-        assertTrue(f1.getType() == EmptyInline.class);\n-        EmptyInline empty = (EmptyInline)f1.get(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-\n-        Field f2 = v.getClass().getDeclaredField(\"vempty\");\n-        assertTrue(f2.getType() == EmptyInline.class);\n-        EmptyInline vempty = (EmptyInline)f2.get(v);\n-        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n-\n-        f1.set(v, new EmptyInline());\n-        assertTrue((EmptyInline)f1.get(v) == new EmptyInline());\n-        f2.set(v, new EmptyInline());\n-        assertTrue((EmptyInline)f2.get(v) == new EmptyInline());\n-    }\n-\n-    @Test\n-    public void testMethodHandleInlineValue() throws Throwable {\n-        InlineValue v = new InlineValue();\n-        MethodHandle mh = MethodHandles.lookup().findGetter(InlineValue.class, \"empty\", EmptyInline.class);\n-        EmptyInline empty = (EmptyInline) mh.invokeExact(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-    }\n-\n-    @Test\n-    public void testMethodHandleMutableValue() throws Throwable {\n-        MutableValue v = new MutableValue();\n-        MethodHandle getter = MethodHandles.lookup().findGetter(MutableValue.class, \"empty\", EmptyInline.class);\n-        EmptyInline empty = (EmptyInline) getter.invokeExact(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-\n-        MethodHandle getter1 = MethodHandles.lookup().findGetter(MutableValue.class, \"vempty\", EmptyInline.class);\n-        EmptyInline vempty = (EmptyInline) getter1.invokeExact(v);\n-        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n-\n-        MethodHandle setter = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyInline.class);\n-        setter.invokeExact(v, new EmptyInline());\n-        empty = (EmptyInline) getter.invokeExact(v);\n-        assertTrue(empty == new EmptyInline());\n-\n-        MethodHandle setter1 = MethodHandles.lookup().findSetter(MutableValue.class, \"vempty\", EmptyInline.class);\n-        setter1.invokeExact(v, new EmptyInline());\n-        vempty = (EmptyInline) getter1.invokeExact(v);\n-        assertTrue(vempty == new EmptyInline());\n-    }\n-\n-    @Test(expectedExceptions = { IllegalAccessException.class})\n-    public void noWriteAccess() throws ReflectiveOperationException {\n-        InlineValue v = new InlineValue();\n-        Field f = v.getClass().getDeclaredField(\"empty\");\n-        f.set(v, null);\n-    }\n-\n-    @Test(expectedExceptions = { NullPointerException.class})\n-    public void nonNullableField_reflection() throws ReflectiveOperationException {\n-        MutableValue v = new MutableValue();\n-        Field f = v.getClass().getDeclaredField(\"empty\");\n-        f.set(v, null);\n-    }\n-\n-    @Test(expectedExceptions = { NullPointerException.class})\n-    public void nonNullableField_MethodHandle() throws Throwable {\n-        MutableValue v = new MutableValue();\n-        MethodHandle mh = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyInline.class);\n-        EmptyInline.ref e = null;\n-        EmptyInline empty = (EmptyInline) mh.invokeExact(v, (EmptyInline)e);\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/UninitializedInlineValueTest.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @compile --enable-preview --source ${jdk.version} UninitializedValueTest.java\n+ * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=128 UninitializedValueTest\n+ * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=0 UninitializedValueTest\n+ * @summary Test reflection and method handle on accessing a field of a primitive class\n+ *          that may be flattened or non-flattened\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class UninitializedValueTest {\n+    static primitive class EmptyValue {\n+        public boolean isEmpty() {\n+            return true;\n+        }\n+    }\n+\n+    static primitive class Value {\n+        Object o;\n+        EmptyValue empty;\n+        Value() {\n+            this.o = null;\n+            this.empty = new EmptyValue();\n+        }\n+    }\n+\n+    static class MutableValue {\n+        Object o;\n+        EmptyValue empty;\n+        volatile EmptyValue vempty;\n+    }\n+\n+    @Test\n+    public void emptyValueClass() throws ReflectiveOperationException {\n+        EmptyValue e = new EmptyValue();\n+        Field[] fields = e.getClass().getDeclaredFields();\n+        assertTrue(fields.length == 0);\n+    }\n+\n+    @Test\n+    public void testValue() throws ReflectiveOperationException {\n+        Value v = new Value();\n+        Field f0 = v.getClass().getDeclaredField(\"o\");\n+        Object o = f0.get(v);\n+        assertTrue(o == null);\n+\n+        \/\/ field of primitive value type must be non-null\n+        Field f1 = v.getClass().getDeclaredField(\"empty\");\n+        assertTrue(f1.getType() == EmptyValue.class);\n+        EmptyValue empty = (EmptyValue)f1.get(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+    }\n+\n+    @Test\n+    public void testMutableValue() throws ReflectiveOperationException {\n+        MutableValue v = new MutableValue();\n+        Field f0 = v.getClass().getDeclaredField(\"o\");\n+        f0.set(v, null);\n+        assertTrue( f0.get(v) == null);\n+\n+        \/\/ field of primitive value type type must be non-null\n+        Field f1 = v.getClass().getDeclaredField(\"empty\");\n+        assertTrue(f1.getType() == EmptyValue.class);\n+        EmptyValue empty = (EmptyValue)f1.get(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+\n+        Field f2 = v.getClass().getDeclaredField(\"vempty\");\n+        assertTrue(f2.getType() == EmptyValue.class);\n+        EmptyValue vempty = (EmptyValue)f2.get(v);\n+        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n+\n+        f1.set(v, new EmptyValue());\n+        assertTrue((EmptyValue)f1.get(v) == new EmptyValue());\n+        f2.set(v, new EmptyValue());\n+        assertTrue((EmptyValue)f2.get(v) == new EmptyValue());\n+    }\n+\n+    @Test\n+    public void testMethodHandleValue() throws Throwable {\n+        Value v = new Value();\n+        MethodHandle mh = MethodHandles.lookup().findGetter(Value.class, \"empty\", EmptyValue.class);\n+        EmptyValue empty = (EmptyValue) mh.invokeExact(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+    }\n+\n+    @Test\n+    public void testMethodHandleMutableValue() throws Throwable {\n+        MutableValue v = new MutableValue();\n+        MethodHandle getter = MethodHandles.lookup().findGetter(MutableValue.class, \"empty\", EmptyValue.class);\n+        EmptyValue empty = (EmptyValue) getter.invokeExact(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+\n+        MethodHandle getter1 = MethodHandles.lookup().findGetter(MutableValue.class, \"vempty\", EmptyValue.class);\n+        EmptyValue vempty = (EmptyValue) getter1.invokeExact(v);\n+        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n+\n+        MethodHandle setter = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyValue.class);\n+        setter.invokeExact(v, new EmptyValue());\n+        empty = (EmptyValue) getter.invokeExact(v);\n+        assertTrue(empty == new EmptyValue());\n+\n+        MethodHandle setter1 = MethodHandles.lookup().findSetter(MutableValue.class, \"vempty\", EmptyValue.class);\n+        setter1.invokeExact(v, new EmptyValue());\n+        vempty = (EmptyValue) getter1.invokeExact(v);\n+        assertTrue(vempty == new EmptyValue());\n+    }\n+\n+    @Test(expectedExceptions = { IllegalAccessException.class})\n+    public void noWriteAccess() throws ReflectiveOperationException {\n+        Value v = new Value();\n+        Field f = v.getClass().getDeclaredField(\"empty\");\n+        f.set(v, null);\n+    }\n+\n+    @Test(expectedExceptions = { NullPointerException.class})\n+    public void nonNullableField_reflection() throws ReflectiveOperationException {\n+        MutableValue v = new MutableValue();\n+        Field f = v.getClass().getDeclaredField(\"empty\");\n+        f.set(v, null);\n+    }\n+\n+    @Test(expectedExceptions = { NullPointerException.class})\n+    public void nonNullableField_MethodHandle() throws Throwable {\n+        MutableValue v = new MutableValue();\n+        MethodHandle mh = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyValue.class);\n+        EmptyValue.ref e = null;\n+        EmptyValue empty = (EmptyValue) mh.invokeExact(v, (EmptyValue)e);\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/UninitializedValueTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Basic test for Array::get, Array::set, Arrays::setAll on inline class array\n+ * @summary Basic test for Array::get, Array::set, Arrays::setAll on primitive class array\n@@ -39,7 +39,6 @@\n-    private final Class<?> arrayClass;\n-    private final Class<?> componentType;\n-    private final Object[] array;\n-    ValueArray() {\n-        this.arrayClass = null;\n-        this.array = null;\n-        this.componentType = null;\n+    @DataProvider(name=\"elementTypes\")\n+    static Object[][] elementTypes() {\n+        return new Object[][]{\n+            new Object[] { Point.class, new Point(0,0) },\n+            new Object[] { Point.ref.class, null },\n+        };\n@@ -47,6 +46,21 @@\n-    ValueArray(Class<?> arrayClass, Object[] array) {\n-        this.arrayClass = arrayClass;\n-        this.array = array;\n-        this.componentType = arrayClass.getComponentType();\n-        assertTrue(arrayClass.isArray());\n-        assertTrue(array.getClass() == arrayClass);\n+    @Test(dataProvider=\"elementTypes\")\n+    public void testPrimitiveElementType(Class<?> elementType, Object defaultValue) {\n+        assertTrue(elementType.isPrimitiveClass());\n+        assertTrue(elementType.isPrimaryType() || defaultValue != null);\n+\n+        Object[] array = (Object[])Array.newInstance(elementType, 1);\n+        Class<?> arrayType = array.getClass();\n+        assertTrue(arrayType.componentType() == elementType);\n+        \/\/ Array is a reference type\n+        assertTrue(arrayType.isArray());\n+        assertTrue(arrayType.isPrimaryType());\n+        assertEquals(arrayType.asPrimaryType(), arrayType);\n+        assertTrue(array[0] == defaultValue);\n+\n+        \/\/ check the element type of multi-dimensional array\n+        Object[][] multiArray = (Object[][])Array.newInstance(elementType, 1, 2, 3);\n+        Class<?> c = multiArray.getClass();\n+        while (c.getComponentType() != null) {\n+            c = c.getComponentType();\n+        }\n+        assertTrue(c == elementType);\n@@ -55,3 +69,23 @@\n-    private static Class<?> nullablePointArrayClass() {\n-        Object a = new Point.ref[0];\n-        return a.getClass();\n+    @DataProvider(name=\"arrayTypes\")\n+    static Object[][] arrayTypes() {\n+        return new Object[][] {\n+            new Object[] { Object[].class,\n+                           new Object[] { new Object(), new Object()}},\n+            new Object[] { Point[].class,\n+                           new Point[] { Point.makePoint(1, 2),\n+                                         Point.makePoint(10, 20),\n+                                         Point.makePoint(100, 200)}},\n+            new Object[] { Point[][].class,\n+                           new Point[][] { new Point[] { Point.makePoint(1, 2),\n+                                                         Point.makePoint(10, 20)}}},\n+            new Object[] { Point.ref[].class,\n+                           new Point.ref[] { Point.makePoint(11, 22),\n+                                             Point.makePoint(110, 220),\n+                                             null }},\n+            new Object[] { NonFlattenValue[].class,\n+                           new NonFlattenValue[] { NonFlattenValue.make(1, 2),\n+                                                   NonFlattenValue.make(10, 20),\n+                                                   NonFlattenValue.make(100, 200)}},\n+            new Object[] { Point[].class,  new Point[0] },\n+            new Object[] { Point.ref[].class,  new Point.ref[0] },\n+        };\n@@ -60,4 +94,5 @@\n-    void run() {\n-        testClassName();\n-        testArrayElements();\n-\n+    @Test(dataProvider=\"arrayTypes\")\n+    public void testArrays(Class<?> arrayClass, Object[] array) {\n+        testClassName(arrayClass);\n+        testArrayElements(arrayClass, array);\n+        Class<?> componentType = arrayClass.componentType();\n@@ -65,3 +100,3 @@\n-            Object[] qArray = (Object[]) Array.newInstance(componentType, 0);\n-            Object[] lArray = (Object[]) Array.newInstance(componentType.referenceType().get(), 0);\n-            testInlineArrayCovariance(componentType, qArray, lArray);\n+            Object[] qArray = (Object[]) Array.newInstance(componentType.asValueType(), 0);\n+            Object[] lArray = (Object[]) Array.newInstance(componentType.asPrimaryType(), 0);\n+            testArrayCovariance(componentType, qArray, lArray);\n@@ -71,1 +106,4 @@\n-    void testClassName() {\n+    \/**\n+     * Verify the array class's name of the form \"[QPoint;\" or \"[LPoint;\"\n+     *\/\n+    static void testClassName(Class<?> arrayClass) {\n@@ -80,1 +118,1 @@\n-        sb.append(c.isPrimitiveClass() ? \"Q\" : \"L\").append(c.getName()).append(\";\");\n+        sb.append(c.isValueType() ? \"Q\" : \"L\").append(c.getName()).append(\";\");\n@@ -84,2 +122,7 @@\n-    void testArrayElements() {\n-        Object[] array = (Object[]) Array.newInstance(componentType, this.array.length);\n+    \/**\n+     * Setting the elements of an array.\n+     * NPE will be thrown if null is set on an element in an array of value type\n+     *\/\n+    static void testArrayElements(Class<?> arrayClass, Object[] array) {\n+        Class<?> componentType = arrayClass.getComponentType();\n+        assertTrue(arrayClass.isArray());\n@@ -87,1 +130,3 @@\n-        assertTrue(array.getClass().getComponentType() == componentType);\n+        Object[] newArray = (Object[]) Array.newInstance(componentType, array.length);\n+        assertTrue(newArray.getClass() == arrayClass);\n+        assertTrue(newArray.getClass().getComponentType() == componentType);\n@@ -90,2 +135,2 @@\n-        for (int i=0; i < this.array.length; i++) {\n-            Array.set(array, i, this.array[i]);\n+        for (int i = 0; i < array.length; i++) {\n+            Array.set(newArray, i, array[i]);\n@@ -93,3 +138,3 @@\n-        for (int i=0; i < this.array.length; i++) {\n-            Object o = Array.get(array, i);\n-            assertEquals(o, this.array[i]);\n+        for (int i = 0; i < array.length; i++) {\n+            Object o = Array.get(newArray, i);\n+            assertEquals(o, array[i]);\n@@ -97,1 +142,1 @@\n-        Arrays.setAll(array, i -> this.array[i]);\n+        Arrays.setAll(newArray, i -> array[i]);\n@@ -100,3 +145,3 @@\n-        if (!componentType.isPrimitiveClass()) {\n-            for (int i=0; i < array.length; i++) {\n-                Array.set(array, i, null);\n+        if (!componentType.isValueType()) {\n+            for (int i = 0; i < newArray.length; i++) {\n+                Array.set(newArray, i, null);\n@@ -105,1 +150,1 @@\n-            for (int i=0; i < array.length; i++) {\n+            for (int i = 0; i < newArray.length; i++) {\n@@ -107,3 +152,4 @@\n-                    Array.set(array, i, null);\n-                    assertFalse(true, \"expect NPE but not thrown\");\n-                } catch (NullPointerException e) { }\n+                    Array.set(newArray, i, null);\n+                    fail(\"expect NPE but not thrown\");\n+                } catch (NullPointerException e) {\n+                }\n@@ -114,1 +160,4 @@\n-    void testInlineArrayCovariance(Class<?> componentType, Object[] qArray, Object[] lArray) {\n+    \/**\n+     * Point[] is a subtype of Point.ref[], which is a subtype of Object[].\n+     *\/\n+    static void testArrayCovariance(Class<?> componentType, Object[] qArray, Object[] lArray) {\n@@ -121,4 +170,0 @@\n-        \/\/ Class.instanceof inline vs indirect\n-        assertFalse(qArray.getClass().isInstance(lArray));\n-        assertTrue(lArray.getClass().isInstance(qArray));\n-\n@@ -129,1 +174,5 @@\n-        \/\/ Class.isAssignableFrom inline vs indirect\n+        \/\/ V.val[] is a subtype of V.ref[]\n+        assertFalse(qArray.getClass().isInstance(lArray));\n+        assertTrue(lArray.getClass().isInstance(qArray));\n+\n+        \/\/ V.val[] is a subtype of V.ref[]\n@@ -137,1 +186,1 @@\n-        \/\/ Class.cast inline vs indirect\n+        \/\/ Class.cast\n@@ -141,32 +190,3 @@\n-            assertFalse(true, \"cast of Point? to Point should not succeed\");\n-        } catch (ClassCastException cce) { }\n-    }\n-\n-\n-    @DataProvider(name=\"arrayTypes\")\n-    static Object[][] arrayTypes() {\n-        return new Object[][] {\n-            new Object[] { Object[].class,\n-                           new Object[] { new Object(), new Object()}},\n-            new Object[] { Point[].class,\n-                           new Point[] { Point.makePoint(1, 2),\n-                                         Point.makePoint(10, 20),\n-                                         Point.makePoint(100, 200)}},\n-            new Object[] { Point[][].class,\n-                           new Point[][] { new Point[] { Point.makePoint(1, 2),\n-                                                         Point.makePoint(10, 20)}}},\n-            new Object[] { nullablePointArrayClass(),\n-                           new Point.ref[] { Point.makePoint(11, 22),\n-                                          Point.makePoint(110, 220),\n-                                          null }},\n-            new Object[] { NonFlattenValue[].class,\n-                           new NonFlattenValue[] { NonFlattenValue.make(1, 2),\n-                                                   NonFlattenValue.make(10, 20),\n-                                                   NonFlattenValue.make(100, 200)}},\n-        };\n-    }\n-\n-    @Test(dataProvider=\"arrayTypes\")\n-    public static void test(Class<?> arrayClass, Object[] array) {\n-        ValueArray test = new ValueArray(arrayClass, array);\n-        test.run();\n+            fail(\"cast of Point.ref[] to Point[] should not succeed\");\n+        } catch (ClassCastException cce) {\n+        }\n@@ -194,1 +214,1 @@\n-            throw new AssertionError(\"IAE not thrown\");\n+            fail(\"IAE not thrown\");\n@@ -199,1 +219,1 @@\n-            throw new AssertionError(\"IAE not thrown\");\n+            fail(\"IAE not thrown\");\n@@ -209,6 +229,0 @@\n-        ValueArray test = new ValueArray(Point[].class, qArray);\n-        test.run();\n-\n-        ValueArray test1 = new ValueArray(Point.ref[].class, lArray);\n-        test.run();\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueArray.java","additions":104,"deletions":90,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,0 @@\n-        Method toString = test.getMethod(\"toString\", valueClass);\n-        String s = (String)toString.invoke(null, value);\n-        assertEquals(s, value.localToString());\n-        assertEquals(s, value.toString());\n-\n@@ -94,6 +89,0 @@\n-\n-        public String localToString() {\n-            System.out.println(l);\n-            return String.format(\"[%s i=%s d=%s s=%s l=%s]\", Value.class.getName(),\n-                                 i, String.valueOf(d), s, l.toString());\n-        }\n@@ -168,15 +157,0 @@\n-        mv = cw.visitMethod(\n-            ACC_PUBLIC + ACC_STATIC + ACC_FINAL,\n-            \"toString\",\n-            Type.getMethodDescriptor(Type.getType(String.class), type),\n-            null,\n-            null);\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInvokeDynamicInsn(\"toString\",\n-            Type.getMethodDescriptor(Type.getType(String.class), type),\n-            bootstrap,  type);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueBootstrapMethods.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n- * @summary Test inline classes with Reference types\n- * @run testng\/othervm InlineReferenceTest\n+ * @summary Test primitive classes with Reference types\n+ * @run testng\/othervm WeakReferenceTest\n@@ -38,1 +38,1 @@\n-public class InlineReferenceTest {\n+public class WeakReferenceTest {\n","filename":"test\/jdk\/valhalla\/valuetypes\/WeakReferenceTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/valhalla\/valuetypes\/InlineReferenceTest.java","status":"renamed"},{"patch":"@@ -41,1 +41,1 @@\n-        if (!o.toString().equals(\"[AnonymousValueType$1 x=10]\"))\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AnonymousValueType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,4 +56,4 @@\n-        \"         6: anewarray     #3                  \/\/ class ArrayCreationWithQuestion$VT$ref\",\n-        \"        17: anewarray     #3                  \/\/ class ArrayCreationWithQuestion$VT$ref\",\n-        \"        28: anewarray     #12                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n-        \"        39: anewarray     #12                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n+        \"         6: anewarray     #3                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        \"        17: anewarray     #3                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        \"        28: anewarray     #11                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n+        \"        39: anewarray     #11                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ArrayCreationWithQuestion.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        ClassFile cls = ClassFile.read(AttributesTest.class.getResourceAsStream(\"AttributesTest$1V$ref.class\"));\n+        ClassFile cls = ClassFile.read(AttributesTest.class.getResourceAsStream(\"AttributesTest$1V.class\"));\n@@ -56,1 +56,1 @@\n-        if (inners.number_of_classes != 2) {\n+        if (inners.number_of_classes != 1) {\n@@ -63,4 +63,0 @@\n-        name = inners.classes[1].getInnerName(cls.constant_pool);\n-        if (!name.equals(\"V$ref\")) {\n-            throw new AssertionError(\"Unexpected inner class \" + name);\n-        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AttributesTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        if (splits.length != 4) {\n+        if (splits.length != 9) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/BoxValCastTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        if (!p.toString().equals(\"[ChainedAssignmentTest$Point x=1234 y=1234]\"))\n+        if (p.x != 1234 || p.y != 1234)\n@@ -54,1 +54,1 @@\n-        if (!lp.toString().equals(\"[ChainedAssignmentTest$LongPoint x=1234 y=1234]\"))\n+        if (lp.x != 1234 || lp.y != 1234)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ChainedAssignmentTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors$ref;\"))\n+                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors;\"))\n@@ -57,1 +57,1 @@\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors$ref;\"))\n+                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors;\"))\n@@ -61,1 +61,1 @@\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors$ref;\"))\n+                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors;\"))\n@@ -65,1 +65,1 @@\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors$ref;\"))\n+                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors;\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckFieldDescriptors.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8267542\n- * @summary Verify that necessary checkcasts are generated while acessing an instance\n- *          field\/method through a reference projection.\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile CheckNeededCastInMemberAccess.java\n- * @run main CheckNeededCastInMemberAccess\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Code_attribute.InvalidIndex;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import java.util.Arrays;\n-import java.util.stream.Collectors;\n-import java.util.stream.StreamSupport;\n-\n-public class CheckNeededCastInMemberAccess {\n-\n-    static primitive class Point {\n-        int x = 0, y = 0;\n-        void foo() {\n-            Point p0 = new Point();\n-            int x0 = p0.x;\n-            p0.foo();\n-            Point.ref p1 = null;\n-            int x1 = p1.x;\n-            p1.foo();\n-        }\n-    }\n-\n-    public static void main(String[] args)\n-            throws IOException, ConstantPoolException, InvalidDescriptor, InvalidIndex {\n-        new CheckNeededCastInMemberAccess()\n-                .checkClassFile(new File(System.getProperty(\"test.classes\", \".\"),\n-                    CheckNeededCastInMemberAccess.Point.class.getName() + \".class\"));\n-    }\n-\n-    void checkClassFile(File file)\n-            throws IOException, ConstantPoolException, InvalidDescriptor, InvalidIndex {\n-        ClassFile classFile = ClassFile.read(file);\n-        ConstantPool constantPool = classFile.constant_pool;\n-\n-        Method method = Arrays.stream(classFile.methods)\n-                              .filter(m -> getName(m, constantPool)\n-                                               .equals(\"foo\"))\n-                              .findAny()\n-                              .get();\n-        String expectedInstructions = \"\"\"\n-                                    invokestatic\n-                                    astore_1\n-                                    aload_1\n-                                    getfield\n-                                    istore_2\n-                                    aload_1\n-                                    invokevirtual\n-                                    aconst_null\n-                                    astore_3\n-                                    aload_3\n-                                    checkcast\n-                                    getfield\n-                                    istore\n-                                    aload_3\n-                                    checkcast\n-                                    invokevirtual\n-                                    return\n-                                      \"\"\";\n-        Code_attribute code = (Code_attribute) method.attributes\n-                .get(Attribute.Code);\n-        String actualInstructions = printCode(code);\n-        if (!expectedInstructions.equals(actualInstructions)) {\n-            throw new AssertionError(\"Unexpected instructions found:\\n\" +\n-                                     actualInstructions);\n-        }\n-    }\n-\n-    String printCode(Code_attribute code) {\n-        return StreamSupport.stream(code.getInstructions().spliterator(), false)\n-                            .map(Instruction::getMnemonic)\n-                            .collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n-    }\n-\n-    String getName(Method m, ConstantPool constantPool) {\n-        try {\n-            return m.getName(constantPool);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckNeededCastInMemberAccess.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -33,5 +33,4 @@\n-\tpublic static void main(String[] args) {\n-\t\tString s = new CheckSeparateCompile0().new O().new M().new I().foo();\n-        if (!s.equals(\"[CheckSeparateCompile0$O$M$I i=0]\"))\n-            throw new AssertionError(s);\n-\t}\n+    public static void main(String[] args) {\n+        if (new CheckSeparateCompile0().new O().new M().new I().foo().i != 890)\n+            throw new AssertionError(\"Broken\");\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckSeparateCompile.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-                int i = 0;\n+                int i = 890;\n@@ -39,2 +39,2 @@\n-                String foo() {\n-                    return this.toString();\n+                I foo() {\n+                    return this;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckSeparateCompile0.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDunifiedValRefClass -XDallowWithFieldOperator Point.java Rectangle.java\n+ * @compile -XDallowWithFieldOperator Point.java Rectangle.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ConsumeUnifiedClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-        String o = new CtorChain().toString();\n-        if (!o.equals(\"[CtorChain x1=10 x2=20 x3=30 x4=40 x5=50]\"))\n+        CtorChain cc = new CtorChain();\n+        if (cc.x1 != 10 || cc.x2 != 20 || cc.x3 != 30 || cc.x4 != 40 || cc.x5 != 50)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CtorChain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-        if (!new InlineClassTest().toString().equals(\"[InlineClassTest x=42]\"))\n+        if (new InlineClassTest().x != 42)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InlineClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        if (!toString.equals(\"[InlineDiamondTest$Y x=42]\"))\n+        if (!toString.equals(\"InlineDiamondTest$Y@\" + Integer.toHexString(is.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InlineDiamondTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test nest host - member attributes\n- * @bug 8244314\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -XDallowWithFieldOperator Point.java\n- * @run main InlineNestingAttributesTest\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-public class InlineNestingAttributesTest {\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(InlineNestingAttributesTest.class.getResourceAsStream(\"Point.class\"));\n-        ClassFile clsProj = ClassFile.read(InlineNestingAttributesTest.class.getResourceAsStream(\"Point$ref.class\"));\n-\n-        NestMembers_attribute nestMembers = (NestMembers_attribute)clsProj.attributes.get(Attribute.NestMembers);\n-        CONSTANT_Class_info[] members = nestMembers != null ? nestMembers.getChildren(clsProj.constant_pool) : new CONSTANT_Class_info[0];\n-\n-        if (members.length != 1 || !members[0].getName().equals(\"Point\")) {\n-            throw new RuntimeException(\"Nest members not present\");\n-        }\n-\n-        NestHost_attribute nestHost = (NestHost_attribute)cls.attributes.get(Attribute.NestHost);\n-        CONSTANT_Class_info host = nestHost != null ? nestHost.getNestTop(cls.constant_pool) : null;\n-\n-        if (host == null || !host.getName().equals(\"Point$ref\")) {\n-            throw new RuntimeException(\"Nest host not present\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InlineNestingAttributesTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -46,1 +46,1 @@\n-        if (!i.toString().equals(\"[LubWithInlines$XNodeWrapper i=42]\"))\n+        if (!i.toString().equals(\"LubWithInlines$XNodeWrapper@\" + Integer.toHexString(i.hashCode())))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/LubWithInlines.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @compile -XDunifiedValRefClass NoUnnecessaryCast.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/NoUnnecessaryCast.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        \"         3: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT$ref;\\\"\",\n+        \"         3: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT;\\\"\",\n@@ -61,1 +61,1 @@\n-        \"        19: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT$ref;\\\"\",\n+        \"        19: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT;\\\"\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ProjectedArrayDotClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check to see if the reference projection is a sealed class\n- * @bug 8244315\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -XDallowWithFieldOperator Point.java\n- * @run main ProjectionSealed\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-public class ProjectionSealed {\n-    public static void main(String[] args) throws Exception {\n-        ClassFile clsProj = ClassFile.read(ProjectionSealed.class.getResourceAsStream(\"Point$ref.class\"));\n-\n-        PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute)clsProj.attributes.get(Attribute.PermittedSubclasses);\n-        CONSTANT_Class_info[] infos = permitted != null ? permitted.getSubtypes(clsProj.constant_pool) : new CONSTANT_Class_info[0];\n-\n-        if (infos.length != 1 || !infos[0].getName().equals(\"Point\")) {\n-            throw new RuntimeException(\"Sealed classes not present\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ProjectionSealed.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-        String aDotThis;\n+        A aDotThis;\n@@ -36,1 +36,1 @@\n-            aDotThis = A.this.toString();\n+            aDotThis = A.this;\n@@ -39,1 +39,1 @@\n-        String getADotThis() {\n+        A getADotThis() {\n@@ -51,1 +51,1 @@\n-        if (!new QualifiedSuperCtor(new A()).getADotThis().equals(\"[A x=1000000]\"))\n+        if (new QualifiedSuperCtor(new A()).getADotThis().x !=1000000)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/QualifiedSuperCtor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        if (!tName.equals(\"RefDotClass$ref\"))\n+        if (!tName.equals(\"RefDotClass.ref\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDotClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        if (!v.toString().equals(\"[SideEffectTest$V x=1234]\"))\n+        if (v.x != 1234)\n@@ -63,1 +63,1 @@\n-        if (!v.toString().equals(\"[SideEffectTest$V x=8765]\"))\n+        if (v.x != 8765)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SideEffectTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        ClassFile cls = ClassFile.read(SignatureTest.class.getResourceAsStream(\"SignatureTest$ref.class\"));\n+        ClassFile cls = ClassFile.read(SignatureTest.class.getResourceAsStream(\"SignatureTest.class\"));\n@@ -43,6 +43,0 @@\n-\n-        cls = ClassFile.read(SignatureTest.class.getResourceAsStream(\"SignatureTest.class\"));\n-        signature = (Signature_attribute) cls.attributes.get(Attribute.Signature);\n-        s = signature.getSignature(cls.constant_pool);\n-        if (!s.equals(\"<T:Ljava\/lang\/Object;>LSignatureTest$ref<TT;>;\"))\n-            throw new AssertionError(\"Unexpected signature: \" + s);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SignatureTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8265423\n- * @summary Experimental support for generating a single class file per primitive class\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile SplitPrimitiveClassBytecodeTest.java\n- * @run main SplitPrimitiveClassBytecodeTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class SplitPrimitiveClassBytecodeTest {\n-\n-    public primitive class X {\n-\n-        X.ref xr = null;\n-\n-        public void foo(X.ref[] xra, X[] xa) {\n-            xa = new X[10];\n-            xra = new X.ref[10];\n-            xra[0] = xa[0];\n-            xa[1] = xra[0];\n-            Class<?> c = X.class;\n-            c = X.ref.class;\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new SplitPrimitiveClassBytecodeTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"SplitPrimitiveClassBytecodeTest$X.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-        \/\/ check field\n-        \"final SplitPrimitiveClassBytecodeTest$X$ref xr;\",\n-        \"descriptor: LSplitPrimitiveClassBytecodeTest$X$ref;\",\n-        \"flags: (0x0010) ACC_FINAL\",\n-\n-        \/\/ check method\n-        \"public void foo(SplitPrimitiveClassBytecodeTest$X$ref[], SplitPrimitiveClassBytecodeTest$X[]);\",\n-        \"descriptor: ([LSplitPrimitiveClassBytecodeTest$X$ref;[QSplitPrimitiveClassBytecodeTest$X;)V\",\n-        \" 0: bipush        10\",\n-        \" 2: anewarray     #11                 \/\/ class \\\"QSplitPrimitiveClassBytecodeTest$X;\\\"\",\n-        \" 5: astore_2\",\n-        \" 6: bipush        10\",\n-        \" 8: anewarray     #13                 \/\/ class SplitPrimitiveClassBytecodeTest$X$ref\",\n-        \"11: astore_1\",\n-        \"12: aload_1\",\n-        \"13: iconst_0\",\n-        \"14: aload_2\",\n-        \"15: iconst_0\",\n-        \"16: aaload\",\n-        \"17: aastore\",\n-        \"18: aload_2\",\n-        \"19: iconst_1\",\n-        \"20: aload_1\",\n-        \"21: iconst_0\",\n-        \"22: aaload\",\n-        \"23: checkcast     #11                 \/\/ class \\\"QSplitPrimitiveClassBytecodeTest$X;\\\"\",\n-        \"26: aastore\",\n-        \"27: ldc           #1                  \/\/ class SplitPrimitiveClassBytecodeTest$X\",\n-        \"29: astore_3\",\n-        \"30: ldc           #13                 \/\/ class SplitPrimitiveClassBytecodeTest$X$ref\",\n-        \"32: astore_3\",\n-        \"33: return\",\n-         });\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassBytecodeTest.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8265423\n- * @summary Experimental support for generating a single class file per primitive class\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @run main SplitPrimitiveClassInnerClassesTest\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-public class SplitPrimitiveClassInnerClassesTest {\n-\n-    primitive class V<T> implements java.io.Serializable {}\n-\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(SplitPrimitiveClassInnerClassesTest.class.getResourceAsStream(\"SplitPrimitiveClassInnerClassesTest.class\"));\n-\n-        if (cls == null) {\n-            throw new AssertionError(\"Could not locate the class files\");\n-        }\n-\n-        \/* Check emission of inner class attribute *\/\n-        InnerClasses_attribute inners = (InnerClasses_attribute) cls.attributes.get(Attribute.InnerClasses);\n-        if (inners == null) {\n-            throw new AssertionError(\"Missing inner class attribute\");\n-        }\n-        boolean foundV = false, foundVref = false;\n-        for (int i = 0; i < inners.number_of_classes; i++) {\n-            String name = inners.classes[i].getInnerName(cls.constant_pool);\n-            if (name.equals(\"V\"))\n-                foundV = true;\n-            else if (name.equals(\"V$ref\"))\n-                foundVref = true;\n-        }\n-        if (!foundV || !foundVref) {\n-            throw new AssertionError(\"Incorrect inner class attribute\");\n-        }\n-\n-        \/\/ Test signature attribute\n-        cls = ClassFile.read(SplitPrimitiveClassInnerClassesTest.class.getResourceAsStream(\"SplitPrimitiveClassInnerClassesTest$V.class\"));\n-        Signature_attribute signature = (Signature_attribute)cls.attributes.get(Attribute.Signature);\n-        String sign =  signature.getSignature(cls.constant_pool);\n-        if (sign == null || !sign.equals(\"<T:Ljava\/lang\/Object;>LSplitPrimitiveClassInnerClassesTest$V$ref<TT;>;\")) {\n-            throw new RuntimeException(\"Wrong signature \" + sign);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassInnerClassesTest.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8265423\n- * @summary Experimental support for generating a single class file per primitive class\n- * @compile SplitPrimitiveClassNestHostTest.java\n- * @run main SplitPrimitiveClassNestHostTest\n- *\/\n-\n-import java.util.Arrays;\n-\n-public primitive class SplitPrimitiveClassNestHostTest implements java.io.Serializable {\n-\n-    primitive class Inner {}\n-\n-    public static void main(String [] args) {\n-\n-        \/\/ check wiring of super types.\n-        Class<?> superClass = SplitPrimitiveClassNestHostTest.class.getSuperclass();\n-        if (!superClass.equals(\n-                    SplitPrimitiveClassNestHostTest.class.referenceType().get()))\n-            throw new AssertionError(\"Wrong superclass for SplitPrimitiveClassNestHostTest\");\n-\n-        Class<?> [] superInterfaces = SplitPrimitiveClassNestHostTest.class.getInterfaces();\n-        if (superInterfaces.length != 1)\n-            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest\");\n-\n-        if (!superInterfaces[0].equals(PrimitiveObject.class))\n-            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest\");\n-\n-        \/\/ check super types of ref.class\n-        if (!superClass.getSuperclass().equals(Object.class))\n-            throw new AssertionError(\"Wrong superclass for SplitPrimitiveClassNestHostTest.ref\");\n-        superInterfaces = superClass.getInterfaces();\n-        if (superInterfaces.length != 1)\n-            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest.ref\");\n-\n-        if (!superInterfaces[0].equals(java.io.Serializable.class))\n-            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest.ref\");\n-\n-\n-        Class<?> nestHost = SplitPrimitiveClassNestHostTest.class.getNestHost();\n-        if (!nestHost.equals(SplitPrimitiveClassNestHostTest.class.referenceType().get()))\n-            throw new AssertionError(\"Wrong nest host: \" + nestHost);\n-\n-        Class<?> [] members = nestHost.getNestMembers();\n-        if (members.length != 4)\n-            throw new AssertionError(\"Wrong member count: \" + members.length);\n-\n-        if (!members[0].equals(nestHost))\n-            throw new AssertionError(\"Wrong initial member: \" + members[0]);\n-\n-        if (!members[1].equals(SplitPrimitiveClassNestHostTest.class))\n-            throw new AssertionError(\"Wrong member[1]: \" + members[1]);\n-\n-        if (!members[1].getNestHost().equals(nestHost))\n-            throw new AssertionError(\"Wrong nest host for member[1]: \" + members[1]);\n-\n-        if (!Arrays.equals(members[1].getNestMembers(), members))\n-            throw new AssertionError(\"Wrong nest members for member[1]: \" + members[1]);\n-\n-        if (!members[2].equals(Inner.class))\n-            throw new AssertionError(\"Wrong member[2]: \" + members[2]);\n-\n-        if (!members[2].getNestHost().equals(nestHost))\n-            throw new AssertionError(\"Wrong nest host for member[2]: \" + members[2]);\n-\n-        if (!Arrays.equals(members[2].getNestMembers(), members))\n-            throw new AssertionError(\"Wrong nest members for member[2]: \" + members[2]);\n-\n-        if (!members[3].equals(Inner.class.referenceType().get()))\n-            throw new AssertionError(\"Wrong member[3]: \" + members[3]);\n-\n-        if (!members[3].getNestHost().equals(nestHost))\n-            throw new AssertionError(\"Wrong nest host for member[3]: \" + members[3]);\n-\n-        if (!Arrays.equals(members[3].getNestMembers(), members))\n-            throw new AssertionError(\"Wrong nest members for member[3]: \" + members[3]);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassNestHostTest.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -45,1 +45,1 @@\n-        if (!testValue1.toString().equals(\"[TestValue1 x=42]\"))\n+        if (testValue1.x != 42)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TestQualifierOnInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,11 +55,2 @@\n-\n-\n-\n-\n-        \/\/ Check that V's super class is V.ref in class file.\n-        Class<?> vrefCls = inln_o.getClass().getSuperclass();\n-        if (!vrefCls.getCanonicalName().equals(\"TopInterfaceTest.V$ref\"))\n-            throw new AssertionError(\"Wrong super type for value type\");\n-\n-        \/\/ Check that no injection has happened for jlO itself.\n-        Class<?> jlo = vrefCls.getSuperclass();\n+        \/\/ Check that V's super class is Object in class file.\n+        Class<?> jlo = inln_o.getClass().getSuperclass();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TopInterfaceTest.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary V.ref class should not inadvertently carry over attributes from V.class\n+ * @summary Verify that primitive class declarations can be annotated\n@@ -104,27 +104,0 @@\n-\n-        \/\/ Verify that annotations are not carried over to the reference projection\n-        cls = ClassFile.read(UnannotatedProjection.class.getResourceAsStream(\"UnannotatedProjection$V$ref.class\"));\n-\n-        if (cls == null) {\n-            throw new AssertionError(\"Could not locate the class files\");\n-        }\n-\n-        inv = (RuntimeInvisibleAnnotations_attribute) cls.attributes.get(Attribute.RuntimeInvisibleAnnotations);\n-        if (inv != null) {\n-            throw new AssertionError(\"Annotations carried over to projection!\");\n-        }\n-\n-        invta = (RuntimeInvisibleTypeAnnotations_attribute) cls.attributes.get(Attribute.RuntimeInvisibleTypeAnnotations);\n-        if (invta != null) {\n-            throw new AssertionError(\"Annotations carried over to projection!\");\n-        }\n-\n-        v = (RuntimeVisibleAnnotations_attribute) cls.attributes.get(Attribute.RuntimeVisibleAnnotations);\n-        if (v != null) {\n-            throw new AssertionError(\"Annotations carried over to projection!\");\n-        }\n-\n-        vta = (RuntimeVisibleTypeAnnotations_attribute) cls.attributes.get(Attribute.RuntimeVisibleTypeAnnotations);\n-        if (vta != null) {\n-            throw new AssertionError(\"Annotations carried over to projection!\");\n-        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnannotatedProjection.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @compile -XDunifiedValRefClass UnifiedPrimitiveClassBytecodeTest.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassBytecodeTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- * @compile -XDunifiedValRefClass UnifiedPrimitiveClassInnerClassesTest.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassInnerClassesTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @compile -XDunifiedValRefClass UnifiedPrimitiveClassNestHostTest.java\n@@ -69,1 +68,1 @@\n-        if (!members[1].equals(Inner.class))\n+        if (!members[1].equals(Inner.class.asPrimaryType()))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassNestHostTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-            return String.format(\"[%s i=%s d=%s s=%s l=%s]\", Value.class.getName(),\n-                                 i, String.valueOf(d), s, l.toString());\n+            return String.format(\"%s@%s\", Value.class.getName(), Integer.toHexString(localHashCode()));\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ValueBootstrapMethodsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        if (!x.toString().equals(\"[ValueConstructorRef x=1234 y=5678]\"))\n+        if (x.x != 1234 || x.y != 5678)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ValueConstructorRef.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-        if (!v.toString().equals(\"[WithFieldAccessorTest$V i=20]\"))\n-            throw new AssertionError(\"Withfield didn't work!\" + v.toString());\n+        if (v.i != 20)\n+            throw new AssertionError(\"Withfield didn't work!\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/WithFieldAccessorTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-     if (!w.toString().equals(\"[WithFieldOfGenericType value=true]\"))\n+     if (w.value != true)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/WithFieldOfGenericType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}