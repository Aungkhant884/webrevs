{"files":[{"patch":"@@ -3826,0 +3826,2 @@\n+  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+\n@@ -3827,1 +3829,1 @@\n-  \/\/ so using rcpool to meet shared code expectations\n+  __ lea(c_rarg1, Address(c_rarg1, in_bytes(cp_base_offset)));\n@@ -3829,1 +3831,4 @@\n-  call_VM(r1, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), rcpool);\n+  __ lea(c_rarg2, at_tos());\n+  call_VM(r1, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), c_rarg1, c_rarg2);\n+  \/\/ new value type is returned in r1\n+  \/\/ stack adjustment is returned in r0\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3191,1 +3191,1 @@\n-  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield2), cpentry, rax);\n+  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cpentry, rax);\n@@ -3193,1 +3193,1 @@\n-  \/\/ stack adjustement is returned in rax\n+  \/\/ stack adjustment is returned in rax\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -257,36 +257,0 @@\n-void copy_primitive_argument(intptr_t* addr, Handle instance, int offset, BasicType type) {\n-  switch (type) {\n-  case T_BOOLEAN:\n-    instance()->bool_field_put(offset, (jboolean)*((int*)addr));\n-    break;\n-  case T_CHAR:\n-    instance()->char_field_put(offset, (jchar) *((int*)addr));\n-    break;\n-  case T_FLOAT:\n-    instance()->float_field_put(offset, (jfloat)*((float*)addr));\n-    break;\n-  case T_DOUBLE:\n-    instance()->double_field_put(offset, (jdouble)*((double*)addr));\n-    break;\n-  case T_BYTE:\n-    instance()->byte_field_put(offset, (jbyte)*((int*)addr));\n-    break;\n-  case T_SHORT:\n-    instance()->short_field_put(offset, (jshort)*((int*)addr));\n-    break;\n-  case T_INT:\n-    instance()->int_field_put(offset, (jint)*((int*)addr));\n-    break;\n-  case T_LONG:\n-    instance()->long_field_put(offset, (jlong)*((long long*)addr));\n-    break;\n-  case T_OBJECT:\n-  case T_ARRAY:\n-  case T_INLINE_TYPE:\n-    fatal(\"Should not be handled with this method\");\n-    break;\n-  default:\n-    fatal(\"Unsupported BasicType\");\n-  }\n-}\n-\n@@ -309,69 +273,1 @@\n-\/\/ withfield support used by aarch64 but not x86 (see withfield2 below)\n-JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* current, ConstantPoolCache* cp_cache))\n-  LastFrameAccessor last_frame(current);\n-  \/\/ Getting the InlineKlass\n-  int index = ConstantPool::decode_cpcache_index(last_frame.get_index_u2_cpcache(Bytecodes::_withfield));\n-  ConstantPoolCacheEntry* cp_entry = cp_cache->entry_at(index);\n-  assert(cp_entry->is_resolved(Bytecodes::_withfield), \"Should have been resolved\");\n-  Klass* klass = cp_entry->f1_as_klass();\n-  assert(klass->is_inline_klass(), \"withfield only applies to inline types\");\n-  InlineKlass* vklass = InlineKlass::cast(klass);\n-\n-  \/\/ Getting Field information\n-  int offset = cp_entry->f2_as_index();\n-  int field_index = cp_entry->field_index();\n-  int field_offset = cp_entry->f2_as_offset();\n-  Symbol* field_signature = vklass->field_signature(field_index);\n-  BasicType field_type = Signature::basic_type(field_signature);\n-  int return_offset = (type2size[field_type] + type2size[T_OBJECT]) * AbstractInterpreter::stackElementSize;\n-\n-  \/\/ Getting old value\n-  frame& f = last_frame.get_frame();\n-  jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;\n-  int vt_offset = type2size[field_type];\n-  oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);\n-  if (old_value == NULL) {\n-    THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);\n-  }\n-  assert(oopDesc::is_oop(old_value), \"Verifying receiver\");\n-  assert(old_value->klass()->is_inline_klass(), \"Must have been checked during resolution\");\n-  Handle old_value_h(THREAD, old_value);\n-\n-  \/\/ Creating new value by copying the one passed in argument\n-  instanceOop new_value = vklass->allocate_instance_buffer(\n-      CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));\n-  Handle new_value_h = Handle(THREAD, new_value);\n-  vklass->inline_copy_oop_to_new_oop(old_value_h(), new_value_h());\n-\n-  \/\/ Updating the field specified in arguments\n-  if (field_type == T_ARRAY || field_type == T_OBJECT) {\n-    oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n-    assert(aoop == NULL || oopDesc::is_oop(aoop),\"argument must be a reference type\");\n-    new_value_h()->obj_field_put(field_offset, aoop);\n-  } else if (field_type == T_INLINE_TYPE) {\n-    if (cp_entry->is_inlined()) {\n-      oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n-      assert(vt_oop != NULL && oopDesc::is_oop(vt_oop) && vt_oop->is_inline_type(),\"argument must be an inline type\");\n-      InlineKlass* field_vk = InlineKlass::cast(vklass->get_inline_type_field_klass(field_index));\n-      assert(vt_oop != NULL && field_vk == vt_oop->klass(), \"Must match\");\n-      field_vk->write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));\n-    } else { \/\/ not inlined\n-      oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n-      if (voop == NULL && cp_entry->is_null_free_inline_type()) {\n-        THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);\n-      }\n-      assert(voop == NULL || oopDesc::is_oop(voop),\"checking argument\");\n-      new_value_h()->obj_field_put(field_offset, voop);\n-    }\n-  } else { \/\/ not T_OBJECT nor T_ARRAY nor T_INLINE_TYPE\n-    intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);\n-    copy_primitive_argument(addr, new_value_h, field_offset, field_type);\n-  }\n-\n-  \/\/ returning result\n-  current->set_vm_result(new_value_h());\n-  return return_offset;\n-JRT_END\n-\n-\/\/ withfield support for x86, avoiding costly calls to retrieve last Java frame\n-JRT_ENTRY(int, InterpreterRuntime::withfield2(JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr))\n+JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr))\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":105,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -68,2 +68,1 @@\n-  static int     withfield     (JavaThread* current, ConstantPoolCache* cp_cache);\n-  static int     withfield2     (JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr);\n+  static int     withfield     (JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}