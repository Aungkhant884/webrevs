{"files":[{"patch":"@@ -1182,1 +1182,1 @@\n-            } else if (cl.isInlineClass()) {\n+            } else if (cl.isPrimitiveClass()) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-        boolean isInlineClass = cl.isInlineClass();\n+        boolean isPrimitiveClass = cl.isPrimitiveClass();\n@@ -579,2 +579,2 @@\n-            } else if (isInlineClass && writeReplaceMethod == null) {\n-                deserializeEx = new ExceptionInfo(name, \"inline class\");\n+            } else if (isPrimitiveClass && writeReplaceMethod == null) {\n+                deserializeEx = new ExceptionInfo(name, \"primitive class\");\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-    private static final int INLINE     = 0x00000100;\n+    private static final int PRIMITIVE_CLASS = 0x00000100;\n@@ -236,1 +236,1 @@\n-        return (isInlineClass() ? \"inline \" : \"\")\n+        return (isPrimitiveClass() ? \"primitive \" : \"\")\n@@ -300,3 +300,2 @@\n-                if (isInlineClass()) {\n-                    sb.append(\"inline\");\n-                    sb.append(' ');\n+                if (isPrimitiveClass()) {\n+                    sb.append(\"primitive \");\n@@ -557,1 +556,1 @@\n-     * Returns {@code true} if this class is an inline class.\n+     * Returns {@code true} if this class is a primitive class.\n@@ -559,1 +558,1 @@\n-     * @return {@code true} if this class is an inline class\n+     * @return {@code true} if this class is a primitive class, otherwise false\n@@ -562,2 +561,2 @@\n-    public boolean isInlineClass() {\n-        return (this.getModifiers() & INLINE) != 0;\n+    public boolean isPrimitiveClass() {\n+        return (this.getModifiers() & PRIMITIVE_CLASS) != 0;\n@@ -567,5 +566,5 @@\n-     * Returns a {@code Class} object representing the <em>value projection<\/em>\n-     * type of this class if this {@code Class} represents the reference projection\n-     * type of an {@linkplain #isInlineClass() inline class}.\n-     * If this {@code Class} represents the value projection type\n-     * of an inline class, then this method returns this class.\n+     * Returns a {@code Optional<Class>} object representing the <em>primitive value type<\/em>\n+     * of this class if this {@code Class} represents the <em>primitive reference type<\/em>\n+     * of a {@linkplain #isPrimitiveClass() primitive class}.\n+     * If this {@code Class} represents the primitive value type\n+     * of a primitive class, then this method returns this class.\n@@ -574,3 +573,3 @@\n-     * @return the {@code Class} object representing the value projection type of\n-     *         this class if this class is the value projection type\n-     *         or the reference projection type of an inline class;\n+     * @return the {@code Optional<Class>} representing the primitive value type of\n+     *         this class if this class is the primitive value type\n+     *         or the primitive reference type of a primitive class;\n@@ -584,1 +583,1 @@\n-        Class<?>[] valRefTypes = getProjectionTypes();\n+        Class<?>[] valRefTypes = getPrimitiveTypes();\n@@ -592,6 +591,3 @@\n-     * If this {@code Class} represents an {@linkplain #isInlineClass()\n-     * inline class} with a reference projection type, then this method\n-     * returns the <em>reference projection<\/em> type of this inline class.\n-     * <p>\n-     * If this {@code Class} represents the reference projection type\n-     * of an inline class, then this method returns this class.\n+     * If this {@code Class} represents a {@linkplain #isPrimitiveClass()\n+     * primitive reference type}, then this method\n+     * returns the <em>primitive reference type<\/em> type of this primitive class.\n@@ -599,3 +595,2 @@\n-     * If this class is an {@linkplain #isInlineClass() inline class}\n-     * without a reference projection, then this method returns an empty\n-     * {@code Optional}.\n+     * If this {@code Class} represents the primitive reference type\n+     * of a primitive class, then this method returns this class.\n@@ -603,2 +598,1 @@\n-     * If this class is an identity class, then this method returns this\n-     * class.\n+     * If this class is an identity class, then this method returns this class.\n@@ -608,2 +602,2 @@\n-     * @return the {@code Class} object representing a reference type for\n-     *         this class if present; an empty {@link Optional} otherwise.\n+     * @return the {@code Optional<Class>} object representing the reference type for\n+     *         this class, if present; an empty {@link Optional} otherwise.\n@@ -616,1 +610,1 @@\n-        Class<?>[] valRefTypes = getProjectionTypes();\n+        Class<?>[] valRefTypes = getPrimitiveTypes();\n@@ -621,2 +615,2 @@\n-     * Returns true if this Class object represents a reference projection\n-     * type for an inline class.\n+     * Returns true if this Class object represents a primitive reference\n+     * type for a primitive class.\n@@ -624,4 +618,3 @@\n-     * A reference projection type must be a sealed abstract class that\n-     * permits the inline projection type to extend.  The inline projection\n-     * type and reference projection type for an inline type must be of\n-     * the same package.\n+     * A primitive reference type must be a sealed abstract class that\n+     * permits the primitive value type to extend.  The primitive value type\n+     * and primitive reference type for a primitive type must be of the same package.\n@@ -629,2 +622,2 @@\n-    private boolean isReferenceProjectionType() {\n-        if (isPrimitive() || isArray() || isInterface() || isInlineClass())\n+    private boolean isPrimitiveReferenceType() {\n+        if (isPrimitive() || isArray() || isInterface() || isPrimitiveClass())\n@@ -638,1 +631,1 @@\n-        Class<?>[] valRefTypes = getProjectionTypes();\n+        Class<?>[] valRefTypes = getPrimitiveTypes();\n@@ -642,2 +635,2 @@\n-    private transient Class<?>[] projectionTypes;\n-    private Class<?>[] getProjectionTypes() {\n+    private transient Class<?>[] primitiveTypes;\n+    private Class<?>[] getPrimitiveTypes() {\n@@ -647,1 +640,1 @@\n-        Class<?>[] valRefTypes = projectionTypes;\n+        Class<?>[] valRefTypes = primitiveTypes;\n@@ -649,3 +642,1 @@\n-            \/\/ C.ensureProjectionTypesInited calls initProjectionTypes that may\n-            \/\/ call D.ensureProjectionTypesInited where D is its superclass.\n-            \/\/ So initProjectionTypes is called without holding any lock to\n+            \/\/ So newPrimitiveTypeArray is called without holding any lock to\n@@ -653,1 +644,1 @@\n-            \/\/ initialize the projection types for C and E where D is\n+            \/\/ initialize the primitive types for C and E where D is\n@@ -655,1 +646,1 @@\n-            valRefTypes = newProjectionTypeArray();\n+            valRefTypes = newPrimitiveTypeArray();\n@@ -658,3 +649,3 @@\n-            \/\/ set the projection types if not set\n-            if (projectionTypes == null) {\n-                projectionTypes = valRefTypes;\n+            \/\/ set the value and reference types if not set\n+            if (primitiveTypes == null) {\n+                primitiveTypes = valRefTypes;\n@@ -663,1 +654,1 @@\n-        return projectionTypes;\n+        return primitiveTypes;\n@@ -667,3 +658,3 @@\n-     * Returns an array of Class object whose element at index 0 represents the\n-     * value projection type and element at index 1 represents the reference\n-     * projection type if present.\n+     * Returns an array of Class objects whose element at index 0 represents the\n+     * primitive value type and element at index 1 represents the\n+     * primitive reference type, if present.\n@@ -671,2 +662,2 @@\n-     * If this Class object is neither a value projection type nor\n-     * a reference projection type for an inline class, then an empty array\n+     * If this Class object is neither a primitive value type nor\n+     * a primitive reference type for a primitive class, then an empty array\n@@ -675,1 +666,1 @@\n-    private Class<?>[] newProjectionTypeArray() {\n+    private Class<?>[] newPrimitiveTypeArray() {\n@@ -679,1 +670,1 @@\n-        if (isInlineClass()) {\n+        if (isPrimitiveClass()) {\n@@ -681,1 +672,1 @@\n-            if (superClass != Object.class && superClass.isReferenceProjectionType()) {\n+            if (superClass != Object.class && superClass.isPrimitiveReferenceType()) {\n@@ -687,1 +678,1 @@\n-            Class<?> valType = valueProjectionType();\n+            Class<?> valType = primitiveValueType();\n@@ -697,2 +688,2 @@\n-     * Returns the value projection type if this Class represents\n-     * a reference projection type.  If this class is an inline class\n+     * Returns the primitive value type if this Class represents\n+     * a primitive reference type.  If this class is a primitive class\n@@ -701,1 +692,1 @@\n-    private Class<?> valueProjectionType() {\n+    private Class<?> primitiveValueType() {\n@@ -705,1 +696,1 @@\n-        if (isInlineClass())\n+        if (isPrimitiveClass())\n@@ -713,4 +704,4 @@\n-        \/\/ A reference projection type must be a sealed abstract class\n-        \/\/ that permits the inline projection type to extend.\n-        \/\/ The inline projection type and reference projection type for\n-        \/\/ an inline type must be of the same package.\n+        \/\/ A primitive reference type must be a sealed abstract class\n+        \/\/ that permits the primitive class project type to extend.\n+        \/\/ The primitive class project type and primitive reference type for\n+        \/\/ a primitive class type must be of the same package.\n@@ -725,1 +716,1 @@\n-                    if (valType.isInlineClass()) {\n+                    if (valType.isPrimitiveClass()) {\n@@ -1013,1 +1004,1 @@\n-     * <tr><th scope=\"row\"> {@linkplain #isInlineClass() inline class} with <a href=\"ClassLoader.html#binary-name\">binary name<\/a> <i>N<\/i>\n+     * <tr><th scope=\"row\"> {@linkplain #isPrimitiveClass() primitive class} with <a href=\"ClassLoader.html#binary-name\">binary name<\/a> <i>N<\/i>\n@@ -3963,2 +3954,2 @@\n-     * @throws NullPointerException if this is an {@linkplain #isInlineClass()\n-     * inline type} and the object is {@code null}\n+     * @throws NullPointerException if this is an {@linkplain #isPrimitiveClass()\n+     * primitive class} and the object is {@code null}\n@@ -3971,2 +3962,2 @@\n-        if (isInlineClass() && obj == null)\n-            throw new NullPointerException(getName() + \" is an inline class\");\n+        if (isPrimitiveClass() && obj == null)\n+            throw new NullPointerException(getName() + \" is a primitive class\");\n@@ -4483,1 +4474,1 @@\n-        String typeDesc = isInlineClass() ? \"Q\" : \"L\";\n+        String typeDesc = isPrimitiveClass() ? \"Q\" : \"L\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":68,"deletions":77,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * An inline class implements the {@code NonTearable} interface to\n+ * A primitive class implements the {@code NonTearable} interface to\n@@ -38,1 +38,1 @@\n- * <p> An inline instance of multiple components is said to be \"torn\"\n+ * <p> An primitive instance of multiple components is said to be \"torn\"\n@@ -48,1 +48,1 @@\n- * model break up inline instance reads and writes into reads and\n+ * model break up primitive classinstance reads and writes into reads and\n@@ -62,2 +62,2 @@\n-    \/\/ TO DO: Decide whether and how to restrict this type to to\n-    \/\/ inline classes only, or if not, whether to document its\n+    \/\/ TO DO: Decide whether and how to restrict this type to\n+    \/\/ primitive classes only, or if not, whether to document its\n","filename":"src\/java.base\/share\/classes\/java\/lang\/NonTearable.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.invoke.ValueBootstrapMethods;\n@@ -242,1 +241,1 @@\n-     * If this object is an instance of an inline class, then\n+     * If this object is an instance of a primitive class, then\n@@ -244,1 +243,1 @@\n-     * the name of the inline class, and string representations of\n+     * the name of the primitive class, and string representations of\n@@ -251,1 +250,1 @@\n-        if (getClass().isInlineClass()) {\n+        if (getClass().isPrimitiveClass()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -369,1 +369,1 @@\n-                \/\/ inline types: fromType and toType are projection types of the same inline class\n+                \/\/ primitive types: fromType and toType are types of the same primitive class\n@@ -379,1 +379,1 @@\n-     * via inline narrowing and widening conversions.\n+     * via primitive class narrowing and widening conversions.\n@@ -385,2 +385,2 @@\n-     * If {@code fromType} is an inline class, this method returns {@code true}\n-     * if {@code toType} is the {@linkplain Class#referenceType() reference projection type}\n+     * If {@code fromType} is a primitive class, this method returns {@code true}\n+     * if {@code toType} is the {@linkplain Class#referenceType() primitive reference type}\n@@ -388,2 +388,2 @@\n-     * If {@code toType} is an inline class, this method returns {@code true}\n-     * if {@code toType} is the {@linkplain Class#valueType() value projection type}\n+     * If {@code toType} is a primitive class, this method returns {@code true}\n+     * if {@code toType} is the {@linkplain Class#valueType() primitive value type}\n@@ -403,1 +403,1 @@\n-        if (!fromType.isInlineClass() && !toType.isInlineClass()) {\n+        if (!fromType.isPrimitiveClass() && !toType.isPrimitiveClass()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        assert(ctor.isObjectConstructor() && !ctor.getDeclaringClass().isInlineClass()) : ctor;\n+        assert(ctor.isObjectConstructor() && !ctor.getDeclaringClass().isPrimitiveClass()) : ctor;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-        assert(!clazz.isInlineClass() || !isField() || Modifier.isFinal(flags));\n+        assert(!clazz.isPrimitiveClass() || !isField() || Modifier.isFinal(flags));\n@@ -479,1 +479,1 @@\n-    \/** Query whether this member is a field of an inline class. *\/\n+    \/** Query whether this member is a field of a primitive class. *\/\n@@ -483,1 +483,1 @@\n-            return type.isInlineClass();\n+            return type.isPrimitiveClass();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4316,1 +4316,1 @@\n-        if (arrayClass.isInlineClass()) {\n+        if (arrayClass.isPrimitiveClass()) {\n@@ -5082,1 +5082,1 @@\n-        } else if (type.isInlineClass()) {\n+        } else if (type.isPrimitiveClass()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-         * do the substitutability test if they are of an inline type.\n+         * do the substitutability test if they are of a primitive type.\n@@ -159,1 +159,1 @@\n-         * of the given inline class are substitutable.\n+         * of the given primitive class are substitutable.\n@@ -162,1 +162,1 @@\n-            assert type.isInlineClass();\n+            assert type.isPrimitiveClass();\n@@ -184,1 +184,1 @@\n-            assert type.isInlineClass();\n+            assert type.isPrimitiveClass();\n@@ -196,2 +196,2 @@\n-                \/\/ For inline type or reference type, this calls Objects::hashCode.\n-                \/\/ If the instance is of inline type and the hashCode method is not\n+                \/\/ For primitive type or reference type, this calls Objects::hashCode.\n+                \/\/ If the instance is of primitive type and the hashCode method is not\n@@ -213,1 +213,1 @@\n-            assert type.isInlineClass();\n+            assert type.isPrimitiveClass();\n@@ -259,1 +259,1 @@\n-            return a.getClass().isInlineClass() ? inlineValueEq(a, b) : (a == b);\n+            return a.getClass().isPrimitiveClass() ? inlineValueEq(a, b) : (a == b);\n@@ -266,1 +266,1 @@\n-            assert a != null && b != null && isSameInlineClass(a, b);\n+            assert a != null && b != null && isSamePrimitiveClass(a, b);\n@@ -285,1 +285,1 @@\n-         * Returns true if the given objects are of the same inline class.\n+         * Returns true if the given objects are of the same primitive class.\n@@ -287,1 +287,1 @@\n-         * Two objects are of the same inline class iff:\n+         * Two objects are of the same primitive class iff:\n@@ -289,1 +289,1 @@\n-         * 2. the declaring class of a and b is the same inline class\n+         * 2. the declaring class of a and b is the same primitive class\n@@ -291,1 +291,1 @@\n-        private static boolean isSameInlineClass(Object a, Object b) {\n+        private static boolean isSamePrimitiveClass(Object a, Object b) {\n@@ -294,1 +294,1 @@\n-            return a.getClass().isInlineClass() && a.getClass() == b.getClass();\n+            return a.getClass().isPrimitiveClass() && a.getClass() == b.getClass();\n@@ -335,1 +335,1 @@\n-            findStatic(\"isSameInlineClass\", methodType(boolean.class, Object.class, Object.class));\n+            findStatic(\"isSamePrimitiveClass\", methodType(boolean.class, Object.class, Object.class));\n@@ -541,1 +541,1 @@\n-        if (type.isInlineClass())\n+        if (type.isPrimitiveClass())\n@@ -555,1 +555,1 @@\n-     * Invoke the bootstrap methods hashCode for the given inline object.\n+     * Invoke the bootstrap methods hashCode for the given primitive classobject.\n@@ -557,1 +557,1 @@\n-     * @return the hash code of the given inline object.\n+     * @return the hash code of the given primitive classobject.\n@@ -564,2 +564,2 @@\n-            if (!type.isInlineClass())\n-                throw new InternalError(\"must be inline type: \" + type.getName());\n+            if (!type.isPrimitiveClass())\n+                throw new InternalError(\"must be primitive type: \" + type.getName());\n@@ -582,1 +582,1 @@\n-     * Invoke the bootstrap methods hashCode for the given inline object.\n+     * Invoke the bootstrap methods hashCode for the given primitive classobject.\n@@ -584,1 +584,1 @@\n-     * @return the string representation of the given inline object.\n+     * @return the string representation of the given primitive classobject.\n@@ -591,2 +591,2 @@\n-            if (!type.isInlineClass())\n-                throw new InternalError(\"must be inline type: \" + type.getName());\n+            if (!type.isPrimitiveClass())\n+                throw new InternalError(\"must be primitive type: \" + type.getName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ValueBootstrapMethods.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Parameter;\n@@ -37,1 +36,0 @@\n-import java.util.LinkedHashMap;\n@@ -39,1 +37,0 @@\n-import java.util.Map;\n@@ -49,1 +46,0 @@\n-import static java.util.stream.Collectors.toList;\n@@ -234,1 +230,1 @@\n-            return maybeAdapt(componentType.isInlineClass() && UNSAFE.isFlattenedArray(arrayClass)\n+            return maybeAdapt(componentType.isPrimitiveClass() && UNSAFE.isFlattenedArray(arrayClass)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-            if (handle.fieldType.isInlineClass())\n+            if (handle.fieldType.isPrimitiveClass())\n@@ -504,1 +504,1 @@\n-            if (handle.fieldType.isInlineClass())\n+            if (handle.fieldType.isPrimitiveClass())\n@@ -747,1 +747,1 @@\n-        assert componentType.isInlineClass() && UNSAFE.isFlattenedArray(arrayClass);\n+        assert componentType.isPrimitiveClass() && UNSAFE.isFlattenedArray(arrayClass);\n@@ -806,1 +806,1 @@\n-            if (handle.componentType.isInlineClass())\n+            if (handle.componentType.isPrimitiveClass())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * The referent must not be an instance of an inline class; such a value\n+ * The referent must not be an instance of a primitive class; such a value\n@@ -89,1 +89,1 @@\n-     *         {@link Class#isInlineClass() inlineClass}\n+     *         {@link Class#isPrimitiveClass() primitive class}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,2 +463,2 @@\n-        if (referent != null && referent.getClass().isInlineClass()) {\n-            throw new IllegalArgumentException(\"cannot reference an inline value of type: \" +\n+        if (referent != null && referent.getClass().isPrimitiveClass()) {\n+            throw new IllegalArgumentException(\"cannot reference a primitive type: \" +\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * The referent must not be an instance of an inline class; such a value\n+ * The referent must not be an instance of a primitive class; such a value\n@@ -86,2 +86,2 @@\n-     * @throws IllegalArgumentException if the referent is an instance of an\n-     *         {@link Class#isInlineClass() inlineClass}\n+     * @throws IllegalArgumentException if the referent is an instance of a\n+     *         {@link Class#isPrimitiveClass() primitive class}\n@@ -101,2 +101,2 @@\n-     * @throws IllegalArgumentException if the referent is an instance of an\n-     *         {@link Class#isInlineClass() inlineClass}\n+     * @throws IllegalArgumentException if the referent is an instance of a\n+     *         {@link Class#isPrimitiveClass() primitive class}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/SoftReference.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * The referent must not be an instance of an inline class; such a value\n+ * The referent must not be an instance of a primitive class; such a value\n@@ -58,2 +58,2 @@\n-     * @throws IllegalArgumentException if the referent is an instance of an\n-     *         {@link Class#isInlineClass() inlineClass}\n+     * @throws IllegalArgumentException if the referent is an instance of a\n+     *         {@link Class#isPrimitiveClass() primitive class}\n@@ -72,2 +72,2 @@\n-     * @throws IllegalArgumentException if the referent is an instance of an\n-     *         {@link Class#isInlineClass() inlineClass}\n+     * @throws IllegalArgumentException if the referent is an instance of a\n+     *         {@link Class#isPrimitiveClass() primitive class}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/WeakReference.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-     * <li>fields declared in a {@linkplain Class#isInlineClass() inline class}<\/li>\n+     * <li>fields declared in a {@linkplain Class#isPrimitiveClass() primitive class}<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -735,2 +735,2 @@\n-     * <li>the field's declaring class is not an {@linkplain Class#isInlineClass()\n-     *     inline class}; and<\/li>\n+     * <li>the field's declaring class is not a {@linkplain Class#isPrimitiveClass()\n+     *     primitive class}; and<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -866,1 +866,1 @@\n-                if (type.isInlineClass()) {\n+                if (type.isPrimitiveClass()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-     * @param vc inline class\n+     * @param pc primitive class\n@@ -237,1 +237,1 @@\n-    public native <V> V getValue(Object o, long offset, Class<?> vc);\n+    public native <V> V getValue(Object o, long offset, Class<?> pc);\n@@ -250,1 +250,1 @@\n-     * @param vc inline class\n+     * @param pc primitive class\n@@ -257,1 +257,1 @@\n-    public native <V> void putValue(Object o, long offset, Class<?> vc, V v);\n+    public native <V> void putValue(Object o, long offset, Class<?> pc, V v);\n@@ -260,1 +260,1 @@\n-     * Fetches a reference value of type {@code vc} from a given Java variable.\n+     * Fetches a reference value of type {@code pc} from a given Java variable.\n@@ -262,1 +262,1 @@\n-     * for a nullable-projection of an inline type.\n+     * for a nullable reference of a primitive type.\n@@ -264,1 +264,1 @@\n-     * @param vc inline class\n+     * @param pc primitive class\n@@ -266,1 +266,1 @@\n-    public Object getReference(Object o, long offset, Class<?> vc) {\n+    public Object getReference(Object o, long offset, Class<?> pc) {\n@@ -268,2 +268,2 @@\n-        if (ref == null && vc.isInlineClass()) {\n-            \/\/ If the type of the returned reference is a regular inline type\n+        if (ref == null && pc.isPrimitiveClass()) {\n+            \/\/ If the type of the returned reference is a regular primitive type\n@@ -271,1 +271,1 @@\n-            ref = uninitializedDefaultValue(vc);\n+            ref = uninitializedDefaultValue(pc);\n@@ -278,2 +278,2 @@\n-        if (ref == null && vc.isInlineClass()) {\n-            \/\/ If the type of the returned reference is a regular inline type\n+        if (ref == null && vc.isPrimitiveClass()) {\n+            \/\/ If the type of the returned reference is a regular primitive type\n@@ -287,1 +287,1 @@\n-     * Returns an uninitialized default value of the given inline class.\n+     * Returns an uninitialized default value of the given primitive class.\n@@ -289,1 +289,1 @@\n-    public native <V> V uninitializedDefaultValue(Class<?> vc);\n+    public native <V> V uninitializedDefaultValue(Class<?> pc);\n@@ -312,1 +312,1 @@\n-     * Returns the header size of the given inline class\n+     * Returns the header size of the given primitive class.\n@@ -314,1 +314,1 @@\n-     * @param vc inline class\n+     * @param pc primitive class\n@@ -316,1 +316,1 @@\n-     * @return the header size of the inline class\n+     * @return the header size of the primitive class\n@@ -318,1 +318,1 @@\n-    public native <V> long valueHeaderSize(Class<V> vc);\n+    public native <V> long valueHeaderSize(Class<V> pc);\n@@ -1570,1 +1570,1 @@\n-        return o != null && o.getClass().isInlineClass();\n+        return o != null && o.getClass().isPrimitiveClass();\n@@ -1574,1 +1574,1 @@\n-     * For inline type, CAS should do substitutability test as opposed\n+     * For primitive type, CAS should do substitutability test as opposed\n@@ -1584,1 +1584,1 @@\n-        if (valueType.isInlineClass() || isInlineType(expected)) {\n+        if (valueType.isPrimitiveClass() || isInlineType(expected)) {\n@@ -1625,1 +1625,1 @@\n-        if (valueType.isInlineClass() || isInlineType(expected)) {\n+        if (valueType.isPrimitiveClass() || isInlineType(expected)) {\n@@ -1707,1 +1707,1 @@\n-        if (valueType.isInlineClass() || isInlineType(expected)) {\n+        if (valueType.isPrimitiveClass() || isInlineType(expected)) {\n@@ -1733,1 +1733,1 @@\n-        if (valueType.isInlineClass() || isInlineType(expected)) {\n+        if (valueType.isPrimitiveClass() || isInlineType(expected)) {\n@@ -1759,1 +1759,1 @@\n-        if (valueType.isInlineClass() || isInlineType(expected)) {\n+        if (valueType.isPrimitiveClass() || isInlineType(expected)) {\n@@ -1785,1 +1785,1 @@\n-        if (valueType.isInlineClass() || isInlineType(expected)) {\n+        if (valueType.isPrimitiveClass() || isInlineType(expected)) {\n@@ -2417,2 +2417,2 @@\n-     * an inline type.  This is a temporary workaround until better localized\n-     * atomic access mechanisms are supported for inline types.\n+     * a primitive type.  This is a temporary workaround until better localized\n+     * atomic access mechanisms are supported for primitive types.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -680,1 +680,1 @@\n-            stringBuilder.append(isInlineClass(currentClass) ? 'Q' : 'L').append(getInternalName(currentClass)).append(';');\n+            stringBuilder.append(isPrimitiveClass(currentClass) ? 'Q' : 'L').append(getInternalName(currentClass)).append(';');\n@@ -684,1 +684,1 @@\n-    static boolean isInlineClass(Class<?> clazz) {\n+    static boolean isPrimitiveClass(Class<?> clazz) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        return !field.getType().isInlineClass();\n+        return !field.getType().isPrimitiveClass();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeFieldAccessorImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -647,1 +647,1 @@\n-        if (f.getDeclaringClass().isInlineClass()) {\n+        if (f.getDeclaringClass().isPrimitiveClass()) {\n@@ -682,1 +682,1 @@\n-        if (f.getDeclaringClass().isInlineClass()) {\n+        if (f.getDeclaringClass().isPrimitiveClass()) {\n@@ -710,1 +710,1 @@\n-        if (f.getDeclaringClass().isInlineClass()) {\n+        if (f.getDeclaringClass().isPrimitiveClass()) {\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-                    return (aClass.isInlineClass() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n+                    return (aClass.isPrimitiveClass() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n@@ -273,1 +273,1 @@\n-                return aClass != null && aClass.isInlineClass();\n+                return aClass != null && aClass.isPrimitiveClass();\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        assertTrue(c.isInlineClass());\n+        assertTrue(c.isPrimitiveClass());\n","filename":"test\/jdk\/valhalla\/valuetypes\/InlineConstructorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        if (elementType.isInlineClass()) {\n+        if (elementType.isPrimitiveClass()) {\n@@ -127,1 +127,1 @@\n-            assertFalse(elementType.isInlineClass(), \"should fail to set an inline class array element to null\");\n+            assertFalse(elementType.isPrimitiveClass(), \"should fail to set an inline class array element to null\");\n@@ -129,1 +129,1 @@\n-            assertTrue(elementType.isInlineClass(), \"should only fail to set an inline class array element to null\");\n+            assertTrue(elementType.isPrimitiveClass(), \"should only fail to set an inline class array element to null\");\n@@ -164,1 +164,1 @@\n-            if (c.isInlineClass())\n+            if (c.isPrimitiveClass())\n@@ -197,1 +197,1 @@\n-        assertTrue(f.getType().isInlineClass() || f.getType().valueType().isPresent());\n+        assertTrue(f.getType().isPrimitiveClass() || f.getType().valueType().isPresent());\n@@ -292,1 +292,1 @@\n-        boolean canBeNull = !f.getType().isInlineClass();\n+        boolean canBeNull = !f.getType().isPrimitiveClass();\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-        assertTrue(inlineClass.isInlineClass());\n-        assertFalse(Point.ref.class.isInlineClass());\n+        assertTrue(inlineClass.isPrimitiveClass());\n+        assertFalse(Point.ref.class.isPrimitiveClass());\n@@ -126,1 +126,1 @@\n-        if (!c.isInlineClass() || c != type) {\n+        if (!c.isPrimitiveClass() || c != type) {\n@@ -167,1 +167,1 @@\n-        assertTrue(componentType.isInlineClass() || componentType.valueType().isPresent());\n+        assertTrue(componentType.isPrimitiveClass() || componentType.valueType().isPresent());\n","filename":"test\/jdk\/valhalla\/valuetypes\/Reflection.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        if (componentType.isInlineClass()) {\n+        if (componentType.isPrimitiveClass()) {\n@@ -75,1 +75,1 @@\n-        sb.append(c.isInlineClass() ? \"Q\" : \"L\").append(c.getName()).append(\";\");\n+        sb.append(c.isPrimitiveClass() ? \"Q\" : \"L\").append(c.getName()).append(\";\");\n@@ -95,1 +95,1 @@\n-        if (!componentType.isInlineClass()) {\n+        if (!componentType.isPrimitiveClass()) {\n@@ -110,1 +110,1 @@\n-        assertTrue(componentType.isInlineClass());\n+        assertTrue(componentType.isPrimitiveClass());\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueArray.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}