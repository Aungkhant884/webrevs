{"files":[{"patch":"@@ -360,1 +360,1 @@\n-            return new MethodType(t.getParameterTypes().prepend(outerThisType),\n+            t = new MethodType(t.getParameterTypes().prepend(outerThisType),\n@@ -364,1 +364,2 @@\n-        } else {\n+        }\n+        if (!types.flattenWithTypeRestrictions) {\n@@ -367,0 +368,26 @@\n+        List<Type> rpt = List.nil();\n+        Type rrt = null;\n+        boolean mutateExternalType = false;\n+        \/\/ Computed restricted parameter types\n+        for (Type pt: t.getParameterTypes()) {\n+            if (pt.isValue()) {\n+                mutateExternalType = true;\n+                rpt = rpt.append(pt.referenceProjection());\n+            } else {\n+                rpt = rpt.append(pt);\n+            }\n+        }\n+        Type rt = t.getReturnType();\n+        if (rt.isValue()) {\n+            mutateExternalType = true;\n+            rrt = rt.referenceProjection();\n+        } else {\n+            rrt = rt;\n+        }\n+        if (mutateExternalType) {\n+            t = new MethodType(rpt,\n+                    rrt,\n+                    t.getThrownTypes(),\n+                    t.tsym);\n+        }\n+        return t;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1280,0 +1280,32 @@\n+\n+            new AttributeReader(names.RestrictedMethod, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowInlineTypes;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (!types.flattenWithTypeRestrictions) {\n+                        bp = bp + attrLen;\n+                        return;\n+                    }\n+                    int paramCount = nextByte();\n+                    if (sym.name == names.init && sym.owner.hasOuterInstance())\n+                        paramCount --;\n+                    List<Type> paramTypes = List.nil();\n+                    for (int i = 0; i < paramCount; i++) {\n+                        int restrictedParamTypeIndex = nextChar();\n+                        paramTypes = paramTypes.append(\n+                                  restrictedParamTypeIndex == 0 ?\n+                                  sym.type.getParameterTypes().get(i)\n+                                : poolReader.getType(restrictedParamTypeIndex));\n+                    }\n+                    int restrictedReturnTypeIndex = nextChar();\n+                    Type returnType =\n+                            restrictedReturnTypeIndex == 0 || sym.isConstructor() ?\n+                                    sym.type.getReturnType()\n+                                    : poolReader.getType(restrictedReturnTypeIndex);\n+                    if (sym.kind == MTH && sym.owner.kind == TYP) {\n+                        sym.type = new MethodType(paramTypes, returnType, sym.type.getThrownTypes(), sym.type.tsym);\n+                    }\n+                }\n+            },\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1057,0 +1057,75 @@\n+        \/\/ See if we need to emit a RestrictedMethod attribute\n+        boolean emitRestrictedMethod = false;\n+\n+        if (types.flattenWithTypeRestrictions && m.name == m.name.table.names.init && m.owner.hasOuterInstance()) {\n+            Type outerThisType = types.erasure(m.owner.type.getEnclosingType());\n+            if (outerThisType.isValue()) {\n+                emitRestrictedMethod = true;\n+            }\n+        }\n+        CheckTypeRestrictedParameters:\n+        for (Type pt : m.type.getParameterTypes()) {\n+            if (pt.isValue() && types.flattenWithTypeRestrictions) {\n+                emitRestrictedMethod = true;\n+                break;\n+            }\n+            for (Attribute.Compound anno : pt.getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    emitRestrictedMethod = true;\n+                    break CheckTypeRestrictedParameters;\n+                }\n+            }\n+        }\n+        if (m.type.getReturnType().isValue() && types.flattenWithTypeRestrictions) {\n+            emitRestrictedMethod = true;\n+        } else {\n+            for (Attribute.Compound anno : m.type.getReturnType().getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    emitRestrictedMethod = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (emitRestrictedMethod) {\n+            int alenIdx = writeAttr(names.RestrictedMethod);\n+            databuf.appendByte(m.externalType(types).getParameterTypes().size());\n+            if (types.flattenWithTypeRestrictions) {\n+                if (m.name == names.init && m.owner.hasOuterInstance()) {\n+                    Type outerThisType = types.erasure(m.owner.type.getEnclosingType());\n+                    databuf.appendChar(outerThisType.isValue() ? poolWriter.putDescriptor(outerThisType) : 0);\n+                }\n+                for (Type pt : m.erasure(types).getParameterTypes()) {\n+                    databuf.appendChar(pt.isValue() ? poolWriter.putDescriptor(pt) : 0);\n+                }\n+                Type rt = m.erasure(types).getReturnType();\n+                databuf.appendChar(rt.isValue() ? poolWriter.putDescriptor(rt) : 0);\n+            } else {\n+                int restrictedTypeDescriptor;\n+                for (Type pt : m.type.getParameterTypes()) {\n+                    restrictedTypeDescriptor = 0;\n+                    for (Attribute.Compound anno : pt.getAnnotationMirrors()) {\n+                        if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                            Attribute member = anno.member(names.value);\n+                            Assert.check(member.type.tsym == syms.stringType.tsym);\n+                            String utf8 = (String) member.getValue();\n+                            restrictedTypeDescriptor = poolWriter.putName(names.fromString(utf8));\n+                        }\n+                    }\n+                    databuf.appendChar(restrictedTypeDescriptor);\n+                }\n+                restrictedTypeDescriptor = 0;\n+                Type rt = m.type.getReturnType();\n+                for (Attribute.Compound anno : rt.getAnnotationMirrors()) {\n+                    if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                        Attribute member = anno.member(names.value);\n+                        Assert.check(member.type.tsym == syms.stringType.tsym);\n+                        String utf8 = (String) member.getValue();\n+                        restrictedTypeDescriptor = poolWriter.putName(names.fromString(utf8));\n+                    }\n+                }\n+                databuf.appendChar(restrictedTypeDescriptor);\n+            }\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+    public final Name RestrictedMethod;\n@@ -342,0 +343,1 @@\n+        RestrictedMethod = fromString(\"RestrictedMethod\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    public static final String RestrictedMethod          = \"RestrictedMethod\";\n@@ -142,0 +143,1 @@\n+            standardAttributes.put(RestrictedMethod, RestrictedMethod_attribute.class);\n@@ -210,0 +212,1 @@\n+        R visitRestrictedMethod(RestrictedMethod_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -664,0 +664,10 @@\n+        @Override\n+        public Void visitRestrictedMethod(RestrictedMethod_attribute attr, ClassOutputStream out) {\n+            out.writeByte(attr.num_params);\n+            for (int i = 0; i < attr.num_params; i++) {\n+                out.writeShort(attr.restricted_param_type[i]);\n+            }\n+            out.writeShort(attr.restricted_return_type);\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+\n+public class RestrictedMethod_attribute extends Attribute {\n+\n+    RestrictedMethod_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        num_params = cr.readUnsignedByte();\n+        restricted_param_type = new int [num_params];\n+        for (int i = 0; i < num_params; i++) {\n+            restricted_param_type[i] = cr.readUnsignedShort();\n+        }\n+        restricted_return_type = cr.readUnsignedShort();\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitRestrictedMethod(this, data);\n+    }\n+\n+    public int getParameterCount() {\n+        return num_params;\n+    }\n+\n+    public int getRestrictedParameterType(int i) {\n+        return restricted_param_type[i];\n+    }\n+\n+    public int getRestrictedReturnType() {\n+        return restricted_return_type;\n+    }\n+\n+    int num_params;\n+    int restricted_param_type[];\n+    int restricted_return_type;\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RestrictedMethod_attribute.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -65,0 +65,1 @@\n+import com.sun.tools.classfile.RestrictedMethod_attribute;\n@@ -821,0 +822,25 @@\n+    @Override\n+    public Void visitRestrictedMethod(RestrictedMethod_attribute attr, Void aVoid) {\n+        print(\"RestrictedMethod: (\");\n+        int tidx;\n+        String type;\n+        String unrestricted = \"<unrestricted>\";\n+        for (int i = 0, count = attr.getParameterCount(); i < count; i++) {\n+            tidx = attr.getRestrictedParameterType(i);\n+            try {\n+                type = tidx == 0 ? unrestricted : constant_pool.getUTF8Value(tidx);\n+            } catch (ConstantPoolException e) {\n+                    type = report(e);\n+            }\n+            print((i == 0 ? \"\" : \", \") + \"#\" + tidx + \" \" + type);\n+        }\n+        tidx = attr.getRestrictedReturnType();\n+        try {\n+            type = tidx == 0 ? unrestricted : constant_pool.getUTF8Value(tidx);\n+        } catch (ConstantPoolException e) {\n+            type = report(e);\n+        }\n+        println(\")#\" + tidx + \" \" + type);\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1379,0 +1379,5 @@\n+\n+        @Override\n+        public Void visitRestrictedMethod(RestrictedMethod_attribute attr, T p) {\n+            return null;\n+        }\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    public R visitRestrictedMethod(RestrictedMethod_attribute attr, P p) { return null; }\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AttributeVisitor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260870\n+ * @summary Generate RestrictedMethod attributes from annotations\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @run main AnnotatedRestrictedMethodTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+public class AnnotatedRestrictedMethodTest {\n+\n+    inline class Point {}\n+    inline class Line {}\n+\n+    Point foo(int x, Point p, int y, Line l) {\n+        return p;\n+    }\n+\n+    @RestrictedType(\"QAnnotatedRestrictedMethodTest$Point;\")\n+    Object goo(int x,\n+               @RestrictedType(\"QAnnotatedRestrictedMethodTest$Point;\") Object p,\n+               int y,\n+               @RestrictedType(\"QAnnotatedRestrictedMethodTest$Line;\") Object l) {\n+        return p;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(AnnotatedRestrictedMethodTest.class.getResourceAsStream(\"AnnotatedRestrictedMethodTest.class\"));\n+\n+        for (Method meth: cls.methods) {\n+            if (meth.getName(cls.constant_pool).equals(\"foo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(IQAnnotatedRestrictedMethodTest$Point;IQAnnotatedRestrictedMethodTest$Line;)QAnnotatedRestrictedMethodTest$Point;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method\");\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma != null) {\n+                    throw new AssertionError(\"Unexpected restricted method attribute\");\n+                }\n+            } else if (meth.getName(cls.constant_pool).equals(\"goo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(ILjava\/lang\/Object;ILjava\/lang\/Object;)Ljava\/lang\/Object;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method \" + desc);\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma == null) {\n+                    throw new AssertionError(\"Missing restricted method attribute\");\n+                }\n+\n+                if (rma.getParameterCount() != 4) {\n+                    throw new AssertionError(\"Wrong parameter count\");\n+                }\n+                int typeindex;\n+                String type;\n+                for (int i = 0; i < 4; i++) {\n+                    typeindex = rma.getRestrictedParameterType(i);\n+                    switch(i) {\n+                        case 0:\n+                        case 2:\n+                            if (typeindex != 0) {\n+                                throw new AssertionError(\"Unexpected type restriction\");\n+                            }\n+                            break;\n+                        case 1:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Point;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                        case 3:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Line;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                    }\n+                }\n+                typeindex = rma.getRestrictedReturnType();\n+                if (typeindex == 0) {\n+                    throw new AssertionError(\"Missing type restriction\");\n+                }\n+                if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Point;\")) {\n+                    throw new AssertionError(\"Unexpected type restriction \" + type);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AnnotatedRestrictedMethodTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260870\n+ * @summary Generate RestrictedMethod attributes triggered via compile time flag\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDflattenWithTypeRestrictions FlaggedRestrictedMethodTest.java\n+ * @run main FlaggedRestrictedMethodTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+public class FlaggedRestrictedMethodTest {\n+\n+    inline class Point {}\n+    inline class Line {}\n+\n+    static Point foo(int x, Point p, int y, Line l) {\n+        return p;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(FlaggedRestrictedMethodTest.class.getResourceAsStream(\"FlaggedRestrictedMethodTest.class\"));\n+\n+        for (Method meth: cls.methods) {\n+            if (meth.getName(cls.constant_pool).equals(\"foo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(ILFlaggedRestrictedMethodTest$Point$ref;ILFlaggedRestrictedMethodTest$Line$ref;)LFlaggedRestrictedMethodTest$Point$ref;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method\" + desc);\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma == null) {\n+                    throw new AssertionError(\"Missing restricted method attribute\");\n+                }\n+\n+                if (rma.getParameterCount() != 4) {\n+                    throw new AssertionError(\"Wrong parameter count\");\n+                }\n+                int typeindex;\n+                String type;\n+                for (int i = 0; i < 4; i++) {\n+                    typeindex = rma.getRestrictedParameterType(i);\n+                    switch(i) {\n+                        case 0:\n+                        case 2:\n+                            if (typeindex != 0) {\n+                                throw new AssertionError(\"Unexpected type restriction\");\n+                            }\n+                            break;\n+                        case 1:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Point;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                        case 3:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Line;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                    }\n+                }\n+                typeindex = rma.getRestrictedReturnType();\n+                if (typeindex == 0) {\n+                    throw new AssertionError(\"Missing type restriction\");\n+                }\n+                if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Point;\")) {\n+                    throw new AssertionError(\"Unexpected type restriction \" + type);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/FlaggedRestrictedMethodTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260870\n+ * @summary Flatten with type restrictions separate compilation test\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDflattenWithTypeRestrictions FlaggedRestrictedMethodTest.java\n+ * @compile\/fail\/ref=RestrictedMethodTest.out -XDrawDiagnostics -XDflattenWithTypeRestrictions RestrictedMethodTest.java\n+ *\/\n+\n+public class RestrictedMethodTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        FlaggedRestrictedMethodTest.foo(10, null, 20, null);\n+        FlaggedRestrictedMethodTest.foo(10, new FlaggedRestrictedMethodTest.Point(), 20, null);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedMethodTest.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+RestrictedMethodTest.java:38:36: compiler.err.cant.apply.symbol: kindname.method, foo, int,FlaggedRestrictedMethodTest.Point,int,FlaggedRestrictedMethodTest.Line, int,compiler.misc.type.null,int,compiler.misc.type.null, kindname.class, FlaggedRestrictedMethodTest, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlaggedRestrictedMethodTest.Point))\n+RestrictedMethodTest.java:39:45: compiler.err.encl.class.required: FlaggedRestrictedMethodTest.Point\n+RestrictedMethodTest.java:39:36: compiler.err.cant.apply.symbol: kindname.method, foo, int,FlaggedRestrictedMethodTest.Point,int,FlaggedRestrictedMethodTest.Line, int,FlaggedRestrictedMethodTest.Point,int,compiler.misc.type.null, kindname.class, FlaggedRestrictedMethodTest, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlaggedRestrictedMethodTest.Line))\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedMethodTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"}]}