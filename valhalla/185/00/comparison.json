{"files":[{"patch":"@@ -3072,0 +3072,3 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2566,0 +2566,4 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3202,0 +3202,3 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3091,0 +3091,4 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3990,0 +3990,20 @@\n+void LIR_Assembler::emit_profile_inline_type(LIR_OpProfileInlineType* op) {\n+  Register obj = op->obj()->as_register();\n+  Register tmp = op->tmp()->as_pointer_register();\n+  Address mdo_addr = as_Address(op->mdp()->as_address_ptr());\n+  bool not_null = op->not_null();\n+  int flag = op->flag();\n+\n+  Label not_inline_type;\n+  if (!not_null) {\n+    __ testptr(obj, obj);\n+    __ jccb(Assembler::zero, not_inline_type);\n+  }\n+\n+  __ test_oop_is_not_inline_type(obj, tmp, not_inline_type);\n+\n+  __ orb(mdo_addr, flag);\n+\n+  __ bind(not_inline_type);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1702,1 +1702,1 @@\n-void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp) {\n+void InterpreterMacroAssembler::profile_not_taken_branch(Register mdp, bool acmp) {\n@@ -1714,1 +1714,1 @@\n-    update_mdp_by_constant(mdp, in_bytes(BranchData::branch_data_size()));\n+    update_mdp_by_constant(mdp, acmp ? in_bytes(ACmpData::acmp_data_size()): in_bytes(BranchData::branch_data_size()));\n@@ -2138,0 +2138,31 @@\n+void InterpreterMacroAssembler::profile_acmp(Register mdp,\n+                                             Register left,\n+                                             Register right,\n+                                             Register tmp) {\n+  if (ProfileInterpreter) {\n+    Label profile_continue;\n+\n+    \/\/ If no method data exists, go to profile_continue.\n+    test_method_data_pointer(mdp, profile_continue);\n+\n+    mov(tmp, left);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::left_offset())));\n+\n+    Label left_not_inline_type;\n+    test_oop_is_not_inline_type(left, tmp, left_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::left_inline_type_byte_constant());\n+    bind(left_not_inline_type);\n+\n+    mov(tmp, right);\n+    profile_obj_type(tmp, Address(mdp, in_bytes(ACmpData::right_offset())));\n+\n+    Label right_not_inline_type;\n+    test_oop_is_not_inline_type(right, tmp, right_not_inline_type);\n+    set_mdp_flag_at(mdp, ACmpData::right_inline_type_byte_constant());\n+    bind(right_not_inline_type);\n+\n+    bind(profile_continue);\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-  void profile_not_taken_branch(Register mdp);\n+  void profile_not_taken_branch(Register mdp, bool acmp = false);\n@@ -304,0 +304,1 @@\n+  void profile_acmp(Register mdp, Register left, Register right, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2619,0 +2619,10 @@\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type) {\n+  testptr(object, object);\n+  jcc(Assembler::equal, not_inline_type);\n+  const int is_inline_type_mask = markWord::always_locked_pattern;\n+  movptr(tmp, Address(object, oopDesc::mark_offset_in_bytes()));\n+  andptr(tmp, is_inline_type_mask);\n+  cmpptr(tmp, is_inline_type_mask);\n+  jcc(Assembler::notEqual, not_inline_type);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type);\n@@ -746,0 +747,1 @@\n+  void andptr(Register dst, Address src) { LP64_ONLY(andq(dst, src)) NOT_LP64(andl(dst, src)) ; }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2490,0 +2490,2 @@\n+  __ profile_acmp(rbx, rdx, rax, rcx);\n+\n@@ -2496,3 +2498,1 @@\n-    __ movptr(rbx, rdx);\n-    __ andptr(rbx, rax);\n-    __ testptr(rbx, rbx);\n+    __ testptr(rdx, rax);\n@@ -2503,0 +2503,1 @@\n+    __ andptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n@@ -2504,4 +2505,1 @@\n-    __ movptr(rcx, Address(rax, oopDesc::mark_offset_in_bytes()));\n-    __ andptr(rbx, is_inline_type_mask);\n-    __ andptr(rbx, rcx);\n-    __ cmpl(rbx, is_inline_type_mask);\n+    __ cmpptr(rbx, is_inline_type_mask);\n@@ -2530,1 +2528,1 @@\n-  __ profile_not_taken_branch(rax);\n+  __ profile_not_taken_branch(rax, true);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1058,0 +1058,1 @@\n+void Canonicalizer::do_ProfileACmpTypes(ProfileACmpTypes* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  virtual void do_ProfileACmpTypes(ProfileACmpTypes*  x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1337,0 +1337,5 @@\n+  if ((stream()->cur_bc() == Bytecodes::_if_acmpeq || stream()->cur_bc() == Bytecodes::_if_acmpne) &&\n+      is_profiling() && profile_branches()) {\n+    compilation()->set_would_profile(true);\n+    append(new ProfileACmpTypes(method(), bci(), x, y));\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+class   ProfileACmpTypes;\n@@ -213,0 +214,1 @@\n+  virtual void do_ProfileACmpTypes(ProfileACmpTypes*  x) = 0;\n@@ -2674,1 +2676,1 @@\n-    \/\/ The ProfileType has side-effects and must occur precisely where located\n+    \/\/ The ProfileReturnType has side-effects and must occur precisely where located\n@@ -2690,0 +2692,42 @@\n+LEAF(ProfileACmpTypes, Instruction)\n+ private:\n+  ciMethod*        _method;\n+  int              _bci;\n+  Value            _left;\n+  Value            _right;\n+  bool             _left_maybe_null;\n+  bool             _right_maybe_null;\n+\n+ public:\n+  ProfileACmpTypes(ciMethod* method, int bci, Value left, Value right)\n+    : Instruction(voidType)\n+    , _method(method)\n+    , _bci(bci)\n+    , _left(left)\n+    , _right(right)\n+  {\n+    \/\/ The ProfileACmp has side-effects and must occur precisely where located\n+    pin();\n+    _left_maybe_null = true;\n+    _right_maybe_null = true;\n+  }\n+\n+  ciMethod* method()             const { return _method; }\n+  int bci()                      const { return _bci; }\n+  Value left()                 const { return _left; }\n+  Value right()                 const { return _right; }\n+  bool left_maybe_null()       const { return _left_maybe_null; }\n+  bool right_maybe_null()       const { return _right_maybe_null; }\n+  void set_left_maybe_null(bool v)   { _left_maybe_null = v; }\n+  void set_right_maybe_null(bool v)   { _right_maybe_null = v; }\n+\n+  virtual void input_values_do(ValueVisitor* f)   {\n+    if (_left != NULL) {\n+      f->visit(&_left);\n+    }\n+    if (_right != NULL) {\n+      f->visit(&_right);\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -914,0 +914,1 @@\n+\n@@ -921,0 +922,7 @@\n+void InstructionPrinter::do_ProfileACmpTypes(ProfileACmpTypes* x) {\n+  output()->print(\"profile acmp types \");\n+  print_value(x->left());\n+  output()->print(\", \");\n+  print_value(x->right());\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  virtual void do_ProfileACmpTypes(ProfileACmpTypes*  x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -977,1 +977,12 @@\n-  default:\n+\n+    \/\/ LIR_OpProfileInlineType:\n+    case lir_profile_inline_type: {\n+      assert(op->as_OpProfileInlineType() != NULL, \"must be\");\n+      LIR_OpProfileInlineType* opProfileInlineType = (LIR_OpProfileInlineType*)op;\n+\n+      do_input(opProfileInlineType->_mdp); do_temp(opProfileInlineType->_mdp);\n+      do_input(opProfileInlineType->_obj);\n+      do_temp(opProfileInlineType->_tmp);\n+      break;\n+    }\n+default:\n@@ -1194,0 +1205,4 @@\n+void LIR_OpProfileInlineType::emit_code(LIR_Assembler* masm) {\n+  masm->emit_profile_inline_type(this);\n+}\n+\n@@ -1880,0 +1895,2 @@\n+     \/\/ LIR_OpProfileInlineType\n+     case lir_profile_inline_type:   s = \"profile_inline_type\"; break;\n@@ -2216,0 +2233,8 @@\n+\/\/ LIR_OpProfileInlineType\n+void LIR_OpProfileInlineType::print_instr(outputStream* out) const {\n+  out->print(\" flag = %x \", flag());\n+  mdp()->print(out);          out->print(\" \");\n+  obj()->print(out);          out->print(\" \");\n+  tmp()->print(out);          out->print(\" \");\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -881,0 +881,1 @@\n+class    LIR_OpProfileInlineType;\n@@ -1003,0 +1004,1 @@\n+    , lir_profile_inline_type\n@@ -1151,0 +1153,1 @@\n+  virtual LIR_OpProfileInlineType* as_OpProfileInlineType() { return NULL; }\n@@ -2059,0 +2062,32 @@\n+\/\/ LIR_OpProfileInlineType\n+class LIR_OpProfileInlineType : public LIR_Op {\n+ friend class LIR_OpVisitState;\n+\n+ private:\n+  LIR_Opr      _mdp;\n+  LIR_Opr      _obj;\n+  int          _flag;\n+  LIR_Opr      _tmp;\n+  bool         _not_null;      \/\/ true if we know statically that _obj cannot be null\n+\n+ public:\n+  \/\/ Destroys recv\n+  LIR_OpProfileInlineType(LIR_Opr mdp, LIR_Opr obj, int flag, LIR_Opr tmp, bool not_null)\n+    : LIR_Op(lir_profile_inline_type, LIR_OprFact::illegalOpr, NULL)  \/\/ no result, no info\n+    , _mdp(mdp)\n+    , _obj(obj)\n+    , _flag(flag)\n+    , _tmp(tmp)\n+    , _not_null(not_null) { }\n+\n+  LIR_Opr      mdp()              const             { return _mdp;              }\n+  LIR_Opr      obj()              const             { return _obj;              }\n+  int          flag()             const             { return _flag;             }\n+  LIR_Opr      tmp()              const             { return _tmp;              }\n+  bool         not_null()         const             { return _not_null;         }\n+\n+  virtual void emit_code(LIR_Assembler* masm);\n+  virtual LIR_OpProfileInlineType* as_OpProfileInlineType() { return this; }\n+  virtual void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n+\n@@ -2352,0 +2387,3 @@\n+  void profile_inline_type(LIR_Address* mdp, LIR_Opr obj, int flag, LIR_Opr tmp, bool not_null) {\n+    append(new LIR_OpProfileInlineType(LIR_OprFact::address(mdp), obj, flag, tmp, not_null));\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+  void emit_profile_inline_type(LIR_OpProfileInlineType* op);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1771,1 +1771,1 @@\n-      profile_array_load_store_flags(md, load_store, flag);\n+      profile_flags(md, load_store, flag);\n@@ -2181,1 +2181,1 @@\n-      profile_array_load_store_flags(md, load_store, flag);\n+      profile_flags(md, load_store, flag);\n@@ -2988,5 +2988,12 @@\n-void LIRGenerator::profile_array_load_store_flags(ciMethodData* md, ciArrayLoadStoreData* load_store, int flag, LIR_Opr mdp) {\n-  assert(md != NULL && load_store != NULL, \"should have been initialized\");\n-  if (mdp == NULL) {\n-    mdp = new_register(T_METADATA);\n-    __ metadata2reg(md->constant_encoding(), mdp);\n+void LIRGenerator::profile_flags(ciMethodData* md, ciProfileData* data, int flag, LIR_Condition condition) {\n+  assert(md != NULL && data != NULL, \"should have been initialized\");\n+  LIR_Opr mdp = new_register(T_METADATA);\n+  __ metadata2reg(md->constant_encoding(), mdp);\n+  LIR_Address* addr = new LIR_Address(mdp, md->byte_offset_of_slot(data, DataLayout::flags_offset()), T_BYTE);\n+  LIR_Opr flags = new_register(T_INT);\n+  __ move(addr, flags);\n+  if (condition != lir_cond_always) {\n+    LIR_Opr update = new_register(T_INT);\n+    __ cmove(condition, LIR_OprFact::intConst(0), LIR_OprFact::intConst(flag), update, T_INT);\n+  } else {\n+    __ logical_or(flags, LIR_OprFact::intConst(flag), flags);\n@@ -2994,5 +3001,1 @@\n-  LIR_Address* addr = new LIR_Address(mdp, md->byte_offset_of_slot(load_store, DataLayout::flags_offset()), T_BYTE);\n-  LIR_Opr id = new_register(T_INT);\n-  __ move(addr, id);\n-  __ logical_or(id, LIR_OprFact::intConst(flag), id);\n-  __ store(id, addr);\n+  __ store(flags, addr);\n@@ -3004,3 +3007,0 @@\n-  LIR_Opr mdp = new_register(T_METADATA);\n-  assert(md != NULL, \"should have been initialized\");\n-  __ metadata2reg(md->constant_encoding(), mdp);\n@@ -3008,1 +3008,0 @@\n-  __ branch(lir_cond_equal, L_end->label());\n@@ -3010,3 +3009,1 @@\n-  profile_array_load_store_flags(md, load_store, ArrayLoadStoreData::null_free_array_byte_constant(), mdp);\n-\n-  __ branch_destination(L_end->label());\n+  profile_flags(md, load_store, ArrayLoadStoreData::null_free_array_byte_constant(), lir_cond_equal);\n@@ -3752,0 +3749,47 @@\n+bool LIRGenerator::profile_inline_klass(ciMethodData* md, ciProfileData* data, Value value, int flag) {\n+  ciKlass* klass = value->as_loaded_klass_or_null();\n+  if (klass != NULL) {\n+    if (klass->is_inlinetype()) {\n+      profile_flags(md, data, flag, lir_cond_always);\n+    } else if (klass->can_be_inline_klass()) {\n+      return false;\n+    }\n+  } else {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\n+void LIRGenerator::do_ProfileACmpTypes(ProfileACmpTypes* x) {\n+  ciMethod* method = x->method();\n+  assert(method != NULL, \"method should be set if branch is profiled\");\n+  ciMethodData* md = method->method_data_or_null();\n+  assert(md != NULL, \"Sanity\");\n+  ciProfileData* data = md->bci_to_data(x->bci());\n+  assert(data != NULL, \"must have profiling data\");\n+  assert(data->is_ACmpData(), \"need BranchData for two-way branches\");\n+  ciACmpData* acmp = (ciACmpData*)data;\n+  LIR_Opr mdp = LIR_OprFact::illegalOpr;\n+  profile_type(md, md->byte_offset_of_slot(acmp, ACmpData::left_offset()), 0,\n+               acmp->left()->type(), x->left(), mdp, !x->left_maybe_null(), NULL, NULL);\n+  int flags_offset = md->byte_offset_of_slot(data, DataLayout::flags_offset());\n+  if (!profile_inline_klass(md, acmp, x->left(), ACmpData::left_inline_type_byte_constant())) {\n+    LIR_Opr mdp = new_register(T_METADATA);\n+    __ metadata2reg(md->constant_encoding(), mdp);\n+    LIRItem value(x->left(), this);\n+    value.load_item();\n+    __ profile_inline_type(new LIR_Address(mdp, flags_offset, T_INT), value.result(), ACmpData::left_inline_type_byte_constant(), new_register(T_INT), !x->left_maybe_null());\n+  }\n+  profile_type(md, md->byte_offset_of_slot(acmp, ACmpData::left_offset()),\n+               in_bytes(ACmpData::right_offset()) - in_bytes(ACmpData::left_offset()),\n+               acmp->right()->type(), x->right(), mdp, !x->right_maybe_null(), NULL, NULL);\n+  if (!profile_inline_klass(md, acmp, x->right(), ACmpData::right_inline_type_byte_constant())) {\n+    LIR_Opr mdp = new_register(T_METADATA);\n+    __ metadata2reg(md->constant_encoding(), mdp);\n+    LIRItem value(x->right(), this);\n+    value.load_item();\n+    __ profile_inline_type(new LIR_Address(mdp, flags_offset, T_INT), value.result(), ACmpData::right_inline_type_byte_constant(), new_register(T_INT), !x->left_maybe_null());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":63,"deletions":19,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-  void profile_array_load_store_flags(ciMethodData* md, ciArrayLoadStoreData* load_store, int flag, LIR_Opr mdp = NULL);\n+  void profile_flags(ciMethodData* md, ciProfileData* load_store, int flag, LIR_Condition condition = lir_cond_always);\n@@ -505,0 +505,1 @@\n+  bool profile_inline_klass(ciMethodData* md, ciProfileData* data, Value value, int flag);\n@@ -618,0 +619,1 @@\n+  virtual void do_ProfileACmpTypes(ProfileACmpTypes* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -546,0 +546,1 @@\n+  void do_ProfileACmpTypes(ProfileACmpTypes*  x);\n@@ -675,0 +676,1 @@\n+  void handle_ProfileACmpTypes(ProfileACmpTypes* x);\n@@ -738,0 +740,1 @@\n+void NullCheckVisitor::do_ProfileACmpTypes(ProfileACmpTypes* x) { nce()->handle_ProfileACmpTypes(x); }\n@@ -1172,0 +1175,5 @@\n+void NullCheckEliminator::handle_ProfileACmpTypes(ProfileACmpTypes* x) {\n+  x->set_left_maybe_null(!set_contains(x->left()));\n+  x->set_right_maybe_null(!set_contains(x->right()));\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+    void do_ProfileACmpTypes(ProfileACmpTypes*  x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -211,0 +211,1 @@\n+  void do_ProfileACmpTypes(ProfileACmpTypes*  x) { \/* nothing to do *\/ }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -709,0 +709,17 @@\n+bool ciMethod::acmp_profiled_type(int bci, ciKlass*& left_type, ciKlass*& right_type, ProfilePtrKind& left_ptr, ProfilePtrKind& right_ptr, bool &left_inline_type, bool &right_inline_type) {\n+  if (method_data() != NULL && method_data()->is_mature()) {\n+    ciProfileData* data = method_data()->bci_to_data(bci);\n+    if (data != NULL && data->is_ACmpData()) {\n+      ciACmpData* acmp = (ciACmpData*)data->as_ACmpData();\n+      left_type = acmp->left()->valid_type();\n+      right_type = acmp->right()->valid_type();\n+      left_ptr = acmp->left()->ptr_kind();\n+      right_ptr = acmp->right()->ptr_kind();\n+      left_inline_type = acmp->left_inline_type();\n+      right_inline_type = acmp->right_inline_type();\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  ProfileUnknownNull,\n@@ -268,1 +269,3 @@\n-\n+  bool          acmp_profiled_type(int bci, ciKlass*& left_type, ciKlass*& right_type,\n+                                   ProfilePtrKind& left_ptr, ProfilePtrKind& right_ptr,\n+                                   bool &left_inline_type, bool &right_inline_type);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -370,0 +370,2 @@\n+  case DataLayout::acmp_data_tag:\n+    return new ciACmpData(data_layout);\n@@ -919,0 +921,11 @@\n+\n+void ciACmpData::print_data_on(outputStream* st, const char* extra) const {\n+  BranchData::print_data_on(st, extra);\n+  st->cr();\n+  tab(st, true);\n+  st->print(\"left\");\n+  left()->print_data_on(st);\n+  tab(st, true);\n+  st->print(\"right\");\n+  right()->print_data_on(st);\n+}\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -382,0 +382,17 @@\n+class ciACmpData : public ACmpData {\n+public:\n+  ciACmpData(DataLayout* layout) : ACmpData(layout) {}\n+\n+  ciSingleTypeEntry* left() const { return (ciSingleTypeEntry*)ACmpData::left(); }\n+  ciSingleTypeEntry* right() const { return (ciSingleTypeEntry*)ACmpData::right(); }\n+\n+  virtual void translate_from(const ProfileData* data) {\n+    left()->translate_type_data_from(data->as_ACmpData()->left());\n+    right()->translate_type_data_from(data->as_ACmpData()->right());\n+  }\n+\n+#ifndef PRODUCT\n+  void print_data_on(outputStream* st, const char* extra = NULL) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -520,0 +520,1 @@\n+  declare_constant(DataLayout::acmp_data_tag)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -526,0 +526,4 @@\n+  if (data()->flags()) {\n+    tty->cr();\n+    tab(st);\n+  }\n@@ -660,0 +664,10 @@\n+void ACmpData::print_data_on(outputStream* st, const char* extra) const {\n+  BranchData::print_data_on(st, extra);\n+  tab(st, true);\n+  st->print(\"left\");\n+  _left.print_data_on(st);\n+  tab(st, true);\n+  st->print(\"right\");\n+  _right.print_data_on(st);\n+}\n+\n@@ -727,2 +741,0 @@\n-  case Bytecodes::_if_acmpeq:\n-  case Bytecodes::_if_acmpne:\n@@ -732,0 +744,3 @@\n+  case Bytecodes::_if_acmpne:\n+  case Bytecodes::_if_acmpeq:\n+    return ACmpData::static_cell_count();\n@@ -1078,2 +1093,0 @@\n-  case Bytecodes::_if_acmpeq:\n-  case Bytecodes::_if_acmpne:\n@@ -1085,0 +1098,5 @@\n+  case Bytecodes::_if_acmpeq:\n+  case Bytecodes::_if_acmpne:\n+    cell_count = ACmpData::static_cell_count();\n+    tag = DataLayout::acmp_data_tag;\n+    break;\n@@ -1154,0 +1172,2 @@\n+  case DataLayout::acmp_data_tag:\n+    return new ACmpData(this);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -127,1 +127,2 @@\n-    array_load_store_data_tag\n+    array_load_store_data_tag,\n+    acmp_data_tag\n@@ -260,0 +261,1 @@\n+class       ACmpData;\n@@ -395,0 +397,1 @@\n+  virtual bool is_ACmpData()          const { return false; }\n@@ -457,0 +460,4 @@\n+  ACmpData* as_ACmpData() const {\n+    assert(is_ACmpData(), \"wrong type\");\n+    return is_ACmpData() ? (ACmpData*)this : NULL;\n+  }\n@@ -615,1 +622,2 @@\n-      layout->tag() == DataLayout::branch_data_tag, \"wrong type\");\n+      layout->tag() == DataLayout::branch_data_tag ||\n+      layout->tag() == DataLayout::acmp_data_tag, \"wrong type\");\n@@ -1499,1 +1507,1 @@\n-    assert(layout->tag() == DataLayout::branch_data_tag, \"wrong type\");\n+    assert(layout->tag() == DataLayout::branch_data_tag || layout->tag() == DataLayout::acmp_data_tag, \"wrong type\");\n@@ -1929,0 +1937,73 @@\n+class ACmpData : public BranchData {\n+private:\n+  enum {\n+    left_inline_type_flag = DataLayout::first_flag,\n+    right_inline_type_flag\n+  };\n+\n+  SingleTypeEntry _left;\n+  SingleTypeEntry _right;\n+\n+public:\n+  ACmpData(DataLayout* layout) :\n+    BranchData(layout),\n+    _left(BranchData::static_cell_count()),\n+    _right(BranchData::static_cell_count() + SingleTypeEntry::static_cell_count()) {\n+    assert(layout->tag() == DataLayout::acmp_data_tag, \"wrong type\");\n+    _left.set_profile_data(this);\n+    _right.set_profile_data(this);\n+  }\n+\n+  const SingleTypeEntry* left() const {\n+    return &_left;\n+  }\n+\n+  const SingleTypeEntry* right() const {\n+    return &_right;\n+  }\n+\n+  virtual bool is_ACmpData() const { return true; }\n+\n+  static int static_cell_count() {\n+    return BranchData::static_cell_count()+ SingleTypeEntry::static_cell_count() * 2;\n+  }\n+\n+  virtual int cell_count() const {\n+    return static_cell_count();\n+  }\n+\n+  void set_left_inline_type() { set_flag_at(left_inline_type_flag); }\n+  bool left_inline_type() const { return flag_at(left_inline_type_flag); }\n+\n+  void set_right_inline_type() { set_flag_at(right_inline_type_flag); }\n+  bool right_inline_type() const { return flag_at(right_inline_type_flag); }\n+\n+  \/\/ Code generation support\n+  static int left_inline_type_byte_constant() {\n+    return flag_number_to_constant(left_inline_type_flag);\n+  }\n+\n+  static int right_inline_type_byte_constant() {\n+    return flag_number_to_constant(right_inline_type_flag);\n+  }\n+\n+  static ByteSize left_offset() {\n+    return cell_offset(BranchData::static_cell_count());\n+  }\n+\n+  static ByteSize right_offset() {\n+    return cell_offset(BranchData::static_cell_count() + SingleTypeEntry::static_cell_count());\n+  }\n+\n+  virtual void clean_weak_klass_links(bool always_clean) {\n+    _left.clean_weak_klass_links(always_clean);\n+    _right.clean_weak_klass_links(always_clean);\n+  }\n+\n+  static ByteSize acmp_data_size() {\n+    return cell_offset(static_cell_count());\n+  }\n+\n+  virtual void print_data_on(outputStream* st, const char* extra = NULL) const;\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":84,"deletions":3,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -777,0 +777,3 @@\n+  product(bool, UseACmpProfile, false,                                      \\\n+          \"Take advantage of profiling at acmp\")                            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2279,1 +2279,1 @@\n-    const TypePtr* ptr = (ptr_kind == ProfileMaybeNull && current_type->speculative_maybe_null()) ? TypePtr::BOTTOM : TypePtr::NOTNULL;\n+    const TypePtr* ptr = (ptr_kind != ProfileNeverNull && current_type->speculative_maybe_null()) ? TypePtr::BOTTOM : TypePtr::NOTNULL;\n@@ -3559,1 +3559,1 @@\n-Node* GraphKit::is_inline_type(Node* obj) {\n+Node* GraphKit::inline_type_test(Node* obj) {\n@@ -3564,2 +3564,9 @@\n-  Node* cmp = _gvn.transform(new CmpXNode(andx, mask));\n-  return _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  return _gvn.transform(new CmpXNode(andx, mask));\n+}\n+\n+Node* GraphKit::is_inline_type(Node* obj) {\n+  return _gvn.transform(new BoolNode(inline_type_test(obj), BoolTest::eq));\n+}\n+\n+Node* GraphKit::is_not_inline_type(Node* obj) {\n+  return _gvn.transform(new BoolNode(inline_type_test(obj), BoolTest::ne));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -856,0 +856,1 @@\n+  Node* inline_type_test(Node* obj);\n@@ -857,0 +858,1 @@\n+  Node* is_not_inline_type(Node* obj);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -553,0 +553,4 @@\n+  void    acmp_always_null_input(Node* input, const TypeOopPtr* tinput, BoolTest::mask btest, Node* eq_region);\n+  void    acmp_known_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, ciKlass* input_type, BoolTest::mask btest, Node* eq_region);\n+  Node*   acmp_null_check(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, Node*& null_ctl);\n+  void    acmp_unknown_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, BoolTest::mask btest, Node* eq_region);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2052,1 +2052,152 @@\n-void Parse::do_acmp(BoolTest::mask btest, Node* a, Node* b) {\n+\n+static ProfilePtrKind speculative_ptr_kind(const TypeOopPtr* t) {\n+  if (t->speculative() == NULL) {\n+    return ProfileUnknownNull;\n+  }\n+  if (t->speculative_always_null()) {\n+    return ProfileAlwaysNull;\n+  }\n+  if (t->speculative_maybe_null()) {\n+    return ProfileMaybeNull;\n+  }\n+  return ProfileNeverNull;\n+}\n+\n+void Parse::acmp_always_null_input(Node* input, const TypeOopPtr* tinput, BoolTest::mask btest, Node* eq_region) {\n+  inc_sp(2);\n+  Node* cast = null_check_common(input, T_OBJECT, true, NULL,\n+                                 !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check) &&\n+                                 speculative_ptr_kind(tinput) == ProfileAlwaysNull);\n+  dec_sp(2);\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      replace_in_map(input, cast);\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    replace_in_map(input, cast);\n+  }\n+}\n+\n+Node* Parse::acmp_null_check(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, Node*& null_ctl) {\n+  inc_sp(2);\n+  null_ctl = top();\n+  Node* cast = null_check_oop(input, &null_ctl,\n+                              input_ptr == ProfileNeverNull || (input_ptr == ProfileUnknownNull && !too_many_traps_or_recompiles(Deoptimization::Reason_null_check)),\n+                              false,\n+                              speculative_ptr_kind(tinput) == ProfileNeverNull &&\n+                              !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check));\n+  dec_sp(2);\n+  assert(!stopped(), \"null input should have been caught earlier\");\n+  return cast;\n+}\n+\n+void Parse::acmp_known_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, ciKlass* input_type, BoolTest::mask btest, Node* eq_region) {\n+  Node* ne_region = new RegionNode(1);\n+  Node* null_ctl;\n+  Node* cast = acmp_null_check(input, tinput, input_ptr, null_ctl);\n+  ne_region->add_req(null_ctl);\n+\n+  Node* slow_ctl = type_check_receiver(cast, input_type, 1.0, &cast);\n+  {\n+    PreserveJVMState pjvms(this);\n+    inc_sp(2);\n+    set_control(slow_ctl);\n+    Deoptimization::DeoptReason reason;\n+    if (tinput->speculative_type() != NULL && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+      reason = Deoptimization::Reason_speculate_class_check;\n+    } else {\n+      reason = Deoptimization::Reason_class_check;\n+    }\n+    uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+  }\n+  ne_region->add_req(control());\n+\n+  record_for_igvn(ne_region);\n+  set_control(_gvn.transform(ne_region));\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      if (null_ctl == top()) {\n+        replace_in_map(input, cast);\n+      }\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    if (null_ctl == top()) {\n+      replace_in_map(input, cast);\n+    }\n+    set_control(_gvn.transform(ne_region));\n+  }\n+}\n+\n+void Parse::acmp_unknown_non_inline_type_input(Node* input, const TypeOopPtr* tinput, ProfilePtrKind input_ptr, BoolTest::mask btest, Node* eq_region) {\n+  Node* ne_region = new RegionNode(1);\n+  Node* null_ctl;\n+  Node* cast = acmp_null_check(input, tinput, input_ptr, null_ctl);\n+  ne_region->add_req(null_ctl);\n+\n+  {\n+    BuildCutout unless(this, is_not_inline_type(cast), PROB_MAX);\n+    inc_sp(2);\n+    uncommon_trap_exact(Deoptimization::Reason_class_check, Deoptimization::Action_maybe_recompile);\n+  }\n+\n+  ne_region->add_req(control());\n+\n+  record_for_igvn(ne_region);\n+  set_control(_gvn.transform(ne_region));\n+  if (btest == BoolTest::ne) {\n+    {\n+      PreserveJVMState pjvms(this);\n+      if (null_ctl == top()) {\n+        replace_in_map(input, cast);\n+      }\n+      int target_bci = iter().get_dest();\n+      merge(target_bci);\n+    }\n+    record_for_igvn(eq_region);\n+    set_control(_gvn.transform(eq_region));\n+  } else {\n+    if (null_ctl == top()) {\n+      replace_in_map(input, cast);\n+    }\n+    set_control(_gvn.transform(ne_region));\n+  }\n+}\n+\n+void Parse::do_acmp(BoolTest::mask btest, Node* right, Node* left) {\n+  ciKlass* left_type = NULL;\n+  ciKlass* right_type = NULL;\n+  ProfilePtrKind left_ptr = ProfileUnknownNull;\n+  ProfilePtrKind right_ptr = ProfileUnknownNull;\n+  bool left_inline_type = true;\n+  bool right_inline_type = true;\n+\n+  \/\/ Leverage profiling at acmp\n+  if (UseACmpProfile) {\n+    method()->acmp_profiled_type(bci(), left_type, right_type, left_ptr, right_ptr, left_inline_type, right_inline_type);\n+    if (too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {\n+      left_type = NULL;\n+      right_type = NULL;\n+      left_inline_type = true;\n+      right_inline_type = true;\n+    }\n+    if (too_many_traps_or_recompiles(Deoptimization::Reason_null_check)) {\n+      left_ptr = ProfileUnknownNull;\n+      right_ptr = ProfileUnknownNull;\n+    }\n+  }\n+\n+ if (UseTypeSpeculation) {\n+    record_profile_for_speculation(left, left_type, left_ptr);\n+    record_profile_for_speculation(right, right_type, right_ptr);\n+  }\n+\n@@ -2054,1 +2205,1 @@\n-    Node* cmp = CmpP(a, b);\n+    Node* cmp = CmpP(right, left);\n@@ -2061,1 +2212,1 @@\n-  if (a->is_InlineType()) {\n+  if (right->is_InlineType()) {\n@@ -2065,1 +2216,1 @@\n-    a = a->as_InlineType()->buffer(this)->get_oop();\n+    right = right->as_InlineType()->buffer(this)->get_oop();\n@@ -2067,1 +2218,1 @@\n-  if (b->is_InlineType()) {\n+  if (left->is_InlineType()) {\n@@ -2071,1 +2222,1 @@\n-    b = b->as_InlineType()->buffer(this)->get_oop();\n+    left = left->as_InlineType()->buffer(this)->get_oop();\n@@ -2075,3 +2226,3 @@\n-  const TypeOopPtr* ta = _gvn.type(a)->isa_oopptr();\n-  const TypeOopPtr* tb = _gvn.type(b)->isa_oopptr();\n-  Node* cmp = CmpP(a, b);\n+  const TypeOopPtr* tright = _gvn.type(right)->isa_oopptr();\n+  const TypeOopPtr* tleft = _gvn.type(left)->isa_oopptr();\n+  Node* cmp = CmpP(right, left);\n@@ -2079,2 +2230,2 @@\n-  if (ta == NULL || !ta->can_be_inline_type() ||\n-      tb == NULL || !tb->can_be_inline_type()) {\n+  if (tright == NULL || !tright->can_be_inline_type() ||\n+      tleft == NULL || !tleft->can_be_inline_type()) {\n@@ -2110,18 +2261,7 @@\n-  \/\/ Pointers are not equal, check if first operand is non-null\n-  Node* ne_region = new RegionNode(6);\n-  inc_sp(2);\n-  Node* null_ctl = top();\n-  Node* not_null_a = null_check_oop(a, &null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);\n-  dec_sp(2);\n-  ne_region->init_req(1, null_ctl);\n-  if (stopped()) {\n-    record_for_igvn(ne_region);\n-    set_control(_gvn.transform(ne_region));\n-    if (btest == BoolTest::ne) {\n-      {\n-        PreserveJVMState pjvms(this);\n-        int target_bci = iter().get_dest();\n-        merge(target_bci);\n-      }\n-      record_for_igvn(eq_region);\n-      set_control(_gvn.transform(eq_region));\n+  \/\/ Prefer speculative types if available\n+  if (!too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {\n+    if (tleft->speculative_type() != NULL) {\n+      left_type = tleft->speculative_type();\n+    }\n+    if (tright->speculative_type() != NULL) {\n+      right_type = tright->speculative_type();\n@@ -2129,0 +2269,47 @@\n+  }\n+\n+  if (speculative_ptr_kind(tleft) != ProfileMaybeNull && speculative_ptr_kind(tleft) != ProfileUnknownNull) {\n+    ProfilePtrKind speculative_left_ptr = speculative_ptr_kind(tleft);\n+    if (speculative_left_ptr == ProfileAlwaysNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_assert)) {\n+      left_ptr = speculative_left_ptr;\n+    } else if (speculative_left_ptr == ProfileNeverNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check)) {\n+      left_ptr = speculative_left_ptr;\n+    }\n+  }\n+  if (speculative_ptr_kind(tright) != ProfileMaybeNull && speculative_ptr_kind(tright) != ProfileUnknownNull) {\n+    ProfilePtrKind speculative_right_ptr = speculative_ptr_kind(tright);\n+    if (speculative_right_ptr == ProfileAlwaysNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_assert)) {\n+      right_ptr = speculative_right_ptr;\n+    } else if (speculative_right_ptr == ProfileNeverNull && !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_null_check)) {\n+      right_ptr = speculative_right_ptr;\n+    }\n+  }\n+\n+  if (left_ptr == ProfileAlwaysNull) {\n+    \/\/ Comparison with null. Assert the input is indeed null and we're done.\n+    acmp_always_null_input(left, tleft, btest, eq_region);\n+    return;\n+  }\n+  if (right_ptr == ProfileAlwaysNull) {\n+    \/\/ Comparison with null. Assert the input is indeed null and we're done.\n+    acmp_always_null_input(right, tright, btest, eq_region);\n+    return;\n+  }\n+  if (left_type != NULL && !left_type->is_inlinetype()) {\n+    \/\/ Comparison with an object of known type\n+    acmp_known_non_inline_type_input(left, tleft, left_ptr, left_type, btest, eq_region);\n+    return;\n+  }\n+  if (right_type != NULL && !right_type->is_inlinetype()) {\n+    \/\/ Comparison with an object of known type\n+    acmp_known_non_inline_type_input(right, tright, right_ptr, right_type, btest, eq_region);\n+    return;\n+  }\n+  if (!left_inline_type) {\n+    \/\/ Comparison with an object of known not to be an inline type\n+    acmp_unknown_non_inline_type_input(left, tleft, left_ptr, btest, eq_region);\n+    return;\n+  }\n+  if (!right_inline_type) {\n+    \/\/ Comparison with an object of known not to be an inline type\n+    acmp_unknown_non_inline_type_input(right, tright, right_ptr, btest, eq_region);\n@@ -2132,0 +2319,6 @@\n+  \/\/ Pointers are not equal, check if first operand is non-null\n+  Node* ne_region = new RegionNode(6);\n+  Node* null_ctl;\n+  Node* not_null_right = acmp_null_check(right, tright, right_ptr, null_ctl);\n+  ne_region->init_req(1, null_ctl);\n+\n@@ -2133,1 +2326,1 @@\n-  Node* is_value = is_inline_type(not_null_a);\n+  Node* is_value = is_inline_type(not_null_right);\n@@ -2140,4 +2333,1 @@\n-  inc_sp(2);\n-  null_ctl = top();\n-  Node* not_null_b = null_check_oop(b, &null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);\n-  dec_sp(2);\n+  Node* not_null_left = acmp_null_check(left, tleft, left_ptr, null_ctl);\n@@ -2145,14 +2335,0 @@\n-  if (stopped()) {\n-    record_for_igvn(ne_region);\n-    set_control(_gvn.transform(ne_region));\n-    if (btest == BoolTest::ne) {\n-      {\n-        PreserveJVMState pjvms(this);\n-        int target_bci = iter().get_dest();\n-        merge(target_bci);\n-      }\n-      record_for_igvn(eq_region);\n-      set_control(_gvn.transform(eq_region));\n-    }\n-    return;\n-  }\n@@ -2161,3 +2337,3 @@\n-  Node* kls_a = load_object_klass(not_null_a);\n-  Node* kls_b = load_object_klass(not_null_b);\n-  Node* kls_cmp = CmpP(kls_a, kls_b);\n+  Node* kls_right = load_object_klass(not_null_right);\n+  Node* kls_left = load_object_klass(not_null_left);\n+  Node* kls_cmp = CmpP(kls_left, kls_right);\n@@ -2204,2 +2380,2 @@\n-  call->init_req(TypeFunc::Parms, not_null_a);\n-  call->init_req(TypeFunc::Parms+1, not_null_b);\n+  call->init_req(TypeFunc::Parms, not_null_left);\n+  call->init_req(TypeFunc::Parms+1, not_null_right);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":229,"deletions":53,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+            new UnknownProfileData(this, config.dataLayoutACmpDataTag),\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        assert tag >= config.dataLayoutNoTag && tag <= config.dataLayoutArrayLoadStoreDataTag : \"profile data tag out of bounds: \" + tag;\n+        assert tag >= config.dataLayoutNoTag && tag <= config.dataLayoutACmpDataTag : \"profile data tag out of bounds: \" + tag;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMethodDataAccessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,0 +315,1 @@\n+    final int dataLayoutACmpDataTag = getConstant(\"DataLayout::acmp_data_tag\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -183,0 +183,2 @@\n+    protected static final int ACmpProfileOn = 0x10000;\n+    protected static final int ACmpProfileOff = 0x20000;\n@@ -192,0 +194,1 @@\n+    protected static final boolean UseACmpProfile = (Boolean)WHITE_BOX.getVMFlag(\"UseACmpProfile\");\n@@ -227,0 +230,1 @@\n+    protected static final String NULL_ASSERT_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*null_assert\" + END;\n@@ -234,0 +238,1 @@\n+    protected static final String SUBSTITUTABLITY_TEST = START + \"CallStaticJava\" + MID + \"java.lang.invoke.ValueBootstrapMethods::isSubstitutable\" + END;\n@@ -267,0 +272,1 @@\n+                \"-XX:-UseACmpProfile\",\n@@ -275,0 +281,1 @@\n+                \"-XX:-UseACmpProfile\",\n@@ -283,0 +290,1 @@\n+                \"-XX:-UseACmpProfile\",\n@@ -292,0 +300,1 @@\n+                \"-XX:-UseACmpProfile\",\n@@ -301,0 +310,1 @@\n+                \"-XX:-UseACmpProfile\",\n@@ -310,0 +320,1 @@\n+                \"-XX:-UseACmpProfile\",\n@@ -507,0 +518,2 @@\n+            new TestAnnotation(ACmpProfileOn, () -> UseACmpProfile),\n+            new TestAnnotation(ACmpProfileOff, () -> !UseACmpProfile),\n@@ -826,2 +839,17 @@\n-    \/\/ Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to\n-    \/\/ a normal method invocation when encountering flattened arrays.\n+    enum TriState {\n+        Maybe,\n+        Yes,\n+        No\n+    }\n+\n+    static private TriState compiledByC2(Method m) {\n+        if (!USE_COMPILER || XCOMP || TEST_C1) {\n+            return TriState.Maybe;\n+        }\n+        if (WHITE_BOX.isMethodCompiled(m, false) &&\n+            WHITE_BOX.getMethodCompilationLevel(m, false) >= COMP_LEVEL_FULL_OPTIMIZATION) {\n+            return TriState.Yes;\n+        }\n+        return TriState.No;\n+    }\n+\n@@ -829,2 +857,13 @@\n-        return USE_COMPILER && !XCOMP && WHITE_BOX.isMethodCompiled(m, false) &&\n-            WHITE_BOX.getMethodCompilationLevel(m, false) >= COMP_LEVEL_FULL_OPTIMIZATION;\n+        return compiledByC2(m) == TriState.Yes;\n+    }\n+\n+    static void assertDeoptimizedByC2(Method m) {\n+        if (compiledByC2(m) == TriState.Yes) {\n+            throw new RuntimeException(\"Expected to have deoptimized\");\n+        }\n+    }\n+\n+    static void assertCompiledByC2(Method m) {\n+        if (compiledByC2(m) == TriState.No) {\n+            throw new RuntimeException(\"Expected to be compiled\");\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeTest.java","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -45,15 +45,0 @@\n-    \/\/ Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to\n-    \/\/ a normal method invocation when encountering flattened arrays.\n-    private static void assertDeoptimizedByC2(Method m) {\n-        int CompLevel_none              = 0,         \/\/ Interpreter\n-            CompLevel_simple            = 1,         \/\/ C1\n-            CompLevel_limited_profile   = 2,         \/\/ C1, invocation & backedge counters\n-            CompLevel_full_profile      = 3,         \/\/ C1, invocation & backedge counters + mdo\n-            CompLevel_full_optimization = 4;         \/\/ C2 or JVMCI\n-\n-        if (USE_COMPILER && !XCOMP && !STRESS_CC && WHITE_BOX.isMethodCompiled(m, false) &&\n-            WHITE_BOX.getMethodCompilationLevel(m, false) >= CompLevel_full_optimization) {\n-            throw new RuntimeException(\"Type check should have caused it to deoptimize\");\n-        }\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3308,0 +3308,26 @@\n+\n+    \/\/ acmp doesn't need substitutablity test when one input is known\n+    \/\/ not to be a value type\n+    @Test(failOn = SUBSTITUTABLITY_TEST)\n+    public boolean test120(Integer o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test120_verifier(boolean warmup) {\n+        test120(42, 42);\n+        test120(42, testValue1);\n+    }\n+\n+    \/\/ acmp doesn't need substitutablity test when one input null\n+    @Test(failOn = SUBSTITUTABLITY_TEST)\n+    public boolean test121(Object o1) {\n+        Object o2 = null;\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test121_verifier(boolean warmup) {\n+        test121(testValue1);\n+        test121(null);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+         \"-XX:-UseACmpProfile\",\n@@ -50,0 +51,1 @@\n+          \"-XX:+UseACmpProfile\",\n@@ -52,0 +54,1 @@\n+          \"-XX:-UseACmpProfile\",\n@@ -55,0 +58,1 @@\n+          \"-XX:-UseACmpProfile\",\n@@ -59,0 +63,1 @@\n+          \"-XX:+UseACmpProfile\",\n@@ -62,0 +67,1 @@\n+          \"-XX:-UseACmpProfile\",\n@@ -483,0 +489,427 @@\n+\n+    \/\/ acmp tests\n+\n+    \/\/ branch frequency profiling causes not equal branch to be optimized out\n+    @Warmup(10000)\n+    @Test(failOn = SUBSTITUTABLITY_TEST)\n+    public boolean test21(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test21_verifier(boolean warmup) {\n+        test21(42, 42);\n+        test21(testValue1, testValue1);\n+    }\n+\n+    \/\/ Input profiled non null\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_ASSERT_TRAP }, matchCount = { 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test22(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test22_verifier(boolean warmup) {\n+        test22(42, null);\n+        test22(42.0, null);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test22\"));\n+            test22(42, 42.0);\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test22\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_ASSERT_TRAP }, matchCount = { 1})\n+    @Test(valid = TypeProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_ASSERT_TRAP }, matchCount = { 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test23(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test23_verifier(boolean warmup) {\n+        test23(null, 42);\n+        test23(null, 42.0);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test23\"));\n+            test23(42, 42.0);\n+            if (UseACmpProfile || TypeProfileLevel != 0) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test23\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_ASSERT_TRAP }, matchCount = { 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test24(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @DontCompile\n+    public void test24_verifier(boolean warmup) {\n+        test24(42, null);\n+        test24(42.0, null);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test24\"));\n+            test24(42, 42.0);\n+             if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test24\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_ASSERT_TRAP }, matchCount = { 1})\n+    @Test(valid = TypeProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_ASSERT_TRAP }, matchCount = { 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test25(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @DontCompile\n+    public void test25_verifier(boolean warmup) {\n+        test25(null, 42);\n+        test25(null, 42.0);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test25\"));\n+            test25(42, 42.0);\n+            if (UseACmpProfile || TypeProfileLevel != 0) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test25\"));\n+            }\n+        }\n+    }\n+\n+    \/\/ Input profiled not inline type with known type\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(valid = TypeProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test26(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test26_verifier(boolean warmup) {\n+        test26(42, 42);\n+        test26(42, 42.0);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test26\"));\n+            for (int i = 0; i < 10; i++) {\n+                test26(42.0, 42);\n+            }\n+            if (UseACmpProfile || TypeProfileLevel != 0) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test26\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test27(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test27_verifier(boolean warmup) {\n+        test27(42, 42);\n+        test27(42.0, 42);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test27\"));\n+            for (int i = 0; i < 10; i++) {\n+                test27(42, 42.0);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test27\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(valid = TypeProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test28(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @DontCompile\n+    public void test28_verifier(boolean warmup) {\n+        test28(42, 42);\n+        test28(42, 42.0);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test28\"));\n+            for (int i = 0; i < 10; i++) {\n+                test28(42.0, 42);\n+            }\n+            if (UseACmpProfile || TypeProfileLevel != 0) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test28\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test29(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @DontCompile\n+    public void test29_verifier(boolean warmup) {\n+        test29(42, 42);\n+        test29(42.0, 42);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test29\"));\n+            for (int i = 0; i < 10; i++) {\n+                test29(42, 42.0);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test29\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST + NULL_CHECK_TRAP, match = { CLASS_CHECK_TRAP }, matchCount = { 1})\n+    @Test(valid = TypeProfileOn, failOn = SUBSTITUTABLITY_TEST + NULL_CHECK_TRAP, match = { CLASS_CHECK_TRAP }, matchCount = { 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test30(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test30_verifier(boolean warmup) {\n+        test30(42, 42);\n+        test30(42, 42.0);\n+        test30(null, 42);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test30\"));\n+            for (int i = 0; i < 10; i++) {\n+                test30(42.0, 42);\n+            }\n+            if (UseACmpProfile || TypeProfileLevel != 0) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test30\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST + NULL_CHECK_TRAP)\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test31(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test31_verifier(boolean warmup) {\n+        test31(42, 42);\n+        test31(42.0, 42);\n+        test31(42, null);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test31\"));\n+            for (int i = 0; i < 10; i++) {\n+                test31(42, 42.0);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test31\"));\n+            }\n+        }\n+    }\n+\n+    \/\/ Input profiled not inline type with unknown type\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test32(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test32_verifier(boolean warmup) {\n+        test32(42, 42);\n+        test32(42, testValue1);\n+        test32(42.0, 42);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test32\"));\n+            for (int i = 0; i < 10; i++) {\n+                test32(testValue1, 42);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test32\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test33(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test33_verifier(boolean warmup) {\n+        test33(42, 42);\n+        test33(testValue1, 42);\n+        test33(42, 42.0);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test33\"));\n+            for (int i = 0; i < 10; i++) {\n+                test33(42, testValue1);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test33\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test34(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @DontCompile\n+    public void test34_verifier(boolean warmup) {\n+        test34(42, 42);\n+        test34(42, testValue1);\n+        test34(42.0, 42);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test34\"));\n+            for (int i = 0; i < 10; i++) {\n+                test34(testValue1, 42);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test34\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { NULL_CHECK_TRAP, CLASS_CHECK_TRAP }, matchCount = { 1, 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test35(Object o1, Object o2) {\n+        return o1 != o2;\n+    }\n+\n+    @DontCompile\n+    public void test35_verifier(boolean warmup) {\n+        test35(42, 42);\n+        test35(testValue1, 42);\n+        test35(42, 42.0);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test35\"));\n+            for (int i = 0; i < 10; i++) {\n+                test35(42, testValue1);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test35\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST + NULL_CHECK_TRAP, match = { CLASS_CHECK_TRAP }, matchCount = { 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test36(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test36_verifier(boolean warmup) {\n+        test36(42, 42.0);\n+        test36(42.0, testValue1);\n+        test36(null, 42);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test36\"));\n+            for (int i = 0; i < 10; i++) {\n+                test36(testValue1, 42);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test36\"));\n+            }\n+        }\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST + NULL_CHECK_TRAP)\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1})\n+    public boolean test37(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @DontCompile\n+    public void test37_verifier(boolean warmup) {\n+        test37(42.0, 42);\n+        test37(testValue1, 42.0);\n+        test37(42, null);\n+        if (!warmup) {\n+            assertCompiledByC2(tests.get(\"TestLWorldProfiling::test37\"));\n+            for (int i = 0; i < 10; i++) {\n+                test37(42, testValue1);\n+            }\n+            if (UseACmpProfile) {\n+                assertDeoptimizedByC2(tests.get(\"TestLWorldProfiling::test37\"));\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that acmp profile data that's unused at the acmp is fed to\n+    \/\/ speculation and leverage later\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { CLASS_CHECK_TRAP }, matchCount = { 1})\n+    @Test(valid = TypeProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { CLASS_CHECK_TRAP }, matchCount = { 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1 })\n+    public void test38(Object o1, Object o2, Object o3) {\n+        if (o1 == o2) {\n+            test38_helper2();\n+        }\n+        test38_helper(o1, o3);\n+    }\n+\n+    public void test38_helper(Object o1, Object o2) {\n+        if (o1 == o2) {\n+        }\n+    }\n+\n+    public void test38_helper2() {\n+    }\n+\n+    @DontCompile\n+    public void test38_verifier(boolean warmup) {\n+        test38(42, 42, 42);\n+        test38_helper(testValue1, testValue2);\n+    }\n+\n+    @Warmup(10000)\n+    @Test(valid = ACmpProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { CLASS_CHECK_TRAP }, matchCount = { 1})\n+    @Test(valid = TypeProfileOn, failOn = SUBSTITUTABLITY_TEST, match = { CLASS_CHECK_TRAP }, matchCount = { 1})\n+    @Test(match = { SUBSTITUTABLITY_TEST }, matchCount = { 1 })\n+    public void test39(Object o1, Object o2, Object o3) {\n+        if (o1 == o2) {\n+            test39_helper2();\n+        }\n+        test39_helper(o2, o3);\n+    }\n+\n+    public void test39_helper(Object o1, Object o2) {\n+        if (o1 == o2) {\n+        }\n+    }\n+\n+    public void test39_helper2() {\n+    }\n+\n+    @DontCompile\n+    public void test39_verifier(boolean warmup) {\n+        test39(42, 42, 42);\n+        test39_helper(testValue1, testValue2);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":433,"deletions":0,"binary":false,"changes":433,"status":"modified"},{"patch":"@@ -44,8 +44,0 @@\n-    \/\/ Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to\n-    \/\/ a normal method invocation when encountering flattened arrays.\n-    private static void assertDeoptimizedByC2(Method m) {\n-        if (isCompiledByC2(m)) {\n-            throw new RuntimeException(\"Type check should have caused it to deoptimize\");\n-        }\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}