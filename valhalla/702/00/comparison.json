{"files":[{"patch":"@@ -2325,70 +2325,0 @@\n-    public boolean isIdentityType(Type t) {\n-        if (t.isPrimitiveClass() || t.isReferenceProjection() || t.isValueClass() || t.isValueInterface()) {\n-            return false;\n-        }\n-        if (t.tsym == syms.objectType.tsym) {\n-            return false;\n-        }\n-        if (t.hasTag(ARRAY))\n-            return true;\n-        if (t.hasTag(CLASS) && !t.isValueClass() && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n-            return true;\n-        }\n-        if (implicitIdentityType(t)) {\n-            return true;\n-        }\n-        return false;\n-    }\n-        \/\/ where\n-        private boolean implicitIdentityType(Type t) {\n-            \/* An abstract class can be declared with the identity\/value modifier;\n-             * or, if it declares a field, an instance initializer, a non-empty constructor, or\n-             * a synchronized instance method, it implicitly is an Identity type.\n-             *\/\n-            if (!t.tsym.isAbstract())\n-                return false;\n-\n-            for (; t != Type.noType; t = supertype(t)) {\n-\n-                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n-                    return false;\n-\n-                if  (t.tsym == syms.objectType.tsym)\n-                    return false;\n-\n-                if (!t.tsym.isAbstract()) {\n-                    return !t.tsym.isPrimitiveClass();\n-                }\n-\n-                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n-                    return true;\n-                }\n-\n-                \/\/ No instance fields and no arged constructors both mean inner classes cannot be primitive class supers.\n-                Type encl = t.getEnclosingType();\n-                if (encl != null && encl.hasTag(CLASS)) {\n-                    return true;\n-                }\n-                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n-                    switch (s.kind) {\n-                        case VAR:\n-                            if ((s.flags() & STATIC) == 0) {\n-                                return true;\n-                            }\n-                            break;\n-                        case MTH:\n-                            if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n-                                return true;\n-                            } else if (s.isConstructor()) {\n-                                MethodSymbol m = (MethodSymbol)s;\n-                                if (m.getParameters().size() > 0 || (m.flags() & EMPTYNOARGCONSTR) == 0) {\n-                                    return true;\n-                                }\n-                            }\n-                            break;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -5534,1 +5534,1 @@\n-                if ((c.flags() & (VALUE_CLASS | ABSTRACT)) == VALUE_CLASS) { \/\/ for non-intersection, concrete primitive\/value classes.\n+                if (c.isValueClass()) {\n@@ -5536,4 +5536,1 @@\n-                    JCClassDecl classDecl = (JCClassDecl) env.tree;\n-                    if (classDecl.extending != null) {\n-                        chk.checkSuperConstraintsOfValueClass(env.tree.pos(), c);\n-                    }\n+                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -751,2 +751,2 @@\n-    void checkSuperConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n-        for(Type st = types.supertype(c.type); st != Type.noType; st = types.supertype(st)) {\n+    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+        for (Type st : types.closure(c.type)) {\n@@ -754,3 +754,3 @@\n-                return;\n-            if  (st.tsym == syms.objectType.tsym)\n-                return;\n+                continue;\n+            if  (st.tsym == syms.objectType.tsym || st.isInterface())\n+                continue;\n@@ -758,4 +758,4 @@\n-                log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n-            }\n-            if ((st.tsym.flags() & IDENTITY_TYPE) == 0) {\n-                return;\n+                if (c != st.tsym) {\n+                    log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n+                }\n+                continue;\n@@ -763,2 +763,2 @@\n-            \/\/ TODO: If an IDENTITY_TYPE we may not issue an error below, if older abstract class qualifies\n-            \/\/ We have an unsuitable abstract super class, find out why exactly and complain\n+            \/\/ dealing with an abstract value or value super class below.\n+            Fragment fragment = c.isAbstract() && c.isValueClass() && c == st.tsym ? Fragments.AbstractValueClass(c) : Fragments.SuperclassOfValueClass(c, st);\n@@ -766,1 +766,1 @@\n-                log.error(pos, Errors.SuperClassDeclaresInitBlock(c, st));\n+                log.error(pos, Errors.SuperClassDeclaresInitBlock(fragment));\n@@ -772,1 +772,1 @@\n-                log.error(pos, Errors.SuperClassCannotBeInner(c, st));\n+                log.error(pos, Errors.SuperClassCannotBeInner(fragment));\n@@ -778,1 +778,1 @@\n-                        log.error(pos, Errors.SuperFieldNotAllowed(s, c, st));\n+                        log.error(pos, Errors.SuperFieldNotAllowed(s, fragment));\n@@ -782,1 +782,1 @@\n-                    if ((s.flags() & SYNCHRONIZED) != 0) {\n+                    if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n@@ -787,1 +787,1 @@\n-                            log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, c, st));\n+                            log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, fragment));\n@@ -790,1 +790,1 @@\n-                                log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, c, st));\n+                                log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, fragment));\n@@ -2769,6 +2769,7 @@\n-            List<Type> superTypes = types.closure(c);\n-            for (Type superType : superTypes) {\n-                if (cIsValue && (superType.tsym.flags() & IDENTITY_TYPE) != 0) {\n-                    log.error(pos, Errors.ValueTypeHasIdentitySuperType(c, superType));\n-                } else if (cHasIdentity && (superType.tsym.flags() & VALUE_CLASS) != 0) {\n-                    log.error(pos, Errors.IdentityTypeHasValueSuperType(c, superType));\n+            for (Type t : types.closure(c)) {\n+                if (t != c) {\n+                    if (cIsValue && (t.tsym.flags() & IDENTITY_TYPE) != 0) {\n+                        log.error(pos, Errors.ValueTypeHasIdentitySuperType(c, t));\n+                    } else if (cHasIdentity && (t.tsym.flags() & VALUE_CLASS) != 0) {\n+                        log.error(pos, Errors.IdentityTypeHasValueSuperType(c, t));\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;\n@@ -1106,2 +1107,2 @@\n-                if ((tree.sym.flags() & (ABSTRACT | INTERFACE)) == ABSTRACT) {\n-                    if (types.isIdentityType(tree.sym.type)) {\n+                if ((tree.sym.flags() & (ABSTRACT | IDENTITY_TYPE | INTERFACE)) == ABSTRACT) {\n+                    if (abstractClassHasImplicitIdentity(tree)) {\n@@ -1114,0 +1115,40 @@\n+            \/\/ where\n+            private boolean abstractClassHasImplicitIdentity(JCClassDecl tree) {\n+\n+                Type t = tree.sym.type;\n+\n+                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n+                    return false;\n+\n+                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n+                    return true;\n+                }\n+\n+                \/\/ No instance fields and no arged constructors both mean inner classes cannot be value class supers.\n+                Type encl = t.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    return true;\n+                }\n+                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0) {\n+                                return true;\n+                            }\n+                            break;\n+                        case MTH:\n+                            if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n+                                return true;\n+                            } else if (s.isConstructor()) {\n+                                MethodSymbol m = (MethodSymbol)s;\n+                                if (m.getParameters().size() > 0 || (m.flags() & EMPTYNOARGCONSTR) == 0) {\n+                                    return true;\n+                                }\n+                            }\n+                            break;\n+                    }\n+                }\n+                return false;\n+            }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -3968,1 +3968,1 @@\n-# 0: symbol, 1: symbol, 2: type\n+# 0: symbol, 1: message segment\n@@ -3970,1 +3970,1 @@\n-    The super class {2} of the value class {1} defines a constructor {0} that takes arguments. This is disallowed\n+    {1} defines a constructor {0} that takes arguments. This is disallowed\n@@ -3972,1 +3972,1 @@\n-# 0: symbol, 1: symbol, 2: type\n+# 0: symbol, 1: message segment\n@@ -3974,1 +3974,1 @@\n-    The super class {2} of the value class {1} defines an instance field {0}. This is disallowed\n+    {1} defines an instance field {0}. This is disallowed\n@@ -3976,1 +3976,1 @@\n-# 0: symbol, 1: symbol, 2: type\n+# 0: symbol, 1: message segment\n@@ -3978,1 +3978,1 @@\n-    The super class {2} of the value class {1} defines a nonempty no-arg constructor {0}. This is disallowed\n+    {1} defines a nonempty no-arg constructor {0}. This is disallowed\n@@ -3980,1 +3980,1 @@\n-# 0: symbol, 1: type\n+# 0: message segment\n@@ -3982,1 +3982,1 @@\n-    The super class {1} of the value class {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n+    {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n@@ -3984,1 +3984,1 @@\n-# 0: symbol, 1: type\n+# 0: message segment\n@@ -3986,1 +3986,9 @@\n-    The super class {1} of the value class {0} is an inner class. This is disallowed.\n+    {0} is an inner class. This is disallowed.\n+\n+# 0: symbol, 1: type\n+compiler.misc.superclass.of.value.class=\\\n+    The super class {1} of the value class {0}\n+\n+# 0: symbol\n+compiler.misc.abstract.value.class=\\\n+    The abstract value class {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -227,0 +227,2 @@\n+compiler.misc.abstract.value.class\n+compiler.misc.superclass.of.value.class\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n- * @ignore\n","filename":"test\/langtools\/tools\/javac\/processing\/rounds\/OverwriteBetweenCompilations.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,4 +2,4 @@\n-BinarySuperclassConstraints.java:29:15: compiler.err.super.field.not.allowed: x, BinarySuperclassConstraints.I6, SuperclassCollections.SuperWithInstanceField\n-BinarySuperclassConstraints.java:38:15: compiler.err.super.no.arg.constructor.must.be.empty: SuperclassCollections.SuperWithNonEmptyNoArgCtor(), BinarySuperclassConstraints.I9, SuperclassCollections.SuperWithNonEmptyNoArgCtor\n-BinarySuperclassConstraints.java:40:15: compiler.err.super.constructor.cannot.take.arguments: SuperclassCollections.SuperWithArgedCtor(java.lang.String), BinarySuperclassConstraints.I10, SuperclassCollections.SuperWithArgedCtor\n-BinarySuperclassConstraints.java:42:15: compiler.err.super.no.arg.constructor.must.be.empty: SuperclassCollections.SuperWithInstanceInit(), BinarySuperclassConstraints.I11, SuperclassCollections.SuperWithInstanceInit\n+BinarySuperclassConstraints.java:29:15: compiler.err.super.field.not.allowed: x, (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I6, SuperclassCollections.SuperWithInstanceField)\n+BinarySuperclassConstraints.java:38:15: compiler.err.super.no.arg.constructor.must.be.empty: SuperclassCollections.SuperWithNonEmptyNoArgCtor(), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I9, SuperclassCollections.SuperWithNonEmptyNoArgCtor)\n+BinarySuperclassConstraints.java:40:15: compiler.err.super.constructor.cannot.take.arguments: SuperclassCollections.SuperWithArgedCtor(java.lang.String), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I10, SuperclassCollections.SuperWithArgedCtor)\n+BinarySuperclassConstraints.java:42:15: compiler.err.super.no.arg.constructor.must.be.empty: SuperclassCollections.SuperWithInstanceInit(), (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I11, SuperclassCollections.SuperWithInstanceInit)\n@@ -7,1 +7,1 @@\n-BinarySuperclassConstraints.java:46:15: compiler.err.super.class.cannot.be.inner: BinarySuperclassConstraints.I13, SuperclassCollections.InnerSuper\n+BinarySuperclassConstraints.java:46:15: compiler.err.super.class.cannot.be.inner: (compiler.misc.superclass.of.value.class: BinarySuperclassConstraints.I13, SuperclassCollections.InnerSuper)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/BinarySuperclassConstraints.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,23 @@\n- * @test \/nodynamiccopyright\/\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n@@ -33,1 +55,2 @@\n-    static abstract class H extends ImplicitIdentityTypeTest {}  \/\/ concrete super.\n+\n+    static abstract class H extends ImplicitIdentityTypeTest {}  \/\/ not identity - no inheritance of flag bits from concrete super.\n@@ -66,2 +89,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ImplicitIdentityTypeTest.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,4 +2,4 @@\n-SuperclassConstraints.java:44:15: compiler.err.super.field.not.allowed: x, SuperclassConstraints.I6, SuperclassConstraints.SuperWithInstanceField\n-SuperclassConstraints.java:76:15: compiler.err.super.no.arg.constructor.must.be.empty: SuperclassConstraints.SuperWithNonEmptyNoArgCtor(), SuperclassConstraints.I9, SuperclassConstraints.SuperWithNonEmptyNoArgCtor\n-SuperclassConstraints.java:85:15: compiler.err.super.constructor.cannot.take.arguments: SuperclassConstraints.SuperWithArgedCtor(java.lang.String), SuperclassConstraints.I10, SuperclassConstraints.SuperWithArgedCtor\n-SuperclassConstraints.java:98:15: compiler.err.super.class.declares.init.block: SuperclassConstraints.I11, SuperclassConstraints.SuperWithInstanceInit\n+SuperclassConstraints.java:44:15: compiler.err.super.field.not.allowed: x, (compiler.misc.superclass.of.value.class: SuperclassConstraints.I6, SuperclassConstraints.SuperWithInstanceField)\n+SuperclassConstraints.java:76:15: compiler.err.super.no.arg.constructor.must.be.empty: SuperclassConstraints.SuperWithNonEmptyNoArgCtor(), (compiler.misc.superclass.of.value.class: SuperclassConstraints.I9, SuperclassConstraints.SuperWithNonEmptyNoArgCtor)\n+SuperclassConstraints.java:85:15: compiler.err.super.constructor.cannot.take.arguments: SuperclassConstraints.SuperWithArgedCtor(java.lang.String), (compiler.misc.superclass.of.value.class: SuperclassConstraints.I10, SuperclassConstraints.SuperWithArgedCtor)\n+SuperclassConstraints.java:98:15: compiler.err.super.class.declares.init.block: (compiler.misc.superclass.of.value.class: SuperclassConstraints.I11, SuperclassConstraints.SuperWithInstanceInit)\n@@ -7,1 +7,1 @@\n-SuperclassConstraints.java:110:15: compiler.err.super.class.cannot.be.inner: SuperclassConstraints.I13, SuperclassConstraints.InnerSuper\n+SuperclassConstraints.java:110:15: compiler.err.super.class.cannot.be.inner: (compiler.misc.superclass.of.value.class: SuperclassConstraints.I13, SuperclassConstraints.InnerSuper)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SuperclassConstraints.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8287136\n+ * @summary [lw4] Javac tolerates abstract value classes that violate constraints for qualifying to be value super classes\n+ * @compile\/fail\/ref=ValueConcreteSuperType.out -XDrawDiagnostics ValueConcreteSuperType.java\n+ *\/\n+\n+public class ValueConcreteSuperType {\n+    static abstract value class H extends ValueConcreteSuperType {}  \/\/ Error: concrete super.\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ValueConcreteSuperType.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+ValueConcreteSuperType.java:9:27: compiler.err.concrete.supertype.for.value.class: ValueConcreteSuperType.H, ValueConcreteSuperType\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ValueConcreteSuperType.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8287136\n+ * @summary [lw4] Javac tolerates abstract value classes that violate constraints for qualifying to be value super classes\n+ * @compile\/fail\/ref=AbstractValueClassConstraints.out -XDrawDiagnostics AbstractValueClassConstraints.java\n+ *\/\n+\n+public class AbstractValueClassConstraints {\n+\n+    static abstract value class V1 {\n+        int f;  \/\/ Error, abstract value class may not declare an instance field.\n+    }\n+\n+    abstract value class V2 {\n+        \/\/ Error, an abstract value class may not have an enclosing instance.\n+    }\n+\n+    static abstract value class V3 {\n+        synchronized void foo() {\n+         \/\/ Error, abstract value class may not declare a synchronized instance method.\n+        }\n+    }\n+\n+    static abstract value class V4 {\n+        { int f = 42; } \/\/ Error, abstract value class may not declare an instance initializer.\n+    }\n+\n+    static abstract value class V5 {\n+        V5(int x) {}  \/\/ Error, abstract value class may not declare a non-trivial constructor.\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AbstractValueClassConstraints.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+AbstractValueClassConstraints.java:44:27: compiler.err.mod.not.allowed.here: synchronized\n+AbstractValueClassConstraints.java:35:27: compiler.err.super.field.not.allowed: f, (compiler.misc.abstract.value.class: AbstractValueClassConstraints.V1)\n+AbstractValueClassConstraints.java:39:20: compiler.err.super.class.cannot.be.inner: (compiler.misc.abstract.value.class: AbstractValueClassConstraints.V2)\n+AbstractValueClassConstraints.java:49:27: compiler.err.super.class.declares.init.block: (compiler.misc.abstract.value.class: AbstractValueClassConstraints.V4)\n+AbstractValueClassConstraints.java:53:27: compiler.err.super.constructor.cannot.take.arguments: AbstractValueClassConstraints.V5(int), (compiler.misc.abstract.value.class: AbstractValueClassConstraints.V5)\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AbstractValueClassConstraints.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+CheckMakeDefault.java:10:20: compiler.err.super.class.cannot.be.inner: (compiler.misc.abstract.value.class: Point.A)\n@@ -11,1 +12,1 @@\n-10 errors\n+11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckMakeDefault.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8287713\n+ * @summary [lw4] Javac incorrectly flags subclasses as being ACC_IDENTITY classes.\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @run main NoAutoInheritanceOfIdentityFlagBit\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+\n+public class NoAutoInheritanceOfIdentityFlagBit { \/\/ ACC_IDENTITY - concrete class\n+\n+    abstract class A {}  \/\/ ACC_IDENTITY: Inner class\n+\n+    static abstract class B {}  \/\/ NO ACC_IDENTITY: No an inner class with an enclosing instance\n+\n+    static abstract class C {\n+        int f; \/\/ ACC_IDENTITY since an instance field is declared.\n+    }\n+\n+    static abstract value class D {} \/\/ No ACC_IDENTITY since an express abstract value class.\n+\n+    static value class E {} \/\/ No ACC_IDENTITY since an express concrete value class.\n+\n+    static abstract class F extends C {} \/\/ No ACC_IDENTITY - since no auto propagation.\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n+        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$A.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n+        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$B.class\"));\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+\n+        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$C.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n+        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$D.class\"));\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+\n+        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$E.class\"));\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+\n+        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$F.class\"));\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NoAutoInheritanceOfIdentityFlagBit.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n-       \/\/ ACC_IDENTITY as it extends an identity class.\n+       \/\/ NOT ACC_IDENTITY  - flags bits are not auto inherited from extended identity class.\n@@ -51,1 +51,1 @@\n-        \/\/ ACC_IDENTITY as it extends an implicit identity class.\n+        \/\/ NOT ACC_IDENTITY - flags bits are not auto inherited from extended identity class.\n@@ -62,1 +62,1 @@\n-        \/\/ ACC_IDENTITY as it extends an implicit identity class.\n+        \/\/ NOT ACC_IDENTITY as flag bits are not auto inherited from the extended implicit identity class.\n@@ -72,1 +72,1 @@\n-        \/\/ ACC_IDENTITY as it extends an implicit identity class.\n+        \/\/ NOT ACC_IDENTITY as flag bits are not auto inherited from the extended implicit identity class.\n@@ -124,2 +124,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n@@ -136,2 +136,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n@@ -144,2 +144,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n@@ -152,2 +152,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/PermitsValueTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -15,2 +15,2 @@\n-    \/\/ The class may not be declared abstract.\n-    abstract value class AbsValue {}  \/\/ Error: value class cannot be abstract\n+\n+    abstract value class AbsValue {}  \/\/ Error: value class inner\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SemanticsViolationsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+SemanticsViolationsTest.java:16:20: compiler.err.super.class.cannot.be.inner: (compiler.misc.abstract.value.class: SemanticsViolationsTest.AbsValue)\n@@ -9,1 +10,1 @@\n-SemanticsViolationsTest.java:47:11: compiler.err.super.field.not.allowed: xx, SemanticsViolationsTest.BrokenValue3, SemanticsViolationsTest.AbstractWithState\n+SemanticsViolationsTest.java:47:11: compiler.err.super.field.not.allowed: xx, (compiler.misc.superclass.of.value.class: SemanticsViolationsTest.BrokenValue3, SemanticsViolationsTest.AbstractWithState)\n@@ -16,1 +17,1 @@\n-15 errors\n+16 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SemanticsViolationsTest.out","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8287136\n+ * @summary [lw4] Javac tolerates abstract value classes that violate constraints for qualifying to be value super classes\n+ * @compile\/fail\/ref=ValueSuperClassConstraints.out -XDrawDiagnostics ValueSuperClassConstraints.java\n+ *\/\n+\n+public class ValueSuperClassConstraints {\n+\n+    static abstract class I1 { \/\/ has identity since it declares an instance field.\n+        int f;\n+    }\n+\n+    static value class V1 extends I1 {} \/\/ Error.\n+\n+    abstract class I2 { \/\/ has identity since is an inner class\n+    }\n+\n+    static value class V2 extends I2 {} \/\/ Error.\n+\n+    static abstract class I3 { \/\/ has identity since it declared a synchronized instance method.\n+        synchronized void foo() {\n+        }\n+    }\n+\n+    static value class V3 extends I3 {} \/\/ Error.\n+\n+    static abstract class I4 { \/\/ has identity since it declares an instance initializer\n+        { int f = 42; }\n+    }\n+\n+    static value class V4 extends I4 {} \/\/ Error.\n+\n+    static abstract class I5 { \/\/ has identity since it declares a non-trivial constructor\n+        I5(int x) {}\n+    }\n+\n+    static value class V5 extends I5 {} \/\/ Error.\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueSuperClassConstraints.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+ValueSuperClassConstraints.java:39:18: compiler.err.super.field.not.allowed: f, (compiler.misc.superclass.of.value.class: ValueSuperClassConstraints.V1, ValueSuperClassConstraints.I1)\n+ValueSuperClassConstraints.java:44:18: compiler.err.super.class.cannot.be.inner: (compiler.misc.superclass.of.value.class: ValueSuperClassConstraints.V2, ValueSuperClassConstraints.I2)\n+ValueSuperClassConstraints.java:51:18: compiler.err.super.method.cannot.be.synchronized: foo(), ValueSuperClassConstraints.V3, ValueSuperClassConstraints.I3\n+ValueSuperClassConstraints.java:57:18: compiler.err.super.class.declares.init.block: (compiler.misc.superclass.of.value.class: ValueSuperClassConstraints.V4, ValueSuperClassConstraints.I4)\n+ValueSuperClassConstraints.java:63:18: compiler.err.super.constructor.cannot.take.arguments: ValueSuperClassConstraints.I5(int), (compiler.misc.superclass.of.value.class: ValueSuperClassConstraints.V5, ValueSuperClassConstraints.I5)\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueSuperClassConstraints.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"}]}