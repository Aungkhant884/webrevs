{"files":[{"patch":"@@ -682,1 +682,0 @@\n-#ifndef _LP64\n@@ -685,7 +684,0 @@\n-#else\n-#ifdef ASSERT\n-        \/\/ Overwrite the unused slot with known junk\n-        __ mov64(rax, CONST64(0xdeadffffdeadaaaa));\n-        __ movptr(Address(rsp, st_off), rax);\n-#endif \/* ASSERT *\/\n-#endif \/\/ _LP64\n@@ -699,14 +691,1 @@\n-        NOT_LP64(ShouldNotReachHere());\n-        \/\/ Two VMRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG\n-        \/\/ T_DOUBLE and T_LONG use two slots in the interpreter\n-        if (sig_extended.at(i)._bt == T_LONG || sig_extended.at(i)._bt == T_DOUBLE) {\n-          \/\/ long\/double in gpr\n-#ifdef ASSERT\n-          \/\/ Overwrite the unused slot with known junk\n-          LP64_ONLY(__ mov64(rax, CONST64(0xdeadffffdeadaaab)));\n-          __ movptr(Address(rsp, st_off), rax);\n-#endif \/* ASSERT *\/\n-          __ movptr(Address(rsp, next_off), r);\n-        } else {\n-          __ movptr(Address(rsp, st_off), r);\n-        }\n+        ShouldNotReachHere();\n@@ -898,3 +877,1 @@\n-        const int offset = (NOT_LP64(true ||) sig_extended.at(i)._bt==T_LONG||sig_extended.at(i)._bt==T_DOUBLE)?\n-                           next_off : ld_off;\n-        __ movptr(rsi, Address(saved_sp, offset));\n+        __ movptr(rsi, Address(saved_sp, next_off));\n@@ -902,1 +879,0 @@\n-#ifndef _LP64\n@@ -905,1 +881,0 @@\n-#endif \/\/ _LP64\n@@ -916,5 +891,1 @@\n-        const int offset = (NOT_LP64(true ||) sig_extended.at(i)._bt==T_LONG||sig_extended.at(i)._bt==T_DOUBLE)?\n-                           next_off : ld_off;\n-\n-        __ movptr(r, Address(saved_sp, offset));\n-#ifndef _LP64\n+        __ movptr(r, Address(saved_sp, next_off));\n@@ -926,1 +897,0 @@\n-#endif \/\/ _LP64\n@@ -1179,1 +1149,1 @@\n-    NOT_LP64(__ movptr(rbx, Address(rbp, reg2offset_in(src.second()))));\n+    __ movptr(rbx, Address(rbp, reg2offset_in(src.second())));\n@@ -1181,1 +1151,1 @@\n-    NOT_LP64(__ movptr(Address(rsp, reg2offset_out(dst.second())), rbx));\n+    __ movptr(Address(rsp, reg2offset_out(dst.second())), rbx);\n@@ -1203,1 +1173,1 @@\n-    NOT_LP64(__ movptr(rbx, Address(rbp, reg2offset_in(src.second()))));\n+    __ movptr(rbx, Address(rbp, reg2offset_in(src.second())));\n@@ -1205,1 +1175,1 @@\n-    NOT_LP64(__ movptr(Address(rsp, reg2offset_out(dst.second())), rbx));\n+    __ movptr(Address(rsp, reg2offset_out(dst.second())), rbx);\n@@ -1227,1 +1197,1 @@\n-    NOT_LP64(__ movptr(Address(rbp, -2*wordSize), rdx));\n+    __ movptr(Address(rbp, -2*wordSize), rdx);\n@@ -1247,1 +1217,1 @@\n-    NOT_LP64(__ movptr(rdx, Address(rbp, -2*wordSize)));\n+    __ movptr(rdx, Address(rbp, -2*wordSize));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":9,"deletions":39,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -6364,1 +6364,0 @@\n-  ins_cost(400);\n@@ -6377,1 +6376,0 @@\n-  ins_cost(400);\n@@ -6390,1 +6388,0 @@\n-  ins_cost(400);\n@@ -6403,1 +6400,0 @@\n-  ins_cost(400);\n@@ -7944,1 +7940,0 @@\n-  ins_cost(450);\n@@ -7960,1 +7955,0 @@\n-  ins_cost(450);\n@@ -7977,1 +7971,0 @@\n-  ins_cost(250);\n@@ -7992,1 +7985,0 @@\n-  ins_cost(450);\n@@ -8932,1 +8924,0 @@\n-  ins_cost(400);\n@@ -9757,1 +9748,0 @@\n-  ins_cost(100);\n@@ -10083,1 +10073,0 @@\n-  ins_cost(100);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -7137,1 +7137,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -7506,1 +7506,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8179,1 +8179,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8370,1 +8370,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8577,1 +8577,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3698,11 +3698,0 @@\n-operand no_rax_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));\n-  match(RegL);\n-  match(rRegL);\n-  match(rdx_RegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -7716,1 +7705,1 @@\n-  ins_cost(125); \/\/ XXX\n+  ins_cost(150); \/\/ XXX\n@@ -7886,1 +7875,1 @@\n-  ins_cost(125); \/\/ XXX\n+  ins_cost(150); \/\/ XXX\n@@ -8562,12 +8551,0 @@\n-instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n-%{\n-  match(Set dst (SubI dst src));\n-  effect(KILL cr);\n-\n-  format %{ \"subl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ subl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n@@ -8579,1 +8556,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8600,13 +8577,0 @@\n-instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (SubI (LoadI dst) src)));\n-  effect(KILL cr);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"subl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ subl($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -8625,12 +8589,0 @@\n-instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (SubL dst src));\n-  effect(KILL cr);\n-\n-  format %{ \"subq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ subq($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n@@ -8642,1 +8594,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -8663,13 +8615,0 @@\n-instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (SubL (LoadL dst) src)));\n-  effect(KILL cr);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"subq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ subq($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -8879,1 +8818,1 @@\n-instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)\n+instruct mulHiL_rReg(rdx_RegL dst, rRegL src, rax_RegL rax, rFlagsReg cr)\n@@ -8892,1 +8831,1 @@\n-instruct umulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)\n+instruct umulHiL_rReg(rdx_RegL dst, rRegL src, rax_RegL rax, rFlagsReg cr)\n@@ -9045,65 +8984,0 @@\n-\n-\/\/----------- DivL-By-Constant-Expansions--------------------------------------\n-\/\/ DivI cases are handled by the compiler\n-\n-\/\/ Magic constant, reciprocal of 10\n-instruct loadConL_0x6666666666666667(rRegL dst)\n-%{\n-  effect(DEF dst);\n-\n-  format %{ \"movq    $dst, #0x666666666666667\\t# Used in div-by-10\" %}\n-  ins_encode(load_immL(dst, 0x6666666666666667));\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)\n-%{\n-  effect(DEF dst, USE src, USE_KILL rax, KILL cr);\n-\n-  format %{ \"imulq   rdx:rax, rax, $src\\t# Used in div-by-10\" %}\n-  ins_encode %{\n-    __ imulq($src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, KILL cr);\n-\n-  format %{ \"sarq    $dst, #63\\t# Used in div-by-10\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Register, 63);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, KILL cr);\n-\n-  format %{ \"sarq    $dst, #2\\t# Used in div-by-10\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Register, 2);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)\n-%{\n-  match(Set dst (DivL src div));\n-\n-  ins_cost((5+8)*100);\n-  expand %{\n-    rax_RegL rax;                     \/\/ Killed temp\n-    rFlagsReg cr;                     \/\/ Killed\n-    loadConL_0x6666666666666667(rax); \/\/ movq  rax, 0x6666666666666667\n-    mul_hi(dst, src, rax, cr);        \/\/ mulq  rdx:rax <= rax * $src\n-    sarL_rReg_63(src, cr);            \/\/ sarq  src, 63\n-    sarL_rReg_2(dst, cr);             \/\/ sarq  rdx, 2\n-    subL_rReg(dst, src, cr);          \/\/ subl  rdx, src\n-  %}\n-%}\n-\n-\/\/-----------------------------------------------------------------------------\n-\n@@ -9176,26 +9050,0 @@\n-\/\/ Shift Left by one\n-instruct salI_rReg_1(rRegI dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (LShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sall($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by one\n-instruct salI_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\\t\" %}\n-  ins_encode %{\n-    __ sall($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9280,26 +9128,0 @@\n-\/\/ Arithmetic shift right by one\n-instruct sarI_rReg_1(rRegI dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (RShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sarl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Arithmetic shift right by one\n-instruct sarI_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sarl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9383,26 +9205,0 @@\n-\/\/ Logical shift right by one\n-instruct shrI_rReg_1(rRegI dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (URShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"shrl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrl($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Logical shift right by one\n-instruct shrI_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"shrl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrl($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9488,26 +9284,0 @@\n-\/\/ Shift Left by one\n-instruct salL_rReg_1(rRegL dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (LShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by one\n-instruct salL_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9592,26 +9362,0 @@\n-\/\/ Arithmetic shift right by one\n-instruct sarL_rReg_1(rRegL dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (RShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sarq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Arithmetic shift right by one\n-instruct sarL_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sarq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -9696,26 +9440,0 @@\n-\/\/ Logical shift right by one\n-instruct shrL_rReg_1(rRegL dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (URShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"shrq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Logical shift right by one\n-instruct shrL_mem_1(memory dst, immI_1 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"shrq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrq($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n@@ -10092,1 +9810,1 @@\n-instruct andI_rReg_imm255(rRegI dst, immI_255 src)\n+instruct andI_rReg_imm255(rRegI dst, rRegI src, immI_255 mask)\n@@ -10094,1 +9812,1 @@\n-  match(Set dst (AndI dst src));\n+  match(Set dst (AndI src mask));\n@@ -10096,1 +9814,1 @@\n-  format %{ \"movzbl  $dst, $dst\\t# int & 0xFF\" %}\n+  format %{ \"movzbl  $dst, $src\\t# int & 0xFF\" %}\n@@ -10098,1 +9816,1 @@\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ movzbl($dst$$Register, $src$$Register);\n@@ -10116,1 +9834,1 @@\n-instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)\n+instruct andI_rReg_imm65535(rRegI dst, rRegI src, immI_65535 mask)\n@@ -10118,1 +9836,1 @@\n-  match(Set dst (AndI dst src));\n+  match(Set dst (AndI src mask));\n@@ -10120,1 +9838,1 @@\n-  format %{ \"movzwl  $dst, $dst\\t# int & 0xFFFF\" %}\n+  format %{ \"movzwl  $dst, $src\\t# int & 0xFFFF\" %}\n@@ -10122,1 +9840,1 @@\n-    __ movzwl($dst$$Register, $dst$$Register);\n+    __ movzwl($dst$$Register, $src$$Register);\n@@ -10173,1 +9891,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10371,1 +10089,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10464,1 +10182,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10531,1 +10249,1 @@\n-instruct andL_rReg_imm255(rRegL dst, immL_255 src)\n+instruct andL_rReg_imm255(rRegL dst, rRegL src, immL_255 mask)\n@@ -10533,1 +10251,1 @@\n-  match(Set dst (AndL dst src));\n+  match(Set dst (AndL src mask));\n@@ -10535,1 +10253,1 @@\n-  format %{ \"movzbq  $dst, $dst\\t# long & 0xFF\" %}\n+  format %{ \"movzbl  $dst, $src\\t# long & 0xFF\" %}\n@@ -10537,1 +10255,2 @@\n-    __ movzbq($dst$$Register, $dst$$Register);\n+    \/\/ movzbl zeroes out the upper 32-bit and does not need REX.W\n+    __ movzbl($dst$$Register, $src$$Register);\n@@ -10543,1 +10262,1 @@\n-instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)\n+instruct andL_rReg_imm65535(rRegL dst, rRegL src, immL_65535 mask)\n@@ -10545,1 +10264,1 @@\n-  match(Set dst (AndL dst src));\n+  match(Set dst (AndL src mask));\n@@ -10547,1 +10266,1 @@\n-  format %{ \"movzwq  $dst, $dst\\t# long & 0xFFFF\" %}\n+  format %{ \"movzwl  $dst, $src\\t# long & 0xFFFF\" %}\n@@ -10549,1 +10268,2 @@\n-    __ movzwq($dst$$Register, $dst$$Register);\n+    \/\/ movzwl zeroes out the upper 32-bit and does not need REX.W\n+    __ movzwl($dst$$Register, $src$$Register);\n@@ -10573,1 +10293,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10788,1 +10508,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n@@ -10885,1 +10605,1 @@\n-  ins_cost(125);\n+  ins_cost(150);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":30,"deletions":310,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-  void emit_int8(int8_t x1) {\n+  void emit_int8(uint8_t x1) {\n@@ -216,1 +216,1 @@\n-    *((int8_t*)  curr++) = x1;\n+    *((uint8_t*)  curr++) = x1;\n@@ -220,2 +220,2 @@\n-  void emit_int16(int16_t x) { *((int16_t*) end()) = x; set_end(end() + sizeof(int16_t)); }\n-  void emit_int16(int8_t x1, int8_t x2) {\n+  void emit_int16(uint16_t x) { *((uint16_t*) end()) = x; set_end(end() + sizeof(uint16_t)); }\n+  void emit_int16(uint8_t x1, uint8_t x2) {\n@@ -223,2 +223,2 @@\n-    *((int8_t*)  curr++) = x1;\n-    *((int8_t*)  curr++) = x2;\n+    *((uint8_t*)  curr++) = x1;\n+    *((uint8_t*)  curr++) = x2;\n@@ -228,1 +228,1 @@\n-  void emit_int24(int8_t x1, int8_t x2, int8_t x3)  {\n+  void emit_int24(uint8_t x1, uint8_t x2, uint8_t x3)  {\n@@ -230,3 +230,3 @@\n-    *((int8_t*)  curr++) = x1;\n-    *((int8_t*)  curr++) = x2;\n-    *((int8_t*)  curr++) = x3;\n+    *((uint8_t*)  curr++) = x1;\n+    *((uint8_t*)  curr++) = x2;\n+    *((uint8_t*)  curr++) = x3;\n@@ -236,1 +236,1 @@\n-  void emit_int32(int32_t x) {\n+  void emit_int32(uint32_t x) {\n@@ -238,2 +238,2 @@\n-    *((int32_t*) curr) = x;\n-    set_end(curr + sizeof(int32_t));\n+    *((uint32_t*) curr) = x;\n+    set_end(curr + sizeof(uint32_t));\n@@ -241,1 +241,1 @@\n-  void emit_int32(int8_t x1, int8_t x2, int8_t x3, int8_t x4)  {\n+  void emit_int32(uint8_t x1, uint8_t x2, uint8_t x3, uint8_t x4)  {\n@@ -243,4 +243,4 @@\n-    *((int8_t*)  curr++) = x1;\n-    *((int8_t*)  curr++) = x2;\n-    *((int8_t*)  curr++) = x3;\n-    *((int8_t*)  curr++) = x4;\n+    *((uint8_t*)  curr++) = x1;\n+    *((uint8_t*)  curr++) = x2;\n+    *((uint8_t*)  curr++) = x3;\n+    *((uint8_t*)  curr++) = x4;\n@@ -250,1 +250,1 @@\n-  void emit_int64( int64_t x)  { *((int64_t*) end()) = x; set_end(end() + sizeof(int64_t)); }\n+  void emit_int64( uint64_t x)  { *((uint64_t*) end()) = x; set_end(end() + sizeof(uint64_t)); }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    CFGPrinter::print_cfg(_bci2block, title.as_string(), false, false);\n+    CFGPrinter::print_cfg(_bci2block, title.freeze(), false, false);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1115,1 +1115,1 @@\n-  ss.print(\"Assertion %s %s %s in method %s\", strStream1.as_string(), ip2.cond_name(cond), strStream2.as_string(), strStream.as_string());\n+  ss.print(\"Assertion %s %s %s in method %s\", strStream1.freeze(), ip2.cond_name(cond), strStream2.freeze(), strStream.freeze());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-      _masm->block_comment(st.as_string());\n+      _masm->block_comment(st.freeze());\n@@ -270,1 +270,1 @@\n-    _masm->block_comment(st.as_string());\n+    _masm->block_comment(st.freeze());\n@@ -300,1 +300,1 @@\n-        _masm->block_comment(st.as_string());\n+        _masm->block_comment(st.freeze());\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -679,1 +679,1 @@\n-    ResourceMark rm;\n+    ResourceMark rm; \/\/ print_value_string\n@@ -685,1 +685,1 @@\n-    Exceptions::log_exception(exception, tempst.as_string());\n+    Exceptions::log_exception(exception, tempst.freeze());\n@@ -1638,1 +1638,1 @@\n-    tty->print_cr(\"Predicate failed trap in method %s at bci %d inlined in %s at pc \" INTPTR_FORMAT, ss1.as_string(), vfst.bci(), ss2.as_string(), p2i(caller_frame.pc()));\n+    tty->print_cr(\"Predicate failed trap in method %s at bci %d inlined in %s at pc \" INTPTR_FORMAT, ss1.freeze(), vfst.bci(), ss2.freeze(), p2i(caller_frame.pc()));\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-    st->print(\" loaded=true initialized=%s finalized=%s subklass=%s size=%d flags=\",\n+    st->print(\" initialized=%s finalized=%s subklass=%s size=%d flags=\",\n@@ -352,2 +352,0 @@\n-  } else {\n-    st->print(\" loaded=false\");\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,0 +245,1 @@\n+  st->print(\" loaded=%s\", (is_loaded() ? \"true\" : \"false\"));\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -205,6 +205,2 @@\n-    if (klass->is_array_klass()) {\n-      assert(!klass->is_type_array_klass(), \"\");\n-      klass = ciEnv::unloaded_ciobjarrayklass();\n-    } else {\n-      klass = ciEnv::unloaded_ciinstance_klass();\n-    }\n+    VM_ENTRY_MARK;\n+    klass = CURRENT_ENV->get_unloaded_klass(_holder, klass->name());\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -550,1 +550,0 @@\n-  ResourceMark rm;\n@@ -556,1 +555,1 @@\n-    tty->print(\"%s\", ss.as_string());\n+    tty->print(\"%s\", ss.freeze());\n@@ -2026,1 +2025,0 @@\n-  ResourceMark rm;\n@@ -2034,1 +2032,1 @@\n-  tty->print(\"%s\", s.as_string());\n+  tty->print(\"%s\", s.freeze());\n@@ -2039,1 +2037,0 @@\n-  ResourceMark rm;\n@@ -2354,1 +2351,0 @@\n-      ResourceMark rm;\n@@ -2362,1 +2358,1 @@\n-      xtty->print(\"%s\", s.as_string());\n+      xtty->print(\"%s\", s.freeze());\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -627,5 +627,0 @@\n-    \/\/ Objects failing evacuation will turn into old objects since the regions\n-    \/\/ are relabeled as such. We mark the failing objects in the marking bitmap\n-    \/\/ and later use it to handle all failed objects.\n-    _g1h->mark_evac_failure_object(old);\n-\n@@ -636,0 +631,4 @@\n+    \/\/ Mark the failing object in the marking bitmap and later use the bitmap to handle\n+    \/\/ evacuation failure recovery.\n+    _g1h->mark_evac_failure_object(_worker_id, old, word_sz);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1216,0 +1216,3 @@\n+        if (!is_aligned(data_offset, CompilerToVM::Data::get_data_section_item_alignment())) {\n+          JVMCI_ERROR(\"data offset 0x%x is not %d-byte aligned%s\", data_offset, relocInfo::addr_unit(), stream->context());\n+        }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-    tty->print_raw_cr(s.as_string());\n+    tty->print_raw_cr(s.freeze());\n@@ -2211,5 +2211,3 @@\n-C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong handle))\n-  if (handle != 0) {\n-    JVMCIENV->runtime()->destroy_oop_handle(handle);\n-  }\n-}\n+C2V_VMENTRY(void, releaseClearedOopHandles, (JNIEnv* env, jobject))\n+  JVMCIENV->runtime()->release_cleared_oop_handles();\n+C2V_END\n@@ -2906,1 +2904,1 @@\n-  {CC \"deleteGlobalHandle\",                           CC \"(J)V\",                                                                            FN_PTR(deleteGlobalHandle)},\n+  {CC \"releaseClearedOopHandles\",                     CC \"()V\",                                                                             FN_PTR(releaseClearedOopHandles)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -94,0 +94,3 @@\n+    \/\/ Minimum alignment of an offset into CodeBuffer::SECT_CONSTS\n+    static int data_section_item_alignment;\n+\n@@ -101,0 +104,4 @@\n+\n+    static int get_data_section_item_alignment() {\n+      return data_section_item_alignment;\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+  static_field(CompilerToVM::Data,             data_section_item_alignment,            int)                                          \\\n+                                                                                                                                     \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-        _fillerArrayKlassObj = TypeArrayKlass::create_klass(T_INT, \"Ljava\/internal\/vm\/FillerArray;\", CHECK);\n+        _fillerArrayKlassObj = TypeArrayKlass::create_klass(T_INT, \"Ljdk\/internal\/vm\/FillerArray;\", CHECK);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                                             IN_HEAP | IS_ARRAY | IS_NOT_NULL;\n+                                             IN_HEAP | IS_ARRAY | IS_NOT_NULL | IS_DEST_UNINITIALIZED;\n","filename":"src\/hotspot\/share\/oops\/access.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  template <DecoratorSet decorator>\n+  template<DecoratorSet decorators>\n@@ -168,0 +168,1 @@\n+\n@@ -171,0 +172,2 @@\n+  template<DecoratorSet decorators>\n+  void obj_field_put_access(int offset, oop value);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -225,0 +225,2 @@\n+template <DecoratorSet decorators>\n+inline void oopDesc::obj_field_put_access(int offset, oop value)    { HeapAccess<decorators>::oop_store_at(as_oop(), offset, value); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-              fatal(\"unexpected comparison %s\", ss.as_string());\n+              fatal(\"unexpected comparison %s\", ss.freeze());\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-void Compile::remove_useless_nodes(Unique_Node_List &useful) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n@@ -436,1 +436,1 @@\n-      record_for_igvn(n->unique_out());\n+      worklist->push(n->unique_out());\n@@ -439,1 +439,1 @@\n-      record_for_igvn(n);\n+      worklist->push(n);\n@@ -456,0 +456,5 @@\n+#ifdef ASSERT\n+  if (_modified_nodes != NULL) {\n+    _modified_nodes->remove_useless_nodes(useful.member_set());\n+  }\n+#endif\n@@ -5023,1 +5028,1 @@\n-      ss.print(\"%s\", pib->ss()->as_string());\n+      ss.print(\"%s\", pib->ss()->freeze());\n@@ -5034,1 +5039,1 @@\n-    strncpy(_print_inlining_output, ss.base(), end+1);\n+    strncpy(_print_inlining_output, ss.freeze(), end+1);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-    print_inlining_stream()->print(\"%s\", ss.as_string());\n+    print_inlining_stream()->print(\"%s\", ss.freeze());\n@@ -977,1 +977,1 @@\n-  void              remove_useless_nodes(Unique_Node_List &useful);\n+  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    out->print(\"%s\", ss.as_string());\n+    out->print(\"%s\", ss.freeze());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-    const char *msg = msg_stream.as_string();\n+    const char *msg = msg_stream.freeze();\n@@ -219,1 +219,1 @@\n-    const char *msg = msg_stream.as_string();\n+    const char *msg = msg_stream.freeze();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4098,1 +4098,2 @@\n-    if (!incr->is_Phi()) {\n+    \/\/ Or the region node is the loop head\n+    if (!incr->is_Phi() || incr->in(0) == head) {\n@@ -4278,1 +4279,14 @@\n-\/\/ register move)\n+\/\/ register move):\n+\/\/\n+\/\/     iv Phi            iv Phi\n+\/\/       |                 |\n+\/\/       |                AddI (+stride)\n+\/\/       |                 |\n+\/\/       |              Opaque2  # Blocks IGVN from folding these nodes until loop opts are over.\n+\/\/       |     ====>       |\n+\/\/       |                AddI (-stride)\n+\/\/       |                 |\n+\/\/       |               CastII  # Preserve type of iv Phi\n+\/\/       |                 |\n+\/\/   Outside Use       Outside Use\n+\/\/\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -995,0 +995,5 @@\n+    } else if (C->regalloc()->is_oop(local)) {\n+      assert(t->base() == Type::OopPtr || t->base() == Type::InstPtr ||\n+             t->base() == Type::AryPtr,\n+             \"Unexpected type: %s\", t->msg());\n+      array->append(new_loc_value( C->regalloc(), regnum, Location::oop ));\n@@ -996,1 +1001,4 @@\n-      array->append(new_loc_value( C->regalloc(), regnum, C->regalloc()->is_oop(local) ? Location::oop : Location::normal ));\n+      assert(t->base() == Type::Int || t->base() == Type::Half ||\n+             t->base() == Type::FloatCon || t->base() == Type::FloatBot,\n+             \"Unexpected type: %s\", t->msg());\n+      array->append(new_loc_value( C->regalloc(), regnum, Location::normal ));\n@@ -1542,1 +1550,1 @@\n-      MacroAssembler(cb).block_comment(st.as_string());\n+      MacroAssembler(cb).block_comment(st.freeze());\n@@ -1996,1 +2004,1 @@\n-        tty->print_raw(method_metadata_str.as_string());\n+        tty->print_raw(method_metadata_str.freeze());\n@@ -2002,1 +2010,1 @@\n-      tty->print_raw(dump_asm_str.as_string());\n+      tty->print_raw(dump_asm_str.freeze());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-  C->remove_useless_nodes(_useful);\n+  C->disconnect_useless_nodes(_useful, worklist);\n@@ -1812,0 +1812,3 @@\n+  assert(_root_and_safepoints.size() == 0, \"must be empty (unused)\");\n+  _root_and_safepoints.push(C->root());\n+\n@@ -1817,2 +1820,3 @@\n-      \/\/ Keep track of SafePoint nodes for PhaseCCP::transform()\n-      _safepoints.push(n);\n+      \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n+      \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n+      _root_and_safepoints.push(n);\n@@ -2009,4 +2013,2 @@\n-  new_node = transform_once(n);     \/\/ Check for constant\n-  _nodes.map( n->_idx, new_node );  \/\/ Flag as having been cloned\n-  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n-  GrowableArray <Node *> trstack(C->live_nodes() >> 1);\n+  assert(n->is_Root(), \"traversal must start at root\");\n+  assert(_root_and_safepoints.member(n), \"root (n) must be in list\");\n@@ -2015,1 +2017,3 @@\n-  trstack.push(new_node);           \/\/ Process children of cloned node\n+  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n+  GrowableArray <Node *> transform_stack(C->live_nodes() >> 1);\n+  Unique_Node_List useful; \/\/ track all visited nodes, so that we can remove the complement\n@@ -2017,0 +2021,1 @@\n+  \/\/ Initialize the traversal.\n@@ -2024,2 +2029,2 @@\n-  for (uint i = 0; i < _safepoints.size(); ++i) {\n-    Node* nn = _safepoints.at(i);\n+  for (uint i = 0; i < _root_and_safepoints.size(); ++i) {\n+    Node* nn = _root_and_safepoints.at(i);\n@@ -2028,3 +2033,4 @@\n-    new_node = transform_once(nn);\n-    _nodes.map(nn->_idx, new_node);\n-    trstack.push(new_node);\n+    new_node = transform_once(nn);  \/\/ Check for constant\n+    _nodes.map(nn->_idx, new_node); \/\/ Flag as having been cloned\n+    transform_stack.push(new_node); \/\/ Process children of cloned node\n+    useful.push(new_node);\n@@ -2033,2 +2039,2 @@\n-  while ( trstack.is_nonempty() ) {\n-    Node *clone = trstack.pop();\n+  while (transform_stack.is_nonempty()) {\n+    Node* clone = transform_stack.pop();\n@@ -2043,1 +2049,2 @@\n-          trstack.push(new_input);\n+          transform_stack.push(new_input);     \/\/ Process children of cloned node\n+          useful.push(new_input);\n@@ -2049,1 +2056,20 @@\n-  return new_node;\n+\n+  \/\/ The above transformation might lead to subgraphs becoming unreachable from the\n+  \/\/ bottom while still being reachable from the top. As a result, nodes in that\n+  \/\/ subgraph are not transformed and their bottom types are not updated, leading to\n+  \/\/ an inconsistency between bottom_type() and type(). In rare cases, LoadNodes in\n+  \/\/ such a subgraph, might be re-enqueued for IGVN indefinitely by MemNode::Ideal_common\n+  \/\/ because their address type is inconsistent. Therefore, we aggressively remove\n+  \/\/ all useless nodes here even before PhaseIdealLoop::build_loop_late gets a chance\n+  \/\/ to remove them anyway.\n+  if (C->cached_top_node()) {\n+    useful.push(C->cached_top_node());\n+  }\n+  C->update_dead_node_list(useful);\n+  remove_useless_nodes(useful.member_set());\n+  _worklist.remove_useless_nodes(useful.member_set());\n+  C->disconnect_useless_nodes(useful, &_worklist);\n+\n+  Node* new_root = _nodes[n->_idx];\n+  assert(new_root->is_Root(), \"transformed root node must be a root node\");\n+  return new_root;\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":43,"deletions":17,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -571,2 +571,1 @@\n-  Unique_Node_List _safepoints;\n-\n+  Unique_Node_List _root_and_safepoints;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1730,1 +1730,1 @@\n-    c = new RTMLockingNamedCounter(st.as_string());\n+    c = new RTMLockingNamedCounter(st.freeze());\n@@ -1732,1 +1732,1 @@\n-    c = new NamedCounter(st.as_string(), tag);\n+    c = new NamedCounter(st.freeze(), tag);\n@@ -1766,1 +1766,1 @@\n-  st->print_raw_cr(tempst.as_string());\n+  st->print_raw_cr(tempst.freeze());\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2556,1 +2556,1 @@\n-    tty->print_raw(st.as_string());\n+    tty->print_raw(st.freeze());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  tty->print_raw(st.as_string());\n+  tty->print_raw(st.freeze());\n@@ -224,1 +224,1 @@\n-  tty->print_raw(st.as_string());\n+  tty->print_raw(st.freeze());\n@@ -355,1 +355,1 @@\n-        tty->print_raw(st.as_string());\n+        tty->print_raw(st.freeze());\n@@ -1682,1 +1682,1 @@\n-    tty->print_raw(st.as_string());\n+    tty->print_raw(st.freeze());\n@@ -2163,1 +2163,1 @@\n-        tty->print_raw(st.as_string());\n+        tty->print_raw(st.freeze());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+     * @see ClassDesc#ofDescriptor(String)\n+     * @see ClassDesc#ofInternalName(String)\n@@ -82,0 +84,25 @@\n+    \/**\n+     * Returns a {@linkplain ClassDesc} for a class or interface type,\n+     * given the name of the class or interface in internal form,\n+     * such as {@code \"java\/lang\/String\"}.\n+     *\n+     * @apiNote\n+     * To create a descriptor for an array type, either use {@link #ofDescriptor(String)}\n+     * or {@link #arrayType()}; to create a descriptor for a primitive type, use\n+     * {@link #ofDescriptor(String)} or use the predefined constants in\n+     * {@link ConstantDescs}.\n+     *\n+     * @param name the fully qualified class name, in internal (slash-separated) form\n+     * @return a {@linkplain ClassDesc} describing the desired class\n+     * @throws NullPointerException if the argument is {@code null}\n+     * @throws IllegalArgumentException if the name string is not in the\n+     * correct format\n+     * @jvms 4.2.1 Binary Class and Interface Names\n+     * @see ClassDesc#of(String)\n+     * @see ClassDesc#ofDescriptor(String)\n+     *\/\n+    static ClassDesc ofInternalName(String name) {\n+        ConstantUtils.validateInternalClassName(requireNonNull(name));\n+        return ClassDesc.ofDescriptor(\"L\" + name + \";\");\n+    }\n+\n@@ -131,0 +158,2 @@\n+     * @see ClassDesc#of(String)\n+     * @see ClassDesc#ofInternalName(String)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -61,0 +61,17 @@\n+    \/**\n+      * Validates the correctness of an internal class name.\n+      * In particular checks for the presence of invalid characters in the name.\n+      *\n+      * @param name the class name\n+      * @return the class name passed if valid\n+      * @throws IllegalArgumentException if the class name is invalid\n+      *\/\n+     static String validateInternalClassName(String name) {\n+         for (int i=0; i<name.length(); i++) {\n+             char ch = name.charAt(i);\n+             if (ch == ';' || ch == '[' || ch == '.')\n+                 throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+         }\n+         return name;\n+     }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -217,0 +217,5 @@\n+        \/**\n+          * Warn about compiler possible lossy conversions.\n+          *\/\n+        LOSSY_CONVERSIONS(\"lossy-conversions\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -856,1 +856,1 @@\n-                type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype.baseType(), variable.name);\n+                type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype, variable.name);\n@@ -1323,1 +1323,1 @@\n-                        v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);\n+                        v.type = chk.checkLocalVarType(tree, tree.init.type, tree.name);\n@@ -1919,0 +1919,2 @@\n+\n+                        var.flags_field |= Flags.FINAL;\n@@ -2614,1 +2616,1 @@\n-                                                qualifierType.referenceProjection() : qualifierType);\n+                                         qualifierType.referenceProjection() : qualifierType.baseType());\n@@ -3980,0 +3982,1 @@\n+            chk.checkLossOfPrecision(tree.rhs.pos(), operand, owntype);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1143,1 +1143,1 @@\n-        Type varType = types.upward(t, types.captures(t));\n+        Type varType = types.upward(t, types.captures(t)).baseType();\n@@ -4035,0 +4035,16 @@\n+    \/**\n+     *  Check for possible loss of precission\n+     *  @param pos           Position for error reporting.\n+     *  @param found    The computed type of the tree\n+     *  @param req  The computed type of the tree\n+     *\/\n+    void checkLossOfPrecision(final DiagnosticPosition pos, Type found, Type req) {\n+        if (found.isNumeric() && req.isNumeric() && !types.isAssignable(found, req)) {\n+            deferredLintHandler.report(() -> {\n+                if (lint.isEnabled(LintCategory.LOSSY_CONVERSIONS))\n+                    log.warning(LintCategory.LOSSY_CONVERSIONS,\n+                            pos, Warnings.PossibleLossOfPrecision(found, req));\n+            });\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3766,2 +3766,1 @@\n-        int startPos = token.pos;\n-            JCModifiers mods = optFinal(Flags.FINAL);\n+            JCModifiers mods = optFinal(0);\n@@ -3774,1 +3773,1 @@\n-            JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));\n+            JCModifiers mods = F.Modifiers(0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2536,0 +2536,4 @@\n+# 0: type, 1: type\n+compiler.warn.possible.loss.of.precision=\\\n+    implicit cast from {0} to {1} in compound assignment is possibly lossy\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,0 +213,3 @@\n+javac.opt.Xlint.desc.lossy-conversions=\\\n+    Warn about possible lossy conversions in compound assignment.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    headerObj = (FileMapHeader) VMObjectFactory.newObject(FileMapInfo.FileMapHeader.class, header);\n+    headerObj = VMObjectFactory.newObject(FileMapHeader.class, header);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-        Short sourceFileIndex = (Short) utf8ToIndex.get(\"SourceFile\");\n+        Short sourceFileIndex = utf8ToIndex.get(\"SourceFile\");\n@@ -140,1 +140,1 @@\n-        Short innerClassesIndex = (Short) utf8ToIndex.get(\"InnerClasses\");\n+        Short innerClassesIndex = utf8ToIndex.get(\"InnerClasses\");\n@@ -145,1 +145,1 @@\n-        Short constantValueIndex = (Short) utf8ToIndex.get(\"ConstantValue\");\n+        Short constantValueIndex = utf8ToIndex.get(\"ConstantValue\");\n@@ -150,1 +150,1 @@\n-        Short syntheticIndex = (Short) utf8ToIndex.get(\"Synthetic\");\n+        Short syntheticIndex = utf8ToIndex.get(\"Synthetic\");\n@@ -154,1 +154,1 @@\n-        Short deprecatedIndex = (Short) utf8ToIndex.get(\"Deprecated\");\n+        Short deprecatedIndex = utf8ToIndex.get(\"Deprecated\");\n@@ -159,1 +159,1 @@\n-        Short codeIndex = (Short) utf8ToIndex.get(\"Code\");\n+        Short codeIndex = utf8ToIndex.get(\"Code\");\n@@ -163,1 +163,1 @@\n-        Short exceptionsIndex = (Short) utf8ToIndex.get(\"Exceptions\");\n+        Short exceptionsIndex = utf8ToIndex.get(\"Exceptions\");\n@@ -171,1 +171,1 @@\n-        Short lineNumberTableIndex = (Short) utf8ToIndex.get(\"LineNumberTable\");\n+        Short lineNumberTableIndex = utf8ToIndex.get(\"LineNumberTable\");\n@@ -176,1 +176,1 @@\n-        Short localVariableTableIndex = (Short) utf8ToIndex.get(\"LocalVariableTable\");\n+        Short localVariableTableIndex = utf8ToIndex.get(\"LocalVariableTable\");\n@@ -181,1 +181,1 @@\n-        Short signatureIdx = (Short) utf8ToIndex.get(\"Signature\");\n+        Short signatureIdx = utf8ToIndex.get(\"Signature\");\n@@ -235,1 +235,1 @@\n-                     Short s = (Short) utf8ToIndex.get(klassName);\n+                     Short s = utf8ToIndex.get(klassName);\n@@ -245,1 +245,1 @@\n-                     Short s = (Short) utf8ToIndex.get(str);\n+                     Short s = utf8ToIndex.get(str);\n@@ -336,1 +336,1 @@\n-        Short index = (Short) classToIndex.get(klassName);\n+        Short index = classToIndex.get(klassName);\n@@ -345,1 +345,1 @@\n-            Short index = (Short) classToIndex.get(superName);\n+            Short index = classToIndex.get(superName);\n@@ -363,5 +363,3 @@\n-           Short index = (Short) classToIndex.get(k.getName().asString());\n-           if (index != null) { \/\/ Injected interfaces have no constant pool entry\n-               dos.writeShort(index.shortValue());\n-               if (DEBUG) debugMessage(\"\\t\" + index);\n-           }\n+           Short index = classToIndex.get(k.getName().asString());\n+           dos.writeShort(index.shortValue());\n+           if (DEBUG) debugMessage(\"\\t\" + index);\n@@ -604,1 +602,1 @@\n-            dos.writeShort((short)codeAttrCount);\n+            dos.writeShort(codeAttrCount);\n@@ -620,1 +618,1 @@\n-                writeIndex((short) _localVariableTableIndex);\n+                writeIndex(_localVariableTableIndex);\n@@ -663,1 +661,1 @@\n-        Short index = (Short) utf8ToIndex.get(signature);\n+        Short index = utf8ToIndex.get(signature);\n@@ -687,1 +685,1 @@\n-        final int numInnerClasses = (int) (innerClasses.length() \/ 4);\n+        final int numInnerClasses = innerClasses.length() \/ 4;\n@@ -702,1 +700,1 @@\n-            Short index = (Short) utf8ToIndex.get(sourceFileName.asString());\n+            Short index = utf8ToIndex.get(sourceFileName.asString());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-gc\/metaspace\/TestMetaspacePerfCounters.java#Epsilon-64 8293503 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}