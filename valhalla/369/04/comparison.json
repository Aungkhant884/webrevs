{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCDefaultValue;\n@@ -330,0 +331,10 @@\n+    @Override\n+    public void visitDefaultValue(JCDefaultValue that) {\n+        if (TreeInfo.isPossiblePolyDefault(that, that.type)) {\n+            processArg(that, speculativeTree -> new ResolvedDefaultType(that, env, speculativeTree));\n+        } else {\n+            \/\/not a poly expression, just call Attr\n+            setResult(that, attr.attribTree(that, env, attr.unknownExprInfo));\n+        }\n+    }\n+\n@@ -718,0 +729,30 @@\n+        }\n+    }\n+\n+    \/**\n+     * Argument type for default values.\n+     *\/\n+    class ResolvedDefaultType extends ResolvedMemberType<JCDefaultValue> {\n+\n+        public ResolvedDefaultType(JCExpression tree, Env<AttrContext> env, JCDefaultValue speculativeTree) {\n+            this(tree, env, speculativeTree, new HashMap<>());\n+        }\n+\n+        public ResolvedDefaultType(JCExpression tree, Env<AttrContext> env, JCDefaultValue speculativeTree, Map<ResultInfo, Type> speculativeTypes) {\n+            super(tree, env, speculativeTree, speculativeTypes);\n+        }\n+\n+        @Override\n+        ResultInfo resultInfo(ResultInfo resultInfo) {\n+            return resultInfo.dup(attr.defaultPolyContext(speculativeTree, speculativeTree.clazz.type.tsym, resultInfo.checkContext));\n+        }\n+\n+        @Override\n+        Type methodType() {\n+            return (speculativeTree.defaultValueConstructor != null) ?\n+                    speculativeTree.defaultValueConstructor.baseType() : syms.errType;\n+        }\n+\n+        @Override\n+        ArgumentType<JCDefaultValue> dup(JCDefaultValue tree, Env<AttrContext> env) {\n+            return new ResolvedDefaultType(tree, env, speculativeTree, speculativeTypes);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;\n@@ -675,1 +676,1 @@\n-    Type attribTree(JCTree tree, Env<AttrContext> env, ResultInfo resultInfo) {\n+    Type attribTree (JCTree tree, Env<AttrContext> env, ResultInfo resultInfo) {\n@@ -5023,1 +5024,1 @@\n-        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n+        Type clazztype = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP, Type.noType));\n@@ -5025,1 +5026,1 @@\n-            site = capture(site); \/\/ Capture field access\n+            clazztype = capture(clazztype); \/\/ Capture field access\n@@ -5027,10 +5028,7 @@\n-        Symbol sym = switch (site.getTag()) {\n-                case WILDCARD -> throw new AssertionError(tree);\n-                case PACKAGE -> {\n-                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n-                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n-                    yield syms.errSymbol;\n-                }\n-                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n-                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n-        };\n+        if (TreeInfo.isPossiblePolyDefault(tree, clazztype)) {\n+            var flavor = clazztype.getTag() == CLASS ? clazztype.getFlavor() : Flavor.X_Typeof_X;\n+            ClassType site = new ClassType(clazztype.getEnclosingType(),\n+                        clazztype.tsym.type.getTypeArguments(),\n+                                           clazztype.tsym,\n+                                           clazztype.getMetadata(),\n+                                           flavor);\n@@ -5038,2 +5036,33 @@\n-        if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-            site = types.skipTypeVars(site, true);\n+            Env<AttrContext> diamondEnv = env.dup(tree);\n+            diamondEnv.info.selectSuper = false;\n+            diamondEnv.info.pendingResolutionPhase = MethodResolutionPhase.BASIC;\n+\n+            var clazzTypeArgs = site.getTypeArguments();\n+            Type constrType = tree.defaultValueConstructor = new ForAll(clazzTypeArgs,\n+                    new MethodType(List.nil(), site, List.nil(), syms.methodClass));\n+\n+            MethodSymbol constructor = new MethodSymbol(Flags.SYNTHETIC, names.init, constrType, site.tsym);\n+            ResultInfo diamondResult = new ResultInfo(KindSelector.VAL, newMethodTemplate(resultInfo.pt, List.nil(), List.nil()),\n+                    defaultPolyContext(tree, clazztype.tsym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);\n+\n+            Type defaultType = checkId(tree, site, constructor, diamondEnv, diamondResult);\n+\n+            if (defaultType.isErroneous()) {\n+                tree.clazz.type = types.createErrorType(clazztype);\n+            } else {\n+                tree.defaultValueConstructor = types.createMethodTypeWithReturn(defaultType, syms.voidType);\n+                tree.clazz.type = defaultType.getReturnType();\n+            }\n+            clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);\n+            result = check(tree, clazztype, KindSelector.VAL, resultInfo);\n+        } else {\n+            chk.validate(tree.clazz, env);\n+            Symbol sym = switch (clazztype.getTag()) {\n+                case WILDCARD -> throw new AssertionError(tree);\n+                case ERROR -> types.createErrorType(names._default, clazztype.tsym, clazztype).tsym;\n+                default -> new VarSymbol(STATIC, names._default, clazztype, clazztype.tsym);\n+            };\n+            if (clazztype.hasTag(TYPEVAR) && sym.kind != ERR) {\n+                clazztype = types.skipTypeVars(clazztype, true);\n+            }\n+            result = tree.type = checkId(tree, clazztype, sym, env, resultInfo);\n@@ -5041,1 +5070,10 @@\n-        result = checkId(tree, site, sym, env, resultInfo);\n+    }\n+    \/\/ where\n+    CheckContext defaultPolyContext(JCDefaultValue tree, TypeSymbol tsym, CheckContext checkContext) {\n+        return new Check.NestedCheckContext(checkContext) {\n+            @Override\n+            public void report(DiagnosticPosition _unused, JCDiagnostic details) {\n+                enclosingContext.report(tree.clazz,\n+                        diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));\n+            }\n+        };\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":54,"deletions":16,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1410,1 +1410,1 @@\n-\n+        public Type defaultValueConstructor; \/\/ Possible parameterized type of \"constructor\"\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,0 +279,21 @@\n+    \/** Return true if a default expression may represent a poly expression (with elided types) *\/\n+    public static boolean isPossiblePolyDefault(JCDefaultValue tree, Type clazztype) {\n+        JCTypeApply applyTree = TreeInfo.getTypeApplication(tree.clazz);\n+        if (applyTree != null) {\n+            return applyTree.arguments.isEmpty();\n+        } else {\n+            \/\/ No type arguments before .default - Consider if the type is generic or not\n+            return clazztype == null || clazztype.tsym.type.isParameterized();\n+        }\n+    }\n+\n+    \/** Return true if a tree directly or indirectly represents a type application. *\/\n+    public static JCTypeApply getTypeApplication(JCTree tree) {\n+        switch(tree.getTag()) {\n+            case TYPEAPPLY: return (JCTypeApply)tree;\n+            case NEWCLASS: return getTypeApplication(((JCNewClass)tree).clazz);\n+            case ANNOTATED_TYPE: return getTypeApplication(((JCAnnotatedType)tree).underlyingType);\n+            default: return null;\n+        }\n+    }\n+\n@@ -297,0 +318,3 @@\n+            case DEFAULT_VALUE:\n+                ((JCDefaultValue)tree).polyKind = pkind;\n+                break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8210906\n+ * @summary [lworld] default value creation should not impose raw types on users.\n+ * @compile\/fail\/ref=PolyDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev PolyDefault.java\n+ *\/\n+import java.util.concurrent.Callable;\n+import java.util.LinkedList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public primitive class PolyDefault<E> implements Callable<E> {\n+    E value;\n+    protected PolyDefault() { this.value = E.default; }\n+    PolyDefault(E value) { this.value = value; }\n+\n+    @Override\n+    public E call() throws Exception {\n+        return value;\n+    }\n+\n+    @FunctionalInterface\n+    interface PolyProducer {\n+        PolyDefault<String> produce();\n+    }\n+\n+    interface Foo<X extends Number> extends List<X> {\n+    }\n+\n+    public static <T extends Boolean> String overload(List<T> nums) {\n+        return \"\";\n+    }\n+\n+    public static <T extends Number> T overload(Collection<T> nums) {\n+        return T.default;\n+    }\n+\n+    public static void main(String [] args) throws Exception {\n+\n+        List<Integer> il = LinkedList.default;\n+        Integer i0 = il.get(0);\n+\n+        var a = overload(Foo.default);\n+        var b = a.intValue();\n+\n+        \/\/ Things which should just work\n+        PolyDefault<LinkedList<Long>> foo = PolyDefault.default; \/\/ Poly expression\n+        LinkedList<Long> c = foo.call(); \/\/ This should be fine, inferred above\n+        var genericDefault1 = PolyDefault<LinkedList<Long>>.default;\n+\n+        PolyProducer genericDefault = () -> PolyDefault.default;\n+\n+        \/\/ Problems\n+        List<String> boing = new PolyDefault<>(); \/\/ Error: Can't make a PolyDefault into a list\n+        List<String> boom = PolyDefault.default; \/\/ Error: Can't make a PolyDefault into a list\n+        List<String> tschak = Foo.default; \/\/ Error: Can make a Foo into a list, but then must be List<? extends Number>\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PolyDefault.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+PolyDefault.java:54:45: compiler.err.prob.found.req: (compiler.misc.cant.apply.diamond.1: (compiler.misc.diamond: PolyDefault), (compiler.misc.infer.no.conforming.instance.exists: E, PolyDefault<E>, java.util.List<java.lang.String>))\n+PolyDefault.java:55:29: compiler.err.prob.found.req: (compiler.misc.cant.apply.diamond.1: (compiler.misc.diamond: PolyDefault), (compiler.misc.infer.no.conforming.instance.exists: E, PolyDefault<E>, java.util.List<java.lang.String>))\n+PolyDefault.java:56:31: compiler.err.prob.found.req: (compiler.misc.cant.apply.diamond.1: (compiler.misc.diamond: PolyDefault.Foo), (compiler.misc.incompatible.bounds: X, (compiler.misc.eq.bounds: java.lang.String), (compiler.misc.upper.bounds: java.lang.Number)))\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PolyDefault.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8210906\n+ * @summary [lworld] default value creation should not impose raw types on users.\n+ * @run main PolyDefaultArgs\n+ *\/\n+public primitive class PolyDefaultArgs<T> {\n+\n+    static void m(PolyDefaultArgs<String> p) { }\n+\n+    static <T>void check(PolyDefaultArgs.ref<T> rp) {\n+    if (rp != null) {\n+            throw new RuntimeException(\"reference projection must be null\");\n+        }\n+    }\n+\n+    public static void main(String [] args) {\n+        \/\/ Ensure that the arguments to m() can be inferred\n+        m(new PolyDefaultArgs<>()); \/\/ OK\n+        m(PolyDefaultArgs<String>.default); \/\/ OK\n+        m(PolyDefaultArgs.default); \/\/ Now also OK\n+\n+        \/\/ Ensure that the default of a reference type is null\n+        check(PolyDefaultArgs.ref<String>.default);\n+        check(PolyDefaultArgs.ref.default);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PolyDefaultArgs.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,20 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8210906\n- * @summary [lworld] default value creation should not impose raw types on users.\n- * @compile\/fail\/ref=UncheckedDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev UncheckedDefault.java\n- *\/\n-\n-public primitive class UncheckedDefault<E> {\n-    E value;\n-    UncheckedDefault(E value) { this.value = value; }\n-    public static void main(String [] args) {\n-        UncheckedDefault<String> foo = UncheckedDefault.default;\n-    }\n-\n-    public E makeDefault() {\n-        E e = E.default;\n-        return e;\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UncheckedDefault.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-UncheckedDefault.java:12:56: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedDefault, UncheckedDefault<java.lang.String>\n-- compiler.err.warnings.and.werror\n-1 error\n-1 warning\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UncheckedDefault.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,2 +1,2 @@\n-UnknownTypeDefault.java:11:22: compiler.err.cant.resolve.location: kindname.class, Y, null, null, (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n-UnknownTypeDefault.java:12:24: compiler.err.cant.resolve.location: kindname.class, y.Z, null, null, (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n+UnknownTypeDefault.java:11:21: compiler.err.cant.resolve.location: kindname.class, Y, , , (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n+UnknownTypeDefault.java:12:22: compiler.err.doesnt.exist: y\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnknownTypeDefault.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}