{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCDefaultValue;\n@@ -330,0 +331,10 @@\n+    @Override\n+    public void visitDefaultValue(JCDefaultValue that) {\n+        if (TreeInfo.isPossiblePolyDefault(that, that.type)) {\n+            processArg(that, speculativeTree -> new ResolvedDefaultType(that, env, speculativeTree));\n+        } else {\n+            \/\/not a poly expression, just call Attr\n+            setResult(that, attr.attribTree(that, env, attr.unknownExprInfo));\n+        }\n+    }\n+\n@@ -718,0 +729,30 @@\n+        }\n+    }\n+\n+    \/**\n+     * Argument type for default values.\n+     *\/\n+    class ResolvedDefaultType extends ResolvedMemberType<JCDefaultValue> {\n+\n+        public ResolvedDefaultType(JCExpression tree, Env<AttrContext> env, JCDefaultValue speculativeTree) {\n+            this(tree, env, speculativeTree, new HashMap<>());\n+        }\n+\n+        public ResolvedDefaultType(JCExpression tree, Env<AttrContext> env, JCDefaultValue speculativeTree, Map<ResultInfo, Type> speculativeTypes) {\n+            super(tree, env, speculativeTree, speculativeTypes);\n+        }\n+\n+        @Override\n+        ResultInfo resultInfo(ResultInfo resultInfo) {\n+            return resultInfo.dup(attr.defaultPolyContext(speculativeTree, speculativeTree.clazz.type.tsym, resultInfo.checkContext));\n+        }\n+\n+        @Override\n+        Type methodType() {\n+            return (speculativeTree.defaultValueConstructor != null) ?\n+                    speculativeTree.defaultValueConstructor.baseType() : syms.errType;\n+        }\n+\n+        @Override\n+        ArgumentType<JCDefaultValue> dup(JCDefaultValue tree, Env<AttrContext> env) {\n+            return new ResolvedDefaultType(tree, env, speculativeTree, speculativeTypes);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -5028,1 +5028,1 @@\n-        if (isPossiblePolyDefault(tree, clazztype)) {\n+        if (TreeInfo.isPossiblePolyDefault(tree, clazztype)) {\n@@ -5042,1 +5042,1 @@\n-            Type constrType = new ForAll(clazzTypeArgs,\n+            Type constrType = tree.defaultValueConstructor = new ForAll(clazzTypeArgs,\n@@ -5054,0 +5054,1 @@\n+            \ttree.defaultValueConstructor = types.createMethodTypeWithReturn(defaultType, syms.voidType);\n@@ -5081,10 +5082,0 @@\n-    \/\/where\n-    boolean isPossiblePolyDefault(JCDefaultValue tree, Type clazztype) {\n-        JCTypeApply applyTree = TreeInfo.getTypeApplication(tree.clazz);\n-        if (applyTree != null) {\n-            return applyTree.arguments.isEmpty();\n-        } else {\n-            \/\/ No type arguments before .default - Consider if the type is generic or not\n-            return clazztype == null || clazztype.tsym.type.isParameterized();\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1410,1 +1410,1 @@\n-\n+\t\tpublic Type defaultValueConstructor; \/\/ Possible parameterized type of \"constructor\" \n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,0 +279,11 @@\n+    \/** Return true if a default expression may represent a poly expression (with elided types) *\/\n+    public static boolean isPossiblePolyDefault(JCDefaultValue tree, Type clazztype) {\n+        JCTypeApply applyTree = TreeInfo.getTypeApplication(tree.clazz);\n+        if (applyTree != null) {\n+            return applyTree.arguments.isEmpty();\n+        } else {\n+            \/\/ No type arguments before .default - Consider if the type is generic or not\n+            return clazztype == null || clazztype.tsym.type.isParameterized();\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8210906\n+ * @summary [lworld] default value creation should not impose raw types on users.\n+ * @run main PolyDefaultArgs\n+ *\/\n+\n+public primitive class PolyDefaultArgs<T> {\n+\n+    static void m(PolyDefaultArgs<String> ls) { }\n+\n+    public static void main(String [] args) {\n+        m(new PolyDefaultArgs<>()); \/\/ OK\n+        m(PolyDefaultArgs<String>.default); \/\/ OK\n+        m(PolyDefaultArgs.default); \/\/ Now also OK\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PolyDefaultArgs.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"}]}