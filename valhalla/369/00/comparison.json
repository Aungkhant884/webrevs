{"files":[{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+\/**\n+ * A tree node for a {@code default} instance initializion expression.\n+ *\n+ * For example:\n+ * <pre>\n+ *   Optional<String>.default\n+ * <\/pre>\n+ *\n+ * @jls todo\n+ *\n+ * @since valhalla\n+ *\/\n+public interface DefaultExpressionTree extends ExpressionTree {\n+\n+    \/**\n+     * Returns the name of the class of the instance being initialized.\n+     * @return the name\n+     *\/\n+    ExpressionTree getClazz();\n+\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DefaultExpressionTree.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -256,0 +256,7 @@\n+        \/**\n+         * Used for instances of {@link DefaultExpressionTree}.\n+         *\n+         * @since valhalla\n+         *\/\n+        DEFAULT_EXPRESSION(DefaultExpressionTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -172,0 +172,8 @@\n+    \/**\n+     * Visits a DefaultExpression node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\/\n+    R visitDefaultExpression(DefaultExpressionTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -302,0 +302,12 @@\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n+    public R visitDefaultExpression(DefaultExpressionTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -388,0 +388,13 @@\n+    \/**\n+     * {@inheritDoc} This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n+    @Override\n+    public R visitDefaultExpression(DefaultExpressionTree node, P p) {\n+        R r = scan(node.getClazz(), p);\n+        return r;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4257,1 +4257,1 @@\n-                tree.name == names._class || tree.name == names._default)\n+                tree.name == names._class)\n@@ -4259,4 +4259,0 @@\n-            if (tree.name == names._default && !allowPrimitiveClasses) {\n-                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                        Feature.PRIMITIVE_CLASSES.error(sourceName));\n-            }\n@@ -4284,9 +4280,4 @@\n-                if (tree.name == names._default) {\n-                    result = check(tree, litType(BOT).constType(null),\n-                            KindSelector.VAL, resultInfo);\n-                } else {\n-                    log.error(tree.pos(), Errors.TypeVarCantBeDeref);\n-                    result = tree.type = types.createErrorType(tree.name, site.tsym, site);\n-                    tree.sym = tree.type.tsym;\n-                    return;\n-                }\n+                log.error(tree.pos(), Errors.TypeVarCantBeDeref);\n+                result = tree.type = types.createErrorType(tree.name, site.tsym, site);\n+                tree.sym = tree.type.tsym;\n+                return;\n@@ -4436,3 +4427,1 @@\n-                } else if (name == names._default) {\n-                    return new VarSymbol(STATIC, names._default, site, site.tsym);\n-                } else if (name == names.ref && site.isPrimitiveClass() && resultInfo.pkind.contains(KindSelector.TYP)) {\n+               } else if (name == names.ref && site.isPrimitiveClass() && resultInfo.pkind.contains(KindSelector.TYP)) {\n@@ -4451,4 +4440,0 @@\n-                if (name == names._default) {\n-                    \/\/ Be sure to return the default value before examining bounds\n-                    return new VarSymbol(STATIC, names._default, site, site.tsym);\n-                }\n@@ -4484,2 +4469,0 @@\n-                } else if (name == names._default) {\n-                    return new VarSymbol(STATIC, names._default, site, site.tsym);\n@@ -4901,0 +4884,50 @@\n+    @Override\n+    public void visitDefaultExpression(JCDefaultExpression tree) {\n+        if (!allowPrimitiveClasses) {\n+            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n+        }\n+\n+        \/\/ Attribute the qualifier expression\n+        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP, Type.noType));\n+        if (!pkind().contains(KindSelector.TYP_PCK))\n+            site = capture(site); \/\/ Capture field access\n+\n+        switch (site.getTag()) {\n+            case ERROR:\n+            case PACKAGE:\n+                log.error(tree.pos(), Errors.CantDeref(site));\n+                break;\n+            case WILDCARD:\n+                throw new AssertionError(tree);\n+            case ARRAY:\n+            case CLASS:\n+                site = checkPossiblePolyDefault(tree, site);\n+                break;\n+        }\n+\n+        Symbol sym = new VarSymbol(STATIC, names._default, site, site.tsym);\n+        result = checkId(tree, site, sym, env, resultInfo);\n+    }\n+    \/\/where\n+    Type checkPossiblePolyDefault(JCDefaultExpression tree, Type t) {\n+\n+        JCTypeApply applyTree = TreeInfo.getTypeApplication(tree.clazz);\n+        Type expectedType = pt();\n+\n+        if (applyTree != null) {\n+            \/\/ Type arguments are supplied, no need to infer\n+            tree.polyKind = PolyKind.STANDALONE;\n+            return chk.checkClassType(tree.pos(), t, true);\n+        } else {\n+            \/\/ No type arguments before .default - Consider if the type id generic or not\n+            if (t.tsym.type.getTypeArguments().isEmpty() || expectedType.getTag() != NONE) {\n+                \/\/ Oh, nice - the type is not generic, not a poly expression\n+                tree.polyKind = PolyKind.STANDALONE;\n+            } else {\n+                tree.polyKind = PolyKind.POLY;\n+            }\n+        }\n+        return (t.tsym == expectedType.tsym) ? expectedType : t;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":56,"deletions":23,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2351,10 +2351,0 @@\n-        } else if (tree.name == names._default) {\n-            if (tree.type.asElement().isPrimitiveClass()) {\n-                code.emitop2(defaultvalue, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n-            } else if (tree.type.isReference()) {\n-                code.emitop0(aconst_null);\n-            } else {\n-                code.emitop0(zero(Code.typecode(tree.type)));\n-            }\n-            result = items.makeStackItem(tree.type);\n-            return;\n@@ -2417,0 +2407,12 @@\n+    public void visitDefaultExpression(JCDefaultExpression tree) {\n+        if (tree.type.asElement().isPrimitiveClass()) {\n+            code.emitop2(defaultvalue, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n+        } else if (tree.type.isReference()) {\n+            code.emitop0(aconst_null);\n+        } else {\n+            code.emitop0(zero(Code.typecode(tree.type)));\n+        }\n+        result = items.makeStackItem(tree.type);\n+        return;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -203,1 +203,2 @@\n-                    rhs = make.Select(type, new VarSymbol(STATIC, names._default, currentClass.type, currentClass.sym));\n+                    rhs = make.DefaultExpression(type);\n+                    rhs.type = currentClass.type;\n@@ -338,1 +339,1 @@\n-        if (fieldAccess.name != names._class && fieldAccess.name != names._default) {  \/\/ TODO: this and super ??\n+        if (fieldAccess.name != names._class) {  \/\/ TODO: this and super ??\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1360,1 +1360,1 @@\n-                                t = to(F.at(pos).Select(t, names._default));\n+                                t = to(F.at(pos).DefaultExpression(t));\n@@ -1437,1 +1437,1 @@\n-                                    t =  toP(F.at(token.pos).Select(t, names._default));\n+                                    t =  toP(F.at(token.pos).DefaultExpression(t));\n@@ -2280,1 +2280,5 @@\n-                t = toP(F.at(pos).Select(t, selector == CLASS ? names._class : names._default));\n+                if (selector == CLASS) {\n+                    t = toP(F.at(pos).Select(t, names._class));\n+                } else {\n+                    t = toP(F.at(pos).DefaultExpression(t));\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -256,0 +256,4 @@\n+        \/** Default expressions, of type DefaultExpressionTree.\n+         *\/\n+        DEFAULT_EXPRESSION,\n+\n@@ -1361,0 +1365,26 @@\n+    \/**\n+     * A \"Identifier<TA1, TA2>.default\" construction.\n+     *\/\n+    public static class JCDefaultExpression extends JCPolyExpression implements DefaultExpressionTree {\n+        public JCExpression clazz;\n+\n+        protected JCDefaultExpression(JCExpression clazz) {\n+            this.clazz = clazz;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitDefaultExpression(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.DEFAULT_EXPRESSION; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public ExpressionTree getClazz() { return clazz; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitDefaultExpression(this, d);\n+        }\n+        @Override\n+        public Tag getTag() {\n+            return DEFAULT_EXPRESSION;\n+        }\n+    }\n+\n@@ -3212,0 +3242,1 @@\n+        JCDefaultExpression DefaultExpression(JCExpression type);\n@@ -3290,0 +3321,1 @@\n+        public void visitDefaultExpression(JCDefaultExpression that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -746,0 +746,9 @@\n+    public void visitDefaultExpression(JCDefaultExpression tree) {\n+        try {\n+            printExpr(tree.clazz, TreeInfo.postfixPrec);\n+            print(\".default\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -201,0 +201,7 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDefaultExpression(DefaultExpressionTree node, P p) {\n+        JCDefaultExpression t = (JCDefaultExpression) node;\n+        JCExpression clazz = copy(t.clazz, p);\n+        return M.at(t.pos).DefaultExpression(clazz);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -278,0 +278,10 @@\n+    \/** Return true if a tree directly or indirectly represents a type application. *\/\n+    public static JCTypeApply getTypeApplication(JCTree tree) {\n+        switch(tree.getTag()) {\n+            case TYPEAPPLY: return (JCTypeApply)tree;\n+            case NEWCLASS: return getTypeApplication(((JCNewClass)tree).clazz);\n+            case ANNOTATED_TYPE: return getTypeApplication(((JCAnnotatedType)tree).underlyingType);\n+            default: return null;\n+        }\n+    }\n+\n@@ -490,0 +500,2 @@\n+            case DEFAULT_EXPRESSION:\n+                return getStartPos(((JCDefaultExpression) tree).clazz);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -301,0 +301,6 @@\n+    public JCDefaultExpression DefaultExpression(JCExpression type) {\n+        JCDefaultExpression tree = new JCDefaultExpression(type);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -189,0 +189,4 @@\n+    public void visitDefaultExpression(JCDefaultExpression tree) {\n+        scan(tree.clazz);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -383,0 +383,5 @@\n+    public void visitDefaultExpression(JCDefaultExpression tree) {\n+        tree.clazz = translate(tree.clazz);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8210906\n+ * @summary [lworld] default value creation should not impose raw types on users.\n+ * @compile\/fail\/ref=PolyDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev PolyDefault.java\n+ *\/\n+import java.util.concurrent.Callable;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public primitive class PolyDefault<E> implements Callable<E> {\n+    E value;\n+    protected PolyDefault() { this.value = E.default; }\n+    PolyDefault(E value) { this.value = value; }\n+\n+    @Override\n+    public E call() throws Exception {\n+        return value;\n+    }\n+\n+    static primitive class NotParameterized {\n+        public int i = 0;\n+    }\n+\n+    @FunctionalInterface\n+    interface PolyProducer {\n+        PolyDefault<String> produce();\n+    }\n+\n+    public static void main(String [] args) throws Exception {\n+        PolyDefault<LinkedList<Long>> foo = PolyDefault.default; \/\/ Poly expression\n+        LinkedList<Long> a = foo.call(); \/\/ This should fine\n+        var nonGenericDefault = NotParameterized.default; \/\/ Not poly\n+        var genericDefault1 = PolyDefault<LinkedList<Long>>.default;\n+\n+        PolyProducer genericDefault = () -> PolyDefault.default;\n+\n+        List<String> boom = PolyDefault.default; \/\/ Type error\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PolyDefault.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+PolyDefault.java:38:40: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: PolyDefault, java.util.List<java.lang.String>)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PolyDefault.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=UncheckedDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev UncheckedDefault.java\n+ * @run main UncheckedDefault\n@@ -13,0 +13,1 @@\n+        String s = foo.value;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UncheckedDefault.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-UncheckedDefault.java:12:56: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedDefault, UncheckedDefault<java.lang.String>\n-- compiler.err.warnings.and.werror\n-1 error\n-1 warning\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UncheckedDefault.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"}]}