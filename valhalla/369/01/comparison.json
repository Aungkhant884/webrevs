{"files":[{"patch":"@@ -53,0 +53,1 @@\n+import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;\n@@ -675,1 +676,1 @@\n-    Type attribTree(JCTree tree, Env<AttrContext> env, ResultInfo resultInfo) {\n+    Type attribTree (JCTree tree, Env<AttrContext> env, ResultInfo resultInfo) {\n@@ -5023,1 +5024,1 @@\n-        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n+        Type clazztype = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP, Type.noType));\n@@ -5025,1 +5026,24 @@\n-            site = capture(site); \/\/ Capture field access\n+            clazztype = capture(clazztype); \/\/ Capture field access\n+\n+        if (isPossiblePolyDefault(tree, clazztype)) {\n+            var flavor = clazztype.getTag() == CLASS ? clazztype.getFlavor() : Flavor.X_Typeof_X;\n+            ClassType site = new ClassType(clazztype.getEnclosingType(),\n+                        clazztype.tsym.type.getTypeArguments(),\n+                                           clazztype.tsym,\n+                                           clazztype.getMetadata(),\n+                                           flavor);\n+\n+            Env<AttrContext> diamondEnv = env.dup(tree);\n+            diamondEnv.info.selectSuper = false;\n+            diamondEnv.info.pendingResolutionPhase = MethodResolutionPhase.BASIC;\n+\n+            final TypeSymbol csym = clazztype.tsym;\n+            var clazzTypeArgs = csym.type.getTypeArguments();\n+            Type constrType = new ForAll(clazzTypeArgs,\n+                    new MethodType(List.nil(), csym.type, List.nil(), syms.methodClass));\n+\n+            MethodSymbol constructor = new MethodSymbol(Flags.SYNTHETIC, names.init, constrType, site.tsym);\n+            ResultInfo diamondResult = new ResultInfo(KindSelector.VAL, newMethodTemplate(resultInfo.pt, List.nil(), List.nil()),\n+                    defaultPolyContext(tree, csym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);\n+\n+            Type defaultType = checkId(tree, site, constructor, diamondEnv, diamondResult);\n@@ -5027,1 +5051,10 @@\n-        Symbol sym = switch (site.getTag()) {\n+            if (defaultType.isErroneous()) {\n+                tree.clazz.type = types.createErrorType(clazztype);\n+            } else {\n+                tree.clazz.type = defaultType.getReturnType();\n+            }\n+            clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);\n+            result = check(tree, clazztype, KindSelector.VAL, resultInfo);\n+        } else {\n+            chk.validate(tree.clazz, env);\n+            Symbol sym = switch (clazztype.getTag()) {\n@@ -5029,7 +5062,17 @@\n-                case PACKAGE -> {\n-                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n-                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n-                    yield syms.errSymbol;\n-                }\n-                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n-                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n+                case ERROR -> types.createErrorType(names._default, clazztype.tsym, clazztype).tsym;\n+                default -> new VarSymbol(STATIC, names._default, clazztype, clazztype.tsym);\n+            };\n+            if (clazztype.hasTag(TYPEVAR) && sym.kind != ERR) {\n+                clazztype = types.skipTypeVars(clazztype, true);\n+            }\n+            result = tree.type = checkId(tree, clazztype, sym, env, resultInfo);\n+        }\n+    }\n+    \/\/ where\n+    CheckContext defaultPolyContext(JCDefaultValue tree, TypeSymbol tsym, CheckContext checkContext) {\n+        return new Check.NestedCheckContext(checkContext) {\n+            @Override\n+            public void report(DiagnosticPosition _unused, JCDiagnostic details) {\n+                enclosingContext.report(tree.clazz,\n+                        diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));\n+            }\n@@ -5037,3 +5080,9 @@\n-\n-        if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-            site = types.skipTypeVars(site, true);\n+    }\n+    \/\/where\n+    boolean isPossiblePolyDefault(JCDefaultValue tree, Type clazztype) {\n+        JCTypeApply applyTree = TreeInfo.getTypeApplication(tree.clazz);\n+        if (applyTree != null) {\n+            return applyTree.arguments.isEmpty();\n+        } else {\n+            \/\/ No type arguments before .default - Consider if the type is generic or not\n+            return clazztype == null || clazztype.tsym.type.isParameterized();\n@@ -5041,1 +5090,0 @@\n-        result = checkId(tree, site, sym, env, resultInfo);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":63,"deletions":15,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -279,0 +279,10 @@\n+    \/** Return true if a tree directly or indirectly represents a type application. *\/\n+    public static JCTypeApply getTypeApplication(JCTree tree) {\n+        switch(tree.getTag()) {\n+            case TYPEAPPLY: return (JCTypeApply)tree;\n+            case NEWCLASS: return getTypeApplication(((JCNewClass)tree).clazz);\n+            case ANNOTATED_TYPE: return getTypeApplication(((JCAnnotatedType)tree).underlyingType);\n+            default: return null;\n+        }\n+    }\n+\n@@ -297,0 +307,3 @@\n+            case DEFAULT_VALUE:\n+                ((JCDefaultValue)tree).polyKind = pkind;\n+                break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8210906\n+ * @summary [lworld] default value creation should not impose raw types on users.\n+ * @compile\/fail\/ref=PolyDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev PolyDefault.java\n+ *\/\n+import java.util.concurrent.Callable;\n+import java.util.LinkedList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public primitive class PolyDefault<E> implements Callable<E> {\n+    E value;\n+    protected PolyDefault() { this.value = E.default; }\n+    PolyDefault(E value) { this.value = value; }\n+\n+    @Override\n+    public E call() throws Exception {\n+        return value;\n+    }\n+\n+    @FunctionalInterface\n+    interface PolyProducer {\n+        PolyDefault<String> produce();\n+    }\n+\n+    interface Foo<X extends Number> extends List<X> {\n+    }\n+\n+    public static <T extends Boolean> String overload(List<T> nums) {\n+        return \"\";\n+    }\n+\n+    public static <T extends Number> T overload(Collection<T> nums) {\n+        return T.default;\n+    }\n+\n+    public static void main(String [] args) throws Exception {\n+\n+        List<Integer> il = LinkedList.default;\n+        Integer i0 = il.get(0);\n+\n+        var a = overload(Foo.default);\n+        var b = a.intValue();\n+\n+        \/\/ Things which should just work\n+        PolyDefault<LinkedList<Long>> foo = PolyDefault.default; \/\/ Poly expression\n+        LinkedList<Long> c = foo.call(); \/\/ This should be fine, inferred above\n+        var genericDefault1 = PolyDefault<LinkedList<Long>>.default;\n+\n+        PolyProducer genericDefault = () -> PolyDefault.default;\n+\n+        \/\/ Problems\n+        List<String> boing = new PolyDefault<>(); \/\/ Error: Can't make a PolyDefault into a list\n+        List<String> boom = PolyDefault.default; \/\/ Error: Can't make a PolyDefault into a list\n+        List<String> tschak = Foo.default; \/\/ Error: Can make a Foo into a list, but then must be List<? extends Number>\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PolyDefault.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+PolyDefault.java:54:45: compiler.err.prob.found.req: (compiler.misc.cant.apply.diamond.1: (compiler.misc.diamond: PolyDefault), (compiler.misc.infer.no.conforming.instance.exists: E, PolyDefault<E>, java.util.List<java.lang.String>))\n+PolyDefault.java:55:29: compiler.err.prob.found.req: (compiler.misc.cant.apply.diamond.1: (compiler.misc.diamond: PolyDefault), (compiler.misc.infer.no.conforming.instance.exists: E, PolyDefault<E>, java.util.List<java.lang.String>))\n+PolyDefault.java:56:31: compiler.err.prob.found.req: (compiler.misc.cant.apply.diamond.1: (compiler.misc.diamond: PolyDefault.Foo), (compiler.misc.incompatible.bounds: X, (compiler.misc.eq.bounds: java.lang.String), (compiler.misc.upper.bounds: java.lang.Number)))\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PolyDefault.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -1,20 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8210906\n- * @summary [lworld] default value creation should not impose raw types on users.\n- * @compile\/fail\/ref=UncheckedDefault.out -Xlint:all -Werror -XDrawDiagnostics -XDdev UncheckedDefault.java\n- *\/\n-\n-public primitive class UncheckedDefault<E> {\n-    E value;\n-    UncheckedDefault(E value) { this.value = value; }\n-    public static void main(String [] args) {\n-        UncheckedDefault<String> foo = UncheckedDefault.default;\n-    }\n-\n-    public E makeDefault() {\n-        E e = E.default;\n-        return e;\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UncheckedDefault.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-UncheckedDefault.java:12:56: compiler.warn.prob.found.req: (compiler.misc.unchecked.assign), UncheckedDefault, UncheckedDefault<java.lang.String>\n-- compiler.err.warnings.and.werror\n-1 error\n-1 warning\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UncheckedDefault.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,2 +1,2 @@\n-UnknownTypeDefault.java:11:22: compiler.err.cant.resolve.location: kindname.class, Y, null, null, (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n-UnknownTypeDefault.java:12:24: compiler.err.cant.resolve.location: kindname.class, y.Z, null, null, (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n+UnknownTypeDefault.java:11:21: compiler.err.cant.resolve.location: kindname.class, Y, , , (compiler.misc.location: kindname.class, UnknownTypeDefault, null)\n+UnknownTypeDefault.java:12:22: compiler.err.doesnt.exist: y\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnknownTypeDefault.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}