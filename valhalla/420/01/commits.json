[{"commit":{"message":"Store total frame size in sp_inc"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp"}],"sha":"d9fa5724dd5142edaa7f99af0234222ad0ea66ce"},{"commit":{"message":"8266890: [lworld] [AArch64] add support for InlineTypePassFieldsAsArgs\n\nThis patch implements InlineTypePassFieldsAsArgs on AArch64 and the\nassociated stack extension\/repair mechanism. It mostly follows the x86\nimplementation closely except for how the stack increment is stored in\nthe callee frame. On x86 the sp_inc stack slot stores the total size of\nthe frame which is the sum of the extension space, return address copy,\nand the original method frame size (i.e. the total bytes needed to pop\nthe frame). On AArch64 we just store the size of the extension space. I\ndid it this way because it simplifies the stack repair code in\nMacroAssembler::remove_frame (I've added some notes there to document\nthis). I don't think this should cause any problem because only the\nMacroAssembler and platform-dependant frame walking code need to be\naware of this.\n\nThis patch includes JDK-8266609 which is a small refactoring in mainline\nJDK to simplify how the frame size is passed around in the AArch64 C1\nbackend.\n\nThere was some X86 specific code in unpack_inline_args() in\nmacroAssembler_common.cpp. I've split this out into an arch-dependant\nMacroAssembler::extend_stack_for_inline_args().\n\nMacroAssembler::pack_inline_helper() and shuffle_inline_args() now take\na new Register val_array argument which is the register holding the\nbuffered oop array for packing. Previously it assumed this was already\nloaded in RAX (x86) or x20 (AArch64) but IMO passing it in explicitly\nmakes the code easier to understand.\n\nThere is one new test failure: TestNullableInlineTypes.java. The test\nseems functionally correct but there is a failure verifying the C2 IR\ngraph (see below). I haven't investigated this but the test enables\nInlineTypePassFieldsAsArgs which we don't support yet on AArch64 so that\nmight be causing the failure.\n\nException in thread \"main\" java.lang.RuntimeException: Graph for 'TestNullableInlineTypes::test26' contains forbidden node:\n83  StoreL  ===  176  177  84  14  [[ 89 ]]  @compiler\/valhalla\/inlinetypes\/MyValue3:exact+16 *, name=l, idx=6;  Memory: @rawptr:BotPTR, idx=Raw; !orig=82 !jvms: TestNullableInlineTypes::test26 @ bci:13 (line 704): expected false, was true"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp"},{"filename":"src\/hotspot\/share\/asm\/macroAssembler_common.cpp"},{"filename":"src\/hotspot\/share\/asm\/macroAssembler_common.hpp"},{"filename":"src\/hotspot\/share\/runtime\/arguments.cpp"},{"filename":"src\/hotspot\/share\/runtime\/frame.cpp"},{"filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp"},{"filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp"}],"sha":"435308d639f8b21e3dedc167bbafc2676e707f77"}]