{"files":[{"patch":"@@ -1432,0 +1432,8 @@\n+        \/**\n+         * Does `this' symbolize a primitive class that would, under the translation\n+         * scheme in effect be lowered into two class files on a bifurcased basis ??\n+         *\/\n+        public boolean isSplitPrimitiveClass(Types types) {\n+            return types.splitPrimitiveClass && this.isPrimitiveClass();\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,0 +104,12 @@\n+    \/**\n+     * If true, the ClassWriter will split a primitive class declaration into two class files\n+     * P.ref.class and P.val.class (P.class for pure primitive classes)\n+     *\n+     * This is the default behavior, can be eoverridden with -XDunifiedValRefClass\n+     *\n+     * If false, we emit a single class for a primtive class 'P' and the reference projection and\n+     * value projection types are encoded in descriptors as LP; and QP; resperctively.\n+     *\/\n+\n+    public boolean splitPrimitiveClass;\n+\n@@ -129,0 +141,1 @@\n+        splitPrimitiveClass = options.isUnset(\"unifiedValRefClass\");\n@@ -5356,1 +5369,1 @@\n-            if (ct.isReferenceProjection()) {\n+            if (types.splitPrimitiveClass && ct.isReferenceProjection()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3111,5 +3111,4 @@\n-            \/\/ widening coversion is a NOP for the VM due to subtyping relationship at class file\n-            return tree;\n-        } else {\n-            \/\/ For narrowing conversion, insert a cast which should trigger a null check\n-            return (T) make.TypeCast(type, tree);\n+            \/\/ widening coversion is a NOP for the VM due to subtyping relationship at class file level\n+            \/\/ where we bifurcate a primitive class into two class files.\n+            if (types.splitPrimitiveClass)\n+                return tree;\n@@ -3117,0 +3116,4 @@\n+        \/\/ For narrowing conversion, insert a cast which should trigger a null check\n+        \/\/ For widening conversions, insert a cast if emitting a unified class file.\n+        return (T) make.TypeCast(type, tree);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2690,1 +2690,1 @@\n-                    readClassFileInternal(referenceProjection);\n+                    referenceProjection.complete();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -848,1 +848,1 @@\n-            if (inner.isPrimitiveClass()) {\n+            if (inner.isSplitPrimitiveClass(types)) {\n@@ -886,1 +886,1 @@\n-            if (csym.isPrimitiveClass()) {\n+            if (csym.isSplitPrimitiveClass(types)) {\n@@ -902,1 +902,1 @@\n-                    if (s.isPrimitiveClass() && s.owner.kind != PCK) {\n+                    if (s.isSplitPrimitiveClass(types) && s.owner.kind != PCK) {\n@@ -919,1 +919,1 @@\n-        if (csym.owner.kind != PCK || csym.isPrimitiveClass()) {\n+        if (csym.owner.kind != PCK || csym.isSplitPrimitiveClass(types)) {\n@@ -922,1 +922,1 @@\n-            if (outerMost.isPrimitiveClass()) {\n+            if (outerMost.isSplitPrimitiveClass(types)) {\n@@ -1533,1 +1533,1 @@\n-        if (c.isPrimitiveClass()) {\n+        if (c.isSplitPrimitiveClass(types)) {\n@@ -1634,2 +1634,2 @@\n-        Type supertype = c.isPrimitiveClass() ? c.type.referenceProjection() : types.supertype(c.type);\n-        List<Type> interfaces = c.isPrimitiveClass() ? List.nil() : types.interfaces(c.type);\n+        Type supertype = c.isSplitPrimitiveClass(types) ? c.type.referenceProjection() : types.supertype(c.type);\n+        List<Type> interfaces = c.isSplitPrimitiveClass(types) ? List.nil() : types.interfaces(c.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -402,0 +402,11 @@\n+    public void emitLdc(LoadableConstant constant, int od) {\n+        if (od <= 255) {\n+            emitop1(ldc1, od, constant);\n+        }\n+        else {\n+            emitop2(ldc2, od, constant);\n+        }\n+    }\n+\n+    \/** Emit a ldc (or ldc_w) instruction, taking into account operand size\n+     *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2275,1 +2275,1 @@\n-        \/\/ inline widening conversion is a nop, as the VM sees a subtyping relationship.\n+        \/\/ inline widening conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n@@ -2278,1 +2278,1 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type)) &&\n+            (!tree.clazz.type.isReferenceProjection() || !types.splitPrimitiveClass || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type)) &&\n@@ -2348,1 +2348,1 @@\n-            code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, !types.splitPrimitiveClass && tree.selected.type.isPrimitiveClass()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-                    if (ct.isReferenceProjection()) {\n+                    if (types.splitPrimitiveClass && ct.isReferenceProjection()) {\n@@ -517,2 +517,2 @@\n-        signatureGen.assembleSig(t.isPrimitiveClass() ? t.referenceProjection() : types.supertype(t));\n-        if (!t.isPrimitiveClass()) {\n+        signatureGen.assembleSig(t.isPrimitiveClass() && types.splitPrimitiveClass ? t.referenceProjection() : types.supertype(t));\n+        if (!t.isPrimitiveClass() || !types.splitPrimitiveClass) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265423\n+ * @summary Experimental support for generating a single class file per primitive class\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile SplitPrimitiveClassBytecodeTest.java\n+ * @run main SplitPrimitiveClassBytecodeTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+public class SplitPrimitiveClassBytecodeTest {\n+\n+    public primitive class X {\n+\n+        X.ref xr = null;\n+\n+        public void foo(X.ref[] xra, X[] xa) {\n+            xa = new X[10];\n+            xra = new X.ref[10];\n+            xra[0] = xa[0];\n+            xa[1] = xra[0];\n+            Class<?> c = X.class;\n+            c = X.ref.class;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new SplitPrimitiveClassBytecodeTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"SplitPrimitiveClassBytecodeTest$X.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+        \/\/ check field\n+        \"final SplitPrimitiveClassBytecodeTest$X$ref xr;\",\n+        \"descriptor: LSplitPrimitiveClassBytecodeTest$X$ref;\",\n+        \"flags: (0x0010) ACC_FINAL\",\n+\n+        \/\/ check method\n+        \"public void foo(SplitPrimitiveClassBytecodeTest$X$ref[], SplitPrimitiveClassBytecodeTest$X[]);\",\n+        \"descriptor: ([LSplitPrimitiveClassBytecodeTest$X$ref;[QSplitPrimitiveClassBytecodeTest$X;)V\",\n+        \" 0: bipush        10\",\n+        \" 2: anewarray     #11                 \/\/ class \\\"QSplitPrimitiveClassBytecodeTest$X;\\\"\",\n+        \" 5: astore_2\",\n+        \" 6: bipush        10\",\n+        \" 8: anewarray     #13                 \/\/ class SplitPrimitiveClassBytecodeTest$X$ref\",\n+        \"11: astore_1\",\n+        \"12: aload_1\",\n+        \"13: iconst_0\",\n+        \"14: aload_2\",\n+        \"15: iconst_0\",\n+        \"16: aaload\",\n+        \"17: aastore\",\n+        \"18: aload_2\",\n+        \"19: iconst_1\",\n+        \"20: aload_1\",\n+        \"21: iconst_0\",\n+        \"22: aaload\",\n+        \"23: checkcast     #11                 \/\/ class \\\"QSplitPrimitiveClassBytecodeTest$X;\\\"\",\n+        \"26: aastore\",\n+        \"27: ldc           #1                  \/\/ class SplitPrimitiveClassBytecodeTest$X\",\n+        \"29: astore_3\",\n+        \"30: ldc           #13                 \/\/ class SplitPrimitiveClassBytecodeTest$X$ref\",\n+        \"32: astore_3\",\n+        \"33: return\",\n+         });\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassBytecodeTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265423\n+ * @summary Experimental support for generating a single class file per primitive class\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @run main SplitPrimitiveClassInnerClassesTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+public class SplitPrimitiveClassInnerClassesTest {\n+\n+    primitive class V<T> implements java.io.Serializable {}\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(SplitPrimitiveClassInnerClassesTest.class.getResourceAsStream(\"SplitPrimitiveClassInnerClassesTest.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of inner class attribute *\/\n+        InnerClasses_attribute inners = (InnerClasses_attribute) cls.attributes.get(Attribute.InnerClasses);\n+        if (inners == null) {\n+            throw new AssertionError(\"Missing inner class attribute\");\n+        }\n+        boolean foundV = false, foundVref = false;\n+        for (int i = 0; i < inners.number_of_classes; i++) {\n+            String name = inners.classes[i].getInnerName(cls.constant_pool);\n+            if (name.equals(\"V\"))\n+                foundV = true;\n+            else if (name.equals(\"V$ref\"))\n+                foundVref = true;\n+        }\n+        if (!foundV || !foundVref) {\n+            throw new AssertionError(\"Incorrect inner class attribute\");\n+        }\n+\n+        \/\/ Test signature attribute\n+        cls = ClassFile.read(SplitPrimitiveClassInnerClassesTest.class.getResourceAsStream(\"SplitPrimitiveClassInnerClassesTest$V.class\"));\n+        Signature_attribute signature = (Signature_attribute)cls.attributes.get(Attribute.Signature);\n+        String sign =  signature.getSignature(cls.constant_pool);\n+        if (sign == null || !sign.equals(\"<T:Ljava\/lang\/Object;>LSplitPrimitiveClassInnerClassesTest$V$ref<TT;>;\")) {\n+            throw new RuntimeException(\"Wrong signature \" + sign);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassInnerClassesTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265423\n+ * @summary Experimental support for generating a single class file per primitive class\n+ * @compile SplitPrimitiveClassNestHostTest.java\n+ * @run main SplitPrimitiveClassNestHostTest\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public primitive class SplitPrimitiveClassNestHostTest implements java.io.Serializable {\n+\n+    primitive class Inner {}\n+\n+    public static void main(String [] args) {\n+\n+        \/\/ check wiring of super types.\n+        Class<?> superClass = SplitPrimitiveClassNestHostTest.class.getSuperclass();\n+        if (!superClass.equals(\n+                    SplitPrimitiveClassNestHostTest.class.referenceType().get()))\n+            throw new AssertionError(\"Wrong superclass for SplitPrimitiveClassNestHostTest\");\n+\n+        Class<?> [] superInterfaces = SplitPrimitiveClassNestHostTest.class.getInterfaces();\n+        if (superInterfaces.length != 1)\n+            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest\");\n+\n+        if (!superInterfaces[0].equals(PrimitiveObject.class))\n+            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest\");\n+\n+        \/\/ check super types of ref.class\n+        if (!superClass.getSuperclass().equals(Object.class))\n+            throw new AssertionError(\"Wrong superclass for SplitPrimitiveClassNestHostTest.ref\");\n+        superInterfaces = superClass.getInterfaces();\n+        if (superInterfaces.length != 1)\n+            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest.ref\");\n+\n+        if (!superInterfaces[0].equals(java.io.Serializable.class))\n+            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest.ref\");\n+\n+\n+        Class<?> nestHost = SplitPrimitiveClassNestHostTest.class.getNestHost();\n+        if (!nestHost.equals(SplitPrimitiveClassNestHostTest.class.referenceType().get()))\n+            throw new AssertionError(\"Wrong nest host: \" + nestHost);\n+\n+        Class<?> [] members = nestHost.getNestMembers();\n+        if (members.length != 4)\n+            throw new AssertionError(\"Wrong member count: \" + members.length);\n+\n+        if (!members[0].equals(nestHost))\n+            throw new AssertionError(\"Wrong initial member: \" + members[0]);\n+\n+        if (!members[1].equals(SplitPrimitiveClassNestHostTest.class))\n+            throw new AssertionError(\"Wrong member[1]: \" + members[1]);\n+\n+        if (!members[1].getNestHost().equals(nestHost))\n+            throw new AssertionError(\"Wrong nest host for member[1]: \" + members[1]);\n+\n+        if (!Arrays.equals(members[1].getNestMembers(), members))\n+            throw new AssertionError(\"Wrong nest members for member[1]: \" + members[1]);\n+\n+        if (!members[2].equals(Inner.class))\n+            throw new AssertionError(\"Wrong member[2]: \" + members[2]);\n+\n+        if (!members[2].getNestHost().equals(nestHost))\n+            throw new AssertionError(\"Wrong nest host for member[2]: \" + members[2]);\n+\n+        if (!Arrays.equals(members[2].getNestMembers(), members))\n+            throw new AssertionError(\"Wrong nest members for member[2]: \" + members[2]);\n+\n+        if (!members[3].equals(Inner.class.referenceType().get()))\n+            throw new AssertionError(\"Wrong member[3]: \" + members[3]);\n+\n+        if (!members[3].getNestHost().equals(nestHost))\n+            throw new AssertionError(\"Wrong nest host for member[3]: \" + members[3]);\n+\n+        if (!Arrays.equals(members[3].getNestMembers(), members))\n+            throw new AssertionError(\"Wrong nest members for member[3]: \" + members[3]);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassNestHostTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265423\n+ * @summary Experimental support for generating a single class file per primitive class\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDunifiedValRefClass UnifiedPrimitiveClassBytecodeTest.java\n+ * @run main UnifiedPrimitiveClassBytecodeTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+public class UnifiedPrimitiveClassBytecodeTest {\n+\n+    public primitive class X {\n+\n+        X.ref xr = null;\n+\n+        public void foo(X.ref[] xra, X[] xa) {\n+            xa = new X[10];\n+            xra = new X.ref[10];\n+            xra[0] = xa[0];\n+            xa[1] = xra[0];\n+            Class<?> c = X.class;\n+            c = X.ref.class;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new UnifiedPrimitiveClassBytecodeTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"UnifiedPrimitiveClassBytecodeTest$X.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+        \/\/ check field\n+        \"final UnifiedPrimitiveClassBytecodeTest$X xr;\",\n+        \"descriptor: LUnifiedPrimitiveClassBytecodeTest$X;\",\n+        \"flags: (0x0010) ACC_FINAL\",\n+\n+        \/\/ check method\n+        \"public void foo(UnifiedPrimitiveClassBytecodeTest$X[], UnifiedPrimitiveClassBytecodeTest$X[]);\",\n+        \"descriptor: ([LUnifiedPrimitiveClassBytecodeTest$X;[QUnifiedPrimitiveClassBytecodeTest$X;)V\",\n+        \" 0: bipush        10\",\n+        \" 2: anewarray     #11                 \/\/ class \\\"QUnifiedPrimitiveClassBytecodeTest$X;\\\"\",\n+        \" 5: astore_2\",\n+        \" 6: bipush        10\",\n+        \" 8: anewarray     #13                 \/\/ class UnifiedPrimitiveClassBytecodeTest$X\",\n+        \"11: astore_1\",\n+        \"12: aload_1\",\n+        \"13: iconst_0\",\n+        \"14: aload_2\",\n+        \"15: iconst_0\",\n+        \"16: aaload\",\n+        \"17: checkcast     #13                 \/\/ class UnifiedPrimitiveClassBytecodeTest$X\",\n+        \"20: aastore\",\n+        \"21: aload_2\",\n+        \"22: iconst_1\",\n+        \"23: aload_1\",\n+        \"24: iconst_0\",\n+        \"25: aaload\",\n+        \"26: checkcast     #11                 \/\/ class \\\"QUnifiedPrimitiveClassBytecodeTest$X;\\\"\",\n+        \"29: aastore\",\n+        \"30: ldc           #11                 \/\/ class \\\"QUnifiedPrimitiveClassBytecodeTest$X;\\\"\",\n+        \"32: astore_3\",\n+        \"33: ldc           #13                 \/\/ class UnifiedPrimitiveClassBytecodeTest$X\",\n+        \"35: astore_3\",\n+        \"36: return\",\n+         });\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassBytecodeTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265423\n+ * @summary Experimental support for generating a single class file per primitive class\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDunifiedValRefClass UnifiedPrimitiveClassInnerClassesTest.java\n+ * @run main UnifiedPrimitiveClassInnerClassesTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+public class UnifiedPrimitiveClassInnerClassesTest {\n+\n+    primitive class V<T> implements java.io.Serializable {}\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(UnifiedPrimitiveClassInnerClassesTest.class.getResourceAsStream(\"UnifiedPrimitiveClassInnerClassesTest.class\"));\n+\n+        if (cls == null) {\n+            throw new AssertionError(\"Could not locate the class files\");\n+        }\n+\n+        \/* Check emission of inner class attribute *\/\n+        InnerClasses_attribute inners = (InnerClasses_attribute) cls.attributes.get(Attribute.InnerClasses);\n+        if (inners == null) {\n+            throw new AssertionError(\"Missing inner class attribute\");\n+        }\n+        boolean foundV = false, foundVref = false;\n+        for (int i = 0; i < inners.number_of_classes; i++) {\n+            String name = inners.classes[i].getInnerName(cls.constant_pool);\n+            if (name.equals(\"V\"))\n+                foundV = true;\n+            else if (name.equals(\"V$ref\"))\n+                foundVref = true;\n+        }\n+        if (!foundV || foundVref) {\n+            throw new AssertionError(\"Incorrect inner class attribute\");\n+        }\n+\n+        \/\/ Test signature attribute\n+        cls = ClassFile.read(UnifiedPrimitiveClassInnerClassesTest.class.getResourceAsStream(\"UnifiedPrimitiveClassInnerClassesTest$V.class\"));\n+        Signature_attribute signature = (Signature_attribute)cls.attributes.get(Attribute.Signature);\n+        String sign =  signature.getSignature(cls.constant_pool);\n+        if (sign == null || !sign.equals(\"<T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\")) {\n+            throw new RuntimeException(\"Wrong signature \" + sign);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassInnerClassesTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8265423\n+ * @summary Experimental support for generating a single class file per primitive class\n+ * @compile -XDunifiedValRefClass UnifiedPrimitiveClassNestHostTest.java\n+ * @run main UnifiedPrimitiveClassNestHostTest\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public primitive class UnifiedPrimitiveClassNestHostTest implements java.io.Serializable {\n+\n+    primitive class Inner {}\n+\n+    public static void main(String [] args) {\n+\n+       \/\/ check wiring of super types.\n+        Class<?> superClass = UnifiedPrimitiveClassNestHostTest.class.getSuperclass();\n+        if (!superClass.equals(Object.class))\n+            throw new AssertionError(\"Wrong superclass for UnifiedPrimitiveClassNestHostTest\");\n+\n+        Class<?> [] superInterfaces = UnifiedPrimitiveClassNestHostTest.class.getInterfaces();\n+        if (superInterfaces.length != 2)\n+            throw new AssertionError(\"Wrong super interfaces for UnifiedPrimitiveClassNestHostTest\");\n+\n+        if (!superInterfaces[0].equals(java.io.Serializable.class))\n+            throw new AssertionError(\"Wrong super interfaces for UnifiedPrimitiveClassNestHostTest\");\n+        if (!superInterfaces[1].equals(PrimitiveObject.class))\n+            throw new AssertionError(\"Wrong super interfaces for UnifiedPrimitiveClassNestHostTest\");\n+\n+        Class<?> nestHost = UnifiedPrimitiveClassNestHostTest.class.getNestHost();\n+        String hostName = nestHost.getName();\n+\n+        if (!hostName.equals(\"UnifiedPrimitiveClassNestHostTest\"))\n+            throw new AssertionError(\"Wrong nest host: \" + hostName);\n+\n+        Class<?> [] members = nestHost.getNestMembers();\n+        if (members.length != 2)\n+            throw new AssertionError(\"Wrong member count: \" + members.length);\n+\n+        if (!members[0].equals(nestHost))\n+            throw new AssertionError(\"Wrong initial member: \" + members[0]);\n+\n+        if (!members[1].equals(Inner.class))\n+            throw new AssertionError(\"Wrong initial member: \" + members[1]);\n+\n+        if (!members[1].getNestHost().equals(nestHost))\n+            throw new AssertionError(\"Wrong nest host for member[1]: \" + members[1]);\n+\n+        if (!Arrays.equals(members[1].getNestMembers(), members))\n+            throw new AssertionError(\"Wrong members for member[1]: \" + members[1]);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassNestHostTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}