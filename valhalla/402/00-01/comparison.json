{"files":[{"patch":"@@ -984,4 +984,0 @@\n-      if (is_updateBytes) {\n-        base_op = access_resolve(ACCESS_READ, base_op);\n-      }\n-\n@@ -1066,4 +1062,0 @@\n-      if (is_updateBytes) {\n-        base_op = access_resolve(ACCESS_READ, base_op);\n-      }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1089,4 +1089,0 @@\n-      if (is_updateBytes) {\n-        base_op = access_resolve(IS_NOT_NULL | ACCESS_READ, base_op);\n-      }\n-\n@@ -1150,1 +1146,1 @@\n-  LIR_Opr result_a = access_resolve(ACCESS_READ, a.result());\n+  LIR_Opr result_a = a.result();\n@@ -1158,1 +1154,1 @@\n-  LIR_Opr result_b = access_resolve(ACCESS_READ, b.result());\n+  LIR_Opr result_b = b.result();\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -232,0 +232,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3815,1 +3815,1 @@\n-      (CheckIntrinsics ? callee->intrinsic_candidate() : true)) {\n+      callee->check_intrinsic_candidate()) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2046,9 +2046,0 @@\n-LIR_Opr LIRGenerator::access_resolve(DecoratorSet decorators, LIR_Opr obj) {\n-  \/\/ Use stronger ACCESS_WRITE|ACCESS_READ by default.\n-  if ((decorators & (ACCESS_READ | ACCESS_WRITE)) == 0) {\n-    decorators |= ACCESS_READ | ACCESS_WRITE;\n-  }\n-\n-  return _barrier_set->resolve(this, decorators, obj);\n-}\n-\n@@ -2193,1 +2184,0 @@\n-    LIR_Opr buf_obj = access_resolve(IS_NOT_NULL | ACCESS_READ, buf.result());\n@@ -2195,1 +2185,1 @@\n-      cmp_mem_int(lir_cond_belowEqual, buf_obj, java_nio_Buffer::limit_offset(), index.result()->as_jint(), info);\n+      cmp_mem_int(lir_cond_belowEqual, buf.result(), java_nio_Buffer::limit_offset(), index.result()->as_jint(), info);\n@@ -2198,1 +2188,1 @@\n-      cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf_obj,\n+      cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf.result(),\n@@ -3714,0 +3704,4 @@\n+  case vmIntrinsics::_blackhole:\n+    do_blackhole(x);\n+    break;\n+\n@@ -4180,0 +4174,9 @@\n+void LIRGenerator::do_blackhole(Intrinsic *x) {\n+  assert(!x->has_receiver(), \"Should have been checked before: only static methods here\");\n+  for (int c = 0; c < x->number_of_arguments(); c++) {\n+    \/\/ Load the argument\n+    LIRItem vitem(x->argument_at(c), this);\n+    vitem.load_item();\n+    \/\/ ...and leave it unused.\n+  }\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,0 +271,1 @@\n+  void do_blackhole(Intrinsic* x);\n@@ -320,2 +321,0 @@\n-  LIR_Opr access_resolve(DecoratorSet decorators, LIR_Opr obj);\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -308,6 +308,0 @@\n-  BarrierSetC1* bsc1 = BarrierSet::barrier_set()->barrier_set_c1();\n-  const char* name = bsc1->rtcall_name_for_address(entry);\n-  if (name != NULL) {\n-    return name;\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,0 +158,2 @@\n+\n+  CompilerOracle::tag_blackhole_if_possible(h_m);\n@@ -1264,0 +1266,1 @@\n+bool ciMethod::is_empty       () const {         FETCH_FLAG_FROM_VM(is_empty_method); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -208,0 +208,9 @@\n+  bool check_intrinsic_candidate() const {\n+    if (intrinsic_id() == vmIntrinsics::_blackhole) {\n+      \/\/ This is the intrinsic without an associated method, so no intrinsic_candidate\n+      \/\/ flag is set. The intrinsic is still correct.\n+      return true;\n+    }\n+    return (CheckIntrinsics ? intrinsic_candidate() : true);\n+  }\n+\n@@ -353,0 +362,1 @@\n+  bool is_empty       () const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5568,0 +5568,5 @@\n+        if (vmIntrinsics::_blackhole == id) {\n+          \/\/ The _blackhole intrinsic is a special marker. No explicit method\n+          \/\/ is defined for it.\n+          continue;\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+  case vmIntrinsics::_blackhole:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -537,0 +537,3 @@\n+  \/* special marker for blackholed methods: *\/                                                                          \\\n+  do_intrinsic(_blackhole,                java_lang_Object,       blackhole_name, star_name, F_S)                       \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -289,0 +289,1 @@\n+  template(blackhole_name,                            \"<blackhole>\")  \/*fake name*\/               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,0 +309,5 @@\n+  if (option == CompileCommand::Blackhole && !UnlockExperimentalVMOptions) {\n+    warning(\"Blackhole compile option is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions\");\n+    return;\n+  }\n+\n@@ -420,0 +425,31 @@\n+void CompilerOracle::tag_blackhole_if_possible(const methodHandle& method) {\n+  if (!check_predicate(CompileCommand::Blackhole, method)) {\n+    return;\n+  }\n+  guarantee(UnlockExperimentalVMOptions, \"Checked during initial parsing\");\n+  if (method->result_type() != T_VOID) {\n+    warning(\"Blackhole compile option only works for methods with void type: %s\",\n+            method->name_and_sig_as_C_string());\n+    return;\n+  }\n+  if (!method->is_empty_method()) {\n+    warning(\"Blackhole compile option only works for empty methods: %s\",\n+            method->name_and_sig_as_C_string());\n+    return;\n+  }\n+  if (!method->is_static()) {\n+    warning(\"Blackhole compile option only works for static methods: %s\",\n+            method->name_and_sig_as_C_string());\n+    return;\n+  }\n+  if (method->intrinsic_id() == vmIntrinsics::_blackhole) {\n+    return;\n+  }\n+  if (method->intrinsic_id() != vmIntrinsics::_none) {\n+    warning(\"Blackhole compile option only works for methods that do not have intrinsic set: %s, %s\",\n+            method->name_and_sig_as_C_string(), vmIntrinsics::name_at(method->intrinsic_id()));\n+    return;\n+  }\n+  method->set_intrinsic_id(vmIntrinsics::_blackhole);\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+  option(Blackhole,  \"blackhole\", Bool) \\\n@@ -147,0 +148,3 @@\n+  \/\/ Tags the method as blackhole candidate, if possible.\n+  static void tag_blackhole_if_possible(const methodHandle& method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -346,4 +346,0 @@\n-\n-LIR_Opr BarrierSetC1::resolve(LIRGenerator* gen, DecoratorSet decorators, LIR_Opr obj) {\n-  return obj;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,4 +138,0 @@\n-  virtual LIR_Opr resolve(LIRGenerator* gen, DecoratorSet decorators, LIR_Opr obj);\n-\n-  virtual const char* rtcall_name_for_address(address entry) { return NULL; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"compiler\/compilerOracle.hpp\"\n@@ -994,0 +995,1 @@\n+    CompilerOracle::tag_blackhole_if_possible(method);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -684,0 +684,2 @@\n+  case vmIntrinsics::_blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+macro(Blackhole)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3982,0 +3982,2 @@\n+  case Op_Blackhole:\n+    break;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  if ((CheckIntrinsics ? callee->intrinsic_candidate() : true) &&\n+  if (callee->check_intrinsic_candidate() &&\n@@ -677,0 +677,3 @@\n+  case vmIntrinsics::_blackhole:\n+    return inline_blackhole();\n+\n@@ -2073,1 +2076,1 @@\n-Node* LibraryCallKit::make_unsafe_address(Node*& base, Node* offset, DecoratorSet decorators, BasicType type, bool can_cast) {\n+Node* LibraryCallKit::make_unsafe_address(Node*& base, Node* offset, BasicType type, bool can_cast) {\n@@ -2318,1 +2321,1 @@\n-  Node* adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);\n+  Node* adr = make_unsafe_address(base, offset, type, kind == Relaxed);\n@@ -2742,1 +2745,1 @@\n-  Node* adr = make_unsafe_address(base, offset, ACCESS_WRITE | ACCESS_READ, type, false);\n+  Node* adr = make_unsafe_address(base, offset,type, false);\n@@ -4323,2 +4326,2 @@\n-  Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);\n-  Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);\n+  Node* src = make_unsafe_address(src_ptr, src_off);\n+  Node* dst = make_unsafe_address(dst_ptr, dst_off);\n@@ -5553,2 +5556,2 @@\n-  Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);\n-  Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);\n+  Node* obja_adr = make_unsafe_address(obja, aoffset);\n+  Node* objb_adr = make_unsafe_address(objb, boffset);\n@@ -7253,0 +7256,20 @@\n+\n+\/\/------------------------------- inline_blackhole --------------------------------------\n+\/\/\n+\/\/ Make sure all arguments to this node are alive.\n+\/\/ This matches methods that were requested to be blackholed through compile commands.\n+\/\/\n+bool LibraryCallKit::inline_blackhole() {\n+  assert(callee()->is_static(), \"Should have been checked before: only static methods here\");\n+  assert(callee()->is_empty(), \"Should have been checked before: only empty methods here\");\n+  assert(callee()->holder()->is_loaded(), \"Should have been checked before: only methods for loaded classes here\");\n+\n+  \/\/ Bind call arguments as blackhole arguments to keep them alive\n+  Node* bh = insert_mem_bar(Op_Blackhole);\n+  uint nargs = callee()->arg_size();\n+  for (uint i = 0; i < nargs; i++) {\n+    bh->add_req(argument(i));\n+  }\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-  Node* make_unsafe_address(Node*& base, Node* offset, DecoratorSet decorators, BasicType type = T_ILLEGAL, bool can_cast = false);\n+  Node* make_unsafe_address(Node*& base, Node* offset, BasicType type = T_ILLEGAL, bool can_cast = false);\n@@ -380,0 +380,2 @@\n+\n+  bool inline_blackhole();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/regalloc.hpp\"\n@@ -3432,0 +3433,1 @@\n+  case Op_Blackhole:         return new BlackholeNode(C, atp, pn);\n@@ -3666,0 +3668,21 @@\n+#ifndef PRODUCT\n+void BlackholeNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n+  st->print(\"blackhole \");\n+  bool first = true;\n+  for (uint i = 0; i < req(); i++) {\n+    Node* n = in(i);\n+    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        st->print(\", \");\n+      }\n+      char buf[128];\n+      ra->dump_register(n, buf);\n+      st->print(\"%s\", buf);\n+    }\n+  }\n+  st->cr();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1351,0 +1351,20 @@\n+\/\/------------------------------BlackholeNode----------------------------\n+\/\/ Blackhole all arguments. This node would survive through the compiler\n+\/\/ the effects on its arguments, and would be finally matched to nothing.\n+class BlackholeNode : public MemBarNode {\n+public:\n+  BlackholeNode(Compile* C, int alias_idx, Node* precedent)\n+    : MemBarNode(C, alias_idx, precedent) {}\n+  virtual int   Opcode() const;\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  const RegMask &in_RegMask(uint idx) const {\n+    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n+    \/\/ and all stack slots. This would avoid any redundant register moves\n+    \/\/ for blackhole inputs.\n+    return RegMask::All;\n+  }\n+#ifndef PRODUCT\n+  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class BlackholeNode;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,7 @@\n+const RegMask RegMask::All(\n+# define BODY(I) -1,\n+  FORALL_BODY\n+# undef BODY\n+  0\n+);\n+\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+  static const RegMask All;     \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -611,1 +611,0 @@\n-  DecoratorSet decorators = C2_UNSAFE_ACCESS;\n@@ -617,1 +616,1 @@\n-  Node* addr = make_unsafe_address(base, offset, decorators, (is_mask ? T_BOOLEAN : elem_bt), true);\n+  Node* addr = make_unsafe_address(base, offset, (is_mask ? T_BOOLEAN : elem_bt), true);\n@@ -805,1 +804,1 @@\n-  Node* addr = make_unsafe_address(base, offset, C2_UNSAFE_ACCESS, elem_bt, true);\n+  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1599,0 +1599,1 @@\n+  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Mesa 3-D Graphics Library v19.2.1\n+## Mesa 3-D Graphics Library v21.0.3\n","filename":"src\/java.desktop\/share\/legal\/mesa3d.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,5 +59,0 @@\n-#if defined(USE_MGL_NAMESPACE)\n-#include \"gl_mangle.h\"\n-#endif\n-\n-\n@@ -2134,7 +2129,0 @@\n-\/**\n- ** NOTE!!!!!  If you add new functions to this file, or update\n- ** glext.h be sure to regenerate the gl_mangle.h file.  See comments\n- ** in that file for details.\n- **\/\n-\n-\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/J2D_GL\/gl.h","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-#define GL_GLEXT_VERSION 20190611\n+#define GL_GLEXT_VERSION 20190911\n@@ -5030,0 +5030,16 @@\n+#ifndef GL_KHR_shader_subgroup\n+#define GL_KHR_shader_subgroup 1\n+#define GL_SUBGROUP_SIZE_KHR              0x9532\n+#define GL_SUBGROUP_SUPPORTED_STAGES_KHR  0x9533\n+#define GL_SUBGROUP_SUPPORTED_FEATURES_KHR 0x9534\n+#define GL_SUBGROUP_QUAD_ALL_STAGES_KHR   0x9535\n+#define GL_SUBGROUP_FEATURE_BASIC_BIT_KHR 0x00000001\n+#define GL_SUBGROUP_FEATURE_VOTE_BIT_KHR  0x00000002\n+#define GL_SUBGROUP_FEATURE_ARITHMETIC_BIT_KHR 0x00000004\n+#define GL_SUBGROUP_FEATURE_BALLOT_BIT_KHR 0x00000008\n+#define GL_SUBGROUP_FEATURE_SHUFFLE_BIT_KHR 0x00000010\n+#define GL_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT_KHR 0x00000020\n+#define GL_SUBGROUP_FEATURE_CLUSTERED_BIT_KHR 0x00000040\n+#define GL_SUBGROUP_FEATURE_QUAD_BIT_KHR  0x00000080\n+#endif \/* GL_KHR_shader_subgroup *\/\n+\n@@ -6503,0 +6519,4 @@\n+#ifndef GL_EXT_EGL_sync\n+#define GL_EXT_EGL_sync 1\n+#endif \/* GL_EXT_EGL_sync *\/\n+\n@@ -9297,0 +9317,11 @@\n+#ifndef GL_MESA_framebuffer_flip_y\n+#define GL_MESA_framebuffer_flip_y 1\n+#define GL_FRAMEBUFFER_FLIP_Y_MESA        0x8BBB\n+typedef void (APIENTRYP PFNGLFRAMEBUFFERPARAMETERIMESAPROC) (GLenum target, GLenum pname, GLint param);\n+typedef void (APIENTRYP PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC) (GLenum target, GLenum pname, GLint *params);\n+#ifdef GL_GLEXT_PROTOTYPES\n+GLAPI void APIENTRY glFramebufferParameteriMESA (GLenum target, GLenum pname, GLint param);\n+GLAPI void APIENTRY glGetFramebufferParameterivMESA (GLenum target, GLenum pname, GLint *params);\n+#endif\n+#endif \/* GL_MESA_framebuffer_flip_y *\/\n+\n@@ -9410,0 +9441,19 @@\n+#ifndef GL_NVX_gpu_multicast2\n+#define GL_NVX_gpu_multicast2 1\n+#define GL_UPLOAD_GPU_MASK_NVX            0x954A\n+typedef void (APIENTRYP PFNGLUPLOADGPUMASKNVXPROC) (GLbitfield mask);\n+typedef void (APIENTRYP PFNGLMULTICASTVIEWPORTARRAYVNVXPROC) (GLuint gpu, GLuint first, GLsizei count, const GLfloat *v);\n+typedef void (APIENTRYP PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC) (GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);\n+typedef void (APIENTRYP PFNGLMULTICASTSCISSORARRAYVNVXPROC) (GLuint gpu, GLuint first, GLsizei count, const GLint *v);\n+typedef GLuint (APIENTRYP PFNGLASYNCCOPYBUFFERSUBDATANVXPROC) (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);\n+typedef GLuint (APIENTRYP PFNGLASYNCCOPYIMAGESUBDATANVXPROC) (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);\n+#ifdef GL_GLEXT_PROTOTYPES\n+GLAPI void APIENTRY glUploadGpuMaskNVX (GLbitfield mask);\n+GLAPI void APIENTRY glMulticastViewportArrayvNVX (GLuint gpu, GLuint first, GLsizei count, const GLfloat *v);\n+GLAPI void APIENTRY glMulticastViewportPositionWScaleNVX (GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);\n+GLAPI void APIENTRY glMulticastScissorArrayvNVX (GLuint gpu, GLuint first, GLsizei count, const GLint *v);\n+GLAPI GLuint APIENTRY glAsyncCopyBufferSubDataNVX (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);\n+GLAPI GLuint APIENTRY glAsyncCopyImageSubDataNVX (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);\n+#endif\n+#endif \/* GL_NVX_gpu_multicast2 *\/\n+\n@@ -9424,0 +9474,14 @@\n+#ifndef GL_NVX_progress_fence\n+#define GL_NVX_progress_fence 1\n+typedef GLuint (APIENTRYP PFNGLCREATEPROGRESSFENCENVXPROC) (void);\n+typedef void (APIENTRYP PFNGLSIGNALSEMAPHOREUI64NVXPROC) (GLuint signalGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+typedef void (APIENTRYP PFNGLWAITSEMAPHOREUI64NVXPROC) (GLuint waitGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+typedef void (APIENTRYP PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC) (GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+#ifdef GL_GLEXT_PROTOTYPES\n+GLAPI GLuint APIENTRY glCreateProgressFenceNVX (void);\n+GLAPI void APIENTRY glSignalSemaphoreui64NVX (GLuint signalGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+GLAPI void APIENTRY glWaitSemaphoreui64NVX (GLuint waitGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+GLAPI void APIENTRY glClientWaitSemaphoreui64NVX (GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+#endif\n+#endif \/* GL_NVX_progress_fence *\/\n+\n@@ -10971,0 +11035,5 @@\n+#ifndef GL_NV_shader_subgroup_partitioned\n+#define GL_NV_shader_subgroup_partitioned 1\n+#define GL_SUBGROUP_FEATURE_PARTITIONED_BIT_NV 0x00000100\n+#endif \/* GL_NV_shader_subgroup_partitioned *\/\n+\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/J2D_GL\/glext.h","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -66,5 +66,0 @@\n-#if defined(USE_MGL_NAMESPACE)\n-#include \"glx_mangle.h\"\n-#endif\n-\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/opengl\/J2D_GL\/glx.h","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-#define GLX_GLXEXT_VERSION 20180525\n+#define GLX_GLXEXT_VERSION 20190911\n@@ -312,0 +312,8 @@\n+#ifndef GLX_EXT_context_priority\n+#define GLX_EXT_context_priority 1\n+#define GLX_CONTEXT_PRIORITY_LEVEL_EXT    0x3100\n+#define GLX_CONTEXT_PRIORITY_HIGH_EXT     0x3101\n+#define GLX_CONTEXT_PRIORITY_MEDIUM_EXT   0x3102\n+#define GLX_CONTEXT_PRIORITY_LOW_EXT      0x3103\n+#endif \/* GLX_EXT_context_priority *\/\n+\n@@ -508,1 +516,0 @@\n-#define GLX_RENDERER_ID_MESA              0x818E\n@@ -533,1 +540,1 @@\n-typedef Bool ( *PFNGLXSET3DFXMODEMESAPROC) (int mode);\n+typedef GLboolean ( *PFNGLXSET3DFXMODEMESAPROC) (GLint mode);\n@@ -535,1 +542,1 @@\n-Bool glXSet3DfxModeMESA (int mode);\n+GLboolean glXSet3DfxModeMESA (GLint mode);\n@@ -580,0 +587,9 @@\n+#ifndef GLX_NV_multigpu_context\n+#define GLX_NV_multigpu_context 1\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_NV    0x20AA\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_SINGLE_NV 0x20AB\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_AFR_NV 0x20AC\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_MULTICAST_NV 0x20AD\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_MULTI_DISPLAY_MULTICAST_NV 0x20AE\n+#endif \/* GLX_NV_multigpu_context *\/\n+\n@@ -685,2 +701,0 @@\n-\/* JDK modification *\/\n-#elif defined(__sun__)\n@@ -688,1 +702,1 @@\n-#elif defined(__digital__)\n+#elif defined(__sun__) || defined(__digital__)\n@@ -699,1 +713,0 @@\n-\n@@ -871,1 +884,1 @@\n-typedef int ( *PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);\n+typedef void ( *PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);\n@@ -877,1 +890,1 @@\n-int glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);\n+void glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);\n@@ -985,1 +998,1 @@\n-typedef Status ( *PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);\n+typedef Status ( *PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex);\n@@ -987,1 +1000,1 @@\n-Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);\n+Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex);\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/opengl\/J2D_GL\/glxext.h","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef __wglext_h_\n-#define __wglext_h_ 1\n+#ifndef __wgl_wglext_h_\n+#define __wgl_wglext_h_ 1\n@@ -38,1 +38,1 @@\n-** Copyright (c) 2013-2017 The Khronos Group Inc.\n+** Copyright (c) 2013-2018 The Khronos Group Inc.\n@@ -71,1 +71,1 @@\n-#define WGL_WGLEXT_VERSION 20170817\n+#define WGL_WGLEXT_VERSION 20190728\n@@ -350,1 +350,1 @@\n-typedef INT (WINAPI * PFNWGLGETGPUINFOAMDPROC) (UINT id, int property, GLenum dataType, UINT size, void *data);\n+typedef INT (WINAPI * PFNWGLGETGPUINFOAMDPROC) (UINT id, INT property, GLenum dataType, UINT size, void *data);\n@@ -360,1 +360,1 @@\n-INT WINAPI wglGetGPUInfoAMD (UINT id, int property, GLenum dataType, UINT size, void *data);\n+INT WINAPI wglGetGPUInfoAMD (UINT id, INT property, GLenum dataType, UINT size, void *data);\n@@ -376,0 +376,5 @@\n+#ifndef WGL_ATI_render_texture_rectangle\n+#define WGL_ATI_render_texture_rectangle 1\n+#define WGL_TEXTURE_RECTANGLE_ATI         0x21A5\n+#endif \/* WGL_ATI_render_texture_rectangle *\/\n+\n@@ -378,1 +383,1 @@\n-#define WGL_COLORSPACE_EXT                0x3087\n+#define WGL_COLORSPACE_EXT                0x309D\n@@ -742,0 +747,9 @@\n+#ifndef WGL_NV_multigpu_context\n+#define WGL_NV_multigpu_context 1\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_NV    0x20AA\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_SINGLE_NV 0x20AB\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_AFR_NV 0x20AC\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_MULTICAST_NV 0x20AD\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_MULTI_DISPLAY_MULTICAST_NV 0x20AE\n+#endif \/* WGL_NV_multigpu_context *\/\n+\n@@ -752,2 +766,2 @@\n-typedef int (WINAPI * PFNWGLENUMERATEVIDEODEVICESNVPROC) (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);\n-typedef BOOL (WINAPI * PFNWGLBINDVIDEODEVICENVPROC) (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);\n+typedef int (WINAPI * PFNWGLENUMERATEVIDEODEVICESNVPROC) (HDC hDc, HVIDEOOUTPUTDEVICENV *phDeviceList);\n+typedef BOOL (WINAPI * PFNWGLBINDVIDEODEVICENVPROC) (HDC hDc, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);\n@@ -756,2 +770,2 @@\n-int WINAPI wglEnumerateVideoDevicesNV (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);\n-BOOL WINAPI wglBindVideoDeviceNV (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);\n+int WINAPI wglEnumerateVideoDevicesNV (HDC hDc, HVIDEOOUTPUTDEVICENV *phDeviceList);\n+BOOL WINAPI wglBindVideoDeviceNV (HDC hDc, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);\n@@ -862,1 +876,1 @@\n-typedef INT64 (WINAPI * PFNWGLSWAPLAYERBUFFERSMSCOMLPROC) (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);\n+typedef INT64 (WINAPI * PFNWGLSWAPLAYERBUFFERSMSCOMLPROC) (HDC hdc, INT fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);\n@@ -869,1 +883,1 @@\n-INT64 WINAPI wglSwapLayerBuffersMscOML (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);\n+INT64 WINAPI wglSwapLayerBuffersMscOML (HDC hdc, INT fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/opengl\/J2D_GL\/wglext.h","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Objects;\n@@ -1027,1 +1028,0 @@\n-                        break;\n@@ -1042,2 +1042,3 @@\n-        \/\/The text from the @see tag.  We will output this text when a label is not specified.\n-        Content text = plainOrCode(kind == LINK_PLAIN, Text.of(removeTrailingSlash(seeText)));\n+        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n+        Content text = plainOrCode(isLinkPlain,\n+                Text.of(Objects.requireNonNullElse(ch.getReferencedSignature(see), \"\")));\n@@ -1152,2 +1153,0 @@\n-            text = plainOrCode(kind == LINK_PLAIN, Text.of(refMemName));\n-\n@@ -1155,1 +1154,3 @@\n-                    refMem, (labelContent.isEmpty() ? text: labelContent), null, false);\n+                    refMem, (labelContent.isEmpty()\n+                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n+                            : labelContent), null, false);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-            if (refSignature.endsWith(\"[]\")) {\n+            if (refSignature != null && refSignature.endsWith(\"[]\")) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/SerializedFormBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -464,1 +464,1 @@\n-                return node.getSignature();\n+                return normalizeSignature(node.getSignature());\n@@ -469,0 +469,52 @@\n+    @SuppressWarnings(\"fallthrough\")\n+    private static String normalizeSignature(String sig) {\n+        if (sig == null\n+                || (!sig.contains(\" \") && !sig.contains(\"\\n\")\n+                 && !sig.contains(\"\\r\") && !sig.endsWith(\"\/\"))) {\n+            return sig;\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        char lastChar = 0;\n+        for (int i = 0; i < sig.length(); i++) {\n+            char ch = sig.charAt(i);\n+            switch (ch) {\n+                case '\\n':\n+                case '\\r':\n+                case '\\f':\n+                case '\\t':\n+                case ' ':\n+                    \/\/ Add at most one space char, or none if it isn't needed\n+                    switch (lastChar) {\n+                        case 0:\n+                        case'(':\n+                        case'<':\n+                        case ' ':\n+                        case '.':\n+                            break;\n+                        default:\n+                            sb.append(' ');\n+                            lastChar = ' ';\n+                            break;\n+                    }\n+                    break;\n+                case ',':\n+                case '>':\n+                case ')':\n+                case '.':\n+                    \/\/ Remove preceding space character\n+                    if (lastChar == ' ') {\n+                        sb.setLength(sb.length() - 1);\n+                    }\n+                    \/\/ fallthrough\n+                default:\n+                    sb.append(ch);\n+                    lastChar = ch;\n+            }\n+        }\n+        \/\/ Delete trailing slash\n+        if (lastChar == '\/') {\n+            sb.setLength(sb.length() - 1);\n+        }\n+        return sb.toString();\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":54,"deletions":2,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  compiler\/blackhole\/ \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeExistingIntrinsicWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeExistingIntrinsicWarningTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG =\n+        \"Blackhole compile option only works for methods that do not have intrinsic set: java.lang.Thread.onSpinWait()V, _onSpinWait\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeExistingIntrinsicWarningTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Should print the warning\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,java\/lang\/Thread.onSpinWait\"\n+        );\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,java\/lang\/Thread.onSpinWait,Blackhole\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,java\/lang\/Thread.onSpinWait\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,java\/lang\/Thread.onSpinWait,Blackhole\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeExistingIntrinsicWarningTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeExperimentalUnlockTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeExperimentalUnlockTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG = \"Blackhole compile option is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeExperimentalUnlockTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Option is disabled by default, should fail:\n+        shouldFail(\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+        shouldFail(\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+\n+        \/\/ Option should be enabled by UnlockExperimentalVMOptions\n+        shouldPass(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+        shouldPass(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1(c);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeExperimentalUnlockTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeIntrinsicTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeIntrinsicTest {\n+\n+    private static final Map<String, Runnable> TESTS;\n+\n+    static {\n+        TESTS = new LinkedHashMap<>();\n+        TESTS.put(\"bh_s_boolean_0\", BlackholeIntrinsicTest::test_boolean_0);\n+        TESTS.put(\"bh_s_byte_0\",    BlackholeIntrinsicTest::test_byte_0);\n+        TESTS.put(\"bh_s_char_0\",    BlackholeIntrinsicTest::test_char_0);\n+        TESTS.put(\"bh_s_short_0\",   BlackholeIntrinsicTest::test_short_0);\n+        TESTS.put(\"bh_s_int_0\",     BlackholeIntrinsicTest::test_int_0);\n+        TESTS.put(\"bh_s_float_0\",   BlackholeIntrinsicTest::test_float_0);\n+        TESTS.put(\"bh_s_long_0\",    BlackholeIntrinsicTest::test_long_0);\n+        TESTS.put(\"bh_s_double_0\",  BlackholeIntrinsicTest::test_double_0);\n+        TESTS.put(\"bh_s_Object_0\",  BlackholeIntrinsicTest::test_Object_0);\n+\n+        TESTS.put(\"bh_s_boolean_1\", BlackholeIntrinsicTest::test_boolean_1);\n+        TESTS.put(\"bh_s_byte_1\",    BlackholeIntrinsicTest::test_byte_1);\n+        TESTS.put(\"bh_s_char_1\",    BlackholeIntrinsicTest::test_char_1);\n+        TESTS.put(\"bh_s_short_1\",   BlackholeIntrinsicTest::test_short_1);\n+        TESTS.put(\"bh_s_int_1\",     BlackholeIntrinsicTest::test_int_1);\n+        TESTS.put(\"bh_s_float_1\",   BlackholeIntrinsicTest::test_float_1);\n+        TESTS.put(\"bh_s_long_1\",    BlackholeIntrinsicTest::test_long_1);\n+        TESTS.put(\"bh_s_double_1\",  BlackholeIntrinsicTest::test_double_1);\n+        TESTS.put(\"bh_s_Object_1\",  BlackholeIntrinsicTest::test_Object_1);\n+\n+        TESTS.put(\"bh_s_boolean_2\", BlackholeIntrinsicTest::test_boolean_2);\n+        TESTS.put(\"bh_s_byte_2\",    BlackholeIntrinsicTest::test_byte_2);\n+        TESTS.put(\"bh_s_char_2\",    BlackholeIntrinsicTest::test_char_2);\n+        TESTS.put(\"bh_s_short_2\",   BlackholeIntrinsicTest::test_short_2);\n+        TESTS.put(\"bh_s_int_2\",     BlackholeIntrinsicTest::test_int_2);\n+        TESTS.put(\"bh_s_float_2\",   BlackholeIntrinsicTest::test_float_2);\n+        TESTS.put(\"bh_s_long_2\",    BlackholeIntrinsicTest::test_long_2);\n+        TESTS.put(\"bh_s_double_2\",  BlackholeIntrinsicTest::test_double_2);\n+        TESTS.put(\"bh_s_Object_2\",  BlackholeIntrinsicTest::test_Object_2);\n+    }\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            test(args[0]);\n+        }\n+    }\n+\n+    public static void driver() throws IOException {\n+        for (String test : TESTS.keySet()) {\n+            check(test, \"-XX:TieredStopAtLevel=1\");\n+            check(test, \"-XX:-TieredCompilation\");\n+            if (Platform.is64bit()) {\n+                check(test, \"-XX:-UseCompressedOops\", \"-XX:TieredStopAtLevel=1\");\n+                check(test, \"-XX:-UseCompressedOops\", \"-XX:-TieredCompilation\");\n+            }\n+        }\n+    }\n+\n+    private static void test(String test) {\n+        Runnable r = TESTS.get(test);\n+        if (r == null) {\n+           throw new IllegalArgumentException(\"Cannot find test \" + test);\n+        }\n+        for (int t = 0; t < TRIES; t++) {\n+            r.run();\n+        }\n+    }\n+\n+    public static void check(String test, String... args) throws IOException {\n+        List<String> cmdline = new ArrayList();\n+        cmdline.add(\"-Xmx128m\");\n+        cmdline.add(\"-Xbatch\");\n+        cmdline.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        cmdline.add(\"-XX:+AbortVMOnCompilationFailure\");\n+        cmdline.add(\"-XX:+PrintCompilation\");\n+        cmdline.add(\"-XX:+PrintInlining\");\n+        cmdline.add(\"-XX:+UnlockExperimentalVMOptions\");\n+        cmdline.add(\"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\");\n+        cmdline.addAll(Arrays.asList(args));\n+        cmdline.add(\"compiler.blackhole.BlackholeIntrinsicTest\");\n+        cmdline.add(test);\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.stderrShouldBeEmpty();\n+        output.stdoutShouldMatch(\"compiler.blackhole.BlackholeTarget::\" + test + \".*intrinsic.*\");\n+    }\n+\n+    private static void test_boolean_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_0();\n+        }\n+    }\n+\n+    private static void test_byte_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_0();\n+        }\n+    }\n+\n+    private static void test_char_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_0();\n+        }\n+    }\n+\n+    private static void test_short_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_0();\n+        }\n+    }\n+\n+    private static void test_int_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_0();\n+        }\n+    }\n+\n+    private static void test_float_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_0();\n+        }\n+    }\n+\n+    private static void test_long_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_0();\n+        }\n+    }\n+\n+    private static void test_double_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_0();\n+        }\n+    }\n+\n+    private static void test_Object_0() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_Object_0();\n+        }\n+    }\n+\n+    private static void test_boolean_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_1((c & 0x1) == 0);\n+        }\n+    }\n+\n+    private static void test_byte_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_1((byte)c);\n+        }\n+    }\n+\n+    private static void test_char_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_1((char)c);\n+        }\n+    }\n+\n+    private static void test_short_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_1((short)c);\n+        }\n+    }\n+\n+    private static void test_int_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1(c);\n+        }\n+    }\n+\n+    private static void test_float_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_1(c);\n+        }\n+    }\n+\n+    private static void test_long_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_1(c);\n+        }\n+    }\n+\n+    private static void test_double_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_1(c);\n+        }\n+    }\n+\n+    private static void test_Object_1() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            BlackholeTarget.bh_s_Object_1(o);\n+        }\n+    }\n+\n+    private static void test_boolean_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_boolean_2((c & 0x1) == 0, (c & 0x2) == 0);\n+        }\n+    }\n+\n+    private static void test_byte_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_byte_2((byte)c, (byte)(c + 1));\n+        }\n+    }\n+\n+    private static void test_char_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_char_2((char)c, (char)(c + 1));\n+        }\n+    }\n+\n+    private static void test_short_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_short_2((short)c, (short)(c + 1));\n+        }\n+    }\n+\n+    private static void test_int_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_float_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_float_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_long_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_long_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_double_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_double_2(c, c + 1);\n+        }\n+    }\n+\n+    private static void test_Object_2() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            BlackholeTarget.bh_s_Object_2(o1, o2);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeIntrinsicTest.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeNonEmptyWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonEmptyWarningTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG = \"Blackhole compile option only works for empty methods: compiler.blackhole.BlackholeTarget.bh_s_int_1_delegate(I)V\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeNonEmptyWarningTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Should print the warning\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            BlackholeTarget.bh_s_int_1_delegate(c);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonEmptyWarningTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeNonStaticWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonStaticWarningTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG = \"Blackhole compile option only works for static methods: compiler.blackhole.BlackholeTarget.bh_i_int_0()V\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeNonStaticWarningTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Should print the warning\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_i_int_0();\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonStaticWarningTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib \/\n+ * @requires vm.flagless\n+ * @run driver compiler.blackhole.BlackholeNonVoidWarningTest\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BlackholeNonVoidWarningTest {\n+\n+    private static final int CYCLES = 100_000;\n+    private static final int TRIES = 10;\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args.length == 0) {\n+            driver();\n+        } else {\n+            runner();\n+        }\n+    }\n+\n+    private static final String MSG = \"Blackhole compile option only works for methods with void type: compiler.blackhole.BlackholeTarget.bh_sr_int(I)I\";\n+\n+    private static List<String> cmdline(String[] args) {\n+        List<String> r = new ArrayList();\n+        r.add(\"-Xmx128m\");\n+        r.add(\"-Xbatch\");\n+        r.addAll(Arrays.asList(args));\n+        r.add(\"compiler.blackhole.BlackholeNonVoidWarningTest\");\n+        r.add(\"run\");\n+        return r;\n+    }\n+\n+    public static void shouldFail(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(MSG);\n+    }\n+\n+    public static void shouldPass(String... args) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(cmdline(args));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotContain(MSG);\n+    }\n+\n+    public static void driver() throws IOException {\n+        \/\/ Should print the warning\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldFail(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+\n+        \/\/ Should be able to shun the warning\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=blackhole,compiler\/blackhole\/BlackholeTarget.bh_*\"\n+        );\n+        shouldPass(\n+            \"-XX:-PrintWarnings\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=quiet\",\n+            \"-XX:CompileCommand=option,compiler\/blackhole\/BlackholeTarget.bh_*,Blackhole\"\n+        );\n+    }\n+\n+    public static void runner() {\n+        for (int t = 0; t < TRIES; t++) {\n+            run();\n+        }\n+    }\n+\n+    public static void run() {\n+        for (int c = 0; c < CYCLES; c++) {\n+            if (BlackholeTarget.bh_sr_int(c) != 0) {\n+                throw new AssertionError(\"Return value error\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeNonVoidWarningTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.blackhole;\n+\n+import java.lang.reflect.*;\n+\n+public class BlackholeTarget {\n+    public void call_for_null_check() {}\n+\n+    public        void    bh_i_boolean_0()           {}\n+    public        void    bh_i_byte_0()              {}\n+    public        void    bh_i_short_0()             {}\n+    public        void    bh_i_char_0()              {}\n+    public        void    bh_i_int_0()               {}\n+    public        void    bh_i_float_0()             {}\n+    public        void    bh_i_long_0()              {}\n+    public        void    bh_i_double_0()            {}\n+    public        void    bh_i_Object_0()            {}\n+\n+    public static void    bh_s_boolean_0()           {}\n+    public static void    bh_s_byte_0()              {}\n+    public static void    bh_s_short_0()             {}\n+    public static void    bh_s_char_0()              {}\n+    public static void    bh_s_int_0()               {}\n+    public static void    bh_s_float_0()             {}\n+    public static void    bh_s_long_0()              {}\n+    public static void    bh_s_double_0()            {}\n+    public static void    bh_s_Object_0()            {}\n+\n+    public static void    bh_s_boolean_1(boolean v)  {}\n+    public static void    bh_s_byte_1(byte v)        {}\n+    public static void    bh_s_short_1(short v)      {}\n+    public static void    bh_s_char_1(char v)        {}\n+    public static void    bh_s_int_1(int v)          {}\n+    public static void    bh_s_float_1(float v)      {}\n+    public static void    bh_s_long_1(long v)        {}\n+    public static void    bh_s_double_1(double v)    {}\n+    public static void    bh_s_Object_1(Object v)    {}\n+\n+    public static void    bh_s_boolean_1_delegate(boolean v)  { bh_s_boolean_1(v); }\n+    public static void    bh_s_byte_1_delegate(byte v)        { bh_s_byte_1(v);    }\n+    public static void    bh_s_short_1_delegate(short v)      { bh_s_short_1(v);   }\n+    public static void    bh_s_char_1_delegate(char v)        { bh_s_char_1(v);    }\n+    public static void    bh_s_int_1_delegate(int v)          { bh_s_int_1(v);     }\n+    public static void    bh_s_float_1_delegate(float v)      { bh_s_float_1(v);   }\n+    public static void    bh_s_long_1_delegate(long v)        { bh_s_long_1(v);    }\n+    public static void    bh_s_double_1_delegate(double v)    { bh_s_double_1(v);  }\n+    public static void    bh_s_Object_1_delegate(Object v)    { bh_s_Object_1(v);  }\n+\n+    public static void    bh_s_boolean_2(boolean v1, boolean v2) {}\n+    public static void    bh_s_byte_2(byte v1, byte v2)          {}\n+    public static void    bh_s_short_2(short v1, short v2)       {}\n+    public static void    bh_s_char_2(char v1, char v2)          {}\n+    public static void    bh_s_int_2(int v1, int v2)             {}\n+    public static void    bh_s_float_2(float v1, float v2)       {}\n+    public static void    bh_s_long_2(long v1, long v2)          {}\n+    public static void    bh_s_double_2(double v1, double v2)    {}\n+    public static void    bh_s_Object_2(Object v1, Object v2)    {}\n+\n+    public static boolean bh_sr_boolean(boolean v) { return false; }\n+    public static byte    bh_sr_byte(byte v)       { return 0;     }\n+    public static short   bh_sr_short(short v)     { return 0;     }\n+    public static char    bh_sr_char(char v)       { return 0;     }\n+    public static int     bh_sr_int(int v)         { return 0;     }\n+    public static float   bh_sr_float(float v)     { return 0;     }\n+    public static long    bh_sr_long(long v)       { return 0;     }\n+    public static double  bh_sr_double(double v)   { return 0;     }\n+    public static Object  bh_sr_Object(Object v)   { return null;  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -60,3 +60,4 @@\n-            \"OldSuper id: 2 super: 1 source: \" + loadeesJar,\n-            \"ChildOldSuper id: 3 super: 2 source: \" + loadeesJar,\n-            \"GChild id: 4 super: 3 source: \" + loadeesJar\n+            \"java\/lang\/IdentityObject id: 2\",\n+            \"OldSuper id: 3 super: 1 interfaces: 2 source: \" + loadeesJar,\n+            \"ChildOldSuper id: 4 super: 3 source: \" + loadeesJar,\n+            \"GChild id: 5 super: 4 source: \" + loadeesJar\n@@ -69,3 +70,4 @@\n-            \"OldInf id: 2 super: 1 source: \" + loadeesJar2,\n-            \"ChildOldInf id: 3 super: 1 interfaces: 2 source: \" + loadeesJar2,\n-            \"GChild2 id: 4 super: 3 source: \" + loadeesJar2\n+            \"java\/lang\/IdentityObject id: 2\",\n+            \"OldInf id: 3 super: 1 source: \" + loadeesJar2,\n+            \"ChildOldInf id: 4 super: 1 interfaces: 2 3 source: \" + loadeesJar2,\n+            \"GChild2 id: 5 super: 4 source: \" + loadeesJar2\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/OldClassAndInf.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      8017191 8182765 8200432 8239804\n+ * @bug      8017191 8182765 8200432 8239804 8250766\n@@ -46,0 +46,1 @@\n+                \"--no-platform-links\",\n@@ -58,1 +59,3 @@\n-                <a href=\"Test.InnerOne.html#baz(float)\"><code>something<\/code><\/a><\/dd>\n+                <a href=\"Test.InnerOne.html#baz(float)\"><code>something<\/code><\/a>,\\s\n+                <a href=\"Test.InnerOne.html#format(java.lang.String,java.lang.Object...)\"><code>Test\\\n+                .InnerOne.format(java.lang.String, java.lang.Object...)<\/code><\/a><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/TestSeeTag.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-    * Testing different combos of see tags.\n+    * Testing different combos of see tags, including some weird formatting.\n@@ -33,1 +33,3 @@\n-    * @see InnerOne#bar(Object)\n+    * @see InnerOne#bar(\n+    *                   Object\n+    *                   )\n@@ -36,0 +38,1 @@\n+    * @see InnerOne#format( java .lang.String  , java.  lang.Object ... )\n@@ -57,0 +60,7 @@\n+\n+        \/**\n+         * Test for multiple args and varargs.\n+         *\/\n+        public static String format(String s, Object... args) {\n+            return String.format(s, args);\n+        }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/pkg\/Test.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"}]}