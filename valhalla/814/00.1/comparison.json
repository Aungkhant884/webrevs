{"files":[{"patch":"@@ -276,1 +276,1 @@\n-  $1_FLAGS += -g -Xlint:all $$($1_TARGET_RELEASE) $$(PARANOIA_FLAGS) $$(JAVA_WARNINGS_ARE_ERRORS)\n+  $1_FLAGS += -g -XDenablePrimitiveClasses -Xlint:all $$($1_TARGET_RELEASE) $$(PARANOIA_FLAGS) $$(JAVA_WARNINGS_ARE_ERRORS)\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1022,0 +1022,1 @@\n+    _jdk_internal_vm_annotation_MultiField,\n@@ -1028,0 +1029,1 @@\n+  jbyte _multifield_arg;\n@@ -1054,0 +1056,3 @@\n+  void set_multifield_arg(jbyte arg) { _multifield_arg = arg; }\n+  jbyte multifield_arg() const { return _multifield_arg; }\n+\n@@ -1055,0 +1060,1 @@\n+  bool is_multifield_base() const { return has_annotation(_jdk_internal_vm_annotation_MultiField); }\n@@ -1194,0 +1200,3 @@\n+    b_tag_val = 'B',\n+    b_con_off = 7,\n+    b_size = 9,\n@@ -1240,0 +1249,9 @@\n+    } else if (AnnotationCollector::_jdk_internal_vm_annotation_MultiField == id) {\n+      \/\/ TODO: change those assertion into a conditional statement to process the value\n+      assert(count == 1, \"MultiField annotation must have at least one argument\");  \/\/ Is it true?\n+      assert(member == vmSymbols::value_name(), \"Must be\");\n+      assert(b_tag_val == *(abase + tag_off), \"Must be a byte value\");\n+      int arg_index = Bytes::get_Java_u2((address)abase + b_con_off);\n+      int multifield_arg = cp->int_at(arg_index);\n+      assert(((jbyte)multifield_arg) == multifield_arg, \"Must be\");\n+      coll->set_multifield_arg(multifield_arg);\n@@ -1559,3 +1577,9 @@\n-  u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,\n-                                              u2,\n-                                              total_fields * (FieldInfo::field_slots + 1));\n+\n+  GrowableArray<FieldInfo>* temp_fieldinfo = new GrowableArray<FieldInfo>(total_fields, mtNone);\n+  GrowableArray<u2>* temp_generic_signature = new GrowableArray<u2>(total_fields, mtNone);\n+  GrowableArray<MultiFieldInfo>* temp_multifield_info = new GrowableArray<MultiFieldInfo>(0, mtNone); \/\/ could be allocated lazily\n+  FieldInfo fi;\n+  FieldInfo* f = &fi;\n+  GrowableArray<AnnotationArray*>* fields_annotations = NULL;\n+  GrowableArray<AnnotationArray*>* fields_type_annotations = NULL;\n+\n@@ -1565,1 +1589,2 @@\n-  int num_generic_signature = 0;\n+  int inj_multifields = 0;\n+  int field_index = -1;\n@@ -1568,0 +1593,1 @@\n+    field_index++;\n@@ -1612,4 +1638,2 @@\n-        if (_fields_annotations == NULL) {\n-          _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n-                                             _loader_data, length, NULL,\n-                                             CHECK);\n+        if (fields_annotations == NULL) {\n+          fields_annotations = new GrowableArray<AnnotationArray*>(length, mtNone);\n@@ -1617,1 +1641,2 @@\n-        _fields_annotations->at_put(n, parsed_annotations.field_annotations());\n+\n+        fields_annotations->at_put_grow(field_index, parsed_annotations.field_annotations(), NULL);\n@@ -1621,6 +1646,2 @@\n-        if (_fields_type_annotations == NULL) {\n-          _fields_type_annotations =\n-            MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n-                                                         length,\n-                                                         NULL,\n-                                                         CHECK);\n+        if (fields_type_annotations == NULL) {\n+          fields_type_annotations = new GrowableArray<AnnotationArray*>(length, mtNone);\n@@ -1628,1 +1649,1 @@\n-        _fields_type_annotations->at_put(n, parsed_annotations.field_type_annotations());\n+        fields_type_annotations->at_put_grow(field_index, parsed_annotations.field_type_annotations(), NULL);\n@@ -1637,1 +1658,1 @@\n-        fa[generic_signature_slot] = generic_signature_index;\n+        temp_generic_signature->append(generic_signature_index);\n@@ -1639,1 +1660,0 @@\n-        num_generic_signature ++;\n@@ -1643,2 +1663,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, n);\n-    field->initialize(access_flags.as_short(),\n+    f->initialize(access_flags.as_short(),\n@@ -1648,0 +1667,3 @@\n+    int base_idx = temp_fieldinfo->append(fi);\n+    assert(base_idx == field_index, \"Must be\");\n+    FieldInfo* const field = temp_fieldinfo->adr_at(field_index);\n@@ -1660,0 +1682,33 @@\n+\n+    if (parsed_annotations.is_multifield_base() && is_java_primitive(cp->basic_type_for_signature_at(signature_index))) {\n+      field->set_multifield_base(true);\n+      char* base_name = cp->symbol_at(name_index)->as_C_string();\n+      for (int i = 1; i < parsed_annotations.multifield_arg(); i++) {\n+        field_index++;\n+        stringStream st;\n+        st.print(\"%s\", base_name);\n+        st.print(\"#\");\n+        st.print(\"%d\", i);\n+        Symbol* inj_name = SymbolTable::new_symbol(st.as_string());\n+        MultiFieldInfo mfi(inj_name, base_idx, i);\n+        int mfi_idx = temp_multifield_info->append(mfi);\n+        f->initialize(access_flags.as_short(),\n+                      mfi_idx,\n+                      signature_index,\n+                      constantvalue_index);\n+        int inj_idx = temp_fieldinfo->append(fi);\n+        assert(inj_idx == field_index, \"Must be\");\n+        FieldInfo* const field = temp_fieldinfo->adr_at(inj_idx);\n+        const BasicType type = cp->basic_type_for_signature_at(signature_index);\n+        \/\/ Update FieldAllocationCount for this kind of field\n+        fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n+        field->set_multifield(true);\n+        if (fields_annotations != NULL && fields_annotations->at(base_idx) != NULL) {\n+          fields_annotations->at_put_grow(field_index, fields_annotations->at(base_idx));\n+        }\n+        if (fields_type_annotations != NULL && fields_type_annotations->at(base_idx) != NULL) {\n+          fields_type_annotations->at_put_grow(field_index, fields_type_annotations->at(base_idx));\n+        }\n+        inj_multifields++;\n+      }\n+    }\n@@ -1662,1 +1717,2 @@\n-  int index = length;\n+  *java_fields_count_ptr = *java_fields_count_ptr + inj_multifields;\n+  int index = length + inj_multifields;\n@@ -1671,1 +1727,1 @@\n-          const FieldInfo* const f = FieldInfo::from_field_array(fa, i);\n+          const FieldInfo* const f = temp_fieldinfo->adr_at(i);\n@@ -1680,1 +1736,0 @@\n-          \/\/ These will be removed from the field array at the end\n@@ -1686,2 +1741,1 @@\n-      FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-      field->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n+      f->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n@@ -1691,0 +1745,3 @@\n+      field_index++;\n+      int inj_idx = temp_fieldinfo->append(fi);\n+      assert(inj_idx == field_index, \"Must be\");\n@@ -1701,2 +1758,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-    field->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n+    f->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n@@ -1706,0 +1762,3 @@\n+    field_index++;\n+    int inj_idx = temp_fieldinfo->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1713,2 +1772,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-    field->initialize(JVM_ACC_FIELD_INTERNAL,\n+    f->initialize(JVM_ACC_FIELD_INTERNAL,\n@@ -1718,0 +1776,3 @@\n+    field_index++;\n+    int inj_idx = temp_fieldinfo->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1728,0 +1789,2 @@\n+  assert(index == field_index + 1, \"Must be\");\n+  assert(temp_fieldinfo->length() == field_index + 1, \"Must be\");\n@@ -1731,1 +1794,1 @@\n-                                   index * FieldInfo::field_slots + num_generic_signature,\n+                                   temp_fieldinfo->length() * FieldInfo::field_slots + temp_generic_signature->length(),\n@@ -1739,2 +1802,5 @@\n-    for (; i < index * FieldInfo::field_slots; i++) {\n-      _fields->at_put(i, fa[i]);\n+    for (i = 0; i < index; i++) {\n+      u2* adr = (u2*)temp_fieldinfo->adr_at(i);\n+      for (int j = 0; j < FieldInfo::field_slots; j++) {\n+        _fields->at_put(i * FieldInfo::field_slots + j, adr[j]);\n+      }\n@@ -1742,3 +1808,3 @@\n-    for (int j = total_fields * FieldInfo::field_slots;\n-         j < generic_signature_slot; j++) {\n-      _fields->at_put(i++, fa[j]);\n+    i = index * FieldInfo::field_slots;\n+    for (int j = 0; j < temp_generic_signature->length(); j++) {\n+      _fields->at_put(i++, temp_generic_signature->at(j));\n@@ -1746,0 +1812,1 @@\n+\n@@ -1749,0 +1816,25 @@\n+  if (temp_multifield_info->length() > 0) {\n+    _multifield_info = MetadataFactory::new_array<MultiFieldInfo>(_loader_data, temp_multifield_info->length(), CHECK);\n+    for (int i = 0; i < temp_multifield_info->length(); i++) {\n+      _multifield_info->at_put(i, temp_multifield_info->at(i));\n+    }\n+  }\n+\n+  if (fields_annotations != NULL) {\n+    _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n+                                             _loader_data, temp_fieldinfo->length(), NULL,\n+                                             CHECK);\n+    for (int i = 0; i < fields_annotations->length(); i++) {\n+      _fields_annotations->at_put(i, fields_annotations->at(i));\n+    }\n+  }\n+\n+  if (fields_type_annotations != NULL) {\n+     _fields_type_annotations = MetadataFactory::new_array<AnnotationArray*>(\n+                                             _loader_data, temp_fieldinfo->length(), NULL,\n+                                             CHECK);\n+    for (int i = 0; i < fields_type_annotations->length(); i++) {\n+      _fields_type_annotations->at_put(i, fields_type_annotations->at(i));\n+    }\n+  }\n+\n@@ -1760,1 +1852,1 @@\n-      for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+      for (AllFieldStream fs(_fields, cp, _multifield_info); !fs.done(); fs.next()) {\n@@ -2135,0 +2227,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_MultiField_signature): {\n+      if (_location != _in_field) break;  \/\/ only allow for fields\n+      if (!privileged)            break;  \/\/ honor privileges\n+      return _jdk_internal_vm_annotation_MultiField;\n+    }\n@@ -4205,0 +4302,1 @@\n+  this_klass->set_multifield_info(_multifield_info);\n@@ -5710,0 +5808,1 @@\n+  assert(NULL == _multifield_info, \"invariant\");\n@@ -5851,1 +5950,1 @@\n-  for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -5985,0 +6084,1 @@\n+  _multifield_info(NULL),\n@@ -6070,0 +6170,1 @@\n+  _multifield_info = NULL;\n@@ -6083,0 +6184,4 @@\n+  if (_multifield_info != NULL) {\n+    MetadataFactory::free_array<MultiFieldInfo>(_loader_data, _multifield_info);\n+  }\n+\n@@ -6576,1 +6681,1 @@\n-    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(_fields, cp, _multifield_info); !fs.done(); fs.next()) {\n@@ -6599,1 +6704,1 @@\n-      _field_info, _inline_type_field_klasses);\n+      _field_info, _inline_type_field_klasses, _multifield_info);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":144,"deletions":39,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  _is_reference(false) {\n+  _is_reference(false),\n+  _multifield_index(-1) {\n@@ -56,1 +57,1 @@\n-LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :\n+LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index) :\n@@ -65,2 +66,3 @@\n- _is_reference(is_reference) {\n-  assert(kind == REGULAR || kind == INLINED || kind == INHERITED,\n+ _is_reference(is_reference),\n+ _multifield_index(multifield_index) {\n+  assert(kind == REGULAR || kind == INLINED || kind == INHERITED || kind == MULTIFIELD,\n@@ -85,0 +87,1 @@\n+  _multifields(NULL),\n@@ -90,1 +93,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false, -1);\n@@ -100,1 +103,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true, -1);\n@@ -109,1 +112,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false, -1);\n@@ -118,0 +121,24 @@\n+void FieldGroup::add_multifield(AllFieldStream fs, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk) {\n+  assert(fs.is_multifield() || fs.is_multifield_base(), \"Must be\");\n+  u2 base = fs.multifield_base();\n+  BasicType type = Signature::basic_type(fs.signature());\n+  MultiFieldGroup* mfg = NULL;\n+  if (_multifields != NULL) {\n+    for (int i = 0; i < _multifields->length(); i++) {\n+      if (base == _multifields->at(i)->multifield_base()) {\n+        mfg = _multifields->at(i);\n+        break;\n+      }\n+    }\n+  } else {\n+    _multifields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<MultiFieldGroup*>(8);\n+  }\n+  if (mfg == NULL) {\n+    mfg = new(ResourceObj::RESOURCE_AREA, mtInternal) MultiFieldGroup(base, fs.signature());\n+    mfg->add_field(fs, vk);\n+    _multifields->append(mfg);\n+  } else {\n+    mfg->add_field(fs, vk);\n+  }\n+}\n+\n@@ -125,0 +152,16 @@\n+  if (_multifields != NULL) {\n+    for (int i = 0; i < _multifields->length(); i++) {\n+      int size = _multifields->at(i)->fields()->at(0)->size();\n+      int alignment =  _multifields->at(i)->fields()->at(0)->alignment();\n+      int multialignment = size\/alignment;\n+      if (size % multialignment != 0) multialignment+= alignment;\n+      \/\/ Problem: at this point, multialignment can be a weird number, for instance not a power of two\n+      int multisize = multialignment * alignment * _multifields->at(i)->fields()->length();  \/\/ should be stored\n+      \/\/ True alignment should be adjusted to increase chances to be on a single cache line\n+      int multifield_group_alignment = MIN2(round_up_power_of_2(multisize), HeapWordSize);\n+      _multifields->at(i)->set_group_size(multisize);\n+      _multifields->at(i)->set_group_alignment(multifield_group_alignment);\n+      _multifields->at(i)->fields()->sort(MultiFieldGroup::compare_multifield_index);\n+    }\n+    _multifields->sort(MultiFieldGroup::compare_multifield_groups_inverted);\n+  }\n@@ -141,1 +184,29 @@\n-FieldLayout::FieldLayout(Array<u2>* fields, ConstantPool* cp) :\n+MultiFieldGroup::MultiFieldGroup(u2 base, Symbol* signature) :  _multifield_base(base), _signature(signature), _fields(NULL) { }\n+\n+void MultiFieldGroup::add_field(AllFieldStream fs, InlineKlass* vk) {\n+  assert(fs.is_multifield() || fs.is_multifield_base(), \"Must be\");\n+  assert(fs.multifield_base() == multifield_base(), \"multifield base mismatch\");\n+  jbyte idx = fs.multifield_index();\n+  if (_fields == NULL) {\n+    _fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(8);\n+  } else {\n+    guarantee(fs.signature() == signature(), \"multifield signature mismatch\");\n+  }\n+  BasicType type = Signature::basic_type(fs.signature());\n+  LayoutRawBlock* block = NULL;\n+  if (type == T_PRIMITIVE_OBJECT) {\n+    block = new LayoutRawBlock(fs.index(), LayoutRawBlock::MULTIFIELD, vk->get_exact_size_in_bytes(),\n+                               vk->get_alignment(), false, fs.multifield_index());\n+  } else {\n+    int size = type2aelembytes(type);\n+    block = new LayoutRawBlock(fs.index(), LayoutRawBlock::MULTIFIELD, size, size, false, fs.multifield_index());\n+  }\n+  int cursor = 0;\n+  for (; cursor < _fields->length(); cursor++) {\n+    assert(_fields->at(cursor)->multifield_index() != fs.multifield_index(), \"multifield index duplicate found\");\n+    if (_fields->at(cursor)->multifield_index() > fs.multifield_index()) break;\n+  }\n+  _fields->insert_before(cursor, block);\n+}\n+\n+FieldLayout::FieldLayout(Array<u2>* fields, ConstantPool* cp, Array<MultiFieldInfo>* multifields) :\n@@ -144,0 +215,1 @@\n+  _multifield_info(multifields),\n@@ -187,1 +259,2 @@\n-         && block->kind() != LayoutRawBlock::INLINED) {\n+         && block->kind() != LayoutRawBlock::INLINED\n+         && block->kind() != LayoutRawBlock::MULTIFIELD) {\n@@ -316,0 +389,31 @@\n+void FieldLayout::add_multifield(MultiFieldGroup* multifield_group, LayoutRawBlock* start) {\n+  if (start == NULL) {\n+    start = _start;\n+  }\n+  LayoutRawBlock* candidate = NULL;\n+  if (start == last_block()) {\n+    candidate = last_block();\n+  } else {\n+    candidate = last_block()->prev_block();\n+    while (candidate->kind() != LayoutRawBlock::EMPTY || !candidate->fit(multifield_group->group_size(), multifield_group->group_alignment())) {\n+      if (candidate == start) {\n+        candidate = last_block();\n+        break;\n+      }\n+      candidate = candidate->prev_block();\n+    }\n+    assert(candidate != NULL, \"Candidate must not be null\");\n+    assert(candidate->kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n+  }\n+  if ((candidate->offset() % multifield_group->group_alignment()) != 0) {\n+    int adjustment = multifield_group->group_alignment() - (candidate->offset() % multifield_group->group_alignment());\n+    LayoutRawBlock* adj = new LayoutRawBlock(LayoutRawBlock::EMPTY, adjustment);\n+    insert(candidate, adj);\n+  }\n+  assert(candidate->fit(multifield_group->group_size(), multifield_group->group_alignment()), \"Candidate must be able to store the whole contiguous block\");\n+  for (int i = 0; i < multifield_group->fields()->length(); i++) {\n+    LayoutRawBlock* b = multifield_group->fields()->at(i);\n+    insert_field_block(candidate, b);\n+  }\n+}\n+\n@@ -335,1 +439,1 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik->fields(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n@@ -344,1 +448,1 @@\n-                                   vk->get_alignment(), false);\n+                                   vk->get_alignment(), false, -1);\n@@ -349,1 +453,1 @@\n-        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false, -1);\n@@ -473,1 +577,1 @@\n-                       fi->name(_cp)->as_C_string(),\n+                       fi->name(_multifield_info, _cp)->as_C_string(),\n@@ -484,1 +588,1 @@\n-                       fi->name(_cp)->as_C_string(),\n+                       fi->name(_multifield_info, _cp)->as_C_string(),\n@@ -504,1 +608,1 @@\n-        for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+        for (AllFieldStream fs(ik->fields(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n@@ -533,0 +637,10 @@\n+    case LayoutRawBlock::MULTIFIELD:\n+      FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n+      output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                       b->offset(),\n+                       fi->name(_multifield_info, _cp)->as_C_string(),\n+                       fi->signature(_cp)->as_C_string(),\n+                       b->size(),\n+                       b->alignment(),\n+                       \"MULTIFIELD\");\n+      break;\n@@ -540,1 +654,2 @@\n-                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses) :\n+                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses,\n+                                       Array<MultiFieldInfo>* multifields) :\n@@ -547,0 +662,1 @@\n+  _multifield_info(multifields),\n@@ -548,1 +664,1 @@\n-  _contended_groups(GrowableArray<FieldGroup*>(8)),\n+  _contended_groups(GrowableArray<FieldGroup*>(0)),\n@@ -578,1 +694,1 @@\n-  _layout = new FieldLayout(_fields, _constant_pool);\n+  _layout = new FieldLayout(_fields, _constant_pool, _multifield_info);\n@@ -584,1 +700,1 @@\n-  _static_layout = new FieldLayout(_fields, _constant_pool);\n+  _static_layout = new FieldLayout(_fields, _constant_pool, _multifield_info);\n@@ -597,1 +713,1 @@\n-  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(_fields, _constant_pool, _multifield_info); !fs.done(); fs.next()) {\n@@ -618,49 +734,18 @@\n-    switch(type) {\n-    case T_BYTE:\n-    case T_CHAR:\n-    case T_DOUBLE:\n-    case T_FLOAT:\n-    case T_INT:\n-    case T_LONG:\n-    case T_SHORT:\n-    case T_BOOLEAN:\n-      group->add_primitive_field(fs, type);\n-      break;\n-    case T_OBJECT:\n-    case T_ARRAY:\n-      if (group != _static_fields) _nonstatic_oopmap_count++;\n-      group->add_oop_field(fs);\n-      break;\n-    case T_PRIMITIVE_OBJECT:\n-      _has_inline_type_fields = true;\n-      if (group == _static_fields) {\n-        \/\/ static fields are never inlined\n-        group->add_oop_field(fs);\n-      } else {\n-        _has_flattening_information = true;\n-        \/\/ Flattening decision to be taken here\n-        \/\/ This code assumes all verification already have been performed\n-        \/\/ (field's type has been loaded and it is an inline klass)\n-        JavaThread* THREAD = JavaThread::current();\n-        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n-        assert(klass != NULL, \"Sanity check\");\n-        InlineKlass* vk = InlineKlass::cast(klass);\n-        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n-        if (vk->is_naturally_atomic()) {\n-          too_atomic_to_flatten = false;\n-          \/\/too_volatile_to_flatten = false; \/\/FIXME\n-          \/\/ volatile fields are currently never inlined, this could change in the future\n-        }\n-        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n-          group->add_inlined_field(fs, vk);\n-          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-          fs.set_inlined(true);\n-          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-            _has_nonatomic_values = true;\n-            _atomic_field_count--;  \/\/ every other field is atomic but this one\n-          }\n-        } else {\n-          _nonstatic_oopmap_count++;\n+    bool has_multifield_annotation = false;\n+    if (fs.is_multifield() || fs.is_multifield_base()) {\n+      group->add_multifield(fs, _multifield_info);\n+    } else {\n+      switch(type) {\n+        case T_BYTE:\n+        case T_CHAR:\n+        case T_DOUBLE:\n+        case T_FLOAT:\n+        case T_INT:\n+        case T_LONG:\n+        case T_SHORT:\n+        case T_BOOLEAN:\n+          group->add_primitive_field(fs, type);\n+          break;\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          if (group != _static_fields) _nonstatic_oopmap_count++;\n@@ -668,1 +753,40 @@\n-        }\n+          break;\n+        case T_PRIMITIVE_OBJECT:\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never inlined\n+            group->add_oop_field(fs);\n+          } else {\n+            _has_flattening_information = true;\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verification already have been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            JavaThread* THREAD = JavaThread::current();\n+            Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+            assert(klass != NULL, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ volatile fields are currently never inlined, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n+              group->add_inlined_field(fs, vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              fs.set_inlined(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              group->add_oop_field(fs);\n+            }\n+          }\n+          break;\n+        default:\n+          fatal(\"Something wrong?\");\n@@ -670,3 +794,0 @@\n-      break;\n-    default:\n-      fatal(\"Something wrong?\");\n@@ -698,1 +819,1 @@\n-  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(_fields, _constant_pool, _multifield_info); !fs.done(); fs.next()) {\n@@ -710,53 +831,23 @@\n-    switch(type) {\n-    case T_BYTE:\n-    case T_CHAR:\n-    case T_DOUBLE:\n-    case T_FLOAT:\n-    case T_INT:\n-    case T_LONG:\n-    case T_SHORT:\n-    case T_BOOLEAN:\n-      if (group != _static_fields) {\n-        field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n-      }\n-      group->add_primitive_field(fs, type);\n-      break;\n-    case T_OBJECT:\n-    case T_ARRAY:\n-      if (group != _static_fields) {\n-        _nonstatic_oopmap_count++;\n-        field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n-      }\n-      group->add_oop_field(fs);\n-      break;\n-    case T_PRIMITIVE_OBJECT: {\n-\/\/      fs.set_inline(true);\n-      _has_inline_type_fields = true;\n-      if (group == _static_fields) {\n-        \/\/ static fields are never inlined\n-        group->add_oop_field(fs);\n-      } else {\n-        \/\/ Flattening decision to be taken here\n-        \/\/ This code assumes all verifications have already been performed\n-        \/\/ (field's type has been loaded and it is an inline klass)\n-        JavaThread* THREAD = JavaThread::current();\n-        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n-        assert(klass != NULL, \"Sanity check\");\n-        InlineKlass* vk = InlineKlass::cast(klass);\n-        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n-        if (vk->is_naturally_atomic()) {\n-          too_atomic_to_flatten = false;\n-          \/\/too_volatile_to_flatten = false; \/\/FIXME\n-          \/\/ volatile fields are currently never inlined, this could change in the future\n-        }\n-        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n-          group->add_inlined_field(fs, vk);\n-          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-          field_alignment = vk->get_alignment();\n-          fs.set_inlined(true);\n-          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-            _has_nonatomic_values = true;\n-            _atomic_field_count--;  \/\/ every other field is atomic but this one\n+    bool has_multifield_annotation = false;\n+    if (fs.is_multifield() || fs.is_multifield_base()) {\n+      group->add_multifield(fs, _multifield_info);\n+    } else {\n+      switch(type) {\n+        case T_BYTE:\n+        case T_CHAR:\n+        case T_DOUBLE:\n+        case T_FLOAT:\n+        case T_INT:\n+        case T_LONG:\n+        case T_SHORT:\n+        case T_BOOLEAN:\n+          if (group != _static_fields) {\n+            field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n+          }\n+          group->add_primitive_field(fs, type);\n+          break;\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          if (group != _static_fields) {\n+            _nonstatic_oopmap_count++;\n+            field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n@@ -764,3 +855,40 @@\n-        } else {\n-          _nonstatic_oopmap_count++;\n-          field_alignment = type2aelembytes(T_OBJECT);\n+          break;\n+        case T_PRIMITIVE_OBJECT: {\n+          \/\/      fs.set_inline(true);\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never inlined\n+            group->add_oop_field(fs);\n+          } else {\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verifications have already been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            JavaThread* THREAD = JavaThread::current();\n+            Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+            assert(klass != NULL, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ volatile fields are currently never inlined, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n+              group->add_inlined_field(fs, vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              field_alignment = vk->get_alignment();\n+              fs.set_inlined(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              field_alignment = type2aelembytes(T_OBJECT);\n+              group->add_oop_field(fs);\n+            }\n+          }\n+          break;\n@@ -769,0 +897,2 @@\n+        default:\n+          fatal(\"Unexpected BasicType\");\n@@ -770,4 +900,0 @@\n-      break;\n-    }\n-    default:\n-      fatal(\"Unexpected BasicType\");\n@@ -777,0 +903,8 @@\n+  _root_group->sort_by_size();\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      if (_root_group->multifields()->at(i)->group_alignment() > alignment) {\n+        alignment = _root_group->multifields()->at(i)->group_alignment();\n+      }\n+    }\n+  }\n@@ -812,0 +946,5 @@\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      _layout->add_multifield(_root_group->multifields()->at(i));\n+    }\n+  }\n@@ -821,1 +960,6 @@\n-      _layout->add(cg->big_primitive_fields());\n+      if (cg->multifields() != NULL) {\n+        for (int i = 0; i < cg->multifields()->length(); i++) {\n+          _layout->add_multifield(cg->multifields()->at(i), start);\n+        }\n+      }\n+      _layout->add(cg->big_primitive_fields(), start);\n@@ -833,0 +977,5 @@\n+  if (_static_fields->multifields() != NULL) {\n+    for (int i = 0; i < _static_fields->multifields()->length(); i++) {\n+      _layout->add_multifield(_static_fields->multifields()->at(i));\n+    }\n+  }\n@@ -866,0 +1015,5 @@\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      _layout->add_multifield(_root_group->multifields()->at(i));\n+    }\n+  }\n@@ -879,1 +1033,0 @@\n-  _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":289,"deletions":136,"binary":false,"changes":425,"status":"modified"},{"patch":"@@ -5085,1 +5085,5 @@\n-  VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+  \/\/FIXME: VectorPayload class no longer holds the Object payload.\n+  \/\/Multi-field based payloads have been moved to leaf level\n+  \/\/concrete classes. Offset recorded here is used for object\n+  \/\/re-construction during de-opt.\n+  \/\/ VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1266,1 +1266,1 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,0 +194,7 @@\n+  \/* support multi-field based vectors *\/                                                                       \\\n+  do_klass(vector_VectorPayloadMF64_klass,              jdk_internal_vm_vector_VectorPayloadMF64              ) \\\n+  do_klass(vector_VectorPayloadMF128_klass,             jdk_internal_vm_vector_VectorPayloadMF128             ) \\\n+  do_klass(vector_VectorPayloadMF256_klass,             jdk_internal_vm_vector_VectorPayloadMF256             ) \\\n+  do_klass(vector_VectorPayloadMF512_klass,             jdk_internal_vm_vector_VectorPayloadMF512             ) \\\n+                                                                                                                \\\n+                                                                                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\/\/ Mapping function names to values. New entries should be added below.\n+\/\/ Mapping function names to values. New entries should be added below.\n@@ -96,3 +96,7 @@\n-  template(payload_name,                              \"payload\")                                            \\\n-  template(ETYPE_name,                                \"ETYPE\")                                              \\\n-  template(VLENGTH_name,                              \"VLENGTH\")                                            \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512\") \\\n+  template(payload_name,                              \"payload\")                                  \\\n+  template(ETYPE_name,                                \"ETYPE\")                                    \\\n+  template(VLENGTH_name,                              \"VLENGTH\")                                  \\\n@@ -266,0 +270,1 @@\n+  template(jdk_internal_vm_annotation_MultiField_signature,                  \"Ljdk\/internal\/vm\/annotation\/MultiField;\") \\\n@@ -268,0 +273,6 @@\n+  \/* VectorAPI support *\/                                                                         \\\n+  template(vector_VectorPayloadMF64_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64;\")  \\\n+  template(vector_VectorPayloadMF128_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128;\") \\\n+  template(vector_VectorPayloadMF256_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256;\") \\\n+  template(vector_VectorPayloadMF512_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512;\") \\\n+                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -373,1 +373,2 @@\n-  f(RecordComponent)\n+  f(RecordComponent) \\\n+  f(MultiFieldInfo)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  class   MultiFieldInfo;    \/\/ no C++ vtable\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-  jint int_at(int which) {\n+  jint int_at(int which) const {\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,0 +167,8 @@\n+  FieldInfo* MultiFieldInfo::base_field_info(InstanceKlass* ik) {\n+    return ik->field(_base_index);\n+  }\n+\n+  void MultiFieldInfo::metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_name);\n+  }\n+\n@@ -544,0 +552,1 @@\n+  _multifield_info(NULL),\n@@ -749,0 +758,4 @@\n+  if (_multifield_info != NULL && !_multifield_info->is_shared()) {\n+    MetadataFactory::free_array<MultiFieldInfo>(loader_data, _multifield_info);\n+  }\n+\n@@ -2654,0 +2667,3 @@\n+  if(_multifield_info != NULL) {\n+    it->push(&_multifield_info);\n+  }\n@@ -2704,1 +2720,1 @@\n-    for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -136,0 +136,16 @@\n+class MultiFieldInfo : public MetaspaceObj {\n+ private:\n+  Symbol* _name;\n+  u2 _base_index;\n+  jbyte _multifield_index;\n+ public:\n+  MultiFieldInfo() : _name(NULL), _base_index(0), _multifield_index(-1) {}\n+  MultiFieldInfo(Symbol* name, u2 base, jbyte index) : _name(name), _base_index(base), _multifield_index(index) {}\n+  Symbol* name() const { return _name; }\n+  u2 base_index() const { return _base_index; }\n+  jbyte multifield_index() const { return _multifield_index; }\n+  FieldInfo* base_field_info(InstanceKlass* ik);\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  MetaspaceObj::Type type() const { return MultiFieldInfoType; }\n+};\n+\n@@ -226,0 +242,3 @@\n+  \/\/ Array containing meta-data generated for multifields\n+  Array<MultiFieldInfo>* _multifield_info;\n+\n@@ -446,0 +465,1 @@\n+  friend class MultiFieldInfo;\n@@ -451,1 +471,1 @@\n-  Symbol* field_name        (int index) const { return field(index)->name(constants()); }\n+  Symbol* field_name        (int index) const { return field(index)->name(multifield_info(), constants()); }\n@@ -466,0 +486,11 @@\n+  Array<MultiFieldInfo>* multifield_info() const { return _multifield_info; }\n+\n+  MultiFieldInfo multifield_info(int i) const {\n+    guarantee(_multifield_info != NULL, \"Just checking\");\n+    return _multifield_info->at(i);\n+  }\n+  void set_multifield_info(Array<MultiFieldInfo>* array) {\n+    assert(_multifield_info == NULL, \"Must be initialized only once\");\n+    _multifield_info = array;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -110,1 +110,2 @@\n-  guarantee(f->name_index() != 0 && f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n+  \/\/ assert to be extended to allow multifield names\n+  guarantee(\/*f->name_index() != 0 &&*\/ f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,0 +93,3 @@\n+  inline bool is_multifield()            const;\n+  inline u2   multifield_base()          const;\n+  inline jbyte multifield_index()        const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,0 +30,1 @@\n+import jdk.internal.vm.annotation.MultiField;\n@@ -31,0 +33,1 @@\n+\n@@ -32,0 +35,1 @@\n+import java.lang.reflect.*;\n@@ -151,1 +155,7 @@\n-    public static class VectorSpecies<E> {}\n+    public static class VectorSpecies<E> { }\n+\n+    public abstract static class VectorPayload {\n+        protected abstract Object getPayload();\n+    }\n+\n+    public static abstract class Vector<E> extends VectorPayload { }\n@@ -153,1 +163,1 @@\n-    public static class VectorPayload {\n+    public static class VectorShuffle<E> extends VectorPayload {\n@@ -156,1 +166,4 @@\n-        public VectorPayload(Object payload) {\n+        protected final Object getPayload() {\n+            return VectorSupport.maybeRebox(this).payload;\n+        }\n+        public VectorShuffle(Object payload) {\n@@ -159,0 +172,4 @@\n+    }\n+\n+    public static class VectorMask<E> extends VectorPayload {\n+        private final Object payload; \/\/ array of primitives\n@@ -163,0 +180,3 @@\n+        public VectorMask(Object payload) {\n+            this.payload = payload;\n+        }\n@@ -165,3 +185,14 @@\n-    public static class Vector<E> extends VectorPayload {\n-        public Vector(Object payload) {\n-            super(payload);\n+    public abstract static class VectorPayloadMF {\n+        public abstract long multiFieldOffset();\n+\n+        private static VectorPayloadMF newInstanceFactory(int elemSize, int length)  {\n+            VectorPayloadMF obj = null;\n+            int vecSize = elemSize * length;\n+            switch(vecSize) {\n+                case 8: obj = new VectorPayloadMF64(); break;\n+                case 16: obj = new VectorPayloadMF128(); break;\n+                case 32: obj = new VectorPayloadMF256(); break;\n+                case 64: obj = new VectorPayloadMF512(); break;\n+                default: assert false : \"Unhandled vector size\";\n+            }\n+            return obj;\n@@ -169,4 +200,2 @@\n-    }\n-    public static class VectorShuffle<E> extends VectorPayload {\n-        public VectorShuffle(Object payload) {\n-            super(payload);\n+        public static VectorPayloadMF createVectPayloadInstance(int elemSize, int length) {\n+            return newInstanceFactory(elemSize, length);\n@@ -175,4 +204,21 @@\n-    }\n-    public static class VectorMask<E> extends VectorPayload {\n-        public VectorMask(Object payload) {\n-            super(payload);\n+\n+        public static VectorPayloadMF createVectPayloadInstanceB(int elemSize, int length, byte [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putByte(obj, start_offset + i * Byte.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public static VectorPayloadMF createVectPayloadInstanceS(int elemSize, int length, short [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putShort(obj, start_offset + i * Short.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n@@ -180,0 +226,105 @@\n+\n+        public static VectorPayloadMF createVectPayloadInstanceI(int elemSize, int length, int [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putInt(obj, start_offset + i * Integer.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public static VectorPayloadMF createVectPayloadInstanceL(int elemSize, int length, long [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putLong(obj, start_offset + i * Long.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public static VectorPayloadMF createVectPayloadInstanceF(int elemSize, int length, float [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putFloat(obj, start_offset + i * Float.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public static VectorPayloadMF createVectPayloadInstanceD(int elemSize, int length, double [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putDouble(obj, start_offset + i * Double.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public int length(int elemSize) {\n+            try {\n+                var field = this.getClass().getDeclaredField(\"mfield\");\n+                var msanno = field.getAnnotationsByType(MultiField.class);\n+\n+                Objects.nonNull(msanno);\n+\n+                assert msanno.length == 1;\n+                return msanno[0].value() \/ elemSize;\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1;\n+        }\n+\n+        public static long multiFieldOffset(Class<? extends VectorPayloadMF> cls) {\n+            try {\n+                var field = cls.getDeclaredField(\"mfield\");\n+                return Unsafe.getUnsafe().objectFieldOffset(field);\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1L;\n+        }\n+    }\n+\n+    public primitive static class VectorPayloadMF64 extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128 extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256 extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512 extends VectorPayloadMF {\n+        @MultiField(value = 64)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":165,"deletions":14,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.vector.VectorSupport;\n@@ -36,1 +37,2 @@\n-abstract class AbstractSpecies<E> extends jdk.internal.vm.vector.VectorSupport.VectorSpecies<E>\n+\n+abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>\n@@ -114,0 +116,2 @@\n+    @Stable \/\/lazy JIT constant\n+    AbstractVector<E> dummyVectorMF;\n@@ -313,0 +317,10 @@\n+    @ForceInline\n+    \/*package-private*\/\n+    AbstractVector<E> dummyVectorMF() {\n+        \/\/ This JITs to a constant value:\n+        AbstractVector<E> dummy = dummyVectorMF;\n+        if (dummy != null)  return dummy;\n+        \/\/ The rest of this computation is probably not JIT-ted.\n+        return makeDummyVectorMF();\n+    }\n+\n@@ -321,0 +335,48 @@\n+    VectorSupport.VectorPayloadMF createVectorMF(Object initarr) {\n+        VectorSupport.VectorPayloadMF za = null;\n+        switch (laneType.switchKey) {\n+        case LaneType.SK_FLOAT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(elementByteSize(), laneCount, (float[])initarr);\n+            break;\n+        case LaneType.SK_DOUBLE:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(elementByteSize(), laneCount, (double[])initarr);\n+            break;\n+        case LaneType.SK_BYTE:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(elementByteSize(), laneCount, (byte[])initarr);\n+            break;\n+        case LaneType.SK_SHORT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(elementByteSize(), laneCount, (short[])initarr);\n+            break;\n+        case LaneType.SK_INT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(elementByteSize(), laneCount, (int[])initarr);\n+            break;\n+        case LaneType.SK_LONG:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(elementByteSize(), laneCount, (long[])initarr);\n+            break;\n+        default:\n+            assert false : \"Unsupported elemType in createVectorMF\";\n+            break;\n+        }\n+        return za;\n+    }\n+\n+    private AbstractVector<E> makeDummyVectorMF() {\n+        Object za = null;\n+        switch (laneType.switchKey) {\n+        case LaneType.SK_FLOAT:\n+        case LaneType.SK_DOUBLE:\n+        case LaneType.SK_BYTE:\n+        case LaneType.SK_SHORT:\n+        case LaneType.SK_INT:\n+        case LaneType.SK_LONG:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstance(elementByteSize(), laneCount);\n+            break;\n+        default:\n+            assert false : \"Unsupported elemType in makeDummyVectorMF\";\n+            break;\n+        }\n+        return dummyVector = vectorFactory.apply(za);\n+        \/\/ This is the only use of vectorFactory.\n+        \/\/ All other factory requests are routed\n+        \/\/ through the dummy vector.\n+    }\n@@ -328,1 +390,1 @@\n-        return dummyVector().maskFromArray(bits);\n+        return dummyVectorMF().maskFromArray(bits);\n@@ -335,1 +397,1 @@\n-        return dummyVector().shuffleFromArray(sourceIndexes, offset);\n+        return dummyVectorMF().shuffleFromArray(sourceIndexes, offset);\n@@ -342,1 +404,1 @@\n-        return dummyVector().shuffleFromArray(sourceIndexes, 0);\n+        return dummyVectorMF().shuffleFromArray(sourceIndexes, 0);\n@@ -349,1 +411,1 @@\n-        return dummyVector().shuffleFromOp(fn);\n+        return dummyVectorMF().shuffleFromOp(fn);\n@@ -358,1 +420,1 @@\n-            return dummyVector().iotaShuffle();\n+            return dummyVectorMF().iotaShuffle();\n@@ -360,1 +422,1 @@\n-            return dummyVector().iotaShuffle(start, step, wrap);\n+            return dummyVectorMF().iotaShuffle(start, step, wrap);\n@@ -455,1 +517,1 @@\n-    abstract AbstractVector<E> rvOp(RVOp f);\n+    abstract AbstractVector<E> rvOpMF(RVOp f);\n@@ -467,1 +529,1 @@\n-        return dummyVector().maskFromArray(res);\n+        return dummyVectorMF().maskFromArray(res);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":71,"deletions":9,"binary":false,"changes":80,"status":"modified"}]}