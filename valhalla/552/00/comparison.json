{"files":[{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import java.lang.invoke.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import static jdk.test.lib.Asserts.*;\n+\n+import jdk.experimental.bytecode.*;\n+\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+\/**\n+ * @test TestBytecodeLib\n+ * @summary Check bytecode test library generates the correct code for Valhalla changes to JVMS\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n+ * @compile Point.java TestBytecodeLib.java\n+ * @run main\/othervm runtime.valhalla.inlinetypes.TestBytecodeLib\n+ *\/\n+\n+public class TestBytecodeLib {\n+\n+    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    public static void main(String[] args) throws Throwable {\n+        testAnewarrayDesc();\n+        testCheckcastDesc();\n+        \/\/ No support in test library for \"ldc(Class<?>)\" at all in this incarnation of the API, skip it\n+        testMultianewarrayDesc();\n+    }\n+\n+    \/\/ anewarray accepts reference and inline reference type\n+    \/\/ checkcast for arrays accepts reference and inline reference array type\n+    static void testAnewarrayDesc() throws Throwable {\n+        Class<?> lClass = Point.ref.class;\n+        Class<?> qClass = Point.val.class;\n+\n+        String methodName = \"anewarrayLQClass\";\n+        MethodType methodType = MethodType.methodType(void.class);\n+        byte[] codeBytes = InstructionHelper.buildCode(LOOKUP, methodName, methodType,\n+            CODE -> {\n+                CODE\n+                .iconst_3()\n+                .anewarray(lClass)\n+                .checkcast(Point.ref[].class)\n+                .pop()\n+                .iconst_3()\n+                .anewarray(qClass)\n+                .checkcast(Point.val[].class)\n+                .pop()\n+                .return_();\n+            }\n+        );\n+\n+        \/\/ Verify correct byte-code\n+        dumpBytes(methodName + \".class\", codeBytes);\n+\n+        \/\/ Verify it works\n+        InstructionHelper.loadCodeBytes(LOOKUP, methodName, methodType, codeBytes).invokeExact();\n+    }\n+\n+    \/\/ checkcast accepts reference and inline reference type\n+    static void testCheckcastDesc() throws Throwable {\n+        Class<?> lClass = Point.ref.class;\n+        Class<?> qClass = Point.val.class;\n+\n+        String methodName = \"checkcastLQClass\";\n+        MethodType methodType = MethodType.methodType(void.class);\n+        byte[] codeBytes = InstructionHelper.buildCode(LOOKUP, methodName, methodType,\n+            CODE -> {\n+                CODE\n+                .defaultvalue(Point.class)\n+                .checkcast(lClass) \/\/ expect no descriptor here\n+                .checkcast(qClass) \/\/ expect Q-type descriptor here\n+                .pop()\n+                .return_();\n+            }\n+        );\n+\n+        \/\/ Verify correct byte-code\n+        dumpBytes(methodName + \".class\", codeBytes);\n+\n+        \/\/ Verify it works\n+        InstructionHelper.loadCodeBytes(LOOKUP, methodName, methodType, codeBytes).invokeExact();\n+    }\n+\n+    \/\/ multianewarray accepts reference and inline reference type...it naturally does, but...\n+    \/\/ checkcast for multidim arrays accepts reference and inline reference array type\n+    static void testMultianewarrayDesc() throws Throwable {\n+        Class<?> lClass = Point.ref[][].class;\n+        Class<?> qClass = Point.val[][].class;\n+\n+        String methodName = \"multianewarrayLQClass\";\n+        MethodType methodType = MethodType.methodType(void.class);\n+        byte dimCnt = (byte) 2;\n+        byte[] codeBytes = InstructionHelper.buildCode(LOOKUP, methodName, methodType,\n+            CODE -> {\n+                CODE\n+                .iconst_3()\n+                .iconst_4()\n+                .multianewarray(lClass, dimCnt)\n+                .checkcast(lClass)\n+                .pop()\n+                .iconst_3()\n+                .iconst_4()\n+                .multianewarray(qClass, dimCnt)\n+                .checkcast(qClass)\n+                .pop()\n+                .return_();\n+            }\n+        );\n+\n+        \/\/ Verify correct byte-code\n+        dumpBytes(methodName + \".class\", codeBytes);\n+\n+        \/\/ Verify it works\n+        InstructionHelper.loadCodeBytes(LOOKUP, methodName, methodType, codeBytes).invokeExact();\n+    }\n+\n+    \/*\n+        Dump the resulting bytes for inspection.\n+\n+        TODO: Would prefer programmtic use of ClassReader for verification, but only\n+        when the JVMS on q-types is less fluid (since it is a lot of work),\n+        so manual inspection for now.\n+\n+        Dump in the dir above \"test-support\/<test-suite-run>\/scratch\/<n>\" so it doesn't get clean up at end of run,\n+        and use a directory \"DUMP_CLASS_FILES\" (in keeping with MethodHandles classfile dump)\n+     *\/\n+    static void dumpBytes(String name, byte[] bytes) throws java.io.IOException {\n+        Path path = Paths.get(\"..\/DUMP_CLASS_FILES\");\n+        Files.createDirectories(path);\n+        path = path.resolve(name);\n+        System.out.println(\"Dump: \" + path);\n+        Files.write(path, bytes);\n+    }\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestBytecodeLib.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String name, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n@@ -168,1 +168,1 @@\n-        return loadCode(lookup, className, name, type, builder);\n+        return loadCode(lookup, className, methodName, type, builder);\n@@ -184,0 +184,10 @@\n+    \/\/ Helper method to load code built with \"buildCode()\"\n+    public static MethodHandle loadCodeBytes(MethodHandles.Lookup lookup, String methodName, MethodType type, byte[] byteCode) {\n+        try {\n+            Class<?> clazz = lookup.defineClass(byteCode);\n+            return lookup.findStatic(clazz, methodName, type);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Failed to loadCodeBytes \\\"\" + methodName + \"\\\"\", t);\n+        }\n+    }\n+\n@@ -189,11 +199,0 @@\n-\n-        IsolatedMethodBuilder isolatedMethodBuilder = new IsolatedMethodBuilder(className, lookup);\n-        isolatedMethodBuilder\n-                .withSuperclass(Object.class)\n-                .withMajorVersion(62)\n-                .withMinorVersion(0)\n-                .withFlags(Flag.ACC_PUBLIC)\n-                .withMethod(methodName, type, M ->\n-                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)\n-                                .withCode(builderFunc, builder));\n-\n@@ -201,1 +200,1 @@\n-            byte[] byteArray = isolatedMethodBuilder.build();\n+            byte[] byteArray = buildCode(lookup, className, methodName, type, builderFunc, builder);\n@@ -209,0 +208,21 @@\n+    public static byte[] buildCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String className = generateClassNameFromLookupClass(lookup);\n+        return buildCode(lookup, className, methodName, type.toMethodDescriptorString(), MethodHandleCodeBuilder::new, builder);\n+    }\n+\n+    public static <C extends CodeBuilder<Class<?>, String, byte[], ?>> byte[] buildCode(\n+        MethodHandles.Lookup lookup, String className, String methodName, String type,\n+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n+            Consumer<? super C> builder) {\n+\n+                return new IsolatedMethodBuilder(className, lookup)\n+                    .withSuperclass(Object.class)\n+                    .withMajorVersion(62)\n+                    .withMinorVersion(0)\n+                    .withFlags(Flag.ACC_PUBLIC)\n+                    .withMethod(methodName, type, M ->\n+                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)\n+                            .withCode(builderFunc, builder)).build();\n+\n+    }\n+\n@@ -224,0 +244,3 @@\n+            if (c.isArray()) {\n+                return c.descriptorString();\n+            }\n@@ -263,5 +286,1 @@\n-                if (aClass.isArray()) {\n-                    return classToInternalName(aClass);\n-                } else {\n-                    return (aClass.isValueType() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n-                }\n+                return aClass.descriptorString();\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":39,"deletions":20,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -176,1 +176,3 @@\n-        code.writeChar(poolHelper.putClass(array));\n+        int poolIdx = (typeHelper.isInlineClass(typeHelper.type(array))) ?\n+            poolHelper.putInlineClass(array) : poolHelper.putClass(array);\n+        code.writeChar(poolIdx);\n@@ -182,1 +184,3 @@\n-        code.writeChar(poolHelper.putClass(target));\n+        int poolIdx = (typeHelper.isInlineClass(typeHelper.type(target))) ?\n+            poolHelper.putInlineClass(target) : poolHelper.putClass(target);\n+        code.writeChar(poolIdx);\n@@ -188,1 +192,3 @@\n-        code.writeChar(poolHelper.putClass(target));\n+        int poolIdx = (typeHelper.isInlineClass(typeHelper.type(target))) ?\n+            poolHelper.putInlineClass(target) : poolHelper.putClass(target);\n+        code.writeChar(poolIdx);\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/CodeBuilder.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-import java.util.function.ToIntFunction;\n-\n-public class IsolatedMethodBuilder extends MethodBuilder<Class<?>, String, Object[]> {\n-\n-    public IsolatedMethodBuilder(Lookup lookup, String name, String type) {\n-        super(null, name, type, new IsolatedMethodPoolHelper(lookup), null);\n-    }\n-\n-    static class IsolatedMethodPoolHelper implements PoolHelper<Class<?>, String, Object[]> {\n-        Map<Object, Integer> constants = new HashMap<>();\n-        Lookup lookup;\n-\n-        private IsolatedMethodPoolHelper(Lookup lookup) {\n-            this.lookup = lookup;\n-        }\n-\n-        @Override\n-        public int putClass(Class<?> symbol) {\n-            return putIfAbsent(symbol);\n-        }\n-\n-        @Override\n-        public int putInlineClass(Class<?> symbol) {\n-            return putIfAbsent(symbol);\n-        }\n-\n-        @Override\n-        public int putFieldRef(Class<?> owner, CharSequence name, String type) {\n-            try {\n-                Field f = owner.getDeclaredField(name.toString()); \/\/TODO: we should unreflect for a var handle\n-                return putIfAbsent(lookup.unreflectGetter(f));\n-            } catch (Throwable ex) {\n-                ex.printStackTrace();\n-                return -1;\n-            }\n-        }\n-\n-        @Override\n-        public int putMethodRef(Class<?> owner, CharSequence name, String type, boolean isInterface) {\n-            try {\n-                Method m = owner.getDeclaredMethod(name.toString()); \/\/we should unreflect according to method vs. constructor\n-                \/\/and static vs. private etc.\n-                return putIfAbsent(lookup.unreflect(m));\n-            } catch (Throwable ex) {\n-                ex.printStackTrace();\n-                return -1;\n-            }\n-        }\n-\n-        @Override\n-        public int putInt(int i) {\n-            return putIfAbsent(i);\n-        }\n-\n-        @Override\n-        public int putFloat(float f) {\n-            return putIfAbsent(f);\n-        }\n-\n-        @Override\n-        public int putLong(long l) {\n-            return putIfAbsent(l);\n-        }\n-\n-        @Override\n-        public int putDouble(double d) {\n-            return putIfAbsent(d);\n-        }\n-\n-        @Override\n-        public int putString(String s) {\n-            return putIfAbsent(s);\n-        }\n-\n-        @Override\n-        public int putInvokeDynamic(CharSequence invokedName, String invokedType, Class<?> bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<Class<?>, String, Object[]>> staticArgs) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putDynamicConstant(CharSequence constName, String constType, Class<?> bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<Class<?>, String, Object[]>> staticArgs) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putHandle(int refKind, Class<?> owner, CharSequence name, String type) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putHandle(int refKind, Class<?> owner, CharSequence name, String type, boolean isInterface) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putMethodType(String s) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putUtf8(CharSequence s) {\n-            return putIfAbsent(s);\n-        }\n-\n-        @Override\n-        public int putType(String s) {\n-            return putIfAbsent(s);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return constants.size();\n-        }\n-\n-        @Override\n-        public Object[] entries() {\n-            return constants.keySet().toArray();\n-        }\n-\n-        int putIfAbsent(Object o) {\n-            int nextIndex = constants.size() + 1;\n-            Object res = constants.putIfAbsent(o, nextIndex);\n-            return res == null ?\n-                    nextIndex : (Integer)res;\n-        }\n-    }\n-\n-    public Object[] entries() {\n-        return poolHelper.entries();\n-    }\n-\n-    @Override\n-    public byte[] build() {\n-        byte[] arr = super.build();\n-        int codelength_offset = 2 + 2 + 2 + 2 +\n-                2 + 4 + 2 + 2;\n-        int code_offset = codelength_offset + 4;\n-        int length = ByteBuffer.wrap(arr).getInt(codelength_offset);\n-        byte[] opcodes = new byte[length];\n-        System.arraycopy(arr, code_offset, opcodes, 0, length);\n-        return opcodes;\n-    }\n-\n-    public static void main(String[] args) {\n-        IsolatedMethodBuilder imb =  new IsolatedMethodBuilder(MethodHandles.lookup(), \"foo\", \"(java\/lang\/String;)I\");\n-        imb.withCode(C ->\n-                    C.aload_0()\n-                     .invokevirtual(String.class, \"length\", \"()I\", false)\n-                     .ireturn());\n-        byte[] opcodes = imb.build();\n-        System.out.println(Arrays.toString(opcodes));\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/IsolatedMethodBuilder.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"}]}