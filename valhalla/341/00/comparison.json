{"files":[{"patch":"@@ -2725,0 +2725,12 @@\n+  if (_desc->bytecode() == Bytecodes::_areturn) {  \/\/ or should the test be state == atos ?\n+    Label not_restricted;\n+    __ get_method(rscratch1);\n+    __ movzwl(rscratch1, Address(rscratch1, Method::flags_offset()));\n+    __ andl(rscratch1, Method::_restricted_method);\n+    __ jcc(Assembler::zero, not_restricted);\n+    Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+    __ movptr(robj, aaddress(0));\n+    __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::restricted_return_value_check), robj);\n+    __ bind(not_restricted);\n+  }\n+\n@@ -3919,0 +3931,13 @@\n+void TemplateTable::restricted_method_check(Register method) {\n+    Label not_restricted;\n+  __ movptr(rscratch1, method);\n+  __ movzwl(rscratch1, Address(rscratch1, Method::flags_offset()));\n+  __ andl(rscratch1, Method::_restricted_method);\n+  __ jcc(Assembler::zero, not_restricted);\n+  __ restore_bcp();\n+  __ push(method);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::restricted_parameter_checks));\n+  __ pop(method);\n+  __ bind(not_restricted);\n+}\n+\n@@ -4032,1 +4057,1 @@\n-\n+  restricted_method_check(method);\n@@ -4046,1 +4071,0 @@\n-\n@@ -4048,0 +4072,1 @@\n+  restricted_method_check(method);\n@@ -4076,0 +4101,1 @@\n+  restricted_method_check(rbx);\n@@ -4086,0 +4112,1 @@\n+  restricted_method_check(rbx);\n@@ -4148,1 +4175,1 @@\n-\n+  restricted_method_check(rbx);\n@@ -4200,0 +4227,2 @@\n+  restricted_method_check(rbx);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+  static void restricted_method_check(Register method);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2684,0 +2684,4 @@\n+  bool has_restricted_method_attribute = false;\n+  const u1* restricted_param_types_start = NULL;\n+  u2 restricted_return_type_index = 0;\n+  u1 restricted_num_params = 0;\n@@ -3020,0 +3024,23 @@\n+      } else if (method_attribute_name == vmSymbols::tag_restricted_method()) {\n+        const u1* const current_start = cfs->current();\n+\n+        \/\/ RestrictedMethod_attribute {\n+        \/\/   u2 name_index;\n+        \/\/   u4 length;\n+        \/\/   u1 num_params;\n+        \/\/   u2 restricted_param_type[num_params];\n+        \/\/   u2 restricted_return_type;\n+        \/\/ }\n+\n+        has_restricted_method_attribute = true;\n+        cfs->guarantee_more(1, CHECK_NULL);  \/\/ num_params\n+        restricted_num_params = cfs->get_u1_fast();\n+        guarantee_property((int)method_attribute_length == restricted_num_params * 2 + 3,\n+                          \"Invalid RestrictedMethod attribute length %u in class file %s\",\n+                          method_attribute_length,\n+                          CHECK_NULL);\n+\n+        restricted_param_types_start = cfs->current();\n+        cfs->skip_u2_fast(restricted_num_params);\n+        cfs->guarantee_more(2, CHECK_NULL);  \/\/ restricted_return_type\n+        restricted_return_type_index = cfs->get_u2_fast();\n@@ -3059,0 +3086,4 @@\n+      \/\/ RestrictedMethod atribute requires a more complex protocol because num_params can be zeo\n+      \/\/ but the attribute still be there because of a restricted return value\n+      \/\/ So -1 is passed if the attribute is absent, otherwise num_params is passed\n+      has_restricted_method_attribute ? restricted_num_params : -1 ,\n@@ -3162,0 +3193,12 @@\n+  \/\/ Copy RestrictedMethod attribute if present\n+  if (has_restricted_method_attribute) {\n+    m->set_restricted_method(true);\n+    *(m->constMethod()->restricted_num_params_addr()) = restricted_num_params;\n+    *(m->constMethod()->restricted_return_type_index_addr()) = restricted_return_type_index;\n+    u2* cursor = m->constMethod()->restricted_param_type_start();\n+    for (int i = 0; i < restricted_num_params; i++) {\n+      cursor[i] = Bytes::get_Java_u2((address)restricted_param_types_start);\n+      restricted_param_types_start +=2;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+  template(tag_restricted_method,                     \"RestrictedMethod\")                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -537,0 +537,45 @@\n+JRT_ENTRY(void, InterpreterRuntime::restricted_parameter_checks(JavaThread* thread))\n+  LastFrameAccessor last_frame(thread);\n+  Method* caller = last_frame.method();\n+  constantPoolHandle cph(THREAD, caller->constants());\n+  Method* callee = last_frame.cache_entry()->method_if_resolved(cph);\n+  assert(callee != NULL, \"Something bad happened\");\n+  if (callee->has_restricted_method()) {\n+    ResourceMark rm(THREAD);\n+    Symbol* signature = callee->signature();\n+    ArgumentCount args(signature);\n+    int arg_count = args.size();\n+    ResourceArea *area = Thread::current()->resource_area();\n+    int* sizes = NEW_ARENA_ARRAY(area, int, arg_count);\n+    int i = 0;\n+    for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {\n+      sizes[i] = parameter_type_word_count(ss.type());\n+      i++;\n+    }\n+    int tos_idx = (int)last_frame.get_frame().interpreter_frame_expression_stack_size() - 3;\n+    for (int i = arg_count - 1; i >=0; --i) {\n+      Klass* k = callee->restricted_param_type_at(i);\n+      if (k != NULL) {\n+        oop arg = *(oop*)last_frame.get_frame().interpreter_frame_expression_stack_at(tos_idx);\n+        if (!arg->klass()->is_subtype_of(k)) {\n+          THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+        }\n+      }\n+      tos_idx -= sizes[i];\n+    }\n+  }\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::restricted_return_value_check(JavaThread* thread, oopDesc* obj))\n+  LastFrameAccessor last_frame(thread);\n+  assert(last_frame.bytecode().code() == Bytecodes::_areturn, \"Only areturn should have such checks\");\n+  Method* method = last_frame.method();\n+  constantPoolHandle cph(THREAD, method->constants());\n+  if (method->constMethod()->has_restricted_method()) {\n+    Klass* k = method->restricted_return_value();\n+    if (k != NULL && !obj->klass()->is_subtype_of(k)) {\n+      THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+    }\n+  }\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -78,0 +78,3 @@\n+  static void restricted_parameter_checks(JavaThread* thread);\n+  static void restricted_return_value_check(JavaThread* thread, oopDesc* obj);\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -132,0 +132,10 @@\n+  \/\/ Protocol for RestrictedMethod attribute\n+  \/\/ if sizes->restricted_method_length() == -1 => attribute is not present\n+  \/\/ if sizes->restricted_method_length() ==  0 => attribute is present but restricted_param_types array is empty\n+  \/\/ otherwise the attribute is present and the restricted_param_types array contains sizes->restricted_method_length() elements\n+  if (sizes->restricted_method_length() >= 0) {\n+    extra_bytes += sizeof(u2); \/\/ restricted_return_type\n+    extra_bytes += sizeof(u1); \/\/ num param\n+    extra_bytes += sizes->restricted_method_length() * sizeof(u2);  \/\/ restricted_param_types array\n+  }\n+\n@@ -177,0 +187,15 @@\n+u1* ConstMethod::restricted_num_params_addr() const {\n+  assert(has_restricted_method(), \"called only if method has a RestrictedMethod attribute\");\n+  return (u1*)last_u2_element();\n+}\n+\n+u2* ConstMethod::restricted_return_type_index_addr() const {\n+  assert(has_restricted_method(), \"called only if method has a RestrictedMethod attribute\");\n+  return last_u2_element() - 1;\n+}\n+\n+u2* ConstMethod::restricted_param_type_start() const {\n+  assert(has_restricted_method(), \"called only if method has a RestrictedMethod attribute\");\n+  return last_u2_element() - 1 - *restricted_num_params_addr();\n+}\n+\n@@ -180,1 +205,5 @@\n-  return last_u2_element();\n+  if (has_restricted_method()) {\n+    return restricted_param_type_start() - 1;\n+  } else {\n+    return last_u2_element();\n+  }\n@@ -185,2 +214,9 @@\n-  return has_generic_signature() ? (last_u2_element() - 1) :\n-                                    last_u2_element();\n+  if (has_generic_signature()) {\n+    return generic_signature_index_addr() - 1;\n+  } else {\n+    if (has_restricted_method()) {\n+      return restricted_param_type_start() - 1;\n+    } else {\n+      return last_u2_element();\n+    }\n+  }\n@@ -196,3 +232,9 @@\n-    \/\/ Else, the exception table is at the end of the constMethod.\n-    return has_generic_signature() ? (last_u2_element() - 1) :\n-                                     last_u2_element();\n+    if (has_generic_signature()) {\n+      return generic_signature_index_addr() - 1;\n+    } else {\n+      if (has_restricted_method()) {\n+        return restricted_param_type_start() - 1;\n+      } else {\n+        return last_u2_element();\n+      }\n+    }\n@@ -212,3 +254,9 @@\n-      \/\/ Else, the exception table is at the end of the constMethod.\n-      return has_generic_signature() ? (last_u2_element() - 1) :\n-                                        last_u2_element();\n+      if (has_generic_signature()) {\n+        return generic_signature_index_addr() - 1;\n+      } else {\n+        if (has_restricted_method()) {\n+          return restricted_param_type_start() - 1;\n+        } else {\n+          return last_u2_element();\n+        }\n+      }\n@@ -233,3 +281,9 @@\n-        \/\/ Else, the exception table is at the end of the constMethod.\n-      return has_generic_signature() ? (last_u2_element() - 1) :\n-                                        last_u2_element();\n+        if (has_generic_signature()) {\n+          return generic_signature_index_addr() - 1;\n+        } else {\n+          if (has_restricted_method()) {\n+            return restricted_param_type_start() - 1;\n+          } else {\n+            return last_u2_element();\n+          }\n+        }\n@@ -267,0 +321,2 @@\n+  if (sizes->restricted_method_length() > 0)\n+    _flags |= _has_restricted_method;\n","filename":"src\/hotspot\/share\/oops\/constMethod.cpp","additions":68,"deletions":12,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -83,0 +83,3 @@\n+\/\/    [EMBEDDED] restricted parameter types + restricted return type + num param (in this order)\n+\/\/     (restricted parameter types are u2, restricted return type is u2)\n+\/\/     (num param is u1)\n@@ -137,1 +140,2 @@\n-  do_element(default_annotations_length)\n+  do_element(default_annotations_length)        \\\n+  do_element(restricted_method_length)\n@@ -189,1 +193,2 @@\n-    _has_default_annotations = 0x0400\n+    _has_default_annotations = 0x0400,\n+    _has_restricted_method = 0x800\n@@ -359,0 +364,15 @@\n+  \/\/ RestrictedMethod support\n+  int restricted_return_value_index() {\n+    assert(has_restricted_method(), \"\");\n+    return *(restricted_return_type_index_addr());\n+  }\n+  int restricted_num_param() {\n+    assert(has_restricted_method(), \"\");\n+    return *(restricted_num_params_addr());\n+  }\n+  int restricted_param_type_index_at(u1 index){\n+    assert(has_restricted_method(), \"\");\n+    u2* array = restricted_param_type_start();\n+    return array[index];\n+  }\n+\n@@ -385,0 +405,3 @@\n+  u1* restricted_num_params_addr() const;\n+  u2* restricted_return_type_index_addr() const;\n+  u2* restricted_param_type_start() const;\n@@ -390,0 +413,1 @@\n+  u2* restricted_method_length_addr() const;\n@@ -425,0 +449,2 @@\n+  bool has_restricted_method() const\n+    { return (_flags & _has_restricted_method) != 0; }\n","filename":"src\/hotspot\/share\/oops\/constMethod.hpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1034,0 +1034,4 @@\n+      \/\/ Loadding classes of restricted parameters\n+      if (m->constMethod()->has_restricted_method()) {\n+        m->resolve_restricted_types(CHECK_false);\n+      }\n@@ -1259,0 +1263,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  int size = Method::size(access_flags.is_native());\n+  int size = Method::size(access_flags.is_native(), sizes);\n@@ -179,0 +179,33 @@\n+\n+void  Method::resolve_restricted_types(TRAPS) {\n+  int idx = constMethod()->restricted_return_value_index();\n+  Handle loader_h(THREAD, constants()->pool_holder()->class_loader());\n+  Handle protdom_h(THREAD, constants()->pool_holder()->protection_domain());\n+  if (idx != 0) {\n+    Symbol* ret = constants()->symbol_at(idx);\n+    Klass* k = SystemDictionary::resolve_or_fail(ret, loader_h, protdom_h, true, CHECK);\n+    *restricted_return_value_addr() = k;\n+  } else {\n+    *restricted_return_value_addr() = NULL;\n+  }\n+  Klass** param_array = restricted_param_type_start();\n+  for (int i = 0; i < restricted_num_param(); i++) {\n+    int idx = constMethod()->restricted_param_type_index_at(i);\n+    if (idx != 0) {\n+      Symbol* ret = constants()->symbol_at(idx);\n+      Klass* k = SystemDictionary::resolve_or_fail(ret, loader_h, protdom_h, true, CHECK);\n+      param_array[i] = k;\n+    } else {\n+      param_array[i] = NULL;\n+    }\n+  }\n+}\n+\n+Klass* Method::restricted_return_value() const {\n+  return *restricted_return_value_addr();\n+}\n+\n+Klass* Method::restricted_param_type_at(int index) const {\n+  return restricted_param_type_start()[index];\n+}\n+\n@@ -344,1 +377,1 @@\n-int Method::size(bool is_native) {\n+int Method::size(bool is_native, InlineTableSizes* sizes) {\n@@ -347,0 +380,3 @@\n+  if (sizes->restricted_method_length() != -1) {\n+    extra_bytes += (sizes->restricted_method_length() + 1) * sizeof(Klass*); \/\/ +1 is for the return value type\n+  }\n@@ -1618,0 +1654,1 @@\n+  int restricted_method_len = 0;\n@@ -1630,0 +1667,1 @@\n+      restricted_method_len,\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+ friend class TemplateTable;\n@@ -97,1 +98,2 @@\n-    _scoped                = 1 << 11\n+    _scoped                = 1 << 11,\n+    _restricted_method     = 1 << 12\n@@ -175,0 +177,6 @@\n+  \/\/ RestrictedMethod support\n+  void resolve_restricted_types(TRAPS);\n+  Klass* restricted_return_value() const;\n+  u1 restricted_num_param() const                { return constMethod()->restricted_num_param(); }\n+  Klass* restricted_param_type_at(int index) const;\n+\n@@ -711,1 +719,1 @@\n-  static int size(bool is_native);\n+  static int size(bool is_native, InlineTableSizes* sizes);\n@@ -956,0 +964,8 @@\n+  void set_restricted_method(bool x) {\n+    _flags = x ? (_flags | _restricted_method) : ( _flags & ~_restricted_method);\n+  }\n+\n+  bool has_restricted_method() const {\n+    return (_flags & _restricted_method) != 0;\n+  }\n+\n@@ -1080,0 +1096,2 @@\n+  Klass** restricted_return_value_addr() const   { return is_native() ? (Klass**)(signature_handler_addr() + 1) : (Klass**) (this+1); }\n+  Klass** restricted_param_type_start() const    { return restricted_return_value_addr() + 1; }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @compile  -XDflattenWithTypeRestrictions SimpleTest.java IncompleteKnowledgeTest.java\n+ * @compile SimpleTest.java IncompleteKnowledgeTest.java\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/IncompleteKnowledgeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2021, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import java.lang.invoke.RestrictedType;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @summary Testing type restrictions on method arguments and return value\n+ * @library \/test\/lib\n+ * @compile RestrictedMethodTest.java\n+ * @run main\/othervm -Xint runtime.valhalla.typerestrictions.RestrictedMethodTest\n+ *\/\n+\n+interface RMInterface {\n+  default public void imethod(@RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o) {\n+    System.out.println(\"imethod says \"+o);\n+  }\n+}\n+\n+public class RestrictedMethodTest implements RMInterface {\n+  static inline class Point {\n+    int x = 0;\n+    int y = 0;\n+  }\n+\n+  void oneRestrictedArgument(@RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o) {\n+    System.out.println(\"oneRestrictedArgument says \" + o);\n+  }\n+\n+  void twoRestrictedArguments(@RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o0,\n+                             @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o1) {\n+    System.out.println(\"twoRestrictedArguments says \" + o0 + \" \" + o1);\n+  }\n+\n+  void secondArgumentRestricted(long l, @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o) {\n+    System.out.println(\"secondArgumentRestricted says \" + l + \" \" + o);\n+  }\n+\n+  static void staticWithOneRestrictedArgument(@RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object o) {\n+    System.out.println(\"staticWithOneRestrictedArgument says \" + o);\n+  }\n+\n+  static @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/RestrictedMethodTest$Point;\") Object restrictedReturnValue(Object o) {\n+    System.out.println(\"Returning \"+o);\n+    return o;\n+  }\n+\n+  static void testRMInterface(RMInterface i) {\n+    Point p = new Point();\n+    Throwable result = null;\n+    try {\n+      i.imethod(p);\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+      i.imethod(new Object());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+  }\n+  static void expectICC(Throwable t) {\n+    Asserts.assertNotNull(t, \"An error should have been thrown\");\n+    Asserts.assertTrue(t instanceof java.lang.IncompatibleClassChangeError, \"Wrong error type\");\n+  }\n+\n+  static void expectNoError(Throwable t) {\n+    Asserts.assertNull(t, \"No Error should have been thrown\");\n+  }\n+  public static void main(String[] args) {\n+    Point p = new Point();\n+    RestrictedMethodTest test = new RestrictedMethodTest();\n+    Throwable result = null;\n+    try {\n+      test.oneRestrictedArgument(p);\n+    }  catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+        test.oneRestrictedArgument(new Object());\n+    } catch(Throwable t) {\n+        result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    try {\n+      test.twoRestrictedArguments(p, new Point());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+      test.twoRestrictedArguments(new Object(), new Point());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    try {\n+      test.twoRestrictedArguments(p, new Object());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    try {\n+      test.secondArgumentRestricted(42L, p);\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+      test.secondArgumentRestricted(42L, new String(\"Duke\"));\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    \/\/ Is code robust againt null receiver?\n+    RestrictedMethodTest test2 = null;\n+    try {\n+        test2.oneRestrictedArgument(new Object());\n+    } catch(Throwable t) {\n+        result = t;\n+    }\n+    Asserts.assertNotNull(result, \"An NPE should have been thrown\");\n+    Asserts.assertTrue(result instanceof java.lang.NullPointerException, \"Wrong exception type\");\n+    result = null;\n+    try {\n+      staticWithOneRestrictedArgument(p);\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+        staticWithOneRestrictedArgument(new Object());\n+    } catch(Throwable t) {\n+        result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+    testRMInterface(test);\n+    try {\n+      restrictedReturnValue(new Point());\n+    } catch(Throwable t) {\n+      result = t;\n+    }\n+    expectNoError(result);\n+    try {\n+        restrictedReturnValue(new Object());\n+    } catch(Throwable t) {\n+        result = t;\n+    }\n+    expectICC(result);\n+    result = null;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/RestrictedMethodTest.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- * @compile  -XDflattenWithTypeRestrictions SimpleTest.java\n+ * @compile SimpleTest.java\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/SimpleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}