{"files":[{"patch":"@@ -693,1 +693,1 @@\n-    \/\/ All 3 entries are the same (no value-type packing)\n+    \/\/ All 3 entries are the same (no inline type packing)\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -844,2 +844,2 @@\n-bool CallNode::has_non_debug_use(Node *n) {\n-  const TypeTuple * d = tf()->domain_cc();\n+bool CallNode::has_non_debug_use(Node* n) {\n+  const TypeTuple* d = tf()->domain_cc();\n@@ -847,2 +847,1 @@\n-    Node *arg = in(i);\n-    if (arg == n) {\n+    if (in(i) == n) {\n@@ -855,6 +854,6 @@\n-bool CallNode::has_debug_use(Node *n) {\n-  assert(jvms() != NULL, \"jvms should not be null\");\n-  for (uint i = jvms()->debug_start(); i < jvms()->debug_end(); i++) {\n-    Node *arg = in(i);\n-    if (arg == n) {\n-      return true;\n+bool CallNode::has_debug_use(Node* n) {\n+  if (jvms() != NULL) {\n+    for (uint i = jvms()->debug_start(); i < jvms()->debug_end(); i++) {\n+      if (in(i) == n) {\n+        return true;\n+      }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -645,2 +645,2 @@\n-  bool                has_non_debug_use(Node *n);\n-  bool                has_debug_use(Node *n);\n+  bool                has_non_debug_use(Node* n);\n+  bool                has_debug_use(Node* n);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-\n-  if (obj->is_InlineType()) {\n+  const Type* obj_type = gvn().type(obj);\n+  if (obj_type->isa_inlinetype() && !obj_type->is_inlinetypeptr()) {\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2230,0 +2230,43 @@\n+void PhaseMacroExpand::inline_type_guard(Node** ctrl, LockNode* lock) {\n+  assert(EnableValhalla, \"should only be used if inline types are enabled\");\n+  Node* obj = lock->obj_node();\n+  const TypePtr* obj_type = _igvn.type(obj)->make_ptr();\n+  if (!obj_type->can_be_inline_type()) {\n+    return;\n+  }\n+  Node* mark = make_load(*ctrl, lock->memory(), obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n+  Node* value_mask = _igvn.MakeConX(markWord::inline_type_pattern);\n+  Node* is_value = _igvn.transform(new AndXNode(mark, value_mask));\n+  Node* cmp = _igvn.transform(new CmpXNode(is_value, value_mask));\n+  Node* bol = _igvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  Node* unc_ctrl = generate_slow_guard(ctrl, bol, NULL);\n+\n+  int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_class_check, Deoptimization::Action_none);\n+  address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n+  const TypePtr* no_memory_effects = NULL;\n+  CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\",\n+                                         lock->jvms()->bci(), no_memory_effects);\n+  unc->init_req(TypeFunc::Control, unc_ctrl);\n+  unc->init_req(TypeFunc::I_O, lock->i_o());\n+  unc->init_req(TypeFunc::Memory, lock->memory());\n+  unc->init_req(TypeFunc::FramePtr,  lock->in(TypeFunc::FramePtr));\n+  unc->init_req(TypeFunc::ReturnAdr, lock->in(TypeFunc::ReturnAdr));\n+  unc->init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));\n+  unc->set_cnt(PROB_UNLIKELY_MAG(4));\n+  unc->copy_call_debug_info(&_igvn, lock);\n+\n+  assert(unc->peek_monitor_box() == lock->box_node(), \"wrong monitor\");\n+  assert((obj_type->is_inlinetypeptr() && unc->peek_monitor_obj()->is_SafePointScalarObject()) ||\n+         (unc->peek_monitor_obj() == lock->obj_node()), \"wrong monitor\");\n+\n+  \/\/ pop monitor and push obj back on stack: we trap before the monitorenter\n+  unc->pop_monitor();\n+  unc->grow_stack(unc->jvms(), 1);\n+  unc->set_stack(unc->jvms(), unc->jvms()->stk_size()-1, obj);\n+  _igvn.register_new_node_with_optimizer(unc);\n+\n+  unc_ctrl = _igvn.transform(new ProjNode(unc, TypeFunc::Control));\n+  Node* halt = _igvn.transform(new HaltNode(unc_ctrl, lock->in(TypeFunc::FramePtr), \"monitor enter on inline type\"));\n+  C->root()->add_req(halt);\n+}\n+\n@@ -2242,2 +2285,0 @@\n-  const Type* obj_type = _igvn.type(alock->obj_node());\n-  assert(!obj_type->isa_inlinetype() && !obj_type->is_inlinetypeptr(), \"Eliminating lock on inline type\");\n@@ -2282,0 +2323,3 @@\n+    \/\/ Deoptimize and re-execute if object is an inline type\n+    inline_type_guard(&ctrl, alock->as_Lock());\n+\n@@ -2525,41 +2569,2 @@\n-  const TypeOopPtr* objptr = _igvn.type(obj)->make_oopptr();\n-  if (objptr->can_be_inline_type()) {\n-    \/\/ Deoptimize and re-execute if a value\n-    assert(EnableValhalla, \"should only be used if inline types are enabled\");\n-    Node* mark = make_load(slow_path, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X->basic_type());\n-    Node* value_mask = _igvn.MakeConX(markWord::inline_type_pattern);\n-    Node* is_value = _igvn.transform(new AndXNode(mark, value_mask));\n-    Node* cmp = _igvn.transform(new CmpXNode(is_value, value_mask));\n-    Node* bol = _igvn.transform(new BoolNode(cmp, BoolTest::eq));\n-    Node* unc_ctrl = generate_slow_guard(&slow_path, bol, NULL);\n-\n-    int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_class_check, Deoptimization::Action_none);\n-    address call_addr = SharedRuntime::uncommon_trap_blob()->entry_point();\n-    const TypePtr* no_memory_effects = NULL;\n-    JVMState* jvms = lock->jvms();\n-    CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\",\n-                                           jvms->bci(), no_memory_effects);\n-\n-    unc->init_req(TypeFunc::Control, unc_ctrl);\n-    unc->init_req(TypeFunc::I_O, lock->i_o());\n-    unc->init_req(TypeFunc::Memory, mem); \/\/ may gc ptrs\n-    unc->init_req(TypeFunc::FramePtr,  lock->in(TypeFunc::FramePtr));\n-    unc->init_req(TypeFunc::ReturnAdr, lock->in(TypeFunc::ReturnAdr));\n-    unc->init_req(TypeFunc::Parms+0, _igvn.intcon(trap_request));\n-    unc->set_cnt(PROB_UNLIKELY_MAG(4));\n-    unc->copy_call_debug_info(&_igvn, lock);\n-\n-    assert(unc->peek_monitor_box() == box, \"wrong monitor\");\n-    assert(unc->peek_monitor_obj() == obj, \"wrong monitor\");\n-\n-    \/\/ pop monitor and push obj back on stack: we trap before the monitorenter\n-    unc->pop_monitor();\n-    unc->grow_stack(unc->jvms(), 1);\n-    unc->set_stack(unc->jvms(), unc->jvms()->stk_size()-1, obj);\n-\n-    _igvn.register_new_node_with_optimizer(unc);\n-\n-    Node* ctrl = _igvn.transform(new ProjNode(unc, TypeFunc::Control));\n-    Node* halt = _igvn.transform(new HaltNode(ctrl, lock->in(TypeFunc::FramePtr), \"monitor enter on value-type\"));\n-    C->root()->add_req(halt);\n-  }\n+  \/\/ Deoptimize and re-execute if object is an inline type\n+  inline_type_guard(&slow_path, lock);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":48,"deletions":43,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+  void inline_type_guard(Node** ctrl, LockNode* lock);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3530,0 +3530,97 @@\n+\n+    \/\/ Lock on inline type (known after inlining)\n+    @ForceInline\n+    public Object test130_inlinee() {\n+        return MyValue1.createWithFieldsInline(rI, rL);\n+    }\n+\n+    @Test()\n+    public void test130() {\n+        Object obj = test130_inlinee();\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test130 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test130_verifier(boolean warmup) {\n+        try {\n+            test130();\n+            throw new RuntimeException(\"test130 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test130 but with field load instead of allocation\n+    @ForceInline\n+    public Object test131_inlinee() {\n+        return testValue1;\n+    }\n+\n+    @Test()\n+    public void test131() {\n+        Object obj = test131_inlinee();\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test131 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test131_verifier(boolean warmup) {\n+        try {\n+            test131();\n+            throw new RuntimeException(\"test131 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test locking on object that is known to be an inline type only after CCP\n+    @Test()\n+    @Warmup(10000)\n+    public void test132() {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        Object obj = new Integer(42);\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            obj = vt;\n+        }\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test132 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test132_verifier(boolean warmup) {\n+        try {\n+            test132();\n+            throw new RuntimeException(\"test132 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test conditional locking on inline type and non-escaping object\n+    @Test()\n+    public void test133(boolean b) {\n+        Object obj = b ? new Integer(42) : MyValue2.createWithFieldsInline(rI, rD);\n+        synchronized (obj) {\n+            if (!b) {\n+                throw new RuntimeException(\"test133 failed: synchronization on inline type should not succeed\");\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test133_verifier(boolean warmup) {\n+        test133(true);\n+        try {\n+            test133(false);\n+            throw new RuntimeException(\"test133 failed: no exception thrown\");\n+        } catch (IllegalMonitorStateException ex) {\n+            \/\/ Expected\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"}]}