{"files":[{"patch":"@@ -3184,1 +3184,8 @@\n-  call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cache);\n+  Register cpentry = rbx;\n+\n+  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+\n+  __ lea(cpentry, Address(cache, index, Address::times_ptr,\n+                         in_bytes(cp_base_offset)));\n+  __ lea(rax, at_tos());\n+  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield2), cpentry, rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -332,1 +332,5 @@\n-  assert(old_value != NULL && oopDesc::is_oop(old_value) && old_value->is_inline_type(),\"Verifying receiver\");\n+  if (old_value == NULL) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);\n+  }\n+  assert(oopDesc::is_oop(old_value), \"Verifying receiver\");\n+  assert(old_value->klass()->is_inline_klass(), \"Must have been checked during resolution\");\n@@ -371,0 +375,72 @@\n+JRT_ENTRY(int, InterpreterRuntime::withfield2(JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr))\n+  oop obj = NULL;\n+  int recv_offset = type2size[as_BasicType(cpe->flag_state())];\n+  assert(frame::interpreter_frame_expression_stack_direction() == -1, \"currently is -1 on all platforms\");\n+  int ret_adj = (recv_offset + type2size[T_OBJECT] )* AbstractInterpreter::stackElementSize;\n+  obj = (oopDesc*)(((uintptr_t*)ptr)[recv_offset * Interpreter::stackElementWords]);\n+  if (obj == NULL) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n+  }\n+  assert(oopDesc::is_oop(obj), \"Verifying receiver\");\n+  assert(obj->klass()->is_inline_klass(), \"Must have been checked during resolution\");\n+  instanceHandle old_value_h(THREAD, (instanceOop)obj);\n+  oop ref = NULL;\n+  if (cpe->flag_state() == atos) {\n+    ref = *(oopDesc**)ptr;\n+  }\n+  Handle ref_h(THREAD, ref);\n+  InlineKlass* ik = InlineKlass::cast(old_value_h()->klass());\n+  instanceOop new_value = ik->allocate_instance_buffer(CHECK_(ret_adj));\n+  Handle new_value_h = Handle(THREAD, new_value);\n+  ik->inline_copy_oop_to_new_oop(old_value_h(), new_value_h());\n+  int offset = cpe->f2_as_offset();\n+  switch(cpe->flag_state()) {\n+    case ztos:\n+      new_value_h()->bool_field_put(offset, (jboolean)(*(jint*)ptr));\n+      break;\n+    case btos:\n+      new_value_h()->byte_field_put(offset, (jbyte)(*(jint*)ptr));\n+      break;\n+    case ctos:\n+      new_value_h()->char_field_put(offset, (jchar)(*(jint*)ptr));\n+      break;\n+    case stos:\n+      new_value_h()->short_field_put(offset, (jshort)(*(jint*)ptr));\n+      break;\n+    case itos:\n+      new_value_h()->int_field_put(offset, (*(jint*)ptr));\n+      break;\n+    case ltos:\n+      new_value_h()->long_field_put(offset, *(jlong*)ptr);\n+      break;\n+    case ftos:\n+      new_value_h()->float_field_put(offset, *(jfloat*)ptr);\n+      break;\n+    case dtos:\n+      new_value_h()->double_field_put(offset, *(jdouble*)ptr);\n+      break;\n+    case atos:\n+      {\n+        if (cpe->is_null_free_inline_type())  {\n+          if (!cpe->is_inlined()) {\n+              if (ref_h() == NULL) {\n+                THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n+              }\n+              new_value_h()->obj_field_put(offset, ref_h());\n+            } else {\n+              int field_index = cpe->field_index();\n+              InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(field_index));\n+              field_ik->write_inlined_field(new_value_h(), offset, ref_h(), CHECK_(ret_adj));\n+            }\n+        } else {\n+          new_value_h()->obj_field_put(offset, ref_h());\n+        }\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  current->set_vm_result(new_value_h());\n+  return ret_adj;\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":77,"deletions":1,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+  static int     withfield2     (JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -973,0 +973,14 @@\n+  if (byte == Bytecodes::_withfield && !resolved_klass->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    char msg[200];\n+    jio_snprintf(msg, sizeof(msg), \"Bytecode withfield cannot be used on identity class %s\", resolved_klass->external_name());\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+  }\n+\n+  if (is_put && !is_static && byte != Bytecodes::_withfield && resolved_klass->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    char msg[200];\n+    jio_snprintf(msg, sizeof(msg), \"Bytecode putfield cannot be used on primitive class %s\", resolved_klass->external_name());\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+  }\n+\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,0 +62,5 @@\n+        Point (int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n@@ -81,0 +86,120 @@\n+    static primitive class TestValue {\n+        boolean z = false;\n+        static boolean[] z_values = new boolean[] { false, true, false};\n+        byte b = 0;\n+        static byte[] b_values = new byte[] { 0, 125, -111};\n+        short s = 0;\n+        static short[] s_values = new short[] { 0, 32654, -31836};\n+        char c = 0;\n+        static char[] c_values = new char[] { 0, 1, 65528};\n+        int i = 0;\n+        static int[] i_values = new int[] { 0, 2137523847, -2037453241};\n+        long l = 0;\n+        static long[] l_values = new long[] { 0, 9123456036854775807L, -9112272036854775507L};\n+        float f = 0.0f;\n+        static float[] f_values = new float[] { 0.0f, 1.52758043e7f, -7.93757e-5f};\n+        double d = 0.0d;\n+        static double[] d_values = new double[] { 0.0d, 3.304786e9d, -0.7548345e-15d};\n+        Object o = null;\n+        static Object[] o_values = new Object[] { null, \"Hello\", \"Duke\"};\n+        Point p = new Point(0, 0);\n+        static Point[] p_values = new Point[] { new Point(0, 0), new Point(-1, 1), new Point(1, -1)};\n+        int[] map = new int[10];\n+\n+        TestValue set_z(int i) {\n+            TestValue t = __WithField(this.z, z_values[i]);\n+            t.map[0] = i;\n+            return t;\n+        }\n+\n+        TestValue set_b(int i) {\n+            TestValue t = __WithField(this.b, b_values[i]);\n+            t.map[1] = i;\n+            return t;\n+        }\n+\n+        TestValue set_s(int i) {\n+            TestValue t = __WithField(this.s, s_values[i]);\n+            t.map[2] = i;\n+            return t;\n+        }\n+\n+        TestValue set_c(int i) {\n+            TestValue t = __WithField(this.c, c_values[i]);\n+            t.map[3] = i;\n+            return t;\n+        }\n+\n+        TestValue set_i(int i) {\n+            TestValue t = __WithField(this.i, i_values[i]);\n+            t.map[4] = i;\n+            return t;\n+        }\n+\n+        TestValue set_l(int i) {\n+            TestValue t = __WithField(this.l, l_values[i]);\n+            t.map[5] = i;\n+            return t;\n+        }\n+\n+        TestValue set_f(int i) {\n+            TestValue t = __WithField(this.f, f_values[i]);\n+            t.map[6] = i;\n+            return t;\n+        }\n+\n+        TestValue set_d(int i) {\n+            TestValue t = __WithField(this.d, d_values[i]);\n+            t.map[7] = i;\n+            return t;\n+        }\n+\n+        TestValue set_o(int i) {\n+            TestValue t = __WithField(this.o, o_values[i]);\n+            t.map[8] = i;\n+            return t;\n+        }\n+\n+        TestValue set_p(int i) {\n+            TestValue t = __WithField(this.p, p_values[i]);\n+            t.map[9] = i;\n+            return t;\n+        }\n+\n+        void verify() {\n+            Asserts.assertEquals(z, z_values[map[0]]);\n+            Asserts.assertEquals(b, b_values[map[1]]);\n+            Asserts.assertEquals(s, s_values[map[2]]);\n+            Asserts.assertEquals(c, c_values[map[3]]);\n+            Asserts.assertEquals(i, i_values[map[4]]);\n+            Asserts.assertEquals(l, l_values[map[5]]);\n+            Asserts.assertEquals(f, f_values[map[6]]);\n+            Asserts.assertEquals(d, d_values[map[7]]);\n+            Asserts.assertEquals(o, o_values[map[8]]);\n+            Asserts.assertEquals(p, p_values[map[9]]);\n+        }\n+\n+        static void test() {\n+            TestValue value = new TestValue();\n+            value.verify();\n+            for (int i = 2; i >= 0; i--) {\n+                value = value.set_z(i);\n+                value.verify();\n+                value = value.set_b(i);\n+                value.verify();\n+                value = value.set_s(i);\n+                value.verify();\n+                value = value.set_c(i);\n+                value.verify();\n+                value = value.set_i(i);\n+                value.verify();\n+                value = value.set_l(i);\n+                value.verify();\n+                value = value.set_f(i);\n+                value.verify();\n+                value = value.set_d(i);\n+                value.verify();\n+            }\n+        }\n+    }\n+\n@@ -86,0 +211,1 @@\n+        TestValue.test();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/VWithFieldTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"modified"}]}