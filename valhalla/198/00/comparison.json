{"files":[{"patch":"@@ -241,0 +241,1 @@\n+         stub_id == Runtime1::new_instance_no_inline_id       ||\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1291,5 +1291,6 @@\n-                       FrameMap::rcx_oop_opr,\n-                       FrameMap::rdi_oop_opr,\n-                       FrameMap::rsi_oop_opr,\n-                       LIR_OprFact::illegalOpr,\n-                       FrameMap::rdx_metadata_opr, info);\n+               \/* allow_inline *\/ false,\n+               FrameMap::rcx_oop_opr,\n+               FrameMap::rdi_oop_opr,\n+               FrameMap::rsi_oop_opr,\n+               LIR_OprFact::illegalOpr,\n+               FrameMap::rdx_metadata_opr, info);\n@@ -1305,6 +1306,7 @@\n-  new_instance(reg, x->klass(), x->is_unresolved(),\n-             FrameMap::rcx_oop_opr,\n-             FrameMap::rdi_oop_opr,\n-             FrameMap::rsi_oop_opr,\n-             LIR_OprFact::illegalOpr,\n-             FrameMap::rdx_metadata_opr, info);\n+  new_instance(reg, x->klass(), false,\n+               \/* allow_inline *\/ true,\n+               FrameMap::rcx_oop_opr,\n+               FrameMap::rdi_oop_opr,\n+               FrameMap::rsi_oop_opr,\n+               LIR_OprFact::illegalOpr,\n+               FrameMap::rdx_metadata_opr, info);\n@@ -1313,1 +1315,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1019,0 +1019,1 @@\n+    case new_instance_no_inline_id:\n@@ -1027,0 +1028,2 @@\n+        } else if (id == new_instance_no_inline_id) {\n+          __ set_info(\"new_instance_no_inline\", dont_gc_arguments);\n@@ -1091,1 +1094,6 @@\n-        int call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);\n+        int call_offset;\n+        if (id == new_instance_no_inline_id) {\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance_no_inline), klass);\n+        } else {\n+          call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);\n+        }\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1045,1 +1045,1 @@\n-      NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before, false);\n+      NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before);\n@@ -1757,0 +1757,2 @@\n+  assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+  assert(vk->nof_nonstatic_fields() > 0, \"Empty inline type access should be removed\");\n@@ -1779,1 +1781,1 @@\n-                              PatchALot;\n+                              (!field->is_flattened() && PatchALot);\n@@ -1798,1 +1800,1 @@\n-  if (field->is_final() && (code == Bytecodes::_putfield || code == Bytecodes::_withfield)) {\n+  if (field->is_final() && code == Bytecodes::_putfield) {\n@@ -1802,1 +1804,1 @@\n-  if (code == Bytecodes::_putfield || code == Bytecodes::_withfield) {\n+  if (code == Bytecodes::_putfield) {\n@@ -1819,0 +1821,3 @@\n+      } else if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+        \/\/ Loading from a field of an empty inline type. Just return the default instance.\n+        constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n@@ -1842,0 +1847,4 @@\n+      if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+        \/\/ Storing to a field of an empty inline type. Ignore.\n+        break;\n+      }\n@@ -1856,1 +1865,5 @@\n-        if (field->is_constant() && !field->is_flattened() && obj_type->is_constant() && !PatchALot) {\n+        if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+          \/\/ Loading from a field of an empty inline type. Just return the default instance.\n+          null_check(obj);\n+          constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+        } else if (field->is_constant() && !field->is_flattened() && obj_type->is_constant() && !PatchALot) {\n@@ -1888,0 +1901,1 @@\n+            assert(!needs_patching, \"Can't patch delayed field access\");\n@@ -1893,0 +1907,1 @@\n+            assert(!needs_patching, \"Can't patch delayed field access\");\n@@ -1907,2 +1922,1 @@\n-            BasicType bt = field->type()->basic_type();\n-            switch (bt) {\n+            switch (field_type) {\n@@ -1911,1 +1925,1 @@\n-              replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));\n+              replacement = append(new Convert(Bytecodes::_i2b, replacement, type));\n@@ -1914,1 +1928,1 @@\n-              replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));\n+              replacement = append(new Convert(Bytecodes::_i2c, replacement, type));\n@@ -1917,1 +1931,1 @@\n-              replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));\n+              replacement = append(new Convert(Bytecodes::_i2s, replacement, type));\n@@ -1927,0 +1941,2 @@\n+          \/\/ Look at the next bytecode to check if we can delay the field access\n+          bool can_delay_access = false;\n@@ -1931,0 +1947,7 @@\n+            ciField* next_field = s.get_field(will_link);\n+            bool next_needs_patching = !next_field->holder()->is_loaded() ||\n+                                       !next_field->will_link(method(), code) ||\n+                                       PatchALot;\n+            can_delay_access = !next_needs_patching;\n+          }\n+          if (can_delay_access) {\n@@ -1941,1 +1964,0 @@\n-            assert(field->type()->is_inlinetype(), \"Sanity check\");\n@@ -1943,1 +1965,0 @@\n-            assert(field->type()->is_inlinetype(), \"Sanity check\");\n@@ -1947,0 +1968,1 @@\n+              assert(!needs_patching, \"Can't patch delayed field access\");\n@@ -1948,2 +1970,1 @@\n-              NewInlineTypeInstance* vt = new NewInlineTypeInstance(field->type()->as_inline_klass(),\n-                                                                    pending_load_indexed()->state_before(), false);\n+              NewInlineTypeInstance* vt = new NewInlineTypeInstance(inline_klass, pending_load_indexed()->state_before());\n@@ -1956,1 +1977,1 @@\n-              NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before, false);\n+              NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before);\n@@ -1967,1 +1988,1 @@\n-                            state_before, needs_patching);\n+                                    state_before, needs_patching);\n@@ -1975,1 +1996,0 @@\n-    case Bytecodes::_withfield:\n@@ -1983,1 +2003,1 @@\n-      if (field->type()->basic_type() == T_BOOLEAN) {\n+      if (field_type == T_BOOLEAN) {\n@@ -1987,2 +2007,4 @@\n-\n-      if (!field->is_flattened()) {\n+      if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+        \/\/ Storing to a field of an empty inline type. Ignore.\n+        null_check(obj);\n+      } else if (!field->is_flattened()) {\n@@ -1995,1 +2017,0 @@\n-        assert(field->type()->is_inlinetype(), \"Sanity check\");\n@@ -1997,3 +2018,1 @@\n-        int flattening_offset = field->offset() - inline_klass->first_field_offset();\n-        copy_inline_content(inline_klass, val, inline_klass->first_field_offset(), obj, field->offset(),\n-                   state_before, needs_patching);\n+        copy_inline_content(inline_klass, val, inline_klass->first_field_offset(), obj, offset, state_before, needs_patching);\n@@ -2023,1 +2042,0 @@\n-\n@@ -2029,0 +2047,1 @@\n+  ValueStack* state_before = copy_state_before();\n@@ -2032,1 +2051,0 @@\n-    ValueStack* state_before = copy_state_before();\n@@ -2038,1 +2056,0 @@\n-  ValueStack* state_before = copy_state_before();\n@@ -2051,1 +2068,1 @@\n-    new_instance = new NewInlineTypeInstance(holder->as_inline_klass(), state_before, false);\n+    new_instance = new NewInlineTypeInstance(holder->as_inline_klass(), state_before);\n@@ -2061,2 +2078,0 @@\n-          assert(field->type()->is_inlinetype(), \"Sanity check\");\n-          assert(field->type()->is_inlinetype(), \"Only inline types can be flattened\");\n@@ -2082,1 +2097,0 @@\n-    assert(field_modify->type()->is_inlinetype(), \"Only inline types can be flattened\");\n@@ -2460,1 +2474,0 @@\n-  assert(!klass->is_inlinetype(), \"must not be an inline klass\");\n@@ -2468,2 +2481,3 @@\n-  if (!stream()->is_unresolved_klass()) {\n-    ciInlineKlass* vk = stream()->get_klass(will_link)->as_inline_klass();\n+  ciKlass* klass = stream()->get_klass(will_link);\n+  if (!stream()->is_unresolved_klass() && klass->is_inlinetype()) {\n+    ciInlineKlass* vk = klass->as_inline_klass();\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":48,"deletions":34,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -310,9 +310,0 @@\n-Value NewInlineTypeInstance::depends_on() {\n-  if (_depends_on != this) {\n-    if (_depends_on->as_NewInlineTypeInstance() != NULL) {\n-      return _depends_on->as_NewInlineTypeInstance()->depends_on();\n-    }\n-  }\n-  return _depends_on;\n-}\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1389,1 +1389,0 @@\n-  bool _is_unresolved;\n@@ -1391,2 +1390,0 @@\n-  Value _depends_on;      \/\/ Link to instance on with withfield was called on\n-  bool _is_optimizable_for_withfield;\n@@ -1399,1 +1396,1 @@\n-  NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)\n+  NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before)\n@@ -1401,1 +1398,0 @@\n-   , _is_unresolved(is_unresolved)\n@@ -1403,1 +1399,0 @@\n-   , _is_optimizable_for_withfield(from_default_value)\n@@ -1408,5 +1403,0 @@\n-    if (depends_on == NULL) {\n-      _depends_on = this;\n-    } else {\n-      _depends_on = depends_on;\n-    }\n@@ -1417,3 +1407,0 @@\n-  bool is_unresolved() const                     { return _is_unresolved; }\n-  Value depends_on();\n-\n@@ -1421,1 +1408,0 @@\n-\n@@ -1432,4 +1418,0 @@\n-  \/\/ withfield optimization\n-  virtual void set_escaped() {\n-    _is_optimizable_for_withfield = false;\n-  }\n@@ -1462,1 +1444,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -676,4 +676,9 @@\n-void LIRGenerator::new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info) {\n-  klass2reg_with_patching(klass_reg, klass, info, is_unresolved);\n-  \/\/ If klass is not loaded we do not know if the klass has finalizers:\n-  if (UseFastNewInstance && klass->is_loaded()\n+void LIRGenerator::new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, bool allow_inline, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info) {\n+  if (allow_inline) {\n+    assert(!is_unresolved && klass->is_loaded(), \"inline type klass should be resolved\");\n+    __ metadata2reg(klass->constant_encoding(), klass_reg);\n+  } else {\n+    klass2reg_with_patching(klass_reg, klass, info, is_unresolved);\n+  }\n+  \/\/ If klass is not loaded we do not know if the klass has finalizers or is an unexpected inline klass\n+  if (UseFastNewInstance && klass->is_loaded() && (allow_inline || !klass->is_inlinetype())\n@@ -693,2 +698,2 @@\n-    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);\n-    __ branch(lir_cond_always, slow_path);\n+    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, allow_inline ? Runtime1::new_instance_id : Runtime1::new_instance_no_inline_id);\n+    __ jump(slow_path);\n@@ -1554,0 +1559,5 @@\n+  if (!inline_type_field_access_prolog(x, info)) {\n+    \/\/ Field store will always deopt due to unloaded field or holder klass\n+    return;\n+  }\n+\n@@ -1557,16 +1567,4 @@\n-    if (needs_patching && x->field()->signature()->is_Q_signature()) {\n-      \/\/ We are storing a field of type \"QT;\" into holder class H, but H is not yet\n-      \/\/ loaded. (If H had been loaded, then T must also have already been loaded\n-      \/\/ due to the \"Q\" signature, and needs_patching would be false).\n-      assert(!x->field()->holder()->is_loaded(), \"must be\");\n-      \/\/ We don't know the offset of this field. Let's deopt and recompile.\n-      CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),\n-                                          Deoptimization::Reason_unloaded,\n-                                          Deoptimization::Action_make_not_entrant);\n-      __ branch(lir_cond_always, stub);\n-    } else {\n-      \/\/ Emit an explicit null check because the offset is too large.\n-      \/\/ If the class is not loaded and the object is NULL, we need to deoptimize to throw a\n-      \/\/ NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.\n-      __ null_check(object.result(), new CodeEmitInfo(info), \/* deoptimize *\/ needs_patching);\n-    }\n+    \/\/ Emit an explicit null check because the offset is too large.\n+    \/\/ If the class is not loaded and the object is NULL, we need to deoptimize to throw a\n+    \/\/ NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.\n+    __ null_check(object.result(), new CodeEmitInfo(info), \/* deoptimize *\/ needs_patching);\n@@ -1650,1 +1648,0 @@\n-  Constant* default_value = NULL;\n@@ -1653,3 +1650,0 @@\n-    default_value = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n-  }\n-  if (default_value != NULL) {\n@@ -1660,0 +1654,1 @@\n+    Constant* default_value = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n@@ -1947,1 +1942,1 @@\n-Constant* LIRGenerator::flattened_field_load_prolog(LoadField* x, CodeEmitInfo* info) {\n+bool LIRGenerator::inline_type_field_access_prolog(AccessField* x, CodeEmitInfo* info) {\n@@ -1949,42 +1944,14 @@\n-  ciInstanceKlass* holder = field->holder();\n-  Constant* default_value = NULL;\n-\n-  \/\/ Unloaded \"QV;\" klasses are represented by a ciInstanceKlass\n-  bool field_type_unloaded = field->type()->is_instance_klass() && !field->type()->as_instance_klass()->is_loaded();\n-\n-  \/\/ Check for edge cases (1), (2) and (3) for getstatic and getfield\n-  bool deopt = false;\n-  bool need_default = false;\n-  if (field->is_static()) {\n-      \/\/ (1) holder is unloaded -- no problem: it will be loaded by patching, and field offset will be determined.\n-      \/\/ No check needed here.\n-\n-    if (field_type_unloaded) {\n-      \/\/ (2) field type is unloaded -- problem: we don't know what the default value is. Let's deopt.\n-      \/\/                               FIXME: consider getting the default value in patching code.\n-      deopt = true;\n-    } else {\n-      need_default = true;\n-    }\n-\n-      \/\/ (3) field is not flattened -- we don't care: static fields are never flattened.\n-      \/\/ No check needed here.\n-  } else {\n-    if (!holder->is_loaded()) {\n-      \/\/ (1) holder is unloaded -- problem: we needed the field offset back in GraphBuilder::access_field()\n-      \/\/                           FIXME: consider getting field offset in patching code (but only if the field\n-      \/\/                           type was loaded at compilation time).\n-      deopt = true;\n-    } else if (field_type_unloaded) {\n-      \/\/ (2) field type is unloaded -- problem: we don't know whether it's flattened or not. Let's deopt\n-      deopt = true;\n-    } else if (!field->is_flattened()) {\n-      \/\/ (3) field is not flattened -- need default value in cases of uninitialized field\n-      need_default = true;\n-    }\n-  }\n-\n-  if (deopt) {\n-    assert(!need_default, \"deopt and need_default cannot both be true\");\n-    assert(x->needs_patching(), \"must be\");\n-    assert(info != NULL, \"must be\");\n+  assert(!field->is_flattened(), \"Flattened field access should have been expanded\");\n+  if (!field->signature()->is_Q_signature()) {\n+    return true; \/\/ Not an inline type field\n+  }\n+  \/\/ Deoptimize if the access is non-static and requires patching (holder not loaded\n+  \/\/ or not accessible) because then we only have partial field information and the\n+  \/\/ field could be flattened (see ciField constructor).\n+  bool could_be_flat = !x->is_static() && x->needs_patching();\n+  \/\/ Deoptimize if we load from a static field with an unloaded type because we need\n+  \/\/ the default value if the field is null.\n+  bool could_be_null = x->is_static() && x->as_LoadField() != NULL && !field->type()->is_loaded();\n+  assert(!could_be_null || !field->holder()->is_loaded(), \"inline type field should be loaded\");\n+  if (could_be_flat || could_be_null) {\n+    assert(x->needs_patching(), \"no deopt required\");\n@@ -1994,22 +1961,2 @@\n-    __ branch(lir_cond_always, stub);\n-  } else if (need_default) {\n-    assert(!field_type_unloaded, \"must be\");\n-    assert(field->type()->is_inlinetype(), \"must be\");\n-    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n-    assert(inline_klass->is_loaded(), \"must be\");\n-\n-    if (field->is_static() && holder->is_loaded()) {\n-      ciInstance* mirror = field->holder()->java_mirror();\n-      ciObject* val = mirror->field_value(field).as_object();\n-      if (val->is_null_object()) {\n-        \/\/ This is a non-nullable static field, but it's not initialized.\n-        \/\/ We need to do a null check, and replace it with the default value.\n-      } else {\n-        \/\/ No need to perform null check on this static field\n-        need_default = false;\n-      }\n-    }\n-\n-    if (need_default) {\n-      default_value = new Constant(new InstanceConstant(inline_klass->default_instance()));\n-    }\n+    __ jump(stub);\n+    return false;\n@@ -2017,2 +1964,1 @@\n-\n-  return default_value;\n+  return true;\n@@ -2050,3 +1996,5 @@\n-  Constant* default_value = NULL;\n-  if (x->field()->signature()->is_Q_signature()) {\n-    default_value = flattened_field_load_prolog(x, info);\n+  if (!inline_type_field_access_prolog(x, info)) {\n+    \/\/ Field load will always deopt due to unloaded field or holder klass\n+    LIR_Opr result = rlock_result(x, field_type);\n+    __ move(LIR_OprFact::oopConst(NULL), result);\n+    return;\n@@ -2084,1 +2032,15 @@\n-  if (default_value != NULL) {\n+  ciField* field = x->field();\n+  if (field->signature()->is_Q_signature()) {\n+    \/\/ Load from non-flattened inline type field requires\n+    \/\/ a null check to replace null with the default value.\n+    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n+    assert(inline_klass->is_loaded(), \"field klass must be loaded\");\n+\n+    ciInstanceKlass* holder = field->holder();\n+    if (field->is_static() && holder->is_loaded()) {\n+      ciObject* val = holder->java_mirror()->field_value(field).as_object();\n+      if (!val->is_null_object()) {\n+        \/\/ Static field is initialized, we don need to perform a null check.\n+        return;\n+      }\n+    }\n@@ -2089,0 +2051,1 @@\n+    Constant* default_value = new Constant(new InstanceConstant(inline_klass->default_instance()));\n@@ -2280,1 +2243,1 @@\n-  __ branch(lir_cond_always, stub);\n+  __ jump(stub);\n@@ -2291,1 +2254,1 @@\n-  __ branch(lir_cond_always, stub);\n+  __ jump(stub);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":62,"deletions":99,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-  Constant* flattened_field_load_prolog(LoadField* x, CodeEmitInfo* info);\n+  bool inline_type_field_access_prolog(AccessField* x, CodeEmitInfo* info);\n@@ -382,1 +382,1 @@\n-  void new_instance    (LIR_Opr  dst, ciInstanceKlass* klass, bool is_unresolved, LIR_Opr  scratch1, LIR_Opr  scratch2, LIR_Opr  scratch3,  LIR_Opr scratch4, LIR_Opr  klass_reg, CodeEmitInfo* info);\n+  void new_instance(LIR_Opr dst, ciInstanceKlass* klass, bool is_unresolved, bool allow_inline, LIR_Opr scratch1, LIR_Opr scratch2, LIR_Opr scratch3, LIR_Opr scratch4, LIR_Opr klass_reg, CodeEmitInfo* info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,4 +363,1 @@\n-\n-JRT_ENTRY(void, Runtime1::new_instance(JavaThread* thread, Klass* klass))\n-  NOT_PRODUCT(_new_instance_slowcase_cnt++;)\n-\n+static void allocate_instance(JavaThread* thread, Klass* klass, TRAPS) {\n@@ -376,0 +373,5 @@\n+}\n+\n+JRT_ENTRY(void, Runtime1::new_instance(JavaThread* thread, Klass* klass))\n+  NOT_PRODUCT(_new_instance_slowcase_cnt++;)\n+  allocate_instance(thread, klass, CHECK);\n@@ -378,0 +380,9 @@\n+\/\/ Same as new_instance but throws error for inline klasses\n+JRT_ENTRY(void, Runtime1::new_instance_no_inline(JavaThread* thread, Klass* klass))\n+  NOT_PRODUCT(_new_instance_slowcase_cnt++;)\n+  if (klass->is_inline_klass()) {\n+    SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_InstantiationError());\n+  } else {\n+    allocate_instance(thread, klass, CHECK);\n+  }\n+JRT_END\n@@ -1018,0 +1029,1 @@\n+    assert(!result.is_inlined(), \"Can not patch access to flattened field\");\n@@ -1587,1 +1599,1 @@\n-  tty->print_cr(\" _new_flat_array_slowcase_cnt:   %d\", _new_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _new_flat_array_slowcase_cnt:    %d\", _new_flat_array_slowcase_cnt);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  stub(new_instance_no_inline)       \\\n@@ -157,0 +158,1 @@\n+  static void new_instance_no_inline(JavaThread* thread, Klass* klass);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-            return NamedRectangle.getP1X(new NamedRectangle());\n+        return NamedRectangle.getP1X(new NamedRectangle());\n@@ -104,2 +104,2 @@\n-            int res = test1();\n-            Asserts.assertEQ(res, 4);\n+        int res = test1();\n+        Asserts.assertEQ(res, 4);\n@@ -111,1 +111,1 @@\n-            return NamedRectangle.getP1(new NamedRectangle());\n+        return NamedRectangle.getP1(new NamedRectangle());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3337,2 +3337,0 @@\n-    \/\/ TODO Disabled until JDK-8253416 is fixed\n-    \/*\n@@ -3374,1 +3372,0 @@\n-    *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @bug 8253416\n+ * @summary Test nestmate access to flattened field if nest-host is not loaded.\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.valhalla.inlinetypes.Test*::<init>\n+ *                   compiler.valhalla.inlinetypes.TestNestmateAccess\n+ * @run main\/othervm -Xcomp -XX:TieredStopAtLevel=1\n+ *                   -XX:CompileCommand=compileonly,compiler.valhalla.inlinetypes.Test*::<init>\n+ *                   compiler.valhalla.inlinetypes.TestNestmateAccess\n+ *\/\n+\n+interface MyInterface {\n+    int hash();\n+}\n+\n+inline class MyValue implements MyInterface {\n+    int x = 42;\n+    int y = 43;\n+\n+    @Override\n+    public int hash() { return x + y; }\n+}\n+\n+\/\/ Test load from flattened field in nestmate when nest-host is not loaded.\n+class Test1 {\n+    private MyValue vt;\n+\n+    public Test1(final MyValue vt) {\n+        this.vt = vt;\n+    }\n+\n+    public MyInterface test() {\n+        return new MyInterface() {\n+            \/\/ The vt field load does not link.\n+            private int x = (Test1.this).vt.hash();\n+\n+            @Override\n+            public int hash() { return x; }\n+        };\n+    }\n+}\n+\n+\/\/ Same as Test1 but outer class is an inline type\n+inline class Test2 {\n+    private MyValue vt;\n+\n+    public Test2(final MyValue vt) {\n+        this.vt = vt;\n+    }\n+\n+    public MyInterface test() {\n+        return new MyInterface() {\n+            \/\/ Delayed flattened load of Test2.this.\n+            \/\/ The vt field load does not link.\n+            private int x = (Test2.this).vt.hash();\n+\n+            @Override\n+            public int hash() { return x; }\n+        };\n+    }\n+}\n+\n+\/\/ Test store to flattened field in nestmate when nest-host is not loaded.\n+class Test3 {\n+    private MyValue vt;\n+\n+    public MyInterface test(MyValue init) {\n+        return new MyInterface() {\n+            \/\/ Store to the vt field does not link.\n+            private MyValue tmp = (vt = init);\n+\n+            @Override\n+            public int hash() { return tmp.hash() + vt.hash(); }\n+        };\n+    }\n+}\n+\n+\/\/ Same as Test1 but with static field\n+class Test4 {\n+    private static MyValue vt;\n+\n+    public Test4(final MyValue vt) {\n+        this.vt = vt;\n+    }\n+\n+    public MyInterface test() {\n+        return new MyInterface() {\n+            \/\/ The vt field load does not link.\n+            private int x = (Test4.this).vt.hash();\n+\n+            @Override\n+            public int hash() { return x; }\n+        };\n+    }\n+}\n+\n+\/\/ Same as Test2 but with static field\n+inline class Test5 {\n+    private static MyValue vt;\n+\n+    public Test5(final MyValue vt) {\n+        this.vt = vt;\n+    }\n+\n+    public MyInterface test() {\n+        return new MyInterface() {\n+            \/\/ Delayed flattened load of Test5.this.\n+            \/\/ The vt field load does not link.\n+            private int x = (Test5.this).vt.hash();\n+\n+            @Override\n+            public int hash() { return x; }\n+        };\n+    }\n+}\n+\n+\/\/ Same as Test3 but with static field\n+class Test6 {\n+    private static MyValue vt;\n+\n+    public MyInterface test(MyValue init) {\n+        return new MyInterface() {\n+            \/\/ Store to the vt field does not link.\n+            private MyValue tmp = (vt = init);\n+\n+            @Override\n+            public int hash() { return tmp.hash() + vt.hash(); }\n+        };\n+    }\n+}\n+\n+\/\/ Same as Test6 but outer class is an inline type\n+inline class Test7 {\n+    private static MyValue vt;\n+\n+    public MyInterface test(MyValue init) {\n+        return new MyInterface() {\n+            \/\/ Store to the vt field does not link.\n+            private MyValue tmp = (vt = init);\n+\n+            @Override\n+            public int hash() { return tmp.hash() + vt.hash(); }\n+        };\n+    }\n+}\n+\n+public class TestNestmateAccess {\n+\n+    public static void main(String[] args) {\n+        Test1 t1 = new Test1(new MyValue());\n+        int res = t1.test().hash();\n+        Asserts.assertEQ(res, 85);\n+\n+        Test2 t2 = new Test2(new MyValue());\n+        res = t2.test().hash();\n+        Asserts.assertEQ(res, 85);\n+\n+        Test3 t3 = new Test3();\n+        res = t3.test(new MyValue()).hash();\n+        Asserts.assertEQ(res, 170);\n+\n+        Test4 t4 = new Test4(new MyValue());\n+        res = t4.test().hash();\n+        Asserts.assertEQ(res, 85);\n+\n+        Test5 t5 = new Test5(new MyValue());\n+        res = t5.test().hash();\n+        Asserts.assertEQ(res, 85);\n+\n+        Test6 t6 = new Test6();\n+        res = t6.test(new MyValue()).hash();\n+        Asserts.assertEQ(res, 170);\n+\n+        Test7 t7 = new Test7();\n+        res = t7.test(new MyValue()).hash();\n+        Asserts.assertEQ(res, 170);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNestmateAccess.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -42,0 +42,6 @@\n+    \/\/ Only prevent loading of classes when testing with C1. Load classes\n+    \/\/ early when executing with C2 to prevent uncommon traps. It's still\n+    \/\/ beneficial to execute this test with C2 because it also checks handling\n+    \/\/ of type mismatches.\n+    private static final boolean PREVENT_LOADING = TEST_C1;\n+\n@@ -49,1 +55,3 @@\n-        {\"-XX:InlineFieldMaxFlatSize=0\"}\n+        {\"-XX:InlineFieldMaxFlatSize=0\"},\n+        {\"-XX:+PatchALot\"},\n+        {\"-XX:InlineFieldMaxFlatSize=0\", \"-XX:+PatchALot\"}\n@@ -75,1 +83,1 @@\n-            foo = 1234;\n+            foo = rI;\n@@ -92,1 +100,1 @@\n-    public int test1(MyValue1Holder holder) {\n+    public int test1(Object holder) {\n@@ -94,1 +102,2 @@\n-            return holder.v.foo + 1;\n+            \/\/ Don't use MyValue1Holder in the signature, it might trigger class loading\n+            return ((MyValue1Holder)holder).v.foo;\n@@ -100,0 +109,1 @@\n+    @DontCompile\n@@ -101,1 +111,1 @@\n-        if (warmup) {\n+        if (warmup && PREVENT_LOADING) {\n@@ -105,1 +115,1 @@\n-            Asserts.assertEQ(test1(holder), 1235);\n+            Asserts.assertEQ(test1(holder), rI);\n@@ -113,1 +123,1 @@\n-    \/\/     getfield  MyValueHolder2.v:QMyValue2;\n+    \/\/     getfield  MyValue2Holder.v:QMyValue2;\n@@ -130,1 +140,1 @@\n-            v = new MyValue2(1234);\n+            v = new MyValue2(rI);\n@@ -134,1 +144,0 @@\n-\n@@ -136,1 +145,1 @@\n-    public int test2(MyValue2Holder holder) {\n+    public int test2(Object holder) {\n@@ -138,1 +147,2 @@\n-            return holder.v.foo + 2;\n+            \/\/ Don't use MyValue2Holder in the signature, it might trigger class loading\n+            return ((MyValue2Holder)holder).v.foo;\n@@ -144,0 +154,1 @@\n+    @DontCompile\n@@ -145,1 +156,1 @@\n-        if (warmup) {\n+        if (warmup && PREVENT_LOADING) {\n@@ -148,2 +159,2 @@\n-            MyValue2Holder holder2 = new MyValue2Holder();\n-            Asserts.assertEQ(test2(holder2), 1236);\n+            MyValue2Holder holder = new MyValue2Holder();\n+            Asserts.assertEQ(test2(holder), rI);\n@@ -159,1 +170,1 @@\n-    \/\/     getfield  MyValueHolder3.v:LMyValue3;\n+    \/\/     getfield  MyValue3Holder.v:LMyValue3;\n@@ -170,1 +181,1 @@\n-            foo = 1234;\n+            foo = rI;\n@@ -187,1 +198,2 @@\n-    public int test3(MyValue3Holder holder) {\n+    public int test3(Object holder) {\n+        \/\/ Don't use MyValue3Holder in the signature, it might trigger class loading\n@@ -191,0 +203,1 @@\n+    @DontCompile\n@@ -192,1 +205,1 @@\n-        if (warmup) {\n+        if (warmup && PREVENT_LOADING) {\n@@ -195,6 +208,9 @@\n-            MyValue3Holder holder = new MyValue3Holder();\n-            try {\n-                test3(holder);\n-                Asserts.fail(\"Should have thrown NoSuchFieldError\");\n-            } catch (NoSuchFieldError e) {\n-                \/\/ OK\n+            \/\/ Make sure klass is resolved\n+            for (int i = 0; i < 10; ++i) {\n+                MyValue3Holder holder = new MyValue3Holder();\n+                try {\n+                    test3(holder);\n+                    Asserts.fail(\"Should have thrown NoSuchFieldError\");\n+                } catch (NoSuchFieldError e) {\n+                    \/\/ OK\n+                }\n@@ -223,4 +239,0 @@\n-    static MyValue4 test4_precondition() {\n-        return new MyValue4(0);\n-    }\n-\n@@ -228,1 +240,1 @@\n-    public void test4(MyValue4Holder holder, MyValue4 v) {\n+    public void test4(Object holder, MyValue4 v) {\n@@ -230,1 +242,2 @@\n-            holder.v = v;\n+            \/\/ Don't use MyValue4Holder in the signature, it might trigger class loading\n+            ((MyValue4Holder)holder).v = v;\n@@ -234,0 +247,1 @@\n+    @DontCompile\n@@ -235,2 +249,2 @@\n-        MyValue4 v = new MyValue4(5678);\n-        if (warmup) {\n+        MyValue4 v = new MyValue4(rI);\n+        if (warmup && PREVENT_LOADING) {\n@@ -241,1 +255,1 @@\n-            Asserts.assertEQ(holder.v.foo, 5678);\n+            Asserts.assertEQ(holder.v.foo, rI);\n@@ -261,0 +275,1 @@\n+\n@@ -267,1 +282,1 @@\n-    public void test5(MyValue5Holder holder, Object o) {\n+    public void test5(Object holder, Object o) {\n@@ -269,0 +284,1 @@\n+            \/\/ Don't use MyValue5 and MyValue5Holder in the signature, it might trigger class loading\n@@ -270,1 +286,1 @@\n-            holder.v = v;\n+            ((MyValue5Holder)holder).v = v;\n@@ -274,0 +290,1 @@\n+    @DontCompile\n@@ -275,1 +292,1 @@\n-        if (warmup) {\n+        if (warmup && PREVENT_LOADING) {\n@@ -279,1 +296,1 @@\n-            Object v = holder.make(5679);\n+            Object v = holder.make(rI);\n@@ -281,1 +298,1 @@\n-            Asserts.assertEQ(holder.v.foo, 5679);\n+            Asserts.assertEQ(holder.v.foo, rI);\n@@ -286,1 +303,1 @@\n-    \/\/ Test case 11: (same as test1, except we use getstatic instead of getfield)\n+    \/\/ Test case 6: (same as test1, except we use getstatic instead of getfield)\n@@ -289,1 +306,1 @@\n-    \/\/     getstatic  MyValue11Holder.v:QMyValue1;\n+    \/\/     getstatic  MyValue6Holder.v:QMyValue1;\n@@ -292,1 +309,1 @@\n-    \/\/ MyValue11 has already been loaded, because it's in the InlineType attribute of\n+    \/\/ MyValue6 has already been loaded, because it's in the InlineType attribute of\n@@ -294,1 +311,1 @@\n-    static final inline class MyValue11 {\n+    static final inline class MyValue6 {\n@@ -297,2 +314,2 @@\n-        MyValue11() {\n-            foo = 1234;\n+        MyValue6() {\n+            foo = rI;\n@@ -302,2 +319,2 @@\n-    static class MyValue11Holder {\n-        static MyValue11 v = new MyValue11();\n+    static class MyValue6Holder {\n+        static MyValue6 v = new MyValue6();\n@@ -306,2 +323,2 @@\n-    static MyValue11 test11_precondition() {\n-        return new MyValue11();\n+    static MyValue6 test6_precondition() {\n+        return new MyValue6();\n@@ -311,1 +328,1 @@\n-    public int test11(int n) {\n+    public int test6(int n) {\n@@ -315,1 +332,1 @@\n-            return MyValue11Holder.v.foo + n;\n+            return MyValue6Holder.v.foo + n;\n@@ -319,3 +336,4 @@\n-    public void test11_verifier(boolean warmup) {\n-        if (warmup) {\n-            test11(0);\n+    @DontCompile\n+    public void test6_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test6(0);\n@@ -323,1 +341,1 @@\n-            Asserts.assertEQ(test11(2), 1236);\n+            Asserts.assertEQ(test6(rI), 2*rI);\n@@ -328,1 +346,1 @@\n-    \/\/ Test case 12:  (same as test2, except we use getstatic instead of getfield)\n+    \/\/ Test case 7:  (same as test2, except we use getstatic instead of getfield)\n@@ -331,1 +349,1 @@\n-    \/\/     getstatic  MyValueHolder12.v:QMyValue12;\n+    \/\/     getstatic  MyValue7Holder.v:QMyValue7;\n@@ -334,1 +352,1 @@\n-    \/\/ MyValue12 has not been loaded, because it is not explicitly referenced by\n+    \/\/ MyValue7 has not been loaded, because it is not explicitly referenced by\n@@ -336,0 +354,198 @@\n+    static final inline class MyValue7 {\n+        final int foo;\n+\n+        MyValue7(int n) {\n+            foo = n;\n+        }\n+    }\n+\n+    static class MyValue7Holder {\n+        static MyValue7 v = new MyValue7(rI);\n+    }\n+\n+    @Test\n+    public int test7(int n) {\n+        if (n == 0) {\n+            return 0;\n+        } else {\n+            return MyValue7Holder.v.foo + n;\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test7_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test7(0);\n+        } else {\n+            Asserts.assertEQ(test7(rI), 2*rI);\n+        }\n+    }\n+\n+    \/\/ Test case 8:\n+    \/\/ Same as case 1, except holder is allocated in test method (-> no holder null check required)\n+    static final inline class MyValue8 {\n+        final int foo;\n+\n+        MyValue8() {\n+            foo = rI;\n+        }\n+    }\n+\n+    static class MyValue8Holder {\n+        MyValue8 v;\n+\n+        public MyValue8Holder() {\n+            v = new MyValue8();\n+        }\n+    }\n+\n+    static MyValue8 test8_precondition() {\n+        return new MyValue8();\n+    }\n+\n+    @Test\n+    public int test8(boolean warmup) {\n+        if (!warmup) {\n+            MyValue8Holder holder = new MyValue8Holder();\n+            return holder.v.foo;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test8_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test8(true);\n+        } else {\n+            Asserts.assertEQ(test8(false), rI);\n+        }\n+    }\n+\n+    \/\/ Test case 9:\n+    \/\/ Same as case 2, except holder is allocated in test method (-> no holder null check required)\n+    static final inline class MyValue9 {\n+        final int foo;\n+\n+        public MyValue9(int n) {\n+            foo = n;\n+        }\n+    }\n+\n+    static class MyValue9Holder {\n+        MyValue9 v;\n+\n+        public MyValue9Holder() {\n+            v = new MyValue9(rI);\n+        }\n+    }\n+\n+    @Test\n+    public int test9(boolean warmup) {\n+        if (!warmup) {\n+            MyValue9Holder holder = new MyValue9Holder();\n+            return holder.v.foo;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test9_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test9(true);\n+        } else {\n+            Asserts.assertEQ(test9(false), rI);\n+        }\n+    }\n+\n+    \/\/ Test case 10:\n+    \/\/ Same as case 4, but with putfield\n+    static final inline class MyValue10 {\n+        final int foo;\n+\n+        public MyValue10() {\n+            foo = rI;\n+        }\n+    }\n+\n+    static class MyValue10Holder {\n+        MyValue10 v1;\n+        MyValue10 v2;\n+\n+        public MyValue10Holder() {\n+            v1 = new MyValue10();\n+            v2 = new MyValue10();\n+        }\n+    }\n+\n+    static MyValue10 test10_precondition() {\n+        return new MyValue10();\n+    }\n+\n+    @Test\n+    public void test10(Object holder) {\n+        \/\/ Don't use MyValue10Holder in the signature, it might trigger class loading\n+        GetUnresolvedInlineFieldWrongSignature.test10(holder);\n+    }\n+\n+    @DontCompile\n+    public void test10_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test10(null);\n+        } else {\n+            \/\/ Make sure klass is resolved\n+            for (int i = 0; i < 10; ++i) {\n+                MyValue10Holder holder = new MyValue10Holder();\n+                try {\n+                    test10(holder);\n+                    Asserts.fail(\"Should have thrown NoSuchFieldError\");\n+                } catch (NoSuchFieldError e) {\n+                    \/\/ OK\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Test case 11:\n+    \/\/ Same as case 4, except holder is allocated in test method (-> no holder null check required)\n+    static final inline class MyValue11 {\n+        final int foo;\n+\n+        MyValue11(int n) {\n+            foo = n;\n+        }\n+    }\n+\n+    static class MyValue11Holder {\n+        MyValue11 v;\n+\n+        public MyValue11Holder() {\n+            v = new MyValue11(0);\n+        }\n+    }\n+\n+    @Test\n+    public Object test11(boolean warmup, MyValue11 v) {\n+        if (!warmup) {\n+            MyValue11Holder holder = new MyValue11Holder();\n+            holder.v = v;\n+            return holder;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test11_verifier(boolean warmup) {\n+        MyValue11 v = new MyValue11(rI);\n+        if (warmup && PREVENT_LOADING) {\n+            test11(true, v);\n+        } else {\n+            MyValue11Holder holder = (MyValue11Holder)test11(false, v);\n+            Asserts.assertEQ(holder.v.foo, rI);\n+        }\n+    }\n+\n+    \/\/ Test case 12:\n+    \/\/ Same as case 5, except holder is allocated in test method (-> no holder null check required)\n@@ -345,1 +561,5 @@\n-        static MyValue12 v = new MyValue12(12);\n+        MyValue12 v;\n+\n+        public MyValue12Holder() {\n+            v = new MyValue12(0);\n+        }\n@@ -349,1 +569,240 @@\n-    public int test12(int n) {\n+    public Object test12(boolean warmup, Object o) {\n+        if (!warmup) {\n+            \/\/ Don't use MyValue12 in the signature, it might trigger class loading\n+            MyValue12Holder holder = new MyValue12Holder();\n+            holder.v = (MyValue12)o;\n+            return holder;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test12_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test12(true, null);\n+        } else {\n+            MyValue12 v = new MyValue12(rI);\n+            MyValue12Holder holder = (MyValue12Holder)test12(false, v);\n+            Asserts.assertEQ(holder.v.foo, rI);\n+        }\n+    }\n+\n+    \/\/ Test case 13:\n+    \/\/ Same as case 10, except MyValue13 is allocated in test method\n+    static final inline class MyValue13 {\n+        final int foo;\n+\n+        public MyValue13() {\n+            foo = rI;\n+        }\n+    }\n+\n+    static class MyValue13Holder {\n+        MyValue13 v;\n+\n+        public MyValue13Holder() {\n+            v = new MyValue13();\n+        }\n+    }\n+\n+    static MyValue13 test13_precondition() {\n+        return new MyValue13();\n+    }\n+\n+    @Test\n+    public void test13(Object holder) {\n+        \/\/ Don't use MyValue13Holder in the signature, it might trigger class loading\n+        GetUnresolvedInlineFieldWrongSignature.test13(holder);\n+    }\n+\n+    @DontCompile\n+    public void test13_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test13(null);\n+        } else {\n+            \/\/ Make sure klass is resolved\n+            for (int i = 0; i < 10; ++i) {\n+                MyValue13Holder holder = new MyValue13Holder();\n+                try {\n+                    test13(holder);\n+                    Asserts.fail(\"Should have thrown InstantiationError\");\n+                } catch (InstantiationError e) {\n+                    \/\/ OK\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Test case 14:\n+    \/\/ Same as case 10, except storing null\n+    static final inline class MyValue14 {\n+        final int foo;\n+\n+        public MyValue14() {\n+            foo = rI;\n+        }\n+    }\n+\n+    static class MyValue14Holder {\n+        MyValue14 v;\n+\n+        public MyValue14Holder() {\n+            v = new MyValue14();\n+        }\n+    }\n+\n+    static MyValue14 test14_precondition() {\n+        return new MyValue14();\n+    }\n+\n+    @Test\n+    public void test14(Object holder) {\n+        \/\/ Don't use MyValue14Holder in the signature, it might trigger class loading\n+        GetUnresolvedInlineFieldWrongSignature.test14(holder);\n+    }\n+\n+    @DontCompile\n+    public void test14_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test14(null);\n+        } else {\n+            \/\/ Make sure klass is resolved\n+            for (int i = 0; i < 10; ++i) {\n+                MyValue14Holder holder = new MyValue14Holder();\n+                try {\n+                    test14(holder);\n+                    Asserts.fail(\"Should have thrown NoSuchFieldError\");\n+                } catch (NoSuchFieldError e) {\n+                    \/\/ OK\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Test case 15:\n+    \/\/ Same as case 13, except MyValue15 is unloaded\n+    static final inline class MyValue15 {\n+        final int foo;\n+\n+        public MyValue15() {\n+            foo = rI;\n+        }\n+    }\n+\n+    static class MyValue15Holder {\n+        MyValue15 v;\n+\n+        public MyValue15Holder() {\n+            v = new MyValue15();\n+        }\n+    }\n+\n+    @Test\n+    public void test15(Object holder) {\n+        \/\/ Don't use MyValue15Holder in the signature, it might trigger class loading\n+        GetUnresolvedInlineFieldWrongSignature.test15(holder);\n+    }\n+\n+    @DontCompile\n+    public void test15_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test15(null);\n+        } else {\n+            \/\/ Make sure klass is resolved\n+            for (int i = 0; i < 10; ++i) {\n+                MyValue15Holder holder = new MyValue15Holder();\n+                try {\n+                    test15(holder);\n+                    Asserts.fail(\"Should have thrown InstantiationError\");\n+                } catch (InstantiationError e) {\n+                    \/\/ OK\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Test case 16:\n+    \/\/ Defaultvalue with type which is not an inline type\n+    static final class MyValue16 {\n+        final int foo;\n+\n+        public MyValue16() {\n+            foo = rI;\n+        }\n+    }\n+\n+    static MyValue16 test16_precondition() {\n+        return new MyValue16();\n+    }\n+\n+    @Test\n+    public Object test16(boolean warmup) {\n+        return GetUnresolvedInlineFieldWrongSignature.test16(warmup);\n+    }\n+\n+    @DontCompile\n+    public void test16_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test16(true);\n+        } else {\n+            \/\/ Make sure klass is resolved\n+            for (int i = 0; i < 10; ++i) {\n+                try {\n+                    test16(false);\n+                    Asserts.fail(\"Should have thrown IncompatibleClassChangeError\");\n+                } catch (IncompatibleClassChangeError e) {\n+                    \/\/ OK\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Test case 17:\n+    \/\/ Same as test16 but with unloaded type at defaultvalue\n+    static final class MyValue17 {\n+        final int foo;\n+\n+        public MyValue17() {\n+            foo = rI;\n+        }\n+    }\n+\n+    @Test\n+    public Object test17(boolean warmup) {\n+        return GetUnresolvedInlineFieldWrongSignature.test17(warmup);\n+    }\n+\n+    @DontCompile\n+    public void test17_verifier(boolean warmup) {\n+        if (warmup && PREVENT_LOADING) {\n+            test17(true);\n+        } else {\n+            \/\/ Make sure klass is resolved\n+            for (int i = 0; i < 10; ++i) {\n+                try {\n+                    test17(false);\n+                    Asserts.fail(\"Should have thrown IncompatibleClassChangeError\");\n+                } catch (IncompatibleClassChangeError e) {\n+                    \/\/ OK\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Test case 18:\n+    \/\/ Same as test7 but with the holder being loaded\n+    static final inline class MyValue18 {\n+        final int foo;\n+\n+        MyValue18(int n) {\n+            foo = n;\n+        }\n+    }\n+\n+    static class MyValue18Holder {\n+        static MyValue18 v = new MyValue18(rI);\n+    }\n+\n+    @Test\n+    public int test18(int n) {\n@@ -353,1 +812,1 @@\n-            return MyValue12Holder.v.foo + n;\n+            return MyValue18Holder.v.foo + n;\n@@ -357,3 +816,40 @@\n-    public void test12_verifier(boolean warmup) {\n-        if (warmup) {\n-            test12(0);\n+    @DontCompile\n+    public void test18_verifier(boolean warmup) {\n+        \/\/ Make sure MyValue18Holder is loaded\n+        MyValue18Holder holder = new MyValue18Holder();\n+        if (warmup && PREVENT_LOADING) {\n+            test18(0);\n+        } else {\n+            Asserts.assertEQ(test18(rI), 2*rI);\n+        }\n+    }\n+\n+    \/\/ Test case 19:\n+    \/\/ Same as test18 but uninitialized (null) static inline type field\n+    static final inline class MyValue19 {\n+        final int foo;\n+\n+        MyValue19(int n) {\n+            foo = n;\n+        }\n+    }\n+\n+    static class MyValue19Holder {\n+        static MyValue19 v;\n+    }\n+\n+    @Test\n+    public int test19(int n) {\n+        if (n == 0) {\n+            return 0;\n+        } else {\n+            return MyValue19Holder.v.foo + n;\n+        }\n+    }\n+\n+    @DontCompile\n+    public void test19_verifier(boolean warmup) {\n+        \/\/ Make sure MyValue19Holder is loaded\n+        MyValue19Holder holder = new MyValue19Holder();\n+        if (warmup && PREVENT_LOADING) {\n+            test19(0);\n@@ -361,1 +857,1 @@\n-          Asserts.assertEQ(test12(1), 13);\n+            Asserts.assertEQ(test19(rI), rI);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":560,"deletions":64,"binary":false,"changes":624,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,41 @@\n+\n+    static class MyValue10 {\n+        int foo;\n+    }\n+\n+    static class MyValue10Holder {\n+        MyValue10 v1;\n+        MyValue10 v2;\n+    }\n+\n+    static class MyValue13 {\n+        int foo;\n+    }\n+\n+    static class MyValue13Holder {\n+        MyValue13 v;\n+    }\n+\n+    static class MyValue14 {\n+        int foo;\n+    }\n+\n+    static class MyValue14Holder {\n+        MyValue14 v;\n+    }\n+\n+    static class MyValue15 {\n+        int foo;\n+    }\n+\n+    static class MyValue15Holder {\n+        MyValue15 v;\n+    }\n+\n+    static inline class MyValue16 {\n+        int foo = 42;\n+    }\n+\n+    static inline class MyValue17 {\n+        int foo = 42;\n+    }\n@@ -37,3 +78,4 @@\n-    static int test3(TestUnloadedInlineTypeField.MyValue3Holder holder3) {\n-        if (holder3 != null) {\n-            return holder3.v.foo + 3;\n+    static int test3(Object holder) {\n+        if (holder != null) {\n+            \/\/ Don't use MyValue3Holder in the signature, it might trigger class loading\n+            return ((TestUnloadedInlineTypeField.MyValue3Holder)holder).v.foo + 3;\n@@ -44,0 +86,44 @@\n+\n+    static void test10(Object holder) {\n+        if (holder != null) {\n+            \/\/ Don't use MyValue10Holder in the signature, it might trigger class loading\n+            ((TestUnloadedInlineTypeField.MyValue10Holder)holder).v1 = ((TestUnloadedInlineTypeField.MyValue10Holder)holder).v2;\n+        }\n+    }\n+\n+    static void test13(Object holder) {\n+        if (holder != null) {\n+            \/\/ Don't use MyValue13Holder in the signature, it might trigger class loading\n+            ((TestUnloadedInlineTypeField.MyValue13Holder)holder).v = new TestUnloadedInlineTypeField.MyValue13();\n+        }\n+    }\n+\n+    static void test14(Object holder) {\n+        if (holder != null) {\n+            \/\/ Don't use MyValue14Holder in the signature, it might trigger class loading\n+            ((TestUnloadedInlineTypeField.MyValue14Holder)holder).v = null;\n+        }\n+    }\n+\n+    static void test15(Object holder) {\n+        if (holder != null) {\n+            \/\/ Don't use MyValue15Holder in the signature, it might trigger class loading\n+            ((TestUnloadedInlineTypeField.MyValue15Holder)holder).v = new TestUnloadedInlineTypeField.MyValue15();\n+        }\n+    }\n+\n+    static Object test16(boolean warmup) {\n+        if (!warmup) {\n+            return TestUnloadedInlineTypeField.MyValue16.default;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static Object test17(boolean warmup) {\n+        if (!warmup) {\n+            return TestUnloadedInlineTypeField.MyValue17.default;\n+        } else {\n+            return null;\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/hack\/GetUnresolvedInlineFieldWrongSignature.java","additions":90,"deletions":4,"binary":false,"changes":94,"status":"modified"}]}