{"files":[{"patch":"@@ -1018,1 +1018,3 @@\n-        if (target.hasMethodParameters() && (options.isSet(PARAMETERS) || m.isConstructor() && (m.flags_field & RECORD) != 0)) {\n+        if (target.hasMethodParameters() && (\n+                options.isSet(PARAMETERS)\n+                || ((m.flags_field & RECORD) != 0 && (m.isConstructor() || m.isPrimitiveObjectFactory())))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -392,1 +392,1 @@\n-        MethodType factoryType = new MethodType(init.erasure(types).getParameterTypes(),\n+        MethodType factoryType = new MethodType(init.type.getParameterTypes(),\n@@ -400,0 +400,6 @@\n+        factory.params = init.params;\n+        \/\/ Re-patch the return type on the erased method type, or code generation will fail\n+        factory.erasure_field = new MethodType(init.erasure(types).getParameterTypes(),\n+                init.owner.type.asValueType(),\n+                init.type.getThrownTypes(),\n+                init.owner.type.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransPrimitiveClass.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8273018\n@@ -129,0 +130,63 @@\n+    @Test\n+    public void testPrimitiveRecordClassFileReading(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           public primitive record R(int i, @A long j, java.util.List<String> l) {}\n+                           \"\"\",\n+                           \"\"\"\n+                           public @interface A {}\n+                           \"\"\");\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(src))\n+                .run();\n+\n+        \/\/read the class file back, to verify javac's ClassReader\n+        \/\/reads the Record attribute properly:\n+        String output = new JavacTask(tb)\n+                .options(\"-Xprint\")\n+                .classpath(out.toString())\n+                .classes(\"R\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT)\n+                .replaceAll(\"\\\\R\", \"\\n\");\n+\n+        String expected =\n+                \"\"\"\n+                \\n\\\n+                public primitive record R(int i, @A long j, java.util.List<java.lang.String> l) {\n+                  private final int i;\n+                  @A\n+                  private final long j;\n+                  private final java.util.List<java.lang.String> l;\n+                \\n\\\n+                  public final java.lang.String toString();\n+                \\n\\\n+                  public final int hashCode();\n+                \\n\\\n+                  public final boolean equals(java.lang.Object arg0);\n+                \\n\\\n+                  public int i();\n+                \\n\\\n+                  @A\n+                  public long j();\n+                \\n\\\n+                  public java.util.List<java.lang.String> l();\n+                \\n\\\n+                  public R(int i,\n+                    @A long j,\n+                    java.util.List<java.lang.String> l);\n+                }\n+                \"\"\";\n+        if (!Objects.equals(expected, output)) {\n+            throw new AssertionError(\"Unexpected output: \" + output);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/records\/RecordReading.java","additions":65,"deletions":1,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @summary [lworld] test for equal treatment of annotations on primitive records (copy of ApplicableAnnotationsOnRecords)\n+ * @bug 8273018\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @run main ApplicableAnnotationsOnPrimitiveRecords\n+ *\/\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.javac.util.Assert;\n+import java.lang.annotation.*;\n+import java.io.InputStream;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.FIELD})\n+@interface FieldAnnotation {\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.METHOD})\n+@interface MethodAnnotation {\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.PARAMETER})\n+@interface ParameterAnnotation {\n+}\n+\n+public primitive record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n+\n+    public static void main(String... args) throws Exception {\n+        try ( InputStream in = ApplicableAnnotationsOnPrimitiveRecords.class.getResourceAsStream(\"ApplicableAnnotationsOnPrimitiveRecords.class\")) {\n+            ClassFile cf = ClassFile.read(in);\n+            Assert.check(cf.methods.length > 5);\n+            for (Method m : cf.methods) {\n+                String methodName = m.getName(cf.constant_pool);\n+                if (methodName.equals(\"toString\") || methodName.equals(\"hashCode\") || methodName.equals(\"equals\") || methodName.equals(\"main\")) {\n+                    \/\/ ignore\n+                } else if (methodName.equals(\"<init>\")) {\n+                    var paAnnos = ((RuntimeVisibleParameterAnnotations_attribute) m.attributes.get(Attribute.RuntimeVisibleParameterAnnotations)).parameter_annotations;\n+                    Assert.check(paAnnos != null && paAnnos.length > 0);\n+                    for (var pa : paAnnos) {\n+                        Assert.check(pa.length == 1);\n+                        Assert.check(cf.constant_pool.getUTF8Value(pa[0].type_index).equals(\"LParameterAnnotation;\"));\n+                    }\n+                } else {\n+                    var annos = ((RuntimeAnnotations_attribute) m.attributes.get(Attribute.RuntimeVisibleAnnotations)).annotations;\n+                    Assert.check(annos.length == 1);\n+                    Assert.check(cf.constant_pool.getUTF8Value(annos[0].type_index).equals(\"LMethodAnnotation;\"));\n+                }\n+            }\n+            Assert.check(cf.fields.length > 0);\n+            for (Field field : cf.fields) {\n+                var annos = ((RuntimeAnnotations_attribute) field.attributes.get(Attribute.RuntimeVisibleAnnotations)).annotations;\n+                Assert.check(annos.length == 1);\n+                Assert.check(cf.constant_pool.getUTF8Value(annos[0].type_index).equals(\"LFieldAnnotation;\"));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"}]}