{"files":[{"patch":"@@ -1018,1 +1018,4 @@\n-        if (target.hasMethodParameters() && (options.isSet(PARAMETERS) || m.isConstructor() && (m.flags_field & RECORD) != 0)) {\n+        if (target.hasMethodParameters() && (\n+                options.isSet(PARAMETERS)\n+                || m.isConstructor() && (m.flags_field & RECORD) != 0\n+                || m.isPrimitiveObjectFactory() && (m.flags_field & RECORD) != 0)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -392,1 +392,1 @@\n-        MethodType factoryType = new MethodType(init.erasure(types).getParameterTypes(),\n+        MethodType factoryType = new MethodType(init.type.getParameterTypes(),\n@@ -401,0 +401,5 @@\n+        \/\/ Re-patch the return type on the erased method type, or code generation will fail\n+        factory.erasure_field = new MethodType(init.erasure(types).getParameterTypes(),\n+                init.owner.type.asValueType(),\n+                init.type.getThrownTypes(),\n+                init.owner.type.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransPrimitiveClass.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -129,0 +129,63 @@\n+    @Test\n+    public void testPrimitiveRecordClassFileReading(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                           \"\"\"\n+                           public primitive record R(int i, @A long j, java.util.List<String> l) {}\n+                           \"\"\",\n+                           \"\"\"\n+                           public @interface A {}\n+                           \"\"\");\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(src))\n+                .run();\n+\n+        \/\/read the class file back, to verify javac's ClassReader\n+        \/\/reads the Record attribute properly:\n+        String output = new JavacTask(tb)\n+                .options(\"-Xprint\")\n+                .classpath(out.toString())\n+                .classes(\"R\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT)\n+                .replaceAll(\"\\\\R\", \"\\n\");\n+\n+        String expected =\n+                \"\"\"\n+                \\n\\\n+                public primitive record R(int i, @A long j, java.util.List<java.lang.String> l) {\n+                  private final int i;\n+                  @A\n+                  private final long j;\n+                  private final java.util.List<java.lang.String> l;\n+                \\n\\\n+                  public final java.lang.String toString();\n+                \\n\\\n+                  public final int hashCode();\n+                \\n\\\n+                  public final boolean equals(java.lang.Object arg0);\n+                \\n\\\n+                  public int i();\n+                \\n\\\n+                  @A\n+                  public long j();\n+                \\n\\\n+                  public java.util.List<java.lang.String> l();\n+                \\n\\\n+                  public R(int i,\n+                    @A long j,\n+                    java.util.List<java.lang.String> l);\n+                }\n+                \"\"\";\n+        if (!Objects.equals(expected, output)) {\n+            throw new AssertionError(\"Unexpected output: \" + output);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/records\/RecordReading.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"}]}