{"files":[{"patch":"@@ -535,1 +535,1 @@\n-  if (InlineTypeReturnedAsFields && return_type->is_inlinetype()) {\n+  if (InlineTypeReturnedAsFields && return_type->is_inlinetype() && return_type->is_null_free()) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2742,1 +2742,1 @@\n-void MacroAssembler::test_field_is_inline_type(Register flags, Register temp_reg, Label& is_inline_type) {\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n@@ -2744,1 +2744,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_inline_type_shift);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n@@ -2747,1 +2747,1 @@\n-  jcc(Assembler::notZero, is_inline_type);\n+  jcc(Assembler::notZero, is_null_free_inline_type);\n@@ -2750,1 +2750,1 @@\n-void MacroAssembler::test_field_is_not_inline_type(Register flags, Register temp_reg, Label& not_inline_type) {\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n@@ -2752,1 +2752,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_inline_type_shift);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n@@ -2755,1 +2755,1 @@\n-  jcc(Assembler::zero, not_inline_type);\n+  jcc(Assembler::zero, not_null_free_inline_type);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n-  void test_field_is_inline_type(Register flags, Register temp_reg, Label& is_inline);\n-  void test_field_is_not_inline_type(Register flags, Register temp_reg, Label& not_inline);\n+  void test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free);\n+  void test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3014,1 +3014,1 @@\n-      Label is_inline_type, uninitialized;\n+      Label is_null_free_inline_type, uninitialized;\n@@ -3016,2 +3016,2 @@\n-      __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n-        \/\/ field is not an inline type\n+      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n+        \/\/ field is not a null free inline type\n@@ -3020,2 +3020,2 @@\n-      \/\/ field is an inline type, must not return null even if uninitialized\n-      __ bind(is_inline_type);\n+      \/\/ field is a null free inline type, must not return null even if uninitialized\n+      __ bind(is_null_free_inline_type);\n@@ -3046,1 +3046,1 @@\n-      __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n+      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n@@ -3395,1 +3395,1 @@\n-        __ test_field_is_not_inline_type(flags2, rscratch1, is_inline_type);\n+        __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n@@ -3402,1 +3402,1 @@\n-        __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -672,1 +672,2 @@\n-    if (!x->klass()->is_inlinetype() && obj->as_Constant() && obj->type()->as_ObjectType()->constant_value()->is_null_object()) {\n+    if (!x->klass()->is_inlinetype() && x->is_null_free()\n+        && obj->as_Constant() && obj->type()->as_ObjectType()->constant_value()->is_null_object()) {\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1847,1 +1847,1 @@\n-      } else if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      } else if (field_type == T_INLINE_TYPE && field->type()->is_null_free() && field->type()->unwrap()->as_inline_klass()->is_empty()) {\n@@ -1849,1 +1849,1 @@\n-        constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+        constant = new Constant(new InstanceConstant(field->type()->unwrap()->as_inline_klass()->default_instance()));\n@@ -1872,1 +1872,1 @@\n-      if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      if (field_type == T_INLINE_TYPE && field->type()->unwrap()->as_inline_klass()->is_empty()) {\n@@ -1890,1 +1890,1 @@\n-        if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+        if (field_type == T_INLINE_TYPE && field->type()->is_null_free() && field->type()->unwrap()->as_inline_klass()->is_empty()) {\n@@ -1893,1 +1893,1 @@\n-          constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+          constant = new Constant(new InstanceConstant(field->type()->unwrap()->as_inline_klass()->default_instance()));\n@@ -1901,1 +1901,1 @@\n-                constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+                constant = new Constant(new InstanceConstant(field->type()->unwrap()->as_inline_klass()->default_instance()));\n@@ -1988,1 +1988,1 @@\n-            ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n+            ciInlineKlass* inline_klass = field->type()->unwrap()->as_inline_klass();\n@@ -2045,1 +2045,1 @@\n-      if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      if (field_type == T_INLINE_TYPE && field->type()->is_null_free() && field->type()->unwrap()->as_inline_klass()->is_empty()) {\n@@ -2056,1 +2056,1 @@\n-        ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n+        ciInlineKlass* inline_klass = field->type()->unwrap()->as_inline_klass();\n@@ -2132,1 +2132,1 @@\n-    ciInlineKlass* vk = field_modify->type()->as_inline_klass();\n+    ciInlineKlass* vk = field_modify->type()->unwrap()->as_inline_klass();\n@@ -2481,1 +2481,1 @@\n-                              declared_signature->return_type()->is_inlinetype());\n+                              declared_signature->return_type()->is_null_free());\n@@ -2529,1 +2529,1 @@\n-  bool null_free = stream()->is_inline_klass();\n+  bool null_free = stream()->has_Q_signature();\n@@ -2556,1 +2556,1 @@\n-  bool null_free = stream()->is_inline_klass();\n+  bool null_free = stream()->has_Q_signature();\n@@ -3582,1 +3582,1 @@\n-    state->store_local(idx, new Local(type, vt, idx, false, type->is_inlinetype()));\n+    state->store_local(idx, new Local(type, vt, idx, false, type->is_null_free()));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1077,1 +1077,1 @@\n-      (method()->signature()->returns_inline_type() ||\n+      (method()->signature()->returns_null_free_inline_type() ||\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2058,1 +2058,1 @@\n-  bool could_be_null = x->is_static() && x->as_LoadField() != NULL && !field->type()->is_loaded();\n+  bool could_be_null = x->is_static() && x->as_LoadField() != NULL && !field->type()->unwrap()->is_loaded();\n@@ -2140,1 +2140,1 @@\n-    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n+    ciInlineKlass* inline_klass = field->type()->unwrap()->as_inline_klass();\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+class    ciWrapper;\n@@ -119,0 +120,1 @@\n+friend class  ciWrapper;               \\\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-bool ciEnv::is_inline_klass(const constantPoolHandle& cpool, int index) {\n+bool ciEnv::has_Q_signature(const constantPoolHandle& cpool, int index) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  bool       is_inline_klass(const constantPoolHandle& cpool,\n+  bool       has_Q_signature(const constantPoolHandle& cpool,\n@@ -475,0 +475,4 @@\n+\n+  ciWrapper* make_null_free_wrapper(ciType* type) {\n+    return _factory->make_null_free_wrapper(type);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,1 +101,6 @@\n-    _type = ciEnv::current(THREAD)->get_klass_by_index(cpool, sig_index, ignore, klass);\n+    ciType* type = ciEnv::current(THREAD)->get_klass_by_index(cpool, sig_index, ignore, klass);\n+    if (signature->is_Q_signature()) {\n+      _type = ciEnv::current(THREAD)->make_null_free_wrapper(type);\n+    } else {\n+      _type = type;\n+    }\n@@ -108,0 +113,3 @@\n+  \/\/ this is needed if the field class is not yet loaded.\n+  _is_null_free = _signature->is_Q_signature();\n+\n@@ -240,0 +248,1 @@\n+  _is_null_free = field->is_null_free();\n@@ -290,0 +299,1 @@\n+  _is_null_free = fd->signature()->is_Q_signature();\n@@ -374,0 +384,6 @@\n+  ciType* rtype;\n+  if (_signature->is_Q_signature()) {\n+    rtype = CURRENT_ENV->make_null_free_wrapper(type);\n+  } else {\n+    rtype = type;\n+  }\n@@ -385,2 +401,3 @@\n-    if (!type_is_also_shared)\n-      return type;              \/\/ Bummer.\n+    if (!type_is_also_shared) {\n+      return rtype;              \/\/ Bummer.\n+    }\n@@ -388,2 +405,2 @@\n-  _type = type;\n-  return type;\n+  _type = rtype;\n+  return rtype;\n@@ -487,0 +504,1 @@\n+  tty->print(\" is_null_free=%s\", bool_to_str(_is_null_free));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  bool             _is_null_free;\n@@ -180,0 +181,1 @@\n+  bool is_null_free            () const { return _is_null_free; }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  virtual bool is_wrapper() const           { return false; }\n@@ -114,0 +115,4 @@\n+  ciWrapper*               as_wrapper() {\n+    assert(is_wrapper(), \"bad cast\");\n+    return (ciWrapper*)this;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -632,0 +632,6 @@\n+ciWrapper* ciObjectFactory::make_null_free_wrapper(ciType* type) {\n+  ciWrapper* wrapper = new (arena()) ciWrapper(type, \/* null_free *\/ true);\n+  init_ident_of(wrapper);\n+  return wrapper;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+  ciWrapper* make_null_free_wrapper(ciType* type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+    if (type->is_inlinetype() && ss.has_Q_descriptor()) {\n+      type = env->make_null_free_wrapper(type);\n+    }\n@@ -75,1 +78,1 @@\n-bool ciSignature::returns_inline_type() const {\n+bool ciSignature::returns_null_free_inline_type() const {\n","filename":"src\/hotspot\/share\/ci\/ciSignature.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  bool      returns_inline_type() const;\n+  bool      returns_null_free_inline_type() const;\n","filename":"src\/hotspot\/share\/ci\/ciSignature.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-bool ciBytecodeStream::is_inline_klass() const {\n+bool ciBytecodeStream::has_Q_signature() const {\n@@ -202,1 +202,1 @@\n-  return CURRENT_ENV->is_inline_klass(cpool, get_klass_index());\n+  return CURRENT_ENV->has_Q_signature(cpool, get_klass_index());\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-  bool is_inline_klass() const;\n+  bool has_Q_signature() const;\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  friend class ciWrapper;\n@@ -74,0 +75,3 @@\n+  virtual ciType*     unwrap()              { return this; }\n+  virtual bool is_null_free() const        { return false; }\n+\n@@ -109,0 +113,31 @@\n+\/\/ ciWrapper\n+\/\/\n+\/\/ This class wraps another type to carry additional information like nullability.\n+\/\/ Should only be instantiated and used by ciTypeFlow and ciSignature.\n+class ciWrapper : public ciType {\n+  CI_PACKAGE_ACCESS\n+\n+private:\n+  ciType* _type;\n+  bool _null_free;\n+\n+  ciWrapper(ciType* type, bool null_free) : ciType(type->basic_type()) {\n+    assert(type->is_inlinetype()\n+          \/\/ An unloaded inline type is an instance_klass (see ciEnv::get_klass_by_name_impl())\n+          || (type->is_instance_klass() && !type->is_loaded()),\n+          \"should only be used for inline types\");\n+    _type = type;\n+    _null_free = null_free;\n+  }\n+\n+  const char* type_string() { return \"ciWrapper\"; }\n+\n+  void print_impl(outputStream* st) { _type->print_impl(st); }\n+\n+public:\n+  bool    is_wrapper() const { return true; }\n+\n+  ciType*     unwrap()       { return _type; }\n+  bool is_null_free() const { return _null_free; }\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-    if (str->is_inline_klass()) {\n+    if (str->has_Q_signature()) {\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5882,1 +5882,1 @@\n-      if (ik->field_is_inline_type(i)) {\n+      if (ik->field_is_null_free_inline_type(i)) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,2 +321,1 @@\n-      if ((class_name->is_Q_array_signature() && !k->is_inline_klass()) ||\n-          (!class_name->is_Q_array_signature() && k->is_inline_klass())) {\n+      if ((class_name->is_Q_array_signature() && !k->is_inline_klass())) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-      if (voop == NULL && cp_entry->is_inline_type()) {\n+      if (voop == NULL && cp_entry->is_null_free_inline_type()) {\n@@ -383,0 +383,1 @@\n+  assert(klass->field_signature(index)->is_Q_signature(), \"Sanity check\");\n@@ -959,1 +960,1 @@\n-    info.is_inline_type()\n+    info.signature()->is_Q_signature() && info.is_inline_type()\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-                                       bool is_inline_type) {\n+                                       bool is_null_free_inline_type) {\n@@ -145,1 +145,1 @@\n-  assert(!is_inlined || is_inline_type, \"Sanity check\");\n+  assert(!is_inlined || is_null_free_inline_type, \"Sanity check\");\n@@ -150,1 +150,1 @@\n-                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),\n+                  ((is_null_free_inline_type ? 1 : 0) << is_null_free_inline_type_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-\/\/ I  flag true if field is an inline type (must never be null)\n+\/\/ I  flag true if field is a null free inline type (must never be null)\n@@ -189,1 +189,1 @@\n-    is_inline_type_shift       = 24,  \/\/ (I) is the type of the field an inline type (must never be null)\n+    is_null_free_inline_type_shift = 24,  \/\/ (I) is the field a null free inline type (must never be null)\n@@ -232,1 +232,1 @@\n-    bool            is_inline_type               \/\/ the field is an inline type (must never be null)\n+    bool            is_null_free_inline_type     \/\/ the field is an inline type (must never be null)\n@@ -365,1 +365,1 @@\n-  bool is_inline_type() const                    { return (_flags & (1 << is_inline_type_shift))       != 0; }\n+  bool is_null_free_inline_type() const          { return (_flags & (1 << is_null_free_inline_type_shift)) != 0; }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-bool InstanceKlass::field_is_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_INLINE_TYPE; }\n+bool InstanceKlass::field_is_null_free_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_INLINE_TYPE; }\n@@ -2894,1 +2894,1 @@\n-  dest[dest_index++] = is_inline_klass() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;\n+  dest[dest_index++] = JVM_SIGNATURE_CLASS;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-  bool    field_is_inline_type(int index) const;\n+  bool    field_is_null_free_inline_type(int index) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    assert(!iter().is_inline_klass(), \"Inline type should be loaded\");\n+    assert(!iter().has_Q_signature(), \"Inline type should be loaded\");\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -526,0 +526,4 @@\n+  bool has_Q_descriptor() const {\n+    return has_envelope() && (_signature->char_at(_begin) == JVM_SIGNATURE_INLINE_TYPE);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        splitPrimitiveClass = options.isUnset(\"unifiedValRefClass\");\n+        splitPrimitiveClass = false ; \/\/ options.isUnset(\"unifiedValRefClass\"); \/\/ Temporarely forcing the default\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-        final String fieldLSignature = \"L\" + inlineClass.getName().replace('.', '\/') + \"$ref;\";\n+        final String fieldLSignature = \"L\" + inlineClass.getName().replace('.', '\/') + \";\";\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}