{"files":[{"patch":"@@ -3218,0 +3218,44 @@\n+\/\/ Max vector size in bytes. 0 if not supported.\n+int VM_Version::max_vector_size(BasicType bt) {\n+  assert(is_java_primitive(bt), \"only primitive type vectors\");\n+  if (UseSSE < 2) return 0;\n+  \/\/ SSE2 supports 128bit vectors for all types.\n+  \/\/ AVX2 supports 256bit vectors for all types.\n+  \/\/ AVX2\/EVEX supports 512bit vectors for all types.\n+  int size = (UseAVX > 1) ? (1 << UseAVX) * 8 : 16;\n+  \/\/ AVX1 supports 256bit vectors only for FLOAT and DOUBLE.\n+  if (UseAVX > 0 && (bt == T_FLOAT || bt == T_DOUBLE))\n+    size = (UseAVX > 2) ? 64 : 32;\n+  if (UseAVX > 2 && (bt == T_BYTE || bt == T_SHORT || bt == T_CHAR))\n+    size = (VM_Version::supports_avx512bw()) ? 64 : 32;\n+  \/\/ Use flag to limit vector size.\n+  size = MIN2(size,(int)MaxVectorSize);\n+  \/\/ Minimum 2 values in vector (or 4 for bytes).\n+  switch (bt) {\n+  case T_DOUBLE:\n+  case T_LONG:\n+    if (size < 16) return 0;\n+    break;\n+  case T_FLOAT:\n+  case T_INT:\n+    if (size < 8) return 0;\n+    break;\n+  case T_BOOLEAN:\n+    if (size < 4) return 0;\n+    break;\n+  case T_CHAR:\n+    if (size < 4) return 0;\n+    break;\n+  case T_BYTE:\n+    if (size < 4) return 0;\n+    break;\n+  case T_SHORT:\n+    if (size < 4) return 0;\n+    break;\n+  default:\n+    assert(false, \"Unexpected basic type\");\n+  }\n+  return size \/ type2aelembytes(bt);\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -777,0 +777,3 @@\n+  \/\/ Max supported vector lane count for a particular lane type.\n+  static int max_vector_size(BasicType bt);\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2266,1 +2266,1 @@\n-  return vector_width_in_bytes(bt)\/type2aelembytes(bt);\n+  return VM_Version::max_vector_size(bt);\n@@ -2268,0 +2268,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1866,7 +1866,10 @@\n-    assert(!inner_field->is_flat(), \"the iteration over nested fields is handled by the loop itself\");\n-    int off = inner_field->offset_in_bytes() - vk->first_field_offset();\n-    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n-    Value replacement = append(load);\n-    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n-    store->set_enclosing_field(enclosing_field);\n-    append(store);\n+    for (int j = 0, sec_offset = 0; j < inner_field->secondary_fields_count(); j++) {\n+      assert(!inner_field->is_flat(), \"the iteration over nested fields is handled by the loop itself\");\n+      int off = inner_field->offset_in_bytes() + sec_offset - vk->first_field_offset();\n+      LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n+      Value replacement = append(load);\n+      StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n+      store->set_enclosing_field(enclosing_field);\n+      append(store);\n+      sec_offset += type2aelembytes(inner_field->type()->basic_type());\n+    }\n@@ -2197,4 +2200,8 @@\n-          LoadField* load = new LoadField(obj, offset, field, false, state_before, false);\n-          Value replacement = append(load);\n-          StoreField* store = new StoreField(new_instance, offset, field, replacement, false, state_before, false);\n-          append(store);\n+          for (int i = 0, sec_offset = 0; i < field->secondary_fields_count(); i++) {\n+            ciField* temp = i > 0 ? static_cast<ciMultiField*>(field)->secondary_field_at(i-1) : field;\n+            LoadField* load = new LoadField(obj, offset + sec_offset, temp, false, state_before, false);\n+            Value replacement = append(load);\n+            StoreField* store = new StoreField(new_instance, offset + sec_offset, temp, replacement, false, state_before, false);\n+            append(store);\n+            sec_offset += type2aelembytes(as_BasicType(load->type()));\n+          }\n@@ -2218,2 +2225,6 @@\n-    StoreField* store = new StoreField(new_instance, offset_modify, field_modify, val, false, state_before, needs_patching);\n-    append(store);\n+    int sec_field_size = type2aelembytes(field_type);\n+    for (int i = 0; i < field_modify->secondary_fields_count(); i++) {\n+      ciField* temp = i > 0 ? static_cast<ciMultiField*>(field_modify)->secondary_field_at(i-1) : field_modify;\n+      StoreField* store = new StoreField(new_instance, offset_modify + i * sec_field_size, temp, val, false, state_before, needs_patching);\n+      append(store);\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1776,6 +1776,1 @@\n-  CompilerThread* ct = CompilerThread::current();\n-  if (ct && ct->compiler()->is_c2()) {\n-    return InlineTypeNode::is_multifield_scalarized(bt, vec_length);\n-  } else {\n-    return true;\n-  }\n+  return InlineTypeNode::is_multifield_scalarized(bt, vec_length);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1634,1 +1634,5 @@\n-      for (int i = 1; i < parsed_annotations.multifield_arg(); i++) {\n+      int bundle_size = parsed_annotations.multifield_arg();\n+      if (bundle_size < 0) {\n+        bundle_size = VectorSupport::get_max_multifield_count(_class_name);\n+      }\n+      for (int i = 1; i < bundle_size; i++) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,35 +195,0 @@\n-  do_klass(vector_VectorPayloadMF8Z_klass,              jdk_internal_vm_vector_VectorPayloadMF8Z              ) \\\n-  do_klass(vector_VectorPayloadMF16Z_klass,             jdk_internal_vm_vector_VectorPayloadMF16Z             ) \\\n-  do_klass(vector_VectorPayloadMF32Z_klass,             jdk_internal_vm_vector_VectorPayloadMF32Z             ) \\\n-  do_klass(vector_VectorPayloadMF64Z_klass,             jdk_internal_vm_vector_VectorPayloadMF64Z             ) \\\n-  do_klass(vector_VectorPayloadMF128Z_klass,            jdk_internal_vm_vector_VectorPayloadMF128Z            ) \\\n-  do_klass(vector_VectorPayloadMF256Z_klass,            jdk_internal_vm_vector_VectorPayloadMF256Z            ) \\\n-  do_klass(vector_VectorPayloadMF512Z_klass,            jdk_internal_vm_vector_VectorPayloadMF512Z            ) \\\n-  do_klass(vector_VectorPayloadMF8B_klass,              jdk_internal_vm_vector_VectorPayloadMF8B              ) \\\n-  do_klass(vector_VectorPayloadMF16B_klass,             jdk_internal_vm_vector_VectorPayloadMF16B             ) \\\n-  do_klass(vector_VectorPayloadMF32B_klass,             jdk_internal_vm_vector_VectorPayloadMF32B             ) \\\n-  do_klass(vector_VectorPayloadMF64B_klass,             jdk_internal_vm_vector_VectorPayloadMF64B             ) \\\n-  do_klass(vector_VectorPayloadMF128B_klass,            jdk_internal_vm_vector_VectorPayloadMF128B            ) \\\n-  do_klass(vector_VectorPayloadMF256B_klass,            jdk_internal_vm_vector_VectorPayloadMF256B            ) \\\n-  do_klass(vector_VectorPayloadMF512B_klass,            jdk_internal_vm_vector_VectorPayloadMF512B            ) \\\n-  do_klass(vector_VectorPayloadMF64S_klass,             jdk_internal_vm_vector_VectorPayloadMF64S             ) \\\n-  do_klass(vector_VectorPayloadMF128S_klass,            jdk_internal_vm_vector_VectorPayloadMF128S            ) \\\n-  do_klass(vector_VectorPayloadMF256S_klass,            jdk_internal_vm_vector_VectorPayloadMF256S            ) \\\n-  do_klass(vector_VectorPayloadMF512S_klass,            jdk_internal_vm_vector_VectorPayloadMF512S            ) \\\n-  do_klass(vector_VectorPayloadMF64I_klass,             jdk_internal_vm_vector_VectorPayloadMF64I             ) \\\n-  do_klass(vector_VectorPayloadMF128I_klass,            jdk_internal_vm_vector_VectorPayloadMF128I            ) \\\n-  do_klass(vector_VectorPayloadMF256I_klass,            jdk_internal_vm_vector_VectorPayloadMF256I            ) \\\n-  do_klass(vector_VectorPayloadMF512I_klass,            jdk_internal_vm_vector_VectorPayloadMF512I            ) \\\n-  do_klass(vector_VectorPayloadMF64L_klass,             jdk_internal_vm_vector_VectorPayloadMF64L             ) \\\n-  do_klass(vector_VectorPayloadMF128L_klass,            jdk_internal_vm_vector_VectorPayloadMF128L            ) \\\n-  do_klass(vector_VectorPayloadMF256L_klass,            jdk_internal_vm_vector_VectorPayloadMF256L            ) \\\n-  do_klass(vector_VectorPayloadMF512L_klass,            jdk_internal_vm_vector_VectorPayloadMF512L            ) \\\n-  do_klass(vector_VectorPayloadMF64F_klass,             jdk_internal_vm_vector_VectorPayloadMF64F             ) \\\n-  do_klass(vector_VectorPayloadMF128F_klass,            jdk_internal_vm_vector_VectorPayloadMF128F            ) \\\n-  do_klass(vector_VectorPayloadMF256F_klass,            jdk_internal_vm_vector_VectorPayloadMF256F            ) \\\n-  do_klass(vector_VectorPayloadMF512F_klass,            jdk_internal_vm_vector_VectorPayloadMF512F            ) \\\n-  do_klass(vector_VectorPayloadMF64D_klass,             jdk_internal_vm_vector_VectorPayloadMF64D             ) \\\n-  do_klass(vector_VectorPayloadMF128D_klass,            jdk_internal_vm_vector_VectorPayloadMF128D            ) \\\n-  do_klass(vector_VectorPayloadMF256D_klass,            jdk_internal_vm_vector_VectorPayloadMF256D            ) \\\n-  do_klass(vector_VectorPayloadMF512D_klass,            jdk_internal_vm_vector_VectorPayloadMF512D            ) \\\n-                                                                                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -188,2 +188,0 @@\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-  template(jdk_internal_vm_vector_VectorPayload,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\")       \\\n@@ -99,0 +98,1 @@\n+  template(jdk_internal_vm_vector_VectorPayload,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\")       \\\n@@ -134,0 +134,14 @@\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxB\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxS, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxS\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxI, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxI\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxL, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxL\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxF, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxF\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxD, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxD\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxBZ, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxBZ\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxSZ, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxSZ\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxIZ, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxIZ\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxLZ, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxLZ\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxBB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxBB\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxSB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxSB\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxIB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxIB\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxLB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxLB\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -462,0 +462,36 @@\n+int VectorSupport::get_max_multifield_count(const Symbol* payload_name) {\n+  assert(payload_name, \"\");\n+  vmSymbolID sid = vmSymbols::find_sid(payload_name);\n+  int size = VM_Version::max_vector_size(T_BYTE);\n+  switch(sid) {\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxB_enum:\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxBZ_enum:\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxBB_enum:\n+       return size;\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxS_enum:\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxSZ_enum:\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxSB_enum:\n+       return size \/ type2aelembytes(T_SHORT);\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxI_enum:\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxIZ_enum:\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxIB_enum:\n+       return size \/ type2aelembytes(T_INT);\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxL_enum:\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxLZ_enum:\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxLB_enum:\n+       return size \/ type2aelembytes(T_LONG);\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxF_enum:\n+       return size \/ type2aelembytes(T_FLOAT);\n+    case vmSymbolID::jdk_internal_vm_vector_VectorPayloadMFMaxD_enum:\n+       return size \/ type2aelembytes(T_DOUBLE);\n+    default  : fatal(\"unknown symbol\"); return -1;\n+  }\n+}\n+\n+int VectorSupport::max_vector_size(BasicType bt) {\n+  if (is_java_primitive(bt)) {\n+    return VM_Version::max_vector_size(bt);\n+  }\n+  return -1;\n+}\n+\n@@ -467,1 +503,0 @@\n-#ifdef COMPILER2\n@@ -469,6 +504,2 @@\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    BasicType bt = java_lang_Class::primitive_type(mirror);\n-    return Matcher::max_vector_size(bt);\n-  }\n-#endif \/\/ COMPILER2\n-  return -1;\n+  BasicType bt = java_lang_Class::primitive_type(mirror);\n+  return VectorSupport::max_vector_size(bt);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+  static int  max_vector_size(BasicType bt);\n+  static int  get_max_multifield_count(const Symbol* payload_name);\n+  static bool is_vector_payload(const Symbol* metadata);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,2 +169,2 @@\n-        public static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n-            if (elemType == boolean.class) {\n+        public static VectorPayloadMF newMaskInstanceFactory(Class<?> elemType, int length, boolean max_payload) {\n+            if (false == max_payload) {\n@@ -181,1 +181,22 @@\n-            } else if (elemType == byte.class) {\n+            } else {\n+                if (elemType == byte.class) {\n+                   return new VectorPayloadMFMaxBZ();\n+                } else if (elemType == short.class) {\n+                   return new VectorPayloadMFMaxSZ();\n+                } else if (elemType == int.class) {\n+                   return new VectorPayloadMFMaxIZ();\n+                } else if (elemType == long.class) {\n+                   return new VectorPayloadMFMaxLZ();\n+                } else if (elemType == float.class) {\n+                   return new VectorPayloadMFMaxIZ();\n+                } else {\n+                   assert elemType == double.class;\n+                   return new VectorPayloadMFMaxLZ();\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF newShuffleInstanceFactory(Class<?> elemType, int length, boolean max_payload) {\n+            if (false == max_payload) {\n@@ -190,1 +211,1 @@\n-                    default: assert false : \"Unhandled vector size\";\n+                    default: assert false : \"Unhandled vector shuffle size\";\n@@ -192,23 +213,14 @@\n-            } else if (elemType == short.class) {\n-                switch(length) {\n-                    case  4: return new VectorPayloadMF64S();\n-                    case  8: return new VectorPayloadMF128S();\n-                    case 16: return new VectorPayloadMF256S();\n-                    case 32: return new VectorPayloadMF512S();\n-                    default: assert false : \"Unhandled vector size\";\n-                }\n-            } else if (elemType == int.class) {\n-                switch(length) {\n-                    case  2: return new VectorPayloadMF64I();\n-                    case  4: return new VectorPayloadMF128I();\n-                    case  8: return new VectorPayloadMF256I();\n-                    case 16: return new VectorPayloadMF512I();\n-                    default: assert false : \"Unhandled vector size\";\n-                }\n-            } else if (elemType == long.class) {\n-                switch(length) {\n-                    case  1: return new VectorPayloadMF64L();\n-                    case  2: return new VectorPayloadMF128L();\n-                    case  4: return new VectorPayloadMF256L();\n-                    case  8: return new VectorPayloadMF512L();\n-                    default: assert false : \"Unhandled vector size\";\n+            } else {\n+                if (elemType == byte.class) {\n+                   return new VectorPayloadMFMaxBB();\n+                } else if (elemType == short.class) {\n+                   return new VectorPayloadMFMaxSB();\n+                } else if (elemType == int.class) {\n+                   return new VectorPayloadMFMaxIB();\n+                } else if (elemType == long.class) {\n+                   return new VectorPayloadMFMaxLB();\n+                } else if (elemType == float.class) {\n+                   return new VectorPayloadMFMaxIB();\n+                } else {\n+                   assert elemType == double.class;\n+                   return new VectorPayloadMFMaxLB();\n@@ -216,7 +228,56 @@\n-            } else if (elemType == float.class) {\n-                switch(length) {\n-                    case  2: return new VectorPayloadMF64F();\n-                    case  4: return new VectorPayloadMF128F();\n-                    case  8: return new VectorPayloadMF256F();\n-                    case 16: return new VectorPayloadMF512F();\n-                    default: assert false : \"Unhandled vector size\";\n+            }\n+            return null;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF newVectorInstanceFactory(Class<?> elemType, int length, boolean max_payload) {\n+            if (false == max_payload) {\n+                if (elemType == byte.class) {\n+                    switch(length) {\n+                        case  8: return new VectorPayloadMF64B();\n+                        case 16: return new VectorPayloadMF128B();\n+                        case 32: return new VectorPayloadMF256B();\n+                        case 64: return new VectorPayloadMF512B();\n+                        default: assert false : \"Unhandled vector size\";\n+                    }\n+                } else if (elemType == short.class) {\n+                    switch(length) {\n+                        case  4: return new VectorPayloadMF64S();\n+                        case  8: return new VectorPayloadMF128S();\n+                        case 16: return new VectorPayloadMF256S();\n+                        case 32: return new VectorPayloadMF512S();\n+                        default: assert false : \"Unhandled vector size\";\n+                    }\n+                } else if (elemType == int.class) {\n+                    switch(length) {\n+                        case  2: return new VectorPayloadMF64I();\n+                        case  4: return new VectorPayloadMF128I();\n+                        case  8: return new VectorPayloadMF256I();\n+                        case 16: return new VectorPayloadMF512I();\n+                        default: assert false : \"Unhandled vector size\";\n+                    }\n+                } else if (elemType == long.class) {\n+                    switch(length) {\n+                        case  1: return new VectorPayloadMF64L();\n+                        case  2: return new VectorPayloadMF128L();\n+                        case  4: return new VectorPayloadMF256L();\n+                        case  8: return new VectorPayloadMF512L();\n+                        default: assert false : \"Unhandled vector size\";\n+                    }\n+                } else if (elemType == float.class) {\n+                    switch(length) {\n+                        case  2: return new VectorPayloadMF64F();\n+                        case  4: return new VectorPayloadMF128F();\n+                        case  8: return new VectorPayloadMF256F();\n+                        case 16: return new VectorPayloadMF512F();\n+                        default: assert false : \"Unhandled vector size\";\n+                    }\n+                } else {\n+                    assert elemType == double.class;\n+                    switch(length) {\n+                        case  1: return new VectorPayloadMF64D();\n+                        case  2: return new VectorPayloadMF128D();\n+                        case  4: return new VectorPayloadMF256D();\n+                        case  8: return new VectorPayloadMF512D();\n+                        default: assert false : \"Unhandled vector size\";\n+                    }\n@@ -225,7 +286,13 @@\n-                assert elemType == double.class;\n-                switch(length) {\n-                    case  1: return new VectorPayloadMF64D();\n-                    case  2: return new VectorPayloadMF128D();\n-                    case  4: return new VectorPayloadMF256D();\n-                    case  8: return new VectorPayloadMF512D();\n-                    default: assert false : \"Unhandled vector size\";\n+                if (elemType == byte.class) {\n+                    return new VectorPayloadMFMaxB();\n+                } else if (elemType == short.class) {\n+                    return new VectorPayloadMFMaxS();\n+                } else if (elemType == int.class) {\n+                    return new VectorPayloadMFMaxI();\n+                } else if (elemType == long.class) {\n+                    return new VectorPayloadMFMaxL();\n+                } else if (elemType == float.class) {\n+                    return new VectorPayloadMFMaxF();\n+                } else {\n+                    assert elemType == double.class;\n+                    return new VectorPayloadMFMaxD();\n@@ -238,2 +305,2 @@\n-        public static VectorPayloadMF createVectPayloadInstanceB(int length, byte [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(byte.class, length);\n+        public static VectorPayloadMF createVectPayloadInstanceB(int length, byte [] init, boolean max_payload) {\n+            VectorPayloadMF obj = newVectorInstanceFactory(byte.class, length, max_payload);\n@@ -250,2 +317,2 @@\n-        public static VectorPayloadMF createVectPayloadInstanceS(int length, short [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(short.class, length);\n+        public static VectorPayloadMF createVectPayloadInstanceS(int length, short [] init, boolean max_payload) {\n+            VectorPayloadMF obj = newVectorInstanceFactory(short.class, length, max_payload);\n@@ -262,2 +329,2 @@\n-        public static VectorPayloadMF createVectPayloadInstanceI(int length, int [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(int.class, length);\n+        public static VectorPayloadMF createVectPayloadInstanceI(int length, int [] init, boolean max_payload) {\n+            VectorPayloadMF obj = newVectorInstanceFactory(int.class, length, max_payload);\n@@ -274,2 +341,2 @@\n-        public static VectorPayloadMF createVectPayloadInstanceL(int length, long [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(long.class, length);\n+        public static VectorPayloadMF createVectPayloadInstanceL(int length, long [] init, boolean max_payload) {\n+            VectorPayloadMF obj = newVectorInstanceFactory(long.class, length, max_payload);\n@@ -286,2 +353,2 @@\n-        public static VectorPayloadMF createVectPayloadInstanceF(int length, float [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(float.class, length);\n+        public static VectorPayloadMF createVectPayloadInstanceF(int length, float [] init, boolean max_payload) {\n+            VectorPayloadMF obj = newVectorInstanceFactory(float.class, length, max_payload);\n@@ -298,2 +365,2 @@\n-        public static VectorPayloadMF createVectPayloadInstanceD(int length, double [] init) {\n-            VectorPayloadMF obj = newInstanceFactory(double.class, length);\n+        public static VectorPayloadMF createVectPayloadInstanceD(int length, double [] init, boolean max_payload) {\n+            VectorPayloadMF obj = newVectorInstanceFactory(double.class, length, max_payload);\n@@ -310,12 +377,1 @@\n-            try {\n-                var field = this.getClass().getDeclaredField(\"mfield\");\n-                var msanno = field.getAnnotationsByType(MultiField.class);\n-\n-                Objects.nonNull(msanno);\n-\n-                assert msanno.length == 1;\n-                return msanno[0].value();\n-            } catch (Exception e) {\n-                System.out.println(e);\n-            }\n-            return -1;\n+            return getClass().getDeclaredFields().length - 1;\n@@ -335,0 +391,54 @@\n+    public primitive static class VectorPayloadMFMaxB extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        byte mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxB.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxS extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        short mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxS.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxI extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        int mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxI.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxL extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        long mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxL.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxF extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        float mfield = 0.0f;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxF.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxD extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        double mfield = 0.0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxD.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n@@ -338,1 +448,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8Z.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF8Z.class);\n@@ -347,1 +457,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16Z.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF16Z.class);\n@@ -356,1 +466,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32Z.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF32Z.class);\n@@ -365,1 +475,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64Z.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64Z.class);\n@@ -374,1 +484,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128Z.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128Z.class);\n@@ -383,1 +493,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256Z.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256Z.class);\n@@ -392,1 +502,37 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512Z.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxBZ extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        boolean mfield = false;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxBZ.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxSZ extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        boolean mfield = false;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxSZ.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxIZ extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        boolean mfield = false;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxIZ.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxLZ extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        boolean mfield = false;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxLZ.class);\n@@ -401,1 +547,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8B.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF8B.class);\n@@ -410,1 +556,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16B.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF16B.class);\n@@ -419,1 +565,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32B.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF32B.class);\n@@ -428,1 +574,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64B.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64B.class);\n@@ -437,1 +583,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128B.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128B.class);\n@@ -446,1 +592,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256B.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256B.class);\n@@ -455,1 +601,37 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512B.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxBB extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        byte mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxBB.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxSB extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        byte mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxSB.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxIB extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        byte mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxIB.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMFMaxLB extends VectorPayloadMF {\n+        @MultiField(value = -1)\n+        byte mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMFMaxLB.class);\n@@ -464,1 +646,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64S.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64S.class);\n@@ -473,1 +655,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128S.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128S.class);\n@@ -482,1 +664,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256S.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256S.class);\n@@ -491,1 +673,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512S.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512S.class);\n@@ -500,1 +682,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64I.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64I.class);\n@@ -509,1 +691,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128I.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128I.class);\n@@ -518,1 +700,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256I.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256I.class);\n@@ -527,1 +709,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512I.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512I.class);\n@@ -535,2 +717,2 @@\n-        long mfield = 0;\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64L.class);\n+        final long mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64L.class);\n@@ -544,2 +726,2 @@\n-        long mfield = 0;\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128L.class);\n+        final long mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128L.class);\n@@ -553,2 +735,2 @@\n-        long mfield = 0;\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256L.class);\n+        final long mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256L.class);\n@@ -562,2 +744,2 @@\n-        long mfield = 0;\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512L.class);\n+        final long mfield = 0;\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512L.class);\n@@ -572,1 +754,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64F.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64F.class);\n@@ -581,1 +763,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128F.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128F.class);\n@@ -590,1 +772,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256F.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256F.class);\n@@ -599,1 +781,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512F.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512F.class);\n@@ -608,1 +790,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64D.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF64D.class);\n@@ -617,1 +799,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128D.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF128D.class);\n@@ -626,1 +808,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256D.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF256D.class);\n@@ -635,1 +817,1 @@\n-        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512D.class);\n+        static final long MFOFFSET = multiFieldOffset(VectorPayloadMF512D.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":285,"deletions":103,"binary":false,"changes":388,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-    static VectorPayloadMF prepare(VectorPayloadMF payload, int offset, int length) {\n-        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+    static VectorPayloadMF prepare(VectorPayloadMF payload, int offset, Class<?> elementType, int length, boolean is_max_species) {\n+        VectorPayloadMF res = VectorPayloadMF.newMaskInstanceFactory(elementType, length, is_max_species);\n@@ -56,2 +56,2 @@\n-    static VectorPayloadMF prepare(boolean val, int length) {\n-        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+    static VectorPayloadMF prepare(boolean val, Class<?> elementType, int length, boolean is_max_species) {\n+        VectorPayloadMF res = VectorPayloadMF.newMaskInstanceFactory(elementType, length, is_max_species);\n@@ -76,1 +76,2 @@\n-        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)(vspecies())).is_max_species();\n+        VectorPayloadMF res = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n@@ -97,1 +98,2 @@\n-        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)(vspecies())).is_max_species();\n+        VectorPayloadMF res = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    static VectorPayloadMF prepare(int length, int[] indices, int offset) {\n-        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+    static VectorPayloadMF prepare(Class<?> elemType, int length, int[] indices, int offset, boolean is_max_species) {\n+        VectorPayloadMF payload = VectorPayloadMF.newShuffleInstanceFactory(elemType, length, is_max_species);\n@@ -55,2 +55,2 @@\n-    static VectorPayloadMF prepare(int length, IntUnaryOperator f) {\n-        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+    static VectorPayloadMF prepare(Class<?> elemType, int length, IntUnaryOperator f, boolean is_max_species) {\n+        VectorPayloadMF payload = VectorPayloadMF.newShuffleInstanceFactory(elemType, length, is_max_species);\n@@ -142,1 +142,2 @@\n-        VectorPayloadMF indices = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        boolean is_max_species = ((AbstractSpecies)(vspecies())).is_max_species();\n+        VectorPayloadMF indices = VectorPayloadMF.newShuffleInstanceFactory(vspecies().elementType(), length, is_max_species);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -301,0 +301,2 @@\n+    boolean is_max_species() { return vectorShape().switchKey == VectorShape.SK_Max_BIT; }\n+\n@@ -323,1 +325,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(laneCount, (float[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(laneCount, (float[])initarr, is_max_species());\n@@ -326,1 +328,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(laneCount, (double[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(laneCount, (double[])initarr, is_max_species());\n@@ -329,1 +331,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(laneCount, (byte[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(laneCount, (byte[])initarr, is_max_species());\n@@ -332,1 +334,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(laneCount, (short[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(laneCount, (short[])initarr, is_max_species());\n@@ -335,1 +337,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(laneCount, (int[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(laneCount, (int[])initarr, is_max_species());\n@@ -338,1 +340,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(laneCount, (long[])initarr);\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(laneCount, (long[])initarr, is_max_species());\n@@ -357,1 +359,1 @@\n-            za = VectorPayloadMF.newInstanceFactory(elementType(), laneCount);\n+            za = VectorPayloadMF.newVectorInstanceFactory(elementType(), laneCount, is_max_species());\n@@ -511,1 +513,1 @@\n-        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(boolean.class, laneCount);\n+        VectorPayloadMF payload = VectorPayloadMF.newMaskInstanceFactory(elementType(), laneCount, is_max_species());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.newInstanceFactory(byte.class, 16));\n-    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte[])(VSPECIES.iotaArray())));\n+    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 16, false));\n+    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(VLENGTH, (byte[])(VSPECIES.iotaArray()), false));\n@@ -589,2 +589,0 @@\n-        private final VectorPayloadMF128Z payload;\n-\n@@ -595,0 +593,2 @@\n+        private final VectorPayloadMF128Z payload;\n+\n@@ -596,1 +596,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -600,1 +600,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -603,0 +603,1 @@\n+\n@@ -770,4 +771,0 @@\n-        public Byte128Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -775,1 +772,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -779,1 +776,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -782,0 +779,5 @@\n+        public Byte128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -824,1 +826,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.newInstanceFactory(byte.class, 32));\n-    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte[])(VSPECIES.iotaArray())));\n+    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 32, false));\n+    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(VLENGTH, (byte[])(VSPECIES.iotaArray()), false));\n@@ -621,2 +621,0 @@\n-        private final VectorPayloadMF256Z payload;\n-\n@@ -627,0 +625,2 @@\n+        private final VectorPayloadMF256Z payload;\n+\n@@ -628,1 +628,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -632,1 +632,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -635,0 +635,1 @@\n+\n@@ -802,4 +803,0 @@\n-        public Byte256Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -807,1 +804,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -811,1 +808,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -814,0 +811,5 @@\n+        public Byte256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -856,1 +858,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.newInstanceFactory(byte.class, 64));\n-    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte[])(VSPECIES.iotaArray())));\n+    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 64, false));\n+    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(VLENGTH, (byte[])(VSPECIES.iotaArray()), false));\n@@ -685,2 +685,0 @@\n-        private final VectorPayloadMF512Z payload;\n-\n@@ -691,0 +689,2 @@\n+        private final VectorPayloadMF512Z payload;\n+\n@@ -692,1 +692,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -696,1 +696,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -699,0 +699,1 @@\n+\n@@ -866,4 +867,0 @@\n-        public Byte512Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -871,1 +868,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -875,1 +872,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -878,0 +875,5 @@\n+        public Byte512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -920,1 +922,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.newInstanceFactory(byte.class, 8));\n-    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte[])(VSPECIES.iotaArray())));\n+    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 8, false));\n+    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(VLENGTH, (byte[])(VSPECIES.iotaArray()), false));\n@@ -573,2 +573,0 @@\n-        private final VectorPayloadMF64Z payload;\n-\n@@ -579,0 +577,2 @@\n+        private final VectorPayloadMF64Z payload;\n+\n@@ -580,1 +580,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -584,1 +584,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -587,0 +587,1 @@\n+\n@@ -754,4 +755,0 @@\n-        public Byte64Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -759,1 +756,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -763,1 +760,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -766,0 +763,5 @@\n+        public Byte64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -808,1 +810,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,892 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import jdk.internal.misc.Unsafe;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+value class ByteMaxVector extends ByteVector {\n+    static final ByteSpecies VSPECIES =\n+        (ByteSpecies) ByteVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<ByteMaxVector> VCLASS = ByteMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMFMaxB.class);\n+\n+    private final VectorPayloadMFMaxB payload;\n+\n+    ByteMaxVector(Object value) {\n+        this.payload = (VectorPayloadMFMaxB) value;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n+    }\n+\n+    static final ByteMaxVector ZERO = new ByteMaxVector(VectorPayloadMF.newVectorInstanceFactory(byte.class, 0, true));\n+    static final ByteMaxVector IOTA = new ByteMaxVector(VectorPayloadMF.createVectPayloadInstanceB(VLENGTH, (byte[])(VSPECIES.iotaArray()), true));\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVectorMF();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public ByteSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Byte> elementType() { return byte.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Byte.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n+    @Override\n+    @ForceInline\n+    public final ByteMaxVector broadcast(byte e) {\n+        return (ByteMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ByteMaxVector broadcast(long e) {\n+        return (ByteMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    ByteMaxMask maskFromPayload(VectorPayloadMF payload) {\n+        return new ByteMaxMask(payload);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    ByteMaxShuffle iotaShuffle() { return ByteMaxShuffle.IOTA; }\n+\n+    @ForceInline\n+    ByteMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    ByteMaxShuffle shuffleFromBytes(VectorPayloadMF indexes) { return new ByteMaxShuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    ByteMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ByteMaxShuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    ByteMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new ByteMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector vectorFactory(VectorPayloadMF vec) {\n+        return new ByteMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector uOpMF(FUnOp f) {\n+        return (ByteMaxVector) super.uOpTemplateMF(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector uOpMF(VectorMask<Byte> m, FUnOp f) {\n+        return (ByteMaxVector)\n+            super.uOpTemplateMF((ByteMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (ByteMaxVector) super.bOpTemplateMF((ByteMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector bOpMF(Vector<Byte> v,\n+                     VectorMask<Byte> m, FBinOp f) {\n+        return (ByteMaxVector)\n+            super.bOpTemplateMF((ByteMaxVector)v, (ByteMaxMask)m,\n+                                f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+        return (ByteMaxVector)\n+            super.tOpTemplateMF((ByteMaxVector)v1, (ByteMaxVector)v2,\n+                                f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n+                     VectorMask<Byte> m, FTriOp f) {\n+        return (ByteMaxVector)\n+            super.tOpTemplateMF((ByteMaxVector)v1, (ByteMaxVector)v2,\n+                                (ByteMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Byte,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector lanewise(Unary op) {\n+        return (ByteMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector lanewise(Unary op, VectorMask<Byte> m) {\n+        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector lanewise(Binary op, Vector<Byte> v) {\n+        return (ByteMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline ByteMaxVector\n+    lanewiseShift(VectorOperators.Binary op, int e) {\n+        return (ByteMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline ByteMaxVector\n+    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Byte> m) {\n+        return (ByteMaxVector) super.lanewiseShiftTemplate(op, ByteMaxMask.class, e, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    ByteMaxVector\n+    lanewise(Ternary op, Vector<Byte> v1, Vector<Byte> v2) {\n+        return (ByteMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    ByteMaxVector\n+    lanewise(Ternary op, Vector<Byte> v1, Vector<Byte> v2, VectorMask<Byte> m) {\n+        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v1, v2, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    ByteMaxVector addIndex(int scale) {\n+        return (ByteMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final byte reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final byte reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Byte> m) {\n+        return super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Byte> m) {\n+        return (long) super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Byte> toShuffle() {\n+        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask test(Test op) {\n+        return super.testTemplate(ByteMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(ByteMaxMask.class, op, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask compare(Comparison op, Vector<Byte> v) {\n+        return super.compareTemplate(ByteMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask compare(Comparison op, byte s) {\n+        return super.compareTemplate(ByteMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(ByteMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask compare(Comparison op, Vector<Byte> v, VectorMask<Byte> m) {\n+        return super.compareTemplate(ByteMaxMask.class, op, v, (ByteMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector blend(Vector<Byte> v, VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.blendTemplate(ByteMaxMask.class,\n+                                (ByteMaxVector) v,\n+                                (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector slice(int origin, Vector<Byte> v) {\n+        return (ByteMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector slice(int origin) {\n+        return (ByteMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector unslice(int origin, Vector<Byte> w, int part) {\n+        return (ByteMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector unslice(int origin, Vector<Byte> w, int part, VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.unsliceTemplate(ByteMaxMask.class,\n+                                  origin, w, part,\n+                                  (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector unslice(int origin) {\n+        return (ByteMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector rearrange(VectorShuffle<Byte> s) {\n+        return (ByteMaxVector)\n+            super.rearrangeTemplate(ByteMaxShuffle.class,\n+                                    (ByteMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector rearrange(VectorShuffle<Byte> shuffle,\n+                                  VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.rearrangeTemplate(ByteMaxShuffle.class,\n+                                    ByteMaxMask.class,\n+                                    (ByteMaxShuffle) shuffle,\n+                                    (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector rearrange(VectorShuffle<Byte> s,\n+                                  Vector<Byte> v) {\n+        return (ByteMaxVector)\n+            super.rearrangeTemplate(ByteMaxShuffle.class,\n+                                    (ByteMaxShuffle) s,\n+                                    (ByteMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector compress(VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.compressTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector expand(VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.expandTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector selectFrom(Vector<Byte> v) {\n+        return (ByteMaxVector)\n+            super.selectFromTemplate((ByteMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector selectFrom(Vector<Byte> v,\n+                                   VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.selectFromTemplate((ByteMaxVector) v,\n+                                     (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public byte lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return laneHelper(i);\n+    }\n+\n+    public byte laneHelper(int i) {\n+        return (byte) VectorSupport.extract(\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public ByteMaxVector withLane(int i, byte e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public ByteMaxVector withLaneHelper(int i, byte e) {\n+       return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final value class ByteMaxMask extends AbstractMask<Byte> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+\n+        ByteMaxMask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxBZ) payload;\n+        }\n+\n+        private final VectorPayloadMFMaxBZ payload;\n+\n+        ByteMaxMask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, ETYPE, VLENGTH, true));\n+        }\n+\n+        ByteMaxMask(boolean val) {\n+            this(prepare(val, ETYPE, VLENGTH, true));\n+        }\n+\n+\n+        @ForceInline\n+        final @Override\n+        public ByteSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        final VectorPayloadMF getBits() {\n+            return payload;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        ByteMaxVector toVector() {\n+            return (ByteMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        ByteMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (ByteMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                ByteMaxMask.class, byte.class, VLENGTH, offset, limit,\n+                (o, l) -> (ByteMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public ByteMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public ByteMaxMask compress() {\n+            return (ByteMaxMask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public ByteMaxMask and(VectorMask<Byte> mask) {\n+            Objects.requireNonNull(mask);\n+            ByteMaxMask m = (ByteMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (ByteMaxMask) m1.bOpMF(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public ByteMaxMask or(VectorMask<Byte> mask) {\n+            Objects.requireNonNull(mask);\n+            ByteMaxMask m = (ByteMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (ByteMaxMask) m1.bOpMF(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public ByteMaxMask xor(VectorMask<Byte> mask) {\n+            Objects.requireNonNull(mask);\n+            ByteMaxMask m = (ByteMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (ByteMaxMask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, VLENGTH, this,\n+                                                            (m) -> ((ByteMaxMask) m).trueCountHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n+                                                            (m) -> ((ByteMaxMask) m).firstTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n+                                                            (m) -> ((ByteMaxMask) m).lastTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> ((ByteMaxMask) m).toLongHelper());\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(ByteMaxMask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((ByteMaxMask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((ByteMaxMask) m).anyTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((ByteMaxMask) m).allTrueHelper());\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static ByteMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final ByteMaxMask  TRUE_MASK = new ByteMaxMask(true);\n+        private static final ByteMaxMask FALSE_MASK = new ByteMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final value class ByteMaxShuffle extends AbstractShuffle<Byte> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+\n+        private final VectorPayloadMFMaxBB payload;\n+\n+        ByteMaxShuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxBB) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public ByteMaxShuffle(int[] indexes, int i) {\n+            this(prepare(ETYPE, VLENGTH, indexes, i, true));\n+        }\n+\n+        public ByteMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(ETYPE, VLENGTH, fn, true));\n+        }\n+\n+        public ByteMaxShuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n+        }\n+\n+        @Override\n+        public ByteSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final ByteMaxShuffle IOTA = new ByteMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public ByteMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((ByteMaxVector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n+            ByteMaxShuffle s = (ByteMaxShuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, true);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n+            }\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new ByteMaxShuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m, int offsetInRange) {\n+        return super.fromArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n+        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m, int offsetInRange) {\n+        return super.fromBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(byte[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        super.intoArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        super.intoBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":892,"deletions":0,"binary":false,"changes":892,"status":"added"},{"patch":"@@ -375,0 +375,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -376,2 +377,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                byte.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                byte.class, length, is_max_species));\n@@ -393,0 +394,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -394,2 +396,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                byte.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                byte.class, length, is_max_species));\n@@ -420,0 +422,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -421,2 +424,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                byte.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                byte.class, length, is_max_species));\n@@ -438,0 +441,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -439,2 +443,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                byte.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                byte.class, length, is_max_species));\n@@ -548,1 +552,2 @@\n-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n@@ -4434,3 +4439,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n-            \/\/    return ByteMaxVector.ZERO;\n+            if ((Class<?>) vectorType() == ByteMaxVector.class)\n+               return ByteMaxVector.ZERO;\n@@ -4449,3 +4453,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n-            \/\/    return ByteMaxVector.IOTA;\n+            if ((Class<?>) vectorType() == ByteMaxVector.class)\n+                return ByteMaxVector.IOTA;\n@@ -4465,3 +4468,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n-            \/\/    return ByteMaxVector.ByteMaxMask.maskAll(bit);\n+            if ((Class<?>) vectorType() == ByteMaxVector.class)\n+                return ByteMaxVector.ByteMaxMask.maskAll(bit);\n@@ -4502,2 +4504,1 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n+            case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n@@ -4537,2 +4538,1 @@\n-    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-    \/*public static final VectorSpecies<Byte> SPECIES_MAX\n+    public static final VectorSpecies<Byte> SPECIES_MAX\n@@ -4543,1 +4543,0 @@\n-     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.newInstanceFactory(double.class, 2));\n-    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double[])(VSPECIES.iotaArray())));\n+    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.newVectorInstanceFactory(double.class, 2, false));\n+    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(VLENGTH, (double[])(VSPECIES.iotaArray()), false));\n@@ -550,2 +550,0 @@\n-        private final VectorPayloadMF16Z payload;\n-\n@@ -556,0 +554,2 @@\n+        private final VectorPayloadMF16Z payload;\n+\n@@ -557,1 +557,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -561,1 +561,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -564,0 +564,1 @@\n+\n@@ -731,4 +732,0 @@\n-        public Double128Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -736,1 +733,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -740,1 +737,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -743,0 +740,5 @@\n+        public Double128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -785,1 +787,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.newInstanceFactory(double.class, 4));\n-    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double[])(VSPECIES.iotaArray())));\n+    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.newVectorInstanceFactory(double.class, 4, false));\n+    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(VLENGTH, (double[])(VSPECIES.iotaArray()), false));\n@@ -554,2 +554,0 @@\n-        private final VectorPayloadMF32Z payload;\n-\n@@ -560,0 +558,2 @@\n+        private final VectorPayloadMF32Z payload;\n+\n@@ -561,1 +561,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -565,1 +565,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -568,0 +568,1 @@\n+\n@@ -735,4 +736,0 @@\n-        public Double256Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -740,1 +737,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -744,1 +741,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -747,0 +744,5 @@\n+        public Double256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -789,1 +791,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.newInstanceFactory(double.class, 8));\n-    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double[])(VSPECIES.iotaArray())));\n+    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.newVectorInstanceFactory(double.class, 8, false));\n+    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(VLENGTH, (double[])(VSPECIES.iotaArray()), false));\n@@ -562,2 +562,0 @@\n-        private final VectorPayloadMF64Z payload;\n-\n@@ -568,0 +566,2 @@\n+        private final VectorPayloadMF64Z payload;\n+\n@@ -569,1 +569,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -573,1 +573,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -576,0 +576,1 @@\n+\n@@ -743,4 +744,0 @@\n-        public Double512Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -748,1 +745,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -752,1 +749,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -755,0 +752,5 @@\n+        public Double512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -797,1 +799,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.newInstanceFactory(double.class, 1));\n-    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double[])(VSPECIES.iotaArray())));\n+    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.newVectorInstanceFactory(double.class, 1, false));\n+    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(VLENGTH, (double[])(VSPECIES.iotaArray()), false));\n@@ -548,2 +548,0 @@\n-        private final VectorPayloadMF8Z payload;\n-\n@@ -554,0 +552,2 @@\n+        private final VectorPayloadMF8Z payload;\n+\n@@ -555,1 +555,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -559,1 +559,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -562,0 +562,1 @@\n+\n@@ -729,4 +730,0 @@\n-        public Double64Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -734,1 +731,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -738,1 +735,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -741,0 +738,5 @@\n+        public Double64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -783,1 +785,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,873 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import jdk.internal.misc.Unsafe;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+value class DoubleMaxVector extends DoubleVector {\n+    static final DoubleSpecies VSPECIES =\n+        (DoubleSpecies) DoubleVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<DoubleMaxVector> VCLASS = DoubleMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMFMaxD.class);\n+\n+    private final VectorPayloadMFMaxD payload;\n+\n+    DoubleMaxVector(Object value) {\n+        this.payload = (VectorPayloadMFMaxD) value;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n+    }\n+\n+    static final DoubleMaxVector ZERO = new DoubleMaxVector(VectorPayloadMF.newVectorInstanceFactory(double.class, 0, true));\n+    static final DoubleMaxVector IOTA = new DoubleMaxVector(VectorPayloadMF.createVectPayloadInstanceD(VLENGTH, (double[])(VSPECIES.iotaArray()), true));\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVectorMF();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public DoubleSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Double> elementType() { return double.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Double.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxVector broadcast(double e) {\n+        return (DoubleMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxVector broadcast(long e) {\n+        return (DoubleMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    DoubleMaxMask maskFromPayload(VectorPayloadMF payload) {\n+        return new DoubleMaxMask(payload);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    DoubleMaxShuffle iotaShuffle() { return DoubleMaxShuffle.IOTA; }\n+\n+    @ForceInline\n+    DoubleMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    DoubleMaxShuffle shuffleFromBytes(VectorPayloadMF indexes) { return new DoubleMaxShuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    DoubleMaxShuffle shuffleFromArray(int[] indexes, int i) { return new DoubleMaxShuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    DoubleMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new DoubleMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    DoubleMaxVector vectorFactory(VectorPayloadMF vec) {\n+        return new DoubleMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    DoubleMaxVector uOpMF(FUnOp f) {\n+        return (DoubleMaxVector) super.uOpTemplateMF(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    DoubleMaxVector uOpMF(VectorMask<Double> m, FUnOp f) {\n+        return (DoubleMaxVector)\n+            super.uOpTemplateMF((DoubleMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    DoubleMaxVector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (DoubleMaxVector) super.bOpTemplateMF((DoubleMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    DoubleMaxVector bOpMF(Vector<Double> v,\n+                     VectorMask<Double> m, FBinOp f) {\n+        return (DoubleMaxVector)\n+            super.bOpTemplateMF((DoubleMaxVector)v, (DoubleMaxMask)m,\n+                                f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    DoubleMaxVector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+        return (DoubleMaxVector)\n+            super.tOpTemplateMF((DoubleMaxVector)v1, (DoubleMaxVector)v2,\n+                                f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    DoubleMaxVector tOpMF(Vector<Double> v1, Vector<Double> v2,\n+                     VectorMask<Double> m, FTriOp f) {\n+        return (DoubleMaxVector)\n+            super.tOpTemplateMF((DoubleMaxVector)v1, (DoubleMaxVector)v2,\n+                                (DoubleMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Double,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector lanewise(Unary op) {\n+        return (DoubleMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector lanewise(Unary op, VectorMask<Double> m) {\n+        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector lanewise(Binary op, Vector<Double> v) {\n+        return (DoubleMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n+        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    DoubleMaxVector\n+    lanewise(Ternary op, Vector<Double> v1, Vector<Double> v2) {\n+        return (DoubleMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    DoubleMaxVector\n+    lanewise(Ternary op, Vector<Double> v1, Vector<Double> v2, VectorMask<Double> m) {\n+        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v1, v2, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    DoubleMaxVector addIndex(int scale) {\n+        return (DoubleMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final double reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final double reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Double> m) {\n+        return super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Double> m) {\n+        return (long) super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Double> toShuffle() {\n+        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask test(Test op) {\n+        return super.testTemplate(DoubleMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(DoubleMaxMask.class, op, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask compare(Comparison op, Vector<Double> v) {\n+        return super.compareTemplate(DoubleMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask compare(Comparison op, double s) {\n+        return super.compareTemplate(DoubleMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(DoubleMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask compare(Comparison op, Vector<Double> v, VectorMask<Double> m) {\n+        return super.compareTemplate(DoubleMaxMask.class, op, v, (DoubleMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector blend(Vector<Double> v, VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.blendTemplate(DoubleMaxMask.class,\n+                                (DoubleMaxVector) v,\n+                                (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector slice(int origin, Vector<Double> v) {\n+        return (DoubleMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector slice(int origin) {\n+        return (DoubleMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector unslice(int origin, Vector<Double> w, int part) {\n+        return (DoubleMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector unslice(int origin, Vector<Double> w, int part, VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.unsliceTemplate(DoubleMaxMask.class,\n+                                  origin, w, part,\n+                                  (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector unslice(int origin) {\n+        return (DoubleMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector rearrange(VectorShuffle<Double> s) {\n+        return (DoubleMaxVector)\n+            super.rearrangeTemplate(DoubleMaxShuffle.class,\n+                                    (DoubleMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector rearrange(VectorShuffle<Double> shuffle,\n+                                  VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.rearrangeTemplate(DoubleMaxShuffle.class,\n+                                    DoubleMaxMask.class,\n+                                    (DoubleMaxShuffle) shuffle,\n+                                    (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector rearrange(VectorShuffle<Double> s,\n+                                  Vector<Double> v) {\n+        return (DoubleMaxVector)\n+            super.rearrangeTemplate(DoubleMaxShuffle.class,\n+                                    (DoubleMaxShuffle) s,\n+                                    (DoubleMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector compress(VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.compressTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector expand(VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.expandTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector selectFrom(Vector<Double> v) {\n+        return (DoubleMaxVector)\n+            super.selectFromTemplate((DoubleMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector selectFrom(Vector<Double> v,\n+                                   VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.selectFromTemplate((DoubleMaxVector) v,\n+                                     (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public double lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        long bits = laneHelper(i);\n+        return Double.longBitsToDouble(bits);\n+    }\n+\n+    public long laneHelper(int i) {\n+        return (long) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public DoubleMaxVector withLane(int i, double e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public DoubleMaxVector withLaneHelper(int i, double e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Double.doubleToLongBits(e),\n+                                (v, ix, bits) -> {\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final value class DoubleMaxMask extends AbstractMask<Double> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+\n+        DoubleMaxMask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxLZ) payload;\n+        }\n+\n+        private final VectorPayloadMFMaxLZ payload;\n+\n+        DoubleMaxMask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, ETYPE, VLENGTH, true));\n+        }\n+\n+        DoubleMaxMask(boolean val) {\n+            this(prepare(val, ETYPE, VLENGTH, true));\n+        }\n+\n+\n+        @ForceInline\n+        final @Override\n+        public DoubleSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        final VectorPayloadMF getBits() {\n+            return payload;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        DoubleMaxVector toVector() {\n+            return (DoubleMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        DoubleMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (DoubleMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                DoubleMaxMask.class, double.class, VLENGTH, offset, limit,\n+                (o, l) -> (DoubleMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public DoubleMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public DoubleMaxMask compress() {\n+            return (DoubleMaxMask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public DoubleMaxMask and(VectorMask<Double> mask) {\n+            Objects.requireNonNull(mask);\n+            DoubleMaxMask m = (DoubleMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (DoubleMaxMask) m1.bOpMF(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public DoubleMaxMask or(VectorMask<Double> mask) {\n+            Objects.requireNonNull(mask);\n+            DoubleMaxMask m = (DoubleMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (DoubleMaxMask) m1.bOpMF(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public DoubleMaxMask xor(VectorMask<Double> mask) {\n+            Objects.requireNonNull(mask);\n+            DoubleMaxMask m = (DoubleMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (DoubleMaxMask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, VLENGTH, this,\n+                                                            (m) -> ((DoubleMaxMask) m).trueCountHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n+                                                            (m) -> ((DoubleMaxMask) m).firstTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n+                                                            (m) -> ((DoubleMaxMask) m).lastTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, VLENGTH, this,\n+                                                      (m) -> ((DoubleMaxMask) m).toLongHelper());\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(DoubleMaxMask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((DoubleMaxMask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((DoubleMaxMask) m).anyTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((DoubleMaxMask) m).allTrueHelper());\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static DoubleMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final DoubleMaxMask  TRUE_MASK = new DoubleMaxMask(true);\n+        private static final DoubleMaxMask FALSE_MASK = new DoubleMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final value class DoubleMaxShuffle extends AbstractShuffle<Double> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+\n+        private final VectorPayloadMFMaxLB payload;\n+\n+        DoubleMaxShuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxLB) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public DoubleMaxShuffle(int[] indexes, int i) {\n+            this(prepare(ETYPE, VLENGTH, indexes, i, true));\n+        }\n+\n+        public DoubleMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(ETYPE, VLENGTH, fn, true));\n+        }\n+\n+        public DoubleMaxShuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n+        }\n+\n+        @Override\n+        public DoubleSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final DoubleMaxShuffle IOTA = new DoubleMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public DoubleMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((DoubleMaxVector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n+            DoubleMaxShuffle s = (DoubleMaxShuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, true);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n+            }\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new DoubleMaxShuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromArray0(double[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m, int offsetInRange) {\n+        return super.fromArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n+        return super.fromArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(double[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(double[] a, int offset, VectorMask<Double> m) {\n+        super.intoArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n+        super.intoArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":873,"deletions":0,"binary":false,"changes":873,"status":"added"},{"patch":"@@ -375,0 +375,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -376,2 +377,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                double.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                double.class, length, is_max_species));\n@@ -393,0 +394,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -394,2 +396,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                double.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                double.class, length, is_max_species));\n@@ -420,0 +422,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -421,2 +424,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                double.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                double.class, length, is_max_species));\n@@ -438,0 +441,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -439,2 +443,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                double.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                double.class, length, is_max_species));\n@@ -548,1 +552,2 @@\n-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n@@ -2976,1 +2981,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -2979,2 +2984,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3271,1 +3274,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -3274,2 +3277,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3467,1 +3468,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -3470,2 +3471,0 @@\n-             *\/\n-            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3584,1 +3583,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -3587,3 +3586,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n-\n@@ -4038,3 +4034,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-            \/\/    return DoubleMaxVector.ZERO;\n+            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+               return DoubleMaxVector.ZERO;\n@@ -4053,3 +4048,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-            \/\/    return DoubleMaxVector.IOTA;\n+            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+                return DoubleMaxVector.IOTA;\n@@ -4069,3 +4063,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-            \/\/    return DoubleMaxVector.DoubleMaxMask.maskAll(bit);\n+            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+                return DoubleMaxVector.DoubleMaxMask.maskAll(bit);\n@@ -4106,2 +4099,1 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n+            case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n@@ -4141,2 +4133,1 @@\n-    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-    \/*public static final VectorSpecies<Double> SPECIES_MAX\n+    public static final VectorSpecies<Double> SPECIES_MAX\n@@ -4147,1 +4138,0 @@\n-     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":26,"deletions":36,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.newInstanceFactory(float.class, 4));\n-    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float[])(VSPECIES.iotaArray())));\n+    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.newVectorInstanceFactory(float.class, 4, false));\n+    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(VLENGTH, (float[])(VSPECIES.iotaArray()), false));\n@@ -554,2 +554,0 @@\n-        private final VectorPayloadMF32Z payload;\n-\n@@ -560,0 +558,2 @@\n+        private final VectorPayloadMF32Z payload;\n+\n@@ -561,1 +561,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -565,1 +565,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -568,0 +568,1 @@\n+\n@@ -735,4 +736,0 @@\n-        public Float128Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -740,1 +737,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -744,1 +741,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -747,0 +744,5 @@\n+        public Float128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -789,1 +791,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.newInstanceFactory(float.class, 8));\n-    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float[])(VSPECIES.iotaArray())));\n+    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.newVectorInstanceFactory(float.class, 8, false));\n+    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(VLENGTH, (float[])(VSPECIES.iotaArray()), false));\n@@ -562,2 +562,0 @@\n-        private final VectorPayloadMF64Z payload;\n-\n@@ -568,0 +566,2 @@\n+        private final VectorPayloadMF64Z payload;\n+\n@@ -569,1 +569,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -573,1 +573,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -576,0 +576,1 @@\n+\n@@ -743,4 +744,0 @@\n-        public Float256Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -748,1 +745,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -752,1 +749,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -755,0 +752,5 @@\n+        public Float256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -797,1 +799,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.newInstanceFactory(float.class, 16));\n-    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float[])(VSPECIES.iotaArray())));\n+    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.newVectorInstanceFactory(float.class, 16, false));\n+    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(VLENGTH, (float[])(VSPECIES.iotaArray()), false));\n@@ -578,2 +578,0 @@\n-        private final VectorPayloadMF128Z payload;\n-\n@@ -584,0 +582,2 @@\n+        private final VectorPayloadMF128Z payload;\n+\n@@ -585,1 +585,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -589,1 +589,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -592,0 +592,1 @@\n+\n@@ -759,4 +760,0 @@\n-        public Float512Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -764,1 +761,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -768,1 +765,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -771,0 +768,5 @@\n+        public Float512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -813,1 +815,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.newInstanceFactory(float.class, 2));\n-    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float[])(VSPECIES.iotaArray())));\n+    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.newVectorInstanceFactory(float.class, 2, false));\n+    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(VLENGTH, (float[])(VSPECIES.iotaArray()), false));\n@@ -550,2 +550,0 @@\n-        private final VectorPayloadMF16Z payload;\n-\n@@ -556,0 +554,2 @@\n+        private final VectorPayloadMF16Z payload;\n+\n@@ -557,1 +557,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -561,1 +561,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -564,0 +564,1 @@\n+\n@@ -731,4 +732,0 @@\n-        public Float64Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -736,1 +733,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -740,1 +737,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -743,0 +740,5 @@\n+        public Float64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -785,1 +787,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,873 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import jdk.internal.misc.Unsafe;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+value class FloatMaxVector extends FloatVector {\n+    static final FloatSpecies VSPECIES =\n+        (FloatSpecies) FloatVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<FloatMaxVector> VCLASS = FloatMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMFMaxF.class);\n+\n+    private final VectorPayloadMFMaxF payload;\n+\n+    FloatMaxVector(Object value) {\n+        this.payload = (VectorPayloadMFMaxF) value;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n+    }\n+\n+    static final FloatMaxVector ZERO = new FloatMaxVector(VectorPayloadMF.newVectorInstanceFactory(float.class, 0, true));\n+    static final FloatMaxVector IOTA = new FloatMaxVector(VectorPayloadMF.createVectPayloadInstanceF(VLENGTH, (float[])(VSPECIES.iotaArray()), true));\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVectorMF();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public FloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float> elementType() { return float.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n+    @Override\n+    @ForceInline\n+    public final FloatMaxVector broadcast(float e) {\n+        return (FloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final FloatMaxVector broadcast(long e) {\n+        return (FloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    FloatMaxMask maskFromPayload(VectorPayloadMF payload) {\n+        return new FloatMaxMask(payload);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    FloatMaxShuffle iotaShuffle() { return FloatMaxShuffle.IOTA; }\n+\n+    @ForceInline\n+    FloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    FloatMaxShuffle shuffleFromBytes(VectorPayloadMF indexes) { return new FloatMaxShuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    FloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new FloatMaxShuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    FloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new FloatMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    FloatMaxVector vectorFactory(VectorPayloadMF vec) {\n+        return new FloatMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    FloatMaxVector uOpMF(FUnOp f) {\n+        return (FloatMaxVector) super.uOpTemplateMF(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    FloatMaxVector uOpMF(VectorMask<Float> m, FUnOp f) {\n+        return (FloatMaxVector)\n+            super.uOpTemplateMF((FloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    FloatMaxVector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (FloatMaxVector) super.bOpTemplateMF((FloatMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    FloatMaxVector bOpMF(Vector<Float> v,\n+                     VectorMask<Float> m, FBinOp f) {\n+        return (FloatMaxVector)\n+            super.bOpTemplateMF((FloatMaxVector)v, (FloatMaxMask)m,\n+                                f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    FloatMaxVector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+        return (FloatMaxVector)\n+            super.tOpTemplateMF((FloatMaxVector)v1, (FloatMaxVector)v2,\n+                                f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    FloatMaxVector tOpMF(Vector<Float> v1, Vector<Float> v2,\n+                     VectorMask<Float> m, FTriOp f) {\n+        return (FloatMaxVector)\n+            super.tOpTemplateMF((FloatMaxVector)v1, (FloatMaxVector)v2,\n+                                (FloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector lanewise(Unary op) {\n+        return (FloatMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector lanewise(Unary op, VectorMask<Float> m) {\n+        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector lanewise(Binary op, Vector<Float> v) {\n+        return (FloatMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n+        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    FloatMaxVector\n+    lanewise(Ternary op, Vector<Float> v1, Vector<Float> v2) {\n+        return (FloatMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    FloatMaxVector\n+    lanewise(Ternary op, Vector<Float> v1, Vector<Float> v2, VectorMask<Float> m) {\n+        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v1, v2, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    FloatMaxVector addIndex(int scale) {\n+        return (FloatMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final float reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final float reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float> m) {\n+        return super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float> m) {\n+        return (long) super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Float> toShuffle() {\n+        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask test(Test op) {\n+        return super.testTemplate(FloatMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(FloatMaxMask.class, op, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask compare(Comparison op, Vector<Float> v) {\n+        return super.compareTemplate(FloatMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask compare(Comparison op, float s) {\n+        return super.compareTemplate(FloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(FloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask compare(Comparison op, Vector<Float> v, VectorMask<Float> m) {\n+        return super.compareTemplate(FloatMaxMask.class, op, v, (FloatMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector blend(Vector<Float> v, VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.blendTemplate(FloatMaxMask.class,\n+                                (FloatMaxVector) v,\n+                                (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector slice(int origin, Vector<Float> v) {\n+        return (FloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector slice(int origin) {\n+        return (FloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector unslice(int origin, Vector<Float> w, int part) {\n+        return (FloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector unslice(int origin, Vector<Float> w, int part, VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.unsliceTemplate(FloatMaxMask.class,\n+                                  origin, w, part,\n+                                  (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector unslice(int origin) {\n+        return (FloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector rearrange(VectorShuffle<Float> s) {\n+        return (FloatMaxVector)\n+            super.rearrangeTemplate(FloatMaxShuffle.class,\n+                                    (FloatMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector rearrange(VectorShuffle<Float> shuffle,\n+                                  VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.rearrangeTemplate(FloatMaxShuffle.class,\n+                                    FloatMaxMask.class,\n+                                    (FloatMaxShuffle) shuffle,\n+                                    (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector rearrange(VectorShuffle<Float> s,\n+                                  Vector<Float> v) {\n+        return (FloatMaxVector)\n+            super.rearrangeTemplate(FloatMaxShuffle.class,\n+                                    (FloatMaxShuffle) s,\n+                                    (FloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector compress(VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.compressTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector expand(VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.expandTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector selectFrom(Vector<Float> v) {\n+        return (FloatMaxVector)\n+            super.selectFromTemplate((FloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector selectFrom(Vector<Float> v,\n+                                   VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.selectFromTemplate((FloatMaxVector) v,\n+                                     (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public float lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        int bits = laneHelper(i);\n+        return Float.intBitsToFloat(bits);\n+    }\n+\n+    public int laneHelper(int i) {\n+        return (int) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public FloatMaxVector withLane(int i, float e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public FloatMaxVector withLaneHelper(int i, float e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Float.floatToIntBits(e),\n+                                (v, ix, bits) -> {\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final value class FloatMaxMask extends AbstractMask<Float> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+\n+        FloatMaxMask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxIZ) payload;\n+        }\n+\n+        private final VectorPayloadMFMaxIZ payload;\n+\n+        FloatMaxMask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, ETYPE, VLENGTH, true));\n+        }\n+\n+        FloatMaxMask(boolean val) {\n+            this(prepare(val, ETYPE, VLENGTH, true));\n+        }\n+\n+\n+        @ForceInline\n+        final @Override\n+        public FloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        final VectorPayloadMF getBits() {\n+            return payload;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        FloatMaxVector toVector() {\n+            return (FloatMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        FloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (FloatMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                FloatMaxMask.class, float.class, VLENGTH, offset, limit,\n+                (o, l) -> (FloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public FloatMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public FloatMaxMask compress() {\n+            return (FloatMaxMask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public FloatMaxMask and(VectorMask<Float> mask) {\n+            Objects.requireNonNull(mask);\n+            FloatMaxMask m = (FloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (FloatMaxMask) m1.bOpMF(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public FloatMaxMask or(VectorMask<Float> mask) {\n+            Objects.requireNonNull(mask);\n+            FloatMaxMask m = (FloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (FloatMaxMask) m1.bOpMF(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public FloatMaxMask xor(VectorMask<Float> mask) {\n+            Objects.requireNonNull(mask);\n+            FloatMaxMask m = (FloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (FloatMaxMask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, VLENGTH, this,\n+                                                            (m) -> ((FloatMaxMask) m).trueCountHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n+                                                            (m) -> ((FloatMaxMask) m).firstTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n+                                                            (m) -> ((FloatMaxMask) m).lastTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, VLENGTH, this,\n+                                                      (m) -> ((FloatMaxMask) m).toLongHelper());\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(FloatMaxMask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((FloatMaxMask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((FloatMaxMask) m).anyTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((FloatMaxMask) m).allTrueHelper());\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static FloatMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final FloatMaxMask  TRUE_MASK = new FloatMaxMask(true);\n+        private static final FloatMaxMask FALSE_MASK = new FloatMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final value class FloatMaxShuffle extends AbstractShuffle<Float> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+\n+        private final VectorPayloadMFMaxIB payload;\n+\n+        FloatMaxShuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxIB) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public FloatMaxShuffle(int[] indexes, int i) {\n+            this(prepare(ETYPE, VLENGTH, indexes, i, true));\n+        }\n+\n+        public FloatMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(ETYPE, VLENGTH, fn, true));\n+        }\n+\n+        public FloatMaxShuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n+        }\n+\n+        @Override\n+        public FloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final FloatMaxShuffle IOTA = new FloatMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public FloatMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((FloatMaxVector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n+            FloatMaxShuffle s = (FloatMaxShuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, true);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n+            }\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new FloatMaxShuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromArray0(float[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m, int offsetInRange) {\n+        return super.fromArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n+        return super.fromArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(float[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(float[] a, int offset, VectorMask<Float> m) {\n+        super.intoArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n+        super.intoArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":873,"deletions":0,"binary":false,"changes":873,"status":"added"},{"patch":"@@ -375,0 +375,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -376,2 +377,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                float.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                float.class, length, is_max_species));\n@@ -393,0 +394,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -394,2 +396,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                float.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                float.class, length, is_max_species));\n@@ -420,0 +422,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -421,2 +424,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                float.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                float.class, length, is_max_species));\n@@ -438,0 +441,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -439,2 +443,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                float.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                float.class, length, is_max_species));\n@@ -548,1 +552,2 @@\n-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n@@ -3979,3 +3984,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n-            \/\/    return FloatMaxVector.ZERO;\n+            if ((Class<?>) vectorType() == FloatMaxVector.class)\n+               return FloatMaxVector.ZERO;\n@@ -3994,3 +3998,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n-            \/\/    return FloatMaxVector.IOTA;\n+            if ((Class<?>) vectorType() == FloatMaxVector.class)\n+                return FloatMaxVector.IOTA;\n@@ -4010,3 +4013,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n-            \/\/    return FloatMaxVector.FloatMaxMask.maskAll(bit);\n+            if ((Class<?>) vectorType() == FloatMaxVector.class)\n+                return FloatMaxVector.FloatMaxMask.maskAll(bit);\n@@ -4047,2 +4049,1 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n+            case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n@@ -4082,2 +4083,1 @@\n-    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-    \/*public static final VectorSpecies<Float> SPECIES_MAX\n+    public static final VectorSpecies<Float> SPECIES_MAX\n@@ -4088,1 +4088,0 @@\n-     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.newInstanceFactory(int.class, 4));\n-    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int[])(VSPECIES.iotaArray())));\n+    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.newVectorInstanceFactory(int.class, 4, false));\n+    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(VLENGTH, (int[])(VSPECIES.iotaArray()), false));\n@@ -565,2 +565,0 @@\n-        private final VectorPayloadMF32Z payload;\n-\n@@ -571,0 +569,2 @@\n+        private final VectorPayloadMF32Z payload;\n+\n@@ -572,1 +572,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -576,1 +576,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -579,0 +579,1 @@\n+\n@@ -746,4 +747,0 @@\n-        public Int128Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -751,1 +748,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -755,1 +752,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -758,0 +755,5 @@\n+        public Int128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -800,1 +802,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.newInstanceFactory(int.class, 8));\n-    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int[])(VSPECIES.iotaArray())));\n+    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.newVectorInstanceFactory(int.class, 8, false));\n+    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(VLENGTH, (int[])(VSPECIES.iotaArray()), false));\n@@ -573,2 +573,0 @@\n-        private final VectorPayloadMF64Z payload;\n-\n@@ -579,0 +577,2 @@\n+        private final VectorPayloadMF64Z payload;\n+\n@@ -580,1 +580,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -584,1 +584,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -587,0 +587,1 @@\n+\n@@ -754,4 +755,0 @@\n-        public Int256Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -759,1 +756,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -763,1 +760,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -766,0 +763,5 @@\n+        public Int256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -808,1 +810,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.newInstanceFactory(int.class, 16));\n-    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int[])(VSPECIES.iotaArray())));\n+    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.newVectorInstanceFactory(int.class, 16, false));\n+    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(VLENGTH, (int[])(VSPECIES.iotaArray()), false));\n@@ -589,2 +589,0 @@\n-        private final VectorPayloadMF128Z payload;\n-\n@@ -595,0 +593,2 @@\n+        private final VectorPayloadMF128Z payload;\n+\n@@ -596,1 +596,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -600,1 +600,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -603,0 +603,1 @@\n+\n@@ -770,4 +771,0 @@\n-        public Int512Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -775,1 +772,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -779,1 +776,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -782,0 +779,5 @@\n+        public Int512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -824,1 +826,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.newInstanceFactory(int.class, 2));\n-    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int[])(VSPECIES.iotaArray())));\n+    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.newVectorInstanceFactory(int.class, 2, false));\n+    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(VLENGTH, (int[])(VSPECIES.iotaArray()), false));\n@@ -561,2 +561,0 @@\n-        private final VectorPayloadMF16Z payload;\n-\n@@ -567,0 +565,2 @@\n+        private final VectorPayloadMF16Z payload;\n+\n@@ -568,1 +568,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -572,1 +572,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -575,0 +575,1 @@\n+\n@@ -742,4 +743,0 @@\n-        public Int64Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -747,1 +744,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -751,1 +748,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -754,0 +751,5 @@\n+        public Int64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -796,1 +798,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,899 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import jdk.internal.misc.Unsafe;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+value class IntMaxVector extends IntVector {\n+    static final IntSpecies VSPECIES =\n+        (IntSpecies) IntVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<IntMaxVector> VCLASS = IntMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMFMaxI.class);\n+\n+    private final VectorPayloadMFMaxI payload;\n+\n+    IntMaxVector(Object value) {\n+        this.payload = (VectorPayloadMFMaxI) value;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n+    }\n+\n+    static final IntMaxVector ZERO = new IntMaxVector(VectorPayloadMF.newVectorInstanceFactory(int.class, 0, true));\n+    static final IntMaxVector IOTA = new IntMaxVector(VectorPayloadMF.createVectPayloadInstanceI(VLENGTH, (int[])(VSPECIES.iotaArray()), true));\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVectorMF();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public IntSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Integer> elementType() { return int.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Integer.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n+    @Override\n+    @ForceInline\n+    public final IntMaxVector broadcast(int e) {\n+        return (IntMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final IntMaxVector broadcast(long e) {\n+        return (IntMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    IntMaxMask maskFromPayload(VectorPayloadMF payload) {\n+        return new IntMaxMask(payload);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    IntMaxShuffle iotaShuffle() { return IntMaxShuffle.IOTA; }\n+\n+    @ForceInline\n+    IntMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    IntMaxShuffle shuffleFromBytes(VectorPayloadMF indexes) { return new IntMaxShuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    IntMaxShuffle shuffleFromArray(int[] indexes, int i) { return new IntMaxShuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    IntMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new IntMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    IntMaxVector vectorFactory(VectorPayloadMF vec) {\n+        return new IntMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    IntMaxVector uOpMF(FUnOp f) {\n+        return (IntMaxVector) super.uOpTemplateMF(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    IntMaxVector uOpMF(VectorMask<Integer> m, FUnOp f) {\n+        return (IntMaxVector)\n+            super.uOpTemplateMF((IntMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    IntMaxVector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (IntMaxVector) super.bOpTemplateMF((IntMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    IntMaxVector bOpMF(Vector<Integer> v,\n+                     VectorMask<Integer> m, FBinOp f) {\n+        return (IntMaxVector)\n+            super.bOpTemplateMF((IntMaxVector)v, (IntMaxMask)m,\n+                                f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    IntMaxVector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+        return (IntMaxVector)\n+            super.tOpTemplateMF((IntMaxVector)v1, (IntMaxVector)v2,\n+                                f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    IntMaxVector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n+                     VectorMask<Integer> m, FTriOp f) {\n+        return (IntMaxVector)\n+            super.tOpTemplateMF((IntMaxVector)v1, (IntMaxVector)v2,\n+                                (IntMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Integer,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector lanewise(Unary op) {\n+        return (IntMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector lanewise(Unary op, VectorMask<Integer> m) {\n+        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector lanewise(Binary op, Vector<Integer> v) {\n+        return (IntMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline IntMaxVector\n+    lanewiseShift(VectorOperators.Binary op, int e) {\n+        return (IntMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline IntMaxVector\n+    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Integer> m) {\n+        return (IntMaxVector) super.lanewiseShiftTemplate(op, IntMaxMask.class, e, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    IntMaxVector\n+    lanewise(Ternary op, Vector<Integer> v1, Vector<Integer> v2) {\n+        return (IntMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    IntMaxVector\n+    lanewise(Ternary op, Vector<Integer> v1, Vector<Integer> v2, VectorMask<Integer> m) {\n+        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v1, v2, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    IntMaxVector addIndex(int scale) {\n+        return (IntMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final int reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final int reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Integer> m) {\n+        return super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Integer> m) {\n+        return (long) super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Integer> toShuffle() {\n+        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask test(Test op) {\n+        return super.testTemplate(IntMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(IntMaxMask.class, op, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask compare(Comparison op, Vector<Integer> v) {\n+        return super.compareTemplate(IntMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask compare(Comparison op, int s) {\n+        return super.compareTemplate(IntMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(IntMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask compare(Comparison op, Vector<Integer> v, VectorMask<Integer> m) {\n+        return super.compareTemplate(IntMaxMask.class, op, v, (IntMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector blend(Vector<Integer> v, VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.blendTemplate(IntMaxMask.class,\n+                                (IntMaxVector) v,\n+                                (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector slice(int origin, Vector<Integer> v) {\n+        return (IntMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector slice(int origin) {\n+        return (IntMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector unslice(int origin, Vector<Integer> w, int part) {\n+        return (IntMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector unslice(int origin, Vector<Integer> w, int part, VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.unsliceTemplate(IntMaxMask.class,\n+                                  origin, w, part,\n+                                  (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector unslice(int origin) {\n+        return (IntMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector rearrange(VectorShuffle<Integer> s) {\n+        return (IntMaxVector)\n+            super.rearrangeTemplate(IntMaxShuffle.class,\n+                                    (IntMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector rearrange(VectorShuffle<Integer> shuffle,\n+                                  VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.rearrangeTemplate(IntMaxShuffle.class,\n+                                    IntMaxMask.class,\n+                                    (IntMaxShuffle) shuffle,\n+                                    (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector rearrange(VectorShuffle<Integer> s,\n+                                  Vector<Integer> v) {\n+        return (IntMaxVector)\n+            super.rearrangeTemplate(IntMaxShuffle.class,\n+                                    (IntMaxShuffle) s,\n+                                    (IntMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector compress(VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.compressTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector expand(VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.expandTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector selectFrom(Vector<Integer> v) {\n+        return (IntMaxVector)\n+            super.selectFromTemplate((IntMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector selectFrom(Vector<Integer> v,\n+                                   VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.selectFromTemplate((IntMaxVector) v,\n+                                     (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public int lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return laneHelper(i);\n+    }\n+\n+    public int laneHelper(int i) {\n+        return (int) VectorSupport.extract(\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public IntMaxVector withLane(int i, int e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public IntMaxVector withLaneHelper(int i, int e) {\n+       return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final value class IntMaxMask extends AbstractMask<Integer> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+\n+        IntMaxMask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxIZ) payload;\n+        }\n+\n+        private final VectorPayloadMFMaxIZ payload;\n+\n+        IntMaxMask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, ETYPE, VLENGTH, true));\n+        }\n+\n+        IntMaxMask(boolean val) {\n+            this(prepare(val, ETYPE, VLENGTH, true));\n+        }\n+\n+\n+        @ForceInline\n+        final @Override\n+        public IntSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        final VectorPayloadMF getBits() {\n+            return payload;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        IntMaxVector toVector() {\n+            return (IntMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        IntMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (IntMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                IntMaxMask.class, int.class, VLENGTH, offset, limit,\n+                (o, l) -> (IntMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public IntMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public IntMaxMask compress() {\n+            return (IntMaxMask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public IntMaxMask and(VectorMask<Integer> mask) {\n+            Objects.requireNonNull(mask);\n+            IntMaxMask m = (IntMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (IntMaxMask) m1.bOpMF(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public IntMaxMask or(VectorMask<Integer> mask) {\n+            Objects.requireNonNull(mask);\n+            IntMaxMask m = (IntMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (IntMaxMask) m1.bOpMF(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public IntMaxMask xor(VectorMask<Integer> mask) {\n+            Objects.requireNonNull(mask);\n+            IntMaxMask m = (IntMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (IntMaxMask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, VLENGTH, this,\n+                                                            (m) -> ((IntMaxMask) m).trueCountHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n+                                                            (m) -> ((IntMaxMask) m).firstTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n+                                                            (m) -> ((IntMaxMask) m).lastTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, VLENGTH, this,\n+                                                      (m) -> ((IntMaxMask) m).toLongHelper());\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(IntMaxMask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((IntMaxMask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((IntMaxMask) m).anyTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((IntMaxMask) m).allTrueHelper());\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static IntMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final IntMaxMask  TRUE_MASK = new IntMaxMask(true);\n+        private static final IntMaxMask FALSE_MASK = new IntMaxMask(false);\n+\n+\n+        static VectorPayloadMF maskLowerHalf() {\n+            VectorPayloadMF newObj = VectorPayloadMF.newMaskInstanceFactory(ETYPE, VLENGTH, true);\n+            newObj = Unsafe.getUnsafe().makePrivateBuffer(newObj);\n+            long mf_offset = newObj.multiFieldOffset();\n+            int len = VLENGTH >> 1;\n+            for (int i = 0; i < len; i++) {\n+                Unsafe.getUnsafe().putBoolean(newObj, mf_offset + i, true);\n+            }\n+            newObj = Unsafe.getUnsafe().finishPrivateBuffer(newObj);\n+            return newObj;\n+        }\n+\n+        static final IntMaxMask LOWER_HALF_TRUE_MASK = new IntMaxMask(maskLowerHalf());\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final value class IntMaxShuffle extends AbstractShuffle<Integer> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+\n+        private final VectorPayloadMFMaxIB payload;\n+\n+        IntMaxShuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxIB) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public IntMaxShuffle(int[] indexes, int i) {\n+            this(prepare(ETYPE, VLENGTH, indexes, i, true));\n+        }\n+\n+        public IntMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(ETYPE, VLENGTH, fn, true));\n+        }\n+\n+        public IntMaxShuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n+        }\n+\n+        @Override\n+        public IntSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final IntMaxShuffle IOTA = new IntMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public IntMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, IntMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((IntMaxVector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n+            IntMaxShuffle s = (IntMaxShuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, true);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n+            }\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new IntMaxShuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromArray0(int[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m, int offsetInRange) {\n+        return super.fromArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n+        return super.fromArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(int[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        super.intoArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n+        super.intoArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":899,"deletions":0,"binary":false,"changes":899,"status":"added"},{"patch":"@@ -375,0 +375,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -376,2 +377,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                int.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                int.class, length, is_max_species));\n@@ -393,0 +394,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -394,2 +396,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                int.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                int.class, length, is_max_species));\n@@ -420,0 +422,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -421,2 +424,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                int.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                int.class, length, is_max_species));\n@@ -438,0 +441,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -439,2 +443,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                int.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                int.class, length, is_max_species));\n@@ -548,1 +552,2 @@\n-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n@@ -4147,3 +4152,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n-            \/\/    return IntMaxVector.ZERO;\n+            if ((Class<?>) vectorType() == IntMaxVector.class)\n+               return IntMaxVector.ZERO;\n@@ -4162,3 +4166,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n-            \/\/    return IntMaxVector.IOTA;\n+            if ((Class<?>) vectorType() == IntMaxVector.class)\n+                return IntMaxVector.IOTA;\n@@ -4178,3 +4181,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n-            \/\/    return IntMaxVector.IntMaxMask.maskAll(bit);\n+            if ((Class<?>) vectorType() == IntMaxVector.class)\n+                return IntMaxVector.IntMaxMask.maskAll(bit);\n@@ -4215,2 +4217,1 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;\n+            case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;\n@@ -4250,2 +4251,1 @@\n-    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-    \/*public static final VectorSpecies<Integer> SPECIES_MAX\n+    public static final VectorSpecies<Integer> SPECIES_MAX\n@@ -4256,1 +4256,0 @@\n-     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.newInstanceFactory(long.class, 2));\n-    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long[])(VSPECIES.iotaArray())));\n+    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.newVectorInstanceFactory(long.class, 2, false));\n+    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(VLENGTH, (long[])(VSPECIES.iotaArray()), false));\n@@ -551,2 +551,0 @@\n-        private final VectorPayloadMF16Z payload;\n-\n@@ -557,0 +555,2 @@\n+        private final VectorPayloadMF16Z payload;\n+\n@@ -558,1 +558,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -562,1 +562,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -565,0 +565,1 @@\n+\n@@ -732,4 +733,0 @@\n-        public Long128Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -737,1 +734,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -741,1 +738,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -744,0 +741,5 @@\n+        public Long128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -786,1 +788,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.newInstanceFactory(long.class, 4));\n-    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long[])(VSPECIES.iotaArray())));\n+    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.newVectorInstanceFactory(long.class, 4, false));\n+    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(VLENGTH, (long[])(VSPECIES.iotaArray()), false));\n@@ -555,2 +555,0 @@\n-        private final VectorPayloadMF32Z payload;\n-\n@@ -561,0 +559,2 @@\n+        private final VectorPayloadMF32Z payload;\n+\n@@ -562,1 +562,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -566,1 +566,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -569,0 +569,1 @@\n+\n@@ -736,4 +737,0 @@\n-        public Long256Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -741,1 +738,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -745,1 +742,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -748,0 +745,5 @@\n+        public Long256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -790,1 +792,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.newInstanceFactory(long.class, 8));\n-    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long[])(VSPECIES.iotaArray())));\n+    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.newVectorInstanceFactory(long.class, 8, false));\n+    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(VLENGTH, (long[])(VSPECIES.iotaArray()), false));\n@@ -563,2 +563,0 @@\n-        private final VectorPayloadMF64Z payload;\n-\n@@ -569,0 +567,2 @@\n+        private final VectorPayloadMF64Z payload;\n+\n@@ -570,1 +570,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -574,1 +574,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -577,0 +577,1 @@\n+\n@@ -744,4 +745,0 @@\n-        public Long512Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -749,1 +746,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -753,1 +750,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -756,0 +753,5 @@\n+        public Long512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -798,1 +800,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.newInstanceFactory(long.class, 1));\n-    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long[])(VSPECIES.iotaArray())));\n+    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.newVectorInstanceFactory(long.class, 1, false));\n+    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(VLENGTH, (long[])(VSPECIES.iotaArray()), false));\n@@ -549,2 +549,0 @@\n-        private final VectorPayloadMF8Z payload;\n-\n@@ -555,0 +553,2 @@\n+        private final VectorPayloadMF8Z payload;\n+\n@@ -556,1 +556,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -560,1 +560,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -563,0 +563,1 @@\n+\n@@ -730,4 +731,0 @@\n-        public Long64Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -735,1 +732,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -739,1 +736,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -742,0 +739,5 @@\n+        public Long64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -784,1 +786,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,875 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import jdk.internal.misc.Unsafe;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+value class LongMaxVector extends LongVector {\n+    static final LongSpecies VSPECIES =\n+        (LongSpecies) LongVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<LongMaxVector> VCLASS = LongMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMFMaxL.class);\n+\n+    private final VectorPayloadMFMaxL payload;\n+\n+    LongMaxVector(Object value) {\n+        this.payload = (VectorPayloadMFMaxL) value;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n+    }\n+\n+    static final LongMaxVector ZERO = new LongMaxVector(VectorPayloadMF.newVectorInstanceFactory(long.class, 0, true));\n+    static final LongMaxVector IOTA = new LongMaxVector(VectorPayloadMF.createVectPayloadInstanceL(VLENGTH, (long[])(VSPECIES.iotaArray()), true));\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVectorMF();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public LongSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Long> elementType() { return long.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Long.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n+    @Override\n+    @ForceInline\n+    public final LongMaxVector broadcast(long e) {\n+        return (LongMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    LongMaxMask maskFromPayload(VectorPayloadMF payload) {\n+        return new LongMaxMask(payload);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    LongMaxShuffle iotaShuffle() { return LongMaxShuffle.IOTA; }\n+\n+    @ForceInline\n+    LongMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    LongMaxShuffle shuffleFromBytes(VectorPayloadMF indexes) { return new LongMaxShuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    LongMaxShuffle shuffleFromArray(int[] indexes, int i) { return new LongMaxShuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    LongMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new LongMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    LongMaxVector vectorFactory(VectorPayloadMF vec) {\n+        return new LongMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    LongMaxVector uOpMF(FUnOp f) {\n+        return (LongMaxVector) super.uOpTemplateMF(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    LongMaxVector uOpMF(VectorMask<Long> m, FUnOp f) {\n+        return (LongMaxVector)\n+            super.uOpTemplateMF((LongMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    LongMaxVector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (LongMaxVector) super.bOpTemplateMF((LongMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    LongMaxVector bOpMF(Vector<Long> v,\n+                     VectorMask<Long> m, FBinOp f) {\n+        return (LongMaxVector)\n+            super.bOpTemplateMF((LongMaxVector)v, (LongMaxMask)m,\n+                                f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    LongMaxVector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+        return (LongMaxVector)\n+            super.tOpTemplateMF((LongMaxVector)v1, (LongMaxVector)v2,\n+                                f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    LongMaxVector tOpMF(Vector<Long> v1, Vector<Long> v2,\n+                     VectorMask<Long> m, FTriOp f) {\n+        return (LongMaxVector)\n+            super.tOpTemplateMF((LongMaxVector)v1, (LongMaxVector)v2,\n+                                (LongMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Long,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector lanewise(Unary op) {\n+        return (LongMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector lanewise(Unary op, VectorMask<Long> m) {\n+        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector lanewise(Binary op, Vector<Long> v) {\n+        return (LongMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n+        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline LongMaxVector\n+    lanewiseShift(VectorOperators.Binary op, int e) {\n+        return (LongMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline LongMaxVector\n+    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Long> m) {\n+        return (LongMaxVector) super.lanewiseShiftTemplate(op, LongMaxMask.class, e, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    LongMaxVector\n+    lanewise(Ternary op, Vector<Long> v1, Vector<Long> v2) {\n+        return (LongMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    LongMaxVector\n+    lanewise(Ternary op, Vector<Long> v1, Vector<Long> v2, VectorMask<Long> m) {\n+        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v1, v2, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    LongMaxVector addIndex(int scale) {\n+        return (LongMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Long> m) {\n+        return super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Long> m) {\n+        return (long) super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Long> toShuffle() {\n+        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final LongMaxMask test(Test op) {\n+        return super.testTemplate(LongMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final LongMaxMask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(LongMaxMask.class, op, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final LongMaxMask compare(Comparison op, Vector<Long> v) {\n+        return super.compareTemplate(LongMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final LongMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(LongMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public final LongMaxMask compare(Comparison op, Vector<Long> v, VectorMask<Long> m) {\n+        return super.compareTemplate(LongMaxMask.class, op, v, (LongMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector blend(Vector<Long> v, VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.blendTemplate(LongMaxMask.class,\n+                                (LongMaxVector) v,\n+                                (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector slice(int origin, Vector<Long> v) {\n+        return (LongMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector slice(int origin) {\n+        return (LongMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector unslice(int origin, Vector<Long> w, int part) {\n+        return (LongMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector unslice(int origin, Vector<Long> w, int part, VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.unsliceTemplate(LongMaxMask.class,\n+                                  origin, w, part,\n+                                  (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector unslice(int origin) {\n+        return (LongMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector rearrange(VectorShuffle<Long> s) {\n+        return (LongMaxVector)\n+            super.rearrangeTemplate(LongMaxShuffle.class,\n+                                    (LongMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector rearrange(VectorShuffle<Long> shuffle,\n+                                  VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.rearrangeTemplate(LongMaxShuffle.class,\n+                                    LongMaxMask.class,\n+                                    (LongMaxShuffle) shuffle,\n+                                    (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector rearrange(VectorShuffle<Long> s,\n+                                  Vector<Long> v) {\n+        return (LongMaxVector)\n+            super.rearrangeTemplate(LongMaxShuffle.class,\n+                                    (LongMaxShuffle) s,\n+                                    (LongMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector compress(VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.compressTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector expand(VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.expandTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector selectFrom(Vector<Long> v) {\n+        return (LongMaxVector)\n+            super.selectFromTemplate((LongMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector selectFrom(Vector<Long> v,\n+                                   VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.selectFromTemplate((LongMaxVector) v,\n+                                     (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public long lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return laneHelper(i);\n+    }\n+\n+    public long laneHelper(int i) {\n+        return (long) VectorSupport.extract(\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public LongMaxVector withLane(int i, long e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public LongMaxVector withLaneHelper(int i, long e) {\n+       return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final value class LongMaxMask extends AbstractMask<Long> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+\n+        LongMaxMask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxLZ) payload;\n+        }\n+\n+        private final VectorPayloadMFMaxLZ payload;\n+\n+        LongMaxMask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, ETYPE, VLENGTH, true));\n+        }\n+\n+        LongMaxMask(boolean val) {\n+            this(prepare(val, ETYPE, VLENGTH, true));\n+        }\n+\n+\n+        @ForceInline\n+        final @Override\n+        public LongSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        final VectorPayloadMF getBits() {\n+            return payload;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        LongMaxVector toVector() {\n+            return (LongMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        LongMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (LongMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                LongMaxMask.class, long.class, VLENGTH, offset, limit,\n+                (o, l) -> (LongMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public LongMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public LongMaxMask compress() {\n+            return (LongMaxMask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public LongMaxMask and(VectorMask<Long> mask) {\n+            Objects.requireNonNull(mask);\n+            LongMaxMask m = (LongMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (LongMaxMask) m1.bOpMF(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public LongMaxMask or(VectorMask<Long> mask) {\n+            Objects.requireNonNull(mask);\n+            LongMaxMask m = (LongMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (LongMaxMask) m1.bOpMF(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public LongMaxMask xor(VectorMask<Long> mask) {\n+            Objects.requireNonNull(mask);\n+            LongMaxMask m = (LongMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (LongMaxMask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, VLENGTH, this,\n+                                                            (m) -> ((LongMaxMask) m).trueCountHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n+                                                            (m) -> ((LongMaxMask) m).firstTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n+                                                            (m) -> ((LongMaxMask) m).lastTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, VLENGTH, this,\n+                                                      (m) -> ((LongMaxMask) m).toLongHelper());\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(LongMaxMask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((LongMaxMask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((LongMaxMask) m).anyTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((LongMaxMask) m).allTrueHelper());\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static LongMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final LongMaxMask  TRUE_MASK = new LongMaxMask(true);\n+        private static final LongMaxMask FALSE_MASK = new LongMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final value class LongMaxShuffle extends AbstractShuffle<Long> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+\n+        private final VectorPayloadMFMaxLB payload;\n+\n+        LongMaxShuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxLB) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public LongMaxShuffle(int[] indexes, int i) {\n+            this(prepare(ETYPE, VLENGTH, indexes, i, true));\n+        }\n+\n+        public LongMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(ETYPE, VLENGTH, fn, true));\n+        }\n+\n+        public LongMaxShuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n+        }\n+\n+        @Override\n+        public LongSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final LongMaxShuffle IOTA = new LongMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public LongMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, LongMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((LongMaxVector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n+            LongMaxShuffle s = (LongMaxShuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, true);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n+            }\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new LongMaxShuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromArray0(long[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m, int offsetInRange) {\n+        return super.fromArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n+        return super.fromArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(long[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(long[] a, int offset, VectorMask<Long> m) {\n+        super.intoArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n+        super.intoArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":875,"deletions":0,"binary":false,"changes":875,"status":"added"},{"patch":"@@ -375,0 +375,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -376,2 +377,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                long.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                long.class, length, is_max_species));\n@@ -393,0 +394,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -394,2 +396,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                long.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                long.class, length, is_max_species));\n@@ -420,0 +422,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -421,2 +424,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                long.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                long.class, length, is_max_species));\n@@ -438,0 +441,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -439,2 +443,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                long.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                long.class, length, is_max_species));\n@@ -548,1 +552,2 @@\n-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n@@ -3029,1 +3034,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -3032,2 +3037,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3324,1 +3327,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -3327,2 +3330,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3520,1 +3521,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -3523,2 +3524,0 @@\n-             *\/\n-            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3637,1 +3636,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -3640,3 +3639,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n-\n@@ -4082,3 +4078,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n-            \/\/    return LongMaxVector.ZERO;\n+            if ((Class<?>) vectorType() == LongMaxVector.class)\n+               return LongMaxVector.ZERO;\n@@ -4097,3 +4092,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n-            \/\/    return LongMaxVector.IOTA;\n+            if ((Class<?>) vectorType() == LongMaxVector.class)\n+                return LongMaxVector.IOTA;\n@@ -4113,3 +4107,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n-            \/\/    return LongMaxVector.LongMaxMask.maskAll(bit);\n+            if ((Class<?>) vectorType() == LongMaxVector.class)\n+                return LongMaxVector.LongMaxMask.maskAll(bit);\n@@ -4150,2 +4143,1 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;\n+            case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;\n@@ -4185,2 +4177,1 @@\n-    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-    \/*public static final VectorSpecies<Long> SPECIES_MAX\n+    public static final VectorSpecies<Long> SPECIES_MAX\n@@ -4191,1 +4182,0 @@\n-     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":26,"deletions":36,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.newInstanceFactory(short.class, 8));\n-    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short[])(VSPECIES.iotaArray())));\n+    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.newVectorInstanceFactory(short.class, 8, false));\n+    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(VLENGTH, (short[])(VSPECIES.iotaArray()), false));\n@@ -573,2 +573,0 @@\n-        private final VectorPayloadMF64Z payload;\n-\n@@ -579,0 +577,2 @@\n+        private final VectorPayloadMF64Z payload;\n+\n@@ -580,1 +580,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -584,1 +584,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -587,0 +587,1 @@\n+\n@@ -754,4 +755,0 @@\n-        public Short128Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -759,1 +756,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -763,1 +760,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -766,0 +763,5 @@\n+        public Short128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -808,1 +810,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.newInstanceFactory(short.class, 16));\n-    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short[])(VSPECIES.iotaArray())));\n+    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.newVectorInstanceFactory(short.class, 16, false));\n+    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(VLENGTH, (short[])(VSPECIES.iotaArray()), false));\n@@ -589,2 +589,0 @@\n-        private final VectorPayloadMF128Z payload;\n-\n@@ -595,0 +593,2 @@\n+        private final VectorPayloadMF128Z payload;\n+\n@@ -596,1 +596,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -600,1 +600,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -603,0 +603,1 @@\n+\n@@ -770,4 +771,0 @@\n-        public Short256Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -775,1 +772,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -779,1 +776,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -782,0 +779,5 @@\n+        public Short256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -824,1 +826,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.newInstanceFactory(short.class, 32));\n-    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short[])(VSPECIES.iotaArray())));\n+    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.newVectorInstanceFactory(short.class, 32, false));\n+    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(VLENGTH, (short[])(VSPECIES.iotaArray()), false));\n@@ -621,2 +621,0 @@\n-        private final VectorPayloadMF256Z payload;\n-\n@@ -627,0 +625,2 @@\n+        private final VectorPayloadMF256Z payload;\n+\n@@ -628,1 +628,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -632,1 +632,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -635,0 +635,1 @@\n+\n@@ -802,4 +803,0 @@\n-        public Short512Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -807,1 +804,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -811,1 +808,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -814,0 +811,5 @@\n+        public Short512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -856,1 +858,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.newInstanceFactory(short.class, 4));\n-    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short[])(VSPECIES.iotaArray())));\n+    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.newVectorInstanceFactory(short.class, 4, false));\n+    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(VLENGTH, (short[])(VSPECIES.iotaArray()), false));\n@@ -565,2 +565,0 @@\n-        private final VectorPayloadMF32Z payload;\n-\n@@ -571,0 +569,2 @@\n+        private final VectorPayloadMF32Z payload;\n+\n@@ -572,1 +572,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -576,1 +576,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -579,0 +579,1 @@\n+\n@@ -746,4 +747,0 @@\n-        public Short64Shuffle(int[] indexes) {\n-            this(indexes, 0);\n-        }\n-\n@@ -751,1 +748,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -755,1 +752,1 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n@@ -758,0 +755,5 @@\n+        public Short64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n@@ -800,1 +802,1 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,892 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import jdk.internal.misc.Unsafe;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+value class ShortMaxVector extends ShortVector {\n+    static final ShortSpecies VSPECIES =\n+        (ShortSpecies) ShortVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<ShortMaxVector> VCLASS = ShortMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMFMaxS.class);\n+\n+    private final VectorPayloadMFMaxS payload;\n+\n+    ShortMaxVector(Object value) {\n+        this.payload = (VectorPayloadMFMaxS) value;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n+    }\n+\n+    static final ShortMaxVector ZERO = new ShortMaxVector(VectorPayloadMF.newVectorInstanceFactory(short.class, 0, true));\n+    static final ShortMaxVector IOTA = new ShortMaxVector(VectorPayloadMF.createVectPayloadInstanceS(VLENGTH, (short[])(VSPECIES.iotaArray()), true));\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVectorMF();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public ShortSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Short> elementType() { return short.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Short.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n+    @Override\n+    @ForceInline\n+    public final ShortMaxVector broadcast(short e) {\n+        return (ShortMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ShortMaxVector broadcast(long e) {\n+        return (ShortMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    ShortMaxMask maskFromPayload(VectorPayloadMF payload) {\n+        return new ShortMaxMask(payload);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    ShortMaxShuffle iotaShuffle() { return ShortMaxShuffle.IOTA; }\n+\n+    @ForceInline\n+    ShortMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    ShortMaxShuffle shuffleFromBytes(VectorPayloadMF indexes) { return new ShortMaxShuffle(indexes); }\n+\n+    @Override\n+    @ForceInline\n+    ShortMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ShortMaxShuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    ShortMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new ShortMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    ShortMaxVector vectorFactory(VectorPayloadMF vec) {\n+        return new ShortMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    ShortMaxVector uOpMF(FUnOp f) {\n+        return (ShortMaxVector) super.uOpTemplateMF(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ShortMaxVector uOpMF(VectorMask<Short> m, FUnOp f) {\n+        return (ShortMaxVector)\n+            super.uOpTemplateMF((ShortMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    ShortMaxVector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (ShortMaxVector) super.bOpTemplateMF((ShortMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ShortMaxVector bOpMF(Vector<Short> v,\n+                     VectorMask<Short> m, FBinOp f) {\n+        return (ShortMaxVector)\n+            super.bOpTemplateMF((ShortMaxVector)v, (ShortMaxMask)m,\n+                                f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    ShortMaxVector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+        return (ShortMaxVector)\n+            super.tOpTemplateMF((ShortMaxVector)v1, (ShortMaxVector)v2,\n+                                f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ShortMaxVector tOpMF(Vector<Short> v1, Vector<Short> v2,\n+                     VectorMask<Short> m, FTriOp f) {\n+        return (ShortMaxVector)\n+            super.tOpTemplateMF((ShortMaxVector)v1, (ShortMaxVector)v2,\n+                                (ShortMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Short,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector lanewise(Unary op) {\n+        return (ShortMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector lanewise(Unary op, VectorMask<Short> m) {\n+        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector lanewise(Binary op, Vector<Short> v) {\n+        return (ShortMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n+        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline ShortMaxVector\n+    lanewiseShift(VectorOperators.Binary op, int e) {\n+        return (ShortMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline ShortMaxVector\n+    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Short> m) {\n+        return (ShortMaxVector) super.lanewiseShiftTemplate(op, ShortMaxMask.class, e, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    ShortMaxVector\n+    lanewise(Ternary op, Vector<Short> v1, Vector<Short> v2) {\n+        return (ShortMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    ShortMaxVector\n+    lanewise(Ternary op, Vector<Short> v1, Vector<Short> v2, VectorMask<Short> m) {\n+        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v1, v2, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    ShortMaxVector addIndex(int scale) {\n+        return (ShortMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Short> m) {\n+        return super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Short> m) {\n+        return (long) super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Short> toShuffle() {\n+        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask test(Test op) {\n+        return super.testTemplate(ShortMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(ShortMaxMask.class, op, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask compare(Comparison op, Vector<Short> v) {\n+        return super.compareTemplate(ShortMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask compare(Comparison op, short s) {\n+        return super.compareTemplate(ShortMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(ShortMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask compare(Comparison op, Vector<Short> v, VectorMask<Short> m) {\n+        return super.compareTemplate(ShortMaxMask.class, op, v, (ShortMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector blend(Vector<Short> v, VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.blendTemplate(ShortMaxMask.class,\n+                                (ShortMaxVector) v,\n+                                (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector slice(int origin, Vector<Short> v) {\n+        return (ShortMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector slice(int origin) {\n+        return (ShortMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector unslice(int origin, Vector<Short> w, int part) {\n+        return (ShortMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector unslice(int origin, Vector<Short> w, int part, VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.unsliceTemplate(ShortMaxMask.class,\n+                                  origin, w, part,\n+                                  (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector unslice(int origin) {\n+        return (ShortMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector rearrange(VectorShuffle<Short> s) {\n+        return (ShortMaxVector)\n+            super.rearrangeTemplate(ShortMaxShuffle.class,\n+                                    (ShortMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector rearrange(VectorShuffle<Short> shuffle,\n+                                  VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.rearrangeTemplate(ShortMaxShuffle.class,\n+                                    ShortMaxMask.class,\n+                                    (ShortMaxShuffle) shuffle,\n+                                    (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector rearrange(VectorShuffle<Short> s,\n+                                  Vector<Short> v) {\n+        return (ShortMaxVector)\n+            super.rearrangeTemplate(ShortMaxShuffle.class,\n+                                    (ShortMaxShuffle) s,\n+                                    (ShortMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector compress(VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.compressTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector expand(VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.expandTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector selectFrom(Vector<Short> v) {\n+        return (ShortMaxVector)\n+            super.selectFromTemplate((ShortMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector selectFrom(Vector<Short> v,\n+                                   VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.selectFromTemplate((ShortMaxVector) v,\n+                                     (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return laneHelper(i);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public ShortMaxVector withLane(int i, short e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public ShortMaxVector withLaneHelper(int i, short e) {\n+       return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final value class ShortMaxMask extends AbstractMask<Short> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+\n+        ShortMaxMask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxSZ) payload;\n+        }\n+\n+        private final VectorPayloadMFMaxSZ payload;\n+\n+        ShortMaxMask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, ETYPE, VLENGTH, true));\n+        }\n+\n+        ShortMaxMask(boolean val) {\n+            this(prepare(val, ETYPE, VLENGTH, true));\n+        }\n+\n+\n+        @ForceInline\n+        final @Override\n+        public ShortSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        final VectorPayloadMF getBits() {\n+            return payload;\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        ShortMaxVector toVector() {\n+            return (ShortMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        ShortMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (ShortMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                ShortMaxMask.class, short.class, VLENGTH, offset, limit,\n+                (o, l) -> (ShortMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public ShortMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public ShortMaxMask compress() {\n+            return (ShortMaxMask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public ShortMaxMask and(VectorMask<Short> mask) {\n+            Objects.requireNonNull(mask);\n+            ShortMaxMask m = (ShortMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (ShortMaxMask) m1.bOpMF(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public ShortMaxMask or(VectorMask<Short> mask) {\n+            Objects.requireNonNull(mask);\n+            ShortMaxMask m = (ShortMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (ShortMaxMask) m1.bOpMF(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public ShortMaxMask xor(VectorMask<Short> mask) {\n+            Objects.requireNonNull(mask);\n+            ShortMaxMask m = (ShortMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (ShortMaxMask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, VLENGTH, this,\n+                                                            (m) -> ((ShortMaxMask) m).trueCountHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n+                                                            (m) -> ((ShortMaxMask) m).firstTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n+                                                            (m) -> ((ShortMaxMask) m).lastTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> ((ShortMaxMask) m).toLongHelper());\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(ShortMaxMask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (((ShortMaxMask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((ShortMaxMask) m).anyTrueHelper());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> ((ShortMaxMask) m).allTrueHelper());\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static ShortMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final ShortMaxMask  TRUE_MASK = new ShortMaxMask(true);\n+        private static final ShortMaxMask FALSE_MASK = new ShortMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final value class ShortMaxShuffle extends AbstractShuffle<Short> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+\n+        private final VectorPayloadMFMaxSB payload;\n+\n+        ShortMaxShuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMFMaxSB) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n+        }\n+\n+        public ShortMaxShuffle(int[] indexes, int i) {\n+            this(prepare(ETYPE, VLENGTH, indexes, i, true));\n+        }\n+\n+        public ShortMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(ETYPE, VLENGTH, fn, true));\n+        }\n+\n+        public ShortMaxShuffle(int[] indexes) {\n+            this(indexes, 0);\n+        }\n+\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n+        }\n+\n+        @Override\n+        public ShortSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final ShortMaxShuffle IOTA = new ShortMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public ShortMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((ShortMaxVector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n+            ShortMaxShuffle s = (ShortMaxShuffle) shuffle;\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, true);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n+            }\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n+            return new ShortMaxShuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m, int offsetInRange) {\n+        return super.fromArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m, int offsetInRange) {\n+        return super.fromCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Short> m) {\n+        super.intoArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        super.intoCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":892,"deletions":0,"binary":false,"changes":892,"status":"added"},{"patch":"@@ -375,0 +375,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -376,2 +377,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                short.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                short.class, length, is_max_species));\n@@ -393,0 +394,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -394,2 +396,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                short.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                short.class, length, is_max_species));\n@@ -420,0 +422,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -421,2 +424,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                short.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                short.class, length, is_max_species));\n@@ -438,0 +441,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -439,2 +443,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                short.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                short.class, length, is_max_species));\n@@ -548,1 +552,2 @@\n-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n@@ -4428,3 +4433,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n-            \/\/    return ShortMaxVector.ZERO;\n+            if ((Class<?>) vectorType() == ShortMaxVector.class)\n+               return ShortMaxVector.ZERO;\n@@ -4443,3 +4447,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n-            \/\/    return ShortMaxVector.IOTA;\n+            if ((Class<?>) vectorType() == ShortMaxVector.class)\n+                return ShortMaxVector.IOTA;\n@@ -4459,3 +4462,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n-            \/\/    return ShortMaxVector.ShortMaxMask.maskAll(bit);\n+            if ((Class<?>) vectorType() == ShortMaxVector.class)\n+                return ShortMaxVector.ShortMaxMask.maskAll(bit);\n@@ -4496,2 +4498,1 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n+            case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n@@ -4531,2 +4532,1 @@\n-    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-    \/*public static final VectorSpecies<Short> SPECIES_MAX\n+    public static final VectorSpecies<Short> SPECIES_MAX\n@@ -4537,1 +4537,0 @@\n-     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -379,0 +379,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -380,2 +381,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                $type$.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                $type$.class, length, is_max_species));\n@@ -397,0 +398,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -398,2 +400,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                $type$.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                $type$.class, length, is_max_species));\n@@ -424,0 +426,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -425,2 +428,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                $type$.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                $type$.class, length, is_max_species));\n@@ -442,0 +445,1 @@\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n@@ -443,2 +447,2 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n-                $type$.class, length));\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newVectorInstanceFactory(\n+                $type$.class, length, is_max_species));\n@@ -552,1 +556,2 @@\n-        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        boolean is_max_species = ((AbstractSpecies)vspecies()).is_max_species();\n+        VectorPayloadMF mbits = VectorPayloadMF.newMaskInstanceFactory(vspecies().elementType(), length, is_max_species);\n@@ -3787,1 +3792,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -3790,2 +3795,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -4427,1 +4430,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -4430,2 +4433,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -4971,1 +4972,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -4974,2 +4975,0 @@\n-             *\/\n-            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -5163,1 +5162,1 @@\n-            \/*vix = IntVector\n+            vix = IntVector\n@@ -5166,3 +5165,0 @@\n-             *\/\n-             assert false : \"Unhandled case for Multi-field based MaxVector\";\n-\n@@ -5720,3 +5716,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-            \/\/    return $Type$MaxVector.ZERO;\n+            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+               return $Type$MaxVector.ZERO;\n@@ -5735,3 +5730,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-            \/\/    return $Type$MaxVector.IOTA;\n+            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+                return $Type$MaxVector.IOTA;\n@@ -5751,3 +5745,2 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-            \/\/    return $Type$MaxVector.$Type$MaxMask.maskAll(bit);\n+            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+                return $Type$MaxVector.$Type$MaxMask.maskAll(bit);\n@@ -5788,2 +5781,1 @@\n-            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-            \/\/case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;\n+            case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;\n@@ -5823,2 +5815,1 @@\n-    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n-    \/*public static final VectorSpecies<$Boxtype$> SPECIES_MAX\n+    public static final VectorSpecies<$Boxtype$> SPECIES_MAX\n@@ -5829,1 +5820,0 @@\n-     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":26,"deletions":36,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -72,2 +72,7 @@\n-    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.newInstanceFactory($type$.class, $numLanes$));\n-    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$[])(VSPECIES.iotaArray())));\n+#if[!Max]\n+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.newVectorInstanceFactory($type$.class, $numLanes$, false));\n+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$(VLENGTH, ($type$[])(VSPECIES.iotaArray()), false));\n+#else[!Max]\n+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.newVectorInstanceFactory($type$.class, $numLanes$, true));\n+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$(VLENGTH, ($type$[])(VSPECIES.iotaArray()), true));\n+#end[!Max]\n@@ -836,1 +841,10 @@\n-        private final VectorPayloadMF$vectorsizeinbytes$Z payload;\n+#if[Max]\n+        $masktype$(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$Z) payload;\n+        }\n+\n+        private final VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$Z payload;\n+\n+        $masktype$(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, ETYPE, VLENGTH, true));\n+        }\n@@ -838,0 +852,4 @@\n+        $masktype$(boolean val) {\n+            this(prepare(val, ETYPE, VLENGTH, true));\n+        }\n+#else[Max]\n@@ -842,0 +860,2 @@\n+        private final VectorPayloadMF$vectorsizeinbytes$Z payload;\n+\n@@ -843,1 +863,1 @@\n-            this(prepare(payload, offset, VLENGTH));\n+            this(prepare(payload, offset, ETYPE, VLENGTH, false));\n@@ -847,1 +867,1 @@\n-            this(prepare(val, VLENGTH));\n+            this(prepare(val, ETYPE, VLENGTH, false));\n@@ -849,0 +869,2 @@\n+#end[Max]\n+\n@@ -1004,1 +1026,5 @@\n-            VectorPayloadMF newObj = VectorPayloadMF.newInstanceFactory(boolean.class, VLENGTH);\n+#if[Max]\n+            VectorPayloadMF newObj = VectorPayloadMF.newMaskInstanceFactory(ETYPE, VLENGTH, true);\n+#else[Max]\n+            VectorPayloadMF newObj = VectorPayloadMF.newMaskInstanceFactory(ETYPE, VLENGTH, false);\n+#end[Max]\n@@ -1027,1 +1053,2 @@\n-        private final VectorPayloadMF$vectorsizeinbytes$B payload;\n+#if[Max]\n+        private final VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$B payload;\n@@ -1030,1 +1057,1 @@\n-            this.payload = (VectorPayloadMF$vectorsizeinbytes$B) payload;\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$$Boxbitsinitials$B) payload;\n@@ -1035,2 +1062,14 @@\n-        public $shuffletype$(int[] indexes) {\n-            this(indexes, 0);\n+        public $shuffletype$(int[] indexes, int i) {\n+            this(prepare(ETYPE, VLENGTH, indexes, i, true));\n+        }\n+\n+        public $shuffletype$(IntUnaryOperator fn) {\n+            this(prepare(ETYPE, VLENGTH, fn, true));\n+        }\n+#else[Max]\n+        private final VectorPayloadMF$vectorsizeinbytes$B payload;\n+\n+        $shuffletype$(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -1040,1 +1079,1 @@\n-            this(prepare(VLENGTH, indexes, i));\n+            this(prepare(ETYPE, VLENGTH, indexes, i, false));\n@@ -1044,1 +1083,6 @@\n-            this(prepare(VLENGTH, fn));\n+            this(prepare(ETYPE, VLENGTH, fn, false));\n+        }\n+#end[Max]\n+\n+        public $shuffletype$(int[] indexes) {\n+            this(indexes, 0);\n@@ -1047,0 +1091,1 @@\n+\n@@ -1089,1 +1134,5 @@\n-            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+#if[Max]\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, true);\n+#else[Max]\n+            VectorPayloadMF r = VectorPayloadMF.newShuffleInstanceFactory(ETYPE, VLENGTH, false);\n+#end[Max]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":62,"deletions":13,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -151,2 +151,1 @@\n-  # for bits in 64 128 256 512 Max\n-  for bits in 64 128 256 512\n+  for bits in 64 128 256 512 Max\n@@ -181,0 +180,1 @@\n+        vectorsizeinbytes=\"${bits}\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}