{"files":[{"patch":"@@ -3704,10 +3704,0 @@\n-#ifdef ASSERT\n-  {\n-    Label L;\n-    cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n-    jcc(Assembler::equal, L);\n-    stop(\"klass not initialized\");\n-    bind(L);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-  vklass->initialize(THREAD);\n+  vklass->initialize(CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1270,1 +1270,1 @@\n-  {\n+  if (EnableValhalla) {\n@@ -1278,7 +1278,1 @@\n-              true, CHECK);\n-          if (klass == NULL) {\n-            THROW(vmSymbols::java_lang_NoClassDefFoundError());\n-          }\n-          if (!klass->is_inline_klass()) {\n-            THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n-          }\n+              true, THREAD);\n@@ -1287,4 +1281,20 @@\n-        InstanceKlass::cast(klass)->initialize(CHECK);\n-        if (fs.access_flags().is_static()) {\n-          if (java_mirror()->obj_field(fs.offset()) == NULL) {\n-            java_mirror()->obj_field_put(fs.offset(), InlineKlass::cast(klass)->default_value());\n+\n+        if (!HAS_PENDING_EXCEPTION) {\n+          assert(klass != NULL, \"Must  be\");\n+          InstanceKlass::cast(klass)->initialize(THREAD);\n+          if (fs.access_flags().is_static()) {\n+            if (java_mirror()->obj_field(fs.offset()) == NULL) {\n+              java_mirror()->obj_field_put(fs.offset(), InlineKlass::cast(klass)->default_value());\n+            }\n+          }\n+        }\n+\n+        if (HAS_PENDING_EXCEPTION) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          {\n+            EXCEPTION_MARK;\n+            add_initialization_error(THREAD, e);\n+            \/\/ Locks object, set state, and notify all waiting threads\n+            set_initialization_state_and_notify(initialization_error, THREAD);\n+            CLEAR_PENDING_EXCEPTION;\n@@ -1292,0 +1302,1 @@\n+          THROW_OOP(e());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package runtime.valhalla.inlinetypes;\n+\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+* @test\n+* @summary Test several scenarios of class initialization failures\n+* @library \/test\/lib\n+* @run main\/othervm  runtime.valhalla.inlinetypes.ClassInitializationFailuresTest\n+\n+*\/\n+public class ClassInitializationFailuresTest {\n+\n+  static boolean failingInitialization = true;\n+  static Object bo = null;\n+\n+  static primitive class BadOne {\n+    int i = 0;\n+    static {\n+      if (ClassInitializationFailuresTest.failingInitialization) {\n+        throw new RuntimeException(\"Failing initialization\");\n+      }\n+    }\n+  }\n+\n+  static primitive class TestClass1 {\n+    BadOne badField = new BadOne();\n+  }\n+\n+  \/\/ Test handling of errors during the initialization of a primitive class\n+  \/\/ Initialization of TestClass1 triggers the initialization of classes\n+  \/\/ of all its primitive class typed fields, in this case BadOne\n+  \/\/ Static initializer of BadOne throws an exception, so BadOne's initialization\n+  \/\/ fails, which must caused the initialization of TestClass1 to fail too\n+  \/\/ First attempt to instantiate TestClass1 must fail with an ExceptionInInitializerError\n+  \/\/ because an exception has been thrown during the initialization process\n+  \/\/ Second attempt to instantiate TestClass1 must fail with a NoClassDefFoundError\n+  \/\/ because TestClass1 must already be in a faile initialization state (so no new\n+  \/\/ attempt to initialize the class)\n+  static void testClassInitialization() {\n+    Throwable e = null;\n+    try {\n+      TestClass1 t1 = new TestClass1();\n+    } catch(Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Exception should have been thrown\");\n+    Asserts.assertTrue(e.getClass() == ExceptionInInitializerError.class, \"Must be an ExceptionInInitializerError\");\n+    Asserts.assertTrue(e.getCause().getClass() == RuntimeException.class, \"Must be the exception thown in the static initializer of BadOne\");\n+    \/\/ Second attempt because it doesn't fail the same way\n+    e = null;\n+    try {\n+      TestClass1 t1 = new TestClass1();\n+    } catch(Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Error should have been thrown\");\n+    Asserts.assertTrue(e.getClass() == NoClassDefFoundError.class, \"Must be a NoClassDefFoundError\");\n+    Asserts.assertTrue(e.getCause().getClass() == ExceptionInInitializerError.class, \"Must be an ExceptionInInitializerError\");\n+  }\n+\n+  static primitive class BadTwo {\n+    int i = 0;\n+    static {\n+      if (ClassInitializationFailuresTest.failingInitialization) {\n+        throw new RuntimeException(\"Failing initialization\");\n+      }\n+    }\n+  }\n+\n+  static primitive class BadThree {\n+    int i = 0;\n+    static {\n+      if (ClassInitializationFailuresTest.failingInitialization) {\n+        throw new RuntimeException(\"Failing initialization\");\n+      }\n+    }\n+  }\n+\n+  \/\/ Same test as above, but for arrays of primitive objects\n+  static void testArrayInitialization() {\n+    \/\/ Testing anewarray when the primitive element class fails to initialize properly\n+    Throwable e = null;\n+    try {\n+      BadTwo[] array = new BadTwo[10];\n+    } catch(Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Error should have been thrown\");\n+    Asserts.assertTrue(e.getClass() == ExceptionInInitializerError.class, \" Must be an ExceptionInInitializerError\");\n+    \/\/ Second attempt because it doesn't fail the same way\n+    try {\n+      BadTwo[] array = new BadTwo[10];\n+    } catch(Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Error should have been thrown\");\n+    Asserts.assertTrue(e.getClass() == NoClassDefFoundError.class, \"Must be a NoClassDefFoundError\");\n+    Asserts.assertTrue(e.getCause().getClass() == ExceptionInInitializerError.class, \"Must be an ExceptionInInitializerError\");\n+    \/\/ Testing multianewarray when the primitive element class fails to initialize properly\n+    try {\n+      BadThree[][] array = new BadThree[10][20];\n+    } catch(Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Error should have been thrown\");\n+    Asserts.assertTrue(e.getClass() == ExceptionInInitializerError.class, \" Must be an ExceptionInInitializerError\");\n+    \/\/ Second attempt because it doesn't fail the same way\n+    try {\n+      BadThree[][][] array = new BadThree[10][30][10];\n+    } catch(Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Error should have been thrown\");\n+    Asserts.assertTrue(e.getClass() == NoClassDefFoundError.class, \"Must be a NoClassDefFoundError\");\n+    Asserts.assertTrue(e.getCause().getClass() == ExceptionInInitializerError.class, \"Must be an ExceptionInInitializerError\");\n+  }\n+\n+  static primitive class BadFour {\n+    int i = 0;\n+    static BadFour[] array;\n+    static {\n+      array = new BadFour[10];\n+      if (ClassInitializationFailuresTest.failingInitialization) {\n+        throw new RuntimeException(\"Failing initialization\");\n+      }\n+    }\n+  }\n+\n+  \/\/ Even if a primitive class fails to initialize property, some instances\n+  \/\/ of this class can escape and be accessible. The JVM must be able to\n+  \/\/ deal with those instances without crashes. The test below checks that\n+  \/\/ escaped values stored in an array are handled correctly\n+  static void testEscapedValueInArray() {\n+    Throwable e = null;\n+    try {\n+      BadFour bt = new BadFour();\n+    } catch (Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Error must have been thrown\");\n+    Asserts.assertTrue(e.getClass() == ExceptionInInitializerError.class, \" Must be an ExceptionInInitializerError\");\n+    e = null;\n+    try {\n+      BadFour t = BadFour.array[0];\n+    } catch(Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Error should have been thrown\");\n+    Asserts.assertTrue(e.getClass() == NoClassDefFoundError.class, \"Must be a NoClassDefFoundError\");\n+    Asserts.assertTrue(e.getCause().getClass() == ExceptionInInitializerError.class, \"Must be an ExceptionInInitializerError\");\n+  }\n+\n+  static primitive class BadFive {\n+    int i = 0;\n+    static {\n+      ClassInitializationFailuresTest.bo = new BadSix();\n+      if (ClassInitializationFailuresTest.failingInitialization) {\n+        throw new RuntimeException(\"Failing initialization\");\n+      }\n+    }\n+  }\n+\n+  static class BadSix {\n+    BadFive bf = new BadFive();\n+  }\n+\n+  \/\/ Same test as above, but escaped values are stored in an object\n+  static void testEscapedValueInObject() {\n+    Throwable e = null;\n+    try {\n+      BadSix bt = new BadSix();\n+    } catch (Throwable t) {\n+      e = t;\n+    }\n+    Asserts.assertNotNull(e, \"Error must have been thrown\");\n+    Asserts.assertNotNull(ClassInitializationFailuresTest.bo, \"bo object should have been set\");\n+    BadFive bf = ((BadSix)ClassInitializationFailuresTest.bo).bf;\n+  }\n+\n+  public static void main(String[] args) {\n+    testClassInitialization();\n+    testArrayInitialization();\n+    testEscapedValueInArray();\n+    testEscapedValueInObject();\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ClassInitializationFailuresTest.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"}]}