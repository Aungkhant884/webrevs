{"files":[{"patch":"@@ -623,0 +623,4 @@\n+\n+        boolean tUndet = t.hasTag(UNDETVAR);\n+        boolean sUndet = s.hasTag(UNDETVAR);\n+\n@@ -625,2 +629,2 @@\n-                    isSubtype(t.referenceProjection(), s) :\n-                    !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n+                    isSubtype(allowUniversalTVars && (tUndet || sUndet) ? t : t.referenceProjection(), s) :\n+                    !t.hasTag(BOT) && isSubtype(t, allowUniversalTVars && (tUndet || sUndet) ? s : s.referenceProjection());\n@@ -634,2 +638,0 @@\n-        boolean tUndet = t.hasTag(UNDETVAR);\n-        boolean sUndet = s.hasTag(UNDETVAR);\n@@ -1034,0 +1036,5 @@\n+    \/\/ this relation is now named `extends` in the latest Valhalla docs\n+    public boolean isBoundedBy(Type t, Type s) {\n+        return isBoundedBy(t, s, noWarnings, (t1, s1, w1) -> isSubtype(t1, s1));\n+    }\n+\n@@ -4229,0 +4236,4 @@\n+        \/\/ lub is critical code better to go this way rather than using streams\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i] = ts[i].referenceProjectionOrSelf();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-        final InferenceContext inferenceContext = new InferenceContext(this, tvars);  \/\/B0\n+        final InferenceContext inferenceContext = new InferenceContext(this, tvars, allowBoxing);  \/\/B0\n@@ -178,1 +178,1 @@\n-            DeferredAttr.DeferredAttrContext deferredAttrContext =\n+                DeferredAttr.DeferredAttrContext deferredAttrContext =\n@@ -707,2 +707,2 @@\n-        boolean isSubtype(Type s, Type t, Warner warn) {\n-            return doIncorporationOp(IncorporationBinaryOpKind.IS_SUBTYPE, s, t, warn);\n+        boolean isSubtype(InferenceContext inferenceContext, Type s, Type t, Warner warn) {\n+            return doIncorporationOp(inferenceContext, IncorporationBinaryOpKind.IS_SUBTYPE, s, t, warn);\n@@ -715,1 +715,1 @@\n-            return doIncorporationOp(IncorporationBinaryOpKind.IS_SAME_TYPE, s, t, null);\n+            return doIncorporationOp(null, IncorporationBinaryOpKind.IS_SAME_TYPE, s, t, null);\n@@ -759,1 +759,1 @@\n-                    boolean success = checkBound(t, b, from, to, warn);\n+                    boolean success = checkBound(inferenceContext, t, b, from, to, warn);\n@@ -779,1 +779,1 @@\n-        boolean checkBound(Type s, Type t, InferenceBound ib_s, InferenceBound ib_t, Warner warn) {\n+        boolean checkBound(InferenceContext inferenceContext, Type s, Type t, InferenceBound ib_s, InferenceBound ib_t, Warner warn) {\n@@ -781,1 +781,1 @@\n-                return isSubtype(s, t, warn);\n+                return isSubtype(inferenceContext, s, t, warn);\n@@ -783,1 +783,1 @@\n-                return isSubtype(t, s, warn);\n+                return isSubtype(inferenceContext, t, s, warn);\n@@ -1152,2 +1152,2 @@\n-    boolean doIncorporationOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, Warner warn) {\n-            IncorporationBinaryOp newOp = new IncorporationBinaryOp(opKind, op1, op2);\n+    boolean doIncorporationOp(InferenceContext inferenceContext, IncorporationBinaryOpKind opKind, Type op1, Type op2, Warner warn) {\n+            IncorporationBinaryOp newOp = new IncorporationBinaryOp(inferenceContext, opKind, op1, op2);\n@@ -1169,2 +1169,4 @@\n-            boolean apply(Type op1, Type op2, Warner warn, Types types) {\n-                return types.isBoundedBy(op1, op2, warn, (t, s, w) -> types.isSubtypeUnchecked(t, s, w));\n+            boolean apply(InferenceContext inferenceContext, Type op1, Type op2, Warner warn, Types types) {\n+                return inferenceContext.allowBoxing ?\n+                    types.isBoundedBy(op1, op2, warn, (t, s, w) -> types.isSubtypeUnchecked(t, s, w)) :\n+                    types.isSubtypeUnchecked(op1, op2, warn);\n@@ -1175,1 +1177,1 @@\n-            boolean apply(Type op1, Type op2, Warner warn, Types types) {\n+            boolean apply(InferenceContext inferenceContext, Type op1, Type op2, Warner warn, Types types) {\n@@ -1180,1 +1182,1 @@\n-        abstract boolean apply(Type op1, Type op2, Warner warn, Types types);\n+        abstract boolean apply(InferenceContext inferenceContext, Type op1, Type op2, Warner warn, Types types);\n@@ -1195,0 +1197,1 @@\n+        InferenceContext inferenceContext;\n@@ -1196,1 +1199,2 @@\n-        IncorporationBinaryOp(IncorporationBinaryOpKind opKind, Type op1, Type op2) {\n+        IncorporationBinaryOp(InferenceContext inferenceContext, IncorporationBinaryOpKind opKind, Type op1, Type op2) {\n+            this.inferenceContext = inferenceContext;\n@@ -1221,1 +1225,1 @@\n-            return opKind.apply(op1, op2, warn, types);\n+            return opKind.apply(inferenceContext, op1, op2, warn, types);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+    boolean allowBoxing;\n+\n@@ -89,1 +91,5 @@\n-        this(infer, inferencevars, inferencevars.map(infer.fromTypeVarFun));\n+        this(infer, inferencevars, inferencevars.map(infer.fromTypeVarFun), false);\n+    }\n+\n+    public InferenceContext(Infer infer, List<Type> inferencevars, boolean allowBoxing) {\n+        this(infer, inferencevars, inferencevars.map(infer.fromTypeVarFun), allowBoxing);\n@@ -93,0 +99,4 @@\n+        this(infer, inferencevars, undetvars, false);\n+    }\n+\n+    public InferenceContext(Infer infer, List<Type> inferencevars, List<Type> undetvars, boolean allowBoxing) {\n@@ -97,0 +107,1 @@\n+        this.allowBoxing = allowBoxing;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1056,2 +1056,1 @@\n-                    types.isBoundedBy(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn,\n-                                (t, s, w) -> types.isSubtypeUnchecked(t, s, w)) :\n+                    types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1849,1 +1849,1 @@\n-        todo.clear();\n+        if (todo != null) todo.clear();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,3 +58,1 @@\n-        List<String> typeVars = new ArrayList<>();\n-        typeVars.add(\"T\");\n-        strToTypeFactory = new StrToTypeFactory(null, imports, typeVars);\n+        strToTypeFactory = new StrToTypeFactory(null, imports, null);\n@@ -68,2 +66,5 @@\n-        Type freeType = strToTypeFactory.getType(freeTypeStr);\n-        Type aType = strToTypeFactory.getType(typeStr);\n+        java.util.Map<String, Type> typeMap = strToTypeFactory.getTypes(\n+                List.of(\"T\"),\n+                \"\",\n+                freeTypeStr, typeStr, \"T\"\n+        );\n@@ -71,1 +72,5 @@\n-        withInferenceContext(strToTypeFactory.getTypeVars(), inferenceContext -> {\n+        Type freeType = typeMap.get(freeTypeStr);\n+        Type aType = typeMap.get(typeStr);\n+        Type tVar = typeMap.get(\"T\");\n+\n+        withInferenceContext(com.sun.tools.javac.util.List.of(tVar), inferenceContext -> {\n@@ -77,1 +82,1 @@\n-        withInferenceContext(strToTypeFactory.getTypeVars(), inferenceContext -> {\n+        withInferenceContext(com.sun.tools.javac.util.List.of(tVar), inferenceContext -> {\n","filename":"test\/langtools\/tools\/javac\/T8159970\/TypeEqualityInInferenceTest.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary overload resolution tests for universal type variables\n+ * @compile\/ref=UniversalTVarsOverloadResolutionTest.out -XDrawDiagnostics --should-stop=ifError=ATTR --should-stop=ifNoError=ATTR --debug=verboseResolution=applicable,success,deferred-inference UniversalTVarsOverloadResolutionTest.java\n+ *\/\n+\n+class UniversalTVarsOverloadResolutionTest {\n+    interface MyCollection<__universal T> {}\n+\n+    static class MyList<__universal T> implements MyCollection<T> {\n+        static <T> MyList<T> of(T element) { return null; }\n+    }\n+\n+    interface Shape {}\n+    primitive class Point implements Shape {}\n+\n+    <__universal X> void m1(X x) {}\n+    void m1(Point.ref p) {}\n+\n+    void m2(Point p, Object o) {}\n+    <__universal X> void m2(X x, String s) {}\n+\n+    void test() {\n+        MyList.of(new Point());\n+        MyCollection<Point.ref> refColl = MyList.of(new Point());\n+        MyCollection<Shape> shapeColl = MyList.of(new Point());\n+\n+        m1(Point.default);\n+\n+        m2(Point.default, null);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsOverloadResolutionTest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+UniversalTVarsOverloadResolutionTest.java:24:19: compiler.note.verbose.resolve.multi: <init>, UniversalTVarsOverloadResolutionTest.Point, 0, BASIC, compiler.misc.no.args, compiler.misc.no.args,{(compiler.misc.applicable.method.found: 0, UniversalTVarsOverloadResolutionTest.Point(), null)}\n+UniversalTVarsOverloadResolutionTest.java:24:15: compiler.note.verbose.resolve.multi: of, UniversalTVarsOverloadResolutionTest.MyList, 0, BOX, UniversalTVarsOverloadResolutionTest.Point, compiler.misc.no.args,{(compiler.misc.applicable.method.found.1: 0, <T>of(T), (compiler.misc.partial.inst.sig: (UniversalTVarsOverloadResolutionTest.Point)UniversalTVarsOverloadResolutionTest.MyList<UniversalTVarsOverloadResolutionTest.Point>))}\n+UniversalTVarsOverloadResolutionTest.java:24:18: compiler.note.deferred.method.inst: <T>of(T), (UniversalTVarsOverloadResolutionTest.Point)UniversalTVarsOverloadResolutionTest.MyList<UniversalTVarsOverloadResolutionTest.Point>, compiler.misc.type.none\n+UniversalTVarsOverloadResolutionTest.java:25:53: compiler.note.verbose.resolve.multi: <init>, UniversalTVarsOverloadResolutionTest.Point, 0, BASIC, compiler.misc.no.args, compiler.misc.no.args,{(compiler.misc.applicable.method.found: 0, UniversalTVarsOverloadResolutionTest.Point(), null)}\n+UniversalTVarsOverloadResolutionTest.java:25:49: compiler.note.verbose.resolve.multi: of, UniversalTVarsOverloadResolutionTest.MyList, 0, BOX, UniversalTVarsOverloadResolutionTest.Point, compiler.misc.no.args,{(compiler.misc.applicable.method.found.1: 0, <T>of(T), (compiler.misc.partial.inst.sig: (UniversalTVarsOverloadResolutionTest.Point)UniversalTVarsOverloadResolutionTest.MyList<UniversalTVarsOverloadResolutionTest.Point>))}\n+UniversalTVarsOverloadResolutionTest.java:25:52: compiler.note.deferred.method.inst: <T>of(T), (UniversalTVarsOverloadResolutionTest.Point.ref)UniversalTVarsOverloadResolutionTest.MyList<UniversalTVarsOverloadResolutionTest.Point.ref>, UniversalTVarsOverloadResolutionTest.MyCollection<UniversalTVarsOverloadResolutionTest.Point.ref>\n+UniversalTVarsOverloadResolutionTest.java:26:51: compiler.note.verbose.resolve.multi: <init>, UniversalTVarsOverloadResolutionTest.Point, 0, BASIC, compiler.misc.no.args, compiler.misc.no.args,{(compiler.misc.applicable.method.found: 0, UniversalTVarsOverloadResolutionTest.Point(), null)}\n+UniversalTVarsOverloadResolutionTest.java:26:47: compiler.note.verbose.resolve.multi: of, UniversalTVarsOverloadResolutionTest.MyList, 0, BOX, UniversalTVarsOverloadResolutionTest.Point, compiler.misc.no.args,{(compiler.misc.applicable.method.found.1: 0, <T>of(T), (compiler.misc.partial.inst.sig: (UniversalTVarsOverloadResolutionTest.Point)UniversalTVarsOverloadResolutionTest.MyList<UniversalTVarsOverloadResolutionTest.Point>))}\n+UniversalTVarsOverloadResolutionTest.java:26:50: compiler.note.deferred.method.inst: <T>of(T), (UniversalTVarsOverloadResolutionTest.Shape)UniversalTVarsOverloadResolutionTest.MyList<UniversalTVarsOverloadResolutionTest.Shape>, UniversalTVarsOverloadResolutionTest.MyCollection<UniversalTVarsOverloadResolutionTest.Shape>\n+UniversalTVarsOverloadResolutionTest.java:28:9: compiler.note.verbose.resolve.multi: m1, UniversalTVarsOverloadResolutionTest, 0, BOX, UniversalTVarsOverloadResolutionTest.Point, compiler.misc.no.args,{(compiler.misc.applicable.method.found: 0, m1(UniversalTVarsOverloadResolutionTest.Point.ref), null),(compiler.misc.applicable.method.found.1: 1, <X>m1(X), (compiler.misc.partial.inst.sig: (UniversalTVarsOverloadResolutionTest.Point)void))}\n+UniversalTVarsOverloadResolutionTest.java:30:9: compiler.note.verbose.resolve.multi: m2, UniversalTVarsOverloadResolutionTest, 0, BASIC, UniversalTVarsOverloadResolutionTest.Point,compiler.misc.type.null, compiler.misc.no.args,{(compiler.misc.applicable.method.found: 0, m2(UniversalTVarsOverloadResolutionTest.Point,java.lang.Object), null)}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsOverloadResolutionTest.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8159970\n+ * @summary tests for the type system of universal type variables\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ * @build TypeHarness\n+ * @run main UniversalTvarsTypeSystemTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.UndetVar;\n+import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;\n+import com.sun.tools.javac.code.Types;\n+\n+import com.sun.tools.javac.comp.Infer;\n+import com.sun.tools.javac.comp.InferenceContext;\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+public class UniversalTvarsTypeSystemTest extends TypeHarness {\n+    StrToTypeFactory strToTypeFactory;\n+    Types types;\n+    Infer infer;\n+\n+    UniversalTvarsTypeSystemTest() {\n+        types = Types.instance(context);\n+        infer = Infer.instance(context);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new UniversalTvarsTypeSystemTest().runAll();\n+    }\n+\n+    void runAll() {\n+        strToTypeFactory = new StrToTypeFactory();\n+        testLUB_and_GLB();\n+        test_isBoundedBy();\n+    }\n+\n+    void testLUB_and_GLB() {\n+        java.util.Map<String, Type> typeMap = strToTypeFactory.getTypes(\n+                List.of(),\n+                \"\"\"\n+                interface I {}\n+                static abstract class A {}\n+                primitive class Point extends A implements I {}\n+                \"\"\",\n+                \"Point\", \"Point.ref\", \"A\", \"I\");\n+        Assert.check(types.lub(typeMap.get(\"Point\"), typeMap.get(\"Point.ref\")).tsym == typeMap.get(\"Point.ref\").tsym);\n+        Assert.check(types.lub(typeMap.get(\"Point\"), typeMap.get(\"A\")).tsym == typeMap.get(\"A\").tsym);\n+        Assert.check(types.lub(typeMap.get(\"Point\"), typeMap.get(\"I\")).tsym == typeMap.get(\"I\").tsym);\n+\n+        \/\/ this is currently failing we need to update the implementation of Types::glb\n+        \/\/Assert.check(types.glb(primitiveType, primitiveRefType).tsym == primitiveType.tsym);\n+    }\n+\n+    void test_isBoundedBy() {\n+        java.util.Map<String, Type> typeMap =  strToTypeFactory.getTypes(\n+                List.of(),\n+                \"\"\"\n+                class MyList<__universal T> {}\n+                interface Shape {}\n+                primitive class Point implements Shape {}\n+                \"\"\",\n+                \"Point\", \"Point.ref\", \"Object\",\n+                \"MyList<Point>\", \"MyList<? extends Shape>\",\n+                \"MyList<Shape>\", \"MyList<? super Point>\");\n+        Assert.check(types.isBoundedBy(typeMap.get(\"Point\"), typeMap.get(\"Object\")));\n+        Assert.check(types.isBoundedBy(typeMap.get(\"Point.ref\"), typeMap.get(\"Object\")));\n+        Assert.check(types.isSubtype(typeMap.get(\"MyList<Point>\"), typeMap.get(\"MyList<? extends Shape>\")));\n+        Assert.check(types.isSubtype(typeMap.get(\"MyList<Shape>\"), typeMap.get(\"MyList<? super Point>\")));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTvarsTypeSystemTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.Arrays;\n@@ -57,0 +58,1 @@\n+import static com.sun.tools.javac.code.Kinds.Kind.*;\n@@ -414,0 +416,5 @@\n+        String declarations = \"\";\n+\n+        public StrToTypeFactory() {\n+            this(null, null, null, \"\");\n+        }\n@@ -416,19 +423,1 @@\n-            this.pkg = pkg;\n-            this.imports = imports;\n-            this.typeVarDecls = typeVarDecls == null ? new ArrayList<>() : typeVarDecls;\n-            this.typeVariables = from(this.typeVarDecls.stream()\n-                    .map(this::typeVarName)\n-                    .map(this::getType)\n-                    .collect(Collectors.toList())\n-            );\n-        }\n-\n-        TypeVar getTypeVarFromStr(String name) {\n-            if (typeVarDecls.isEmpty()) {\n-                return null;\n-            }\n-            int index = typeVarDecls.indexOf(name);\n-            if (index != -1) {\n-                return (TypeVar)typeVariables.get(index);\n-            }\n-            return null;\n+            this(pkg, imports, typeVarDecls, \"\");\n@@ -437,2 +426,5 @@\n-        List<Type> getTypeVars() {\n-            return typeVariables;\n+        public StrToTypeFactory(String pkg, java.util.List<String> imports, java.util.List<String> typeVarDecls, String declarations) {\n+            this.pkg = pkg;\n+            this.imports = imports != null ? imports : java.util.List.of();\n+            this.typeVarDecls = typeVarDecls != null ? typeVarDecls : java.util.List.of();\n+            this.declarations = declarations != null ? declarations : \"\";\n@@ -446,3 +438,10 @@\n-        public final Type getType(String type) {\n-            JavaSource source = new JavaSource(type);\n-            MyAttr.theType = null;\n+        public final Type getType(String typeDecl) {\n+            java.util.Map<String, Type> typeMap = getTypes(java.util.List.of(), \"\", typeDecl);\n+            return typeMap.get(typeDecl);\n+        }\n+\n+        public final java.util.Map<String, Type> getTypes(java.util.List<String> typeVarDecls, String declarations, String... types) {\n+            this.declarations = declarations != null ? declarations : \"\";\n+            this.typeVarDecls = typeVarDecls != null ? typeVarDecls : java.util.List.of();\n+            JavaSource source = new JavaSource(types);\n+            MyAttr.types.clear();\n@@ -451,0 +450,2 @@\n+            MyAttr.wrapperClassName = source.wrapperClassName;\n+            MyAttr.typeNames = new ArrayList<>(Arrays.asList(types));\n@@ -452,0 +453,1 @@\n+            tool.shouldStopPolicyIfNoError = com.sun.tools.javac.comp.CompileStates.CompileState.ATTR;\n@@ -457,4 +459,1 @@\n-            if (typeVariables != null) {\n-                return types.subst(MyAttr.theType, MyAttr.typeParameters, typeVariables);\n-            }\n-            return MyAttr.theType;\n+            return MyAttr.types;\n@@ -466,8 +465,14 @@\n-            String type;\n-            String template = \"#Package;\\n\" +\n-                    \"#Imports\\n\" +\n-                    \"class G#Id#TypeVars {\\n\" +\n-                    \"   #FieldType var;\" +\n-                    \"}\";\n-\n-            JavaSource(String type) {\n+            String[] types;\n+            String wrapperClassName;\n+            String template =\n+                    \"\"\"\n+                    #Package;\n+                    #Imports\n+                    class __G#Id#TypeVars {\n+                        #declarations\n+                        \/\/ field declarations below\n+                        #FieldDecls\n+                    }\n+                    \"\"\";\n+\n+            JavaSource(String... types) {\n@@ -476,1 +481,2 @@\n-                this.type = type;\n+                this.wrapperClassName = \"__G\" + id;\n+                this.types = types;\n@@ -485,1 +491,5 @@\n-                return template\n+                String fieldDecls = \"\";\n+                for (String type : types) {\n+                    fieldDecls += \" \" + type + \" var\" + StrToTypeFactory.this.id++ + \";\";\n+                }\n+                String src = template\n@@ -490,1 +500,4 @@\n-                        .replace(\"#FieldType\", type);\n+                        .replace(\"#declarations\", declarations)\n+                        .replace(\"#FieldDecls\", fieldDecls);\n+                System.err.println(\"source obtained:\\n\" + src);\n+                return src;\n@@ -499,1 +512,2 @@\n-        private static Type theType;\n+        static java.util.List<String> typeNames = new ArrayList<>();\n+        private static java.util.Map<String, Type> types = new java.util.LinkedHashMap<>();\n@@ -501,0 +515,1 @@\n+        static String wrapperClassName;\n@@ -513,1 +528,3 @@\n-            theType = tree.type;\n+            if (tree.sym.owner.kind == TYP && tree.sym.owner.name.toString().equals(wrapperClassName)) {\n+                types.put(typeNames.remove(0), tree.type);\n+            }\n@@ -536,1 +553,1 @@\n-            \/\/do nothing\n+            \/\/ do nothing the super class will set to null all compiler components, that is not what you want\n","filename":"test\/langtools\/tools\/lib\/types\/TypeHarness.java","additions":59,"deletions":42,"binary":false,"changes":101,"status":"modified"}]}