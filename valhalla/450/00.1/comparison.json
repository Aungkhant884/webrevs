{"files":[{"patch":"@@ -514,4 +514,2 @@\n-\n-  ciType* return_type = method->return_type();\n-  if (InlineTypeReturnedAsFields && return_type->is_inlinetype()) {\n-    ciInlineKlass* vk = return_type->as_inline_klass();\n+  if (InlineTypeReturnedAsFields && method->signature()->returns_null_free_inline_type()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n@@ -1632,1 +1630,1 @@\n-    __ tst(tmp, markWord::nullfree_array_bit_in_place);\n+    __ tst(tmp, markWord::null_free_array_bit_in_place);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1602,1 +1602,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, true, is_null_free_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n@@ -1606,1 +1606,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, false, is_non_null_free_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -534,3 +534,2 @@\n-  ciType* return_type = method->return_type();\n-  if (InlineTypeReturnedAsFields && return_type->is_inlinetype()) {\n-    ciInlineKlass* vk = return_type->as_inline_klass();\n+  if (InlineTypeReturnedAsFields && method->signature()->returns_null_free_inline_type()) {\n+    ciInlineKlass* vk = method->return_type()->as_inline_klass();\n@@ -2033,1 +2032,1 @@\n-    __ testl(tmp, markWord::nullfree_array_bit_in_place);\n+    __ testl(tmp, markWord::null_free_array_bit_in_place);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2957,1 +2957,1 @@\n-void MacroAssembler::test_field_is_inline_type(Register flags, Register temp_reg, Label& is_inline_type) {\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n@@ -2959,1 +2959,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_inline_type_shift);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n@@ -2962,1 +2962,1 @@\n-  jcc(Assembler::notZero, is_inline_type);\n+  jcc(Assembler::notZero, is_null_free_inline_type);\n@@ -2965,1 +2965,1 @@\n-void MacroAssembler::test_field_is_not_inline_type(Register flags, Register temp_reg, Label& not_inline_type) {\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n@@ -2967,1 +2967,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_inline_type_shift);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n@@ -2970,1 +2970,1 @@\n-  jcc(Assembler::zero, not_inline_type);\n+  jcc(Assembler::zero, not_null_free_inline_type);\n@@ -3022,1 +3022,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, true, is_null_free_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n@@ -3032,1 +3032,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, false, is_non_null_free_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-  void test_field_is_inline_type(Register flags, Register temp_reg, Label& is_inline);\n-  void test_field_is_not_inline_type(Register flags, Register temp_reg, Label& not_inline);\n+  void test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free);\n+  void test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2995,1 +2995,1 @@\n-        Label is_inline_type, uninitialized;\n+        Label is_null_free_inline_type, uninitialized;\n@@ -2997,2 +2997,2 @@\n-        __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n-          \/\/ field is not an inline type\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n+          \/\/ field is not a null free inline type\n@@ -3001,2 +3001,2 @@\n-        \/\/ field is an inline type, must not return null even if uninitialized\n-        __ bind(is_inline_type);\n+        \/\/ field is a null free inline type, must not return null even if uninitialized\n+        __ bind(is_null_free_inline_type);\n@@ -3029,1 +3029,1 @@\n-        __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n@@ -3031,1 +3031,1 @@\n-      \/\/ field is not an inline type\n+      \/\/ field is not a null free inline type\n@@ -3382,1 +3382,1 @@\n-          __ test_field_is_not_inline_type(flags2, rscratch1, is_inline_type);\n+          __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n@@ -3391,1 +3391,1 @@\n-          __ test_field_is_inline_type(flags2, rscratch1, is_inline_type);\n+          __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -679,1 +679,1 @@\n-      if (!is_interface && klass->is_subtype_of(x->klass())) {\n+      if (!is_interface && klass->is_subtype_of(x->klass()) && (!x->is_null_free() || obj->is_null_free())) {\n@@ -685,2 +685,2 @@\n-    \/\/ checkcast of null returns null for non-inline klasses\n-    if (!x->klass()->is_inlinetype() && obj->as_Constant() && obj->type()->as_ObjectType()->constant_value()->is_null_object()) {\n+    \/\/ checkcast of null returns null for non null-free klasses\n+    if (!x->is_null_free() && obj->is_null_obj()) {\n@@ -700,1 +700,1 @@\n-    if (obj->as_Constant() && obj->type()->as_ObjectType()->constant_value()->is_null_object()) {\n+    if (obj->as_Constant() && obj->is_null_obj()) {\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1843,1 +1843,1 @@\n-      } else if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      } else if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1868,1 +1868,1 @@\n-      if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1886,1 +1886,1 @@\n-        if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+        if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -1895,1 +1895,1 @@\n-              if (field->signature()->is_Q_signature() && field_value.is_null_or_zero()) {\n+              if (field->is_null_free() && field_value.is_null_or_zero()) {\n@@ -2041,1 +2041,1 @@\n-      if (field_type == T_INLINE_TYPE && field->type()->as_inline_klass()->is_empty()) {\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n@@ -2473,1 +2473,1 @@\n-                              declared_signature->return_type()->is_inlinetype());\n+                              declared_signature->returns_null_free_inline_type());\n@@ -2517,1 +2517,1 @@\n-  bool null_free = stream()->is_inline_klass();\n+  bool null_free = stream()->has_Q_signature();\n@@ -2544,1 +2544,1 @@\n-  bool null_free = stream()->is_inline_klass();\n+  bool null_free = stream()->has_Q_signature();\n@@ -3572,1 +3572,1 @@\n-    state->store_local(idx, new Local(type, vt, idx, false, type->is_inlinetype()));\n+    state->store_local(idx, new Local(type, vt, idx, false, sig->is_null_free_at(i)));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  ciType* t =  declared_type();\n+  ciType* t = declared_type();\n@@ -141,2 +141,2 @@\n-      if (type->is_obj_array_klass()) {\n-        \/\/ Due to array covariance, the runtime type might be a flattened array.\n+      if (type->is_obj_array_klass() && !type->as_obj_array_klass()->is_elem_null_free()) {\n+        \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue.\n@@ -148,2 +148,0 @@\n-        ciKlass* element_klass = type->as_flat_array_klass()->element_klass();\n-        assert(!element_klass->is_loaded() || element_klass->flatten_array(), \"must be flattened\");\n@@ -169,2 +167,1 @@\n-      ciKlass* element_klass = type->as_obj_array_klass()->element_klass();\n-      if (element_klass->can_be_inline_klass()) {\n+      if (type->as_obj_array_klass()->can_be_inline_array_klass()) {\n@@ -293,1 +290,1 @@\n-  return ciArrayKlass::make(klass());\n+  return ciArrayKlass::make(klass(), is_null_free());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -864,1 +864,1 @@\n-    set_null_free(field->signature()->is_Q_signature());\n+    set_null_free(field->is_null_free());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1073,1 +1073,1 @@\n-      (method()->signature()->returns_inline_type() ||\n+      (method()->signature()->returns_null_free_inline_type() ||\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1741,1 +1741,1 @@\n-  if (field->signature()->is_Q_signature()) {\n+  if (field->is_null_free()) {\n@@ -2040,1 +2040,1 @@\n-  if (!field->signature()->is_Q_signature()) {\n+  if (!field->is_null_free()) {\n@@ -2128,1 +2128,1 @@\n-  if (field->signature()->is_Q_signature()) {\n+  if (field->is_null_free()) {\n@@ -3078,5 +3078,0 @@\n-  \/\/ Inline types can't be null\n-  if (exact_klass != NULL && exact_klass->is_inlinetype()) {\n-    do_null = false;\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -478,1 +478,2 @@\n-      return ciArrayKlass::make(elem_klass);\n+      bool null_free_array = sym->is_Q_array_signature() && sym->char_at(1) == JVM_SIGNATURE_INLINE_TYPE;\n+      return ciArrayKlass::make(elem_klass, null_free_array);\n@@ -605,1 +606,1 @@\n-bool ciEnv::is_inline_klass(const constantPoolHandle& cpool, int index) {\n+bool ciEnv::has_Q_signature(const constantPoolHandle& cpool, int index) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,0 +108,3 @@\n+  \/\/ this is needed if the field class is not yet loaded.\n+  _is_null_free = _signature->is_Q_signature();\n+\n@@ -240,0 +243,1 @@\n+  _is_null_free = field->is_null_free();\n@@ -289,0 +293,1 @@\n+  _is_null_free = fd->signature()->is_Q_signature();\n@@ -486,0 +491,1 @@\n+  tty->print(\" is_null_free=%s\", bool_to_str(_is_null_free));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5753,1 +5753,1 @@\n-      if (ik->field_is_inline_type(i)) {\n+      if (ik->field_is_null_free_inline_type(i)) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -779,0 +779,2 @@\n+int java_lang_Class::_primary_mirror_offset;\n+int java_lang_Class::_secondary_mirror_offset;\n@@ -1015,2 +1017,2 @@\n-        InlineKlass* vk = InlineKlass::cast(InstanceKlass::cast(element_klass));\n-        comp_mirror = Handle(THREAD, vk->java_mirror());\n+        InlineKlass* vk = InlineKlass::cast(element_klass);\n+        comp_mirror = Handle(THREAD, vk->val_mirror());\n@@ -1024,1 +1026,6 @@\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+        oop comp_oop = element_klass->java_mirror();\n+        if (element_klass->is_inline_klass()) {\n+          InlineKlass* ik = InlineKlass::cast(element_klass);\n+          comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+        }\n+        comp_mirror = Handle(THREAD, comp_oop);\n@@ -1064,0 +1071,6 @@\n+\n+    if (k->is_inline_klass()) {\n+      oop secondary_mirror = create_secondary_mirror(k, mirror, CHECK);\n+      set_primary_mirror(mirror(), mirror());\n+      set_secondary_mirror(mirror(), secondary_mirror);\n+    }\n@@ -1069,0 +1082,21 @@\n+\/\/ Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class\n+\/\/ instance with the same value as the primary mirror\n+oop java_lang_Class::create_secondary_mirror(Klass* k, Handle mirror, TRAPS) {\n+  assert(k->is_inline_klass(), \"primitive class\");\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK_0);\n+  Handle secondary_mirror(THREAD, mirror_oop);\n+\n+  java_lang_Class::set_klass(secondary_mirror(), k);\n+  java_lang_Class::set_static_oop_field_count(secondary_mirror(), static_oop_field_count(mirror()));\n+  \/\/ ## do we need to set init lock?\n+  java_lang_Class::set_init_lock(secondary_mirror(), init_lock(mirror()));\n+\n+  set_protection_domain(secondary_mirror(), protection_domain(mirror()));\n+  set_class_loader(secondary_mirror(), class_loader(mirror()));\n+  \/\/ ## handle if java.base is not yet defined\n+  set_module(secondary_mirror(), module(mirror()));\n+  set_primary_mirror(secondary_mirror(), mirror());\n+  set_secondary_mirror(secondary_mirror(), secondary_mirror());\n+  return secondary_mirror();\n+}\n@@ -1215,1 +1249,1 @@\n-    \/\/ Inline types have a val type mirror and a ref type mirror. Don't handle this for now. TODO:CDS\n+    \/\/ Inline types have a primary mirror and a secondary mirror. Don't handle this for now. TODO:CDS\n@@ -1435,0 +1469,20 @@\n+oop java_lang_Class::primary_mirror(oop java_class) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_primary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_primary_mirror(oop java_class, oop mirror) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_primary_mirror_offset, mirror);\n+}\n+\n+oop java_lang_Class::secondary_mirror(oop java_class) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_secondary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_secondary_mirror(oop java_class, oop mirror) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_secondary_mirror_offset, mirror);\n+}\n+\n@@ -1538,1 +1592,1 @@\n-  bool is_value = false;\n+  bool is_Q_descriptor = false;\n@@ -1544,1 +1598,1 @@\n-    is_value = k->is_inline_klass();\n+    is_Q_descriptor = k->is_inline_klass() && is_secondary_mirror(java_class);\n@@ -1552,5 +1606,1 @@\n-    if (is_value) {\n-      st->print(\"Q\");\n-    } else {\n-      st->print(\"L\");\n-    }\n+    st->print(is_Q_descriptor ? \"Q\" : \"L\");\n@@ -1578,1 +1628,6 @@\n-      const char* sigstr = k->signature_name();\n+      const char* sigstr;\n+      if (k->is_inline_klass() && is_secondary_mirror(java_class)) {\n+        sigstr = InlineKlass::cast(k)->val_signature_name();\n+      } else {\n+        sigstr = k->signature_name();\n+      }\n@@ -1659,0 +1714,2 @@\n+  macro(_primary_mirror_offset,      k, \"primaryType\",         class_signature,       false); \\\n+  macro(_secondary_mirror_offset,    k, \"secondaryType\",       class_signature,       false); \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":69,"deletions":12,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -279,0 +279,3 @@\n+  static int _primary_mirror_offset;\n+  static int _secondary_mirror_offset;\n+\n@@ -293,0 +296,3 @@\n+  static void set_primary_mirror(oop java_class, oop comp_mirror);\n+  static void set_secondary_mirror(oop java_class, oop comp_mirror);\n+\n@@ -305,0 +311,1 @@\n+  static oop  create_secondary_mirror(Klass* k, Handle mirror, TRAPS);\n@@ -352,0 +359,5 @@\n+  static oop  primary_mirror(oop java_class);\n+  static oop  secondary_mirror(oop java_class);\n+  static bool is_primary_mirror(oop java_class);\n+  static bool is_secondary_mirror(oop java_class);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -264,0 +264,18 @@\n+inline bool java_lang_Class::is_primary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == primary_mirror(java_class);\n+  } else {\n+    return true;\n+  }\n+}\n+\n+inline bool java_lang_Class::is_secondary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == secondary_mirror(java_class);\n+  } else {\n+    return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -321,5 +321,8 @@\n-      if ((class_name->is_Q_array_signature() && !k->is_inline_klass()) ||\n-          (!class_name->is_Q_array_signature() && k->is_inline_klass())) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n-          }\n-      k = k->array_klass(ndims, CHECK_NULL);\n+      if (class_name->is_Q_array_signature()) {\n+        if (!k->is_inline_klass()) {\n+          THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), \"L\/Q mismatch on bottom type\");\n+        }\n+        k = InlineKlass::cast(k)->null_free_inline_array_klass(ndims, CHECK_NULL);\n+      } else {\n+        k = k->array_klass(ndims, CHECK_NULL);\n+      }\n@@ -862,1 +865,5 @@\n-      k = k->array_klass_or_null(ndims);\n+      if (class_name->is_Q_array_signature()) {\n+        k = InlineKlass::cast(k)->null_free_inline_array_klass_or_null(ndims);\n+      } else {\n+        k = k->array_klass_or_null(ndims);\n+      }\n@@ -1856,1 +1863,5 @@\n-      klass = klass->array_klass_or_null(ndims);\n+      if (class_name->is_Q_array_signature()) {\n+        klass = InlineKlass::cast(klass)->null_free_inline_array_klass_or_null(ndims);\n+      } else {\n+        klass = klass->array_klass_or_null(ndims);\n+      }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -692,0 +692,2 @@\n+  template(primaryType_name,                           \"primaryType\")                                             \\\n+  template(secondaryType_name,                         \"secondaryType\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,3 @@\n-  oop java_class = klass->java_mirror();\n+  oop java_class = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(klass)->val_mirror()\n+                      : klass->java_mirror();\n@@ -353,1 +355,1 @@\n-      if (voop == NULL && cp_entry->is_inline_type()) {\n+      if (voop == NULL && cp_entry->is_null_free_inline_type()) {\n@@ -383,0 +385,1 @@\n+  assert(klass->field_signature(index)->is_Q_signature(), \"Sanity check\");\n@@ -959,1 +962,1 @@\n-    info.is_inline_type()\n+    info.signature()->is_Q_signature() && info.is_inline_type()\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1025,1 +1025,3 @@\n-      result_oop = resolved->java_mirror();\n+      result_oop = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(resolved)->val_mirror()\n+                      : resolved->java_mirror();\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-                                       bool is_inline_type) {\n+                                       bool is_null_free_inline_type) {\n@@ -145,1 +145,1 @@\n-  assert(!is_inlined || is_inline_type, \"Sanity check\");\n+  assert(!is_inlined || is_null_free_inline_type, \"Sanity check\");\n@@ -150,1 +150,1 @@\n-                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),\n+                  ((is_null_free_inline_type ? 1 : 0) << is_null_free_inline_type_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-bool InstanceKlass::field_is_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_INLINE_TYPE; }\n+bool InstanceKlass::field_is_null_free_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_INLINE_TYPE; }\n@@ -1545,1 +1545,2 @@\n-        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this,\n+                                                                  false, false, CHECK_NULL);\n@@ -2871,0 +2872,4 @@\n+  return signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+}\n+\n+const char* InstanceKlass::signature_name_of_carrier(char c) const {\n@@ -2882,1 +2887,1 @@\n-  dest[dest_index++] = is_inline_klass() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;\n+  dest[dest_index++] = c;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  ArrayKlass** _null_free_inline_array_klasses;\n@@ -558,1 +559,1 @@\n-  bool    field_is_inline_type(int index) const;\n+  bool    field_is_null_free_inline_type(int index) const;\n@@ -1249,0 +1250,1 @@\n+  const char* signature_name_of_carrier(char c) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -594,2 +594,0 @@\n-  \/\/ For value classes, this returns the name with a leading 'Q' and a trailing ';'\n-  \/\/     and the package separators as '\/'.\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-\/\/  unused:1 | <-- hash:31 -->| unused:22 larval:1 age:4 flat_array:1 nullfree_array:1 inline_type:1 lock:2\n+\/\/  unused:1 | <-- hash:31 -->| unused:22 larval:1 age:4 flat_array:1 null_free_array:1 inline_type:1 lock:2\n@@ -142,1 +142,1 @@\n-\/\/  The \"fast\" static type bits (flat_array, nullfree_array, and inline_type)\n+\/\/  The \"fast\" static type bits (flat_array, null_free_array, and inline_type)\n@@ -202,1 +202,1 @@\n-  static const int nullfree_array_bits            = LP64_ONLY(1) NOT_LP64(0);\n+  static const int null_free_array_bits           = LP64_ONLY(1) NOT_LP64(0);\n@@ -207,1 +207,1 @@\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - inline_type_bits - larval_bits - flat_array_bits - nullfree_array_bits;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - inline_type_bits - larval_bits - flat_array_bits - null_free_array_bits;\n@@ -217,2 +217,2 @@\n-  static const int nullfree_array_shift           = inline_type_shift + inline_type_bits;\n-  static const int flat_array_shift               = nullfree_array_shift + nullfree_array_bits;\n+  static const int null_free_array_shift          = inline_type_shift + inline_type_bits;\n+  static const int flat_array_shift               = null_free_array_shift + null_free_array_bits;\n@@ -233,3 +233,3 @@\n-  static const uintptr_t nullfree_array_mask      = right_n_bits(nullfree_array_bits);\n-  static const uintptr_t nullfree_array_mask_in_place = (nullfree_array_mask << nullfree_array_shift) | lock_mask_in_place;\n-  static const uintptr_t nullfree_array_bit_in_place = (1 << nullfree_array_shift);\n+  static const uintptr_t null_free_array_mask     = right_n_bits(null_free_array_bits);\n+  static const uintptr_t null_free_array_mask_in_place = (null_free_array_mask << null_free_array_shift) | lock_mask_in_place;\n+  static const uintptr_t null_free_array_bit_in_place  = (1 << null_free_array_shift);\n@@ -237,1 +237,1 @@\n-  static const uintptr_t flat_array_mask_in_place = (flat_array_mask << flat_array_shift) | nullfree_array_mask_in_place | lock_mask_in_place;\n+  static const uintptr_t flat_array_mask_in_place = (flat_array_mask << flat_array_shift) | null_free_array_mask_in_place | lock_mask_in_place;\n@@ -263,3 +263,3 @@\n-  static const uintptr_t nullfree_array_pattern   = nullfree_array_bit_in_place | unlocked_value;\n-  static const uintptr_t flat_array_pattern       = flat_array_bit_in_place | nullfree_array_pattern;\n-  static const uintptr_t static_prototype_mask    = LP64_ONLY(right_n_bits(inline_type_bits + flat_array_bits + nullfree_array_bits)) NOT_LP64(right_n_bits(inline_type_bits));\n+  static const uintptr_t null_free_array_pattern  = null_free_array_bit_in_place | unlocked_value;\n+  static const uintptr_t flat_array_pattern       = flat_array_bit_in_place | null_free_array_pattern;\n+  static const uintptr_t static_prototype_mask    = LP64_ONLY(right_n_bits(inline_type_bits + flat_array_bits + null_free_array_bits)) NOT_LP64(right_n_bits(inline_type_bits));\n@@ -472,2 +472,2 @@\n-  bool is_nullfree_array() const {\n-    return (mask_bits(value(), nullfree_array_mask_in_place) == nullfree_array_pattern);\n+  bool is_null_free_array() const {\n+    return (mask_bits(value(), null_free_array_mask_in_place) == null_free_array_pattern);\n@@ -490,2 +490,2 @@\n-  static markWord nullfree_array_prototype() {\n-    return markWord(nullfree_array_pattern);\n+  static markWord null_free_array_prototype() {\n+    return markWord(null_free_array_pattern);\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-         prototype_header.is_nullfree_array(), \"corrupt prototype header\");\n+         prototype_header.is_null_free_array(), \"corrupt prototype header\");\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,3 @@\n-ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {\n+ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n,\n+                                       Klass* k, Symbol* name, bool null_free,\n+                                       TRAPS) {\n@@ -55,1 +57,1 @@\n-  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);\n+  return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name, null_free);\n@@ -59,1 +61,3 @@\n-                                                      int n, Klass* element_klass, TRAPS) {\n+                                                      int n, Klass* element_klass,\n+                                                      bool null_free, bool qdesc, TRAPS) {\n+  assert(!null_free || (n == 1 && element_klass->is_inline_klass() && qdesc), \"null-free unsupported\");\n@@ -67,1 +71,5 @@\n-      super_klass = element_super->array_klass_or_null();\n+      if (null_free) {\n+        super_klass = element_klass->array_klass_or_null();\n+      } else {\n+        super_klass = element_super->array_klass_or_null();\n+      }\n@@ -79,0 +87,5 @@\n+      if (null_free) {\n+        if (element_klass->array_klass_or_null() == NULL) {\n+          supers_exist = false;\n+        }\n+      }\n@@ -84,1 +97,5 @@\n-          super_klass = element_super->array_klass(CHECK_NULL);\n+          if (null_free) {\n+            element_klass->array_klass(CHECK_NULL);\n+          } else {\n+            element_super->array_klass(CHECK_NULL);\n+          }\n@@ -90,1 +107,5 @@\n-          ek = element_klass->array_klass(n, CHECK_NULL);\n+          if (null_free) {\n+            ek = InlineKlass::cast(element_klass)->null_free_inline_array_klass(CHECK_NULL);\n+          } else {\n+            ek = element_klass->array_klass(n, CHECK_NULL);\n+          }\n@@ -101,1 +122,1 @@\n-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n+  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, qdesc, CHECK_NULL);\n@@ -104,1 +125,1 @@\n-  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, null_free, CHECK_NULL);\n@@ -122,1 +143,1 @@\n-ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {\n+ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name, bool null_free) : ArrayKlass(name, ID) {\n@@ -126,0 +147,2 @@\n+  assert(!null_free || name->is_Q_array_signature(), \"sanity check\");\n+\n@@ -138,2 +161,3 @@\n-  jint lh = array_layout_helper(T_OBJECT);\n-  if (element_klass->is_inline_klass()) {\n+  int lh = array_layout_helper(T_OBJECT);\n+  if (null_free) {\n+    assert(n == 1, \"Bytecode does not support null-free multi-dim\");\n@@ -141,2 +165,2 @@\n-    set_prototype_header(markWord::nullfree_array_prototype());\n-    assert(prototype_header().is_nullfree_array(), \"sanity\");\n+    set_prototype_header(markWord::null_free_array_prototype());\n+    assert(prototype_header().is_null_free_array(), \"sanity\");\n@@ -179,1 +203,1 @@\n-    if (element_klass()->is_inline_klass()) {\n+    if (name()->char_at(1) != JVM_SIGNATURE_ARRAY &&  name()->is_Q_array_signature()) {\n@@ -341,1 +365,2 @@\n-        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n+        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n+                                                          false, this->name()->is_Q_array_signature(), CHECK_NULL);\n@@ -521,1 +546,1 @@\n-  guarantee(obj->is_nullfreeArray() || (!is_null_free_array_klass()), \"null-free klass but not object\");\n+  guarantee(obj->is_null_free_array() || (!is_null_free_array_klass()), \"null-free klass but not object\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -140,2 +140,1 @@\n-bool oopDesc::is_value_noinline()             const { return is_inline_type();         }\n-bool oopDesc::is_nullfreeArray_noinline()     const { return is_nullfreeArray();       }\n+bool oopDesc::is_null_free_array_noinline()   const { return is_null_free_array();     }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  inline bool is_nullfreeArray()       const;\n+  inline bool is_null_free_array()     const;\n@@ -125,2 +125,1 @@\n-  bool is_value_noinline()             const;\n-  bool is_nullfreeArray_noinline()     const;\n+  bool is_null_free_array_noinline()   const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-bool oopDesc::is_nullfreeArray() const {\n+bool oopDesc::is_null_free_array() const {\n@@ -217,1 +217,1 @@\n-  return (mrk.is_unlocked()) ? mrk.is_nullfree_array() : klass()->is_null_free_array_klass();\n+  return (mrk.is_unlocked()) ? mrk.is_null_free_array() : klass()->is_null_free_array_klass();\n@@ -220,2 +220,2 @@\n-bool oopDesc::is_flatArray()     const { return klass()->is_flatArray_klass(); }\n-bool oopDesc::is_nullfreeArray() const { return klass()->is_null_free_array_klass(); }\n+bool oopDesc::is_flatArray()       const { return klass()->is_flatArray_klass(); }\n+bool oopDesc::is_null_free_array() const { return klass()->is_null_free_array_klass(); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-              class_loader_data(), dim + 1, this, CHECK_NULL);\n+              class_loader_data(), dim + 1, this, false, false, CHECK_NULL);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1172,1 +1172,1 @@\n-static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit) {\n+static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit, bool null_free) {\n@@ -1177,1 +1177,1 @@\n-  if (t->as_klass()->is_inlinetype()) {\n+  if (t->as_klass()->is_inlinetype() && null_free) {\n@@ -1285,1 +1285,1 @@\n-          cast_argument(nargs, 0, signature->accessing_klass(), kit);\n+          cast_argument(nargs, 0, signature->accessing_klass(), kit, false);\n@@ -1291,1 +1291,2 @@\n-            cast_argument(nargs, receiver_skip + j, t, kit);\n+            bool null_free = signature->is_null_free_at(i);\n+            cast_argument(nargs, receiver_skip + j, t, kit, null_free);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4594,0 +4594,7 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Perform a full test.\n+  if (superk->is_obj_array_klass() && !superk->as_array_klass()->is_elem_null_free() &&\n+      superk->as_array_klass()->element_klass()->is_inlinetype()) {\n+    return SSC_full_test;\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -702,1 +702,1 @@\n-            if (ct == T_INLINE_TYPE) {\n+            if (declared_signature->returns_null_free_inline_type()) {\n@@ -731,1 +731,2 @@\n-    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType()) {\n+    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType() &&\n+        !gvn().type(peek())->maybe_null() && rtype->as_inline_klass()->is_scalarizable()) {\n@@ -733,4 +734,1 @@\n-      assert(!gvn().type(retnode)->maybe_null(), \"should never be null\");\n-      if (rtype->as_inline_klass()->is_scalarizable()) {\n-        retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass());\n-      }\n+      retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3442,1 +3442,1 @@\n-Node* GraphKit::gen_checkcast(Node *obj, Node* superklass, Node* *failure_control) {\n+Node* GraphKit::gen_checkcast(Node *obj, Node* superklass, Node* *failure_control, bool null_free) {\n@@ -3446,3 +3446,1 @@\n-\n-  \/\/ Check if inline types are involved\n-  bool to_inline = tk->klass()->is_inlinetype();\n+  assert(!null_free || toop->is_inlinetypeptr(), \"must be an inline type pointer\");\n@@ -3475,1 +3473,1 @@\n-          if (to_inline) {\n+          if (null_free) {\n@@ -3477,3 +3475,3 @@\n-            if (toop->inline_klass()->is_scalarizable()) {\n-              obj = InlineTypeNode::make_from_oop(this, obj, toop->inline_klass());\n-            }\n+          }\n+          if (toop->is_inlinetypeptr() && toop->inline_klass()->is_scalarizable() && !gvn().type(obj)->maybe_null()) {\n+            obj = InlineTypeNode::make_from_oop(this, obj, toop->inline_klass());\n@@ -3484,1 +3482,1 @@\n-        if (from_inline || to_inline) {\n+        if (from_inline || null_free) {\n@@ -3488,1 +3486,1 @@\n-          \/\/ Inline type is never null. Always throw an exception.\n+          \/\/ Inline type is null-free. Always throw an exception.\n@@ -3537,1 +3535,1 @@\n-  } else if (to_inline) {\n+  } else if (null_free) {\n@@ -3669,2 +3667,1 @@\n-    if (to_inline && toop->inline_klass()->is_scalarizable()) {\n-      assert(!gvn().type(res)->maybe_null(), \"Inline types are null-free\");\n+    if (toop->is_inlinetypeptr() && toop->inline_klass()->is_scalarizable() && !gvn().type(res)->maybe_null()) {\n@@ -3733,2 +3730,1 @@\n-  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n-  if (val_t == TypePtr::NULL_PTR && !ary_t->is_not_null_free()) {\n+  if (val_t == TypePtr::NULL_PTR) {\n@@ -3736,0 +3732,1 @@\n+    const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n@@ -3928,1 +3925,2 @@\n-    if (UseFlatArray && klass->is_obj_array_klass()) {\n+    if (UseFlatArray && klass->is_obj_array_klass() && !klass->as_obj_array_klass()->is_elem_null_free()) {\n+      \/\/ The runtime type of [LMyValue might be [QMyValue due to [QMyValue <: [LMyValue.\n@@ -3932,1 +3930,1 @@\n-    if (xklass || (klass->is_array_klass() && !can_be_flattened)) {\n+    if (!can_be_flattened && (xklass || klass->is_array_klass())) {\n@@ -4316,3 +4314,3 @@\n-  \/\/ - null-ok:              MyValue.ref[] (ciObjArrayKlass \"[LMyValue$ref\")\n-  \/\/ - null-free:            MyValue.val[] (ciObjArrayKlass \"[QMyValue$val\")\n-  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue$val\")\n+  \/\/ - null-ok:              MyValue.ref[] (ciObjArrayKlass \"[LMyValue\")\n+  \/\/ - null-free:            MyValue.val[] (ciObjArrayKlass \"[QMyValue\")\n+  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n@@ -4325,3 +4323,2 @@\n-    ciKlass* elem_klass = ary_ptr->klass()->as_array_klass()->element_klass();\n-    if (elem_klass != NULL && elem_klass->is_inlinetype()) {\n-      ciInlineKlass* vk = elem_klass->as_inline_klass();\n+    if (ary_ptr->klass()->as_array_klass()->is_elem_null_free()) {\n+      ciInlineKlass* vk = ary_ptr->klass()->as_array_klass()->element_klass()->as_inline_klass();\n@@ -4701,1 +4698,1 @@\n-    } else if (con_type->is_zero_type() && field->type()->is_inlinetype()) {\n+    } else if (con_type->is_zero_type() && field->is_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = NULL);\n+  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = NULL, bool null_free = false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2400,1 +2400,6 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          if (t->is_inlinetype()) {\n+            \/\/ TODO fix with JDK-8267932\n+            return LoadNode::Value(phase);\n+          } else {\n+            return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          }\n@@ -2452,1 +2457,3 @@\n-          if (!ik->is_interface() && !ik->has_subklass()) {\n+          \/\/ Do not fold klass loads from [LMyValue. The runtime type might be [QMyValue due to [QMyValue <: [LMyValue\n+          \/\/ and the klass for [QMyValue is not equal to the klass for [LMyValue.\n+          if (!ik->is_interface() && !ik->has_subklass() && (!ik->is_inlinetype() || ak->is_elem_null_free())) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    if (tp->klass()->is_inlinetype()) {\n+    if (tp->is_inlinetypeptr() && !tp->maybe_null()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-        ciArrayKlass* array_klass = ciArrayKlass::make(vk);\n+        ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n@@ -347,1 +347,1 @@\n-          ciArrayKlass* array_klass = ciArrayKlass::make(vk);\n+          ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -984,2 +984,2 @@\n-        } else if ((r0->is_not_null_free() && klass1->is_obj_array_klass() && klass1->as_obj_array_klass()->element_klass()->is_inlinetype()) ||\n-                   (r1->is_not_null_free() && klass0->is_obj_array_klass() && klass0->as_obj_array_klass()->element_klass()->is_inlinetype())) {\n+        } else if ((r0->is_not_null_free() && klass1->is_array_klass() && klass1->as_array_klass()->is_elem_null_free()) ||\n+                   (r1->is_not_null_free() && klass0->is_array_klass() && klass0->as_array_klass()->is_elem_null_free())) {\n@@ -1147,0 +1147,8 @@\n+  \/\/ Do not fold the subtype check to an array klass pointer comparison for [V? arrays.\n+  \/\/ [QMyValue is a subtype of [LMyValue but the klass for [QMyValue is not equal to\n+  \/\/ the klass for [LMyValue. Do not bypass the klass load from the primary supertype array.\n+  if (superklass->is_obj_array_klass() && !superklass->as_array_klass()->is_elem_null_free() &&\n+      superklass->as_array_klass()->element_klass()->is_inlinetype()) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                 superk->is_obj_array_klass() && superk->as_obj_array_klass()->element_klass()->is_inlinetype()) {\n+                 superk->is_array_klass() && superk->as_array_klass()->is_elem_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,2 +271,3 @@\n-    ciInlineKlass* vk = type->as_inline_klass();\n-    if (vk->is_scalarizable()) {\n+    bool is_null_free = type->is_null_free();\n+    ciInlineKlass* vk = type->unwrap()->as_inline_klass();\n+    if (vk->is_scalarizable() && is_null_free) {\n@@ -275,1 +276,1 @@\n-      return TypeOopPtr::make_from_klass(vk)->join_speculative(TypePtr::NOTNULL);\n+      return TypeOopPtr::make_from_klass(vk)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2089,1 +2090,1 @@\n-      field_array[TypeFunc::Parms] = get_const_type(return_type)->join_speculative(TypePtr::NOTNULL);\n+      field_array[TypeFunc::Parms] = get_const_type(return_type)->join_speculative(sig->returns_null_free_inline_type() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2149,1 +2150,2 @@\n-      if (vt_fields_as_args && type->as_inline_klass()->can_be_passed_as_fields()) {\n+      bool is_null_free = sig->is_null_free_at(i);\n+      if (vt_fields_as_args && type->as_inline_klass()->can_be_passed_as_fields() && is_null_free) {\n@@ -2152,1 +2154,1 @@\n-        field_array[pos++] = get_const_type(type)->join_speculative(TypePtr::NOTNULL);\n+        field_array[pos++] = get_const_type(type)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2450,2 +2452,10 @@\n-  if (tinst)\n-    return tklass->as_instance_klass()->is_final();\n+  if (tinst) {\n+    if (tklass->as_instance_klass()->is_final()) {\n+      \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+      if (tinst->is_inlinetypeptr() && (tinst->ptr() == TypePtr::BotPTR || tinst->ptr() == TypePtr::TopPTR)) {\n+        return false;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n@@ -3567,1 +3577,2 @@\n-    if (etype->is_inlinetypeptr()) {\n+    bool null_free = klass->as_array_klass()->is_elem_null_free();\n+    if (null_free) {\n@@ -3579,1 +3590,2 @@\n-    bool xk = etype->klass_is_exact();\n+    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+    bool xk = etype->klass_is_exact() && (!etype->is_inlinetypeptr() || null_free);\n@@ -3625,1 +3637,1 @@\n-    if (etype->is_inlinetypeptr()) {\n+    if (klass->as_array_klass()->is_elem_null_free()) {\n@@ -5513,1 +5525,2 @@\n-    k_ary = ciArrayKlass::make(el->is_oopptr()->klass());\n+    bool null_free = el->is_inlinetypeptr() && el->isa_instptr()->ptr() != TypePtr::TopPTR && !el->isa_instptr()->maybe_null();\n+    k_ary = ciArrayKlass::make(el->is_oopptr()->klass(), null_free);\n@@ -5517,1 +5530,1 @@\n-      k_ary = ciArrayKlass::make(el->inline_klass());\n+      k_ary = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n@@ -5876,1 +5889,2 @@\n-  bool has_scalar_ret = sig->return_type()->is_inlinetype() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n+  bool has_scalar_ret = sig->returns_null_free_inline_type() && sig->return_type()->is_inlinetype() &&\n+                        sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jni.h\"\n@@ -501,2 +502,12 @@\n-  jboolean ret = sub_klass->is_subtype_of(super_klass) ?\n-                   JNI_TRUE : JNI_FALSE;\n+  jboolean ret;\n+  if (sub_klass == super_klass && sub_klass->is_inline_klass()) {\n+    \/\/ val type is a subtype of ref type\n+    InlineKlass* ik = InlineKlass::cast(sub_klass);\n+    if (sub_mirror == super_mirror || (ik->val_mirror() == sub_mirror && ik->ref_mirror() == super_mirror)) {\n+      ret = JNI_TRUE;\n+    } else {\n+      ret = JNI_FALSE;\n+    }\n+  } else {\n+    ret = sub_klass->is_subtype_of(super_klass) ? JNI_TRUE : JNI_FALSE;\n+  }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1176,1 +1176,1 @@\n-    assert(klass->is_objArray_klass() || klass->is_typeArray_klass(), \"Illegal mirror klass\");\n+    assert(klass->is_objArray_klass() || klass->is_typeArray_klass() || klass->is_flatArray_klass(), \"Illegal mirror klass\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1338,1 +1338,1 @@\n-        if (field._type == T_INLINE_TYPE) {\n+        if (fs.signature()->is_Q_signature()) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-    if (k->is_inline_klass()) {\n+    if (k->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n@@ -397,1 +397,5 @@\n-  klass = klass->array_klass(dim, CHECK_NULL);\n+  if (klass->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+    klass = InlineKlass::cast(klass)->null_free_inline_array_klass(dim, CHECK_NULL);\n+  } else {\n+    klass = klass->array_klass(dim, CHECK_NULL);\n+  }\n@@ -1152,1 +1156,1 @@\n-    rtype = T_INLINE_TYPE;\n+    rtype = java_lang_Class::is_primary_mirror(return_type_mirror) ? T_OBJECT : T_INLINE_TYPE;\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -439,1 +439,2 @@\n-  return klass->java_mirror();\n+  return has_Q_descriptor() ? InlineKlass::cast(klass)->val_mirror()\n+                            : klass->java_mirror();\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-               + getName();\n+               + getName() + (isPrimitiveClass() && isPrimaryType() ? \".ref\" : \"\");\n@@ -556,0 +556,5 @@\n+    \/\/ set by VM if this class is an exotic type such as primitive class\n+    \/\/ otherwise, these two fields are null\n+    private transient Class<T> primaryType;\n+    private transient Class<T> secondaryType;\n+\n@@ -558,0 +563,8 @@\n+     * <p>\n+     * Each primitive class has a {@linkplain #isPrimaryType() primary type}\n+     * representing the <em>primitive reference type<\/em> and a\n+     * {@linkplain #isValueType() secondary type} representing\n+     * the <em>primitive value type<\/em>.  The primitive reference type\n+     * and primitive value type can be obtained by calling the\n+     * {@link #asPrimaryType()} and {@link #asValueType} method\n+     * of a primitive class respectively.\n@@ -567,28 +580,2 @@\n-     * Returns an {@code Optional<Class>} object representing the <em>primitive value type<\/em>\n-     * of this class if this {@code Class} represents the <em>reference type<\/em>\n-     * of a {@linkplain #isPrimitiveClass() primitive class}.\n-     * If this {@code Class} represents the value type of a primitive class,\n-     * then this method returns this class.\n-     * Otherwise an empty {@link Optional} is returned.\n-     *\n-     * @return the {@code Optional<Class>} representing the primitive value type of\n-     *         this class if this class is either the value type\n-     *         or the reference type of a primitive class;\n-     *         an empty {@link Optional} otherwise\n-     * @since Valhalla\n-     *\/\n-    public Optional<Class<?>> valueType() {\n-        if (isPrimitive() || isInterface() || isArray())\n-            return Optional.empty();\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length > 0 ? Optional.of(valRefTypes[0]) : Optional.empty();\n-    }\n-\n-    \/**\n-     * Returns a {@code Class} object representing the reference type\n-     * of this class.\n-     * <p>\n-     * If this {@code Class} represents a {@linkplain #isPrimitiveClass()\n-     * primitive reference type}, then this method\n-     * returns the <em>primitive reference type<\/em> type of this primitive class.\n+     * Returns a {@code Class} object representing the primary type\n+     * of this class or interface.\n@@ -596,2 +583,2 @@\n-     * If this {@code Class} represents the reference type\n-     * of a primitive class, then this method returns this class.\n+     * If this {@code Class} object represents a reference type, then\n+     * this method returns this class.\n@@ -599,1 +586,3 @@\n-     * If this class is an identity class, then this method returns this class.\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive class}, then this method returns the <em>primitive reference type<\/em>\n+     * type of this primitive class.\n@@ -601,1 +590,1 @@\n-     * Otherwise this method returns an empty {@code Optional}.\n+     * If this is a primitive type, then this method returns this class.\n@@ -603,2 +592,2 @@\n-     * @return the {@code Optional<Class>} object representing the reference type for\n-     *         this class, if present; an empty {@link Optional} otherwise.\n+     * @return the {@code Class} representing the primary type of\n+     *         this class or interface\n@@ -607,7 +596,2 @@\n-    public Optional<Class<?>> referenceType() {\n-        if (isPrimitive()) return Optional.empty();\n-        if (isInterface() || isArray()) return Optional.of(this);\n-        if (!isPrimitiveClass()) return Optional.of(this);\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length == 2 ? Optional.of(valRefTypes[1]) : Optional.empty();\n+    public Class<?> asPrimaryType() {\n+        return isPrimitiveClass() ? primaryType : this;\n@@ -616,3 +600,3 @@\n-    \/*\n-     * Returns true if this Class object represents a primitive reference\n-     * type for a primitive class.\n+    \/**\n+     * Returns a {@code Class} object representing the <em>primitive value type<\/em>\n+     * of this class if this class is a {@linkplain #isPrimitiveClass() primitive class}.\n@@ -620,3 +604,5 @@\n-     * A primitive reference type must be a sealed abstract class that\n-     * permits the primitive value type to extend.  The primitive value type\n-     * and primitive reference type for a primitive type must be of the same package.\n+     * @return the {@code Class} representing the primitive value type of\n+     *         this class if this class is a primitive class\n+     * @throws UnsupportedOperationException if this class or interface\n+     *         is not a primitive class\n+     * @since Valhalla\n@@ -624,17 +610,3 @@\n-    private boolean isPrimitiveReferenceType() {\n-        if (isPrimitive() || isArray() || isInterface() || isPrimitiveClass())\n-            return false;\n-\n-        int mods = getModifiers();\n-        if (!Modifier.isAbstract(mods)) {\n-            return false;\n-        }\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length == 2 && valRefTypes[1] == this;\n-    }\n-\n-    private transient Class<?>[] primitiveTypes;\n-    private Class<?>[] getPrimitiveTypes() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n+    public Class<?> asValueType() {\n+        if (isPrimitiveClass())\n+            return secondaryType;\n@@ -642,15 +614,1 @@\n-        Class<?>[] valRefTypes = primitiveTypes;\n-        if (valRefTypes == null) {\n-            \/\/ So newPrimitiveTypeArray is called without holding any lock to\n-            \/\/ avoid potential deadlock when multiple threads attempt to\n-            \/\/ initialize the primitive types for C and E where D is\n-            \/\/ the superclass of both C and E (which is an error case)\n-            valRefTypes = newTypeArrayForPrimitiveClass();\n-        }\n-        synchronized (this) {\n-            \/\/ set the value and reference types if not set\n-            if (primitiveTypes == null) {\n-                primitiveTypes = valRefTypes;\n-            }\n-        }\n-        return primitiveTypes;\n+        throw new UnsupportedOperationException(this.getName() + \" is not a primitive class\");\n@@ -659,4 +617,12 @@\n-    \/*\n-     * Returns an array of Class objects whose element at index 0 represents the\n-     * primitive value type and element at index 1 represents the\n-     * primitive reference type, if present.\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents the primary type\n+     * of this class or interface.\n+     * <p>\n+     * If this is a primitive type, then this method returns {@code true}.\n+     * <p>\n+     * If this {@code Class} object represents a reference type, then\n+     * this method returns {@code true}.\n+     * <p>\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive} reference type, then this method returns {@code true};\n+     * otherwise, this method returns {@code false}.\n@@ -664,3 +630,3 @@\n-     * If this Class object is neither a primitive value type nor\n-     * a primitive reference type for a primitive class, then an empty array\n-     * is returned.\n+     * @return {@code true} if this {@code Class} object represents\n+     * the primary type of this class or interface\n+     * @since Valhalla\n@@ -668,4 +634,1 @@\n-    private Class<?>[] newTypeArrayForPrimitiveClass() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n-\n+    public boolean isPrimaryType() {\n@@ -673,13 +636,1 @@\n-            Class<?> superClass = getSuperclass();\n-            if (superClass != Object.class && superClass.isPrimitiveReferenceType()) {\n-                return new Class<?>[] { this, superClass };\n-            } else {\n-                return new Class<?>[] { this };\n-            }\n-        } else {\n-            Class<?> valType = primitiveValueType();\n-            if (valType != null) {\n-                return new Class<?>[] { valType, this};\n-            } else {\n-                return EMPTY_CLASS_ARRAY;\n-            }\n+            return this == primaryType;\n@@ -687,0 +638,1 @@\n+        return true;\n@@ -689,4 +641,7 @@\n-    \/*\n-     * Returns the primitive value type if this Class represents\n-     * a primitive reference type.  If this class is a primitive class\n-     * then this method returns this class.  Otherwise, returns null.\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents\n+     * a {@linkplain #isPrimitiveClass() primitive} value type.\n+     *\n+     * @return {@code true} if this {@code Class} object represents the\n+     * value type of a primitive class\n+     * @since Valhalla\n@@ -694,23 +649,2 @@\n-    private Class<?> primitiveValueType() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n-\n-        if (isPrimitiveClass())\n-            return this;\n-\n-        int mods = getModifiers();\n-        if (!Modifier.isAbstract(mods)) {\n-            return null;\n-        }\n-\n-        \/\/ A primitive reference type must be a sealed abstract class\n-        \/\/ that permits the primitive class type to extend.\n-        \/\/ The primitive class project type and primitive reference type for\n-        \/\/ a primitive class type must be of the same package.\n-        Class<?>[] subclasses = getPermittedSubclasses0();\n-        if ((subclasses.length == 1) &&\n-                (subclasses[0].isPrimitiveClass()) &&\n-                (getPackageName().equals(subclasses[0].getPackageName()))) {\n-            return subclasses[0];\n-        }\n-        return null;\n+    public boolean isValueType() {\n+        return isPrimitiveClass() && this == secondaryType;\n@@ -863,0 +797,4 @@\n+     * object represents the {@linkplain #isPrimaryType() reference type}\n+     * of a {@linkplain #isPrimitiveClass() primitive class}, this method\n+     * return {@code true} if the specified {@code Class} parameter represents\n+     * the same primitive class. If this {@code Class}\n@@ -871,3 +809,3 @@\n-     * or via a widening reference conversion. See <cite>The Java Language\n-     * Specification<\/cite>, sections {@jls 5.1.1} and {@jls 5.1.4},\n-     * for details.\n+     * or via a widening reference conversion or via a primitive widening\n+     * conversion. See <cite>The Java Language Specification<\/cite>,\n+     * sections {@jls 5.1.1} and {@jls 5.1.4}, for details.\n@@ -1028,1 +966,1 @@\n-     *     returns \"[[LPoint$ref;\"\n+     *     returns \"[[LPoint;\"\n@@ -1862,1 +1800,6 @@\n-        return getName();\n+        if (isPrimitiveClass()) {\n+            \/\/ TODO: null-default\n+            return isPrimaryType() ? getName() + \".ref\" : getName();\n+        } else {\n+            return getName();\n+        }\n@@ -4056,2 +3999,2 @@\n-     * @throws NullPointerException if this is an {@linkplain #isPrimitiveClass()\n-     * primitive class} and the object is {@code null}\n+     * @throws NullPointerException if this is an {@linkplain #isValueType()\n+     * primitive value type} and the object is {@code null}\n@@ -4064,2 +4007,2 @@\n-        if (isPrimitiveClass() && obj == null)\n-            throw new NullPointerException(getName() + \" is a primitive class\");\n+        if (isValueType() && obj == null)\n+            throw new NullPointerException(getName() + \" is a primitive value type\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":83,"deletions":140,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -388,6 +388,2 @@\n-     * If {@code fromType} is a primitive class, this method returns {@code true}\n-     * if {@code toType} is the {@linkplain Class#referenceType() primitive reference type}\n-     * of {@code fromType}.\n-     * If {@code toType} is a primitive class, this method returns {@code true}\n-     * if {@code toType} is the {@linkplain Class#valueType() primitive value type}\n-     * of {@code fromType}.\n+     * If {@code fromType} and {@code toType} is of the same primitive class,\n+     * this method returns {@code true}.\n@@ -406,2 +402,3 @@\n-        if (!fromType.isPrimitiveClass() && !toType.isPrimitiveClass()) {\n-            return false;\n+        if (fromType.isPrimitiveClass() && toType.isPrimitiveClass()) {\n+            \/\/ val projection can be converted to ref projection; or vice verse\n+            return fromType.asPrimaryType() == toType.asPrimaryType();\n@@ -410,1 +407,1 @@\n-        return fromType.valueType().equals(toType.valueType());\n+        return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-            mtype = mtype.insertParameterTypes(0, refc);\n+            Class<?> receiverType = refc.isPrimitiveClass() ? refc.asValueType() : refc;\n+            mtype = mtype.insertParameterTypes(0, receiverType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,1 +119,2 @@\n-                       methodType.returnType() != defc) {\n+                       methodType.returnType() != defc.asValueType()) {\n+                \/\/ TODO: allow to return Object or perhaps one of the supertypes of that class\n@@ -121,1 +122,1 @@\n-                throw new IllegalArgumentException(\"static constructor must be of \" + getDeclaringClass().getName());\n+                throw new IllegalArgumentException(\"static constructor must be of \" + defc.getName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+        Class<?> c = clazz.isPrimitiveClass() ? clazz.asValueType() : clazz;\n@@ -195,1 +196,1 @@\n-            return itype.changeReturnType(clazz);\n+            return itype.changeReturnType(c);\n@@ -197,1 +198,1 @@\n-            return itype.insertParameterTypes(0, clazz);\n+            return itype.insertParameterTypes(0, c);\n@@ -482,1 +483,1 @@\n-            return type.isPrimitiveClass();\n+            return type.isValueType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1506,4 +1506,0 @@\n-            @Override\n-            public String inlineObjectToString(Object o) {\n-                return ValueBootstrapMethods.inlineObjectToString(o);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1619,0 +1619,1 @@\n+            assert lookupClass.isPrimaryType();\n@@ -3443,0 +3444,1 @@\n+            Class<?> defc = c.getDeclaringClass();\n@@ -3445,1 +3447,1 @@\n-                return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n+                return lookup.getDirectConstructorNoSecurityManager(defc, ctor);\n@@ -3448,1 +3450,1 @@\n-                assert(ctor.isMethod() && ctor.getReturnType() == ctor.getDeclaringClass() && ctor.getReferenceKind() == REF_invokeStatic);\n+                assert(ctor.isMethod() && ctor.getReturnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n@@ -3450,1 +3452,1 @@\n-                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);\n+                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), defc, ctor, lookup);\n@@ -3824,1 +3826,1 @@\n-            if (!fullPrivilegeLookup && defc != refc) {\n+            if (!fullPrivilegeLookup && defc.asPrimaryType() != refc.asPrimaryType()) {\n@@ -3907,1 +3909,1 @@\n-                               (defc == refc ||\n+                               (defc.asPrimaryType() == refc.asPrimaryType() ||\n@@ -3912,1 +3914,1 @@\n-                           (defc == refc ||\n+                           (defc.asPrimaryType() == refc.asPrimaryType() ||\n@@ -3989,1 +3991,0 @@\n-\n@@ -4312,1 +4313,3 @@\n-     * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be\n+     * is {@code null} or if the array's element type is a {@link Class#isValueType()\n+     * a primitive value type} and attempts to set {@code null} in the\n+     * array element.  An {@code ArrayIndexOutOfBoundsException} will be\n@@ -4323,3 +4326,0 @@\n-        if (arrayClass.isPrimitiveClass()) {\n-            throw new UnsupportedOperationException();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -892,1 +893,1 @@\n-                \")\" + rtype.getSimpleName());\n+                \")\" + toSimpleName(rtype));\n@@ -894,1 +895,1 @@\n-            sj.add(ptypes[i].getSimpleName());\n+            sj.add(toSimpleName(ptypes[i]));\n@@ -899,0 +900,7 @@\n+    static String toSimpleName(Class<?> c) {\n+        if (c.isPrimitiveClass() && c.isPrimaryType()) {\n+            return c.getSimpleName() + \".ref\";\n+        } else {\n+            return c.getSimpleName();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1656,0 +1656,6 @@\n+            \/\/ the field type (value) is mapped to the return type of MethodType\n+            \/\/ the receiver type is mapped to a parameter type of MethodType\n+            \/\/ So use the value type if it's a primitive class\n+            if (receiver != null && receiver.isPrimitiveClass()) {\n+                receiver = receiver.asValueType();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-            return maybeAdapt(componentType.isPrimitiveClass() && UNSAFE.isFlattenedArray(arrayClass)\n+            return maybeAdapt(componentType.isValueType() && UNSAFE.isFlattenedArray(arrayClass)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -781,0 +781,8 @@\n+\n+    String getDeclaringClassTypeName() {\n+        Class<?> c = getDeclaringClass();\n+        if (c.isPrimitiveClass()) {\n+            c = c.asValueType();\n+        }\n+        return c.getTypeName();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -331,1 +332,1 @@\n-            + getDeclaringClass().getTypeName() + \".\"\n+            + getDeclaringClassTypeName() + \".\"\n@@ -337,1 +338,9 @@\n-        return \"field \" + getDeclaringClass().getTypeName() + \".\" + getName();\n+        return \"field \" + getDeclaringClassTypeName() + \".\" + getName();\n+    }\n+\n+    String getDeclaringClassTypeName() {\n+        Class<?> c = getDeclaringClass();\n+        if (c.isPrimitiveClass()) {\n+            c = c.asValueType();\n+        }\n+        return c.getTypeName();\n@@ -365,1 +374,1 @@\n-            + getDeclaringClass().getTypeName() + \".\"\n+            + getDeclaringClassTypeName() + \".\"\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -878,1 +878,1 @@\n-            if (type != c) {\n+            if (type.asPrimaryType() != c.asPrimaryType()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -869,1 +869,1 @@\n-                if (type.isPrimitiveClass()) {\n+                if (type.isValueType()) {\n@@ -924,1 +924,1 @@\n-         * to invoke Class.asPrimaryType if the class is regular value type.\n+         * to invoke Class::asValueType if the class is a primitive value type.\n@@ -934,0 +934,5 @@\n+            if (cl.isValueType()) {\n+              mv.visitMethodInsn(INVOKEVIRTUAL,\n+                                 JL_CLASS,\n+                                 \"asValueType\", \"()Ljava\/lang\/Class;\", false);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,2 +125,0 @@\n-    String inlineObjectToString(Object o);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-        if (ref == null && pc.isPrimitiveClass()) {\n+        if (ref == null && pc.isValueType()) {\n@@ -278,1 +278,1 @@\n-        if (ref == null && pc.isPrimitiveClass()) {\n+        if (ref == null && pc.isValueType()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        if (defc == lookupClass  &&\n+        if (defc.asPrimaryType() == lookupClass  &&\n@@ -143,1 +143,1 @@\n-            assert (canAccess && refc == defc) || !canAccess;\n+            assert (canAccess && refc.asPrimaryType() == defc.asPrimaryType()) || !canAccess;\n@@ -151,1 +151,1 @@\n-        return (refc == lookupClass ||\n+        return (refc.asPrimaryType() == lookupClass.asPrimaryType() ||\n@@ -276,1 +276,1 @@\n-        if (type == refc) {\n+        if (type.asPrimaryType() == refc.asPrimaryType()) {\n@@ -337,1 +337,1 @@\n-        return (type == res);\n+        return (type.asPrimaryType() == res);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -423,15 +423,0 @@\n-    \/**\n-     * Is this a *derived* reference projection symbol ??\n-     *\/\n-    public boolean isReferenceProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * If this is the symbol for a reference projection class, what is the class for which\n-     * this is a projection ??\n-     *\/\n-    public ClassSymbol valueProjection() {\n-        return null;\n-    }\n-\n@@ -548,2 +533,0 @@\n-     * 'outermost' being a lexical construct, should transcend\n-     *  projections\n@@ -558,1 +541,1 @@\n-        return (ClassSymbol) (prev!= null && prev.isReferenceProjection() ? prev.valueProjection() : prev);\n+        return (ClassSymbol) prev;\n@@ -1434,8 +1417,0 @@\n-        \/**\n-         * Does `this' symbolize a primitive class that would, under the translation\n-         * scheme in effect be lowered into two class files on a bifurcased basis ??\n-         *\/\n-        public boolean isSplitPrimitiveClass(Types types) {\n-            return types.splitPrimitiveClass && this.isPrimitiveClass();\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -105,12 +105,0 @@\n-    \/**\n-     * If true, the ClassWriter will split a primitive class declaration into two class files\n-     * P.ref.class and P.val.class (P.class for pure primitive classes)\n-     *\n-     * This is the default behavior, can be eoverridden with -XDunifiedValRefClass\n-     *\n-     * If false, we emit a single class for a primtive class 'P' and the reference projection and\n-     * value projection types are encoded in descriptors as LP; and QP; resperctively.\n-     *\/\n-\n-    public boolean splitPrimitiveClass;\n-\n@@ -142,1 +130,0 @@\n-        splitPrimitiveClass = options.isUnset(\"unifiedValRefClass\");\n@@ -1883,1 +1870,1 @@\n-                            return (dynamicTypeMayImplementAdditionalInterfaces(t.tsym))\n+                            return ((t.tsym.flags() & FINAL) == 0)\n@@ -4735,1 +4722,1 @@\n-        Assert.check(!dynamicTypeMayImplementAdditionalInterfaces(from.tsym));\n+        Assert.check((from.tsym.flags() & FINAL) != 0);\n@@ -4747,4 +4734,0 @@\n-    private boolean dynamicTypeMayImplementAdditionalInterfaces(TypeSymbol tsym) {\n-        return (tsym.flags() & FINAL) == 0 && !tsym.isReferenceProjection();\n-    }\n-\n@@ -5429,4 +5412,0 @@\n-            if (types.splitPrimitiveClass && ct.isReferenceProjection()) {\n-                append('$');\n-                append(types.names.ref);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1143,3 +1143,0 @@\n-                if (types.splitPrimitiveClass && requireReferenceProjection) {\n-                    flatname = flatname.append('$', names.ref);\n-                }\n@@ -3109,6 +3106,0 @@\n-        if (haveValue) {\n-            \/\/ widening coversion is a NOP for the VM due to subtyping relationship at class file level\n-            \/\/ where we bifurcate a primitive class into two class files.\n-            if (types.splitPrimitiveClass)\n-                return tree;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -74,2 +74,0 @@\n-import static com.sun.tools.javac.code.Type.ClassType.Flavor.L_TypeOf_Q;\n-import static com.sun.tools.javac.code.Type.ClassType.Flavor.Q_TypeOf_Q;\n@@ -560,12 +558,6 @@\n-                name = names.fromUtf(signatureBuffer,\n-                        startSbp,\n-                        sbp - startSbp);\n-                if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                    name = name.subName(0, name.length() - 4);\n-                    Assert.check(prefix == 'L');\n-                    flavor = L_TypeOf_Q;\n-                } else {\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                }\n-                ClassSymbol t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                                                         startSbp,\n+                                                         sbp - startSbp));\n+\n+                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -575,6 +567,2 @@\n-                        if (flavor == L_TypeOf_Q) {\n-                            return et.referenceProjection();\n-                        } else {\n-                            \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n-                            return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n-                        }\n+                        \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n@@ -589,12 +577,5 @@\n-                name = names.fromUtf(signatureBuffer,\n-                        startSbp,\n-                        sbp - startSbp);\n-                if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                    name = name.subName(0, name.length() - 4);\n-                    Assert.check(prefix == 'L');\n-                    flavor = L_TypeOf_Q;\n-                } else {\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                }\n-                ClassSymbol t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n+                                                         startSbp,\n+                                                         sbp - startSbp));\n+                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -661,12 +642,5 @@\n-                    name = names.fromUtf(signatureBuffer,\n-                            startSbp,\n-                            sbp - startSbp);\n-                    if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-                        name = name.subName(0, name.length() - 4);\n-                        Assert.check(prefix == 'L');\n-                        flavor = L_TypeOf_Q;\n-                    } else {\n-                        \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                        flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                    }\n-                    t = flavor == L_TypeOf_Q ? enterPrimitiveClass(name) : enterClass(name);\n+                    t = enterClass(names.fromUtf(signatureBuffer,\n+                                                 startSbp,\n+                                                 sbp - startSbp));\n+                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n+                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -2536,19 +2510,0 @@\n-    \/**\n-     * Special routine to enter a class that we conclude must be a primitive class from naming convention\n-     * E.g, if we see LFoo$ref in descriptors, we discern that to be the reference projection of the primitive\n-     * class Foo\n-     *\/\n-    protected ClassSymbol enterPrimitiveClass(Name name) {\n-        ClassSymbol c = enterClass(name);\n-        noticePrimitiveClass(c);\n-        return c;\n-    }\n-\n-    private void noticePrimitiveClass(ClassSymbol c) {\n-        ClassType ct = (ClassType) c.type;\n-        ct.flavor = ct.flavor.metamorphose(true);\n-        if (c.erasure_field != null) {\n-            ((ClassType) c.erasure_field).flavor = ct.flavor;\n-        }\n-    }\n-\n@@ -2677,3 +2632,0 @@\n-                if ((flags & PRIMITIVE_CLASS) != 0) {\n-                    noticePrimitiveClass(member); \/\/ Do we care to do this ?\n-                }\n@@ -2734,26 +2686,0 @@\n-        readClassFileInternal(c);\n-        if (c.isPrimitiveClass()) {\n-            \/* http:\/\/cr.openjdk.java.net\/~briangoetz\/valhalla\/sov\/04-translation.html\n-               The relationship of value and reference projections differs between the language model\n-               and the VM model. In the language, the value projection is not a subtype of the\n-               reference projection; instead, the two are related by inline narrowing and widening\n-               conversions, whereas in the VM, the two are related by actual subtyping.\n-               Sever the subtyping relationship by rewiring the supertypes here and now.\n-             *\/\n-\n-            Name flatname = TypeSymbol.formFlatName(names.ref, c);\n-            ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);\n-            if (referenceProjection != null) {\n-                if (referenceProjection.name != names.ref && referenceProjection.owner.kind == PCK) {\n-                    referenceProjection.complete();\n-                    ClassType classType = (ClassType) c.type;\n-                    classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;\n-                    classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;\n-                    \/\/ Discard the projection, it will be recomputed on the fly.\n-                    referenceProjection.owner.members().remove(referenceProjection);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void readClassFileInternal(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":18,"deletions":92,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -826,2 +826,1 @@\n-    \/** Write \"inner classes\" attribute. If a primitive class happens to be an inner class,\n-     *  the reference projection class will also be an inner class.\n+    \/** Write \"inner classes\" attribute.\n@@ -831,2 +830,1 @@\n-        int icCountIdx = beginAttrs();\n-        int icCount = 0;\n+        databuf.appendChar(poolWriter.innerClasses.size());\n@@ -849,12 +847,0 @@\n-            icCount++;\n-            if (inner.isSplitPrimitiveClass(types)) {\n-                databuf.appendChar(poolWriter.putClass(inner.type.referenceProjection()));\n-                databuf.appendChar(\n-                        inner.owner.kind == TYP && !inner.name.isEmpty() ? poolWriter.putClass((ClassSymbol)inner.owner) : 0);\n-                databuf.appendChar(\n-                        !inner.name.isEmpty() ? poolWriter.putName(inner.name.append('$', names.ref)) : 0);\n-                flags = (char) ((flags & ~(ACC_PRIMITIVE | FINAL)) | ABSTRACT);\n-                databuf.appendChar(flags);\n-                icCount++;\n-            }\n-        endAttrs(icCountIdx, icCount);\n@@ -886,26 +872,8 @@\n-        Set<ClassSymbol> nestedUnique = new LinkedHashSet<>();\n-        if (csym.owner.kind == PCK) {\n-            if (csym.isSplitPrimitiveClass(types)) {\n-                \/\/ reference projection is the host\n-            } else if (csym.isReferenceProjection()) {\n-                ClassSymbol valueProjection = csym.valueProjection();\n-                nestedUnique.add(valueProjection);\n-                listNested(valueProjection, nestedUnique);\n-            } else {\n-                listNested(csym, nestedUnique);\n-            }\n-            if (!nestedUnique.isEmpty()) {\n-                int alenIdx = writeAttr(names.NestMembers);\n-                int nmcIdx = beginAttrs();\n-                int nmc = 0;\n-                for (ClassSymbol s : nestedUnique) {\n-                    databuf.appendChar(poolWriter.putClass(s));\n-                    nmc++;\n-                    if (s.isSplitPrimitiveClass(types) && s.owner.kind != PCK) {\n-                        databuf.appendChar(poolWriter.putClass(s.type.referenceProjection()));\n-                        nmc++;\n-                    }\n-                }\n-                endAttrs(nmcIdx, nmc);\n-                endAttr(alenIdx);\n-                return 1;\n+        ListBuffer<ClassSymbol> nested = new ListBuffer<>();\n+        listNested(csym, nested);\n+        Set<ClassSymbol> nestedUnique = new LinkedHashSet<>(nested);\n+        if (csym.owner.kind == PCK && !nestedUnique.isEmpty()) {\n+            int alenIdx = writeAttr(names.NestMembers);\n+            databuf.appendChar(nestedUnique.size());\n+            for (ClassSymbol s : nestedUnique) {\n+                databuf.appendChar(poolWriter.putClass(s));\n@@ -913,0 +881,2 @@\n+            endAttr(alenIdx);\n+            return 1;\n@@ -921,1 +891,1 @@\n-        if (csym.owner.kind != PCK || csym.isSplitPrimitiveClass(types)) {\n+        if (csym.owner.kind != PCK) {\n@@ -923,6 +893,1 @@\n-            ClassSymbol outerMost = csym.outermostClass();\n-            if (outerMost.isSplitPrimitiveClass(types)) {\n-                databuf.appendChar(poolWriter.putClass(outerMost.type.referenceProjection()));\n-            } else {\n-                databuf.appendChar(poolWriter.putClass(outerMost));\n-            }\n+            databuf.appendChar(poolWriter.putClass(csym.outermostClass()));\n@@ -935,1 +900,1 @@\n-    private void listNested(Symbol sym, Set<ClassSymbol> seen) {\n+    private void listNested(Symbol sym, ListBuffer<ClassSymbol> seen) {\n@@ -1535,3 +1500,0 @@\n-        if (c.isSplitPrimitiveClass(types)) {\n-            writeClassInternal(getReferenceProjection(c));\n-        }\n@@ -1541,55 +1503,0 @@\n-        \/\/ where\n-        private static ClassSymbol getReferenceProjection(ClassSymbol c) {\n-\n-            ClassSymbol projection;\n-            ClassType projectedType;\n-\n-            ClassType ct = (ClassType) c.type;\n-            \/* Note, the class type associated with the Primitive$ref.class is NOT a reference projection type. A reference projection\n-             * type gets created by using Primitive.ref notation in the source file or while reading in a descriptor of such a type\n-             * from the class file. Here we are generating the Primitive$ref.class for the VM's benefit and it is a reference class.\n-             *\/\n-            projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null, ct.getMetadata(), Flavor.L_TypeOf_L);\n-            projectedType.allparams_field = ct.allparams_field;\n-            projectedType.supertype_field = ct.supertype_field;\n-\n-            projectedType.interfaces_field = ct.interfaces_field;\n-            projectedType.all_interfaces_field = ct.all_interfaces_field;\n-            projectedType.projection = null;\n-\n-            Name projectionName = c.name.append('$', c.name.table.names.ref);\n-            long projectionFlags = (c.flags() & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | (ABSTRACT | SEALED);\n-\n-            projection = new ClassSymbol(projectionFlags, projectionName, projectedType, c.owner) {\n-                @Override\n-                public boolean isReferenceProjection() {\n-                    return true;\n-                }\n-\n-                @Override\n-                public ClassSymbol valueProjection() {\n-                    return c;\n-                }\n-            };\n-            projection.members_field = WriteableScope.create(projection);\n-            for (Symbol s : c.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    clone = refVar;\n-                }\n-                projection.members_field.enter(clone);\n-            }\n-            projection.completer = Completer.NULL_COMPLETER;\n-            projection.sourcefile = c.sourcefile;\n-            projection.flatname = c.flatname.append('$', c.name.table.names.ref);\n-            projection.permitted = List.of(c);\n-            projectedType.tsym = projection;\n-            return projection;\n-        }\n-\n@@ -1640,2 +1547,2 @@\n-        Type supertype = c.isSplitPrimitiveClass(types) ? c.type.referenceProjection() : types.supertype(c.type);\n-        List<Type> interfaces = c.isSplitPrimitiveClass(types) ? List.nil() : types.interfaces(c.type);\n+        Type supertype = types.supertype(c.type);\n+        List<Type> interfaces = types.interfaces(c.type);\n@@ -1674,16 +1581,14 @@\n-        boolean referenceProjection = c.isReferenceProjection();\n-        if (!referenceProjection) {\n-            for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {\n-                switch (sym.kind) {\n-                    case VAR:\n-                        fieldsCount++;\n-                        break;\n-                    case MTH:\n-                        if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n-                        break;\n-                    case TYP:\n-                        poolWriter.enterInner((ClassSymbol)sym);\n-                        break;\n-                    default:\n-                        Assert.error();\n-                }\n+\n+        for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {\n+            switch (sym.kind) {\n+                case VAR:\n+                    fieldsCount++;\n+                    break;\n+                case MTH:\n+                    if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n+                    break;\n+                case TYP:\n+                    poolWriter.enterInner((ClassSymbol)sym);\n+                    break;\n+                default:\n+                    Assert.error();\n@@ -1691,0 +1596,1 @@\n+        }\n@@ -1692,4 +1598,3 @@\n-            if (c.trans_local != null) {\n-                for (ClassSymbol local : c.trans_local) {\n-                    poolWriter.enterInner(local);\n-                }\n+        if (c.trans_local != null) {\n+            for (ClassSymbol local : c.trans_local) {\n+                poolWriter.enterInner(local);\n@@ -1700,2 +1605,1 @@\n-        if (!referenceProjection)\n-            writeFields(c.members());\n+        writeFields(c.members());\n@@ -1703,2 +1607,1 @@\n-        if (!referenceProjection)\n-            writeMethods(c.members());\n+        writeMethods(c.members());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":37,"deletions":134,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -2282,1 +2282,1 @@\n-        \/\/ inline widening conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n+        \/\/ inline widening conversion should not require a checkcast but we issue one per VM's request as of now (see || true below)\n@@ -2285,1 +2285,1 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.splitPrimitiveClass || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type)) &&\n+            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n@@ -2355,1 +2355,1 @@\n-            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, !types.splitPrimitiveClass && tree.selected.type.isPrimitiveClass()));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-                    return (aClass.isPrimitiveClass() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n+                    return (aClass.isValueType() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n@@ -273,1 +273,1 @@\n-                return aClass != null && aClass.isPrimitiveClass();\n+                return aClass != null && aClass.isValueType();\n@@ -282,1 +282,2 @@\n-                        return Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        Class<?> c = Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        return basicTypeHelper.isInlineClass(desc) ? c.asValueType() : c.asPrimaryType();\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}