{"files":[{"patch":"@@ -379,4 +379,1 @@\n-  \/\/ The frame_map records size in slots (32bit word)\n-\n-  \/\/ subtract two words to account for return address and link\n-  return (frame_map()->framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;\n+  return in_bytes(frame_map()->framesize_in_bytes());\n@@ -464,1 +461,2 @@\n-  __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);\n+  int sp_inc_offset = initial_framesize - 3*wordSize;  \/\/ Below saved FP and LR\n+  __ remove_frame(initial_framesize, needs_stack_repair(), sp_inc_offset);\n@@ -529,1 +527,2 @@\n-  __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);\n+  int sp_inc_offset = initial_framesize - 3*wordSize;  \/\/ Below saved FP and LR\n+  __ remove_frame(initial_framesize, needs_stack_repair(), sp_inc_offset);\n@@ -1977,2 +1976,0 @@\n-    case lir_mul_strictfp: \/\/ fall through\n-    case lir_div_strictfp: \/\/ fall through\n@@ -1990,2 +1987,0 @@\n-      case lir_mul_strictfp: \/\/ fall through\n-      case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -684,0 +684,5 @@\n+  \/\/ lr could be poisoned with PAC signature during throw_pending_exception\n+  \/\/ if it was tail-call optimized by compiler, since lr is not callee-saved\n+  \/\/ reload it with proper value\n+  adr(lr, l);\n+\n@@ -4784,1 +4789,2 @@\n-  assert(framesize > 0, \"framesize must be > 0\");\n+  assert(framesize >= 2 * wordSize, \"framesize must include space for FP\/LR\");\n+  assert(framesize % (2*wordSize) == 0, \"must preserve 2*wordSize alignment\");\n@@ -4803,1 +4809,2 @@\n-  assert(framesize > 0, \"framesize must be > 0\");\n+  assert(framesize >= 2 * wordSize, \"framesize must include space for FP\/LR\");\n+  assert(framesize % (2*wordSize) == 0, \"must preserve 2*wordSize alignment\");\n@@ -4818,0 +4825,47 @@\n+void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {\n+  if (needs_stack_repair) {\n+    \/\/ Remove the extension of the caller's frame used for inline type unpacking\n+    \/\/\n+    \/\/ Right now the stack looks like this:\n+    \/\/\n+    \/\/ | Arguments from caller     |\n+    \/\/ |---------------------------|  <-- caller's SP\n+    \/\/ | Saved LR #1               |\n+    \/\/ | Saved FP #1               |\n+    \/\/ |---------------------------|\n+    \/\/ | Extension space for       |\n+    \/\/ |   inline arg (un)packing  |\n+    \/\/ |---------------------------|  <-- start of this method's frame\n+    \/\/ | Saved LR #2               |\n+    \/\/ | Saved FP #2               |\n+    \/\/ |---------------------------|  <-- FP\n+    \/\/ | sp_inc                    |\n+    \/\/ | method locals             |\n+    \/\/ |---------------------------|  <-- SP\n+    \/\/\n+    \/\/ There are two copies of FP and LR on the stack. They will be identical\n+    \/\/ unless the caller has been deoptimized, in which case LR #1 will be patched\n+    \/\/ to point at the deopt blob, and LR #2 will still point into the old method.\n+    \/\/\n+    \/\/ The sp_inc stack slot holds the total size of the frame including the\n+    \/\/ extension space minus two words for the saved FP and LR.\n+\n+    ldr(rscratch1, Address(sp, sp_inc_offset));\n+    add(sp, sp, rscratch1);\n+    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+  } else {\n+    remove_frame(initial_framesize);\n+  }\n+}\n+\n+void MacroAssembler::save_stack_increment(int sp_inc, int frame_size, int sp_inc_offset) {\n+  int real_frame_size = frame_size + sp_inc;\n+  assert(sp_inc == 0 || sp_inc > 2*wordSize, \"invalid sp_inc value\");\n+  assert(real_frame_size >= 2*wordSize, \"frame size must include FP\/LR space\");\n+  assert((real_frame_size & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+\n+  \/\/ Subtract two words for the saved FP and LR as these will be popped\n+  \/\/ separately. See remove_frame above.\n+  mov(rscratch1, real_frame_size - 2*wordSize);\n+  str(rscratch1, Address(sp, sp_inc_offset));\n+}\n@@ -5627,1 +5681,1 @@\n-\/\/ n.b. frame size includes space for return pc and rfp\n+  \/\/ n.b. frame size includes space for return pc and rfp\n@@ -5629,1 +5683,0 @@\n-  assert(framesize % (2 * wordSize) == 0, \"must preserve 2 * wordSize alignment\");\n@@ -5637,1 +5690,1 @@\n-     generate_stack_overflow_check(bangsize);\n+    generate_stack_overflow_check(bangsize);\n@@ -5642,1 +5695,1 @@\n-    Unimplemented();\n+    save_stack_increment(sp_inc, framesize, C->output()->sp_inc_offset());\n@@ -5736,1 +5789,7 @@\n-        mov(to->as_Register(), from->as_Register());\n+        if (from->is_Register() && to->is_Register()) {\n+          mov(to->as_Register(), from->as_Register());\n+        } else if (from->is_FloatRegister() && to->is_FloatRegister()) {\n+          fmovd(to->as_FloatRegister(), from->as_FloatRegister());\n+        } else {\n+          ShouldNotReachHere();\n+        }\n@@ -5738,1 +5797,1 @@\n-        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size;\n@@ -5752,1 +5811,1 @@\n-      Address from_addr = Address(sp, from->reg2stack() * VMRegImpl::stack_slot_size + wordSize);\n+      Address from_addr = Address(sp, from->reg2stack() * VMRegImpl::stack_slot_size);\n@@ -5756,1 +5815,1 @@\n-             ldrd(to->as_FloatRegister(), from_addr);\n+            ldrd(to->as_FloatRegister(), from_addr);\n@@ -5765,1 +5824,1 @@\n-        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size;\n@@ -5778,0 +5837,21 @@\n+\/\/ Calculate the extra stack space required for packing or unpacking inline\n+\/\/ args and adjust the stack pointer\n+int MacroAssembler::extend_stack_for_inline_args(int args_on_stack) {\n+  int sp_inc = args_on_stack * VMRegImpl::stack_slot_size;\n+  sp_inc = align_up(sp_inc, StackAlignmentInBytes);\n+  assert(sp_inc > 0, \"sanity\");\n+\n+  \/\/ Save a copy of the FP and LR here for deoptimization patching and frame walking\n+  stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n+\n+  \/\/ Adjust the stack pointer. This will be repaired on return by MacroAssembler::remove_frame\n+  if (sp_inc < (1 << 9)) {\n+    sub(sp, sp, sp_inc);   \/\/ Fits in an immediate\n+  } else {\n+    mov(rscratch1, sp_inc);\n+    sub(sp, sp, rscratch1);\n+  }\n+\n+  return sp_inc + 2 * wordSize;  \/\/ Account for the FP\/LR space\n+}\n+\n@@ -5784,0 +5864,1 @@\n+  Register tmp1 = r10, tmp2 = r11;\n@@ -5788,3 +5869,3 @@\n-    int st_off = from->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n-    ldr(r10, Address(sp, st_off));\n-    fromReg = r10;\n+    int st_off = from->reg2stack() * VMRegImpl::stack_slot_size;\n+    ldr(tmp1, Address(sp, st_off));\n+    fromReg = tmp1;\n@@ -5805,5 +5886,5 @@\n-     if (idx != from->value()) {\n-       mark_done = false;\n-     }\n-     done = false;\n-     continue;\n+      if (idx != from->value()) {\n+        mark_done = false;\n+      }\n+      done = false;\n+      continue;\n@@ -5818,1 +5899,1 @@\n-      Register dst = toReg->is_stack() ? r13 : toReg->as_Register();\n+      Register dst = toReg->is_stack() ? tmp2 : toReg->as_Register();\n@@ -5826,1 +5907,1 @@\n-        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n@@ -5850,1 +5931,1 @@\n-                                        RegState reg_state[]) {\n+                                        RegState reg_state[], Register val_array) {\n@@ -5859,1 +5940,0 @@\n-  Register val_array = r0;\n@@ -5864,1 +5944,1 @@\n-  Register tmp3 = r1;\n+  Register tmp3 = r12;\n@@ -5867,0 +5947,2 @@\n+  assert_different_registers(val_obj_tmp, from_reg_tmp, tmp1, tmp2, tmp3, val_array);\n+\n@@ -5893,1 +5975,1 @@\n-        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size;\n@@ -5926,9 +6008,0 @@\n-void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {\n-  assert((initial_framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n-  if (needs_stack_repair) {\n-    Unimplemented();\n-  } else {\n-    remove_frame(initial_framesize);\n-  }\n-}\n-\n@@ -5991,0 +6064,43 @@\n+void MacroAssembler::neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n+                                  FloatRegister src2, int cond, bool isQ) {\n+  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    switch (cond) {\n+      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        fcmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (cond) {\n+      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        cmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: cmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n+      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n+      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n+      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n+      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":150,"deletions":34,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -1614,1 +1614,1 @@\n-        __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));\n+        __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_trunc()));\n@@ -1617,1 +1617,1 @@\n-        __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+        __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -2377,2 +2377,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2396,2 +2394,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2413,2 +2409,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2432,2 +2426,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2466,2 +2458,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2477,1 +2467,1 @@\n-    if (code == lir_mul_strictfp || code == lir_div_strictfp) {\n+    if (code == lir_mul || code == lir_div) {\n@@ -2479,1 +2469,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -2503,2 +2493,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2511,1 +2499,1 @@\n-    if (code == lir_mul_strictfp || code == lir_div_strictfp) {\n+    if (code == lir_mul || code == lir_div) {\n@@ -2513,1 +2501,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -2588,1 +2576,0 @@\n-    case lir_mul_strictfp: \/\/ fall through\n@@ -2595,1 +2582,0 @@\n-    case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -922,0 +922,215 @@\n+\/\/ The java_calling_convention describes stack locations as ideal slots on\n+\/\/ a frame with no abi restrictions. Since we must observe abi restrictions\n+\/\/ (like the placement of the register window) the slots must be biased by\n+\/\/ the following value.\n+static int reg2offset_in(VMReg r) {\n+  \/\/ Account for saved rbp and return address\n+  \/\/ This should really be in_preserve_stack_slots\n+  return (r->reg2stack() + 4) * VMRegImpl::stack_slot_size;\n+}\n+\n+static int reg2offset_out(VMReg r) {\n+  return (r->reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;\n+}\n+\n+\/\/ A long move\n+void MacroAssembler::long_move(VMRegPair src, VMRegPair dst) {\n+\n+  \/\/ The calling conventions assures us that each VMregpair is either\n+  \/\/ all really one physical register or adjacent stack slots.\n+\n+  if (src.is_single_phys_reg() ) {\n+    if (dst.is_single_phys_reg()) {\n+      if (dst.first() != src.first()) {\n+        mov(dst.first()->as_Register(), src.first()->as_Register());\n+      }\n+    } else {\n+      assert(dst.is_single_reg(), \"not a stack pair\");\n+      movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n+    }\n+  } else if (dst.is_single_phys_reg()) {\n+    assert(src.is_single_reg(),  \"not a stack pair\");\n+    movq(dst.first()->as_Register(), Address(rbp, reg2offset_out(src.first())));\n+  } else {\n+    assert(src.is_single_reg() && dst.is_single_reg(), \"not stack pairs\");\n+    movq(rax, Address(rbp, reg2offset_in(src.first())));\n+    movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+  }\n+}\n+\n+\/\/ A double move\n+void MacroAssembler::double_move(VMRegPair src, VMRegPair dst) {\n+\n+  \/\/ The calling conventions assures us that each VMregpair is either\n+  \/\/ all really one physical register or adjacent stack slots.\n+\n+  if (src.is_single_phys_reg() ) {\n+    if (dst.is_single_phys_reg()) {\n+      \/\/ In theory these overlap but the ordering is such that this is likely a nop\n+      if ( src.first() != dst.first()) {\n+        movdbl(dst.first()->as_XMMRegister(), src.first()->as_XMMRegister());\n+      }\n+    } else {\n+      assert(dst.is_single_reg(), \"not a stack pair\");\n+      movdbl(Address(rsp, reg2offset_out(dst.first())), src.first()->as_XMMRegister());\n+    }\n+  } else if (dst.is_single_phys_reg()) {\n+    assert(src.is_single_reg(),  \"not a stack pair\");\n+    movdbl(dst.first()->as_XMMRegister(), Address(rbp, reg2offset_out(src.first())));\n+  } else {\n+    assert(src.is_single_reg() && dst.is_single_reg(), \"not stack pairs\");\n+    movq(rax, Address(rbp, reg2offset_in(src.first())));\n+    movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+  }\n+}\n+\n+\n+\/\/ A float arg may have to do float reg int reg conversion\n+void MacroAssembler::float_move(VMRegPair src, VMRegPair dst) {\n+  assert(!src.second()->is_valid() && !dst.second()->is_valid(), \"bad float_move\");\n+\n+  \/\/ The calling conventions assures us that each VMregpair is either\n+  \/\/ all really one physical register or adjacent stack slots.\n+\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      movl(rax, Address(rbp, reg2offset_in(src.first())));\n+      movptr(Address(rsp, reg2offset_out(dst.first())), rax);\n+    } else {\n+      \/\/ stack to reg\n+      assert(dst.first()->is_XMMRegister(), \"only expect xmm registers as parameters\");\n+      movflt(dst.first()->as_XMMRegister(), Address(rbp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    assert(src.first()->is_XMMRegister(), \"only expect xmm registers as parameters\");\n+    movflt(Address(rsp, reg2offset_out(dst.first())), src.first()->as_XMMRegister());\n+  } else {\n+    \/\/ reg to reg\n+    \/\/ In theory these overlap but the ordering is such that this is likely a nop\n+    if ( src.first() != dst.first()) {\n+      movdbl(dst.first()->as_XMMRegister(),  src.first()->as_XMMRegister());\n+    }\n+  }\n+}\n+\n+\/\/ On 64 bit we will store integer like items to the stack as\n+\/\/ 64 bits items (x86_32\/64 abi) even though java would only store\n+\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n+\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+void MacroAssembler::move32_64(VMRegPair src, VMRegPair dst) {\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      \/\/ stack to stack\n+      movslq(rax, Address(rbp, reg2offset_in(src.first())));\n+      movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+    } else {\n+      \/\/ stack to reg\n+      movslq(dst.first()->as_Register(), Address(rbp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    \/\/ Do we really have to sign extend???\n+    \/\/ __ movslq(src.first()->as_Register(), src.first()->as_Register());\n+    movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n+  } else {\n+    \/\/ Do we really have to sign extend???\n+    \/\/ __ movslq(dst.first()->as_Register(), src.first()->as_Register());\n+    if (dst.first() != src.first()) {\n+      movq(dst.first()->as_Register(), src.first()->as_Register());\n+    }\n+  }\n+}\n+\n+void MacroAssembler::move_ptr(VMRegPair src, VMRegPair dst) {\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      \/\/ stack to stack\n+      movq(rax, Address(rbp, reg2offset_in(src.first())));\n+      movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+    } else {\n+      \/\/ stack to reg\n+      movq(dst.first()->as_Register(), Address(rbp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n+  } else {\n+    if (dst.first() != src.first()) {\n+      movq(dst.first()->as_Register(), src.first()->as_Register());\n+    }\n+  }\n+}\n+\n+\/\/ An oop arg. Must pass a handle not the oop itself\n+void MacroAssembler::object_move(OopMap* map,\n+                        int oop_handle_offset,\n+                        int framesize_in_slots,\n+                        VMRegPair src,\n+                        VMRegPair dst,\n+                        bool is_receiver,\n+                        int* receiver_offset) {\n+\n+  \/\/ must pass a handle. First figure out the location we use as a handle\n+\n+  Register rHandle = dst.first()->is_stack() ? rax : dst.first()->as_Register();\n+\n+  \/\/ See if oop is NULL if it is we need no handle\n+\n+  if (src.first()->is_stack()) {\n+\n+    \/\/ Oop is already on the stack as an argument\n+    int offset_in_older_frame = src.first()->reg2stack() + SharedRuntime::out_preserve_stack_slots();\n+    map->set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));\n+    if (is_receiver) {\n+      *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;\n+    }\n+\n+    cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);\n+    lea(rHandle, Address(rbp, reg2offset_in(src.first())));\n+    \/\/ conditionally move a NULL\n+    cmovptr(Assembler::equal, rHandle, Address(rbp, reg2offset_in(src.first())));\n+  } else {\n+\n+    \/\/ Oop is in an a register we must store it to the space we reserve\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+\n+    const Register rOop = src.first()->as_Register();\n+    int oop_slot;\n+    if (rOop == j_rarg0)\n+      oop_slot = 0;\n+    else if (rOop == j_rarg1)\n+      oop_slot = 1;\n+    else if (rOop == j_rarg2)\n+      oop_slot = 2;\n+    else if (rOop == j_rarg3)\n+      oop_slot = 3;\n+    else if (rOop == j_rarg4)\n+      oop_slot = 4;\n+    else {\n+      assert(rOop == j_rarg5, \"wrong register\");\n+      oop_slot = 5;\n+    }\n+\n+    oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;\n+    int offset = oop_slot*VMRegImpl::stack_slot_size;\n+\n+    map->set_oop(VMRegImpl::stack2reg(oop_slot));\n+    \/\/ Store oop in handle area, may be NULL\n+    movptr(Address(rsp, offset), rOop);\n+    if (is_receiver) {\n+      *receiver_offset = offset;\n+    }\n+\n+    cmpptr(rOop, (int32_t)NULL_WORD);\n+    lea(rHandle, Address(rsp, offset));\n+    \/\/ conditionally move a NULL from the handle area where it was just stored\n+    cmovptr(Assembler::equal, rHandle, Address(rsp, offset));\n+  }\n+\n+  \/\/ If arg is on the stack then place it otherwise it is already in correct reg.\n+  if (dst.first()->is_stack()) {\n+    movptr(Address(rsp, reg2offset_out(dst.first())), rHandle);\n+  }\n+}\n+\n@@ -3283,1 +3498,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3285,1 +3500,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3288,1 +3503,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3293,1 +3508,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3295,1 +3510,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3298,1 +3513,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3303,1 +3518,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3305,1 +3520,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3308,1 +3523,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3313,1 +3528,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3315,1 +3530,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3318,1 +3533,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3369,1 +3584,1 @@\n-void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {\n+void MacroAssembler::vpmovmskb(Register dst, XMMRegister src, int vector_len) {\n@@ -3371,1 +3586,1 @@\n-  Assembler::vpmovmskb(dst, src);\n+  Assembler::vpmovmskb(dst, src, vector_len);\n@@ -3384,0 +3599,10 @@\n+void MacroAssembler::vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+  assert((UseAVX > 0), \"AVX support is needed\");\n+  if (reachable(src)) {\n+    Assembler::vpmulld(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(scratch_reg, src);\n+    Assembler::vpmulld(dst, nds, Address(scratch_reg, 0), vector_len);\n+  }\n+}\n+\n@@ -4695,1 +4920,1 @@\n-  assert((fs->_control_word._value & 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,\n+  assert((fs->_control_word._value & 0xffff) == StubRoutines::x86::fpu_cntrl_wrd_std(),\n@@ -4761,1 +4986,1 @@\n-      ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));\n+      ldmxcsr(ExternalAddress(StubRoutines::x86::addr_mxcsr_std()));\n@@ -5341,1 +5566,1 @@\n-    fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));\n+    fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n@@ -5575,0 +5800,16 @@\n+\/\/ Calculate the extra stack space required for packing or unpacking inline\n+\/\/ args and adjust the stack pointer\n+int MacroAssembler::extend_stack_for_inline_args(int args_on_stack) {\n+  \/\/ Two additional slots to account for return address\n+  int sp_inc = (args_on_stack + 2) * VMRegImpl::stack_slot_size;\n+  sp_inc = align_up(sp_inc, StackAlignmentInBytes);\n+  \/\/ Save the return address, adjust the stack (make sure it is properly\n+  \/\/ 16-byte aligned) and copy the return address to the new top of the stack.\n+  \/\/ The stack will be repaired on return (see MacroAssembler::remove_frame).\n+  assert(sp_inc > 0, \"sanity\");\n+  pop(r13);\n+  subptr(rsp, sp_inc);\n+  push(r13);\n+  return sp_inc;\n+}\n+\n@@ -5646,1 +5887,1 @@\n-                                        RegState reg_state[]) {\n+                                        RegState reg_state[], Register val_array) {\n@@ -5655,1 +5896,0 @@\n-  Register val_array = rax;\n@@ -5663,0 +5903,2 @@\n+  assert_different_registers(val_obj_tmp, from_reg_tmp, tmp1, tmp2, tmp3, val_array);\n+\n@@ -8528,1 +8770,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n@@ -8578,1 +8820,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":263,"deletions":21,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"compiler\/oopMap.hpp\"\n@@ -243,0 +245,16 @@\n+#ifdef _LP64\n+  \/\/ Support for argument shuffling\n+\n+  void move32_64(VMRegPair src, VMRegPair dst);\n+  void long_move(VMRegPair src, VMRegPair dst);\n+  void float_move(VMRegPair src, VMRegPair dst);\n+  void double_move(VMRegPair src, VMRegPair dst);\n+  void move_ptr(VMRegPair src, VMRegPair dst);\n+  void object_move(OopMap* map,\n+                   int oop_handle_offset,\n+                   int framesize_in_slots,\n+                   VMRegPair src,\n+                   VMRegPair dst,\n+                   bool is_receiver,\n+                   int* receiver_offset);\n+#endif \/\/ _LP64\n@@ -1340,1 +1358,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1342,1 +1360,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1344,1 +1362,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1346,1 +1364,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1348,1 +1366,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1350,1 +1368,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1352,1 +1370,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1354,1 +1372,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1364,1 +1382,1 @@\n-  void vpmovmskb(Register dst, XMMRegister src);\n+  void vpmovmskb(Register dst, XMMRegister src, int vector_len = Assembler::AVX_256bit);\n@@ -1368,0 +1386,7 @@\n+  void vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+    Assembler::vpmulld(dst, nds, src, vector_len);\n+  };\n+  void vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+    Assembler::vpmulld(dst, nds, src, vector_len);\n+  }\n+  void vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg);\n@@ -1763,1 +1788,2 @@\n-                          RegState reg_state[]);\n+                          RegState reg_state[], Register val_array);\n+  int extend_stack_for_inline_args(int args_on_stack);\n@@ -1839,0 +1865,1 @@\n+  void updateBytesAdler32(Register adler32, Register buf, Register length, XMMRegister shuf0, XMMRegister shuf1, ExternalAddress scale);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1712,11 +1712,2 @@\n-      Label L_strict;\n-      Label L_join;\n-      const Address access_flags      (rcx, Method::access_flags_offset());\n-      __ get_method(rcx);\n-      __ movl(rcx, access_flags);\n-      __ testl(rcx, JVM_ACC_STRICT);\n-      __ jccb(Assembler::notZero, L_strict);\n-      __ fmul_d (at_rsp());\n-      __ jmpb(L_join);\n-      __ bind(L_strict);\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      \/\/ strict semantics\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -1725,1 +1716,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -1727,1 +1718,0 @@\n-      __ bind(L_join);\n@@ -1731,11 +1721,2 @@\n-      Label L_strict;\n-      Label L_join;\n-      const Address access_flags      (rcx, Method::access_flags_offset());\n-      __ get_method(rcx);\n-      __ movl(rcx, access_flags);\n-      __ testl(rcx, JVM_ACC_STRICT);\n-      __ jccb(Assembler::notZero, L_strict);\n-      __ fdivr_d(at_rsp());\n-      __ jmp(L_join);\n-      __ bind(L_strict);\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      \/\/ strict semantics\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -1744,1 +1725,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -1746,1 +1727,0 @@\n-      __ bind(L_join);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,2 +471,0 @@\n-void Canonicalizer::do_IfInstanceOf(IfInstanceOf*    x) {}\n-\n@@ -551,0 +549,16 @@\n+  case vmIntrinsics::_getModifiers: {\n+    assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+    \/\/ Optimize for Foo.class.getModifier()\n+    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n+    if (c != NULL && !c->value()->is_null_object()) {\n+      ciType* t = c->value()->java_mirror_type();\n+      if (t->is_klass()) {\n+        set_constant(t->as_klass()->modifier_flags());\n+      } else {\n+        assert(t->is_primitive_type(), \"should be a primitive type\");\n+        set_constant(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n+      }\n+    }\n+    break;\n+  }\n@@ -802,17 +816,0 @@\n-    } else if (l->as_InstanceOf() != NULL) {\n-      \/\/ NOTE: Code permanently disabled for now since it leaves the old InstanceOf\n-      \/\/       instruction in the graph (it is pinned). Need to fix this at some point.\n-      \/\/       It should also be left in the graph when generating a profiled method version or Goto\n-      \/\/       has to know that it was an InstanceOf.\n-      return;\n-      \/\/ pattern: If ((obj instanceof klass) cond rc) => simplify to: IfInstanceOf or: Goto\n-      InstanceOf* inst = l->as_InstanceOf();\n-      BlockBegin* is_inst_sux = x->sux_for(is_true(1, x->cond(), rc)); \/\/ successor for instanceof == 1\n-      BlockBegin* no_inst_sux = x->sux_for(is_true(0, x->cond(), rc)); \/\/ successor for instanceof == 0\n-      if (is_inst_sux == no_inst_sux && inst->is_loaded()) {\n-        \/\/ both successors identical and klass is loaded => simplify to: Goto\n-        set_canonical(new Goto(is_inst_sux, x->state_before(), x->is_safepoint()));\n-      } else {\n-        \/\/ successors differ => simplify to: IfInstanceOf\n-        set_canonical(new IfInstanceOf(inst->klass(), inst->obj(), true, inst->state_before()->bci(), is_inst_sux, no_inst_sux));\n-      }\n@@ -843,17 +840,0 @@\n-  } else if (x->number_of_sux() == 1) {\n-    \/\/ NOTE: Code permanently disabled for now since the switch statement's\n-    \/\/       tag expression may produce side-effects in which case it must\n-    \/\/       be executed.\n-    return;\n-    \/\/ simplify to Goto\n-    set_canonical(new Goto(x->default_sux(), x->state_before(), x->is_safepoint()));\n-  } else if (x->number_of_sux() == 2) {\n-    \/\/ NOTE: Code permanently disabled for now since it produces two new nodes\n-    \/\/       (Constant & If) and the Canonicalizer cannot return them correctly\n-    \/\/       yet. For now we copied the corresponding code directly into the\n-    \/\/       GraphBuilder (i.e., we should never reach here).\n-    return;\n-    \/\/ simplify to If\n-    assert(x->lo_key() == x->hi_key(), \"keys must be the same\");\n-    Constant* key = new Constant(new IntConstant(x->lo_key()));\n-    set_canonical(new If(x->tag(), If::eql, true, key, x->sux_at(0), x->default_sux(), x->state_before(), x->is_safepoint()));\n@@ -874,17 +854,0 @@\n-  } else if (x->number_of_sux() == 1) {\n-    \/\/ NOTE: Code permanently disabled for now since the switch statement's\n-    \/\/       tag expression may produce side-effects in which case it must\n-    \/\/       be executed.\n-    return;\n-    \/\/ simplify to Goto\n-    set_canonical(new Goto(x->default_sux(), x->state_before(), x->is_safepoint()));\n-  } else if (x->number_of_sux() == 2) {\n-    \/\/ NOTE: Code permanently disabled for now since it produces two new nodes\n-    \/\/       (Constant & If) and the Canonicalizer cannot return them correctly\n-    \/\/       yet. For now we copied the corresponding code directly into the\n-    \/\/       GraphBuilder (i.e., we should never reach here).\n-    return;\n-    \/\/ simplify to If\n-    assert(x->length() == 1, \"length must be the same\");\n-    Constant* key = new Constant(new IntConstant(x->key_at(0)));\n-    set_canonical(new If(x->tag(), If::eql, true, key, x->sux_at(0), x->default_sux(), x->state_before(), x->is_safepoint()));\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":16,"deletions":53,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1246,3 +1246,1 @@\n-  \/\/ NOTE: strictfp can be queried from current method since we don't\n-  \/\/ inline methods with differing strictfp bits\n-  Value res = new ArithmeticOp(code, x, y, method()->is_strict(), state_before);\n+  Value res = new ArithmeticOp(code, x, y, state_before);\n@@ -1251,3 +1249,1 @@\n-  if (method()->is_strict()) {\n-    res = round_fp(res);\n-  }\n+  res = round_fp(res);\n@@ -2227,3 +2223,1 @@\n-    ciInstanceKlass* sender_klass =\n-          calling_klass->is_unsafe_anonymous() ? calling_klass->unsafe_anonymous_host() :\n-                                                 calling_klass;\n+    ciInstanceKlass* sender_klass = calling_klass;\n@@ -2346,2 +2340,1 @@\n-      if (singleton != NULL &&\n-          (!target->is_default_method() || target->is_overpass()) \/* CHA doesn't support default methods yet. *\/ ) {\n+      if (singleton != NULL) {\n@@ -2382,1 +2375,1 @@\n-      dependency_recorder()->assert_unique_concrete_method(actual_recv, cha_monomorphic_target);\n+      dependency_recorder()->assert_unique_concrete_method(actual_recv, cha_monomorphic_target, callee_holder, target);\n@@ -2388,3 +2381,1 @@\n-  if (!PatchALot && Inline && target->is_loaded() &&\n-      (klass->is_initialized() || (klass->is_interface() && target->holder()->is_initialized()))\n-      && !patch_for_appendix) {\n+  if (!PatchALot && Inline && target->is_loaded() && callee_holder->is_linked() && !patch_for_appendix) {\n@@ -2392,1 +2383,1 @@\n-    if (code == Bytecodes::_invokestatic  ||\n+    if ((code == Bytecodes::_invokestatic && callee_holder->is_initialized()) || \/\/ invokestatic involves an initialization barrier on resolved klass\n@@ -2396,2 +2387,3 @@\n-      ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;\n-      bool success = try_inline(inline_target, (cha_monomorphic_target != NULL) || (exact_target != NULL), false, code, better_receiver);\n+      ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;\n+      bool holder_known = (cha_monomorphic_target != NULL) || (exact_target != NULL);\n+      bool success = try_inline(inline_target, holder_known, false \/* ignore_return *\/, code, better_receiver);\n@@ -2486,5 +2478,1 @@\n-    if (method()->is_strict()) {\n-      push(result_type, round_fp(result));\n-    } else {\n-      push(result_type, result);\n-    }\n+    push(result_type, round_fp(result));\n@@ -3452,1 +3440,3 @@\n-  \/\/ can increment the interpreter_invocation_count.\n+  \/\/ can increment the the counters.\n+  \/\/ In addition, with range check elimination, we may need a valid block\n+  \/\/ that dominates all the rest to insert range predicates.\n@@ -3454,1 +3444,1 @@\n-  if (std_entry->number_of_preds() > 0 || count_invocations() || count_backedges()) {\n+  if (std_entry->number_of_preds() > 0 || count_invocations() || count_backedges() || RangeCheckElimination) {\n@@ -4156,1 +4146,3 @@\n-  if (!callee->holder()->is_initialized()) INLINE_BAILOUT(\"callee's klass not initialized yet\");\n+  if (!callee->holder()->is_linked())      INLINE_BAILOUT(\"callee's klass not linked yet\");\n+  if (bc == Bytecodes::_invokestatic &&\n+      !callee->holder()->is_initialized()) INLINE_BAILOUT(\"callee's klass not initialized yet\");\n@@ -4162,13 +4154,0 @@\n-  if (strict_fp_requires_explicit_rounding &&\n-      method()->is_strict() != callee->is_strict()) {\n-#ifdef IA32\n-    \/\/ If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).\n-    \/\/ When SSE2 is present, no special handling is needed.\n-    if (UseSSE < 2) {\n-      INLINE_BAILOUT(\"caller and callee have different strict fp requirements\");\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-\n@@ -4238,0 +4217,2 @@\n+  assert(bc != Bytecodes::_invokestatic || callee->holder()->is_initialized(), \"required\");\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":20,"deletions":39,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -460,1 +460,0 @@\n-  set_flag(TargetIsStrictfpFlag, target_is_loaded() && target->is_strict());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-class       IfInstanceOf;\n@@ -196,1 +195,0 @@\n-  virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;\n@@ -387,1 +385,0 @@\n-    IsStrictfpFlag,\n@@ -393,1 +390,0 @@\n-    TargetIsStrictfpFlag,\n@@ -602,1 +598,0 @@\n-  virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }\n@@ -1128,1 +1123,1 @@\n-  ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)\n+  ArithmeticOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)\n@@ -1131,1 +1126,0 @@\n-    set_flag(IsStrictfpFlag, is_strictfp);\n@@ -1135,3 +1129,0 @@\n-  \/\/ accessors\n-  bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }\n-\n@@ -1338,2 +1329,0 @@\n-  \/\/ Returns false if target is not loaded\n-  bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }\n@@ -2181,54 +2170,0 @@\n-LEAF(IfInstanceOf, BlockEnd)\n- private:\n-  ciKlass* _klass;\n-  Value    _obj;\n-  bool     _test_is_instance;                    \/\/ jump if instance\n-  int      _instanceof_bci;\n-\n- public:\n-  IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)\n-  : BlockEnd(illegalType, NULL, false) \/\/ temporary set to false\n-  , _klass(klass)\n-  , _obj(obj)\n-  , _test_is_instance(test_is_instance)\n-  , _instanceof_bci(instanceof_bci)\n-  {\n-    ASSERT_VALUES\n-    assert(instanceof_bci >= 0, \"illegal bci\");\n-    BlockList* s = new BlockList(2);\n-    s->append(tsux);\n-    s->append(fsux);\n-    set_sux(s);\n-  }\n-\n-  \/\/ accessors\n-  \/\/\n-  \/\/ Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an\n-  \/\/         instance of klass; otherwise it tests if it is *not* and instance\n-  \/\/         of klass.\n-  \/\/\n-  \/\/ Note 2: IfInstanceOf instructions are created by combining an InstanceOf\n-  \/\/         and an If instruction. The IfInstanceOf bci() corresponds to the\n-  \/\/         bci that the If would have had; the (this->) instanceof_bci() is\n-  \/\/         the bci of the original InstanceOf instruction.\n-  ciKlass* klass() const                         { return _klass; }\n-  Value obj() const                              { return _obj; }\n-  int instanceof_bci() const                     { return _instanceof_bci; }\n-  bool test_is_instance() const                  { return _test_is_instance; }\n-  BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }\n-  BlockBegin* tsux() const                       { return sux_for(true); }\n-  BlockBegin* fsux() const                       { return sux_for(false); }\n-\n-  \/\/ manipulation\n-  void swap_sux() {\n-    assert(number_of_sux() == 2, \"wrong number of successors\");\n-    BlockList* s = sux();\n-    BlockBegin* t = s->at(0); s->at_put(0, s->at(1)); s->at_put(1, t);\n-    _test_is_instance = !_test_is_instance;\n-  }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f->visit(&_obj); }\n-};\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":66,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -218,2 +218,0 @@\n-    case lir_mul_strictfp:\n-    case lir_div_strictfp:\n@@ -604,2 +602,0 @@\n-    case lir_mul:\n-    case lir_div:\n@@ -663,2 +659,2 @@\n-    case lir_mul_strictfp:\n-    case lir_div_strictfp:\n+    case lir_mul:\n+    case lir_div:\n@@ -1853,2 +1849,0 @@\n-     case lir_mul_strictfp:          s = \"mul_strictfp\";  break;\n-     case lir_div_strictfp:          s = \"div_strictfp\";  break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -492,17 +492,1 @@\n-\n-void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {\n-  CodeStub* stub = new RangeCheckStub(info, index);\n-  if (index->is_constant()) {\n-    cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index->as_jint(), info);\n-    __ branch(lir_cond_belowEqual, stub); \/\/ forward branch\n-  } else {\n-    cmp_reg_mem(lir_cond_aboveEqual, index, buffer,\n-                java_nio_Buffer::limit_offset(), T_INT, info);\n-    __ branch(lir_cond_aboveEqual, stub); \/\/ forward branch\n-  }\n-  __ move(index, result);\n-}\n-\n-\n-\n-void LIRGenerator::arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp_op, CodeEmitInfo* info) {\n+void LIRGenerator::arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp_op, CodeEmitInfo* info) {\n@@ -527,9 +511,1 @@\n-    case Bytecodes::_dmul:\n-      {\n-        if (is_strictfp) {\n-          __ mul_strictfp(left_op, right_op, result_op, tmp_op); break;\n-        } else {\n-          __ mul(left_op, right_op, result_op); break;\n-        }\n-      }\n-      break;\n+    case Bytecodes::_dmul:  __ mul(left_op, right_op, result_op, tmp_op); break;\n@@ -566,9 +542,1 @@\n-    case Bytecodes::_ddiv:\n-      {\n-        if (is_strictfp) {\n-          __ div_strictfp (left_op, right_op, result_op, tmp_op); break;\n-        } else {\n-          __ div (left_op, right_op, result_op); break;\n-        }\n-      }\n-      break;\n+    case Bytecodes::_ddiv: __ div(left_op, right_op, result_op, tmp_op); break;\n@@ -585,1 +553,1 @@\n-  arithmetic_op(code, result, left, right, false, tmp);\n+  arithmetic_op(code, result, left, right, tmp);\n@@ -590,1 +558,1 @@\n-  arithmetic_op(code, result, left, right, false, LIR_OprFact::illegalOpr, info);\n+  arithmetic_op(code, result, left, right, LIR_OprFact::illegalOpr, info);\n@@ -594,2 +562,2 @@\n-void LIRGenerator::arithmetic_op_fpu(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp) {\n-  arithmetic_op(code, result, left, right, is_strictfp, tmp);\n+void LIRGenerator::arithmetic_op_fpu(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp) {\n+  arithmetic_op(code, result, left, right, tmp);\n@@ -1209,5 +1177,0 @@\n-void LIRGenerator::do_IfInstanceOf(IfInstanceOf* x) {\n-  Unimplemented();\n-}\n-\n-\n@@ -1334,0 +1297,28 @@\n+\/\/ Example: Foo.class.getModifiers()\n+void LIRGenerator::do_getModifiers(Intrinsic* x) {\n+  assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+  LIRItem receiver(x->argument_at(0), this);\n+  receiver.load_item();\n+  LIR_Opr result = rlock_result(x);\n+\n+  CodeEmitInfo* info = NULL;\n+  if (x->needs_null_check()) {\n+    info = state_for(x);\n+  }\n+\n+  LabelObj* L_not_prim = new LabelObj();\n+  LabelObj* L_done = new LabelObj();\n+\n+  LIR_Opr klass = new_register(T_METADATA);\n+  \/\/ Checking if it's a java mirror of primitive type\n+  __ move(new LIR_Address(receiver.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);\n+  __ cmp(lir_cond_notEqual, klass, LIR_OprFact::metadataConst(0));\n+  __ branch(lir_cond_notEqual, L_not_prim->label());\n+  __ move(LIR_OprFact::intConst(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC), result);\n+  __ branch(lir_cond_always, L_done->label());\n+\n+  __ branch_destination(L_not_prim->label());\n+  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_INT), result);\n+  __ branch_destination(L_done->label());\n+}\n@@ -2166,0 +2157,6 @@\n+\/\/ int\/long jdk.internal.util.Preconditions.checkIndex\n+void LIRGenerator::do_PreconditionsCheckIndex(Intrinsic* x, BasicType type) {\n+  assert(x->number_of_arguments() == 3, \"wrong type\");\n+  LIRItem index(x->argument_at(0), this);\n+  LIRItem length(x->argument_at(1), this);\n+  LIRItem oobef(x->argument_at(2), this);\n@@ -2167,11 +2164,2 @@\n-\/\/------------------------java.nio.Buffer.checkIndex------------------------\n-\n-\/\/ int java.nio.Buffer.checkIndex(int)\n-void LIRGenerator::do_NIOCheckIndex(Intrinsic* x) {\n-  \/\/ NOTE: by the time we are in checkIndex() we are guaranteed that\n-  \/\/ the buffer is non-null (because checkIndex is package-private and\n-  \/\/ only called from within other methods in the buffer).\n-  assert(x->number_of_arguments() == 2, \"wrong type\");\n-  LIRItem buf  (x->argument_at(0), this);\n-  LIRItem index(x->argument_at(1), this);\n-  buf.load_item();\n+  length.load_item();\n+  oobef.load_item();\n@@ -2181,10 +2169,15 @@\n-  if (GenerateRangeChecks) {\n-    CodeEmitInfo* info = state_for(x);\n-    CodeStub* stub = new RangeCheckStub(info, index.result());\n-    if (index.result()->is_constant()) {\n-      cmp_mem_int(lir_cond_belowEqual, buf.result(), java_nio_Buffer::limit_offset(), index.result()->as_jint(), info);\n-      __ branch(lir_cond_belowEqual, stub);\n-    } else {\n-      cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf.result(),\n-                  java_nio_Buffer::limit_offset(), T_INT, info);\n-      __ branch(lir_cond_aboveEqual, stub);\n+  \/\/ x->state() is created from copy_state_for_exception, it does not contains arguments\n+  \/\/ we should prepare them before entering into interpreter mode due to deoptimization.\n+  ValueStack* state = x->state();\n+  for (int i = 0; i < x->number_of_arguments(); i++) {\n+    Value arg = x->argument_at(i);\n+    state->push(arg->type(), arg);\n+  }\n+  CodeEmitInfo* info = state_for(x, state);\n+\n+  LIR_Opr len = length.result();\n+  LIR_Opr zero = NULL;\n+  if (type == T_INT) {\n+    zero = LIR_OprFact::intConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::intConst(length.result()->as_jint());\n@@ -2192,4 +2185,34 @@\n-    __ move(index.result(), result);\n-    \/\/ Just load the index into the result register\n-    __ move(index.result(), result);\n-  }\n+    assert(type == T_LONG, \"sanity check\");\n+    zero = LIR_OprFact::longConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::longConst(length.result()->as_jlong());\n+    }\n+  }\n+  \/\/ C1 can not handle the case that comparing index with constant value while condition\n+  \/\/ is neither lir_cond_equal nor lir_cond_notEqual, see LIR_Assembler::comp_op.\n+  LIR_Opr zero_reg = new_register(type);\n+  __ move(zero, zero_reg);\n+#if defined(X86) && !defined(_LP64)\n+  \/\/ BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.\n+  LIR_Opr index_copy = new_register(index.type());\n+  \/\/ index >= 0\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_less, index_copy, zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_greaterEqual, index_copy, len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#else\n+  \/\/ index >= 0\n+  __ cmp(lir_cond_less, index.result(), zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ cmp(lir_cond_greaterEqual, index.result(), len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#endif\n+  __ move(index.result(), result);\n@@ -2199,1 +2222,0 @@\n-\n@@ -3420,11 +3442,0 @@\n-  if (x->type()->is_float() || x->type()->is_double()) {\n-    \/\/ Force rounding of results from non-strictfp when in strictfp\n-    \/\/ scope (or when we don't know the strictness of the callee, to\n-    \/\/ be safe.)\n-    if (method()->is_strict()) {\n-      if (!x->target_is_loaded() || !x->target_is_strictfp()) {\n-        result_register = round_item(result_register);\n-      }\n-    }\n-  }\n-\n@@ -3539,27 +3550,0 @@\n-void LIRGenerator::do_ClassIDIntrinsic(Intrinsic* x) {\n-  CodeEmitInfo* info = state_for(x);\n-  CodeEmitInfo* info2 = new CodeEmitInfo(info); \/\/ Clone for the second null check\n-\n-  assert(info != NULL, \"must have info\");\n-  LIRItem arg(x->argument_at(0), this);\n-\n-  arg.load_item();\n-  LIR_Opr klass = new_register(T_METADATA);\n-  __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);\n-  LIR_Opr id = new_register(T_LONG);\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);\n-\n-  __ move(trace_id_addr, id);\n-  __ logical_or(id, LIR_OprFact::longConst(0x01l), id);\n-  __ store(id, trace_id_addr);\n-\n-#ifdef TRACE_ID_META_BITS\n-  __ logical_and(id, LIR_OprFact::longConst(~TRACE_ID_META_BITS), id);\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  __ unsigned_shift_right(id, TRACE_ID_SHIFT, id);\n-#endif\n-\n-  __ move(id, rlock_result(x));\n-}\n@@ -3615,3 +3599,0 @@\n-  case vmIntrinsics::_getClassId:\n-    do_ClassIDIntrinsic(x);\n-    break;\n@@ -3637,0 +3618,1 @@\n+  case vmIntrinsics::_getModifiers:   do_getModifiers(x);  break;\n@@ -3655,2 +3637,6 @@\n-  \/\/ java.nio.Buffer.checkIndex\n-  case vmIntrinsics::_checkIndex:     do_NIOCheckIndex(x); break;\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+    do_PreconditionsCheckIndex(x, T_INT);\n+    break;\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n+    do_PreconditionsCheckIndex(x, T_LONG);\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":99,"deletions":113,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -671,9 +671,5 @@\n-    if (cpool->is_pseudo_string_at(index)) {\n-      string = cpool->pseudo_string_at(index, cache_index);\n-    } else {\n-      string = cpool->string_at(index, cache_index, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-        record_out_of_memory_failure();\n-        return ciConstant();\n-      }\n+    string = cpool->string_at(index, cache_index, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      CLEAR_PENDING_EXCEPTION;\n+      record_out_of_memory_failure();\n+      return ciConstant();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -258,2 +258,1 @@\n-  \/\/ Trust hidden classes and VM unsafe anonymous classes. They are created via\n-  \/\/ Lookup.defineHiddenClass or the private jdk.internal.misc.Unsafe API and\n+  \/\/ Trust hidden classes. They are created via Lookup.defineHiddenClass and\n@@ -261,1 +260,1 @@\n-  if (holder->is_hidden() || holder->is_unsafe_anonymous())\n+  if (holder->is_hidden())\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,1 +143,4 @@\n-#define CONSTANT_CLASS_DESCRIPTORS        61\n+#define JAVA_18_VERSION                   62\n+\n+#define CONSTANT_CLASS_DESCRIPTORS        62\n+\n@@ -330,12 +333,0 @@\n-        if (has_cp_patch_at(index)) {\n-          Handle patch = clear_cp_patch_at(index);\n-          guarantee_property(java_lang_String::is_instance(patch()),\n-                             \"Illegal utf8 patch at %d in class file %s\",\n-                             index,\n-                             CHECK);\n-          const char* const str = java_lang_String::as_utf8_string(patch());\n-          \/\/ (could use java_lang_String::as_symbol instead, but might as well batch them)\n-          utf8_buffer = (const u1*) str;\n-          utf8_length = (u2) strlen(str);\n-        }\n-\n@@ -631,31 +622,1 @@\n-  _first_patched_klass_resolved_index = num_klasses;\n-  cp->allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);\n-\n-  if (_cp_patches != NULL) {\n-    \/\/ need to treat this_class specially...\n-\n-    \/\/ Add dummy utf8 entries in the space reserved for names of patched classes. We'll use \"*\"\n-    \/\/ for now. These will be replaced with actual names of the patched classes in patch_class().\n-    Symbol* s = vmSymbols::star_name();\n-    for (int n=_orig_cp_size; n<cp->length(); n++) {\n-      cp->symbol_at_put(n, s);\n-    }\n-\n-    int this_class_index;\n-    {\n-      stream->guarantee_more(8, CHECK);  \/\/ flags, this_class, super_class, infs_len\n-      const u1* const mark = stream->current();\n-      stream->skip_u2_fast(1); \/\/ skip flags\n-      this_class_index = stream->get_u2_fast();\n-      stream->set_current(mark);  \/\/ revert to mark\n-    }\n-\n-    for (index = 1; index < length; index++) {          \/\/ Index 0 is unused\n-      if (has_cp_patch_at(index)) {\n-        guarantee_property(index != this_class_index,\n-          \"Illegal constant pool patch to self at %d in class file %s\",\n-          index, CHECK);\n-        patch_constant_pool(cp, index, cp_patch_at(index), CHECK);\n-      }\n-    }\n-  }\n+  cp->allocate_resolved_klasses(_loader_data, num_klasses, CHECK);\n@@ -674,1 +635,1 @@\n-        \/\/ check the name, even if _cp_patches will overwrite it\n+        \/\/ check the name\n@@ -825,82 +786,0 @@\n-Handle ClassFileParser::clear_cp_patch_at(int index) {\n-  Handle patch = cp_patch_at(index);\n-  _cp_patches->at_put(index, Handle());\n-  assert(!has_cp_patch_at(index), \"\");\n-  return patch;\n-}\n-\n-void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {\n-  int name_index = _orig_cp_size + _num_patched_klasses;\n-  int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;\n-\n-  cp->klass_at_put(class_index, name_index, resolved_klass_index, k, name);\n-  _num_patched_klasses ++;\n-}\n-\n-void ClassFileParser::patch_constant_pool(ConstantPool* cp,\n-                                          int index,\n-                                          Handle patch,\n-                                          TRAPS) {\n-  assert(cp != NULL, \"invariant\");\n-\n-  BasicType patch_type = T_VOID;\n-\n-  switch (cp->tag_at(index).value()) {\n-\n-    case JVM_CONSTANT_UnresolvedClass: {\n-      \/\/ Patching a class means pre-resolving it.\n-      \/\/ The name in the constant pool is ignored.\n-      if (java_lang_Class::is_instance(patch())) {\n-        guarantee_property(!java_lang_Class::is_primitive(patch()),\n-                           \"Illegal class patch at %d in class file %s\",\n-                           index, CHECK);\n-        Klass* k = java_lang_Class::as_Klass(patch());\n-        patch_class(cp, index, k, k->name());\n-      } else {\n-        guarantee_property(java_lang_String::is_instance(patch()),\n-                           \"Illegal class patch at %d in class file %s\",\n-                           index, CHECK);\n-        Symbol* const name = java_lang_String::as_symbol(patch());\n-        patch_class(cp, index, NULL, name);\n-      }\n-      break;\n-    }\n-\n-    case JVM_CONSTANT_String: {\n-      \/\/ skip this patch and don't clear it.  Needs the oop array for resolved\n-      \/\/ references to be created first.\n-      return;\n-    }\n-    case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;\n-    case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;\n-    case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;\n-    case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;\n-    patch_prim:\n-    {\n-      jvalue value;\n-      BasicType value_type = java_lang_boxing_object::get_value(patch(), &value);\n-      guarantee_property(value_type == patch_type,\n-                         \"Illegal primitive patch at %d in class file %s\",\n-                         index, CHECK);\n-      switch (value_type) {\n-        case T_INT:    cp->int_at_put(index,   value.i); break;\n-        case T_FLOAT:  cp->float_at_put(index, value.f); break;\n-        case T_LONG:   cp->long_at_put(index,  value.j); break;\n-        case T_DOUBLE: cp->double_at_put(index, value.d); break;\n-        default:       assert(false, \"\");\n-      }\n-    } \/\/ end patch_prim label\n-    break;\n-\n-    default: {\n-      \/\/ %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.\n-      guarantee_property(!has_cp_patch_at(index),\n-                         \"Illegal unexpected patch at %d in class file %s\",\n-                         index, CHECK);\n-      return;\n-    }\n-  } \/\/ end of switch(tag)\n-\n-  \/\/ On fall-through, mark the patch as used.\n-  clear_cp_patch_at(index);\n-}\n@@ -2505,1 +2384,1 @@\n-      flags &= JVM_ACC_STATIC | JVM_ACC_STRICT;\n+      flags &= JVM_ACC_STATIC | (_major_version <= JAVA_16_VERSION ? JVM_ACC_STRICT : 0);\n@@ -3814,5 +3693,0 @@\n-bool ClassFileParser::supports_sealed_types() {\n-  \/\/ temporarily disable the sealed type preview feature check\n-  return _major_version == JVM_CLASSFILE_MAJOR_VERSION;\n-}\n-\n@@ -4075,2 +3949,2 @@\n-          } else if (tag == vmSymbols::tag_permitted_subclasses()) {\n-            if (supports_sealed_types()) {\n+          } else if (_major_version >= JAVA_17_VERSION) {\n+            if (tag == vmSymbols::tag_permitted_subclasses()) {\n@@ -4091,1 +3965,1 @@\n-          \/\/ Skip attribute_length for any attribute where major_verson >= JAVA_16_VERSION\n+          \/\/ Skip attribute_length for any attribute where major_verson >= JAVA_17_VERSION\n@@ -4481,1 +4355,1 @@\n-        Thread *THREAD = Thread::current();\n+        JavaThread *THREAD = Thread::current()->as_Java_thread();\n@@ -4997,0 +4871,1 @@\n+  const bool major_gte_17    = _major_version >= JAVA_17_VERSION;\n@@ -5016,1 +4891,1 @@\n-          (is_abstract && (is_private || is_static || is_strict))) {\n+          (is_abstract && (is_private || is_static || (!major_gte_17 && is_strict)))) {\n@@ -5056,1 +4931,1 @@\n-                (major_gte_1_5 && (is_synchronized || is_strict)))) {\n+                (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n@@ -5748,1 +5623,1 @@\n-  if (_is_hidden || is_unsafe_anonymous()) {\n+  if (_is_hidden) {\n@@ -5750,3 +5625,3 @@\n-    \/\/ hidden or anonymous class itself. If this class needs to refer to its own\n-    \/\/ methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference\n-    \/\/ _this_class_index. However, because this class is hidden or anonymous (it's\n+    \/\/ hidden class itself. If this class needs to refer to its own methods\n+    \/\/ or fields, it would use a CONSTANT_MethodRef, etc, which would reference\n+    \/\/ _this_class_index. However, because this class is hidden (it's\n@@ -5767,4 +5642,0 @@\n-  if (_unsafe_anonymous_host != NULL) {\n-    assert (ik->is_unsafe_anonymous(), \"should be the same\");\n-    ik->set_unsafe_anonymous_host(_unsafe_anonymous_host);\n-  }\n@@ -5983,51 +5854,0 @@\n-\/\/ For an unsafe anonymous class that is in the unnamed package, move it to its host class's\n-\/\/ package by prepending its host class's package name to its class name and setting\n-\/\/ its _class_name field.\n-void ClassFileParser::prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host) {\n-  ResourceMark rm(current);\n-  assert(strrchr(_class_name->as_C_string(), JVM_SIGNATURE_SLASH) == NULL,\n-         \"Unsafe anonymous class should not be in a package\");\n-  TempNewSymbol host_pkg_name =\n-    ClassLoader::package_from_class_name(unsafe_anonymous_host->name());\n-\n-  if (host_pkg_name != NULL) {\n-    int host_pkg_len = host_pkg_name->utf8_length();\n-    int class_name_len = _class_name->utf8_length();\n-    int symbol_len = host_pkg_len + 1 + class_name_len;\n-    char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);\n-    int n = os::snprintf(new_anon_name, symbol_len + 1, \"%.*s\/%.*s\",\n-                         host_pkg_len, host_pkg_name->base(), class_name_len, _class_name->base());\n-    assert(n == symbol_len, \"Unexpected number of characters in string\");\n-\n-    \/\/ Decrement old _class_name to avoid leaking.\n-    _class_name->decrement_refcount();\n-\n-    \/\/ Create a symbol and update the anonymous class name.\n-    \/\/ The new class name is created with a refcount of one. When installed into the InstanceKlass,\n-    \/\/ it'll be two and when the ClassFileParser destructor runs, it'll go back to one and get deleted\n-    \/\/ when the class is unloaded.\n-    _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);\n-  }\n-}\n-\n-\/\/ If the host class and the anonymous class are in the same package then do\n-\/\/ nothing.  If the anonymous class is in the unnamed package then move it to its\n-\/\/ host's package.  If the classes are in different packages then throw an IAE\n-\/\/ exception.\n-void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {\n-  assert(_unsafe_anonymous_host != NULL, \"Expected an unsafe anonymous class\");\n-\n-  const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name->base(),\n-                                               _class_name->utf8_length(), JVM_SIGNATURE_SLASH);\n-  if (anon_last_slash == NULL) {  \/\/ Unnamed package\n-    prepend_host_package_name(THREAD, _unsafe_anonymous_host);\n-  } else {\n-    if (!_unsafe_anonymous_host->is_same_class_package(_unsafe_anonymous_host->class_loader(), _class_name)) {\n-      ResourceMark rm(THREAD);\n-      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-        err_msg(\"Host class %s and anonymous class %s are in different packages\",\n-        _unsafe_anonymous_host->name()->as_C_string(), _class_name->as_C_string()));\n-    }\n-  }\n-}\n-\n@@ -6054,2 +5874,0 @@\n-  _unsafe_anonymous_host(cl_info->unsafe_anonymous_host()),\n-  _cp_patches(cl_info->cp_patches()),\n@@ -6058,3 +5876,0 @@\n-  _num_patched_klasses(0),\n-  _max_num_patched_klasses(0),\n-  _first_patched_klass_resolved_index(0),\n@@ -6130,1 +5945,0 @@\n-  assert(THREAD->is_Java_thread(), \"invariant\");\n@@ -6150,19 +5964,0 @@\n-  if (_cp_patches != NULL) {\n-    int len = _cp_patches->length();\n-    for (int i=0; i<len; i++) {\n-      if (has_cp_patch_at(i)) {\n-        Handle patch = cp_patch_at(i);\n-        if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {\n-          \/\/ We need to append the names of the patched classes to the end of the constant pool,\n-          \/\/ because a patched class may have a Utf8 name that's not already included in the\n-          \/\/ original constant pool. These class names are used when patch_constant_pool()\n-          \/\/ calls patch_class().\n-          \/\/\n-          \/\/ Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.\n-          \/\/ At this point, we don't know the tag for index i yet, because we haven't parsed the\n-          \/\/ constant pool. So we can only assume the worst -- every String is used to patch a Class.\n-          _max_num_patched_klasses++;\n-        }\n-      }\n-    }\n-  }\n@@ -6298,6 +6093,0 @@\n-    assert(_max_num_patched_klasses == 0, \"Sanity check\");\n-  } else {\n-    if (int(cp_size) + _max_num_patched_klasses > 0xffff) {\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"not enough space for patched classes\");\n-    }\n-    cp_size += _max_num_patched_klasses;\n@@ -6372,5 +6161,0 @@\n-  assert(!(_is_hidden && (_unsafe_anonymous_host != NULL)), \"mutually exclusive variants\");\n-\n-  if (_unsafe_anonymous_host != NULL) {\n-    assert(_class_name == vmSymbols::unknown_class_name(), \"A named anonymous class???\");\n-  }\n@@ -6382,2 +6166,1 @@\n-  \/\/ Update the _class_name as needed depending on whether this is a named,\n-  \/\/ un-named, hidden or unsafe-anonymous class.\n+  \/\/ Update the _class_name as needed depending on whether this is a named, un-named, or hidden class.\n@@ -6393,10 +6176,0 @@\n-  \/\/ NOTE: !_is_hidden does not imply \"findable\" as it could be an old-style\n-  \/\/       \"hidden\" unsafe-anonymous class\n-\n-  \/\/ If this is an anonymous class fix up its name if it is in the unnamed\n-  \/\/ package.  Otherwise, throw IAE if it is in a different package than\n-  \/\/ its host class.\n-  } else if (_unsafe_anonymous_host != NULL) {\n-    update_class_name(class_name_in_cp);\n-    fix_unsafe_anonymous_class_name(CHECK);\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":19,"deletions":246,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+int java_lang_String::_flags_offset;\n@@ -213,0 +214,12 @@\n+bool java_lang_String::test_and_set_flag(oop java_string, uint8_t flag_mask) {\n+  uint8_t* addr = flags_addr(java_string);\n+  uint8_t value = Atomic::load(addr);\n+  while ((value & flag_mask) == 0) {\n+    uint8_t old_value = value;\n+    value |= flag_mask;\n+    value = Atomic::cmpxchg(addr, old_value, value);\n+    if (value == old_value) return false; \/\/ Flag bit changed from 0 to 1.\n+  }\n+  return true;                  \/\/ Flag bit is already 1.\n+}\n+\n@@ -226,0 +239,1 @@\n+  STRING_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n@@ -233,0 +247,1 @@\n+  STRING_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n@@ -420,1 +435,1 @@\n-    JavaThread* thread = THREAD->as_Java_thread();\n+    JavaThread* thread = THREAD;\n@@ -446,1 +461,1 @@\n-  { JavaThread* thread = THREAD->as_Java_thread();\n+  { JavaThread* thread = THREAD;\n@@ -459,49 +474,4 @@\n-Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {\n-  oop          obj    = java_string();\n-  \/\/ Typical usage is to convert all '\/' to '.' in string.\n-  typeArrayOop value  = java_lang_String::value(obj);\n-  int          length = java_lang_String::length(obj, value);\n-  bool      is_latin1 = java_lang_String::is_latin1(obj);\n-\n-  \/\/ First check if any from_char exist\n-  int index; \/\/ Declared outside, used later\n-  for (index = 0; index < length; index++) {\n-    jchar c = !is_latin1 ? value->char_at(index) :\n-                  ((jchar) value->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      break;\n-    }\n-  }\n-  if (index == length) {\n-    \/\/ No from_char, so do not copy.\n-    return java_string;\n-  }\n-\n-  \/\/ Check if result string will be latin1\n-  bool to_is_latin1 = false;\n-\n-  \/\/ Replacement char must be latin1\n-  if (CompactStrings && UNICODE::is_latin1(to_char)) {\n-    if (is_latin1) {\n-      \/\/ Source string is latin1 as well\n-      to_is_latin1 = true;\n-    } else if (!UNICODE::is_latin1(from_char)) {\n-      \/\/ We are replacing an UTF16 char. Scan string to\n-      \/\/ check if result can be latin1 encoded.\n-      to_is_latin1 = true;\n-      for (index = 0; index < length; index++) {\n-        jchar c = value->char_at(index);\n-        if (c != from_char && !UNICODE::is_latin1(c)) {\n-          to_is_latin1 = false;\n-          break;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Create new UNICODE (or byte) buffer. Must handlize value because GC\n-  \/\/ may happen during String and char array creation.\n-  typeArrayHandle h_value(THREAD, value);\n-  Handle string = basic_create(length, to_is_latin1, CHECK_NH);\n-  typeArrayOop from_buffer = h_value();\n-  typeArrayOop to_buffer = java_lang_String::value(string());\n+Handle java_lang_String::externalize_classname(Symbol* java_name, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  return create_from_str(java_name->as_klass_external_name(), THREAD);\n+}\n@@ -509,12 +479,4 @@\n-  \/\/ Copy contents\n-  for (index = 0; index < length; index++) {\n-    jchar c = (!is_latin1) ? from_buffer->char_at(index) :\n-                    ((jchar) from_buffer->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      c = to_char;\n-    }\n-    if (!to_is_latin1) {\n-      to_buffer->char_at_put(index, c);\n-    } else {\n-      to_buffer->byte_at_put(index, (jbyte) c);\n-    }\n+jchar* java_lang_String::as_unicode_string(oop java_string, int& length, TRAPS) {\n+  jchar* result = as_unicode_string_or_null(java_string, length);\n+  if (result == NULL) {\n+    THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), \"could not allocate Unicode string\");\n@@ -522,1 +484,1 @@\n-  return string;\n+  return result;\n@@ -525,1 +487,1 @@\n-jchar* java_lang_String::as_unicode_string(oop java_string, int& length, TRAPS) {\n+jchar* java_lang_String::as_unicode_string_or_null(oop java_string, int& length) {\n@@ -541,2 +503,0 @@\n-  } else {\n-    THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), \"could not allocate Unicode string\");\n@@ -1104,1 +1064,1 @@\n-    set_mirror_module_field(THREAD->as_Java_thread(), k, mirror, module);\n+    set_mirror_module_field(THREAD, k, mirror, module);\n@@ -1445,1 +1405,1 @@\n-  set_mirror_module_field(THREAD->as_Java_thread(), k, mirror, module);\n+  set_mirror_module_field(THREAD, k, mirror, module);\n@@ -2485,1 +2445,1 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -2550,1 +2510,1 @@\n-  JavaThread* thread = THREAD->as_Java_thread();\n+  JavaThread* thread = THREAD;\n@@ -2686,1 +2646,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -2713,1 +2673,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -2781,3 +2741,3 @@\n-  Thread* THREAD = Thread::current();\n-  objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));\n-  BacktraceIterator iter(result, THREAD);\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle result(current, objArrayOop(backtrace(throwable)));\n+  BacktraceIterator iter(result, current);\n@@ -2795,1 +2755,1 @@\n-  BacktraceElement bte = iter.next(THREAD);\n+  BacktraceElement bte = iter.next(current);\n@@ -3951,1 +3911,0 @@\n-int jdk_internal_invoke_NativeEntryPoint::_addr_offset;\n@@ -3960,1 +3919,0 @@\n-  macro(_addr_offset,            k, \"addr\",           long_signature, false); \\\n@@ -3983,4 +3941,0 @@\n-address jdk_internal_invoke_NativeEntryPoint::addr(oop entry) {\n-  return (address)entry->long_field(_addr_offset);\n-}\n-\n@@ -4144,1 +4098,1 @@\n-  \/\/ Add a reference to the loader (actually mirror because unsafe anonymous classes will not have\n+  \/\/ Add a reference to the loader (actually mirror because hidden classes may not have\n@@ -4714,20 +4668,0 @@\n-\n-\/\/ Support for intrinsification of java.nio.Buffer.checkIndex\n-\n-int java_nio_Buffer::_limit_offset;\n-\n-#define BUFFER_FIELDS_DO(macro) \\\n-  macro(_limit_offset, k, \"limit\", int_signature, false)\n-\n-void java_nio_Buffer::compute_offsets() {\n-  InstanceKlass* k = vmClasses::nio_Buffer_klass();\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n-  BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {\n-  BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n@@ -5090,1 +5024,1 @@\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated anonymous classes\n+      \/\/ regular Java code. The implementation of java.lang.invoke uses generated hidden classes\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":39,"deletions":105,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  f(java_nio_Buffer) \\\n@@ -99,0 +98,5 @@\n+\/\/ The flags field is a collection of bits representing boolean values used\n+\/\/ internally by the VM.\n+#define STRING_INJECTED_FIELDS(macro) \\\n+  macro(java_lang_String, flags, byte_signature, false)\n+\n@@ -105,0 +109,1 @@\n+  static int _flags_offset;\n@@ -112,0 +117,13 @@\n+  \/\/ Bitmasks for values in the injected flags field.\n+  static const uint8_t _deduplication_forbidden_mask = 1 << 0;\n+  static const uint8_t _deduplication_requested_mask = 1 << 1;\n+\n+  static int flags_offset() { CHECK_INIT(_flags_offset); }\n+  \/\/ Return the address of the injected flags field.\n+  static inline uint8_t* flags_addr(oop java_string);\n+  \/\/ Test whether the designated bit of the injected flags field is set.\n+  static inline bool is_flag_set(oop java_string, uint8_t flag_mask);\n+  \/\/ Atomically test and set the designated bit of the injected flags field,\n+  \/\/ returning true if the bit was already set.\n+  static bool test_and_set_flag(oop java_string, uint8_t flag_mask);\n+\n@@ -130,1 +148,0 @@\n-  static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);\n@@ -140,0 +157,13 @@\n+  \/\/ Set the deduplication_forbidden flag true.  This flag is sticky; once\n+  \/\/ set it never gets cleared.  This is set when a String is interned in\n+  \/\/ the StringTable, to prevent string deduplication from changing the\n+  \/\/ String's value array.\n+  static inline void set_deduplication_forbidden(oop java_string);\n+\n+  \/\/ Test and set the deduplication_requested flag.  Returns the old value\n+  \/\/ of the flag.  This flag is sticky; once set it never gets cleared.\n+  \/\/ Some GCs may use this flag when deciding whether to request\n+  \/\/ deduplication of a String, to avoid multiple requests for the same\n+  \/\/ object.\n+  static inline bool test_and_set_deduplication_requested(oop java_string);\n+\n@@ -145,0 +175,2 @@\n+  static inline bool deduplication_forbidden(oop java_string);\n+  static inline bool deduplication_requested(oop java_string);\n@@ -160,0 +192,1 @@\n+  static jchar* as_unicode_string_or_null(oop java_string, int& length);\n@@ -197,4 +230,2 @@\n-  \/\/ Conversion between '.' and '\/' formats\n-  static Handle externalize_classname(Handle java_string, TRAPS) {\n-    return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);\n-  }\n+  \/\/ Conversion between '.' and '\/' formats, and allocate a String from the result.\n+  static Handle externalize_classname(Symbol* java_name, TRAPS);\n@@ -1022,1 +1053,0 @@\n-  static int _addr_offset;  \/\/ type is jlong\n@@ -1036,1 +1066,0 @@\n-  static address    addr(oop entry);\n@@ -1052,1 +1081,0 @@\n-  static int addr_offset_in_bytes()            { return _addr_offset;            }\n@@ -1566,10 +1594,0 @@\n-class java_nio_Buffer: AllStatic {\n- private:\n-  static int _limit_offset;\n-\n- public:\n-  static int  limit_offset() { CHECK_INIT(_limit_offset); }\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-};\n-\n@@ -1748,0 +1766,1 @@\n+  STRING_INJECTED_FIELDS(macro)             \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -76,0 +77,26 @@\n+uint8_t* java_lang_String::flags_addr(oop java_string) {\n+  assert(_initialized, \"Must be initialized\");\n+  assert(is_instance(java_string), \"Must be java string\");\n+  return java_string->obj_field_addr<uint8_t>(_flags_offset);\n+}\n+\n+bool java_lang_String::is_flag_set(oop java_string, uint8_t flag_mask) {\n+  return (Atomic::load(flags_addr(java_string)) & flag_mask) != 0;\n+}\n+\n+bool java_lang_String::deduplication_forbidden(oop java_string) {\n+  return is_flag_set(java_string, _deduplication_forbidden_mask);\n+}\n+\n+bool java_lang_String::deduplication_requested(oop java_string) {\n+  return is_flag_set(java_string, _deduplication_requested_mask);\n+}\n+\n+void java_lang_String::set_deduplication_forbidden(oop java_string) {\n+  test_and_set_flag(java_string, _deduplication_forbidden_mask);\n+}\n+\n+bool java_lang_String::test_and_set_deduplication_requested(oop java_string) {\n+  return test_and_set_flag(java_string, _deduplication_requested_mask);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -676,1 +676,1 @@\n-  ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n+  ObjectLocker ol(lockObject, THREAD);\n@@ -739,1 +739,1 @@\n-        loaded_class = handle_parallel_loading(THREAD->as_Java_thread(),\n+        loaded_class = handle_parallel_loading(THREAD,\n@@ -879,1 +879,1 @@\n-\/\/ Handles Lookup.defineClass hidden and unsafe_DefineAnonymousClass.\n+\/\/ Handles Lookup.defineClass hidden.\n@@ -889,3 +889,0 @@\n-  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n-  \/\/ - for unsafe anonymous class: create a new CLD whith a class holder that uses\n-  \/\/                               the same class loader as the unsafe_anonymous_host.\n@@ -896,4 +893,2 @@\n-  assert (is_unsafe_anon_class || cl_info.is_hidden(), \"only used for hidden classes\");\n-  guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),\n-              \"should be NULL or the same\");\n-  bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();\n+  assert (cl_info.is_hidden(), \"only used for hidden classes\");\n+  bool create_mirror_cld = !cl_info.is_strong_hidden();\n@@ -913,4 +908,3 @@\n-  \/\/ Hidden classes that are not strong and unsafe anonymous classes must update\n-  \/\/ ClassLoaderData holder so that they can be unloaded when the mirror is no\n-  \/\/ longer referenced.\n-  if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {\n+  \/\/ Hidden classes that are not strong must update ClassLoaderData holder\n+  \/\/ so that they can be unloaded when the mirror is no longer referenced.\n+  if (!cl_info.is_strong_hidden()) {\n@@ -927,9 +921,0 @@\n-  \/\/ Rewrite and patch constant pool here.\n-  if (cl_info.cp_patches() != NULL) {\n-    k->constants()->patch_resolved_references(cl_info.cp_patches());\n-  }\n-\n-  \/\/ If it's anonymous, initialize it now, since nobody else will.\n-  if (is_unsafe_anon_class) {\n-    k->eager_initialize(CHECK_NULL);\n-  }\n@@ -940,1 +925,1 @@\n-    JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n+    JvmtiExport::post_class_load(THREAD, k);\n@@ -946,3 +931,0 @@\n-  assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),\n-         \"cp_patches only found with unsafe_anonymous_host\");\n-\n@@ -972,1 +954,1 @@\n-  ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n+  ObjectLocker ol(lockObject, THREAD);\n@@ -1026,2 +1008,1 @@\n-  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n-  if (cl_info.is_hidden() || is_unsafe_anon_class) {\n+  if (cl_info.is_hidden()) {\n@@ -1036,13 +1017,0 @@\n-\/\/ Load a class for boot loader from the shared spaces. This also\n-\/\/ forces the superclass and all interfaces to be loaded.\n-InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,\n-                                                        PackageEntry* pkg_entry,\n-                                                        TRAPS) {\n-  assert(UseSharedSpaces, \"Sanity check\");\n-  InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);\n-  if (ik != NULL && ik->is_shared_boot_class()) {\n-    return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);\n-  }\n-  return NULL;\n-}\n-\n@@ -1262,1 +1230,1 @@\n-  \/\/ CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).\n+  \/\/ CFLH check is skipped for VM hidden classes (see KlassFactory::create_from_stream).\n@@ -1289,1 +1257,1 @@\n-    ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n+    ObjectLocker ol(lockObject, THREAD);\n@@ -1394,1 +1362,5 @@\n-      k = load_shared_boot_class(class_name, pkg_entry, THREAD);\n+      InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);\n+      if (ik != NULL && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n+        SharedClassLoadingMark slm(THREAD, ik);\n+        k = load_shared_class(ik, class_loader, Handle(), NULL,  pkg_entry, CHECK_NULL);\n+      }\n@@ -1406,0 +1378,1 @@\n+      CDS_ONLY(SharedClassLoadingMark slm(THREAD, k);)\n@@ -1413,1 +1386,1 @@\n-    JavaThread* jt = THREAD->as_Java_thread();\n+    JavaThread* jt = THREAD;\n@@ -1422,2 +1395,1 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);\n-    Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle string = java_lang_String::externalize_classname(class_name, CHECK_NULL);\n@@ -1490,1 +1462,1 @@\n-      JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n+      JvmtiExport::post_class_load(THREAD, loaded_class);\n@@ -1516,1 +1488,1 @@\n-    assert(ObjectSynchronizer::current_thread_holds_lock(THREAD->as_Java_thread(),\n+    assert(ObjectSynchronizer::current_thread_holds_lock(THREAD,\n@@ -1563,1 +1535,1 @@\n-    JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n+    JvmtiExport::post_class_load(THREAD, k);\n@@ -1704,1 +1676,0 @@\n-\/\/ Note: anonymous classes are not in the SD.\n@@ -2012,2 +1983,5 @@\n-    if (entry != NULL) {\n-      assert(entry->nest_host_error() == NULL, \"Nest host error message already set!\");\n+    if (entry != NULL && entry->nest_host_error() == NULL) {\n+      \/\/ An existing entry means we had a true resolution failure (LinkageError) with our nest host, but we\n+      \/\/ still want to add the error message for the higher-level access checks to report. We should\n+      \/\/ only reach here under the same error condition, so we can ignore the potential race with setting\n+      \/\/ the message. If we see it is already set then we can ignore it.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":29,"deletions":55,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+  template(java_nio_Buffer,                           \"java\/nio\/Buffer\")                          \\\n@@ -352,1 +353,1 @@\n-  \/* Panama Support *\/                                                                                          \\\n+  \/* Foreign API Support *\/                                                                                          \\\n@@ -490,0 +491,1 @@\n+  template(checkIndex_name,                           \"checkIndex\")                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -555,1 +555,1 @@\n-      JavaThread* THREAD = current; \/\/ for exception macros\n+      JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -899,1 +899,1 @@\n-    Thread* THREAD = current;  \/\/ for exception macros\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -1078,1 +1078,1 @@\n-    Thread* THREAD = current;  \/\/ for exception macros\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -1118,2 +1118,2 @@\n-  \/\/ Get sender or sender's unsafe_anonymous_host, and only set cpCache entry to resolved if\n-  \/\/ it is not an interface.  The receiver for invokespecial calls within interface\n+  \/\/ Get sender and only set cpCache entry to resolved if it is not an\n+  \/\/ interface.  The receiver for invokespecial calls within interface\n@@ -1122,1 +1122,0 @@\n-  sender = sender->is_unsafe_anonymous() ? sender->unsafe_anonymous_host() : sender;\n@@ -1159,1 +1158,1 @@\n-    Thread* THREAD = current;  \/\/ for exception macros\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -1180,1 +1179,1 @@\n-    Thread* THREAD = current;  \/\/ for exception macros\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-  \/\/ Copy class version\n@@ -242,24 +241,1 @@\n-\/\/ Unsafe anonymous class support:\n-void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {\n-  assert(is_within_bounds(class_index), \"index out of bounds\");\n-  assert(is_within_bounds(name_index), \"index out of bounds\");\n-  assert((resolved_klass_index & 0xffff0000) == 0, \"must be\");\n-  *int_at_addr(class_index) =\n-    build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);\n-\n-  symbol_at_put(name_index, name);\n-  name->increment_refcount();\n-  Klass** adr = resolved_klasses()->adr_at(resolved_klass_index);\n-  Atomic::release_store(adr, k);\n-\n-  \/\/ The interpreter assumes when the tag is stored, the klass is resolved\n-  \/\/ and the Klass* non-NULL, so we need hardware store ordering here.\n-  jbyte qdesc_bit = (name->is_Q_signature()) ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n-  if (k != NULL) {\n-    release_tag_at_put(class_index, JVM_CONSTANT_Class | qdesc_bit);\n-  } else {\n-    release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n-  }\n-}\n-\n-\/\/ Unsafe anonymous class support:\n+\/\/ Hidden class support:\n@@ -336,1 +312,1 @@\n-    if (tag_at(index).is_string() && !cp->is_pseudo_string_at(index)) {\n+    if (tag_at(index).is_string()) {\n@@ -399,1 +375,1 @@\n-  if (!_pool_holder->is_linked() && _pool_holder->is_shared_old_klass()) {\n+  if (!_pool_holder->is_linked() && !_pool_holder->verified_at_dump_time()) {\n@@ -503,1 +479,1 @@\n-  JavaThread* javaThread = THREAD->as_Java_thread();\n+  JavaThread* javaThread = THREAD;\n@@ -643,1 +619,1 @@\n-    Thread *thread = Thread::current();\n+    Thread* current = Thread::current();\n@@ -647,2 +623,2 @@\n-    Handle h_prot (thread, protection_domain);\n-    Handle h_loader (thread, loader);\n+    Handle h_prot (current, protection_domain);\n+    Handle h_loader (current, loader);\n@@ -651,2 +627,2 @@\n-    \/\/ Avoid constant pool verification at a safepoint, which takes the Module_lock.\n-    if (k != NULL && !SafepointSynchronize::is_at_safepoint()) {\n+    \/\/ Avoid constant pool verification at a safepoint, as it takes the Module_lock.\n+    if (k != NULL && current->is_Java_thread()) {\n@@ -654,2 +630,2 @@\n-      ExceptionMark em(thread);\n-      Thread* THREAD = thread; \/\/ For exception macros.\n+      JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n+      ExceptionMark em(THREAD);\n@@ -1110,4 +1086,0 @@\n-    if (this_cp->is_pseudo_string_at(index)) {\n-      result_oop = this_cp->pseudo_string_at(index, cache_index);\n-      break;\n-    }\n@@ -2316,32 +2288,0 @@\n-\/\/ JSR 292 support for patching constant pool oops after the class is linked and\n-\/\/ the oop array for resolved references are created.\n-\/\/ We can't do this during classfile parsing, which is how the other indexes are\n-\/\/ patched.  The other patches are applied early for some error checking\n-\/\/ so only defer the pseudo_strings.\n-void ConstantPool::patch_resolved_references(GrowableArray<Handle>* cp_patches) {\n-  for (int index = 1; index < cp_patches->length(); index++) { \/\/ Index 0 is unused\n-    Handle patch = cp_patches->at(index);\n-    if (patch.not_null()) {\n-      assert (tag_at(index).is_string(), \"should only be string left\");\n-      \/\/ Patching a string means pre-resolving it.\n-      \/\/ The spelling in the constant pool is ignored.\n-      \/\/ The constant reference may be any object whatever.\n-      \/\/ If it is not a real interned string, the constant is referred\n-      \/\/ to as a \"pseudo-string\", and must be presented to the CP\n-      \/\/ explicitly, because it may require scavenging.\n-      int obj_index = cp_to_object_index(index);\n-      pseudo_string_at_put(index, obj_index, patch());\n-     DEBUG_ONLY(cp_patches->at_put(index, Handle());)\n-    }\n-  }\n-#ifdef ASSERT\n-  \/\/ Ensure that all the patches have been used.\n-  for (int index = 0; index < cp_patches->length(); index++) {\n-    assert(cp_patches->at(index).is_null(),\n-           \"Unused constant pool patch at %d in class file %s\",\n-           index,\n-           pool_holder()->external_name());\n-  }\n-#endif \/\/ ASSERT\n-}\n-\n@@ -2400,7 +2340,1 @@\n-      if (is_pseudo_string_at(index)) {\n-        oop anObj = pseudo_string_at(index);\n-        anObj->print_value_on(st);\n-        st->print(\" {\" PTR_FORMAT \"}\", p2i(anObj));\n-      } else {\n-        unresolved_string_at(index)->print_value_on(st);\n-      }\n+      unresolved_string_at(index)->print_value_on(st);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":12,"deletions":78,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-    Thread* THREAD = Thread::current();\n+    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -491,1 +491,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -738,1 +738,1 @@\n-  Thread* THREAD = Thread::current();\n+  Thread* current = Thread::current();\n@@ -743,1 +743,1 @@\n-    RawBytecodeStream bcs(methodHandle(THREAD, m));\n+    RawBytecodeStream bcs(methodHandle(current, m));\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -169,1 +170,1 @@\n-bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {\n+bool InstanceKlass::has_nest_member(JavaThread* current, InstanceKlass* k) const {\n@@ -173,1 +174,1 @@\n-      ResourceMark rm(THREAD);\n+      ResourceMark rm(current);\n@@ -181,1 +182,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -186,2 +187,2 @@\n-  \/\/ Check for a resolved cp entry , else fall back to a name check.\n-  \/\/ We don't want to resolve any class other than the one being checked.\n+  \/\/ Check for the named class in _nest_members.\n+  \/\/ We don't resolve, or load, any classes.\n@@ -190,33 +191,4 @@\n-    if (_constants->tag_at(cp_index).is_klass()) {\n-      Klass* k2 = _constants->klass_at(cp_index, THREAD);\n-      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass()),\n-             \"Exceptions should not be possible here\");\n-      if (k2 == k) {\n-        log_trace(class, nestmates)(\"- class is listed at nest_members[%d] => cp[%d]\", i, cp_index);\n-        return true;\n-      }\n-    }\n-    else {\n-      Symbol* name = _constants->klass_name_at(cp_index);\n-      if (name == k->name()) {\n-        log_trace(class, nestmates)(\"- Found it at nest_members[%d] => cp[%d]\", i, cp_index);\n-\n-        \/\/ Names match so check actual klass. This may trigger class loading if\n-        \/\/ it doesn't match though that should be impossible as it means one classloader\n-        \/\/ has defined two different classes with the same name! A compiler thread won't be\n-        \/\/ able to perform that loading but we can't exclude the compiler threads from\n-        \/\/ executing this logic. But it should actually be impossible to trigger loading here.\n-        Klass* k2 = _constants->klass_at(cp_index, THREAD);\n-        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass()),\n-               \"Exceptions should not be possible here\");\n-        if (k2 == k) {\n-          log_trace(class, nestmates)(\"- class is listed as a nest member\");\n-          return true;\n-        }\n-        else {\n-          \/\/ same name but different klass!\n-          log_trace(class, nestmates)(\" - klass comparison failed!\");\n-          \/\/ can't have two names the same, so we're done\n-          return false;\n-        }\n-      }\n+    Symbol* name = _constants->klass_name_at(cp_index);\n+    if (name == k->name()) {\n+      log_trace(class, nestmates)(\"- named class found at nest_members[%d] => cp[%d]\", i, cp_index);\n+      return true;\n@@ -231,1 +203,1 @@\n-  Thread* THREAD = Thread::current();\n+  Thread* current = Thread::current();\n@@ -237,1 +209,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -244,1 +216,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -251,1 +223,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -293,1 +265,2 @@\n-    if (!THREAD->can_call_java() && !_constants->tag_at(_nest_host_index).is_klass()) {\n+    bool can_resolve = THREAD->can_call_java();\n+    if (!can_resolve && !_constants->tag_at(_nest_host_index).is_klass()) {\n@@ -331,12 +304,7 @@\n-          bool is_member = nest_host_k->has_nest_member(this, THREAD);\n-          \/\/ exception is rare, perhaps impossible\n-          if (!HAS_PENDING_EXCEPTION) {\n-            if (is_member) {\n-              _nest_host = nest_host_k; \/\/ save resolved nest-host value\n-\n-              log_trace(class, nestmates)(\"Resolved nest-host of %s to %s\",\n-                                          this->external_name(), k->external_name());\n-              return nest_host_k;\n-            } else {\n-              error = \"current type is not listed as a nest member\";\n-            }\n+          bool is_member = nest_host_k->has_nest_member(THREAD, this);\n+          if (is_member) {\n+            _nest_host = nest_host_k; \/\/ save resolved nest-host value\n+\n+            log_trace(class, nestmates)(\"Resolved nest-host of %s to %s\",\n+                                        this->external_name(), k->external_name());\n+            return nest_host_k;\n@@ -344,7 +312,1 @@\n-            if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n-              return NULL; \/\/ propagate VMEs\n-            }\n-            stringStream ss;\n-            ss.print(\"exception on member check: \");\n-            java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n-            error = ss.as_string();\n+            error = \"current type is not listed as a nest member\";\n@@ -467,1 +429,0 @@\n-  bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();\n@@ -472,1 +433,0 @@\n-                                       parser.is_unsafe_anonymous(),\n@@ -584,1 +544,0 @@\n-  set_is_unsafe_anonymous(parser.is_unsafe_anonymous());\n@@ -858,1 +817,1 @@\n-  ObjectLocker ol(h_init_lock, THREAD->as_Java_thread());\n+  ObjectLocker ol(h_init_lock, THREAD);\n@@ -947,1 +906,1 @@\n-  JavaThread* jt = THREAD->as_Java_thread();\n+  JavaThread* jt = THREAD;\n@@ -1103,0 +1062,3 @@\n+      if (UseVtableBasedCHA) {\n+        MutexLocker ml(THREAD, Compile_lock);\n+        set_init_state(linked);\n@@ -1104,1 +1066,7 @@\n-      set_init_state(linked);\n+        \/\/ Now flush all code that assume the class is not linked.\n+        if (Universe::is_fully_initialized()) {\n+          CodeCache::flush_dependents_on(this);\n+        }\n+      } else {\n+        set_init_state(linked);\n+      }\n@@ -1106,1 +1074,1 @@\n-        JvmtiExport::post_class_prepare(THREAD->as_Java_thread(), this);\n+        JvmtiExport::post_class_prepare(THREAD, this);\n@@ -1170,1 +1138,1 @@\n-  JavaThread* jt = THREAD->as_Java_thread();\n+  JavaThread* jt = THREAD;\n@@ -1345,1 +1313,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD->as_Java_thread());\n+    ObjectLocker ol(h_init_lock, THREAD);\n@@ -1570,1 +1538,1 @@\n-    JavaThread *jt = THREAD->as_Java_thread();\n+    JavaThread *jt = THREAD;\n@@ -2548,1 +2516,5 @@\n-  it->push(&_default_vtable_indices);\n+  if (!is_rewritten()) {\n+    it->push(&_default_vtable_indices, MetaspaceClosure::_writable);\n+  } else {\n+    it->push(&_default_vtable_indices);\n+  }\n@@ -2582,3 +2554,3 @@\n-  if (MetaspaceShared::is_old_class(this)) {\n-    \/\/ Set the old class bit.\n-    set_is_shared_old_klass();\n+  if (can_be_verified_at_dumptime()) {\n+    \/\/ Remember this so we can avoid walking the hierarchy at runtime.\n+    set_verified_at_dump_time();\n@@ -2684,0 +2656,1 @@\n+  assert(!shared_loading_failed(), \"Must not try to load failed class again\");\n@@ -2733,0 +2706,22 @@\n+\/\/ Check if a class or any of its supertypes has a version older than 50.\n+\/\/ CDS will not perform verification of old classes during dump time because\n+\/\/ without changing the old verifier, the verification constraint cannot be\n+\/\/ retrieved during dump time.\n+\/\/ Verification of archived old classes will be performed during run time.\n+bool InstanceKlass::can_be_verified_at_dumptime() const {\n+  if (major_version() < 50 \/*JAVA_6_VERSION*\/) {\n+    return false;\n+  }\n+  if (java_super() != NULL && !java_super()->can_be_verified_at_dumptime()) {\n+    return false;\n+  }\n+  Array<InstanceKlass*>* interfaces = local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    if (!interfaces->at(i)->can_be_verified_at_dumptime()) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2884,7 +2879,0 @@\n-  \/\/ If this is an unsafe anonymous class, append a hash to make the name unique\n-  if (is_unsafe_anonymous()) {\n-    intptr_t hash = (java_mirror() != NULL) ? java_mirror()->identity_hash() : 0;\n-    jio_snprintf(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, (uintx)hash);\n-    hash_len = (int)strlen(hash_buf);\n-  }\n-\n@@ -2927,6 +2915,0 @@\n-  \/\/ For an unsafe anonymous class return the host class' module\n-  if (is_unsafe_anonymous()) {\n-    assert(unsafe_anonymous_host() != NULL, \"unsafe anonymous class must have a host class\");\n-    return unsafe_anonymous_host()->module();\n-  }\n-\n@@ -3038,3 +3020,3 @@\n-\/\/ Function set_classpath_index checks if the package of the InstanceKlass is in the\n-\/\/ boot loader's package entry table.  If so, then it sets the classpath_index\n-\/\/ in the package entry record.\n+\/\/ Function set_classpath_index ensures that for a non-null _package_entry\n+\/\/ of the InstanceKlass, the entry is in the boot loader's package entry table.\n+\/\/ It then sets the classpath_index in the package entry record.\n@@ -3201,1 +3183,1 @@\n-      \/\/ It may be a local or anonymous class; try for that.\n+      \/\/ It may be a local class; try for that.\n@@ -3493,2 +3475,0 @@\n-#ifndef PRODUCT\n-\n@@ -3600,1 +3580,0 @@\n-  st->print(BULLET\"unsafe anonymous host class:        \"); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st->cr();\n@@ -3669,2 +3648,0 @@\n-#endif \/\/PRODUCT\n-\n@@ -3677,2 +3654,0 @@\n-#ifndef PRODUCT\n-\n@@ -3736,0 +3711,2 @@\n+#ifndef PRODUCT\n+\n@@ -3837,5 +3814,4 @@\n-      Thread* THREAD = Thread::current();\n-      Klass* caller =\n-            THREAD->is_Java_thread()\n-                ? THREAD->as_Java_thread()->security_get_caller_class(1)\n-                : NULL;\n+      Thread* current = Thread::current();\n+      Klass* caller = current->is_Java_thread() ?\n+        current->as_Java_thread()->security_get_caller_class(1):\n+        NULL;\n@@ -4026,4 +4002,0 @@\n-  const Klass* anonymous_host = unsafe_anonymous_host();\n-  if (anonymous_host != NULL) {\n-    guarantee(anonymous_host->is_klass(), \"should be klass\");\n-  }\n@@ -4361,1 +4333,1 @@\n-  if (is_hidden() || unsafe_anonymous_host() != NULL) {\n+  if (is_hidden()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":82,"deletions":110,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-\/\/    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)\n@@ -84,1 +83,0 @@\n-#ifndef PRODUCT\n@@ -94,1 +92,0 @@\n-#endif  \/\/ !PRODUCT\n@@ -235,4 +232,3 @@\n-  int             _static_field_size;    \/\/ number words used by static fields (oop and non-oop) in this klass\n-\n-  int             _nonstatic_oop_map_size;\/\/ size in words of nonstatic oop map blocks\n-  int             _itable_len;           \/\/ length of Java itable (in words)\n+  int             _static_field_size;       \/\/ number words used by static fields (oop and non-oop) in this klass\n+  int             _nonstatic_oop_map_size;  \/\/ size in words of nonstatic oop map blocks\n+  int             _itable_len;              \/\/ length of Java itable (in words)\n@@ -243,4 +239,3 @@\n-  u2              _this_class_index;              \/\/ constant pool entry\n-\n-  u2              _static_oop_field_count;\/\/ number of static oop fields in this klass\n-  u2              _java_fields_count;    \/\/ The number of declared Java fields\n+  u2              _this_class_index;        \/\/ constant pool entry\n+  u2              _static_oop_field_count;  \/\/ number of static oop fields in this klass\n+  u2              _java_fields_count;       \/\/ The number of declared Java fields\n@@ -248,1 +243,1 @@\n-  volatile u2     _idnum_allocated_count;         \/\/ JNI\/JVMTI: increments with the addition of methods, old ids don't change\n+  volatile u2     _idnum_allocated_count;   \/\/ JNI\/JVMTI: increments with the addition of methods, old ids don't change\n@@ -252,1 +247,1 @@\n-  bool            _is_marked_dependent;  \/\/ used for marking during flushing and deoptimization\n+  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n@@ -257,1 +252,1 @@\n-  u1              _init_state;                    \/\/ state of class\n+  u1              _init_state;              \/\/ state of class\n@@ -274,1 +269,1 @@\n-    _misc_is_unsafe_anonymous                 = 1 << 3,  \/\/ has embedded _unsafe_anonymous_host field\n+    _misc_unused                              = 1 << 3,  \/\/ not currently used\n@@ -279,1 +274,1 @@\n-    _unused                                   = 1 << 8,  \/\/\n+    _misc_shared_loading_failed               = 1 << 8,  \/\/ class has been loaded from shared archive\n@@ -372,7 +367,0 @@\n-  \/\/ embedded unsafe_anonymous_host klass follows here\n-  \/\/   The embedded host klass only exists in an unsafe anonymous class for\n-  \/\/   dynamic language support (JSR 292 enabled). The host class grants\n-  \/\/   its access privileges to this class also. The host class is either\n-  \/\/   named, or a previously loaded unsafe anonymous class. A non-anonymous class\n-  \/\/   or an anonymous class loaded through normal classloading does not\n-  \/\/   have this embedded field.\n@@ -408,0 +396,12 @@\n+  bool shared_loading_failed() const {\n+    return (_misc_flags & _misc_shared_loading_failed) != 0;\n+  }\n+\n+  void set_shared_loading_failed() {\n+    _misc_flags |= _misc_shared_loading_failed;\n+  }\n+\n+  void clear_shared_loading_failed() {\n+    _misc_flags &= ~_misc_shared_loading_failed;\n+  }\n+\n@@ -597,2 +597,3 @@\n-  \/\/ Called to verify that k is a member of this nest - does not look at k's nest-host\n-  bool has_nest_member(InstanceKlass* k, TRAPS) const;\n+  \/\/ Called to verify that k is a member of this nest - does not look at k's nest-host,\n+  \/\/ nor does it resolve any CP entries or load any classes.\n+  bool has_nest_member(JavaThread* current, InstanceKlass* k) const;\n@@ -808,14 +809,0 @@\n-  \/\/ host class\n-  inline InstanceKlass* unsafe_anonymous_host() const;\n-  inline void set_unsafe_anonymous_host(const InstanceKlass* host);\n-  bool is_unsafe_anonymous() const                {\n-    return (_misc_flags & _misc_is_unsafe_anonymous) != 0;\n-  }\n-  void set_is_unsafe_anonymous(bool value)        {\n-    if (value) {\n-      _misc_flags |= _misc_is_unsafe_anonymous;\n-    } else {\n-      _misc_flags &= ~_misc_is_unsafe_anonymous;\n-    }\n-  }\n-\n@@ -1171,1 +1158,1 @@\n-                  bool is_interface, bool is_unsafe_anonymous,\n+                  bool is_interface,\n@@ -1178,1 +1165,0 @@\n-           (is_unsafe_anonymous ? (int)sizeof(Klass*)\/wordSize : 0) +\n@@ -1182,0 +1168,1 @@\n+\n@@ -1186,1 +1173,0 @@\n-                                               is_unsafe_anonymous(),\n@@ -1191,0 +1177,1 @@\n+\n@@ -1201,1 +1188,0 @@\n-  inline InstanceKlass** adr_unsafe_anonymous_host() const;\n@@ -1390,0 +1376,1 @@\n+  bool can_be_verified_at_dumptime() const;\n@@ -1401,2 +1388,0 @@\n-#ifndef PRODUCT\n-#endif\n@@ -1408,1 +1393,0 @@\n-#ifndef PRODUCT\n@@ -1411,0 +1395,1 @@\n+#ifndef PRODUCT\n@@ -1567,1 +1552,0 @@\n-    assert(!root->is_interface(), \"no subclasses\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":31,"deletions":47,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-    _is_shared_old_klass = 8\n+    _verified_at_dump_time = 8\n@@ -338,2 +338,2 @@\n-  void set_is_shared_old_klass() {\n-    CDS_ONLY(_shared_class_flags |= _is_shared_old_klass;)\n+  void set_verified_at_dump_time() {\n+    CDS_ONLY(_shared_class_flags |= _verified_at_dump_time;)\n@@ -341,2 +341,2 @@\n-  bool is_shared_old_klass() const {\n-    CDS_ONLY(return (_shared_class_flags & _is_shared_old_klass) != 0;)\n+  bool verified_at_dump_time() const {\n+    CDS_ONLY(return (_shared_class_flags & _verified_at_dump_time) != 0;)\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -359,2 +359,1 @@\n-  template <typename KlassProxy>\n-  inline bool must_be_preserved(KlassProxy klass) const;\n+  inline bool must_be_preserved(const oopDesc* obj) const;\n@@ -379,2 +378,1 @@\n-  template <typename KlassProxy>\n-  inline bool must_be_preserved_for_promotion_failure(KlassProxy klass) const;\n+  inline bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const;\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-#include \"oops\/klass.hpp\"\n+\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -33,2 +35,1 @@\n-template <typename KlassProxy>\n-inline bool markWord::must_be_preserved(KlassProxy klass) const {\n+inline bool markWord::must_be_preserved(const oopDesc* obj) const {\n@@ -41,1 +42,1 @@\n-    markWord prototype_header = prototype_for_klass(klass);\n+    markWord prototype_header = prototype_for_klass(obj->klass());\n@@ -52,2 +53,1 @@\n-template <typename KlassProxy>\n-inline bool markWord::must_be_preserved_for_promotion_failure(KlassProxy klass) const {\n+inline bool markWord::must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n@@ -64,1 +64,1 @@\n-    if (has_bias_pattern() || prototype_for_klass(klass).has_bias_pattern()) {\n+    if (has_bias_pattern() || prototype_for_klass(obj->klass()).has_bias_pattern()) {\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-  THREAD->as_Java_thread()->check_possible_safepoint();\n+  THREAD->check_possible_safepoint();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  Thread* THREAD = Thread::current();\n+  Thread* current = Thread::current();\n@@ -96,3 +96,3 @@\n-  HandleMark hm(THREAD);\n-  Handle object(THREAD, this);\n-  return ObjectSynchronizer::FastHashCode(THREAD, object());\n+  HandleMark hm(current);\n+  Handle object(current, this);\n+  return ObjectSynchronizer::FastHashCode(current, object());\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -275,1 +275,0 @@\n-  inline oop forwardee_acquire() const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"oops\/oop.hpp\"\n+\n@@ -34,1 +36,0 @@\n-#include \"oops\/oop.hpp\"\n@@ -322,7 +323,0 @@\n-\/\/ Note that the forwardee is not the same thing as the displaced_mark.\n-\/\/ The forwardee is used when copying during scavenge and mark-sweep.\n-\/\/ It does need to clear the low two locking- and GC-related bits.\n-oop oopDesc::forwardee_acquire() const {\n-  return cast_to_oop(Atomic::load_acquire(&_mark).decode_pointer());\n-}\n-\n@@ -414,13 +408,0 @@\n-\/\/ Supports deferred calling of obj->klass().\n-class DeferredObjectToKlass {\n-  const oopDesc* _obj;\n-\n-public:\n-  DeferredObjectToKlass(const oopDesc* obj) : _obj(obj) {}\n-\n-  \/\/ Implicitly convertible to const Klass*.\n-  operator const Klass*() const {\n-    return _obj->klass();\n-  }\n-};\n-\n@@ -432,6 +413,1 @@\n-  \/\/ There's a circular dependency between oop.inline.hpp and\n-  \/\/ markWord.inline.hpp because markWord::must_be_preserved wants to call\n-  \/\/ oopDesc::klass(). This could be solved by calling klass() here. However,\n-  \/\/ not all paths inside must_be_preserved calls klass(). Defer the call until\n-  \/\/ the klass is actually needed.\n-  return m.must_be_preserved(DeferredObjectToKlass(this));\n+  return m.must_be_preserved(this);\n@@ -441,1 +417,1 @@\n-  return m.must_be_preserved_for_promotion_failure(DeferredObjectToKlass(this));\n+  return m.must_be_preserved_for_promotion_failure(this);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":4,"deletions":28,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-    JavaThread *jt = THREAD->as_Java_thread();\n+    JavaThread *jt = THREAD;\n@@ -201,1 +201,1 @@\n-  THREAD->as_Java_thread()->check_possible_safepoint();\n+  THREAD->check_possible_safepoint();\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -441,2 +441,3 @@\n-  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, _input_not_const);\n-  assert(!_input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n+  bool input_not_const = true;\n+  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, input_not_const);\n+  assert(!input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n@@ -1193,0 +1194,1 @@\n+  address _call_addr;\n@@ -1195,2 +1197,2 @@\n-  NativeCallGenerator(ciMethod* m, ciNativeEntryPoint* nep)\n-   : CallGenerator(m), _nep(nep) {}\n+  NativeCallGenerator(ciMethod* m, address call_addr, ciNativeEntryPoint* nep)\n+   : CallGenerator(m), _call_addr(call_addr), _nep(nep) {}\n@@ -1204,1 +1206,1 @@\n-  Node* call = kit.make_native_call(tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n+  Node* call = kit.make_native_call(_call_addr, tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n@@ -1208,2 +1210,1 @@\n-  address addr = _nep->entry_point();\n-    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(addr));\n+    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(_call_addr));\n@@ -1334,2 +1335,4 @@\n-      Node* nep = kit.argument(callee->arg_size() - 1);\n-      if (nep->Opcode() == Op_ConP) {\n+      Node* addr_n = kit.argument(1); \/\/ target address\n+      Node* nep_n = kit.argument(callee->arg_size() - 1); \/\/ NativeEntryPoint\n+      \/\/ This check needs to be kept in sync with the one in CallStaticJavaNode::Ideal\n+      if (addr_n->Opcode() == Op_ConL && nep_n->Opcode() == Op_ConP) {\n@@ -1337,3 +1340,5 @@\n-        const TypeOopPtr* oop_ptr = nep->bottom_type()->is_oopptr();\n-        ciNativeEntryPoint* nep = oop_ptr->const_oop()->as_native_entry_point();\n-        return new NativeCallGenerator(callee, nep);\n+        const TypeLong* addr_t = addr_n->bottom_type()->is_long();\n+        const TypeOopPtr* nep_t = nep_n->bottom_type()->is_oopptr();\n+        address addr = (address) addr_t->get_con();\n+        ciNativeEntryPoint* nep = nep_t->const_oop()->as_native_entry_point();\n+        return new NativeCallGenerator(callee, addr, nep);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -445,0 +445,1 @@\n+  remove_useless_coarsened_locks(useful);            \/\/ remove useless coarsened locks nodes\n@@ -514,0 +515,6 @@\n+  if ((_do_locks_coarsening != EliminateLocks) && PrintOpto) {\n+    \/\/ Recompiling without locks coarsening\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without locks coarsening         **\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -541,1 +548,2 @@\n-                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, bool install_code, DirectiveSet* directive)\n+                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing,\n+                  bool do_locks_coarsening, bool install_code, DirectiveSet* directive)\n@@ -544,1 +552,0 @@\n-                  _save_argument_registers(false),\n@@ -549,0 +556,1 @@\n+                  _do_locks_coarsening(do_locks_coarsening),\n@@ -581,0 +589,1 @@\n+                  _coarsened_locks   (comp_arena(), 8, 0, NULL),\n@@ -841,1 +850,0 @@\n-                  bool save_arg_registers,\n@@ -846,1 +854,0 @@\n-    _save_argument_registers(save_arg_registers),\n@@ -851,0 +858,1 @@\n+    _do_locks_coarsening(false),\n@@ -1930,0 +1938,28 @@\n+        \/\/ Check if any users are blackholes. If so, rewrite them to use either the\n+        \/\/ allocated buffer, or individual components, instead of the inline type node\n+        \/\/ that goes away.\n+        for (DUIterator i = vt->outs(); vt->has_out(i); i++) {\n+          if (vt->out(i)->is_Blackhole()) {\n+            BlackholeNode* bh = vt->out(i)->as_Blackhole();\n+\n+            \/\/ Unlink the old input\n+            int idx = bh->find_edge(vt);\n+            assert(idx != -1, \"The edge should be there\");\n+            bh->del_req(idx);\n+            --i;\n+\n+            if (vt->is_allocated(&igvn)) {\n+              \/\/ Already has the allocated instance, blackhole that\n+              bh->add_req(vt->get_oop());\n+            } else {\n+              \/\/ Not allocated yet, blackhole the components\n+              for (uint c = 0; c < vt->field_count(); c++) {\n+                bh->add_req(vt->field_value(c));\n+              }\n+            }\n+\n+            \/\/ Node modified, record for IGVN\n+            igvn.record_for_igvn(bh);\n+          }\n+        }\n+\n@@ -3423,0 +3459,1 @@\n+  case Op_CallLeafVector:\n@@ -3600,2 +3637,0 @@\n-    \/\/ platform dependent reshaping of the address expression\n-    reshape_address(n->as_AddP());\n@@ -3882,0 +3917,1 @@\n+  case Op_VectorCmpMasked:\n@@ -4539,0 +4575,1 @@\n+  ciType* subelem = subk;\n@@ -4540,1 +4577,0 @@\n-    ciArrayKlass* ak = superelem->as_array_klass();\n@@ -4543,0 +4579,3 @@\n+  if (subelem->is_array_klass()) {\n+    subelem = subelem->as_array_klass()->base_element_type();\n+  }\n@@ -4549,0 +4588,1 @@\n+        !(subelem->is_klass() && subelem->as_klass()->is_interface()) &&\n@@ -4550,1 +4590,1 @@\n-      return SSC_always_false;\n+      return SSC_always_false;  \/\/ (2) true path dead; no dynamic test needed\n@@ -4929,0 +4969,95 @@\n+\/**\n+ * Track coarsened Lock and Unlock nodes.\n+ *\/\n+\n+class Lock_List : public Node_List {\n+  uint _origin_cnt;\n+public:\n+  Lock_List(Arena *a, uint cnt) : Node_List(a), _origin_cnt(cnt) {}\n+  uint origin_cnt() const { return _origin_cnt; }\n+};\n+\n+void Compile::add_coarsened_locks(GrowableArray<AbstractLockNode*>& locks) {\n+  int length = locks.length();\n+  if (length > 0) {\n+    \/\/ Have to keep this list until locks elimination during Macro nodes elimination.\n+    Lock_List* locks_list = new (comp_arena()) Lock_List(comp_arena(), length);\n+    for (int i = 0; i < length; i++) {\n+      AbstractLockNode* lock = locks.at(i);\n+      assert(lock->is_coarsened(), \"expecting only coarsened AbstractLock nodes, but got '%s'[%d] node\", lock->Name(), lock->_idx);\n+      locks_list->push(lock);\n+    }\n+    _coarsened_locks.append(locks_list);\n+  }\n+}\n+\n+void Compile::remove_useless_coarsened_locks(Unique_Node_List& useful) {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    Node_List* locks_list = _coarsened_locks.at(i);\n+    for (uint j = 0; j < locks_list->size(); j++) {\n+      Node* lock = locks_list->at(j);\n+      assert(lock->is_AbstractLock(), \"sanity\");\n+      if (!useful.member(lock)) {\n+        locks_list->yank(lock);\n+      }\n+    }\n+  }\n+}\n+\n+void Compile::remove_coarsened_lock(Node* n) {\n+  if (n->is_AbstractLock()) {\n+    int count = coarsened_count();\n+    for (int i = 0; i < count; i++) {\n+      Node_List* locks_list = _coarsened_locks.at(i);\n+      locks_list->yank(n);\n+    }\n+  }\n+}\n+\n+bool Compile::coarsened_locks_consistent() {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    bool unbalanced = false;\n+    bool modified = false; \/\/ track locks kind modifications\n+    Lock_List* locks_list = (Lock_List*)_coarsened_locks.at(i);\n+    uint size = locks_list->size();\n+    if (size != locks_list->origin_cnt()) {\n+      unbalanced = true; \/\/ Some locks were removed from list\n+    } else {\n+      for (uint j = 0; j < size; j++) {\n+        Node* lock = locks_list->at(j);\n+        \/\/ All nodes in group should have the same state (modified or not)\n+        if (!lock->as_AbstractLock()->is_coarsened()) {\n+          if (j == 0) {\n+            \/\/ first on list was modified, the rest should be too for consistency\n+            modified = true;\n+          } else if (!modified) {\n+            \/\/ this lock was modified but previous locks on the list were not\n+            unbalanced = true;\n+            break;\n+          }\n+        } else if (modified) {\n+          \/\/ previous locks on list were modified but not this lock\n+          unbalanced = true;\n+          break;\n+        }\n+      }\n+    }\n+    if (unbalanced) {\n+      \/\/ unbalanced monitor enter\/exit - only some [un]lock nodes were removed or modified\n+#ifdef ASSERT\n+      if (PrintEliminateLocks) {\n+        tty->print_cr(\"=== unbalanced coarsened locks ===\");\n+        for (uint l = 0; l < size; l++) {\n+          locks_list->at(l)->dump();\n+        }\n+      }\n+#endif\n+      record_failure(C2Compiler::retry_no_locks_coarsening());\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":143,"deletions":8,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -118,2 +118,0 @@\n-  \/\/ We do this before the strict f.p. check below because the\n-  \/\/ intrinsics handle strict f.p. correctly.\n@@ -156,6 +154,0 @@\n-  \/\/ If explicit rounding is required, do not inline strict into non-strict code (or the reverse).\n-  if (Matcher::strict_fp_requires_explicit_rounding &&\n-      caller->is_strict() != callee->is_strict()) {\n-    allow_inline = false;\n-  }\n-\n@@ -307,2 +299,1 @@\n-      if (singleton != NULL &&\n-          (!callee->is_default_method() || callee->is_overpass()) \/* CHA doesn't support default methods yet *\/) {\n+      if (singleton != NULL) {\n@@ -328,1 +319,1 @@\n-            dependencies()->assert_unique_concrete_method(declared_interface, cha_monomorphic_target);\n+            dependencies()->assert_unique_concrete_method(declared_interface, cha_monomorphic_target, declared_interface, callee);\n@@ -571,3 +562,1 @@\n-    ciInstanceKlass* sender_klass =\n-        calling_klass->is_unsafe_anonymous() ? calling_klass->unsafe_anonymous_host() :\n-                                               calling_klass;\n+    ciInstanceKlass* sender_klass = calling_klass;\n@@ -692,3 +681,0 @@\n-    \/\/ Round double result after a call from strict to non-strict code\n-    round_double_result(cg->method());\n-\n@@ -1090,1 +1076,1 @@\n-  ciMethod* optimized_virtual_method = optimize_inlining(caller, klass, callee,\n+  ciMethod* optimized_virtual_method = optimize_inlining(caller, klass, holder, callee,\n@@ -1105,1 +1091,1 @@\n-ciMethod* Compile::optimize_inlining(ciMethod* caller, ciInstanceKlass* klass,\n+ciMethod* Compile::optimize_inlining(ciMethod* caller, ciInstanceKlass* klass, ciKlass* holder,\n@@ -1118,0 +1104,4 @@\n+  if (receiver_type == NULL) {\n+    return NULL; \/\/ no receiver type info\n+  }\n+\n@@ -1121,8 +1111,7 @@\n-  if (receiver_type != NULL) {\n-    \/\/ Array methods are all inherited from Object, and are monomorphic.\n-    \/\/ finalize() call on array is not allowed.\n-    if (receiver_type->isa_aryptr() &&\n-        callee->holder() == env()->Object_klass() &&\n-        callee->name() != ciSymbols::finalize_method_name()) {\n-      return callee;\n-    }\n+  \/\/ Array methods are all inherited from Object, and are monomorphic.\n+  \/\/ finalize() call on array is not allowed.\n+  if (receiver_type->isa_aryptr() &&\n+      callee->holder() == env()->Object_klass() &&\n+      callee->name() != ciSymbols::finalize_method_name()) {\n+    return callee;\n+  }\n@@ -1130,4 +1119,4 @@\n-    \/\/ All other interesting cases are instance klasses.\n-    if (!receiver_type->isa_instptr()) {\n-      return NULL;\n-    }\n+  \/\/ All other interesting cases are instance klasses.\n+  if (!receiver_type->isa_instptr()) {\n+    return NULL;\n+  }\n@@ -1135,9 +1124,8 @@\n-    ciInstanceKlass *ikl = receiver_type->klass()->as_instance_klass();\n-    if (ikl->is_loaded() && ikl->is_initialized() && !ikl->is_interface() &&\n-        (ikl == actual_receiver || ikl->is_subtype_of(actual_receiver))) {\n-      \/\/ ikl is a same or better type than the original actual_receiver,\n-      \/\/ e.g. static receiver from bytecodes.\n-      actual_receiver = ikl;\n-      \/\/ Is the actual_receiver exact?\n-      actual_receiver_is_exact = receiver_type->klass_is_exact();\n-    }\n+  ciInstanceKlass *ikl = receiver_type->klass()->as_instance_klass();\n+  if (ikl->is_loaded() && ikl->is_initialized() && !ikl->is_interface() &&\n+      (ikl == actual_receiver || ikl->is_subtype_of(actual_receiver))) {\n+    \/\/ ikl is a same or better type than the original actual_receiver,\n+    \/\/ e.g. static receiver from bytecodes.\n+    actual_receiver = ikl;\n+    \/\/ Is the actual_receiver exact?\n+    actual_receiver_is_exact = receiver_type->klass_is_exact();\n@@ -1148,0 +1136,2 @@\n+\n+  \/\/ Validate receiver info against target method.\n@@ -1149,20 +1139,5 @@\n-    assert(!cha_monomorphic_target->is_abstract(), \"\");\n-    \/\/ Look at the method-receiver type.  Does it add \"too much information\"?\n-    ciKlass*    mr_klass = cha_monomorphic_target->holder();\n-    const Type* mr_type  = TypeInstPtr::make(TypePtr::BotPTR, mr_klass);\n-    if (receiver_type == NULL || !receiver_type->higher_equal(mr_type)) {\n-      \/\/ Calling this method would include an implicit cast to its holder.\n-      \/\/ %%% Not yet implemented.  Would throw minor asserts at present.\n-      \/\/ %%% The most common wins are already gained by +UseUniqueSubclasses.\n-      \/\/ To fix, put the higher_equal check at the call of this routine,\n-      \/\/ and add a CheckCastPP to the receiver.\n-      if (TraceDependencies) {\n-        tty->print_cr(\"found unique CHA method, but could not cast up\");\n-        tty->print(\"  method  = \");\n-        cha_monomorphic_target->print();\n-        tty->cr();\n-      }\n-      if (log() != NULL) {\n-        log()->elem(\"missed_CHA_opportunity klass='%d' method='%d'\",\n-                       log()->identify(klass),\n-                       log()->identify(cha_monomorphic_target));\n+    bool has_receiver = !cha_monomorphic_target->is_static();\n+    bool is_interface_holder = cha_monomorphic_target->holder()->is_interface();\n+    if (has_receiver && !is_interface_holder) {\n+      if (!cha_monomorphic_target->holder()->is_subtype_of(receiver_type->klass())) {\n+        cha_monomorphic_target = NULL; \/\/ not a subtype\n@@ -1170,1 +1145,0 @@\n-      cha_monomorphic_target = NULL;\n@@ -1184,1 +1158,1 @@\n-      dependencies()->assert_unique_concrete_method(actual_receiver, cha_monomorphic_target);\n+      dependencies()->assert_unique_concrete_method(actual_receiver, cha_monomorphic_target, holder, callee);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":36,"deletions":62,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2432,17 +2432,0 @@\n-void GraphKit::round_double_result(ciMethod* dest_method) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-    \/\/ If a strict caller invokes a non-strict callee, round a double result.\n-    \/\/ A non-strict method may return a double value which has an extended exponent,\n-    \/\/ but this must not be visible in a caller which is strict.\n-    BasicType result_type = dest_method->return_type()->basic_type();\n-    assert(method() != NULL, \"must have caller context\");\n-    if( result_type == T_DOUBLE && method()->is_strict() && !dest_method->is_strict() ) {\n-      \/\/ Destination method's return value is on top of stack\n-      \/\/ dstore_rounding() does gvn.transform\n-      Node *result = pop_pair();\n-      result = dstore_rounding(result);\n-      push_pair(result);\n-    }\n-  }\n-}\n-\n@@ -2471,1 +2454,1 @@\n-    if (_method->flags().is_strict() && UseSSE == 0) {\n+    if (UseSSE == 0) {\n@@ -2485,1 +2468,1 @@\n-    if (_method->flags().is_strict() && UseSSE < 2) {\n+    if (UseSSE < 2) {\n@@ -2617,0 +2600,3 @@\n+  } else  if (flags & RC_VECTOR){\n+    uint num_bits = call_type->range_sig()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n+    call = new CallLeafVectorNode(call_type, call_addr, call_name, adr_type, num_bits);\n@@ -2696,2 +2682,7 @@\n-Node* GraphKit::make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n-  uint n_filtered_args = nargs - 2; \/\/ -fallback, -nep;\n+Node* GraphKit::make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n+  \/\/ Select just the actual call args to pass on\n+  \/\/ [MethodHandle fallback, long addr, HALF addr, ... args , NativeEntryPoint nep]\n+  \/\/                                             |          |\n+  \/\/                                             V          V\n+  \/\/                                             [ ... args ]\n+  uint n_filtered_args = nargs - 4; \/\/ -fallback, -addr (2), -nep;\n@@ -2707,1 +2698,1 @@\n-      uint vm_unfiltered_arg_pos = vm_arg_pos + 1; \/\/ +1 to skip fallback handle argument\n+      uint vm_unfiltered_arg_pos = vm_arg_pos + 3; \/\/ +3 to skip fallback handle argument and addr (2 since long)\n@@ -2743,1 +2734,0 @@\n-  address call_addr = nep->entry_point();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -810,1 +810,0 @@\n-  void round_double_result(ciMethod* dest_method);\n@@ -835,1 +834,1 @@\n-  Node* make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n+  Node* make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n@@ -844,0 +843,1 @@\n+    RC_VECTOR = 64,             \/\/ CallLeafVectorNode\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1798,1 +1798,1 @@\n-      set_req(MemNode::Memory, opt_mem);\n+      set_req_X(MemNode::Memory, opt_mem, phase);\n@@ -1873,1 +1873,1 @@\n-      set_req(MemNode::Memory, prev_mem);\n+      set_req_X(MemNode::Memory, prev_mem, phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/type.hpp\"\n@@ -1258,0 +1259,36 @@\n+  \/\/ Narrow receiver type when it is too broad for the method being parsed.\n+  ciInstanceKlass* callee_holder = method()->holder();\n+  if (!method()->is_static()) {\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n+\n+    Node* receiver_obj = local(0);\n+    const TypeInstPtr* receiver_type = _gvn.type(receiver_obj)->isa_instptr();\n+\n+    if (receiver_type != NULL && !receiver_type->higher_equal(holder_type)) {\n+\n+#ifdef ASSERT\n+      \/\/ Perform dynamic receiver subtype check against callee holder class w\/ a halt on failure.\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n+      Node* not_subtype_ctrl = gen_subtype_check(receiver_obj, holder_klass);\n+      assert(!stopped(), \"not a subtype\");\n+\n+      Node* halt = _gvn.transform(new HaltNode(not_subtype_ctrl, frameptr(), \"failed receiver subtype check\"));\n+      C->root()->add_req(halt);\n+#endif \/\/ ASSERT\n+\n+      \/\/ Receiver should always be a subtype of callee holder.\n+      \/\/ But, since C2 type system doesn't properly track interfaces,\n+      \/\/ the invariant on default methods can't be expressed in the type system.\n+      \/\/ Example: for unrelated C <: I and D <: I, (C `meet` D) = Object <\/: I.\n+      \/\/ (Downcasting interface receiver type to concrete class is fine, though it doesn't happen in practice.)\n+      if (!callee_holder->is_interface()) {\n+        assert(callee_holder->is_subtype_of(receiver_type->klass()), \"sanity\");\n+        assert(!receiver_type->klass()->is_interface(), \"interface receiver type\");\n+        receiver_type = receiver_type->join_speculative(holder_type)->is_instptr(); \/\/ keep speculative part\n+        Node* casted_receiver_obj = _gvn.transform(new CheckCastPPNode(control(), receiver_obj, receiver_type));\n+        set_local(0, casted_receiver_obj);\n+      }\n+\n+    }\n+  }\n+\n@@ -1271,1 +1308,1 @@\n-    if(method()->is_static()) {\n+    if (method()->is_static()) {\n@@ -2456,1 +2493,1 @@\n-  if( OptoRemoveUseless && transformed_sfpnt->is_SafePoint() ) {\n+  if (transformed_sfpnt->is_SafePoint()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-        if (false && !bs->array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing)) {\n+        if (false && !bs->array_copy_requires_gc_barriers(false, T_OBJECT, false, false, BarrierSetC2::Parsing)) {\n@@ -628,11 +628,0 @@\n-\/\/ return Region node\n-Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {\n-  Node *region  = new RegionNode(3); \/\/ 2 results\n-  record_for_igvn(region);\n-  region->init_req(1, iffalse);\n-  region->init_req(2, iftrue );\n-  _gvn.set_type(region, Type::CONTROL);\n-  region = _gvn.transform(region);\n-  set_control (region);\n-  return region;\n-}\n@@ -895,1 +884,1 @@\n-  if (makes_backward_branch && UseLoopSafepoints) {\n+  if (makes_backward_branch) {\n@@ -989,1 +978,1 @@\n-  if (makes_backward_branch && UseLoopSafepoints) {\n+  if (makes_backward_branch) {\n@@ -1568,44 +1557,0 @@\n-void Parse::do_irem() {\n-  \/\/ Must keep both values on the expression-stack during null-check\n-  zero_check_int(peek());\n-  \/\/ Compile-time detect of null-exception?\n-  if (stopped())  return;\n-\n-  Node* b = pop();\n-  Node* a = pop();\n-\n-  const Type *t = _gvn.type(b);\n-  if (t != Type::TOP) {\n-    const TypeInt *ti = t->is_int();\n-    if (ti->is_con()) {\n-      int divisor = ti->get_con();\n-      \/\/ check for positive power of 2\n-      if (divisor > 0 &&\n-          (divisor & ~(divisor-1)) == divisor) {\n-        \/\/ yes !\n-        Node *mask = _gvn.intcon((divisor - 1));\n-        \/\/ Sigh, must handle negative dividends\n-        Node *zero = _gvn.intcon(0);\n-        IfNode *ifff = jump_if_fork_int(a, zero, BoolTest::lt, PROB_FAIR, COUNT_UNKNOWN);\n-        Node *iff = _gvn.transform( new IfFalseNode(ifff) );\n-        Node *ift = _gvn.transform( new IfTrueNode (ifff) );\n-        Node *reg = jump_if_join(ift, iff);\n-        Node *phi = PhiNode::make(reg, NULL, TypeInt::INT);\n-        \/\/ Negative path; negate\/and\/negate\n-        Node *neg = _gvn.transform( new SubINode(zero, a) );\n-        Node *andn= _gvn.transform( new AndINode(neg, mask) );\n-        Node *negn= _gvn.transform( new SubINode(zero, andn) );\n-        phi->init_req(1, negn);\n-        \/\/ Fast positive case\n-        Node *andx = _gvn.transform( new AndINode(a, mask) );\n-        phi->init_req(2, andx);\n-        \/\/ Push the merge\n-        push( _gvn.transform(phi) );\n-        return;\n-      }\n-    }\n-  }\n-  \/\/ Default case\n-  push( _gvn.transform( new ModINode(control(),a,b) ) );\n-}\n-\n@@ -2998,1 +2943,7 @@\n-    do_irem();\n+    \/\/ Must keep both values on the expression-stack during null-check\n+    zero_check_int(peek());\n+    \/\/ Compile-time detect of null-exception?\n+    if (stopped())  return;\n+    b = pop();\n+    a = pop();\n+    push(_gvn.transform(new ModINode(control(), a, b)));\n@@ -3357,2 +3308,1 @@\n-    if( UseLoopSafepoints ) {\n-      switch( iter().next_bc() ) {\n+    switch (iter().next_bc()) {\n@@ -3369,1 +3319,0 @@\n-      }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":11,"deletions":62,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -467,7 +467,0 @@\n-  \/\/ Not associative because of boundary conditions (infinity)\n-  if (IdealizedNumerics && !phase->C->method()->is_strict() &&\n-      in(2)->is_Add() && in(1) == in(2)->in(1)) {\n-    \/\/ Convert \"x - (x+y)\" into \"-y\"\n-    return new SubFNode(phase->makecon(TypeF::ZERO), in(2)->in(2));\n-  }\n-\n@@ -509,7 +502,0 @@\n-  \/\/ Not associative because of boundary conditions (infinity)\n-  if (IdealizedNumerics && !phase->C->method()->is_strict() &&\n-      in(2)->is_Add() && in(1) == in(2)->in(1)) {\n-    \/\/ Convert \"x - (x+y)\" into \"-y\"\n-    return new SubDNode(phase->makecon(TypeD::ZERO), in(2)->in(2));\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-Node *SubTypeCheckNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node *SubTypeCheckNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -151,8 +151,1 @@\n-#ifdef ASSERT\n-      const Type* obj_t = phase->type(obj);\n-      if (!obj_t->isa_oopptr() && obj_t != Type::TOP) {\n-        obj->dump();\n-        obj_t->dump(); tty->cr();\n-        fatal(\"only for oop input\");\n-      }\n-#endif\n+      assert(is_oop(phase, obj), \"only for oop input\");\n@@ -167,8 +160,1 @@\n-#ifdef ASSERT\n-      const Type* obj_or_subklass_t = phase->type(obj_or_subklass);\n-      if (!obj_or_subklass_t->isa_oopptr() && obj_or_subklass_t != Type::TOP) {\n-        obj_or_subklass->dump();\n-        obj_or_subklass_t->dump(); tty->cr();\n-        fatal(\"only for oop input\");\n-      }\n-#endif\n+    assert(is_oop(phase, obj_or_subklass), \"only for oop input\");\n@@ -181,3 +167,1 @@\n-#ifdef ASSERT\n-  ciKlass* superk = super_t->is_klassptr()->klass();\n-  ciKlass* subk   = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass();\n+  assert(verify(phase), \"missing Value() optimization\");\n@@ -185,13 +169,8 @@\n-  if (super_t->singleton() && subk != NULL && phase->C->static_subtype_check(superk, subk) == Compile::SSC_easy_test) {\n-    Node* subklass = NULL;\n-    if (sub_t->isa_oopptr()) {\n-      Node* adr = phase->transform(new AddPNode(obj_or_subklass, obj_or_subklass, phase->MakeConX(oopDesc::klass_offset_in_bytes())));\n-      subklass = phase->transform(LoadKlassNode::make(*phase, NULL, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n-    } else {\n-      subklass = obj_or_subklass;\n-    }\n-    Node* res = new CmpPNode(subklass, superklass);\n-    Node* cmp = phase->transform(res);\n-    const Type* t = phase->type(cmp);\n-    if (!((Value(phase) == t) || (t != TypeInt::CC_GT && t != TypeInt::CC_EQ))) {\n-      Value(phase)->dump(); tty->cr();\n+  return NULL;\n+}\n+\n+#ifdef ASSERT\n+bool SubTypeCheckNode::is_oop(PhaseGVN* phase, Node* n) {\n+    const Type* t = phase->type(n);\n+    if (!t->isa_oopptr() && t != Type::TOP) {\n+      n->dump();\n@@ -199,10 +178,1 @@\n-      obj_or_subklass->dump();\n-      subklass->dump();\n-      superklass->dump();\n-      cmp->dump();\n-      tty->print_cr(\"==============================\");\n-      phase->C->root()->dump(9999);\n-      fatal(\"missing Value() optimization\");\n-    }\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(res);\n+      return false;\n@@ -210,1 +180,6 @@\n-    return NULL;\n+    return true;\n+}\n+\n+static Node* record_for_cleanup(Node* n, PhaseGVN* phase) {\n+  if (phase->is_IterGVN()) {\n+    phase->is_IterGVN()->_worklist.push(n); \/\/ record for cleanup\n@@ -212,0 +187,5 @@\n+  return n;\n+}\n+bool SubTypeCheckNode::verify_helper(PhaseGVN* phase, Node* subklass, const Type* cached_t) {\n+  Node* cmp = phase->transform(new CmpPNode(subklass, in(SuperKlass)));\n+  record_for_cleanup(cmp, phase);\n@@ -213,6 +193,2 @@\n-  Node *p1 = phase->transform(new AddPNode(superklass, superklass, phase->MakeConX(in_bytes(Klass::super_check_offset_offset()))));\n-  Node* m = phase->C->immutable_memory();\n-  LoadINode* chk_off_ld = new LoadINode(NULL, m, p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered);\n-  Node *chk_off = phase->transform(chk_off_ld);\n-  int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());\n-  bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+  const Type* cmp_t = phase->type(cmp);\n+  const Type* t = Value(phase);\n@@ -220,5 +196,12 @@\n-  if (might_be_cache) {\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(chk_off_ld);\n-    }\n-    return NULL;\n+  if (t == cmp_t ||\n+      t != cached_t || \/\/ previous observations don't hold anymore\n+      (cmp_t != TypeInt::CC_GT && cmp_t != TypeInt::CC_EQ)) {\n+    return true;\n+  } else {\n+    t->dump(); tty->cr();\n+    this->dump(2); tty->cr();\n+    cmp_t->dump(); tty->cr();\n+    subklass->dump(2); tty->cr();\n+    tty->print_cr(\"==============================\");\n+    phase->C->root()->dump(9999);\n+    return false;\n@@ -226,0 +209,7 @@\n+}\n+\n+\/\/ Verify that optimizing the subtype check to a simple code pattern when possible would not constant fold better.\n+bool SubTypeCheckNode::verify(PhaseGVN* phase) {\n+  Compile* C = phase->C;\n+  Node* obj_or_subklass = in(ObjOrSubKlass);\n+  Node* superklass = in(SuperKlass);\n@@ -227,1 +217,7 @@\n-  if (super_t->singleton() && subk != NULL && phase->C->static_subtype_check(superk, subk) == Compile::SSC_full_test) {\n+  const Type* sub_t = phase->type(obj_or_subklass);\n+  const Type* super_t = phase->type(superklass);\n+\n+  ciKlass* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass(); \/\/ can be NULL for bottom[]\n+  ciKlass* superk = super_t->is_klassptr()->klass();\n+\n+  if (super_t->singleton() && subk != NULL) {\n@@ -231,1 +227,2 @@\n-      subklass = phase->transform(LoadKlassNode::make(*phase, NULL, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+      subklass  = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+      record_for_cleanup(subklass, phase);\n@@ -236,1 +233,14 @@\n-    Node *chk_off_X = chk_off;\n+    const Type* cached_t = Value(phase); \/\/ cache the type to validate consistency\n+    switch (C->static_subtype_check(superk, subk)) {\n+      case Compile::SSC_easy_test: {\n+        return verify_helper(phase, subklass, cached_t);\n+      }\n+      case Compile::SSC_full_test: {\n+        Node* p1 = phase->transform(new AddPNode(superklass, superklass, phase->MakeConX(in_bytes(Klass::super_check_offset_offset()))));\n+        Node* chk_off = phase->transform(new LoadINode(NULL, C->immutable_memory(), p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n+        record_for_cleanup(chk_off, phase);\n+\n+        int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());\n+        bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+        if (!might_be_cache) {\n+          Node* chk_off_X = chk_off;\n@@ -238,1 +248,1 @@\n-    chk_off_X = phase->transform(new ConvI2LNode(chk_off_X));\n+          chk_off_X = phase->transform(new ConvI2LNode(chk_off_X));\n@@ -240,3 +250,2 @@\n-    Node *p2 = phase->transform(new AddPNode(subklass,subklass,chk_off_X));\n-    Node *kmem = phase->C->immutable_memory();\n-    Node *nkls = phase->transform(LoadKlassNode::make(*phase, NULL, kmem, p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n+          Node* p2 = phase->transform(new AddPNode(subklass, subklass, chk_off_X));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n@@ -244,17 +253,9 @@\n-    Node* res = new CmpPNode(superklass, nkls);\n-    Node* cmp = phase->transform(res);\n-    const Type* t = phase->type(cmp);\n-    if (!((Value(phase) == t) || (t != TypeInt::CC_GT && t != TypeInt::CC_EQ))) {\n-      Value(phase)->dump(); tty->cr();\n-      t->dump(); tty->cr();\n-      obj_or_subklass->dump();\n-      subklass->dump();\n-      superklass->dump();\n-      nkls->dump();\n-      cmp->dump();\n-      tty->print_cr(\"==============================\");\n-      phase->C->root()->dump(9999);\n-      fatal(\"missing Value() optimization\");\n-    }\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(res);\n+          return verify_helper(phase, nkls, cached_t);\n+        }\n+        break;\n+      }\n+      case Compile::SSC_always_false:\n+      case Compile::SSC_always_true:\n+      default: {\n+        break; \/\/ nothing to do\n+      }\n@@ -262,3 +263,1 @@\n-    return NULL;\n-#endif\n-  return NULL;\n+  return true;\n@@ -268,0 +267,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":82,"deletions":82,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -1171,0 +1171,1 @@\n+    case Type::VectorMask:\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3725,1 +3725,1 @@\n-          JavaThread* THREAD = thread;\n+          JavaThread* THREAD = thread; \/\/ For exception macros.\n@@ -3766,1 +3766,1 @@\n-      JavaThread* THREAD = JavaThread::current();\n+      JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  JavaThread* jthread = THREAD->as_Java_thread();\n+  JavaThread* jthread = THREAD;\n@@ -425,0 +425,1 @@\n+#if INCLUDE_CDS\n@@ -427,1 +428,1 @@\n-    MetaspaceShared::link_and_cleanup_shared_classes(THREAD);\n+    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n@@ -429,0 +430,1 @@\n+#endif\n@@ -445,0 +447,2 @@\n+    EventSystemGC event;\n+    event.set_invokedConcurrent(ExplicitGCInvokesConcurrent);\n@@ -446,0 +450,1 @@\n+    event.commit();\n@@ -865,1 +870,1 @@\n-  JavaThread* jt = THREAD->as_Java_thread();\n+  JavaThread* jt = THREAD;\n@@ -986,2 +991,0 @@\n-                          NULL, \/\/ unsafe_anonymous_host\n-                          NULL, \/\/ cp_patches\n@@ -1469,1 +1472,1 @@\n-  if (!inner_is_member)  return NULL;     \/\/ a hidden or unsafe anonymous class (inside a method)\n+  if (!inner_is_member)  return NULL;     \/\/ a hidden class (inside a method)\n@@ -3027,1 +3030,1 @@\n-      Thread::send_async_exception(java_thread, java_throwable);\n+      JavaThread::send_async_exception(java_thread, java_throwable);\n@@ -3592,5 +3595,5 @@\n-                                              jstring invokedName,\n-                                              jobject invokedType,\n-                                              jobject methodType,\n-                                              jobject implMethodMember,\n-                                              jobject instantiatedMethodType,\n+                                              jstring interfaceMethodName,\n+                                              jobject factoryType,\n+                                              jobject interfaceMethodType,\n+                                              jobject implementationMember,\n+                                              jobject dynamicMethodType,\n@@ -3605,2 +3608,2 @@\n-  if (caller_ik->is_hidden() || caller_ik->is_unsafe_anonymous()) {\n-    \/\/ VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.\n+  if (caller_ik->is_hidden()) {\n+    \/\/ Hidden classes not of type lambda proxy classes are currently not being archived.\n@@ -3616,3 +3619,3 @@\n-  Symbol* invoked_name = NULL;\n-  if (invokedName != NULL) {\n-    invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));\n+  Symbol* interface_method_name = NULL;\n+  if (interfaceMethodName != NULL) {\n+    interface_method_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(interfaceMethodName));\n@@ -3620,2 +3623,2 @@\n-  Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));\n-  Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);\n+  Handle factory_type_oop(THREAD, JNIHandles::resolve_non_null(factoryType));\n+  Symbol* factory_type = java_lang_invoke_MethodType::as_signature(factory_type_oop(), true);\n@@ -3623,2 +3626,2 @@\n-  Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));\n-  Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);\n+  Handle interface_method_type_oop(THREAD, JNIHandles::resolve_non_null(interfaceMethodType));\n+  Symbol* interface_method_type = java_lang_invoke_MethodType::as_signature(interface_method_type_oop(), true);\n@@ -3626,3 +3629,3 @@\n-  Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));\n-  assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), \"must be\");\n-  Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());\n+  Handle implementation_member_oop(THREAD, JNIHandles::resolve_non_null(implementationMember));\n+  assert(java_lang_invoke_MemberName::is_method(implementation_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(implementation_member_oop());\n@@ -3630,2 +3633,2 @@\n-  Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));\n-  Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);\n+  Handle dynamic_method_type_oop(THREAD, JNIHandles::resolve_non_null(dynamicMethodType));\n+  Symbol* dynamic_method_type = java_lang_invoke_MethodType::as_signature(dynamic_method_type_oop(), true);\n@@ -3633,2 +3636,2 @@\n-  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,\n-                                                 method_type, m, instantiated_method_type, THREAD);\n+  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n+                                                 interface_method_type, m, dynamic_method_type, THREAD);\n@@ -3640,5 +3643,5 @@\n-                                                        jstring invokedName,\n-                                                        jobject invokedType,\n-                                                        jobject methodType,\n-                                                        jobject implMethodMember,\n-                                                        jobject instantiatedMethodType))\n+                                                        jstring interfaceMethodName,\n+                                                        jobject factoryType,\n+                                                        jobject interfaceMethodType,\n+                                                        jobject implementationMember,\n+                                                        jobject dynamicMethodType))\n@@ -3647,2 +3650,2 @@\n-  if (invokedName == NULL || invokedType == NULL || methodType == NULL ||\n-      implMethodMember == NULL || instantiatedMethodType == NULL) {\n+  if (interfaceMethodName == NULL || factoryType == NULL || interfaceMethodType == NULL ||\n+      implementationMember == NULL || dynamicMethodType == NULL) {\n@@ -3659,3 +3662,3 @@\n-  Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));\n-  Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));\n-  Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);\n+  Symbol* interface_method_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(interfaceMethodName));\n+  Handle factory_type_oop(THREAD, JNIHandles::resolve_non_null(factoryType));\n+  Symbol* factory_type = java_lang_invoke_MethodType::as_signature(factory_type_oop(), true);\n@@ -3663,2 +3666,2 @@\n-  Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));\n-  Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);\n+  Handle interface_method_type_oop(THREAD, JNIHandles::resolve_non_null(interfaceMethodType));\n+  Symbol* interface_method_type = java_lang_invoke_MethodType::as_signature(interface_method_type_oop(), true);\n@@ -3666,3 +3669,3 @@\n-  Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));\n-  assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), \"must be\");\n-  Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());\n+  Handle implementation_member_oop(THREAD, JNIHandles::resolve_non_null(implementationMember));\n+  assert(java_lang_invoke_MemberName::is_method(implementation_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(implementation_member_oop());\n@@ -3670,2 +3673,2 @@\n-  Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));\n-  Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);\n+  Handle dynamic_method_type_oop(THREAD, JNIHandles::resolve_non_null(dynamicMethodType));\n+  Symbol* dynamic_method_type = java_lang_invoke_MethodType::as_signature(dynamic_method_type_oop(), true);\n@@ -3673,2 +3676,2 @@\n-  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,\n-                                                                                   method_type, m, instantiated_method_type);\n+  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n+                                                                                   interface_method_type, m, dynamic_method_type);\n@@ -3758,1 +3761,1 @@\n-  DynamicArchive::dump(archive_name, THREAD);\n+  DynamicArchive::dump(archive_name, CHECK);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":51,"deletions":48,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-      Thread* THREAD = thread;\n+      JavaThread* THREAD = thread; \/\/ For exception macros.\n@@ -1889,1 +1889,1 @@\n-  Thread* THREAD = thread;\n+  JavaThread* THREAD = thread; \/\/ For exception macros.\n@@ -1927,1 +1927,1 @@\n-      JavaThread* jt = THREAD->as_Java_thread();\n+      JavaThread* jt = THREAD;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,15 +408,0 @@\n-static bool under_unsafe_anonymous_host(const InstanceKlass* ik, const InstanceKlass* unsafe_anonymous_host) {\n-  DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);\n-  for (;;) {\n-    const InstanceKlass* hc = ik->unsafe_anonymous_host();\n-    if (hc == NULL)        return false;\n-    if (hc == unsafe_anonymous_host)  return true;\n-    ik = hc;\n-\n-    \/\/ There's no way to make a host class loop short of patching memory.\n-    \/\/ Therefore there cannot be a loop here unless there's another bug.\n-    \/\/ Still, let's check for it.\n-    assert(--inf_loop_check > 0, \"no unsafe_anonymous_host loop\");\n-  }\n-}\n-\n@@ -430,6 +415,0 @@\n-  \/\/ If either is on the other's unsafe_anonymous_host chain, access is OK,\n-  \/\/ because one is inside the other.\n-  if (under_unsafe_anonymous_host(accessor_ik, accessee_ik) ||\n-    under_unsafe_anonymous_host(accessee_ik, accessor_ik))\n-    return true;\n-\n@@ -658,10 +637,1 @@\n-  const Klass* host_class = current_class;\n-  if (current_class->is_instance_klass() &&\n-      InstanceKlass::cast(current_class)->is_unsafe_anonymous()) {\n-    host_class = InstanceKlass::cast(current_class)->unsafe_anonymous_host();\n-    assert(host_class != NULL, \"Unsafe anonymous class has null host class\");\n-    assert(!(host_class->is_instance_klass() &&\n-           InstanceKlass::cast(host_class)->is_unsafe_anonymous()),\n-           \"unsafe_anonymous_host should not be unsafe anonymous itself\");\n-  }\n-  if (host_class == member_class) {\n+  if (current_class == member_class) {\n@@ -675,1 +645,1 @@\n-      if (!host_class->is_interface() && host_class->is_subclass_of(member_class)) {\n+      if (!current_class->is_interface() && current_class->is_subclass_of(member_class)) {\n@@ -679,2 +649,2 @@\n-            host_class->is_subclass_of(resolved_class) ||\n-            resolved_class->is_subclass_of(host_class)) {\n+            current_class->is_subclass_of(resolved_class) ||\n+            resolved_class->is_subclass_of(current_class)) {\n@@ -692,3 +662,2 @@\n-  \/\/ private access between different classes needs a nestmate check, but\n-  \/\/ not for unsafe anonymous classes - so check host_class\n-  if (access.is_private() && host_class == current_class) {\n+  \/\/ private access between different classes needs a nestmate check.\n+  if (access.is_private()) {\n@@ -725,1 +694,1 @@\n-\/\/ If !inner_is_member, require the inner to be hidden or unsafe anonymous (non-members).\n+\/\/ If !inner_is_member, require the inner to be hidden (non-member).\n@@ -805,1 +774,0 @@\n-\n@@ -1048,3 +1016,1 @@\n-          if (THREAD->is_Java_thread()) {\n-            JvmtiExport::clear_detected_exception(THREAD->as_Java_thread());\n-          }\n+          JvmtiExport::clear_detected_exception(THREAD);\n@@ -1162,3 +1128,1 @@\n-    if (THREAD->is_Java_thread()) {\n-      JvmtiExport::clear_detected_exception(THREAD->as_Java_thread());\n-    }\n+    JvmtiExport::clear_detected_exception(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":9,"deletions":45,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -392,1 +392,1 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* THREAD = Thread::current()->as_Java_thread();\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -527,0 +528,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -704,0 +706,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1009,0 +1012,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -1472,0 +1476,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1628,0 +1633,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1675,0 +1681,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1729,0 +1736,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1842,1 +1850,6 @@\n-            return enclosingName + \".\" + getSimpleName();\n+            String simpleName = getSimpleName();\n+            return new StringBuilder(enclosingName.length() + simpleName.length() + 1)\n+                    .append(enclosingName)\n+                    .append('.')\n+                    .append(simpleName)\n+                    .toString();\n@@ -1955,0 +1968,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -2026,0 +2040,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2116,0 +2131,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2156,0 +2172,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2210,0 +2227,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2319,0 +2337,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2363,0 +2382,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2410,0 +2430,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2462,0 +2483,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2523,0 +2545,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2593,0 +2616,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2643,0 +2667,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2695,0 +2720,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2759,0 +2785,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2837,0 +2864,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -3083,0 +3111,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -3128,1 +3157,1 @@\n-    private void checkMemberAccess(SecurityManager sm, int which,\n+    private void checkMemberAccess(@SuppressWarnings(\"removal\") SecurityManager sm, int which,\n@@ -3152,1 +3181,1 @@\n-    private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,\n+    private void checkPackageAccess(@SuppressWarnings(\"removal\") SecurityManager sm, final ClassLoader ccl,\n@@ -3158,1 +3187,1 @@\n-            if (pkg != null && !pkg.isEmpty()) {\n+            if (!pkg.isEmpty()) {\n@@ -3181,1 +3210,1 @@\n-    private static void checkPackageAccessForPermittedSubclasses(SecurityManager sm,\n+    private static void checkPackageAccessForPermittedSubclasses(@SuppressWarnings(\"removal\") SecurityManager sm,\n@@ -3192,1 +3221,1 @@\n-                if (pkg != null && !pkg.isEmpty()) {\n+                if (!pkg.isEmpty()) {\n@@ -3209,1 +3238,1 @@\n-            if (baseName != null && !baseName.isEmpty()) {\n+            if (!baseName.isEmpty()) {\n@@ -3877,0 +3906,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -3909,0 +3939,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -4324,0 +4355,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -4416,0 +4448,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -4488,1 +4521,1 @@\n-        String typeDesc = isValueType()  ? \"Q\" : \"L\";\n+        char typeDesc = isPrimitiveClass() ? 'Q' : 'L';\n@@ -4492,2 +4525,7 @@\n-            return typeDesc + name.substring(0, index).replace('.', '\/')\n-                       + \".\" + name.substring(index+1) + \";\";\n+            return new StringBuilder(name.length() + 2)\n+                    .append(typeDesc)\n+                    .append(name.substring(0, index).replace('.', '\/'))\n+                    .append('.')\n+                    .append(name, index + 1, name.length())\n+                    .append(';')\n+                    .toString();\n@@ -4495,1 +4533,6 @@\n-            return typeDesc + getName().replace('.', '\/') + \";\";\n+            String name = getName().replace('.', '\/');\n+            return new StringBuilder(name.length() + 2)\n+                    .append(typeDesc)\n+                    .append(name)\n+                    .append(';')\n+                    .toString();\n@@ -4587,1 +4630,1 @@\n-     * @since 15\n+     * @since 17\n@@ -4589,1 +4632,0 @@\n-    @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.SEALED_CLASSES, reflective=true)\n@@ -4605,0 +4647,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -4636,1 +4679,2 @@\n-     * @return {@code true} if and only if this {@code Class} object represents a sealed class or interface.\n+     * @return {@code true} if and only if this {@code Class} object represents\n+     * a sealed class or interface.\n@@ -4640,1 +4684,1 @@\n-     * @since 15\n+     * @since 17\n@@ -4642,2 +4686,0 @@\n-    @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.SEALED_CLASSES, reflective=true)\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":59,"deletions":17,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,6 +56,6 @@\n-    final MethodType invokedType;             \/\/ The type of the invoked method \"(CC)II\"\n-    final Class<?> samBase;                   \/\/ The type of the returned instance \"interface JJ\"\n-    final String samMethodName;               \/\/ Name of the SAM method \"foo\"\n-    final MethodType samMethodType;           \/\/ Type of the SAM method \"(Object)Object\"\n-    final MethodHandle implMethod;            \/\/ Raw method handle for the implementation method\n-    final MethodType implMethodType;          \/\/ Type of the implMethod MethodHandle \"(CC,int)String\"\n+    final MethodType factoryType;             \/\/ The type of the invoked method \"(CC)II\"\n+    final Class<?> interfaceClass;            \/\/ The type of the returned instance \"interface JJ\"\n+    final String interfaceMethodName;         \/\/ Name of the method to implement \"foo\"\n+    final MethodType interfaceMethodType;     \/\/ Type of the method to implement \"(Object)Object\"\n+    final MethodHandle implementation;        \/\/ Raw method handle for the implementation method\n+    final MethodType implMethodType;          \/\/ Type of the implementation MethodHandle \"(CC,int)String\"\n@@ -66,1 +66,1 @@\n-    final MethodType instantiatedMethodType;  \/\/ Instantiated erased functional interface method type \"(Integer)Object\"\n+    final MethodType dynamicMethodType;       \/\/ Dynamically checked method type \"(Integer)Object\"\n@@ -68,2 +68,2 @@\n-    final Class<?>[] markerInterfaces;        \/\/ Additional marker interfaces to be implemented\n-    final MethodType[] additionalBridges;     \/\/ Signatures of additional methods to bridge\n+    final Class<?>[] altInterfaces;           \/\/ Additional interfaces to be implemented\n+    final MethodType[] altMethods;            \/\/ Signatures of additional methods to bridge\n@@ -77,1 +77,1 @@\n-     * @param invokedType Stacked automatically by VM; the signature of the\n+     * @param factoryType Stacked automatically by VM; the signature of the\n@@ -84,15 +84,15 @@\n-     * @param samMethodName Name of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a String.\n-     * @param samMethodType Type of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a MethodType.\n-     * @param implMethod The implementation method which should be called\n-     *                   (with suitable adaptation of argument types, return\n-     *                   types, and adjustment for captured arguments) when\n-     *                   methods of the resulting functional interface instance\n-     *                   are invoked.\n-     * @param instantiatedMethodType The signature of the primary functional\n-     *                               interface method after type variables are\n-     *                               substituted with their instantiation from\n-     *                               the capture site\n+     * @param interfaceMethodName Name of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a String.\n+     * @param interfaceMethodType Type of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a MethodType.\n+     * @param implementation The implementation method which should be called\n+     *                       (with suitable adaptation of argument types, return\n+     *                       types, and adjustment for captured arguments) when\n+     *                       methods of the resulting functional interface instance\n+     *                       are invoked.\n+     * @param dynamicMethodType The signature of the primary functional\n+     *                          interface method after type variables are\n+     *                          substituted with their instantiation from\n+     *                          the capture site\n@@ -102,4 +102,4 @@\n-     * @param markerInterfaces Additional interfaces which the lambda object\n-     *                       should implement.\n-     * @param additionalBridges Method types for additional signatures to be\n-     *                          bridged to the implementation method\n+     * @param altInterfaces Additional interfaces which the lambda object\n+     *                      should implement.\n+     * @param altMethods Method types for additional signatures to be\n+     *                   implemented by invoking the implementation method\n@@ -107,1 +107,4 @@\n-     * invariants are violated\n+     *         invariants are violated\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -110,8 +113,8 @@\n-                                       MethodType invokedType,\n-                                       String samMethodName,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType,\n-                                       boolean isSerializable,\n-                                       Class<?>[] markerInterfaces,\n-                                       MethodType[] additionalBridges)\n+                                        MethodType factoryType,\n+                                        String interfaceMethodName,\n+                                        MethodType interfaceMethodType,\n+                                        MethodHandle implementation,\n+                                        MethodType dynamicMethodType,\n+                                        boolean isSerializable,\n+                                        Class<?>[] altInterfaces,\n+                                        MethodType[] altMethods)\n@@ -119,1 +122,1 @@\n-        if ((caller.lookupModes() & MethodHandles.Lookup.PRIVATE) == 0) {\n+        if (!caller.hasFullPrivilegeAccess()) {\n@@ -126,1 +129,1 @@\n-        this.invokedType = invokedType;\n+        this.factoryType = factoryType;\n@@ -128,1 +131,1 @@\n-        this.samBase = invokedType.returnType();\n+        this.interfaceClass = factoryType.returnType();\n@@ -130,2 +133,2 @@\n-        this.samMethodName = samMethodName;\n-        this.samMethodType  = samMethodType;\n+        this.interfaceMethodName = interfaceMethodName;\n+        this.interfaceMethodType  = interfaceMethodType;\n@@ -133,3 +136,7 @@\n-        this.implMethod = implMethod;\n-        this.implMethodType = implMethod.type();\n-        this.implInfo = caller.revealDirect(implMethod);\n+        this.implementation = implementation;\n+        this.implMethodType = implementation.type();\n+        try {\n+            this.implInfo = caller.revealDirect(implementation); \/\/ may throw SecurityException\n+        } catch (IllegalArgumentException e) {\n+            throw new LambdaConversionException(implementation + \" is not direct or cannot be cracked\");\n+        }\n@@ -150,8 +157,4 @@\n-                \/\/ Classes compiled prior to dynamic nestmate support invokes a private instance\n-                \/\/ method with REF_invokeSpecial.\n-                \/\/\n-                \/\/ invokespecial should only be used to invoke private nestmate constructors.\n-                \/\/ The lambda proxy class will be defined as a nestmate of targetClass.\n-                \/\/ If the method to be invoked is an instance method of targetClass, then\n-                \/\/ convert to use invokevirtual or invokeinterface.\n-                if (targetClass == implClass && !implInfo.getName().equals(\"<init>\")) {\n+                \/\/ Classes compiled prior to dynamic nestmate support invoke a private instance\n+                \/\/ method with REF_invokeSpecial. Newer classes use REF_invokeVirtual or\n+                \/\/ REF_invokeInterface, and we can use that instruction in the lambda class.\n+                if (targetClass == implClass) {\n@@ -174,1 +177,1 @@\n-        this.instantiatedMethodType = instantiatedMethodType;\n+        this.dynamicMethodType = dynamicMethodType;\n@@ -176,2 +179,2 @@\n-        this.markerInterfaces = markerInterfaces;\n-        this.additionalBridges = additionalBridges;\n+        this.altInterfaces = altInterfaces;\n+        this.altMethods = altMethods;\n@@ -179,7 +182,7 @@\n-        if (samMethodName.isEmpty() ||\n-                samMethodName.indexOf('.') >= 0 ||\n-                samMethodName.indexOf(';') >= 0 ||\n-                samMethodName.indexOf('[') >= 0 ||\n-                samMethodName.indexOf('\/') >= 0 ||\n-                samMethodName.indexOf('<') >= 0 ||\n-                samMethodName.indexOf('>') >= 0) {\n+        if (interfaceMethodName.isEmpty() ||\n+                interfaceMethodName.indexOf('.') >= 0 ||\n+                interfaceMethodName.indexOf(';') >= 0 ||\n+                interfaceMethodName.indexOf('[') >= 0 ||\n+                interfaceMethodName.indexOf('\/') >= 0 ||\n+                interfaceMethodName.indexOf('<') >= 0 ||\n+                interfaceMethodName.indexOf('>') >= 0) {\n@@ -188,1 +191,1 @@\n-                    samMethodName));\n+                    interfaceMethodName));\n@@ -191,1 +194,1 @@\n-        if (!samBase.isInterface()) {\n+        if (!interfaceClass.isInterface()) {\n@@ -193,2 +196,2 @@\n-                    \"Functional interface %s is not an interface\",\n-                    samBase.getName()));\n+                    \"%s is not an interface\",\n+                    interfaceClass.getName()));\n@@ -197,1 +200,1 @@\n-        for (Class<?> c : markerInterfaces) {\n+        for (Class<?> c : altInterfaces) {\n@@ -200,1 +203,1 @@\n-                        \"Marker interface %s is not an interface\",\n+                        \"%s is not an interface\",\n@@ -223,3 +226,3 @@\n-        final int capturedArity = invokedType.parameterCount();\n-        final int samArity = samMethodType.parameterCount();\n-        final int instantiatedArity = instantiatedMethodType.parameterCount();\n+        final int capturedArity = factoryType.parameterCount();\n+        final int samArity = interfaceMethodType.parameterCount();\n+        final int dynamicArity = dynamicMethodType.parameterCount();\n@@ -232,1 +235,1 @@\n-        if (instantiatedArity != samArity) {\n+        if (dynamicArity != samArity) {\n@@ -234,1 +237,1 @@\n-                    String.format(\"Incorrect number of parameters for %s method %s; %d instantiated parameters, %d functional interface method parameters\",\n+                    String.format(\"Incorrect number of parameters for %s method %s; %d dynamic parameters, %d functional interface method parameters\",\n@@ -236,1 +239,1 @@\n-                                  instantiatedArity, samArity));\n+                                  dynamicArity, samArity));\n@@ -238,1 +241,1 @@\n-        for (MethodType bridgeMT : additionalBridges) {\n+        for (MethodType bridgeMT : altMethods) {\n@@ -242,1 +245,1 @@\n-                                      bridgeMT, samMethodType));\n+                                      bridgeMT, interfaceMethodType));\n@@ -257,1 +260,1 @@\n-                receiverClass = instantiatedMethodType.parameterType(0);\n+                receiverClass = dynamicMethodType.parameterType(0);\n@@ -262,1 +265,1 @@\n-                receiverClass = invokedType.parameterType(0);\n+                receiverClass = factoryType.parameterType(0);\n@@ -280,1 +283,1 @@\n-            Class<?> capturedParamType = invokedType.parameterType(i);\n+            Class<?> capturedParamType = factoryType.parameterType(i);\n@@ -290,2 +293,2 @@\n-            Class<?> instantiatedParamType = instantiatedMethodType.parameterType(i - capturedArity);\n-            if (!isAdaptableTo(instantiatedParamType, implParamType, true)) {\n+            Class<?> dynamicParamType = dynamicMethodType.parameterType(i - capturedArity);\n+            if (!isAdaptableTo(dynamicParamType, implParamType, true)) {\n@@ -294,1 +297,1 @@\n-                                      i, instantiatedParamType, implParamType));\n+                                      i, dynamicParamType, implParamType));\n@@ -299,1 +302,1 @@\n-        Class<?> expectedType = instantiatedMethodType.returnType();\n+        Class<?> expectedType = dynamicMethodType.returnType();\n@@ -308,2 +311,2 @@\n-        checkDescriptor(samMethodType);\n-        for (MethodType bridgeMT : additionalBridges) {\n+        checkDescriptor(interfaceMethodType);\n+        for (MethodType bridgeMT : altMethods) {\n@@ -314,1 +317,1 @@\n-    \/** Validate that the given descriptor's types are compatible with {@code instantiatedMethodType} **\/\n+    \/** Validate that the given descriptor's types are compatible with {@code dynamicMethodType} **\/\n@@ -316,2 +319,2 @@\n-        for (int i = 0; i < instantiatedMethodType.parameterCount(); i++) {\n-            Class<?> instantiatedParamType = instantiatedMethodType.parameterType(i);\n+        for (int i = 0; i < dynamicMethodType.parameterCount(); i++) {\n+            Class<?> dynamicParamType = dynamicMethodType.parameterType(i);\n@@ -319,3 +322,3 @@\n-            if (!descriptorParamType.isAssignableFrom(instantiatedParamType)) {\n-                String msg = String.format(\"Type mismatch for instantiated parameter %d: %s is not a subtype of %s\",\n-                                           i, instantiatedParamType, descriptorParamType);\n+            if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {\n+                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not a subtype of %s\",\n+                                           i, dynamicParamType, descriptorParamType);\n@@ -326,1 +329,1 @@\n-        Class<?> instantiatedReturnType = instantiatedMethodType.returnType();\n+        Class<?> dynamicReturnType = dynamicMethodType.returnType();\n@@ -328,1 +331,1 @@\n-        if (!isAdaptableToAsReturnStrict(instantiatedReturnType, descriptorReturnType)) {\n+        if (!isAdaptableToAsReturnStrict(dynamicReturnType, descriptorReturnType)) {\n@@ -330,1 +333,1 @@\n-                                       instantiatedReturnType, descriptorReturnType);\n+                                       dynamicReturnType, descriptorReturnType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":100,"deletions":97,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n-            switch (refKind) {\n-                case REF_invokeSpecial: {\n+            return switch (refKind) {\n+                case REF_invokeSpecial -> {\n@@ -99,1 +99,1 @@\n-                    return new Special(mtype, lform, member, true, callerClass);\n+                    yield new Special(mtype, lform, member, true, callerClass);\n@@ -101,1 +101,1 @@\n-                case REF_invokeInterface: {\n+                case REF_invokeInterface -> {\n@@ -106,1 +106,1 @@\n-                    return new Interface(mtype, lform, member, true, refc);\n+                    yield new Interface(mtype, lform, member, true, refc);\n@@ -108,1 +108,1 @@\n-                default: {\n+                default -> {\n@@ -110,1 +110,1 @@\n-                    return new DirectMethodHandle(mtype, lform, member, true);\n+                    yield new DirectMethodHandle(mtype, lform, member, true);\n@@ -112,1 +112,1 @@\n-            }\n+            };\n@@ -199,1 +199,0 @@\n-        int which;\n@@ -205,8 +204,8 @@\n-        switch (m.getReferenceKind()) {\n-        case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;\n-        case REF_invokeStatic:     which = LF_INVSTATIC;     break;\n-        case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;\n-        case REF_invokeInterface:  which = LF_INVINTERFACE;  break;\n-        case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;\n-        default:  throw new InternalError(m.toString());\n-        }\n+        int which = switch (m.getReferenceKind()) {\n+            case REF_invokeVirtual    -> LF_INVVIRTUAL;\n+            case REF_invokeStatic     -> LF_INVSTATIC;\n+            case REF_invokeSpecial    -> LF_INVSPECIAL;\n+            case REF_invokeInterface  -> LF_INVINTERFACE;\n+            case REF_newInvokeSpecial -> LF_NEWINVSPECIAL;\n+            default -> throw new InternalError(m.toString());\n+        };\n@@ -680,8 +679,8 @@\n-        byte formOp;\n-        switch (m.getReferenceKind()) {\n-        case REF_getField:      formOp = AF_GETFIELD;    break;\n-        case REF_putField:      formOp = AF_PUTFIELD;    break;\n-        case REF_getStatic:     formOp = AF_GETSTATIC;   break;\n-        case REF_putStatic:     formOp = AF_PUTSTATIC;   break;\n-        default:  throw new InternalError(m.toString());\n-        }\n+        boolean isVolatile = m.isVolatile();\n+        byte formOp = switch (m.getReferenceKind()) {\n+            case REF_getField  -> AF_GETFIELD;\n+            case REF_putField  -> AF_PUTFIELD;\n+            case REF_getStatic -> AF_GETSTATIC;\n+            case REF_putStatic -> AF_PUTSTATIC;\n+            default -> throw new InternalError(m.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -317,12 +317,15 @@\n-        if (refKind == originalRefKind)  return true;\n-        switch (originalRefKind) {\n-        case REF_invokeInterface:\n-            \/\/ Looking up an interface method, can get (e.g.) Object.hashCode\n-            assert(refKind == REF_invokeVirtual ||\n-                   refKind == REF_invokeSpecial) : this;\n-            return true;\n-        case REF_invokeVirtual:\n-        case REF_newInvokeSpecial:\n-            \/\/ Looked up a virtual, can get (e.g.) final String.hashCode.\n-            assert(refKind == REF_invokeSpecial) : this;\n-            return true;\n+        if (refKind == originalRefKind) return true;\n+        if (getClass().desiredAssertionStatus()) {\n+            switch (originalRefKind) {\n+                case REF_invokeInterface -> {\n+                    \/\/ Looking up an interface method, can get (e.g.) Object.hashCode\n+                    assert (refKind == REF_invokeVirtual || refKind == REF_invokeSpecial) : this;\n+                }\n+                case REF_invokeVirtual, REF_newInvokeSpecial -> {\n+                    \/\/ Looked up a virtual, can get (e.g.) final String.hashCode.\n+                    assert (refKind == REF_invokeSpecial) : this;\n+                }\n+                default -> {\n+                    assert (false) : this + \" != \" + MethodHandleNatives.refKindName((byte) originalRefKind);\n+                }\n+            }\n@@ -330,1 +333,0 @@\n-        assert(false) : this+\" != \"+MethodHandleNatives.refKindName((byte)originalRefKind);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -110,6 +112,6 @@\n-            switch (a) {\n-                case GET: return \"getElement\";\n-                case SET: return \"setElement\";\n-                case LENGTH: return \"length\";\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> \"getElement\";\n+                case SET    -> \"setElement\";\n+                case LENGTH -> \"length\";\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -119,6 +121,6 @@\n-            switch (a) {\n-                case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;\n-                case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;\n-                case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> ArrayAccessor.OBJECT_ARRAY_GETTER;\n+                case SET    -> ArrayAccessor.OBJECT_ARRAY_SETTER;\n+                case LENGTH -> ArrayAccessor.OBJECT_ARRAY_LENGTH;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -128,6 +130,6 @@\n-            switch (a) {\n-                case GET: return ArrayAccessor.GETTER_INDEX;\n-                case SET: return ArrayAccessor.SETTER_INDEX;\n-                case LENGTH: return ArrayAccessor.LENGTH_INDEX;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> ArrayAccessor.GETTER_INDEX;\n+                case SET    -> ArrayAccessor.SETTER_INDEX;\n+                case LENGTH -> ArrayAccessor.LENGTH_INDEX;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -137,6 +139,6 @@\n-            switch (a) {\n-                case GET: return Intrinsic.ARRAY_LOAD;\n-                case SET: return Intrinsic.ARRAY_STORE;\n-                case LENGTH: return Intrinsic.ARRAY_LENGTH;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> Intrinsic.ARRAY_LOAD;\n+                case SET    -> Intrinsic.ARRAY_STORE;\n+                case LENGTH -> Intrinsic.ARRAY_LENGTH;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -214,6 +216,6 @@\n-            switch (access) {\n-                case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);\n-                case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);\n-                case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);\n-            }\n-            throw unmatchedArrayAccess(access);\n+            return switch (access) {\n+                case GET    -> MethodType.methodType(elemClass, arrayArgClass, int.class);\n+                case SET    -> MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);\n+                case LENGTH -> MethodType.methodType(int.class, arrayArgClass);\n+                default -> throw unmatchedArrayAccess(access);\n+            };\n@@ -223,6 +225,6 @@\n-            switch (access) {\n-                case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);\n-                case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);\n-                case LENGTH: return MethodType.methodType(int.class,  arrayClass);\n-            }\n-            throw unmatchedArrayAccess(access);\n+            return switch (access) {\n+                case GET    -> MethodType.methodType(elemClass, arrayClass, int.class);\n+                case SET    -> MethodType.methodType(void.class, arrayClass, int.class, elemClass);\n+                case LENGTH -> MethodType.methodType(int.class, arrayClass);\n+                default -> throw unmatchedArrayAccess(access);\n+            };\n@@ -826,1 +828,3 @@\n-        names[SELECT_ALT] = new Name(new NamedFunction(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE), names[TEST], names[GET_TARGET], names[GET_FALLBACK]);\n+        names[SELECT_ALT] = new Name(new NamedFunction(\n+                makeIntrinsic(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE)),\n+                names[TEST], names[GET_TARGET], names[GET_FALLBACK]);\n@@ -897,1 +901,1 @@\n-        names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);\n+        names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.GUARD_WITH_CATCH)), args);\n@@ -979,6 +983,5 @@\n-        int idx;\n-        switch (method.getName()) {\n-        case \"invoke\":       idx = 0; break;\n-        case \"invokeExact\":  idx = 1; break;\n-        default:             throw new InternalError(method.getName());\n-        }\n+        int idx = switch (method.getName()) {\n+            case \"invoke\"      -> 0;\n+            case \"invokeExact\" -> 1;\n+            default -> throw new InternalError(method.getName());\n+        };\n@@ -1229,0 +1232,1 @@\n+        TABLE_SWITCH,\n@@ -1243,0 +1247,1 @@\n+        private final Object intrinsicData;\n@@ -1245,0 +1250,4 @@\n+           this(target, intrinsicName, null);\n+        }\n+\n+        IntrinsicMethodHandle(MethodHandle target, Intrinsic intrinsicName, Object intrinsicData) {\n@@ -1248,0 +1257,1 @@\n+            this.intrinsicData = intrinsicData;\n@@ -1260,0 +1270,5 @@\n+        @Override\n+        Object intrinsicData() {\n+            return intrinsicData;\n+        }\n+\n@@ -1285,0 +1300,4 @@\n+        return makeIntrinsic(target, intrinsicName, null);\n+    }\n+\n+    static MethodHandle makeIntrinsic(MethodHandle target, Intrinsic intrinsicName, Object intrinsicData) {\n@@ -1287,1 +1306,1 @@\n-        return new IntrinsicMethodHandle(target, intrinsicName);\n+        return new IntrinsicMethodHandle(target, intrinsicName, intrinsicData);\n@@ -1363,1 +1382,2 @@\n-            NF_LIMIT = 6;\n+            NF_tableSwitch = 6,\n+            NF_LIMIT = 7;\n@@ -1377,23 +1397,18 @@\n-            switch (func) {\n-                case NF_checkSpreadArgument:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"checkSpreadArgument\", Object.class, int.class));\n-                case NF_guardWithCatch:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"guardWithCatch\", MethodHandle.class, Class.class,\n-                                    MethodHandle.class, Object[].class));\n-                case NF_tryFinally:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"tryFinally\", MethodHandle.class, MethodHandle.class, Object[].class));\n-                case NF_loop:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"loop\", BasicType[].class, LoopClauses.class, Object[].class));\n-                case NF_throwException:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"throwException\", Throwable.class));\n-                case NF_profileBoolean:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"profileBoolean\", boolean.class, int[].class));\n-                default:\n-                    throw new InternalError(\"Undefined function: \" + func);\n-            }\n+            return switch (func) {\n+                case NF_checkSpreadArgument -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"checkSpreadArgument\", Object.class, int.class));\n+                case NF_guardWithCatch      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"guardWithCatch\", MethodHandle.class, Class.class,\n+                                                   MethodHandle.class, Object[].class));\n+                case NF_tryFinally          -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"tryFinally\", MethodHandle.class, MethodHandle.class, Object[].class));\n+                case NF_loop                -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"loop\", BasicType[].class, LoopClauses.class, Object[].class));\n+                case NF_throwException      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"throwException\", Throwable.class));\n+                case NF_profileBoolean      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"profileBoolean\", boolean.class, int[].class));\n+                case NF_tableSwitch         -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"tableSwitch\", int.class, MethodHandle.class, CasesHolder.class, Object[].class));\n+                default -> throw new InternalError(\"Undefined function: \" + func);\n+            };\n@@ -1446,0 +1461,5 @@\n+            @Override\n+            public void ensureCustomized(MethodHandle mh) {\n+                mh.customize();\n+            }\n+\n@@ -1605,1 +1625,1 @@\n-            names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.LOOP), args);\n+            names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.LOOP)), args);\n@@ -1842,1 +1862,1 @@\n-        names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.TRY_FINALLY), args);\n+        names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.TRY_FINALLY)), args);\n@@ -1944,1 +1964,1 @@\n-            names[storeNameCursor] = new Name(new NamedFunction(storeFunc, Intrinsic.ARRAY_STORE),\n+            names[storeNameCursor] = new Name(new NamedFunction(makeIntrinsic(storeFunc, Intrinsic.ARRAY_STORE)),\n@@ -1955,0 +1975,135 @@\n+    \/\/ use a wrapper because we need this array to be @Stable\n+    static class CasesHolder {\n+        @Stable\n+        final MethodHandle[] cases;\n+\n+        public CasesHolder(MethodHandle[] cases) {\n+            this.cases = cases;\n+        }\n+    }\n+\n+    static MethodHandle makeTableSwitch(MethodType type, MethodHandle defaultCase, MethodHandle[] caseActions) {\n+        MethodType varargsType = type.changeReturnType(Object[].class);\n+        MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);\n+\n+        MethodHandle unboxResult = unboxResultHandle(type.returnType());\n+\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();\n+        LambdaForm form = makeTableSwitchForm(type.basicType(), data, caseActions.length);\n+        BoundMethodHandle mh;\n+        CasesHolder caseHolder =  new CasesHolder(caseActions);\n+        try {\n+            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) defaultCase, (Object) collectArgs,\n+                                                                (Object) unboxResult, (Object) caseHolder);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+        assert(mh.type() == type);\n+        return mh;\n+    }\n+\n+    private static class TableSwitchCacheKey {\n+        private static final Map<TableSwitchCacheKey, LambdaForm> CACHE = new ConcurrentHashMap<>();\n+\n+        private final MethodType basicType;\n+        private final int numberOfCases;\n+\n+        public TableSwitchCacheKey(MethodType basicType, int numberOfCases) {\n+            this.basicType = basicType;\n+            this.numberOfCases = numberOfCases;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            TableSwitchCacheKey that = (TableSwitchCacheKey) o;\n+            return numberOfCases == that.numberOfCases && Objects.equals(basicType, that.basicType);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(basicType, numberOfCases);\n+        }\n+    }\n+\n+    private static LambdaForm makeTableSwitchForm(MethodType basicType, BoundMethodHandle.SpeciesData data,\n+                                                  int numCases) {\n+        MethodType lambdaType = basicType.invokerType();\n+\n+        \/\/ We need to cache based on the basic type X number of cases,\n+        \/\/ since the number of cases is used when generating bytecode.\n+        \/\/ This also means that we can't use the cache in MethodTypeForm,\n+        \/\/ which only uses the basic type as a key.\n+        TableSwitchCacheKey key = new TableSwitchCacheKey(basicType, numCases);\n+        LambdaForm lform = TableSwitchCacheKey.CACHE.get(key);\n+        if (lform != null) {\n+            return lform;\n+        }\n+\n+        final int THIS_MH       = 0;\n+        final int ARG_BASE      = 1;  \/\/ start of incoming arguments\n+        final int ARG_LIMIT     = ARG_BASE + basicType.parameterCount();\n+        final int ARG_SWITCH_ON = ARG_BASE;\n+        assert ARG_SWITCH_ON < ARG_LIMIT;\n+\n+        int nameCursor = ARG_LIMIT;\n+        final int GET_COLLECT_ARGS  = nameCursor++;\n+        final int GET_DEFAULT_CASE  = nameCursor++;\n+        final int GET_UNBOX_RESULT  = nameCursor++;\n+        final int GET_CASES         = nameCursor++;\n+        final int BOXED_ARGS        = nameCursor++;\n+        final int TABLE_SWITCH      = nameCursor++;\n+        final int UNBOXED_RESULT    = nameCursor++;\n+\n+        int fieldCursor = 0;\n+        final int FIELD_DEFAULT_CASE  = fieldCursor++;\n+        final int FIELD_COLLECT_ARGS  = fieldCursor++;\n+        final int FIELD_UNBOX_RESULT  = fieldCursor++;\n+        final int FIELD_CASES         = fieldCursor++;\n+\n+        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+\n+        names[THIS_MH] = names[THIS_MH].withConstraint(data);\n+        names[GET_DEFAULT_CASE] = new Name(data.getterFunction(FIELD_DEFAULT_CASE), names[THIS_MH]);\n+        names[GET_COLLECT_ARGS]  = new Name(data.getterFunction(FIELD_COLLECT_ARGS), names[THIS_MH]);\n+        names[GET_UNBOX_RESULT]  = new Name(data.getterFunction(FIELD_UNBOX_RESULT), names[THIS_MH]);\n+        names[GET_CASES] = new Name(data.getterFunction(FIELD_CASES), names[THIS_MH]);\n+\n+        {\n+            MethodType collectArgsType = basicType.changeReturnType(Object.class);\n+            MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);\n+            Object[] args = new Object[invokeBasic.type().parameterCount()];\n+            args[0] = names[GET_COLLECT_ARGS];\n+            System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);\n+            names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.TABLE_SWITCH, numCases)), args);\n+        }\n+\n+        {\n+            Object[] tfArgs = new Object[]{\n+                names[ARG_SWITCH_ON], names[GET_DEFAULT_CASE], names[GET_CASES], names[BOXED_ARGS]};\n+            names[TABLE_SWITCH] = new Name(getFunction(NF_tableSwitch), tfArgs);\n+        }\n+\n+        {\n+            MethodHandle invokeBasic = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));\n+            Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[TABLE_SWITCH]};\n+            names[UNBOXED_RESULT] = new Name(invokeBasic, unboxArgs);\n+        }\n+\n+        lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.TABLE_SWITCH);\n+        LambdaForm prev = TableSwitchCacheKey.CACHE.putIfAbsent(key, lform);\n+        return prev != null ? prev : lform;\n+    }\n+\n+    @Hidden\n+    static Object tableSwitch(int input, MethodHandle defaultCase, CasesHolder holder, Object[] args) throws Throwable {\n+        MethodHandle[] caseActions = holder.cases;\n+        MethodHandle selectedCase;\n+        if (input < 0 || input >= caseActions.length) {\n+            selectedCase = defaultCase;\n+        } else {\n+            selectedCase = caseActions[input];\n+        }\n+        return selectedCase.invokeWithArguments(args);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":227,"deletions":72,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.module.IllegalAccessLogger;\n@@ -232,0 +231,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -265,7 +265,0 @@\n-\n-            if (!callerModule.isNamed() && targetModule.isNamed()) {\n-                IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();\n-                if (logger != null) {\n-                    logger.logIfOpenedForIllegalAccess(caller, targetClass);\n-                }\n-            }\n@@ -451,0 +444,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -1857,0 +1851,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -1942,3 +1937,3 @@\n-         * structure of a supported major and minor version. The major and minor version\n-         * may differ from the {@code class} file version of the lookup class of this\n-         * {@code Lookup}.<\/li>\n+         * structure (JVMS {@jvms 4.1}) of a supported major and minor version.\n+         * The major and minor version may differ from the {@code class} file version\n+         * of the lookup class of this {@code Lookup}.<\/li>\n@@ -3780,0 +3775,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -3811,0 +3807,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -5217,7 +5214,7 @@\n-        switch (w) {\n-        case INT:     return result.bindArgumentI(pos, (int)value);\n-        case LONG:    return result.bindArgumentJ(pos, (long)value);\n-        case FLOAT:   return result.bindArgumentF(pos, (float)value);\n-        case DOUBLE:  return result.bindArgumentD(pos, (double)value);\n-        default:      return result.bindArgumentI(pos, ValueConversions.widenSubword(value));\n-        }\n+        return switch (w) {\n+            case INT    -> result.bindArgumentI(pos, (int) value);\n+            case LONG   -> result.bindArgumentJ(pos, (long) value);\n+            case FLOAT  -> result.bindArgumentF(pos, (float) value);\n+            case DOUBLE -> result.bindArgumentD(pos, (double) value);\n+            default -> result.bindArgumentI(pos, ValueConversions.widenSubword(value));\n+        };\n@@ -7798,0 +7795,86 @@\n+    \/**\n+     * Creates a table switch method handle, which can be used to switch over a set of target\n+     * method handles, based on a given target index, called selector.\n+     * <p>\n+     * For a selector value of {@code n}, where {@code n} falls in the range {@code [0, N)},\n+     * and where {@code N} is the number of target method handles, the table switch method\n+     * handle will invoke the n-th target method handle from the list of target method handles.\n+     * <p>\n+     * For a selector value that does not fall in the range {@code [0, N)}, the table switch\n+     * method handle will invoke the given fallback method handle.\n+     * <p>\n+     * All method handles passed to this method must have the same type, with the additional\n+     * requirement that the leading parameter be of type {@code int}. The leading parameter\n+     * represents the selector.\n+     * <p>\n+     * Any trailing parameters present in the type will appear on the returned table switch\n+     * method handle as well. Any arguments assigned to these parameters will be forwarded,\n+     * together with the selector value, to the selected method handle when invoking it.\n+     *\n+     * @apiNote Example:\n+     * The cases each drop the {@code selector} value they are given, and take an additional\n+     * {@code String} argument, which is concatenated (using {@link String#concat(String)})\n+     * to a specific constant label string for each case:\n+     * <blockquote><pre>{@code\n+     * MethodHandles.Lookup lookup = MethodHandles.lookup();\n+     * MethodHandle caseMh = lookup.findVirtual(String.class, \"concat\",\n+     *         MethodType.methodType(String.class, String.class));\n+     * caseMh = MethodHandles.dropArguments(caseMh, 0, int.class);\n+     *\n+     * MethodHandle caseDefault = MethodHandles.insertArguments(caseMh, 1, \"default: \");\n+     * MethodHandle case0 = MethodHandles.insertArguments(caseMh, 1, \"case 0: \");\n+     * MethodHandle case1 = MethodHandles.insertArguments(caseMh, 1, \"case 1: \");\n+     *\n+     * MethodHandle mhSwitch = MethodHandles.tableSwitch(\n+     *     caseDefault,\n+     *     case0,\n+     *     case1\n+     * );\n+     *\n+     * assertEquals(\"default: data\", (String) mhSwitch.invokeExact(-1, \"data\"));\n+     * assertEquals(\"case 0: data\", (String) mhSwitch.invokeExact(0, \"data\"));\n+     * assertEquals(\"case 1: data\", (String) mhSwitch.invokeExact(1, \"data\"));\n+     * assertEquals(\"default: data\", (String) mhSwitch.invokeExact(2, \"data\"));\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param fallback the fallback method handle that is called when the selector is not\n+     *                 within the range {@code [0, N)}.\n+     * @param targets array of target method handles.\n+     * @return the table switch method handle.\n+     * @throws NullPointerException if {@code fallback}, the {@code targets} array, or any\n+     *                              any of the elements of the {@code targets} array are\n+     *                              {@code null}.\n+     * @throws IllegalArgumentException if the {@code targets} array is empty, if the leading\n+     *                                  parameter of the fallback handle or any of the target\n+     *                                  handles is not {@code int}, or if the types of\n+     *                                  the fallback handle and all of target handles are\n+     *                                  not the same.\n+     *\/\n+    public static MethodHandle tableSwitch(MethodHandle fallback, MethodHandle... targets) {\n+        Objects.requireNonNull(fallback);\n+        Objects.requireNonNull(targets);\n+        targets = targets.clone();\n+        MethodType type = tableSwitchChecks(fallback, targets);\n+        return MethodHandleImpl.makeTableSwitch(type, fallback, targets);\n+    }\n+\n+    private static MethodType tableSwitchChecks(MethodHandle defaultCase, MethodHandle[] caseActions) {\n+        if (caseActions.length == 0)\n+            throw new IllegalArgumentException(\"Not enough cases: \" + Arrays.toString(caseActions));\n+\n+        MethodType expectedType = defaultCase.type();\n+\n+        if (!(expectedType.parameterCount() >= 1) || expectedType.parameterType(0) != int.class)\n+            throw new IllegalArgumentException(\n+                \"Case actions must have int as leading parameter: \" + Arrays.toString(caseActions));\n+\n+        for (MethodHandle mh : caseActions) {\n+            Objects.requireNonNull(mh);\n+            if (mh.type() != expectedType)\n+                throw new IllegalArgumentException(\n+                    \"Case actions must have the same type: \" + Arrays.toString(caseActions));\n+        }\n+\n+        return expectedType;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":101,"deletions":18,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1145,0 +1145,1 @@\n+            @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.vm.annotation.DontInline;\n@@ -1639,0 +1640,4 @@\n+        static final int COUNT = GET_AND_UPDATE.ordinal() + 1;\n+        static {\n+            assert (COUNT == values().length);\n+        }\n@@ -1899,1 +1904,1 @@\n-        static final Map<String, AccessMode> methodNameToAccessMode;\n+        static final int COUNT = GET_AND_BITWISE_XOR_ACQUIRE.ordinal() + 1;\n@@ -1901,8 +1906,1 @@\n-            AccessMode[] values = AccessMode.values();\n-            \/\/ Initial capacity of # values divided by the load factor is sufficient\n-            \/\/ to avoid resizes for the smallest table size (64)\n-            int initialCapacity = (int)(values.length \/ 0.75f) + 1;\n-            methodNameToAccessMode = new HashMap<>(initialCapacity);\n-            for (AccessMode am : values) {\n-                methodNameToAccessMode.put(am.methodName, am);\n-            }\n+            assert (COUNT == values().length);\n@@ -1910,1 +1908,0 @@\n-\n@@ -1943,3 +1940,34 @@\n-            AccessMode am = methodNameToAccessMode.get(methodName);\n-            if (am != null) return am;\n-            throw new IllegalArgumentException(\"No AccessMode value for method name \" + methodName);\n+            return switch (methodName) {\n+                case \"get\" -> GET;\n+                case \"set\" -> SET;\n+                case \"getVolatile\" -> GET_VOLATILE;\n+                case \"setVolatile\" -> SET_VOLATILE;\n+                case \"getAcquire\" -> GET_ACQUIRE;\n+                case \"setRelease\" -> SET_RELEASE;\n+                case \"getOpaque\" -> GET_OPAQUE;\n+                case \"setOpaque\" -> SET_OPAQUE;\n+                case \"compareAndSet\" -> COMPARE_AND_SET;\n+                case \"compareAndExchange\" -> COMPARE_AND_EXCHANGE;\n+                case \"compareAndExchangeAcquire\" -> COMPARE_AND_EXCHANGE_ACQUIRE;\n+                case \"compareAndExchangeRelease\" -> COMPARE_AND_EXCHANGE_RELEASE;\n+                case \"weakCompareAndSet\" -> WEAK_COMPARE_AND_SET;\n+                case \"weakCompareAndSetPlain\" -> WEAK_COMPARE_AND_SET_PLAIN;\n+                case \"weakCompareAndSetAcquire\" -> WEAK_COMPARE_AND_SET_ACQUIRE;\n+                case \"weakCompareAndSetRelease\" -> WEAK_COMPARE_AND_SET_RELEASE;\n+                case \"getAndSet\" -> GET_AND_SET;\n+                case \"getAndSetAcquire\" -> GET_AND_SET_ACQUIRE;\n+                case \"getAndSetRelease\" -> GET_AND_SET_RELEASE;\n+                case \"getAndAdd\" -> GET_AND_ADD;\n+                case \"getAndAddAcquire\" -> GET_AND_ADD_ACQUIRE;\n+                case \"getAndAddRelease\" -> GET_AND_ADD_RELEASE;\n+                case \"getAndBitwiseOr\" -> GET_AND_BITWISE_OR;\n+                case \"getAndBitwiseOrRelease\" -> GET_AND_BITWISE_OR_RELEASE;\n+                case \"getAndBitwiseOrAcquire\" -> GET_AND_BITWISE_OR_ACQUIRE;\n+                case \"getAndBitwiseAnd\" -> GET_AND_BITWISE_AND;\n+                case \"getAndBitwiseAndRelease\" -> GET_AND_BITWISE_AND_RELEASE;\n+                case \"getAndBitwiseAndAcquire\" -> GET_AND_BITWISE_AND_ACQUIRE;\n+                case \"getAndBitwiseXor\" -> GET_AND_BITWISE_XOR;\n+                case \"getAndBitwiseXorRelease\" -> GET_AND_BITWISE_XOR_RELEASE;\n+                case \"getAndBitwiseXorAcquire\" -> GET_AND_BITWISE_XOR_ACQUIRE;\n+                default -> throw new IllegalArgumentException(\"No AccessMode value for method name \" + methodName);\n+            };\n@@ -2018,0 +2046,13 @@\n+    @ForceInline\n+    final void checkExactAccessMode(VarHandle.AccessDescriptor ad) {\n+        if (exact && accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n+            throwWrongMethodTypeException(ad);\n+        }\n+    }\n+\n+    @DontInline\n+    private final void throwWrongMethodTypeException(VarHandle.AccessDescriptor ad) {\n+        throw new WrongMethodTypeException(\"expected \" + accessModeType(ad.type) + \" but found \"\n+                + ad.symbolicMethodTypeExact);\n+    }\n+\n@@ -2102,2 +2143,1 @@\n-        MethodType[] methodType_table =\n-                new MethodType[VarHandle.AccessType.values().length];\n+        MethodType[] methodType_table = new MethodType[VarHandle.AccessType.COUNT];\n@@ -2106,2 +2146,1 @@\n-        MethodHandle[] methodHandle_table =\n-                new MethodHandle[AccessMode.values().length];\n+        MethodHandle[] methodHandle_table = new MethodHandle[AccessMode.COUNT];\n@@ -2252,9 +2291,5 @@\n-                switch (this) {\n-                    case FIELD:\n-                    case STATIC_FIELD:\n-                        return new ConstantDesc[] {declaringClass, varType };\n-                    case ARRAY:\n-                        return new ConstantDesc[] {declaringClass };\n-                    default:\n-                        throw new InternalError(\"Cannot reach here\");\n-                }\n+                return switch (this) {\n+                    case FIELD, STATIC_FIELD -> new ConstantDesc[]{declaringClass, varType};\n+                    case ARRAY               -> new ConstantDesc[]{declaringClass};\n+                    default -> throw new InternalError(\"Cannot reach here\");\n+                };\n@@ -2355,14 +2390,10 @@\n-            switch (kind) {\n-                case FIELD:\n-                    return lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n-                                                constantName(),\n-                                                (Class<?>) varType.resolveConstantDesc(lookup));\n-                case STATIC_FIELD:\n-                    return lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n-                                                      constantName(),\n-                                                      (Class<?>) varType.resolveConstantDesc(lookup));\n-                case ARRAY:\n-                    return MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n-                default:\n-                    throw new InternalError(\"Cannot reach here\");\n-            }\n+            return switch (kind) {\n+                case FIELD        -> lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          constantName(),\n+                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n+                case STATIC_FIELD -> lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          constantName(),\n+                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n+                case ARRAY        -> MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n+                default -> throw new InternalError(\"Cannot reach here\");\n+            };\n@@ -2381,11 +2412,7 @@\n-            switch (kind) {\n-                case FIELD:\n-                case STATIC_FIELD:\n-                    return String.format(\"VarHandleDesc[%s%s.%s:%s]\",\n-                                         (kind == Kind.STATIC_FIELD) ? \"static \" : \"\",\n-                                         declaringClass.displayName(), constantName(), varType.displayName());\n-                case ARRAY:\n-                    return String.format(\"VarHandleDesc[%s[]]\", declaringClass.displayName());\n-                default:\n-                    throw new InternalError(\"Cannot reach here\");\n-            }\n+            return switch (kind) {\n+                case FIELD, STATIC_FIELD -> String.format(\"VarHandleDesc[%s%s.%s:%s]\",\n+                                                           (kind == Kind.STATIC_FIELD) ? \"static \" : \"\",\n+                                                           declaringClass.displayName(), constantName(), varType.displayName());\n+                case ARRAY               -> String.format(\"VarHandleDesc[%s[]]\", declaringClass.displayName());\n+                default -> throw new InternalError(\"Cannot reach here\");\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":78,"deletions":51,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -703,4 +703,1 @@\n-\/\/                    if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n-\/\/                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n-\/\/                                + ad.symbolicMethodTypeExact);\n-\/\/                    }\n+\/\/                    handle.checkExactAccessMode(ad);\n@@ -721,4 +718,1 @@\n-\/\/                    if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n-\/\/                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n-\/\/                                + ad.symbolicMethodTypeExact);\n-\/\/                    }\n+\/\/                    handle.checkExactAccessMode(ad);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-public abstract class Executable extends AccessibleObject\n-    implements Member, GenericDeclaration {\n+public abstract sealed class Executable extends AccessibleObject\n+    implements Member, GenericDeclaration permits Constructor, Method {\n@@ -55,0 +55,1 @@\n+    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -393,0 +393,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -466,0 +467,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -666,0 +668,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -1021,0 +1024,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -1058,0 +1062,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -1079,0 +1084,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1116,0 +1122,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1289,0 +1296,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -171,0 +172,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -456,1 +458,1 @@\n-        visit(V17, accessFlags, dotToSlash(className), null,\n+        visit(V18, accessFlags, dotToSlash(className), null,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,0 +135,7 @@\n+\n+    \/**\n+     * Ensure given method handle is customized\n+     *\n+     * @param mh the method handle\n+     *\/\n+    void ensureCustomized(MethodHandle mh);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1463,28 +1463,0 @@\n-    \/**\n-     * Defines a class but does not make it known to the class loader or system dictionary.\n-     * <p>\n-     * For each CP entry, the corresponding CP patch must either be null or have\n-     * the a format that matches its tag:\n-     * <ul>\n-     * <li>Integer, Long, Float, Double: the corresponding wrapper object type from java.lang\n-     * <li>Utf8: a string (must have suitable syntax if used as signature or name)\n-     * <li>Class: any java.lang.Class object\n-     * <li>String: any object (not just a java.lang.String)\n-     * <li>InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments\n-     * <\/ul>\n-     * @param hostClass context for linkage, access control, protection domain, and class loader\n-     * @param data      bytes of a class file\n-     * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data\n-     *\/\n-    @Deprecated(since = \"15\", forRemoval = true)\n-    public Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches) {\n-        if (hostClass == null || data == null) {\n-            throw new NullPointerException();\n-        }\n-        if (hostClass.isArray() || hostClass.isPrimitive()) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return defineAnonymousClass0(hostClass, data, cpPatches);\n-    }\n-\n@@ -4228,1 +4200,0 @@\n-    private native Class<?> defineAnonymousClass0(Class<?> hostClass, byte[] data, Object[] cpPatches);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Objects;\n@@ -327,0 +326,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -379,1 +379,1 @@\n-        return Objects.equals(class1.getPackageName(), class2.getPackageName());\n+        return class1.getPackageName() == class2.getPackageName();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1495,1 +1495,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1544,1 +1543,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1729,1 +1727,0 @@\n-                @SuppressWarnings(\"preview\")\n@@ -1798,1 +1795,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -1841,1 +1837,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1852,1 +1847,0 @@\n-        @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2251,0 +2251,5 @@\n+        if (isPrimitiveClass(t)) {\n+            \/\/ No man may be an island, but the bell tolls for a value.\n+            return t.tsym == sym ? t : null;\n+        }\n+\n@@ -2252,2 +2257,1 @@\n-            if (!isPrimitiveClass(t))\n-                return syms.objectType;\n+            return syms.objectType;\n@@ -2256,2 +2260,2 @@\n-            \/\/ IdentityObject is super interface of every concrete identity class other than jlO\n-            if (t.isPrimitiveClass() || t.tsym == syms.objectType.tsym)\n+            \/\/ IdentityObject is a super interface of every concrete identity class other than jlO\n+            if (t.tsym == syms.objectType.tsym)\n@@ -2263,0 +2267,3 @@\n+            }\n+            if (implicitIdentityType(t)) {\n+                return syms.identityObjectType;\n@@ -2265,1 +2272,1 @@\n-            if (t.isPrimitiveClass() || t.isReferenceProjection())\n+            if (t.isReferenceProjection())\n@@ -2287,4 +2294,0 @@\n-                \/\/ No man may be an island, but the bell tolls for a value.\n-                if (isPrimitiveClass(t))\n-                    return null;\n-\n@@ -2336,0 +2339,57 @@\n+        \/\/ where\n+        private boolean implicitIdentityType(Type t) {\n+            \/* An abstract class can be declared to implement either IdentityObject or PrimitiveObject;\n+             * or, if it declares a field, an instance initializer, a non-empty constructor, or\n+             * a synchronized method, it implicitly implements IdentityObject.\n+             *\/\n+            if (!t.tsym.isAbstract())\n+                return false;\n+\n+            for (; t != Type.noType; t = supertype(t)) {\n+\n+                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n+                    return false;\n+\n+                if  (t.tsym == syms.objectType.tsym)\n+                    return false;\n+\n+                if (!t.tsym.isAbstract()) {\n+                    return !t.tsym.isPrimitiveClass();\n+                }\n+\n+                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n+                    return true;\n+                }\n+\n+                \/\/ No instance fields and no arged constructors both mean inner classes cannot be inline supers.\n+                Type encl = t.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    return true;\n+                }\n+                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0) {\n+                                return true;\n+                            }\n+                            break;\n+                        case MTH:\n+                            if ((s.flags() & SYNCHRONIZED) != 0) {\n+                                return true;\n+                            } else if (s.isConstructor()) {\n+                                MethodSymbol m = (MethodSymbol)s;\n+                                if (m.getParameters().size() > 0) {\n+                                    return true;\n+                                } else {\n+                                    if ((m.flags() & (GENERATEDCONSTR | EMPTYNOARGCONSTR)) == 0) {\n+                                        return true;\n+                                    }\n+                                }\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":69,"deletions":9,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -3637,1 +3637,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(tree.cases) : tree.cases;\n+        handleSwitch(tree, tree.selector, cases);\n@@ -3642,1 +3643,6 @@\n-        if (tree.cases.stream().noneMatch(c -> c.pats.isEmpty())) {\n+        List<JCCase> cases = addDefaultIfNeeded(tree.cases);\n+        handleSwitch(tree, tree.selector, cases);\n+    }\n+\n+    private List<JCCase> addDefaultIfNeeded(List<JCCase> cases) {\n+        if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n@@ -3645,2 +3651,2 @@\n-            JCCase c = make.Case(JCCase.STATEMENT, List.nil(), List.of(thr), null);\n-            tree.cases = tree.cases.append(c);\n+            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), List.of(thr), null);\n+            cases = cases.append(c);\n@@ -3648,1 +3654,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+\n+        return cases;\n@@ -3656,1 +3663,1 @@\n-            switch (c.pats.size()) {\n+            switch (c.labels.size()) {\n@@ -3667,1 +3674,1 @@\n-                    List<JCExpression> patterns = c.pats;\n+                    List<JCCaseLabel> patterns = c.labels;\n@@ -3675,1 +3682,1 @@\n-                    c.pats = patterns;\n+                    c.labels = patterns;\n@@ -3683,1 +3690,1 @@\n-                JCBreak b = make_at(c.pos()).Break(null);\n+                JCBreak b = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n@@ -3696,3 +3703,2 @@\n-        Type target = enumSwitch ? selector.type :\n-            (stringSwitch? syms.stringType : syms.intType);\n-        selector = translate(selector, target);\n+        boolean boxedSwitch = !enumSwitch && !stringSwitch && !selector.type.isPrimitive();\n+        selector = translate(selector, selector.type);\n@@ -3713,0 +3719,4 @@\n+        } else if (boxedSwitch) {\n+            \/\/An switch over boxed primitive. Pattern matching switches are already translated\n+            \/\/by TransPatterns, so all non-primitive types are only boxed primitives:\n+            result = visitBoxedPrimitiveSwitch(tree, selector, cases);\n@@ -3726,3 +3736,26 @@\n-        JCArrayAccess newSelector = make.Indexed(map.mapVar,\n-                                        make.App(make.Select(selector,\n-                                                             ordinalMethod)));\n+        JCExpression newSelector;\n+\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+            \/\/for enum switches with case null, do:\n+            \/\/switch ($selector != null ? $mapVar[$selector.ordinal()] : -1) {...}\n+            \/\/replacing case null with case -1:\n+            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n+                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               selector.type,\n+                                               currentMethodSym);\n+            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n+            newSelector = make.Indexed(map.mapVar,\n+                    make.App(make.Select(make.Ident(dollar_s),\n+                            ordinalMethod)));\n+            newSelector =\n+                    make.LetExpr(List.of(var),\n+                                 make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n+                                                  newSelector,\n+                                                  makeLit(syms.intType, -1))\n+                                     .setType(newSelector.type))\n+                        .setType(newSelector.type);\n+        } else {\n+            newSelector = make.Indexed(map.mapVar,\n+                    make.App(make.Select(selector,\n+                            ordinalMethod)));\n+        }\n@@ -3731,3 +3764,8 @@\n-            if (c.pats.nonEmpty()) {\n-                VarSymbol label = (VarSymbol)TreeInfo.symbol(c.pats.head);\n-                JCLiteral pat = map.forConstant(label);\n+            if (c.labels.head.isExpression()) {\n+                JCExpression pat;\n+                if (TreeInfo.isNull(c.labels.head)) {\n+                    pat = makeLit(syms.intType, -1);\n+                } else {\n+                    VarSymbol label = (VarSymbol)TreeInfo.symbol((JCExpression) c.labels.head);\n+                    pat = map.forConstant(label);\n+                }\n@@ -3810,0 +3848,2 @@\n+            JCCase nullCase = null;\n+            int nullCaseLabel = -1;\n@@ -3812,12 +3852,4 @@\n-                if (oneCase.pats.nonEmpty()) { \/\/ pats is empty for a \"default\" case\n-                    JCExpression expression = oneCase.pats.head;\n-                    String labelExpr = (String) expression.type.constValue();\n-                    Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n-                    Assert.checkNull(mapping);\n-                    int hashCode = labelExpr.hashCode();\n-\n-                    Set<String> stringSet = hashToString.get(hashCode);\n-                    if (stringSet == null) {\n-                        stringSet = new LinkedHashSet<>(1, 1.0f);\n-                        stringSet.add(labelExpr);\n-                        hashToString.put(hashCode, stringSet);\n+                if (oneCase.labels.head.isExpression()) {\n+                    if (TreeInfo.isNull(oneCase.labels.head)) {\n+                        nullCase = oneCase;\n+                        nullCaseLabel = casePosition;\n@@ -3825,2 +3857,15 @@\n-                        boolean added = stringSet.add(labelExpr);\n-                        Assert.check(added);\n+                        JCExpression expression = (JCExpression) oneCase.labels.head;\n+                        String labelExpr = (String) expression.type.constValue();\n+                        Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n+                        Assert.checkNull(mapping);\n+                        int hashCode = labelExpr.hashCode();\n+\n+                        Set<String> stringSet = hashToString.get(hashCode);\n+                        if (stringSet == null) {\n+                            stringSet = new LinkedHashSet<>(1, 1.0f);\n+                            stringSet.add(labelExpr);\n+                            hashToString.put(hashCode, stringSet);\n+                        } else {\n+                            boolean added = stringSet.add(labelExpr);\n+                            Assert.check(added);\n+                        }\n@@ -3901,1 +3946,8 @@\n-            stmtList.append(switch1);\n+\n+            if (nullCase != null) {\n+                stmtList.append(make.If(makeBinary(NE, make.Ident(dollar_s), makeNull()), switch1, make.Exec(make.Assign(make.Ident(dollar_tmp),\n+                                                             make.Literal(nullCaseLabel)).\n+                                                 setType(dollar_tmp.type))).setType(syms.intType));\n+            } else {\n+                stmtList.append(switch1);\n+            }\n@@ -3909,2 +3961,2 @@\n-                boolean isDefault = (oneCase.pats.isEmpty());\n-                JCExpression caseExpr;\n+                boolean isDefault = !oneCase.labels.head.isExpression();\n+                JCCaseLabel caseExpr;\n@@ -3913,2 +3965,4 @@\n-                else {\n-                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens(oneCase.pats.head).\n+                else if (oneCase == nullCase) {\n+                    caseExpr = make.Literal(nullCaseLabel);\n+                } else {\n+                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens((JCExpression) oneCase.labels.head).\n@@ -3918,1 +3972,1 @@\n-                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.nil() : List.of(caseExpr),\n+                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.of(make.DefaultCaseLabel()) : List.of(caseExpr),\n@@ -3952,0 +4006,64 @@\n+    private JCTree visitBoxedPrimitiveSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n+        JCExpression newSelector;\n+\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+            \/\/a switch over a boxed primitive, with a null case. Pick two constants that are\n+            \/\/not used by any branch in the case (c1 and c2), close to other constants that are\n+            \/\/used in the switch. Then do:\n+            \/\/switch ($selector != null ? $selector != c1 ? $selector : c2 : c1) {...}\n+            \/\/replacing case null with case c1\n+            Set<Integer> constants = new LinkedHashSet<>();\n+            JCCase nullCase = null;\n+\n+            for (JCCase c : cases) {\n+                if (TreeInfo.isNull(c.labels.head)) {\n+                    nullCase = c;\n+                } else if (!c.labels.head.hasTag(DEFAULTCASELABEL)) {\n+                    constants.add((int) c.labels.head.type.constValue());\n+                }\n+            }\n+\n+            Assert.checkNonNull(nullCase);\n+\n+            int nullValue = constants.isEmpty() ? 0 : constants.iterator().next();\n+\n+            while (constants.contains(nullValue)) nullValue++;\n+\n+            constants.add(nullValue);\n+            nullCase.labels.head = makeLit(syms.intType, nullValue);\n+\n+            int replacementValue = nullValue;\n+\n+            while (constants.contains(replacementValue)) replacementValue++;\n+\n+            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n+                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               selector.type,\n+                                               currentMethodSym);\n+            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n+            JCExpression nullValueReplacement =\n+                    make.Conditional(makeBinary(NE,\n+                                                 unbox(make.Ident(dollar_s), syms.intType),\n+                                                 makeLit(syms.intType, nullValue)),\n+                                     unbox(make.Ident(dollar_s), syms.intType),\n+                                     makeLit(syms.intType, replacementValue))\n+                        .setType(syms.intType);\n+            JCExpression nullCheck =\n+                    make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n+                                     nullValueReplacement,\n+                                     makeLit(syms.intType, nullValue))\n+                        .setType(syms.intType);\n+            newSelector = make.LetExpr(List.of(var), nullCheck).setType(syms.intType);\n+        } else {\n+            newSelector = unbox(selector, syms.intType);\n+        }\n+\n+        if (tree.hasTag(SWITCH)) {\n+            ((JCSwitch) tree).selector = newSelector;\n+        } else {\n+            ((JCSwitchExpression) tree).selector = newSelector;\n+        }\n+\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":156,"deletions":38,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -202,0 +202,5 @@\n+    \/**\n+     * A table to hold the access flags of the method parameters.\n+     *\/\n+    int[] parameterAccessFlags;\n+\n@@ -282,2 +287,1 @@\n-        allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &&\n-                Feature.SEALED_CLASSES.allowedInSource(source);\n+        allowSealedTypes = Feature.SEALED_CLASSES.allowedInSource(source);\n@@ -584,1 +588,1 @@\n-                                tsym.complete();\n+                                tsym.apiComplete();\n@@ -1095,0 +1099,1 @@\n+                        parameterAccessFlags = new int[numEntries];\n@@ -1103,1 +1108,3 @@\n-                            parameterNameIndices[index++] = nameIndex;\n+                            parameterNameIndices[index] = nameIndex;\n+                            parameterAccessFlags[index] = flags;\n+                            index++;\n@@ -2423,0 +2430,1 @@\n+        parameterAccessFlags = null;\n@@ -2432,0 +2440,4 @@\n+        if (parameterAccessFlags != null && index < parameterAccessFlags.length\n+                && parameterAccessFlags[index] != 0) {\n+            flags |= parameterAccessFlags[index];\n+        }\n@@ -2581,1 +2593,5 @@\n-\n+        if (c.isRecord()) {\n+            for (RecordComponent rc: c.getRecordComponents()) {\n+                rc.accessor = lookupMethod(c, rc.name, List.nil());\n+            }\n+        }\n@@ -2585,0 +2601,9 @@\n+    private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List<Type> argtypes) {\n+        for (Symbol s : tsym.members().getSymbolsByName(name, s -> s.kind == MTH)) {\n+            if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {\n+                return (MethodSymbol) s;\n+            }\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -1723,0 +1724,4 @@\n+        \/\/ Elide strictfp bit in class files\n+        if (target.obsoleteAccStrict())\n+            result &= ~STRICTFP;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1245,1 +1245,1 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        handleSwitch(tree, tree.selector, tree.cases, tree.patternSwitch);\n@@ -1290,1 +1290,1 @@\n-                handleSwitch(tree, tree.selector, tree.cases);\n+                handleSwitch(tree, tree.selector, tree.cases, tree.patternSwitch);\n@@ -1320,1 +1320,2 @@\n-    private void handleSwitch(JCTree swtch, JCExpression selector, List<JCCase> cases) {\n+    private void handleSwitch(JCTree swtch, JCExpression selector, List<JCCase> cases,\n+                              boolean patternSwitch) {\n@@ -1323,0 +1324,1 @@\n+        int switchStart = patternSwitch ? code.entryPoint() : -1;\n@@ -1352,3 +1354,3 @@\n-                if (l.head.pats.nonEmpty()) {\n-                    Assert.check(l.head.pats.size() == 1);\n-                    int val = ((Number)l.head.pats.head.type.constValue()).intValue();\n+                if (l.head.labels.head.isExpression()) {\n+                    Assert.check(l.head.labels.size() == 1);\n+                    int val = ((Number)((JCExpression) l.head.labels.head).type.constValue()).intValue();\n@@ -1426,0 +1428,6 @@\n+            if (switchEnv.info.cont != null) {\n+                Assert.check(patternSwitch);\n+                code.resolve(switchEnv.info.cont);\n+                code.resolve(code.branch(goto_), switchStart);\n+            }\n+\n@@ -2407,1 +2415,1 @@\n-        if (tree.type.asElement().isPrimitiveClass()) {\n+        if (tree.type.isPrimitiveClass()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-                .withMajorVersion(61)\n+                .withMajorVersion(62)\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}