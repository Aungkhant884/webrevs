{"files":[{"patch":"@@ -423,15 +423,0 @@\n-    \/**\n-     * Is this a *derived* reference projection symbol ??\n-     *\/\n-    public boolean isReferenceProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * If this is the symbol for a reference projection class, what is the class for which\n-     * this is a projection ??\n-     *\/\n-    public ClassSymbol valueProjection() {\n-        return null;\n-    }\n-\n@@ -548,2 +533,0 @@\n-     * 'outermost' being a lexical construct, should transcend\n-     *  projections\n@@ -558,1 +541,1 @@\n-        return (ClassSymbol) (prev!= null && prev.isReferenceProjection() ? prev.valueProjection() : prev);\n+        return (ClassSymbol) prev;\n@@ -1434,8 +1417,0 @@\n-        \/**\n-         * Does `this' symbolize a primitive class that would, under the translation\n-         * scheme in effect be lowered into two class files on a bifurcased basis ??\n-         *\/\n-        public boolean isSplitPrimitiveClass(Types types) {\n-            return types.splitPrimitiveClass && this.isPrimitiveClass();\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -105,12 +105,0 @@\n-    \/**\n-     * If true, the ClassWriter will split a primitive class declaration into two class files\n-     * P.ref.class and P.val.class (P.class for pure primitive classes)\n-     *\n-     * This is the default behavior, can be eoverridden with -XDunifiedValRefClass\n-     *\n-     * If false, we emit a single class for a primtive class 'P' and the reference projection and\n-     * value projection types are encoded in descriptors as LP; and QP; resperctively.\n-     *\/\n-\n-    public boolean splitPrimitiveClass;\n-\n@@ -142,1 +130,0 @@\n-        splitPrimitiveClass = false ; \/\/ options.isUnset(\"unifiedValRefClass\"); \/\/ Temporarely forcing the default\n@@ -1883,1 +1870,1 @@\n-                            return (dynamicTypeMayImplementAdditionalInterfaces(t.tsym))\n+                            return ((t.tsym.flags() & FINAL) == 0)\n@@ -4675,1 +4662,1 @@\n-        Assert.check(!dynamicTypeMayImplementAdditionalInterfaces(from.tsym));\n+        Assert.check((from.tsym.flags() & FINAL) != 0);\n@@ -4687,4 +4674,0 @@\n-    private boolean dynamicTypeMayImplementAdditionalInterfaces(TypeSymbol tsym) {\n-        return (tsym.flags() & FINAL) == 0 && !tsym.isReferenceProjection();\n-    }\n-\n@@ -5369,4 +5352,0 @@\n-            if (types.splitPrimitiveClass && ct.isReferenceProjection()) {\n-                append('$');\n-                append(types.names.ref);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3109,6 +3109,0 @@\n-        if (haveValue) {\n-            \/\/ widening coversion is a NOP for the VM due to subtyping relationship at class file level\n-            \/\/ where we bifurcate a primitive class into two class files.\n-            if (types.splitPrimitiveClass)\n-                return tree;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -825,2 +825,1 @@\n-    \/** Write \"inner classes\" attribute. If a primitive class happens to be an inner class,\n-     *  the reference projection class will also be an inner class.\n+    \/** Write \"inner classes\" attribute.\n@@ -830,2 +829,1 @@\n-        int icCountIdx = beginAttrs();\n-        int icCount = 0;\n+        databuf.appendChar(poolWriter.innerClasses.size());\n@@ -848,11 +846,0 @@\n-            icCount++;\n-            if (inner.isSplitPrimitiveClass(types)) {\n-                databuf.appendChar(poolWriter.putClass(inner.type.referenceProjection()));\n-                databuf.appendChar(\n-                        inner.owner.kind == TYP && !inner.name.isEmpty() ? poolWriter.putClass((ClassSymbol)inner.owner) : 0);\n-                databuf.appendChar(\n-                        !inner.name.isEmpty() ? poolWriter.putName(inner.name.append('$', names.ref)) : 0);\n-                flags = (char) ((flags & ~(ACC_PRIMITIVE | FINAL)) | ABSTRACT);\n-                databuf.appendChar(flags);\n-                icCount++;\n-            }\n@@ -860,1 +847,0 @@\n-        endAttrs(icCountIdx, icCount);\n@@ -885,26 +871,8 @@\n-        Set<ClassSymbol> nestedUnique = new LinkedHashSet<>();\n-        if (csym.owner.kind == PCK) {\n-            if (csym.isSplitPrimitiveClass(types)) {\n-                \/\/ reference projection is the host\n-            } else if (csym.isReferenceProjection()) {\n-                ClassSymbol valueProjection = csym.valueProjection();\n-                nestedUnique.add(valueProjection);\n-                listNested(valueProjection, nestedUnique);\n-            } else {\n-                listNested(csym, nestedUnique);\n-            }\n-            if (!nestedUnique.isEmpty()) {\n-                int alenIdx = writeAttr(names.NestMembers);\n-                int nmcIdx = beginAttrs();\n-                int nmc = 0;\n-                for (ClassSymbol s : nestedUnique) {\n-                    databuf.appendChar(poolWriter.putClass(s));\n-                    nmc++;\n-                    if (s.isSplitPrimitiveClass(types) && s.owner.kind != PCK) {\n-                        databuf.appendChar(poolWriter.putClass(s.type.referenceProjection()));\n-                        nmc++;\n-                    }\n-                }\n-                endAttrs(nmcIdx, nmc);\n-                endAttr(alenIdx);\n-                return 1;\n+        ListBuffer<ClassSymbol> nested = new ListBuffer<>();\n+        listNested(csym, nested);\n+        Set<ClassSymbol> nestedUnique = new LinkedHashSet<>(nested);\n+        if (csym.owner.kind == PCK && !nestedUnique.isEmpty()) {\n+            int alenIdx = writeAttr(names.NestMembers);\n+            databuf.appendChar(nestedUnique.size());\n+            for (ClassSymbol s : nestedUnique) {\n+                databuf.appendChar(poolWriter.putClass(s));\n@@ -912,0 +880,2 @@\n+            endAttr(alenIdx);\n+            return 1;\n@@ -920,1 +890,1 @@\n-        if (csym.owner.kind != PCK || csym.isSplitPrimitiveClass(types)) {\n+        if (csym.owner.kind != PCK) {\n@@ -922,6 +892,1 @@\n-            ClassSymbol outerMost = csym.outermostClass();\n-            if (outerMost.isSplitPrimitiveClass(types)) {\n-                databuf.appendChar(poolWriter.putClass(outerMost.type.referenceProjection()));\n-            } else {\n-                databuf.appendChar(poolWriter.putClass(outerMost));\n-            }\n+            databuf.appendChar(poolWriter.putClass(csym.outermostClass()));\n@@ -934,1 +899,1 @@\n-    private void listNested(Symbol sym, Set<ClassSymbol> seen) {\n+    private void listNested(Symbol sym, ListBuffer<ClassSymbol> seen) {\n@@ -1534,3 +1499,0 @@\n-        if (c.isSplitPrimitiveClass(types)) {\n-            writeClassInternal(getReferenceProjection(c));\n-        }\n@@ -1540,55 +1502,0 @@\n-        \/\/ where\n-        private static ClassSymbol getReferenceProjection(ClassSymbol c) {\n-\n-            ClassSymbol projection;\n-            ClassType projectedType;\n-\n-            ClassType ct = (ClassType) c.type;\n-            \/* Note, the class type associated with the Primitive$ref.class is NOT a reference projection type. A reference projection\n-             * type gets created by using Primitive.ref notation in the source file or while reading in a descriptor of such a type\n-             * from the class file. Here we are generating the Primitive$ref.class for the VM's benefit and it is a reference class.\n-             *\/\n-            projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null, ct.getMetadata(), Flavor.L_TypeOf_L);\n-            projectedType.allparams_field = ct.allparams_field;\n-            projectedType.supertype_field = ct.supertype_field;\n-\n-            projectedType.interfaces_field = ct.interfaces_field;\n-            projectedType.all_interfaces_field = ct.all_interfaces_field;\n-            projectedType.projection = null;\n-\n-            Name projectionName = c.name.append('$', c.name.table.names.ref);\n-            long projectionFlags = (c.flags() & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | (ABSTRACT | SEALED);\n-\n-            projection = new ClassSymbol(projectionFlags, projectionName, projectedType, c.owner) {\n-                @Override\n-                public boolean isReferenceProjection() {\n-                    return true;\n-                }\n-\n-                @Override\n-                public ClassSymbol valueProjection() {\n-                    return c;\n-                }\n-            };\n-            projection.members_field = WriteableScope.create(projection);\n-            for (Symbol s : c.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    clone = refVar;\n-                }\n-                projection.members_field.enter(clone);\n-            }\n-            projection.completer = Completer.NULL_COMPLETER;\n-            projection.sourcefile = c.sourcefile;\n-            projection.flatname = c.flatname.append('$', c.name.table.names.ref);\n-            projection.permitted = List.of(c);\n-            projectedType.tsym = projection;\n-            return projection;\n-        }\n-\n@@ -1639,2 +1546,2 @@\n-        Type supertype = c.isSplitPrimitiveClass(types) ? c.type.referenceProjection() : types.supertype(c.type);\n-        List<Type> interfaces = c.isSplitPrimitiveClass(types) ? List.nil() : types.interfaces(c.type);\n+        Type supertype = types.supertype(c.type);\n+        List<Type> interfaces = types.interfaces(c.type);\n@@ -1673,16 +1580,14 @@\n-        boolean referenceProjection = c.isReferenceProjection();\n-        if (!referenceProjection) {\n-            for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {\n-                switch (sym.kind) {\n-                    case VAR:\n-                        fieldsCount++;\n-                        break;\n-                    case MTH:\n-                        if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n-                        break;\n-                    case TYP:\n-                        poolWriter.enterInner((ClassSymbol)sym);\n-                        break;\n-                    default:\n-                        Assert.error();\n-                }\n+\n+        for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {\n+            switch (sym.kind) {\n+                case VAR:\n+                    fieldsCount++;\n+                    break;\n+                case MTH:\n+                    if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n+                    break;\n+                case TYP:\n+                    poolWriter.enterInner((ClassSymbol)sym);\n+                    break;\n+                default:\n+                    Assert.error();\n@@ -1690,0 +1595,1 @@\n+        }\n@@ -1691,4 +1597,3 @@\n-            if (c.trans_local != null) {\n-                for (ClassSymbol local : c.trans_local) {\n-                    poolWriter.enterInner(local);\n-                }\n+        if (c.trans_local != null) {\n+            for (ClassSymbol local : c.trans_local) {\n+                poolWriter.enterInner(local);\n@@ -1699,2 +1604,1 @@\n-        if (!referenceProjection)\n-            writeFields(c.members());\n+        writeFields(c.members());\n@@ -1702,2 +1606,1 @@\n-        if (!referenceProjection)\n-            writeMethods(c.members());\n+        writeMethods(c.members());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":37,"deletions":134,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -2274,1 +2274,1 @@\n-        \/\/ inline widening conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n+        \/\/ inline widening conversion should not require a checkcast but we issue one per VM's request as of now (see || true below)\n@@ -2277,1 +2277,1 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.splitPrimitiveClass || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type)) &&\n+            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n@@ -2347,1 +2347,1 @@\n-            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, !types.splitPrimitiveClass && tree.selected.type.isPrimitiveClass()));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -233,3 +233,0 @@\n-        if (c.isReferenceProjection()) {\n-            c = c.valueProjection();\n-        }\n@@ -381,3 +378,0 @@\n-                    if (types.splitPrimitiveClass && ct.isReferenceProjection()) {\n-                        name = name.append('$', names.ref);\n-                    }\n@@ -517,5 +511,4 @@\n-        signatureGen.assembleSig(t.isPrimitiveClass() && types.splitPrimitiveClass ? t.referenceProjection() : types.supertype(t));\n-        if (!t.isPrimitiveClass() || !types.splitPrimitiveClass) {\n-            for (Type i : types.interfaces(t))\n-                signatureGen.assembleSig(i);\n-        }\n+        signatureGen.assembleSig(types.supertype(t));\n+        for (Type i : types.interfaces(t))\n+            signatureGen.assembleSig(i);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -325,2 +325,1 @@\n-        \/* Rewrite any accesses of the form V.ref.member to ((V) V.ref).member OR\n-           if a static member is being selected via a V.ref as a TYP, rewrite\n+        \/* If a static member is being selected via a V.ref as a TYP, rewrite\n@@ -340,5 +339,0 @@\n-                        } else {\n-                            if (types.splitPrimitiveClass) {\n-                                fieldAccess.selected =\n-                                        make.TypeCast(types.erasure(selectedType.valueProjection()), fieldAccess.selected);\n-                            } \/\/ else members of Foo can be accessed via LFoo or QFoo at the VM level without a cast.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,4 +56,4 @@\n-        \"         6: anewarray     #3                  \/\/ class ArrayCreationWithQuestion$VT$ref\",\n-        \"        17: anewarray     #3                  \/\/ class ArrayCreationWithQuestion$VT$ref\",\n-        \"        28: anewarray     #12                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n-        \"        39: anewarray     #12                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n+        \"         6: anewarray     #3                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        \"        17: anewarray     #3                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        \"        28: anewarray     #11                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n+        \"        39: anewarray     #11                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ArrayCreationWithQuestion.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        ClassFile cls = ClassFile.read(AttributesTest.class.getResourceAsStream(\"AttributesTest$1V$ref.class\"));\n+        ClassFile cls = ClassFile.read(AttributesTest.class.getResourceAsStream(\"AttributesTest$1V.class\"));\n@@ -56,1 +56,1 @@\n-        if (inners.number_of_classes != 2) {\n+        if (inners.number_of_classes != 1) {\n@@ -63,4 +63,0 @@\n-        name = inners.classes[1].getInnerName(cls.constant_pool);\n-        if (!name.equals(\"V$ref\")) {\n-            throw new AssertionError(\"Unexpected inner class \" + name);\n-        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AttributesTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-        if (splits.length != 4) {\n+        if (splits.length != 9) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/BoxValCastTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors$ref;\"))\n+                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors;\"))\n@@ -57,1 +57,1 @@\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors$ref;\"))\n+                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"LCheckFieldDescriptors;\"))\n@@ -61,1 +61,1 @@\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors$ref;\"))\n+                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors;\"))\n@@ -65,1 +65,1 @@\n-                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors$ref;\"))\n+                if (!fld.descriptor.getValue(cls.constant_pool).equals(\"[LCheckFieldDescriptors;\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckFieldDescriptors.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8267542\n- * @summary Verify that necessary checkcasts are generated while acessing an instance\n- *          field\/method through a reference projection.\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile CheckNeededCastInMemberAccess.java\n- * @run main CheckNeededCastInMemberAccess\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Code_attribute.InvalidIndex;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import java.util.Arrays;\n-import java.util.stream.Collectors;\n-import java.util.stream.StreamSupport;\n-\n-public class CheckNeededCastInMemberAccess {\n-\n-    static primitive class Point {\n-        int x = 0, y = 0;\n-        void foo() {\n-            Point p0 = new Point();\n-            int x0 = p0.x;\n-            p0.foo();\n-            Point.ref p1 = null;\n-            int x1 = p1.x;\n-            p1.foo();\n-        }\n-    }\n-\n-    public static void main(String[] args)\n-            throws IOException, ConstantPoolException, InvalidDescriptor, InvalidIndex {\n-        new CheckNeededCastInMemberAccess()\n-                .checkClassFile(new File(System.getProperty(\"test.classes\", \".\"),\n-                    CheckNeededCastInMemberAccess.Point.class.getName() + \".class\"));\n-    }\n-\n-    void checkClassFile(File file)\n-            throws IOException, ConstantPoolException, InvalidDescriptor, InvalidIndex {\n-        ClassFile classFile = ClassFile.read(file);\n-        ConstantPool constantPool = classFile.constant_pool;\n-\n-        Method method = Arrays.stream(classFile.methods)\n-                              .filter(m -> getName(m, constantPool)\n-                                               .equals(\"foo\"))\n-                              .findAny()\n-                              .get();\n-        String expectedInstructions = \"\"\"\n-                                    invokestatic\n-                                    astore_1\n-                                    aload_1\n-                                    getfield\n-                                    istore_2\n-                                    aload_1\n-                                    invokevirtual\n-                                    aconst_null\n-                                    astore_3\n-                                    aload_3\n-                                    checkcast\n-                                    getfield\n-                                    istore\n-                                    aload_3\n-                                    checkcast\n-                                    invokevirtual\n-                                    return\n-                                      \"\"\";\n-        Code_attribute code = (Code_attribute) method.attributes\n-                .get(Attribute.Code);\n-        String actualInstructions = printCode(code);\n-        if (!expectedInstructions.equals(actualInstructions)) {\n-            throw new AssertionError(\"Unexpected instructions found:\\n\" +\n-                                     actualInstructions);\n-        }\n-    }\n-\n-    String printCode(Code_attribute code) {\n-        return StreamSupport.stream(code.getInstructions().spliterator(), false)\n-                            .map(Instruction::getMnemonic)\n-                            .collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n-    }\n-\n-    String getName(Method m, ConstantPool constantPool) {\n-        try {\n-            return m.getName(constantPool);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckNeededCastInMemberAccess.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDunifiedValRefClass -XDallowWithFieldOperator Point.java Rectangle.java\n+ * @compile -XDallowWithFieldOperator Point.java Rectangle.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ConsumeUnifiedClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test nest host - member attributes\n- * @bug 8244314\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -XDallowWithFieldOperator Point.java\n- * @run main InlineNestingAttributesTest\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-public class InlineNestingAttributesTest {\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(InlineNestingAttributesTest.class.getResourceAsStream(\"Point.class\"));\n-        ClassFile clsProj = ClassFile.read(InlineNestingAttributesTest.class.getResourceAsStream(\"Point$ref.class\"));\n-\n-        NestMembers_attribute nestMembers = (NestMembers_attribute)clsProj.attributes.get(Attribute.NestMembers);\n-        CONSTANT_Class_info[] members = nestMembers != null ? nestMembers.getChildren(clsProj.constant_pool) : new CONSTANT_Class_info[0];\n-\n-        if (members.length != 1 || !members[0].getName().equals(\"Point\")) {\n-            throw new RuntimeException(\"Nest members not present\");\n-        }\n-\n-        NestHost_attribute nestHost = (NestHost_attribute)cls.attributes.get(Attribute.NestHost);\n-        CONSTANT_Class_info host = nestHost != null ? nestHost.getNestTop(cls.constant_pool) : null;\n-\n-        if (host == null || !host.getName().equals(\"Point$ref\")) {\n-            throw new RuntimeException(\"Nest host not present\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InlineNestingAttributesTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n- * @compile -XDunifiedValRefClass NoUnnecessaryCast.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/NoUnnecessaryCast.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        \"         3: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT$ref;\\\"\",\n+        \"         3: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT;\\\"\",\n@@ -61,1 +61,1 @@\n-        \"        19: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT$ref;\\\"\",\n+        \"        19: ldc           #13                 \/\/ class \\\"[LProjectedArrayDotClass$VT;\\\"\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ProjectedArrayDotClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check to see if the reference projection is a sealed class\n- * @bug 8244315\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -XDallowWithFieldOperator Point.java\n- * @run main ProjectionSealed\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-public class ProjectionSealed {\n-    public static void main(String[] args) throws Exception {\n-        ClassFile clsProj = ClassFile.read(ProjectionSealed.class.getResourceAsStream(\"Point$ref.class\"));\n-\n-        PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute)clsProj.attributes.get(Attribute.PermittedSubclasses);\n-        CONSTANT_Class_info[] infos = permitted != null ? permitted.getSubtypes(clsProj.constant_pool) : new CONSTANT_Class_info[0];\n-\n-        if (infos.length != 1 || !infos[0].getName().equals(\"Point\")) {\n-            throw new RuntimeException(\"Sealed classes not present\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ProjectionSealed.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -47,1 +47,1 @@\n-        if (!tName.equals(\"RefDotClass$ref\"))\n+        if (!tName.equals(\"RefDotClass.ref\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RefDotClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        ClassFile cls = ClassFile.read(SignatureTest.class.getResourceAsStream(\"SignatureTest$ref.class\"));\n+        ClassFile cls = ClassFile.read(SignatureTest.class.getResourceAsStream(\"SignatureTest.class\"));\n@@ -43,6 +43,0 @@\n-\n-        cls = ClassFile.read(SignatureTest.class.getResourceAsStream(\"SignatureTest.class\"));\n-        signature = (Signature_attribute) cls.attributes.get(Attribute.Signature);\n-        s = signature.getSignature(cls.constant_pool);\n-        if (!s.equals(\"<T:Ljava\/lang\/Object;>LSignatureTest$ref<TT;>;\"))\n-            throw new AssertionError(\"Unexpected signature: \" + s);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SignatureTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8265423\n- * @summary Experimental support for generating a single class file per primitive class\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile SplitPrimitiveClassBytecodeTest.java\n- * @run main SplitPrimitiveClassBytecodeTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class SplitPrimitiveClassBytecodeTest {\n-\n-    public primitive class X {\n-\n-        X.ref xr = null;\n-\n-        public void foo(X.ref[] xra, X[] xa) {\n-            xa = new X[10];\n-            xra = new X.ref[10];\n-            xra[0] = xa[0];\n-            xa[1] = xra[0];\n-            Class<?> c = X.class;\n-            c = X.ref.class;\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new SplitPrimitiveClassBytecodeTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"SplitPrimitiveClassBytecodeTest$X.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-        \/\/ check field\n-        \"final SplitPrimitiveClassBytecodeTest$X$ref xr;\",\n-        \"descriptor: LSplitPrimitiveClassBytecodeTest$X$ref;\",\n-        \"flags: (0x0010) ACC_FINAL\",\n-\n-        \/\/ check method\n-        \"public void foo(SplitPrimitiveClassBytecodeTest$X$ref[], SplitPrimitiveClassBytecodeTest$X[]);\",\n-        \"descriptor: ([LSplitPrimitiveClassBytecodeTest$X$ref;[QSplitPrimitiveClassBytecodeTest$X;)V\",\n-        \" 0: bipush        10\",\n-        \" 2: anewarray     #11                 \/\/ class \\\"QSplitPrimitiveClassBytecodeTest$X;\\\"\",\n-        \" 5: astore_2\",\n-        \" 6: bipush        10\",\n-        \" 8: anewarray     #13                 \/\/ class SplitPrimitiveClassBytecodeTest$X$ref\",\n-        \"11: astore_1\",\n-        \"12: aload_1\",\n-        \"13: iconst_0\",\n-        \"14: aload_2\",\n-        \"15: iconst_0\",\n-        \"16: aaload\",\n-        \"17: aastore\",\n-        \"18: aload_2\",\n-        \"19: iconst_1\",\n-        \"20: aload_1\",\n-        \"21: iconst_0\",\n-        \"22: aaload\",\n-        \"23: checkcast     #11                 \/\/ class \\\"QSplitPrimitiveClassBytecodeTest$X;\\\"\",\n-        \"26: aastore\",\n-        \"27: ldc           #1                  \/\/ class SplitPrimitiveClassBytecodeTest$X\",\n-        \"29: astore_3\",\n-        \"30: ldc           #13                 \/\/ class SplitPrimitiveClassBytecodeTest$X$ref\",\n-        \"32: astore_3\",\n-        \"33: return\",\n-         });\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassBytecodeTest.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8265423\n- * @summary Experimental support for generating a single class file per primitive class\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @run main SplitPrimitiveClassInnerClassesTest\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-public class SplitPrimitiveClassInnerClassesTest {\n-\n-    primitive class V<T> implements java.io.Serializable {}\n-\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(SplitPrimitiveClassInnerClassesTest.class.getResourceAsStream(\"SplitPrimitiveClassInnerClassesTest.class\"));\n-\n-        if (cls == null) {\n-            throw new AssertionError(\"Could not locate the class files\");\n-        }\n-\n-        \/* Check emission of inner class attribute *\/\n-        InnerClasses_attribute inners = (InnerClasses_attribute) cls.attributes.get(Attribute.InnerClasses);\n-        if (inners == null) {\n-            throw new AssertionError(\"Missing inner class attribute\");\n-        }\n-        boolean foundV = false, foundVref = false;\n-        for (int i = 0; i < inners.number_of_classes; i++) {\n-            String name = inners.classes[i].getInnerName(cls.constant_pool);\n-            if (name.equals(\"V\"))\n-                foundV = true;\n-            else if (name.equals(\"V$ref\"))\n-                foundVref = true;\n-        }\n-        if (!foundV || !foundVref) {\n-            throw new AssertionError(\"Incorrect inner class attribute\");\n-        }\n-\n-        \/\/ Test signature attribute\n-        cls = ClassFile.read(SplitPrimitiveClassInnerClassesTest.class.getResourceAsStream(\"SplitPrimitiveClassInnerClassesTest$V.class\"));\n-        Signature_attribute signature = (Signature_attribute)cls.attributes.get(Attribute.Signature);\n-        String sign =  signature.getSignature(cls.constant_pool);\n-        if (sign == null || !sign.equals(\"<T:Ljava\/lang\/Object;>LSplitPrimitiveClassInnerClassesTest$V$ref<TT;>;\")) {\n-            throw new RuntimeException(\"Wrong signature \" + sign);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassInnerClassesTest.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8265423\n- * @summary Experimental support for generating a single class file per primitive class\n- * @compile SplitPrimitiveClassNestHostTest.java\n- * @run main SplitPrimitiveClassNestHostTest\n- *\/\n-\n-import java.util.Arrays;\n-\n-public primitive class SplitPrimitiveClassNestHostTest implements java.io.Serializable {\n-\n-    primitive class Inner {}\n-\n-    public static void main(String [] args) {\n-\n-        \/\/ check wiring of super types.\n-        Class<?> superClass = SplitPrimitiveClassNestHostTest.class.getSuperclass();\n-        if (!superClass.equals(\n-                    SplitPrimitiveClassNestHostTest.class.asPrimaryType()))\n-            throw new AssertionError(\"Wrong superclass for SplitPrimitiveClassNestHostTest\");\n-\n-        Class<?> [] superInterfaces = SplitPrimitiveClassNestHostTest.class.getInterfaces();\n-        if (superInterfaces.length != 1)\n-            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest\");\n-\n-        if (!superInterfaces[0].equals(PrimitiveObject.class))\n-            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest\");\n-\n-        \/\/ check super types of ref.class\n-        if (!superClass.getSuperclass().equals(Object.class))\n-            throw new AssertionError(\"Wrong superclass for SplitPrimitiveClassNestHostTest.ref\");\n-        superInterfaces = superClass.getInterfaces();\n-        if (superInterfaces.length != 1)\n-            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest.ref\");\n-\n-        if (!superInterfaces[0].equals(java.io.Serializable.class))\n-            throw new AssertionError(\"Wrong super interfaces for SplitPrimitiveClassNestHostTest.ref\");\n-\n-\n-        Class<?> nestHost = SplitPrimitiveClassNestHostTest.class.getNestHost();\n-        if (!nestHost.equals(SplitPrimitiveClassNestHostTest.class.asPrimaryType()))\n-            throw new AssertionError(\"Wrong nest host: \" + nestHost);\n-\n-        Class<?> [] members = nestHost.getNestMembers();\n-        if (members.length != 4)\n-            throw new AssertionError(\"Wrong member count: \" + members.length);\n-\n-        if (!members[0].equals(nestHost))\n-            throw new AssertionError(\"Wrong initial member: \" + members[0]);\n-\n-        if (!members[1].equals(SplitPrimitiveClassNestHostTest.class))\n-            throw new AssertionError(\"Wrong member[1]: \" + members[1]);\n-\n-        if (!members[1].getNestHost().equals(nestHost))\n-            throw new AssertionError(\"Wrong nest host for member[1]: \" + members[1]);\n-\n-        if (!Arrays.equals(members[1].getNestMembers(), members))\n-            throw new AssertionError(\"Wrong nest members for member[1]: \" + members[1]);\n-\n-        if (!members[2].equals(Inner.class))\n-            throw new AssertionError(\"Wrong member[2]: \" + members[2]);\n-\n-        if (!members[2].getNestHost().equals(nestHost))\n-            throw new AssertionError(\"Wrong nest host for member[2]: \" + members[2]);\n-\n-        if (!Arrays.equals(members[2].getNestMembers(), members))\n-            throw new AssertionError(\"Wrong nest members for member[2]: \" + members[2]);\n-\n-        if (!members[3].equals(Inner.class.asPrimaryType()))\n-            throw new AssertionError(\"Wrong member[3]: \" + members[3]);\n-\n-        if (!members[3].getNestHost().equals(nestHost))\n-            throw new AssertionError(\"Wrong nest host for member[3]: \" + members[3]);\n-\n-        if (!Arrays.equals(members[3].getNestMembers(), members))\n-            throw new AssertionError(\"Wrong nest members for member[3]: \" + members[3]);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassNestHostTest.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -55,11 +55,2 @@\n-\n-\n-\n-\n-        \/\/ Check that V's super class is V.ref in class file.\n-        Class<?> vrefCls = inln_o.getClass().getSuperclass();\n-        if (!vrefCls.getCanonicalName().equals(\"TopInterfaceTest.V$ref\"))\n-            throw new AssertionError(\"Wrong super type for value type\");\n-\n-        \/\/ Check that no injection has happened for jlO itself.\n-        Class<?> jlo = vrefCls.getSuperclass();\n+        \/\/ Check that V's super class is Object in class file.\n+        Class<?> jlo = inln_o.getClass().getSuperclass();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TopInterfaceTest.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary V.ref class should not inadvertently carry over attributes from V.class\n+ * @summary Verify that primitive class declarations can be annotated\n@@ -104,27 +104,0 @@\n-\n-        \/\/ Verify that annotations are not carried over to the reference projection\n-        cls = ClassFile.read(UnannotatedProjection.class.getResourceAsStream(\"UnannotatedProjection$V$ref.class\"));\n-\n-        if (cls == null) {\n-            throw new AssertionError(\"Could not locate the class files\");\n-        }\n-\n-        inv = (RuntimeInvisibleAnnotations_attribute) cls.attributes.get(Attribute.RuntimeInvisibleAnnotations);\n-        if (inv != null) {\n-            throw new AssertionError(\"Annotations carried over to projection!\");\n-        }\n-\n-        invta = (RuntimeInvisibleTypeAnnotations_attribute) cls.attributes.get(Attribute.RuntimeInvisibleTypeAnnotations);\n-        if (invta != null) {\n-            throw new AssertionError(\"Annotations carried over to projection!\");\n-        }\n-\n-        v = (RuntimeVisibleAnnotations_attribute) cls.attributes.get(Attribute.RuntimeVisibleAnnotations);\n-        if (v != null) {\n-            throw new AssertionError(\"Annotations carried over to projection!\");\n-        }\n-\n-        vta = (RuntimeVisibleTypeAnnotations_attribute) cls.attributes.get(Attribute.RuntimeVisibleTypeAnnotations);\n-        if (vta != null) {\n-            throw new AssertionError(\"Annotations carried over to projection!\");\n-        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnannotatedProjection.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @compile -XDunifiedValRefClass UnifiedPrimitiveClassBytecodeTest.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassBytecodeTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- * @compile -XDunifiedValRefClass UnifiedPrimitiveClassInnerClassesTest.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassInnerClassesTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @compile -XDunifiedValRefClass UnifiedPrimitiveClassNestHostTest.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassNestHostTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}