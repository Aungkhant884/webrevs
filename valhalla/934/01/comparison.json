{"files":[{"patch":"@@ -357,5 +357,0 @@\n-        \/**\n-         * Used for instances of {@link WithFieldTree}.\n-         *\/\n-        WITH_FIELD(WithFieldTree.class),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -559,8 +559,0 @@\n-\n-    \/**\n-     * Visits a {@code WithFieldTree} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     *\/\n-    R visitWithField(WithFieldTree node, P p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-\/**\n- * A tree node for a {@code withfield} expression.\n- *\n- * For example:\n- * <pre>\n- *   x = __WithField(x.x, val)\n- * <\/pre>\n- *\n- * @since 1.11\n- *\/\n-public interface WithFieldTree extends ExpressionTree {\n-    \/**\n-     * Returns the field being updated.\n-     * @return the field\n-     *\/\n-    ExpressionTree getField();\n-\n-    \/**\n-     * Returns the value to which the field is updated.\n-     * @return the value\n-     *\/\n-    ExpressionTree getValue();\n-}\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/WithFieldTree.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -239,14 +239,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     *\/\n-    @Override\n-    public R visitWithField(WithFieldTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -307,16 +307,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     *\/\n-    @Override\n-    public R visitWithField(WithFieldTree node, P p) {\n-        R r = scan(node.getField(), p);\n-        r = scanAndReduce(node.getValue(), p, r);\n-        return r;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -604,2 +604,1 @@\n-        Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+        for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n@@ -625,1 +624,1 @@\n-        if (names.isInitOrVNew(methodName))\n+        if (names.isInit(methodName))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-            String ms = s.isInitOrVNew() ? s.owner.name.toString() : s.name.toString();\n+            String ms = s.isInit() ? s.owner.name.toString() : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.HashMap;\n@@ -359,1 +358,4 @@\n-        if (isValueObjectFactory()) {\n+        \/*if (isValueClassConst()) {\n+            \/\/ previously we had vnew methods which had a return type, not `void`, and we were attaching metadata to it\n+            \/\/ like nullness for example. Type `void` doesn't accept metadata so if we need to state that the result of\n+            \/\/ invoking a value class constructor is never null, we will need another way.\n@@ -363,2 +365,2 @@\n-        }\n-        if (isInitOrVNew() && owner.hasOuterInstance()) {\n+        }*\/\n+        if (isInit() && owner.hasOuterInstance()) {\n@@ -489,2 +491,2 @@\n-    public boolean isValueObjectFactory() {\n-        return name == name.table.names.vnew && this.type.getReturnType().tsym == this.owner;\n+    public boolean isValueClassConst() {\n+        return name == name.table.names.init && this.owner.isValueClass();\n@@ -496,1 +498,1 @@\n-        return isInitOrVNew() && ((flags() & IMPLICIT) != 0);\n+        return isInit() && ((flags() & IMPLICIT) != 0);\n@@ -501,2 +503,2 @@\n-    public boolean isInitOrVNew() {\n-        return name.table.names.isInitOrVNew(name);\n+    public boolean isInit() {\n+        return name.table.names.isInit(name);\n@@ -1715,1 +1717,1 @@\n-                        if (s.isInitOrVNew()) {\n+                        if (s.isInit()) {\n@@ -2049,1 +2051,1 @@\n-                String s = isInitOrVNew()\n+                String s = isInit()\n@@ -2111,1 +2113,1 @@\n-            if (isInitOrVNew() || _other.kind != MTH) return false;\n+            if (isInit() || _other.kind != MTH) return false;\n@@ -2180,1 +2182,1 @@\n-            if (isInitOrVNew() || _other.kind != MTH) return false;\n+            if (isInit() || _other.kind != MTH) return false;\n@@ -2304,1 +2306,1 @@\n-            if (isInitOrVNew())\n+            if (isInit())\n@@ -2477,1 +2479,1 @@\n-                if (refSym.isInitOrVNew()) {\n+                if (refSym.isInit()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-                    !s.isInitOrVNew())\n+                    !s.isInit())\n@@ -245,1 +245,1 @@\n-                    (s.kind == MTH && !s.isInitOrVNew() &&\n+                    (s.kind == MTH && !s.isInit() &&\n@@ -247,1 +247,1 @@\n-                    (s.kind == MTH && s.isInitOrVNew()))\n+                    (s.kind == MTH && s.isInit()))\n@@ -1025,1 +1025,1 @@\n-                    } else if (exsym.isInitOrVNew()) {\n+                    } else if (exsym.isInit()) {\n@@ -1132,1 +1132,1 @@\n-                    if (tree.sym.isInitOrVNew()) {\n+                    if (tree.sym.isInit()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -977,1 +977,1 @@\n-                        !names.isInitOrVNew(t.name) &&\n+                        !names.isInit(t.name) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-            ((names.isInitOrVNew(owner.name) ||    \/\/ i.e. we are in a constructor\n+            ((names.isInit(owner.name) ||    \/\/ i.e. we are in a constructor\n@@ -1084,1 +1084,1 @@\n-                if (names.isInitOrVNew(tree.name)) {\n+                if (names.isInit(tree.name)) {\n@@ -1207,1 +1207,1 @@\n-                if (names.isInitOrVNew(tree.name) && owner.type != syms.objectType) {\n+                if (names.isInit(tree.name) && owner.type != syms.objectType) {\n@@ -2713,1 +2713,1 @@\n-            if (enclMethod != null && names.isInitOrVNew(enclMethod.name)) {\n+            if (enclMethod != null && names.isInit(enclMethod.name)) {\n@@ -3605,2 +3605,1 @@\n-                    Name constructorName = owner.isConcreteValueClass() ? names.vnew : names.init;\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(constructorName)) {\n+                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n@@ -3671,4 +3670,0 @@\n-                \/\/ TODO - a bit hacky but...\n-                if (lhsSym != null && lhsSym.isConcreteValueClass() && that.name == names.init) {\n-                    that.name = names.vnew;\n-                }\n@@ -3763,1 +3758,1 @@\n-            that.sym = refSym.isInitOrVNew() ? refSym.baseSymbol() : refSym;\n+            that.sym = refSym.isInit() ? refSym.baseSymbol() : refSym;\n@@ -4825,1 +4820,1 @@\n-            if (!names.isInitOrVNew(sym.name) || tree.hasTag(REFERENCE)) {\n+            if (!names.isInit(sym.name) || tree.hasTag(REFERENCE)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -819,1 +819,1 @@\n-                    } else if (s.isInitOrVNew()) {\n+                    } else if (s.isInit()) {\n@@ -1116,1 +1116,1 @@\n-                (s.isInitOrVNew() ||\n+                (s.isInit() ||\n@@ -1342,1 +1342,1 @@\n-            if (names.isInitOrVNew(sym.name)) {\n+            if (names.isInit(sym.name)) {\n@@ -1747,1 +1747,1 @@\n-                    env.enclMethod != null && names.isInitOrVNew(env.enclMethod.name);\n+                    env.enclMethod != null && names.isInit(env.enclMethod.name);\n@@ -2357,1 +2357,1 @@\n-                (env.info.isAnonymousDiamond && !m.isInitOrVNew() && !m.isPrivate());\n+                (env.info.isAnonymousDiamond && !m.isInit() && !m.isPrivate());\n@@ -2930,1 +2930,1 @@\n-                     !s.isInitOrVNew();\n+                     !s.isInit();\n@@ -2989,1 +2989,1 @@\n-                     !s.isInitOrVNew();\n+                     !s.isInit();\n@@ -3872,1 +3872,1 @@\n-                if (s.kind == MTH && !s.isInitOrVNew())\n+                if (s.kind == MTH && !s.isInit())\n@@ -3880,1 +3880,1 @@\n-                if (s.kind == MTH && s.isInitOrVNew())\n+                if (s.kind == MTH && s.isInit())\n@@ -3899,1 +3899,1 @@\n-                        (s.kind == MTH && !s.isInitOrVNew() &&\n+                        (s.kind == MTH && !s.isInit() &&\n@@ -3901,1 +3901,1 @@\n-                        (s.kind == MTH && s.isInitOrVNew())) {\n+                        (s.kind == MTH && s.isInit())) {\n@@ -5267,1 +5267,1 @@\n-                    if (sym.isInitOrVNew() &&\n+                    if (sym.isInit() &&\n@@ -5295,1 +5295,1 @@\n-                        if (sym.isInitOrVNew()) {\n+                        if (sym.isInit()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-import java.util.Comparator;\n@@ -344,1 +343,1 @@\n-                Name name = msym.name.table.names.isInitOrVNew(msym.name) ?\n+                Name name = msym.name.table.names.isInit(msym.name) ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -356,2 +356,1 @@\n-            \/\/ TODO - can <vnew> exist in this context?\n-            if ((init = names.isInitOrVNew(owner.name)) || owner.name == names.clinit) {\n+            if ((init = names.isInit(owner.name)) || owner.name == names.clinit) {\n@@ -1672,2 +1671,1 @@\n-                Name constructorName = csym.isConcreteValueClass() ? names.vnew : names.init;\n-                for (Symbol s : csym.members_field.getSymbolsByName(constructorName)) {\n+                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {\n@@ -1777,1 +1775,1 @@\n-                    && !names.isInitOrVNew(sym.name);\n+                    && !names.isInit(sym.name);\n@@ -1899,2 +1897,0 @@\n-                } else if (methodName.equals(\"<vnew>\")) {\n-                    methodName = \"vnew\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1148,1 +1148,1 @@\n-        } else if (names.isInitOrVNew(sym.name) && sym.owner.isDirectlyOrIndirectlyLocal()) {\n+        } else if (names.isInit(sym.name) && sym.owner.isDirectlyOrIndirectlyLocal()) {\n@@ -1352,1 +1352,0 @@\n-                Name constructorName = accOwner.isConcreteValueClass() ? names.vnew : names.init;\n@@ -1355,1 +1354,1 @@\n-                    constructorName,\n+                    names.init,\n@@ -1399,1 +1398,1 @@\n-        if (names.isInitOrVNew(sym.name)) {\n+        if (names.isInit(sym.name)) {\n@@ -1612,1 +1611,1 @@\n-            (owner.isInitOrVNew() && owner.isAnonymous()) ||\n+            (owner.isInit() && owner.isAnonymous()) ||\n@@ -1614,1 +1613,1 @@\n-            (owner.isInitOrVNew() && c.isInner() &&\n+            (owner.isInit() && c.isInner() &&\n@@ -2786,1 +2785,1 @@\n-        if (names.isInitOrVNew(tree.name) &&\n+        if (names.isInit(tree.name) &&\n@@ -2867,1 +2866,1 @@\n-        if (names.isInitOrVNew(tree.name) && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+        if (names.isInit(tree.name) && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n@@ -3110,1 +3109,1 @@\n-        if (names.isInitOrVNew(meth.name) && meth.owner == syms.enumSym)\n+        if (names.isInit(meth.name) && meth.owner == syms.enumSym)\n@@ -3115,1 +3114,1 @@\n-        if (names.isInitOrVNew(meth.name)) {\n+        if (names.isInit(meth.name)) {\n@@ -3710,17 +3709,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        Type fieldType = tree.field.type;\n-        tree.field = translate(tree.field, tree);\n-        tree.value = translate(tree.value, fieldType); \/\/ important to use pre-translation type.\n-\n-        \/\/ If translated field is an Apply, we are\n-        \/\/ seeing an access method invocation. In this case, append\n-        \/\/ right hand side as last argument of the access method.\n-        if (tree.field.hasTag(APPLY)) {\n-            JCMethodInvocation app = (JCMethodInvocation) tree.field;\n-            app.args = List.of(tree.value).prependList(app.args);\n-            result = app;\n-        } else {\n-            result = tree;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":9,"deletions":27,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -190,3 +190,0 @@\n-        if (tree.name == tree.name.table.names.init && allowValueClasses && enclScope.owner.isConcreteValueClass()) {\n-            tree.name = tree.name.table.names.vnew;\n-        }\n@@ -246,1 +243,1 @@\n-        if (m.isInitOrVNew() && m.type.getParameterTypes().size() == 0) {\n+        if (m.isInit() && m.type.getParameterTypes().size() == 0) {\n@@ -365,1 +362,1 @@\n-        if (m.isInitOrVNew()) {\n+        if (m.isInit()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1059,2 +1059,1 @@\n-            Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n-            for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+            for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-        if (names.isInitOrVNew(bestSoFar.name) &&\n+        if (names.isInit(bestSoFar.name) &&\n@@ -295,1 +295,1 @@\n-        return owner.isInitOrVNew() ||\n+        return owner.isInit() ||\n@@ -407,1 +407,1 @@\n-        if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) return false;\n+        if (names.isInit(sym.name) && sym.owner != site.tsym) return false;\n@@ -472,1 +472,1 @@\n-        if (sym.kind != MTH || sym.isInitOrVNew() || sym.isStatic())\n+        if (sym.kind != MTH || sym.isInit() || sym.isStatic())\n@@ -1869,1 +1869,1 @@\n-            if (names.isInitOrVNew(name)) return bestSoFar;\n+            if (names.isInit(name)) return bestSoFar;\n@@ -2913,2 +2913,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n+        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n@@ -2948,1 +2947,0 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2950,1 +2948,1 @@\n-                                    constructorName, argtypes,\n+                                    names.init, argtypes,\n@@ -2973,1 +2971,0 @@\n-        Name constructorName = allowValueClasses && site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2975,1 +2972,1 @@\n-                new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n+                new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n@@ -2990,1 +2987,1 @@\n-                                sym = accessMethod(sym, pos, site, constructorName, true, argtypes, typeargtypes);\n+                                sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);\n@@ -3037,2 +3034,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        for (final Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+        for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n@@ -3047,1 +3043,1 @@\n-                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), constructorName, constrType, site.tsym) {\n+                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {\n@@ -3089,1 +3085,1 @@\n-        if (!names.isInitOrVNew(name)) {\n+        if (!names.isInit(name)) {\n@@ -3683,1 +3679,1 @@\n-            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3715,1 +3711,1 @@\n-            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -4122,1 +4118,1 @@\n-            boolean isConstructor = names.isInitOrVNew(name);\n+            boolean isConstructor = names.isInit(name);\n@@ -4221,1 +4217,1 @@\n-                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              names.isInit(ws.name) ? ws.owner.name : ws.name,\n@@ -4238,1 +4234,1 @@\n-                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              names.isInit(ws.name) ? ws.owner.name : ws.name,\n@@ -4295,1 +4291,1 @@\n-                boolean isConstructor = names.isInitOrVNew(name);\n+                boolean isConstructor = names.isInit(name);\n@@ -4465,1 +4461,1 @@\n-            if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) {\n+            if (names.isInit(sym.name) && sym.owner != site.tsym) {\n@@ -4678,1 +4674,1 @@\n-            if (names.isInitOrVNew(sname)) sname = s1.owner.name;\n+            if (names.isInit(sname)) sname = s1.owner.name;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -325,1 +324,1 @@\n-                !names.isInitOrVNew(sym.name) &&\n+                !names.isInit(sym.name) &&\n@@ -505,7 +504,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        tree.field = translate(tree.field, null);\n-        tree.value = translate(tree.value, erasure(tree.field.type));\n-        tree.type = erasure(tree.type);\n-        result = retype(tree, tree.type, pt);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -43,1 +42,0 @@\n-import com.sun.tools.javac.jvm.Target;\n@@ -62,1 +60,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -1186,1 +1183,1 @@\n-                            } else if (s.isInitOrVNew()) {\n+                            } else if (s.isInit()) {\n@@ -1396,2 +1393,1 @@\n-                Name constructorName = owner().isConcreteValueClass() ? names.vnew : names.init;\n-                constructorSymbol = new MethodSymbol(flags, constructorName,\n+                constructorSymbol = new MethodSymbol(flags, names.init,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -246,4 +246,0 @@\n-        \/\/ value classes related bytecodes\n-        aconst_init     = 203,\n-        withfield       = 204,\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ByteCodes.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -284,7 +284,0 @@\n-        public void visitWithField(JCWithField tree) {\n-            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n-            sr.mergeWith(csp(tree.field));\n-            sr.mergeWith(csp(tree.value));\n-            result = sr;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -872,1 +872,1 @@\n-                    if (sym.isInitOrVNew() && sym.type.getParameterTypes().size() == 0) {\n+                    if (sym.isInit() && sym.type.getParameterTypes().size() == 0) {\n@@ -1064,8 +1064,0 @@\n-                        \/\/ Map value class factory methods back to constructors for the benefit of earlier pipeline stages\n-                        if (sym.kind == MTH && sym.name == names.vnew && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n-                            sym.type = new MethodType(sym.type.getParameterTypes(),\n-                                    syms.voidType,\n-                                    sym.type.getThrownTypes(),\n-                                    syms.methodClass);\n-                        }\n-\n@@ -1457,1 +1449,1 @@\n-        if (!names.isInitOrVNew(nt.name))\n+        if (!names.isInit(nt.name))\n@@ -2385,1 +2377,1 @@\n-        if (names.isInitOrVNew(name) && ((flags & STATIC) != 0)) {\n+        if (names.isInit(name) && ((flags & STATIC) != 0)) {\n@@ -2397,1 +2389,1 @@\n-        if (names.isInitOrVNew(name) && currentOwner.hasOuterInstance()) {\n+        if (names.isInit(name) && currentOwner.hasOuterInstance()) {\n@@ -2442,1 +2434,1 @@\n-            ((name == names.init || name == names.vnew) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            ((name == names.init) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n@@ -2506,1 +2498,1 @@\n-        if (names.isInitOrVNew(sym.name) && currentOwner.hasOuterInstance()) {\n+        if (names.isInit(sym.name) && currentOwner.hasOuterInstance()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1102,1 +1102,1 @@\n-        if ((m.isInitOrVNew() || m.isValueObjectFactory()) && (m.flags_field & RECORD) != 0)\n+        if ((m.isInit() || m.isValueClassConst()) && (m.flags_field & RECORD) != 0)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-        if (member.isInitOrVNew())\n+        if (member.isInit())\n@@ -1025,1 +1025,1 @@\n-        case aconst_init: {\n+        \/*case aconst_init: {\n@@ -1029,1 +1029,1 @@\n-        }\n+        }*\/\n@@ -1056,3 +1056,0 @@\n-        case withfield:\n-            state.pop(((Symbol)data).erasure(types));\n-            break;\n@@ -1385,1 +1382,1 @@\n-            if (meth.isInitOrVNew() && thisType != syms.objectType) {\n+            if (meth.isInit() && thisType != syms.objectType) {\n@@ -2458,2 +2455,0 @@\n-            mnem[aconst_init] = \"aconst_init\";\n-            mnem[withfield] = \"withfield\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-    private final TransValues transValues;\n@@ -120,1 +119,0 @@\n-        transValues = TransValues.instance(context);\n@@ -342,1 +340,1 @@\n-        else items.makeMemberItem(msym, names.isInitOrVNew(name)).invoke();\n+        else items.makeMemberItem(msym, names.isInit(name)).invoke();\n@@ -565,1 +563,1 @@\n-        if (names.isInitOrVNew(md.name) && TreeInfo.isInitialConstructor(md)) {\n+        if (names.isInit(md.name) && TreeInfo.isInitialConstructor(md)) {\n@@ -972,1 +970,1 @@\n-            if (meth.isInitOrVNew()) {\n+            if (meth.isInit()) {\n@@ -1012,1 +1010,1 @@\n-                    } else if (env.enclMethod.sym.isValueObjectFactory()) {\n+                    } else if (env.enclMethod.sym.isValueClassConst()) {\n@@ -1081,1 +1079,1 @@\n-                if (meth.isInitOrVNew() && selfType != syms.objectType)\n+                if (meth.isInit() && selfType != syms.objectType)\n@@ -1178,31 +1176,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        switch(tree.field.getTag()) {\n-            case IDENT:\n-                Symbol sym = ((JCIdent) tree.field).sym;\n-                items.makeThisItem().load();\n-                genExpr(tree.value, tree.field.type).load();\n-                sym = binaryQualifier(sym, env.enclClass.type);\n-                code.emitop2(withfield, sym, PoolWriter::putMember);\n-                result = items.makeStackItem(tree.type);\n-                break;\n-            case SELECT:\n-                JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;\n-                sym = TreeInfo.symbol(fieldAccess);\n-                \/\/ JDK-8207332: To maintain the order of side effects, must compute value ahead of field\n-                genExpr(tree.value, tree.field.type).load();\n-                genExpr(fieldAccess.selected, fieldAccess.selected.type).load();\n-                if (Code.width(tree.field.type) == 2) {\n-                    code.emitop0(dup_x2);\n-                    code.emitop0(pop);\n-                } else {\n-                    code.emitop0(swap);\n-                }\n-                sym = binaryQualifier(sym, fieldAccess.selected.type);\n-                code.emitop2(withfield, sym, PoolWriter::putMember);\n-                result = items.makeStackItem(tree.type);\n-                break;\n-            default:\n-                Assert.check(false);\n-        }\n-    }\n-\n@@ -2490,1 +2457,2 @@\n-            code.emitop2(aconst_init, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n+            \/\/code.emitop2(aconst_init, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n+            code.emitop0(aconst_null);\n@@ -2556,1 +2524,0 @@\n-            cdef = transValues.translateTopLevelClass(cdef, make);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":7,"deletions":40,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,442 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.jvm;\n-\n-import com.sun.tools.javac.code.Flags;\n-import com.sun.tools.javac.code.Scope.LookupKind;\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symbol.MethodSymbol;\n-import com.sun.tools.javac.code.Symbol.VarSymbol;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.code.Type;\n-import com.sun.tools.javac.code.Type.MethodType;\n-import com.sun.tools.javac.code.TypeMetadata;\n-import com.sun.tools.javac.code.Types;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.JCAssign;\n-import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n-import com.sun.tools.javac.tree.JCTree.JCExpression;\n-import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\n-import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n-import com.sun.tools.javac.tree.JCTree.JCIdent;\n-import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n-import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n-import com.sun.tools.javac.tree.JCTree.JCNewClass;\n-import com.sun.tools.javac.tree.JCTree.JCReturn;\n-import com.sun.tools.javac.tree.JCTree.JCStatement;\n-import com.sun.tools.javac.tree.TreeInfo;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.tree.TreeTranslator;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n-import com.sun.tools.javac.util.Options;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static com.sun.tools.javac.code.Flags.RECORD;\n-import static com.sun.tools.javac.code.Flags.STATIC;\n-import static com.sun.tools.javac.code.Flags.ABSTRACT;\n-import static com.sun.tools.javac.code.Flags.VALUE_CLASS;\n-import static com.sun.tools.javac.code.Kinds.Kind.MTH;\n-import static com.sun.tools.javac.code.Kinds.Kind.TYP;\n-import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n-import static com.sun.tools.javac.tree.JCTree.Tag.APPLY;\n-import static com.sun.tools.javac.tree.JCTree.Tag.EXEC;\n-import static com.sun.tools.javac.tree.JCTree.Tag.IDENT;\n-\n-\/**\n- * This pass translates value class constructors into static factory methods and patches up constructor\n- * calls to become invocations of those static factory methods.\n- *\n- * We get commissioned as a subpass of Gen. Constructor trees undergo plenty of change in Lower\n- * (enclosing instance injection, captured locals ...) and in Gen (instance field initialization,\n- * see normalizeDefs) and so it is most effective to wait until things reach a quiescent state\n- * before undertaking the tinkering that we do.\n- *\n- * See https:\/\/bugs.openjdk.java.net\/browse\/JDK-8198749 for the kind of transformations we do.\n- *\n- *\/\n-public class TransValues extends TreeTranslator {\n-\n-    protected static final Context.Key<TransValues> transValueClass = new Context.Key<>();\n-\n-    private Symtab syms;\n-    private TreeMaker make;\n-    private Types types;\n-    private Names names;\n-\n-    private boolean emitQDesc;\n-\n-    \/* Is an assignment undergoing translation just an assignment statement ?\n-       Or is also a value ??\n-    *\/\n-    private boolean requireRVal;\n-\n-    \/\/ class currently undergoing translation.\n-    private JCClassDecl currentClass;\n-\n-    \/\/ method currently undergoing translation.\n-    private JCMethodDecl currentMethod;\n-\n-    \/\/ list of factories synthesized so far.\n-    private List<JCTree> staticFactories;\n-\n-    \/\/ Map from constructor symbols to factory symbols.\n-    private Map<MethodSymbol, MethodSymbol> init2factory = new HashMap<>();\n-\n-    public static TransValues instance(Context context) {\n-        TransValues instance = context.get(transValueClass);\n-        if (instance == null) {\n-            instance = new TransValues(context);\n-            context.put(transValueClass, instance);\n-        }\n-        return instance;\n-    }\n-\n-    protected TransValues(Context context) {\n-        syms = Symtab.instance(context);\n-        make = TreeMaker.instance(context);\n-        types = Types.instance(context);\n-        names = Names.instance(context);\n-        Options options = Options.instance(context);\n-        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T extends JCTree> T translate(T tree, boolean requireRVal) {\n-        boolean priorRequireRVal = this.requireRVal;\n-        try {\n-            this.requireRVal = requireRVal;\n-            if (tree == null) {\n-                return null;\n-            } else {\n-                tree.accept(this);\n-                JCTree tmpResult = this.result;\n-                this.result = null;\n-                return (T)tmpResult; \/\/ XXX cast\n-            }\n-        } finally {\n-             this.requireRVal = priorRequireRVal;\n-        }\n-    }\n-\n-    @Override\n-    public <T extends JCTree> T translate(T tree) {\n-        return translate(tree, true);\n-    }\n-\n-    public JCClassDecl translateTopLevelClass(JCClassDecl classDecl, TreeMaker make) {\n-        try {\n-            this.make = make;\n-            translate(classDecl);\n-        } finally {\n-            \/\/ note that recursive invocations of this method fail hard\n-            this.make = null;\n-        }\n-        init2factory = new HashMap<>();\n-        return classDecl;\n-    }\n-\n-    @Override\n-    public void visitClassDef(JCClassDecl classDecl) {\n-        JCClassDecl previousClass = currentClass;\n-        List<JCTree> previousFactories = staticFactories;\n-        staticFactories = List.nil();\n-        currentClass = classDecl;\n-        try {\n-            super.visitClassDef(classDecl);\n-            classDecl.defs = classDecl.defs.appendList(staticFactories);\n-            staticFactories = List.nil();\n-        }\n-        finally {\n-            currentClass = previousClass;\n-            staticFactories = previousFactories;\n-        }\n-    }\n-\n-    @Override\n-    public void visitMethodDef(JCMethodDecl tree) {\n-        JCMethodDecl previousMethod = currentMethod;\n-        currentMethod = tree;\n-        try {\n-            if (transformToValueFactory()) {\n-\n-                \/\/ Mutate this value class constructor into an equivalent static factory\n-                make.at(tree.pos());\n-                JCExpressionStatement exec = chainedConstructorCall(tree);\n-                Assert.check(exec != null && TreeInfo.isSelfCall(exec));\n-                JCMethodInvocation call = (JCMethodInvocation) exec.expr;\n-\n-                \/* Unlike the reference construction sequence where `this' is allocated ahead of time and\n-                   is passed as an argument into the <init> method, the value static factory must allocate the\n-                   instance that forms the `product' by itself. We do that by injecting a prologue here.\n-                *\/\n-                VarSymbol product = currentMethod.factoryProduct =\n-                        new VarSymbol(0, names.dollarValue,\n-                                currentClass.sym.type.hasImplicitConstructor() ?\n-                                        currentClass.sym.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n-                                        currentClass.sym.type,\n-                                currentMethod.sym); \/\/ TODO: owner needs rewiring\n-                JCExpression rhs;\n-\n-                final Name name = TreeInfo.name(call.meth);\n-                MethodSymbol symbol = (MethodSymbol)TreeInfo.symbol(call.meth);\n-                if (names._super.equals(name)) { \/\/ \"initial\" constructor.\n-                    \/\/ Synthesize code to allocate factory \"product\" via: V $this = V.default;\n-                    Assert.check(symbol.type.getParameterTypes().size() == 0);\n-                    final JCExpression type = make.Type(\n-                            currentClass.sym.type.hasImplicitConstructor() ?\n-                                    currentClass.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n-                                    currentClass.type\n-                            );\n-                    rhs = make.DefaultValue(type);\n-                    rhs.type = currentClass.sym.type.hasImplicitConstructor() ?\n-                            currentClass.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n-                            currentClass.type;\n-                } else {\n-                    \/\/ This must be a chained call of form `this(args)'; Mutate it into a factory invocation i.e V $this = V.init(args);\n-                    Assert.check(TreeInfo.name(TreeInfo.firstConstructorCall(tree).meth) == names._this);\n-                    MethodSymbol factory = getValueObjectFactory(symbol);\n-                    final JCIdent ident = make.Ident(factory);\n-                    rhs = make.App(ident, call.args);\n-                    ((JCMethodInvocation)rhs).varargsElement = call.varargsElement;\n-                }\n-\n-                \/* The static factory product allocation prologue must precede any synthetic inits !!!\n-                   as these may reference `this' which gets pre-allocated for references but\n-                   not for value objects.\n-                *\/\n-                JCStatement prologue = make.VarDef(product, rhs);\n-                tree.body.stats = tree.body.stats.prepend(prologue).diff(List.of(exec));\n-                tree.body = translate(tree.body);\n-\n-                MethodSymbol factorySym = getValueObjectFactory(tree.sym);\n-                MethodType mt = (MethodType) factorySym.type;\n-                mt.restype = mt.restype.addMetadata((new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)));\n-                currentMethod.setType(mt);\n-                currentMethod.factoryProduct = product;\n-                currentClass.sym.members().remove(tree.sym);\n-                tree.sym = factorySym;\n-                currentClass.sym.members().enter(factorySym);\n-                tree.mods.flags |= STATIC;\n-\n-                \/* We may need an epilogue that returns the factory product, but we can't eagerly insert\n-                   a return here, since we don't know much about control flow here. Gen#genMethod\n-                   will insert a return of the factory product if control does reach the end and would\n-                   \"fall off the cliff\" otherwise.\n-                *\/\n-\n-                result = tree;\n-                return;\n-            }\n-            super.visitMethodDef(tree);\n-        } finally {\n-            currentMethod = previousMethod;\n-        }\n-    }\n-\n-    @Override\n-    public void visitReturn(JCReturn tree) {\n-        if (transformToValueFactory()) {\n-            result = make.Return(make.Ident(currentMethod.factoryProduct));\n-        } else {\n-            super.visitReturn(tree);\n-        }\n-    }\n-\n-    \/* Note: 1. Assignop does not call for any translation, since value class instance fields are final and\n-       so cannot be AssignedOped. 2. Any redundantly qualified this would have been lowered already.\n-    *\/\n-    @Override\n-    public void visitAssign(JCAssign tree) {\n-        if (transformToValueFactory()) {\n-            Symbol symbol = null;\n-            switch(tree.lhs.getTag()) {\n-                case IDENT:\n-                    symbol = ((JCIdent)tree.lhs).sym;\n-                    break;\n-                case SELECT:\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) tree.lhs;\n-                    if (fieldAccess.selected.hasTag(IDENT) && ((JCIdent)fieldAccess.selected).name == names._this) {\n-                        symbol = fieldAccess.sym;\n-                    }\n-                    break;\n-                default:\n-                    break;\n-            }\n-            if (isInstanceMemberAccess(symbol)) {\n-                final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                JCTree.JCWithField withField = (JCTree.JCWithField) make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type);\n-                if (withField.type.hasImplicitConstructor()) {\n-                    withField.type = withField.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n-                }\n-                result = make.Assign(facHandle, withField).setType(currentClass.type);\n-                if (requireRVal) {\n-                    result = make.Select(make.Parens((JCExpression) result).setType(currentClass.type), symbol);\n-                }\n-                return;\n-            }\n-        }\n-        super.visitAssign(tree);\n-    }\n-\n-    @Override\n-    public void visitExec(JCExpressionStatement tree) {\n-        if (transformToValueFactory()) {\n-            tree.expr = translate(tree.expr, false);\n-            result = tree;\n-        } else {\n-            super.visitExec(tree);\n-        }\n-    }\n-\n-    @Override\n-    public void visitIdent(JCIdent ident) {\n-        if (transformToValueFactory()) {\n-            Symbol symbol = ident.sym;\n-            if (isInstanceMemberAccess(symbol)) {\n-                final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                result = make.Select(facHandle, symbol);\n-                return;\n-            } else if (symbol.name == names._this) {\n-                result = make.Ident(currentMethod.factoryProduct);\n-                return;\n-            }\n-        }\n-        super.visitIdent(ident);\n-    }\n-\n-    @Override\n-    public void visitSelect(JCFieldAccess fieldAccess) {\n-        if (transformToValueFactory()) { \/\/ Qualified this would have been lowered already.\n-            if (fieldAccess.selected.hasTag(IDENT) && ((JCIdent)fieldAccess.selected).name == names._this) {\n-                Symbol symbol = fieldAccess.sym;\n-                if (isInstanceMemberAccess(symbol)) {\n-                    final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                    result = make.Select(facHandle, symbol);\n-                    return;\n-                }\n-            }\n-        }\n-        \/* If a static member is being selected via a V.ref as a TYP, rewrite\n-           V.ref.member to V.member\n-        *\/\n-        fieldAccess.selected = translate(fieldAccess.selected);\n-        if (fieldAccess.name != names._class) {  \/\/ TODO: this and super ??\n-            Symbol sym = TreeInfo.symbol(fieldAccess);\n-            Symbol sitesym = TreeInfo.symbol(fieldAccess.selected);\n-            Type selectedType = fieldAccess.selected.type;\n-        }\n-        result = fieldAccess;\n-    }\n-\n-    \/\/ Translate a reference style instance creation attempt on a value class to a static factory call.\n-    @Override\n-    public void visitNewClass(JCNewClass tree) {\n-        if (tree.clazz.type.isValueClass()) {\n-            \/\/ Enclosing instances or anonymous classes should have been eliminated by now.\n-            Assert.check(tree.encl == null && tree.def == null);\n-            tree.args = translate(tree.args);\n-            Assert.check(tree.def == null);\n-            MethodSymbol sFactory = getValueObjectFactory((MethodSymbol) tree.constructor);\n-            make.at(tree.pos());\n-            JCExpression declClass = make.Type(tree.constructor.owner.type);\n-            JCExpression meth = make.Select(declClass, sFactory);\n-            meth.type = types.erasure(meth.type);\n-            final JCMethodInvocation apply = make.Apply(tree.typeargs, meth, tree.args);\n-            apply.varargsElement = tree.varargsElement;\n-            apply.type = meth.type.getReturnType();\n-            result = apply;\n-            return;\n-        }\n-        super.visitNewClass(tree);\n-    }\n-\n-    \/\/ Utility methods ...\n-    private boolean transformToValueFactory() {\n-        \/\/ We lower any constructors in abstract value classes to <init> methods while a\n-        \/\/ constructor in a concrete value class is lowered into a static value factory method\n-        return currentClass != null && (currentClass.sym.flags() & (ABSTRACT | VALUE_CLASS)) == VALUE_CLASS && currentMethod != null && currentMethod.sym.name == names.vnew;\n-    }\n-\n-    private boolean isInstanceMemberAccess(Symbol symbol) {\n-        return symbol != null\n-                && (symbol.name != names._this && symbol.name != names._super)\n-                && (symbol.kind == VAR || symbol.kind == MTH)\n-                && symbol.owner == currentClass.sym && !symbol.isStatic();\n-    }\n-\n-    private MethodSymbol getValueObjectFactory(MethodSymbol init) {\n-        Assert.check(init.name.equals(names.vnew));\n-        Assert.check(init.owner.type.isValueClass());\n-        MethodSymbol factory = init2factory.get(init);\n-        if (factory != null)\n-            return factory;\n-\n-        MethodType factoryType = new MethodType(init.type.getParameterTypes(),\n-                                                init.owner.type,\n-                                                init.type.getThrownTypes(),\n-                                                init.owner.type.tsym);\n-        factory = new MethodSymbol(init.flags_field | STATIC,\n-                                        names.vnew,\n-                                        factoryType,\n-                                        init.owner);\n-        factory.params = init.params;\n-        \/\/ Re-patch the return type on the erased method type, or code generation will fail\n-        factory.erasure_field = new MethodType(init.erasure(types).getParameterTypes(),\n-                init.owner.type,\n-                init.type.getThrownTypes(),\n-                init.owner.type.tsym);\n-        factory.setAttributes(init);\n-        init2factory.put(init, factory);\n-        return factory;\n-    }\n-\n-    \/** Return the *statement* in the constructor that `chains' to another constructor call either\n-     *  in the same class or its superclass. One MUST exist except for jlO, though may be buried\n-     *  under synthetic initializations.\n-     *\/\n-    private JCExpressionStatement chainedConstructorCall(JCMethodDecl md) {\n-        if (names.isInitOrVNew(md.name) && md.body != null) {\n-            for (JCStatement statement : md.body.stats) {\n-                if (statement.hasTag(EXEC)) {\n-                    JCExpressionStatement exec = (JCExpressionStatement)statement;\n-                    if (exec.expr.hasTag(APPLY)) {\n-                        JCMethodInvocation apply = (JCMethodInvocation)exec.expr;\n-                        Name name = TreeInfo.name(apply.meth);\n-                        if (name == names._super || name == names._this)\n-                            return exec;\n-                    }\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":0,"deletions":442,"binary":false,"changes":442,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Collections;\n@@ -87,2 +86,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -1786,1 +1783,1 @@\n-                                names.isInitOrVNew(((JCMethodDecl) t).sym.name) ||\n+                                names.isInit(((JCMethodDecl) t).sym.name) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.Flags.Flag;\n@@ -66,1 +65,0 @@\n-import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;\n@@ -72,1 +70,0 @@\n-import java.util.function.BiFunction;\n@@ -4501,1 +4498,1 @@\n-                if (names.isInitOrVNew(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+                if (names.isInit(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -5174,1 +5171,1 @@\n-            if (!isRecord || !names.isInitOrVNew(name) || token.kind == LPAREN) {\n+            if (!isRecord || !names.isInit(name) || token.kind == LPAREN) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,4 +136,0 @@\n-        \/** Withfields, of type WithField.\n-         *\/\n-        WITHFIELD,\n-\n@@ -968,1 +964,1 @@\n-            return name.table.names.isInitOrVNew(name);\n+            return name.table.names.isInit(name);\n@@ -1190,30 +1186,0 @@\n-    \/**\n-     * A withfield expression\n-     *\/\n-    public static class JCWithField extends JCExpression implements WithFieldTree {\n-        public JCExpression field;\n-        public JCExpression value;\n-        protected JCWithField(JCExpression field, JCExpression value) {\n-            this.field = field;\n-            this.value = value;\n-        }\n-        @Override\n-        public void accept(Visitor v) { v.visitWithField(this); }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() { return Kind.WITH_FIELD; }\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getField() { return field; }\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getValue() { return value; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n-            return v.visitWithField(this, d);\n-        }\n-\n-        @Override\n-        public Tag getTag() {\n-            return WITHFIELD;\n-        }\n-    }\n-\n@@ -3655,1 +3621,0 @@\n-        public void visitWithField(JCWithField that)         { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -800,12 +800,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        try {\n-            print(\"__WithField(\");\n-            printExpr(tree.field);\n-            print(\", \");\n-            printExpr(tree.value);\n-            print(\")\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -581,8 +581,0 @@\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public JCTree visitWithField(WithFieldTree node, P p) {\n-        JCWithField t = (JCWithField) node;\n-        JCExpression field = copy(t.field, p);\n-        JCExpression value = copy(t.value, p);\n-        return M.at(t.pos).WithField(field, value);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,12 +84,1 @@\n-            return name == name.table.names.init || name == name.table.names.vnew;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/** Is tree a value factory declaration?\n-     *\/\n-    public static boolean isValueFactory(JCTree tree) {\n-        if (tree.hasTag(METHODDEF)) {\n-            Name name = ((JCMethodDecl) tree).name;\n-            return name == name.table.names.vnew;\n+            return name == name.table.names.init;\n@@ -123,1 +112,1 @@\n-            if (isConstructor(l.head) || isValueFactory(l.head)) return true;\n+            if (isConstructor(l.head)) return true;\n@@ -668,2 +657,0 @@\n-            case WITHFIELD:\n-                return getEndPos(((JCWithField) tree).value, endPosTable);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -269,6 +269,0 @@\n-    public JCWithField WithField(JCExpression field, JCExpression value) {\n-        JCWithField tree = new JCWithField(field, value);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,5 +158,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        scan(tree.field);\n-        scan(tree.value);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -183,6 +183,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        tree.field = translate(tree.field);\n-        tree.value = translate(tree.value);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-    public final Name vnew;\n@@ -308,1 +307,0 @@\n-        vnew = fromString(\"<vnew>\");\n@@ -470,2 +468,2 @@\n-    public boolean isInitOrVNew(Name name) {\n-        return name == init || name == vnew;\n+    public boolean isInit(Name name) {\n+        return name == init;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-                String ms = (s.isInitOrVNew()) ? ownerName : s.name.toString();\n+                String ms = (s.isInit()) ? ownerName : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -32,0 +33,2 @@\n+\/\/ see JDK-8316628\n+\n","filename":"test\/langtools\/jdk\/jshell\/Test8294583.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -32,0 +33,2 @@\n+\/\/ see JDK-8316628\n+\n","filename":"test\/langtools\/jdk\/jshell\/Test8296012.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n@@ -31,0 +32,2 @@\n+\/\/ see JDK-8316628\n+\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnablePreviewTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityCompilationTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInDeconstructionPatterns2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValue.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValueType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayCreationWithQuestion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AutoCloseableTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CanonicalCtorTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNullCheckTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ChainedAssignmentTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+ * @ignore 8316628\n+ *\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFieldDescriptors.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSeparateCompile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralTypingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilerNoBogusAssert.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConditionalInlineTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CtorChain.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultNonInlines.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EnhancedForLoopTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes3.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericArrayRegression.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues5.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GetClassTypingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InferredValueParameterizationTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineDiamondTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerClassAttributeValuenessTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerValueNew.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LocalValueNew.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LubWithInlines.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoCrashTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoUnnecessaryCast.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ParameterizedDefault.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PreloadAttributeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedSuperCtor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedThisTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/RefDotClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileGenerics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SignatureTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SmallSetTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StreamsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperHashCodeEqualsToStringTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestQualifierOnInit.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ThisIsNotAnInstanceField.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassNestHostTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueBootstrapMethodsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueConstructorRef.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueNewReadWrite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValuesAsRefs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8205686 8215109\n- * @summary __WithField seems to have trouble if the value type is a generic type.\n- * @compile -XDenablePrimitiveClasses WithFieldOfGenericType.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses WithFieldOfGenericType\n- *\/\n-\n-public final value class WithFieldOfGenericType<E> {\n-  private final boolean value;\n-\n-  public static <E> WithFieldOfGenericType<E> create() {\n-    return new WithFieldOfGenericType<>(true);\n-  }\n-\n-  private WithFieldOfGenericType(boolean value) {\n-    this.value = value;\n-  }\n-\n-  public static void main(String[] args) {\n-     WithFieldOfGenericType<String> w = create();\n-     if (w.value != true)\n-        throw new AssertionError(\"Withfield didn't work!\");\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldOfGenericType.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldRuntimeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore 8316628\n@@ -34,0 +35,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValue.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValueType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,4 +63,4 @@\n-                \"         6: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n-                \"        17: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n-                \"        33: invokestatic  #16                 \/\/ Method java\/lang\/reflect\/Array.newInstance:(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n-                \"        52: invokestatic  #16                 \/\/ Method java\/lang\/reflect\/Array.newInstance:(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n+                \"         7: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"        16: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"        30: invokestatic  #22                 \/\/ Method java\/lang\/reflect\/Array.newInstance:(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n+                \"        47: invokestatic  #22                 \/\/ Method java\/lang\/reflect\/Array.newInstance:(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @ignore\n@@ -30,0 +31,1 @@\n+\/\/ see JDK-8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConstructorRefTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * @compile\/fail\/ref=ConsumeValueClassAtLowerLevel.out --source 16 -XDrawDiagnostics ConsumeValueClassAtLowerLevel.java\n+ * @compile --source 16 -XDrawDiagnostics ConsumeValueClassAtLowerLevel.java\n@@ -12,4 +12,0 @@\n-        \/* GenericPoint was compiled with a source that allows value classes but ConsumeValueClassAtLowerLevel was not\n-         * so GenericPoint has a <vnew> initializer but in a source that doesn't allow value classes we look for <ini>\n-         * thus the compiler error in the second compilation of ConsumeValueClassAtLowerLevel.java\n-         *\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConsumeValueClassAtLowerLevel.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,3 +65,1 @@\n-         \/\/ Check that constructor invocation has been lowered into invokestatic\n-         \/\/ of the factory method.\n-         \"4: invokestatic  #10                 \/\/ Method \\\"<vnew>\\\":(II)LValueCreationTest$Point;\",\n+         \"0: new           #8                  \/\/ class ValueCreationTest$Point\",\n@@ -72,17 +70,12 @@\n-         \"static ValueCreationTest$Point ValueCreationTest$Point(int, int);\",\n-         \"descriptor: (II)LValueCreationTest$Point;\",\n-         \"flags: (0x0008) ACC_STATIC\",\n-         \"0: aconst_init   #1                  \/\/ class ValueCreationTest$Point\",\n-         \"3: astore_2\",\n-         \"4: iload_0\",\n-         \"5: aload_2\",\n-         \"6: swap\",\n-         \"7: withfield     #3                  \/\/ Field x:I\",\n-        \"10: astore_2\",\n-        \"11: iload_1\",\n-        \"12: aload_2\",\n-        \"13: swap\",\n-        \"14: withfield     #7                  \/\/ Field y:I\",\n-        \"17: astore_2\",\n-        \"18: aload_2\",\n-        \"19: areturn\"\n+         \"ValueCreationTest$Point(int, int);\",\n+         \"descriptor: (II)V\",\n+         \"flags: (0x0000)\",\n+         \"0: aload_0\",\n+         \"1: invokespecial #1                  \/\/ Method java\/lang\/Object.\\\"<init>\\\":()V\",\n+         \"4: aload_0\",\n+         \"5: iload_1\",\n+         \"6: putfield      #7                  \/\/ Field x:I\",\n+         \"9: aload_0\",\n+        \"10: iload_2\",\n+        \"11: putfield      #13                 \/\/ Field y:I\",\n+        \"14: return\"\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueCreationTest.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -747,101 +747,0 @@\n-    public void testCheckVnew() throws Exception {\n-        for (String source : List.of(\n-                \"\"\"\n-                abstract value class A {}\n-                \"\"\",\n-                \"\"\"\n-                value class A {}\n-                \"\"\"\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                boolean isAbstract = classFile.access_flags.is(Flags.ABSTRACT);\n-                for (Method method : classFile.methods) {\n-                    if (isAbstract) {\n-                        assertTrue(method.getName(classFile.constant_pool).equals(\"<init>\"));\n-                        assertTrue(!method.access_flags.is(Flags.STATIC));\n-                    } else {\n-                        assertTrue(method.getName(classFile.constant_pool).equals(\"<vnew>\"));\n-                        assertTrue(method.access_flags.is(Flags.STATIC));\n-                        assertTrue(!method.access_flags.is(Flags.ABSTRACT));\n-                        assertTrue(method.descriptor.getReturnType(classFile.constant_pool).equals(\"A\"));\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ check that <vnew> is invoked with invokestatic\n-        for (String source : List.of(\n-                \"\"\"\n-                value class A {\n-                    void FIND_ME() {\n-                        A a = new A();\n-                    }\n-                }\n-                \"\"\"\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"FIND_ME\")) {\n-                        Code_attribute code_attribute = (Code_attribute)method.attributes.get(\"Code\");\n-                        boolean firstInst = true;\n-                        for (Instruction inst: code_attribute.getInstructions()) {\n-                            if (firstInst) {\n-                                assertTrue(inst.getMnemonic().equals(\"invokestatic\"));\n-                                CONSTANT_Methodref_info methodInfo =\n-                                        (CONSTANT_Methodref_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(methodInfo.getClassInfo().getName().equals(\"A\"));\n-                                assertTrue(methodInfo.getNameAndTypeInfo().getName().equals(\"<vnew>\"));\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ checking the aconst_init and withfield instructions\n-        for (String source : List.of(\n-                \"\"\"\n-                value class A {\n-                    int i;\n-                    String s;\n-\n-                    A(int i, String s) {\n-                        this.i = i;\n-                        this.s = s;\n-                    }\n-                }\n-                \"\"\"\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"<vnew>\")) {\n-                        Code_attribute code_attribute = (Code_attribute)method.attributes.get(\"Code\");\n-                        for (Instruction inst: code_attribute.getInstructions()) {\n-                            if (inst.getMnemonic().equals(\"aconst_init\")) {\n-                                CONSTANT_Class_info classInfo =\n-                                        (CONSTANT_Class_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(classInfo.getName().equals(\"A\"));\n-                            } else if (inst.getMnemonic().equals(\"withfield\")) {\n-                                CONSTANT_Fieldref_info fieldInfo = (CONSTANT_Fieldref_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(fieldInfo.getClassName().equals(\"A\"));\n-                                ConstantPool.CONSTANT_NameAndType_info nameAndType = fieldInfo.getNameAndTypeInfo();\n-                                if (nameAndType.getName().equals(\"i\")) {\n-                                    assertTrue(nameAndType.getType().equals(\"I\"));\n-                                } else if (nameAndType.getName().equals(\"s\")) {\n-                                    assertTrue(nameAndType.getType().equals(\"Ljava\/lang\/String;\"));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectsBinaryCompatibilityTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8205686 8215109\n- * @summary __WithField seems to have trouble if the value type is a generic type.\n- * @compile -XDrawDiagnostics -XDdev WithFieldOfGenericType.java\n- * @run main\/othervm WithFieldOfGenericType\n- *\/\n-\n-public final value class WithFieldOfGenericType<E> {\n-  private final boolean value;\n-\n-  public static <E> WithFieldOfGenericType<E> create() {\n-    return new WithFieldOfGenericType<>(true);\n-  }\n-\n-  private WithFieldOfGenericType(boolean value) {\n-    this.value = value;\n-  }\n-\n-  public static void main(String[] args) {\n-     WithFieldOfGenericType<String> w = create();\n-     if (w.value != true)\n-        throw new AssertionError(\"Withfield didn't work!\");\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldOfGenericType.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n@@ -35,0 +36,2 @@\n+\/\/ see JDK-8316628\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/separate_compilation\/ConcreteValue.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}