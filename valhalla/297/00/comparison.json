{"files":[{"patch":"@@ -496,10 +496,3 @@\n-  \/\/ flat or not. Speculating it's not leads to a much simpler graph\n-  \/\/ shape. Check profiling.\n-  \/\/ For aastore, by the time we're here, the array store check should\n-  \/\/ have already taken advantage of profiling to cast the array to an\n-  \/\/ exact type reported by profiling\n-  const TypeOopPtr* elemptr = elemtype->make_oopptr();\n-  if (elemtype->isa_inlinetype() == NULL &&\n-      (elemptr == NULL || !elemptr->is_inlinetypeptr() || elemptr->maybe_null()) &&\n-      !arytype->is_not_flat()) {\n-    assert(is_reference_type(type), \"Only references\");\n+  \/\/ flat or not. Knowing the exact type avoids runtime checks and leads to\n+  \/\/ a much simpler graph shape. Check profile information.\n+  if (!arytype->is_flat() && !arytype->is_not_flat()) {\n@@ -524,0 +517,1 @@\n+      DEBUG_ONLY(Node* old_control = control();)\n@@ -525,1 +519,3 @@\n-      { PreserveJVMState pjvms(this);\n+      if (stopped()) {\n+        \/\/ The check always fails and therefore profile information is incorrect. Don't use it.\n+        assert(old_control == slow_ctl, \"type check should have been removed\");\n@@ -527,1 +523,9 @@\n-        uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+      } else {\n+        { PreserveJVMState pjvms(this);\n+          set_control(slow_ctl);\n+          uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);\n+        }\n+        replace_in_map(ary, better_ary);\n+        ary = better_ary;\n+        arytype  = _gvn.type(ary)->is_aryptr();\n+        elemtype = arytype->elem();\n@@ -529,4 +533,0 @@\n-      replace_in_map(ary, better_ary);\n-      ary = better_ary;\n-      arytype  = _gvn.type(ary)->is_aryptr();\n-      elemtype = arytype->elem();\n@@ -549,2 +549,2 @@\n-  \/\/ for a non null free or non flat array. Non null free implies non\n-  \/\/ flat so check this one first. Speculating on a non null free\n+  \/\/ for a non null-free or non flat array. Non null-free implies non\n+  \/\/ flat so check this one first. Speculating on a non null-free\n@@ -553,6 +553,1 @@\n-  elemptr = elemtype->make_oopptr();\n-  if (!arytype->is_not_null_free() &&\n-      elemtype->isa_inlinetype() == NULL &&\n-      (elemptr == NULL || !elemptr->is_inlinetypeptr()) &&\n-      UseArrayLoadStoreProfile) {\n-    assert(is_reference_type(type), \"\");\n+  if (!arytype->is_null_free() && !arytype->is_not_null_free()) {\n@@ -566,1 +561,1 @@\n-    } else if (!too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {\n+    } else if (UseArrayLoadStoreProfile && !too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {\n@@ -579,0 +574,1 @@\n+      assert(!stopped(), \"null-free array should have been caught earlier\");\n@@ -586,2 +582,1 @@\n-  if (!arytype->is_not_flat() && elemtype->isa_inlinetype() == NULL) {\n-    assert(is_reference_type(type), \"\");\n+  if (!arytype->is_flat() && !arytype->is_not_flat()) {\n@@ -608,0 +603,1 @@\n+      assert(!stopped(), \"flat array should have been caught earlier\");\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":23,"deletions":27,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1489,1 +1489,1 @@\n-    return make( TypePtr::Constant, k, Offset(0), false, not_flat, not_null_free);\n+    return make(TypePtr::Constant, k, Offset(0), false, not_flat, not_null_free);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -915,0 +915,56 @@\n+\n+    \/\/ Test array access with polluted array type profile\n+    static abstract class Test40Abstract { }\n+    static class Test40Class extends Test40Abstract { }\n+    static inline class Test40Inline extends Test40Abstract { }\n+\n+    @ForceInline\n+    public Object test40_access(Object[] array) {\n+        return array[0];\n+    }\n+\n+    @Warmup(10000)\n+    @Test()\n+    public Object test40(Test40Abstract[] array) {\n+        return test40_access(array);\n+    }\n+\n+    @DontCompile\n+    public void test40_verifier(boolean warmup) {\n+        \/\/ Make sure multiple implementors of Test40Abstract are loaded\n+        Test40Inline tmp1 = new Test40Inline();\n+        Test40Class tmp2 = new Test40Class();\n+        if (warmup) {\n+            \/\/ Pollute profile with Object[] (exact)\n+            test40_access(new Object[1]);\n+        } else {\n+            \/\/ When inlining test40_access, profiling contradicts actual type of array\n+            test40(new Test40Class[1]);\n+        }\n+    }\n+\n+    \/\/ Same as test40 but with array store\n+    @ForceInline\n+    public void test41_access(Object[] array, Object val) {\n+        array[0] = val;\n+    }\n+\n+    @Warmup(10000)\n+    @Test()\n+    public void test41(Test40Inline[] array, Object val) {\n+        test41_access(array, val);\n+    }\n+\n+    @DontCompile\n+    public void test41_verifier(boolean warmup) {\n+        \/\/ Make sure multiple implementors of Test40Abstract are loaded\n+        Test40Inline tmp1 = new Test40Inline();\n+        Test40Class tmp2 = new Test40Class();\n+        if (warmup) {\n+            \/\/ Pollute profile with exact Object[]\n+            test41_access(new Object[1], new Object());\n+        } else {\n+            \/\/ When inlining test41_access, profiling contradicts actual type of array\n+            test41(new Test40Inline[1], new Test40Inline());\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"}]}