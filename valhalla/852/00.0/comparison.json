{"files":[{"patch":"@@ -223,4 +223,2 @@\n-JVM_VirtualThreadMountBegin\n-JVM_VirtualThreadMountEnd\n-JVM_VirtualThreadUnmountBegin\n-JVM_VirtualThreadUnmountEnd\n+JVM_VirtualThreadMount\n+JVM_VirtualThreadUnmount\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-include gensrc\/GensrcEmojiData.gmk\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    DISABLED_WARNINGS := rawtypes serial options, \\\n+    DISABLED_WARNINGS := this-escape rawtypes serial options, \\\n@@ -94,1 +94,1 @@\n-    DISABLED_WARNINGS := processing rawtypes unchecked cast serial preview deprecation, \\\n+    DISABLED_WARNINGS := this-escape processing rawtypes unchecked cast serial preview deprecation, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -944,1 +944,1 @@\n-                                     FloatRegister src2, int cond, bool isQ) {\n+                                     FloatRegister src2, Condition cond, bool isQ) {\n@@ -946,16 +946,14 @@\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    switch (cond) {\n-      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        fcmeq(dst, size, src1, src2);\n-        notr(dst, isQ ? T16B : T8B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n+  FloatRegister zn = src1, zm = src2;\n+  bool needs_negation = false;\n+  switch (cond) {\n+    case LT: cond = GT; zn = src2; zm = src1; break;\n+    case LE: cond = GE; zn = src2; zm = src1; break;\n+    case LO: cond = HI; zn = src2; zm = src1; break;\n+    case LS: cond = HS; zn = src2; zm = src1; break;\n+    case NE: cond = EQ; needs_negation = true; break;\n+    default:\n+      break;\n+  }\n+\n+  if (is_floating_point_type(bt)) {\n+    fcm(cond, dst, size, zn, zm);\n@@ -963,19 +961,5 @@\n-    switch (cond) {\n-      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        cmeq(dst, size, src1, src2);\n-        notr(dst, isQ ? T16B : T8B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: cmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n-      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n-      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n-      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n-      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n+    cm(cond, dst, size, zn, zm);\n+  }\n+\n+  if (needs_negation) {\n+    notr(dst, isQ ? T16B : T8B, dst);\n@@ -1151,1 +1135,1 @@\n-                                    FloatRegister zn, FloatRegister zm, int cond) {\n+                                    FloatRegister zn, FloatRegister zm, Condition cond) {\n@@ -1154,8 +1138,4 @@\n-  \/\/ Convert the original BoolTest condition to Assembler::condition.\n-  Condition condition;\n-    case BoolTest::eq: condition = Assembler::EQ; break;\n-    case BoolTest::ne: condition = Assembler::NE; break;\n-    case BoolTest::le: z1 = zm; z2 = zn; condition = Assembler::GE; break;\n-    case BoolTest::ge: condition = Assembler::GE; break;\n-    case BoolTest::lt: z1 = zm; z2 = zn; condition = Assembler::GT; break;\n-    case BoolTest::gt: condition = Assembler::GT; break;\n+    case LE: z1 = zm; z2 = zn; cond = GE; break;\n+    case LT: z1 = zm; z2 = zn; cond = GT; break;\n+    case LO: z1 = zm; z2 = zn; cond = HI; break;\n+    case LS: z1 = zm; z2 = zn; cond = HS; break;\n@@ -1164,2 +1144,1 @@\n-      assert(false, \"unsupported compare condition\");\n-      ShouldNotReachHere();\n+      break;\n@@ -1169,2 +1148,2 @@\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    sve_fcm(condition, pd, size, pg, z1, z2);\n+  if (is_floating_point_type(bt)) {\n+    sve_fcm(cond, pd, size, pg, z1, z2);\n@@ -1173,1 +1152,1 @@\n-    sve_cmp(condition, pd, size, pg, z1, z2);\n+    sve_cmp(cond, pd, size, pg, z1, z2);\n@@ -2005,1 +1984,1 @@\n-  cmhs(tmp3, T, tmp3, tmp2);\n+  cm(HS, tmp3, T, tmp3, tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":30,"deletions":51,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                    FloatRegister src2, int cond, bool isQ);\n+                    FloatRegister src2, Condition cond, bool isQ);\n@@ -87,1 +87,1 @@\n-                   FloatRegister zn, FloatRegister zm, int cond);\n+                   FloatRegister zn, FloatRegister zm, Condition cond);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1075,1 +1075,0 @@\n-  __ flush();\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6441,4 +6441,4 @@\n-    __ cmhi(decH0, arrangement, decL0, v27);\n-    __ cmhi(decH1, arrangement, decL1, v27);\n-    __ cmhi(decH2, arrangement, decL2, v27);\n-    __ cmhi(decH3, arrangement, decL3, v27);\n+    __ cm(Assembler::HI, decH0, arrangement, decL0, v27);\n+    __ cm(Assembler::HI, decH1, arrangement, decL1, v27);\n+    __ cm(Assembler::HI, decH2, arrangement, decL2, v27);\n+    __ cm(Assembler::HI, decH3, arrangement, decL3, v27);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n@@ -411,1 +411,1 @@\n-    Metadata* o = NULL;\n+    Metadata* o = nullptr;\n@@ -426,1 +426,1 @@\n-    jobject o = NULL;\n+    jobject o = nullptr;\n@@ -497,1 +497,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -160,1 +160,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -326,1 +326,1 @@\n-        __ stop(\"locked object is NULL\");\n+        __ stop(\"locked object is null\");\n@@ -378,1 +378,1 @@\n-  jobject o = NULL;\n+  jobject o = nullptr;\n@@ -385,1 +385,1 @@\n-  Metadata* o = NULL;\n+  Metadata* o = nullptr;\n@@ -405,1 +405,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -455,1 +455,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -488,1 +488,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -499,1 +499,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -531,1 +531,1 @@\n-        assert(unpack_handler != NULL, \"must be\");\n+        assert(unpack_handler != nullptr, \"must be\");\n@@ -581,1 +581,1 @@\n-  guarantee(info != NULL, \"Shouldn't be NULL\");\n+  guarantee(info != nullptr, \"Shouldn't be null\");\n@@ -776,1 +776,1 @@\n-      if (c->as_jobject() == NULL) {\n+      if (c->as_jobject() == nullptr) {\n@@ -842,1 +842,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -990,1 +990,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1087,1 +1087,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -1096,1 +1096,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -1124,1 +1124,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1242,1 +1242,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1247,1 +1247,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1315,1 +1315,1 @@\n-        assert(info == NULL && patch == NULL, \"must be\");\n+        assert(info == nullptr && patch == nullptr, \"must be\");\n@@ -1323,1 +1323,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -1332,1 +1332,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -1384,1 +1384,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -1446,3 +1446,3 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  _branch_target_blocks.append(op->block());\n-  if (op->ublock() != NULL) _branch_target_blocks.append(op->ublock());\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  _branch_target_blocks.append(op->block());\n+  if (op->ublock() != nullptr) _branch_target_blocks.append(op->ublock());\n@@ -1452,1 +1452,1 @@\n-    if (op->info() != NULL) add_debug_info_for_branch(op->info());\n+    if (op->info() != nullptr) add_debug_info_for_branch(op->info());\n@@ -1457,1 +1457,1 @@\n-      assert(op->ublock() != NULL, \"must have unordered successor\");\n+      assert(op->ublock() != nullptr, \"must have unordered successor\");\n@@ -1614,1 +1614,1 @@\n-      assert(op->stub() != NULL, \"stub required\");\n+      assert(op->stub() != nullptr, \"stub required\");\n@@ -1727,2 +1727,2 @@\n-  ciMethodData* md = NULL;\n-  ciProfileData* data = NULL;\n+  ciMethodData* md = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -1732,1 +1732,1 @@\n-    assert(method != NULL, \"Should have method\");\n+    assert(method != nullptr, \"Should have method\");\n@@ -1735,1 +1735,1 @@\n-    assert(md != NULL, \"Sanity\");\n+    assert(md != nullptr, \"Sanity\");\n@@ -1737,1 +1737,1 @@\n-    assert(data != NULL,                \"need data for type check\");\n+    assert(data != nullptr,                \"need data for type check\");\n@@ -1845,1 +1845,1 @@\n-      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -1889,2 +1889,2 @@\n-    ciMethodData* md = NULL;\n-    ciProfileData* data = NULL;\n+    ciMethodData* md = nullptr;\n+    ciProfileData* data = nullptr;\n@@ -1894,1 +1894,1 @@\n-      assert(method != NULL, \"Should have method\");\n+      assert(method != nullptr, \"Should have method\");\n@@ -1897,1 +1897,1 @@\n-      assert(md != NULL, \"Sanity\");\n+      assert(md != nullptr, \"Sanity\");\n@@ -1899,1 +1899,1 @@\n-      assert(data != NULL,                \"need data for type check\");\n+      assert(data != nullptr,                \"need data for type check\");\n@@ -1929,1 +1929,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -2059,1 +2059,1 @@\n-  if ((left_klass == NULL || right_klass == NULL) ||\/\/ The klass is still unloaded, or came from a Phi node.\n+  if ((left_klass == nullptr || right_klass == nullptr) ||\/\/ The klass is still unloaded, or came from a Phi node.\n@@ -2070,1 +2070,1 @@\n-  if (left_klass != NULL && left_klass->is_inlinetype() && left_klass == right_klass) {\n+  if (left_klass != nullptr && left_klass->is_inlinetype() && left_klass == right_klass) {\n@@ -2178,1 +2178,1 @@\n-    const2reg(src, dst, lir_patch_none, NULL);\n+    const2reg(src, dst, lir_patch_none, nullptr);\n@@ -2207,1 +2207,1 @@\n-    const2reg(opr1, result, lir_patch_none, NULL);\n+    const2reg(opr1, result, lir_patch_none, nullptr);\n@@ -2239,1 +2239,1 @@\n-      const2reg(opr2, result, lir_patch_none, NULL);\n+      const2reg(opr2, result, lir_patch_none, nullptr);\n@@ -2249,1 +2249,1 @@\n-  assert(info == NULL, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n+  assert(info == nullptr, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n@@ -2445,1 +2445,1 @@\n-        assert(const_addr != NULL, \"incorrect float\/double constant maintenance\");\n+        assert(const_addr != nullptr, \"incorrect float\/double constant maintenance\");\n@@ -2852,1 +2852,1 @@\n-        \/\/ All we need for now is a comparison with NULL for equality.\n+        \/\/ All we need for now is a comparison with null for equality.\n@@ -2855,1 +2855,1 @@\n-        if (m == NULL) {\n+        if (m == nullptr) {\n@@ -2863,1 +2863,1 @@\n-        if (o == NULL) {\n+        if (o == nullptr) {\n@@ -2873,1 +2873,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2923,1 +2923,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2944,1 +2944,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2967,1 +2967,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -3073,1 +3073,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -3083,1 +3083,1 @@\n-  __ mov_metadata(rbx, (Metadata*)NULL);\n+  __ mov_metadata(rbx, (Metadata*)nullptr);\n@@ -3260,1 +3260,1 @@\n-      \/\/ Take the slow path if it's a null_free destination array, in case the source array contains NULLs.\n+      \/\/ Take the slow path if it's a null_free destination array, in case the source array contains nullptrs.\n@@ -3285,1 +3285,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -3295,1 +3295,1 @@\n-  if (default_type == NULL) {\n+  if (default_type == nullptr) {\n@@ -3314,1 +3314,1 @@\n-    assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+    assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -3395,1 +3395,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(), \"must be true at this point\");\n@@ -3425,1 +3425,1 @@\n-  \/\/ test for NULL\n+  \/\/ test for null\n@@ -3506,1 +3506,1 @@\n-      __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, NULL);\n+      __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, nullptr);\n@@ -3522,1 +3522,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ use stub if available\n+      if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -3727,1 +3727,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -3736,1 +3736,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -3754,1 +3754,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -3775,1 +3775,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -3777,1 +3777,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -3790,1 +3790,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -3815,1 +3815,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -3852,1 +3852,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -3887,1 +3887,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -3900,2 +3900,2 @@\n-      if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n-        if (exact_klass != NULL) {\n+      if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n+        if (exact_klass != nullptr) {\n@@ -3929,1 +3929,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -3949,1 +3949,1 @@\n-      assert(exact_klass != NULL, \"should be\");\n+      assert(exact_klass != nullptr, \"should be\");\n@@ -3980,1 +3980,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -4107,1 +4107,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -4116,1 +4116,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -4126,1 +4126,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -4136,1 +4136,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  if (c && c->state_before() == NULL) {\n+  if (c && c->state_before() == nullptr) {\n@@ -160,1 +160,1 @@\n-  return c->type() != T_OBJECT || c->as_jobject() == NULL;\n+  return c->type() != T_OBJECT || c->as_jobject() == nullptr;\n@@ -334,1 +334,1 @@\n-  CodeEmitInfo* info_for_exception = NULL;\n+  CodeEmitInfo* info_for_exception = nullptr;\n@@ -411,1 +411,1 @@\n-    assert(c != NULL, \"invalid constant\");\n+    assert(c != nullptr, \"invalid constant\");\n@@ -457,1 +457,1 @@\n-    address entry = NULL;\n+    address entry = nullptr;\n@@ -527,1 +527,1 @@\n-    address entry = NULL;\n+    address entry = nullptr;\n@@ -555,1 +555,1 @@\n-    arithmetic_op_long(x->op(), reg, left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), reg, left.result(), right.result(), nullptr);\n@@ -567,1 +567,1 @@\n-    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), nullptr);\n@@ -611,1 +611,1 @@\n-      info = NULL;\n+      info = nullptr;\n@@ -678,1 +678,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -719,1 +719,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -895,1 +895,1 @@\n-  CallingConvention* cc = NULL;\n+  CallingConvention* cc = nullptr;\n@@ -920,1 +920,1 @@\n-      if (StubRoutines::dexp() != NULL) {\n+      if (StubRoutines::dexp() != nullptr) {\n@@ -927,1 +927,1 @@\n-      if (StubRoutines::dlog() != NULL) {\n+      if (StubRoutines::dlog() != nullptr) {\n@@ -934,1 +934,1 @@\n-      if (StubRoutines::dlog10() != NULL) {\n+      if (StubRoutines::dlog10() != nullptr) {\n@@ -941,1 +941,1 @@\n-      if (StubRoutines::dpow() != NULL) {\n+      if (StubRoutines::dpow() != nullptr) {\n@@ -948,1 +948,1 @@\n-      if (VM_Version::supports_sse2() && StubRoutines::dsin() != NULL) {\n+      if (VM_Version::supports_sse2() && StubRoutines::dsin() != nullptr) {\n@@ -955,1 +955,1 @@\n-      if (VM_Version::supports_sse2() && StubRoutines::dcos() != NULL) {\n+      if (VM_Version::supports_sse2() && StubRoutines::dcos() != nullptr) {\n@@ -962,1 +962,1 @@\n-      if (StubRoutines::dtan() != NULL) {\n+      if (StubRoutines::dtan() != nullptr) {\n@@ -973,1 +973,1 @@\n-      if (StubRoutines::dexp() != NULL) {\n+      if (StubRoutines::dexp() != nullptr) {\n@@ -980,1 +980,1 @@\n-      if (StubRoutines::dlog() != NULL) {\n+      if (StubRoutines::dlog() != nullptr) {\n@@ -987,1 +987,1 @@\n-      if (StubRoutines::dlog10() != NULL) {\n+      if (StubRoutines::dlog10() != nullptr) {\n@@ -994,1 +994,1 @@\n-       if (StubRoutines::dpow() != NULL) {\n+       if (StubRoutines::dpow() != nullptr) {\n@@ -1001,1 +1001,1 @@\n-      if (StubRoutines::dsin() != NULL) {\n+      if (StubRoutines::dsin() != nullptr) {\n@@ -1008,1 +1008,1 @@\n-      if (StubRoutines::dcos() != NULL) {\n+      if (StubRoutines::dcos() != nullptr) {\n@@ -1015,1 +1015,1 @@\n-       if (StubRoutines::dtan() != NULL) {\n+       if (StubRoutines::dtan() != nullptr) {\n@@ -1287,1 +1287,1 @@\n-  ConversionStub* stub = NULL;\n+  ConversionStub* stub = nullptr;\n@@ -1379,1 +1379,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1416,1 +1416,1 @@\n-  LIRItemList* items = new LIRItemList(i, i, NULL);\n+  LIRItemList* items = new LIRItemList(i, i, nullptr);\n@@ -1423,1 +1423,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1472,1 +1472,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1491,1 +1491,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1494,1 +1494,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1516,1 +1516,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  \/\/ location (NULL in the displaced hdr location indicates recursive locking)\n+  \/\/ location (null in the displaced hdr location indicates recursive locking)\n@@ -118,1 +118,1 @@\n-  \/\/ if the loaded hdr is NULL we had recursive locking\n+  \/\/ if the loaded hdr is null we had recursive locking\n@@ -295,1 +295,1 @@\n-  \/\/ explicit NULL check not needed since load from [klass_offset] causes a trap\n+  \/\/ explicit null check not needed since load from [klass_offset] causes a trap\n@@ -352,2 +352,2 @@\n-  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n-  if (verified_inline_entry_label != NULL) {\n+  bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n+  if (verified_inline_entry_label != nullptr) {\n@@ -400,1 +400,1 @@\n-  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+  bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-    set_last_Java_frame(thread, noreg, rbp, NULL, rscratch1);\n+    set_last_Java_frame(thread, noreg, rbp, nullptr, rscratch1);\n@@ -676,1 +676,1 @@\n-  OopMap* oop_map = NULL;\n+  OopMap* oop_map = nullptr;\n@@ -873,1 +873,1 @@\n-  assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+  assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -889,1 +889,1 @@\n-  __ set_last_Java_frame(thread, noreg, rbp, NULL, rscratch1);\n+  __ set_last_Java_frame(thread, noreg, rbp, nullptr, rscratch1);\n@@ -1003,1 +1003,1 @@\n-  OopMapSet* oop_maps = NULL;\n+  OopMapSet* oop_maps = nullptr;\n@@ -1384,1 +1384,1 @@\n-        __ check_klass_subtype_slow_path(rsi, rax, rcx, rdi, NULL, &miss);\n+        __ check_klass_subtype_slow_path(rsi, rax, rcx, rdi, nullptr, &miss);\n@@ -1459,1 +1459,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -1609,1 +1609,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  if (BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n+  if (BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {\n@@ -169,1 +169,2 @@\n-      slow_path = &stub->entry();                                                                                                                                                                                                                                                                                                                                                              continuation = &stub->continuation();\n+      slow_path = &stub->entry();\n+      continuation = &stub->continuation();\n@@ -175,1 +176,1 @@\n-  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+  bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n@@ -255,1 +256,1 @@\n-  if (method_data != NULL) {\n+  if (method_data != nullptr) {\n@@ -269,1 +270,1 @@\n-  if (method_data != NULL) {\n+  if (method_data != nullptr) {\n@@ -287,1 +288,1 @@\n-  assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+  assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -297,1 +298,1 @@\n-    assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -383,1 +384,1 @@\n-    assert(stack_rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(stack_rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -443,1 +444,1 @@\n-    assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -692,1 +693,1 @@\n-  \/\/ If we weren't able to swing _owner from NULL to the BasicLock\n+  \/\/ If we weren't able to swing _owner from null to the BasicLock\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  if (_cb != NULL ) {\n+  if (_cb != nullptr ) {\n@@ -116,4 +116,4 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n+    intptr_t* sender_sp = nullptr;\n+    intptr_t* sender_unextended_sp = nullptr;\n+    address   sender_pc = nullptr;\n+    intptr_t* saved_fp =  nullptr;\n@@ -187,1 +187,1 @@\n-    if (sender_pc == NULL ||  sender_blob == NULL) {\n+    if (sender_pc == nullptr ||  sender_blob == nullptr) {\n@@ -220,1 +220,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -262,1 +262,1 @@\n-  if ( (address) this->fp()[return_addr_offset] == NULL) return false;\n+  if ( (address) this->fp()[return_addr_offset] == nullptr) return false;\n@@ -290,1 +290,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -362,1 +362,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -389,1 +389,1 @@\n-  return jfa->last_Java_sp() == NULL;\n+  return jfa->last_Java_sp() == nullptr;\n@@ -393,1 +393,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -438,1 +438,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -440,1 +440,1 @@\n-    if (sender_cm != NULL) {\n+    if (sender_cm != nullptr) {\n@@ -567,1 +567,1 @@\n-        obj = (obj_p == NULL) ? (oop)NULL : *obj_p;\n+        obj = (obj_p == nullptr) ? (oop)nullptr : *obj_p;\n@@ -681,1 +681,1 @@\n-  if (last_Java_sp() == NULL) return;\n+  if (last_Java_sp() == nullptr) return;\n@@ -684,1 +684,1 @@\n-  vmassert(last_Java_pc() == NULL, \"already walkable\");\n+  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -45,5 +45,5 @@\n-  _pc = NULL;\n-  _sp = NULL;\n-  _unextended_sp = NULL;\n-  _fp = NULL;\n-  _cb = NULL;\n+  _pc = nullptr;\n+  _sp = nullptr;\n+  _unextended_sp = nullptr;\n+  _fp = nullptr;\n+  _cb = nullptr;\n@@ -51,1 +51,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -61,1 +61,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -65,1 +65,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -74,1 +74,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -77,1 +77,1 @@\n-    assert(_cb == NULL || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n@@ -97,1 +97,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -99,2 +99,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n@@ -121,1 +121,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -138,1 +138,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -140,2 +140,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(sp), p2i(unextended_sp), p2i(fp));\n@@ -166,1 +166,1 @@\n-  \/\/ assert(_pc != NULL, \"no pc?\");\n+  \/\/ assert(_pc != nullptr, \"no pc?\");\n@@ -172,1 +172,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -178,1 +178,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -193,1 +193,1 @@\n-\/\/ identity and younger\/older relationship. NULL represents an invalid (incomparable)\n+\/\/ identity and younger\/older relationship. null represents an invalid (incomparable)\n@@ -198,1 +198,1 @@\n-inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != NULL && id != NULL, \"NULL frame id\");\n+inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != nullptr && id != nullptr, \"null frame id\");\n@@ -205,1 +205,1 @@\n-  return os::is_readable_pointer(ptr) ? *ptr : NULL;\n+  return os::is_readable_pointer(ptr) ? *ptr : nullptr;\n@@ -214,1 +214,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -238,1 +238,1 @@\n-  assert(mask != NULL, \"\");\n+  assert(mask != nullptr, \"\");\n@@ -291,1 +291,1 @@\n-  if (last_sp == NULL) {\n+  if (last_sp == nullptr) {\n@@ -329,1 +329,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -335,1 +335,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -349,2 +349,2 @@\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n+  if (_cb == nullptr) return nullptr;\n+  if (_cb->oop_maps() != nullptr) {\n@@ -352,1 +352,1 @@\n-    if (nop != NULL && nop->displacement() != 0) {\n+    if (nop != nullptr && nop->displacement() != 0) {\n@@ -359,1 +359,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -389,1 +389,1 @@\n-  if (_cb != NULL) return sender_for_compiled_frame(map);\n+  if (_cb != nullptr) return sender_for_compiled_frame(map);\n@@ -397,1 +397,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -436,1 +436,1 @@\n-    if (nm != NULL && nm->is_compiled_by_c1() && nm->method()->has_scalarized_args() &&\n+    if (nm != nullptr && nm->is_compiled_by_c1() && nm->method()->has_scalarized_args() &&\n@@ -453,1 +453,1 @@\n-      if (oop_map() != NULL) {\n+      if (oop_map() != nullptr) {\n@@ -459,1 +459,1 @@\n-      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n+      assert(oop_map() == nullptr || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,1 +248,1 @@\n-  \/\/ that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.\n+  \/\/ that checks that the *(ebp+frame::interpreter_frame_last_sp) == nullptr.\n@@ -323,1 +323,1 @@\n-  \/\/ crosses regions, storing NULL?\n+  \/\/ crosses regions, storing null?\n@@ -328,1 +328,1 @@\n-  \/\/ storing region crossing non-NULL, is card already dirty?\n+  \/\/ storing region crossing non-null, is card already dirty?\n@@ -348,1 +348,1 @@\n-  \/\/ storing a region crossing, non-NULL oop, card is clean.\n+  \/\/ storing a region crossing, non-null oop, card is clean.\n@@ -580,1 +580,1 @@\n-  \/\/ At this point we know new_value is non-NULL and the new_value crosses regions.\n+  \/\/ At this point we know new_value is non-null and the new_value crosses regions.\n@@ -610,1 +610,1 @@\n-  \/\/ storing region crossing non-NULL, card is clean.\n+  \/\/ storing region crossing non-null, card is clean.\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-  if (bs_nm == NULL) {\n+  if (bs_nm == nullptr) {\n@@ -416,1 +416,1 @@\n-  if (slow_path != NULL) {\n+  if (slow_path != nullptr) {\n@@ -429,1 +429,1 @@\n-  if (bs_nm == NULL) {\n+  if (bs_nm == nullptr) {\n@@ -450,1 +450,1 @@\n-  if (bs == NULL) {\n+  if (bs == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap NULLs passed to check cast\n+define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap nulls passed to check cast\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != null\");\n@@ -304,1 +304,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != nullptr\");\n@@ -403,1 +403,1 @@\n-    jcc(Assembler::zero, L); \/\/ if (thread->jvmti_thread_state() == NULL) exit;\n+    jcc(Assembler::zero, L); \/\/ if (thread->jvmti_thread_state() == nullptr) exit;\n@@ -1534,1 +1534,1 @@\n-  \/\/ Test MDO to avoid the call if it is NULL.\n+  \/\/ Test MDO to avoid the call if it is null.\n@@ -1917,1 +1917,1 @@\n-  \/\/ observed the item[start_row] is NULL.\n+  \/\/ observed the item[start_row] is null.\n@@ -1933,1 +1933,1 @@\n-\/\/   if (row[0].rec != NULL) {\n+\/\/   if (row[0].rec != nullptr) {\n@@ -1936,1 +1936,1 @@\n-\/\/     if (row[1].rec != NULL) {\n+\/\/     if (row[1].rec != nullptr) {\n@@ -1939,1 +1939,1 @@\n-\/\/       if (row[2].rec != NULL) { count.incr(); goto done; } \/\/ overflow\n+\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n@@ -2223,1 +2223,1 @@\n-  if (where != NULL) {\n+  if (where != nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-    \/\/ NULL last_sp until next java call\n+    \/\/ null last_sp until next java call\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  const char *name = NULL;\n+  const char *name = nullptr;\n@@ -111,1 +111,1 @@\n-  address slow_case_addr = NULL;\n+  address slow_case_addr = nullptr;\n@@ -154,1 +154,1 @@\n-  const char *name = NULL;\n+  const char *name = nullptr;\n@@ -203,1 +203,1 @@\n-  address slow_case_addr = NULL;\n+  address slow_case_addr = nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1045,1 +1045,1 @@\n-  \/\/ See if oop is NULL if it is we need no handle\n+  \/\/ See if oop is null if it is we need no handle\n@@ -1058,1 +1058,1 @@\n-    \/\/ conditionally move a NULL\n+    \/\/ conditionally move a null\n@@ -1063,1 +1063,1 @@\n-    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-null\n@@ -1086,1 +1086,1 @@\n-    \/\/ Store oop in handle area, may be NULL\n+    \/\/ Store oop in handle area, may be null\n@@ -1094,1 +1094,1 @@\n-    \/\/ conditionally move a NULL from the handle area where it was just stored\n+    \/\/ conditionally move a null from the handle area where it was just stored\n@@ -1353,1 +1353,1 @@\n-  mov_metadata(rbx, (Metadata*) NULL);  \/\/ Method is zapped till fixup time.\n+  mov_metadata(rbx, (Metadata*) nullptr);  \/\/ Method is zapped till fixup time.\n@@ -1571,1 +1571,1 @@\n-  set_last_Java_frame(java_thread, last_java_sp, rbp, NULL, rscratch1);\n+  set_last_Java_frame(java_thread, last_java_sp, rbp, nullptr, rscratch1);\n@@ -2867,1 +2867,1 @@\n-    \/\/ provoke OS NULL exception if reg = NULL by\n+    \/\/ provoke OS null exception if reg is null by\n@@ -2876,1 +2876,1 @@\n-    \/\/ will provoke OS NULL exception if reg = NULL\n+    \/\/ will provoke OS null exception if reg is null\n@@ -3027,1 +3027,1 @@\n-  const char* buf = NULL;\n+  const char* buf = nullptr;\n@@ -3258,1 +3258,1 @@\n-  if (last_java_pc != NULL) {\n+  if (last_java_pc != nullptr) {\n@@ -4040,1 +4040,1 @@\n-  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  jcc(Assembler::zero, done);           \/\/ Use null as-is.\n@@ -4074,1 +4074,1 @@\n-  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  jcc(Assembler::zero, done);           \/\/ Use null as-is.\n@@ -4579,1 +4579,1 @@\n-  \/\/ for (scan = klass->itable(); scan->interface() != NULL; scan += scan_step) {\n+  \/\/ for (scan = klass->itable(); scan->interface() != nullptr; scan += scan_step) {\n@@ -4637,2 +4637,2 @@\n-  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &L_success, &L_failure, NULL);\n-  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &L_success, NULL);\n+  check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &L_success, &L_failure, nullptr);\n+  check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &L_success, nullptr);\n@@ -4661,4 +4661,4 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  if (L_slow_path == NULL) { L_slow_path = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_slow_path == nullptr) { L_slow_path = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -4760,3 +4760,3 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -4818,1 +4818,1 @@\n-    assert(!pushed_rdi, \"rdi must be left non-NULL\");\n+    assert(!pushed_rdi, \"rdi must be left non-null\");\n@@ -4839,1 +4839,1 @@\n-  assert(L_fast_path != NULL || L_slow_path != NULL, \"at least one is required\");\n+  assert(L_fast_path != nullptr || L_slow_path != nullptr, \"at least one is required\");\n@@ -4842,1 +4842,1 @@\n-  if (L_fast_path == NULL) {\n+  if (L_fast_path == nullptr) {\n@@ -4844,1 +4844,1 @@\n-  } else if (L_slow_path == NULL) {\n+  } else if (L_slow_path == nullptr) {\n@@ -4902,1 +4902,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -4976,1 +4976,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -5045,1 +5045,1 @@\n-        rc = NULL; \/\/ silence compiler warnings\n+        rc = nullptr; \/\/ silence compiler warnings\n@@ -5056,1 +5056,1 @@\n-        pc = NULL; \/\/ silence compiler warnings\n+        pc = nullptr; \/\/ silence compiler warnings\n@@ -5178,1 +5178,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5567,1 +5567,1 @@\n-\/\/ Used for storing NULLs.\n+\/\/ Used for storing nulls.\n@@ -5583,1 +5583,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -5608,1 +5608,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -5633,1 +5633,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -5657,1 +5657,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -5670,1 +5670,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -5688,1 +5688,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -5695,1 +5695,1 @@\n-    if (CompressedOops::base() != NULL) {\n+    if (CompressedOops::base() != nullptr) {\n@@ -5699,1 +5699,1 @@\n-    assert (CompressedOops::base() == NULL, \"sanity\");\n+    assert (CompressedOops::base() == nullptr, \"sanity\");\n@@ -5706,1 +5706,1 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -5719,1 +5719,1 @@\n-      if (CompressedOops::base() != NULL) {\n+      if (CompressedOops::base() != nullptr) {\n@@ -5724,1 +5724,1 @@\n-    assert (CompressedOops::base() == NULL, \"sanity\");\n+    assert (CompressedOops::base() == nullptr, \"sanity\");\n@@ -5733,1 +5733,1 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  if (CompressedKlassPointers::base() != nullptr) {\n@@ -5745,1 +5745,1 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  if (CompressedKlassPointers::base() != nullptr) {\n@@ -5768,1 +5768,1 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  if (CompressedKlassPointers::base() != nullptr) {\n@@ -5782,1 +5782,1 @@\n-  if (CompressedKlassPointers::base() == NULL &&\n+  if (CompressedKlassPointers::base() == nullptr &&\n@@ -5788,1 +5788,1 @@\n-    if (CompressedKlassPointers::base() != NULL) {\n+    if (CompressedKlassPointers::base() != nullptr) {\n@@ -5805,2 +5805,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5814,2 +5814,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5823,1 +5823,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5831,1 +5831,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5839,2 +5839,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5848,2 +5848,2 @@\n-  assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5857,1 +5857,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5865,1 +5865,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -5873,2 +5873,2 @@\n-    if (Universe::heap() != NULL) {\n-      if (CompressedOops::base() == NULL) {\n+    if (Universe::heap() != nullptr) {\n+      if (CompressedOops::base() == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":63,"deletions":63,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  \/\/ Support for NULL-checks\n+  \/\/ Support for null-checks\n@@ -99,1 +99,1 @@\n-  \/\/ Generates code that causes a NULL OS exception if the content of reg is NULL.\n+  \/\/ Generates code that causes a null OS exception if the content of reg is null.\n@@ -156,1 +156,1 @@\n-                file == NULL ? \"<NULL>\" : file, line);\n+                file == nullptr ? \"<null>\" : file, line);\n@@ -425,1 +425,1 @@\n-  \/\/ Used for storing NULL. All other oop constants should be\n+  \/\/ Used for storing null. All other oop constants should be\n@@ -435,1 +435,1 @@\n-  \/\/ converting a zero (like NULL) into a Register by giving\n+  \/\/ converting a zero (like null) into a Register by giving\n@@ -672,1 +672,1 @@\n-  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ One of the three labels can be null, meaning take the fall-through.\n@@ -705,2 +705,2 @@\n-                      Label* L_fast_path = NULL,\n-                      Label* L_slow_path = NULL);\n+                      Label* L_fast_path = nullptr,\n+                      Label* L_slow_path = nullptr);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,1 +238,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -245,1 +245,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -528,2 +528,2 @@\n-  bool has_mh = (strstr(adaptername, \"\/static\") == NULL &&\n-                 strstr(adaptername, \"linkTo\") == NULL);    \/\/ static linkers don't have MH\n+  bool has_mh = (strstr(adaptername, \"\/static\") == nullptr &&\n+                 strstr(adaptername, \"linkTo\") == nullptr);    \/\/ static linkers don't have MH\n@@ -591,1 +591,1 @@\n-          assert(trace_calling_frame.cb() == NULL, \"not a C frame\");\n+          assert(trace_calling_frame.cb() == nullptr, \"not a C frame\");\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-      (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {\n+      (Interpreter::code() != nullptr || StubRoutines::code1() != nullptr)) {\n@@ -767,1 +767,1 @@\n-    if (Interpreter::code() != NULL)\n+    if (Interpreter::code() != nullptr)\n@@ -771,1 +771,1 @@\n-    if (StubRoutines::code1() != NULL)\n+    if (StubRoutines::code1() != nullptr)\n@@ -775,1 +775,1 @@\n-    if (StubRoutines::code2() != NULL)\n+    if (StubRoutines::code2() != nullptr)\n@@ -981,1 +981,1 @@\n-  OopMapSet* oop_maps = NULL;\n+  OopMapSet* oop_maps = nullptr;\n@@ -986,1 +986,0 @@\n-  __ flush();\n@@ -995,1 +994,1 @@\n-  assert(regs2 == NULL, \"not needed on x86\");\n+  assert(regs2 == nullptr, \"not needed on x86\");\n@@ -1348,1 +1347,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       (OopMapSet*)nullptr);\n@@ -1351,1 +1350,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -1367,1 +1366,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -1382,1 +1381,1 @@\n-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);\n+  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n@@ -1508,1 +1507,1 @@\n-  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+  bs->nmethod_entry_barrier(masm, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n@@ -2096,1 +2095,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2225,1 +2224,1 @@\n-  __ set_last_Java_frame(rcx, noreg, noreg, NULL, noreg);\n+  __ set_last_Java_frame(rcx, noreg, noreg, nullptr, noreg);\n@@ -2373,1 +2372,1 @@\n-  __ set_last_Java_frame(rcx, noreg, rbp, NULL, noreg);\n+  __ set_last_Java_frame(rcx, noreg, rbp, nullptr, noreg);\n@@ -2470,1 +2469,1 @@\n-  __ set_last_Java_frame(rdx, noreg, noreg, NULL, noreg);\n+  __ set_last_Java_frame(rdx, noreg, noreg, nullptr, noreg);\n@@ -2582,1 +2581,1 @@\n-  __ set_last_Java_frame(rdi, noreg, rbp, NULL, noreg);\n+  __ set_last_Java_frame(rdi, noreg, rbp, nullptr, noreg);\n@@ -2622,1 +2621,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -2635,1 +2634,1 @@\n-  address call_pc = NULL;\n+  address call_pc = nullptr;\n@@ -2664,1 +2663,1 @@\n-  __ set_last_Java_frame(java_thread, noreg, noreg, NULL, noreg);\n+  __ set_last_Java_frame(java_thread, noreg, noreg, nullptr, noreg);\n@@ -2777,1 +2776,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -2791,1 +2790,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2803,1 +2802,1 @@\n-  __ set_last_Java_frame(thread, noreg, rbp, NULL, noreg);\n+  __ set_last_Java_frame(thread, noreg, rbp, nullptr, noreg);\n@@ -2861,1 +2860,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -851,1 +851,1 @@\n-      __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+      __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n@@ -1055,1 +1055,1 @@\n-      (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {\n+      (Interpreter::code() != nullptr || StubRoutines::code1() != nullptr)) {\n@@ -1064,1 +1064,1 @@\n-    if (Interpreter::code() != NULL)\n+    if (Interpreter::code() != nullptr)\n@@ -1068,1 +1068,1 @@\n-    if (StubRoutines::code1() != NULL)\n+    if (StubRoutines::code1() != nullptr)\n@@ -1072,1 +1072,1 @@\n-    if (StubRoutines::code2() != NULL)\n+    if (StubRoutines::code2() != nullptr)\n@@ -1288,1 +1288,1 @@\n-  address c2i_no_clinit_check_entry = NULL;\n+  address c2i_no_clinit_check_entry = nullptr;\n@@ -1314,1 +1314,0 @@\n-  __ flush();\n@@ -1330,1 +1329,1 @@\n-  assert(regs2 == NULL, \"not needed on x86\");\n+  assert(regs2 == nullptr, \"not needed on x86\");\n@@ -2044,1 +2043,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       nullptr);\n@@ -2047,1 +2046,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -2064,1 +2063,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -2079,1 +2078,1 @@\n-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);\n+  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n@@ -2209,1 +2208,1 @@\n-  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/);\n+  bs->nmethod_entry_barrier(masm, nullptr \/* slow_path *\/, nullptr \/* continuation *\/);\n@@ -2813,1 +2812,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2891,1 +2890,1 @@\n-    __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+    __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n@@ -2973,1 +2972,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n@@ -3006,1 +3005,1 @@\n-  \/\/ QQQ this is useless it was NULL above\n+  \/\/ QQQ this is useless it was null above\n@@ -3192,1 +3191,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n@@ -3350,1 +3349,1 @@\n-  assert(StubRoutines::forward_exception_entry() != NULL,\n+  assert(StubRoutines::forward_exception_entry() != nullptr,\n@@ -3362,1 +3361,1 @@\n-  address call_pc = NULL;\n+  address call_pc = nullptr;\n@@ -3386,1 +3385,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);  \/\/ JavaFrameAnchor::capture_last_Java_pc() will get the pc from the return address, which we store next:\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);  \/\/ JavaFrameAnchor::capture_last_Java_pc() will get the pc from the return address, which we store next:\n@@ -3516,1 +3515,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -3527,1 +3526,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -3536,1 +3535,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -480,1 +480,1 @@\n-  assert(StubRoutines::_call_stub_return_address != NULL,\n+  assert(StubRoutines::_call_stub_return_address != nullptr,\n@@ -1112,1 +1112,1 @@\n-  __ jcc(Assembler::zero, exit); \/\/ if obj is NULL it is OK\n+  __ jcc(Assembler::zero, exit); \/\/ if obj is null it is OK\n@@ -4260,1 +4260,1 @@\n-  if (bs_nm != NULL) {\n+  if (bs_nm != nullptr) {\n@@ -4287,1 +4287,1 @@\n-  void *libjsvml = NULL;\n+  void *libjsvml = nullptr;\n@@ -4293,1 +4293,1 @@\n-  if (libjsvml != NULL) {\n+  if (libjsvml != nullptr) {\n@@ -4357,1 +4357,1 @@\n-  if (UnsafeCopyMemory::_table == NULL) {\n+  if (UnsafeCopyMemory::_table == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-    assert(no_overlap_target != NULL, \"must be generated\");\n-    array_overlap_test(no_overlap_target, NULL, sf);\n+    assert(no_overlap_target != nullptr, \"must be generated\");\n+    array_overlap_test(no_overlap_target, nullptr, sf);\n@@ -129,1 +129,1 @@\n-    array_overlap_test(NULL, &L_no_overlap, sf);\n+    array_overlap_test(nullptr, &L_no_overlap, sf);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-                                                                                   NULL, \"oop_arraycopy_uninit\",\n+                                                                                   nullptr, \"oop_arraycopy_uninit\",\n@@ -127,1 +127,1 @@\n-                                                                                    NULL, \"oop_arraycopy_uninit\",\n+                                                                                    nullptr, \"oop_arraycopy_uninit\",\n@@ -132,1 +132,1 @@\n-  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", NULL,\n+  StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n@@ -215,1 +215,1 @@\n-  if (NOLp == NULL) {\n+  if (NOLp == nullptr) {\n@@ -533,1 +533,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -755,1 +755,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1155,1 +1155,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1268,1 +1268,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1386,1 +1386,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1517,1 +1517,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1628,1 +1628,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1735,1 +1735,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1853,1 +1853,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -1961,1 +1961,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -2043,1 +2043,1 @@\n-  __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, NULL,\n+  __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg,        &L_success, &L_miss, nullptr,\n@@ -2045,1 +2045,1 @@\n-  __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, NULL);\n+  __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, nullptr);\n@@ -2122,1 +2122,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -2429,1 +2429,1 @@\n-  \/\/ (5) src klass and dst klass should be the same and not NULL.\n+  \/\/ (5) src klass and dst klass should be the same and not null.\n@@ -2435,1 +2435,1 @@\n-  \/\/  if (src == NULL) return -1;\n+  \/\/  if (src == nullptr) return -1;\n@@ -2444,1 +2444,1 @@\n-  \/\/  if (dst == NULL) return -1;\n+  \/\/  if (dst == nullptr) return -1;\n@@ -2472,1 +2472,1 @@\n-  \/\/  assert(src->klass() != NULL);\n+  \/\/  assert(src->klass() != nullptr);\n@@ -2477,1 +2477,1 @@\n-    __ jcc(Assembler::notZero, L2);   \/\/ it is broken if klass is NULL\n+    __ jcc(Assembler::notZero, L2);   \/\/ it is broken if klass is null\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  assert(!pass_oop || message == NULL, \"either oop or message but not both\");\n+  assert(!pass_oop || message == nullptr, \"either oop or message but not both\");\n@@ -210,1 +210,1 @@\n-  \/\/ and NULL it as marker that esp is now tos until next java call\n+  \/\/ and null it as marker that esp is now tos until next java call\n@@ -262,1 +262,1 @@\n-  \/\/ NULL last_sp until next java call\n+  \/\/ null last_sp until next java call\n@@ -305,1 +305,1 @@\n-  if (continuation == NULL) {\n+  if (continuation == nullptr) {\n@@ -443,2 +443,2 @@\n-  \/\/ (NULL bcp).  We pass zero for it.  The call returns the address\n-  \/\/ of the verified entry point for the method or NULL if the\n+  \/\/ (null bcp).  We pass zero for it.  The call returns the address\n+  \/\/ of the verified entry point for the method or null if the\n@@ -544,1 +544,1 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != NULL, \"stub not yet generated\");\n+  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n@@ -598,1 +598,1 @@\n-      __ stop(\"synchronization object is NULL\");\n+      __ stop(\"synchronization object is null\");\n@@ -696,1 +696,1 @@\n-  \/\/ Check if local 0 != NULL\n+  \/\/ Check if local 0 != null\n@@ -1311,1 +1311,1 @@\n-  \/\/  pop return address, reset last_sp to NULL\n+  \/\/  pop return address, reset last_sp to null\n@@ -1659,1 +1659,1 @@\n-    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.\n+    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or null.\n@@ -1848,1 +1848,1 @@\n-  assert(Interpreter::trace_code(t->tos_in()) != NULL,\n+  assert(Interpreter::trace_code(t->tos_in()) != nullptr,\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,2 +147,2 @@\n-\/\/ Store an oop (or NULL) at the address described by obj.\n-\/\/ If val == noreg this means store a NULL\n+\/\/ Store an oop (or null) at the address described by obj.\n+\/\/ If val == noreg this means store a null\n@@ -458,1 +458,1 @@\n-    __ xorptr(result, result);  \/\/ NULL object reference\n+    __ xorptr(result, result);  \/\/ null object reference\n@@ -1190,1 +1190,1 @@\n-  \/\/ Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]\n+  \/\/ Have a null in rax, rdx=array, ecx=index.  Store null at ary[idx]\n@@ -1204,1 +1204,1 @@\n-  \/\/ Store a NULL\n+  \/\/ Store a null\n@@ -2287,1 +2287,1 @@\n-          UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+          UseOnStackReplacement ? &backedge_counter_overflow : nullptr);\n@@ -2295,1 +2295,1 @@\n-        UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+        UseOnStackReplacement ? &backedge_counter_overflow : nullptr);\n@@ -2321,1 +2321,1 @@\n-      \/\/ rax: osr nmethod (osr ok) or NULL (osr not possible)\n+      \/\/ rax: osr nmethod (osr ok) or null (osr not possible)\n@@ -2813,1 +2813,1 @@\n-    __ clinit_barrier(klass, thread, NULL \/*L_fast_path*\/, &L_clinit_barrier_slow);\n+    __ clinit_barrier(klass, thread, nullptr \/*L_fast_path*\/, &L_clinit_barrier_slow);\n@@ -2900,1 +2900,1 @@\n-      __ xorptr(rax, rax);      \/\/ NULL object reference\n+      __ xorptr(rax, rax);      \/\/ null object reference\n@@ -2906,1 +2906,1 @@\n-    \/\/ rax,:   object pointer or NULL\n+    \/\/ rax,:   object pointer or null\n@@ -3269,1 +3269,1 @@\n-    \/\/ c_rarg1: object pointer set up above (NULL if static)\n+    \/\/ c_rarg1: object pointer set up above (null if static)\n@@ -4450,1 +4450,1 @@\n-  \/\/ Collect counts on whether this check-cast sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this check-cast sees nulls a lot or not.\n@@ -4525,1 +4525,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -4534,2 +4534,2 @@\n-  \/\/ rax = 0: obj == NULL or  obj is not an instanceof the specified klass\n-  \/\/ rax = 1: obj != NULL and obj is     an instanceof the specified klass\n+  \/\/ rax = 0: obj == nullptr or  obj is not an instanceof the specified klass\n+  \/\/ rax = 1: obj != nullptr and obj is     an instanceof the specified klass\n@@ -4596,1 +4596,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n@@ -4616,1 +4616,1 @@\n-  __ xorl(rmon, rmon); \/\/ points to free slot or NULL\n+  __ xorl(rmon, rmon); \/\/ points to free slot or null\n@@ -4702,1 +4702,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-static get_cpu_info_stub_t get_cpu_info_stub = NULL;\n-static detect_virt_stub_t detect_virt_stub = NULL;\n+static get_cpu_info_stub_t get_cpu_info_stub = nullptr;\n+static detect_virt_stub_t detect_virt_stub = nullptr;\n@@ -405,1 +405,1 @@\n-    \/\/ Generate SEGV here (reference through NULL)\n+    \/\/ Generate SEGV here (reference through null)\n@@ -2114,1 +2114,1 @@\n-  if (stub_blob == NULL) {\n+  if (stub_blob == nullptr) {\n@@ -2188,1 +2188,1 @@\n-static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;\n+static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = nullptr;\n@@ -2198,1 +2198,1 @@\n-static char* _cpu_brand_string = NULL;\n+static char* _cpu_brand_string = nullptr;\n@@ -2323,1 +2323,1 @@\n-  NULL\n+  nullptr\n@@ -2338,1 +2338,1 @@\n-  NULL\n+  nullptr\n@@ -2486,1 +2486,1 @@\n-  if (cpuid_brand_string_stub_blob == NULL) {\n+  if (cpuid_brand_string_stub_blob == nullptr) {\n@@ -2498,1 +2498,1 @@\n-  const char* model = NULL;\n+  const char* model = nullptr;\n@@ -2503,1 +2503,1 @@\n-      if (model == NULL) {\n+      if (model == nullptr) {\n@@ -2512,1 +2512,1 @@\n-  if (_cpu_brand_string == NULL) {\n+  if (_cpu_brand_string == nullptr) {\n@@ -2514,2 +2514,2 @@\n-    if (NULL == _cpu_brand_string) {\n-      return NULL;\n+    if (nullptr == _cpu_brand_string) {\n+      return nullptr;\n@@ -2520,1 +2520,1 @@\n-      _cpu_brand_string = NULL;\n+      _cpu_brand_string = nullptr;\n@@ -2527,1 +2527,1 @@\n-  const char*  brand  = NULL;\n+  const char*  brand  = nullptr;\n@@ -2532,1 +2532,1 @@\n-    for (int i = 0; brand != NULL && i <= brand_num; i += 1) {\n+    for (int i = 0; brand != nullptr && i <= brand_num; i += 1) {\n@@ -2622,1 +2622,1 @@\n-  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf != nullptr, \"buffer is null!\");\n@@ -2625,2 +2625,2 @@\n-  const char* cpu_type = NULL;\n-  const char* x64 = NULL;\n+  const char* cpu_type = nullptr;\n+  const char* x64 = nullptr;\n@@ -2659,1 +2659,1 @@\n-  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf != nullptr, \"buffer is null!\");\n@@ -2661,1 +2661,1 @@\n-  assert(getCPUIDBrandString_stub != NULL, \"not initialized\");\n+  assert(getCPUIDBrandString_stub != nullptr, \"not initialized\");\n@@ -2684,1 +2684,1 @@\n-  guarantee(buf != NULL, \"buffer is NULL!\");\n+  guarantee(buf != nullptr, \"buffer is null!\");\n@@ -2745,1 +2745,1 @@\n-  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf != nullptr, \"buffer is null!\");\n@@ -2750,3 +2750,3 @@\n-  const char*        family = NULL;\n-  const char*        model = NULL;\n-  const char*        brand = NULL;\n+  const char*        family = nullptr;\n+  const char*        model = nullptr;\n+  const char*        brand = nullptr;\n@@ -2756,1 +2756,1 @@\n-  if (family == NULL) {\n+  if (family == nullptr) {\n@@ -2761,1 +2761,1 @@\n-  if (model == NULL) {\n+  if (model == nullptr) {\n@@ -2767,1 +2767,1 @@\n-  if (brand == NULL) {\n+  if (brand == nullptr) {\n@@ -2769,1 +2769,1 @@\n-    if (brand == NULL) {\n+    if (brand == nullptr) {\n@@ -2838,1 +2838,1 @@\n-  if (brand_string == NULL) {\n+  if (brand_string == nullptr) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,3 +52,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be nullptr if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -124,1 +124,1 @@\n-    __ stop(\"Vtable entry is NULL\");\n+    __ stop(\"Vtable entry is null\");\n@@ -148,3 +148,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be nullptr if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-  void finalize_stubs();\n+  bool finalize_stubs();\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,0 +289,5 @@\n+  if (!code()->finalize_stubs()) {\n+    bailout(\"CodeCache is full\");\n+    return;\n+  }\n+\n@@ -316,3 +321,0 @@\n-\n-  \/\/ done\n-  masm()->flush();\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -577,1 +577,1 @@\n-    int offset = field->offset();\n+    int offset = field->offset_in_bytes();\n@@ -587,1 +587,1 @@\n-    int offset = field->offset();\n+    int offset = field->offset_in_bytes();\n@@ -628,1 +628,1 @@\n-      int offset = field->offset();\n+      int offset = field->offset_in_bytes();\n@@ -696,1 +696,1 @@\n-      int offset = field->offset();\n+      int offset = field->offset_in_bytes();\n@@ -1867,1 +1867,1 @@\n-    int off = inner_field->offset() - vk->first_field_offset();\n+    int off = inner_field->offset_in_bytes() - vk->first_field_offset();\n@@ -1916,1 +1916,1 @@\n-  int offset = !needs_patching ? field->offset() : -1;\n+  int offset = !needs_patching ? field->offset_in_bytes() : -1;\n@@ -2065,1 +2065,1 @@\n-              DelayedFieldAccess* dfa = new DelayedFieldAccess(obj, field->holder(), field->offset());\n+              DelayedFieldAccess* dfa = new DelayedFieldAccess(obj, field->holder(), field->offset_in_bytes());\n@@ -2097,1 +2097,1 @@\n-                                    pending_field_access()->offset() + field->offset() - field->holder()->as_inline_klass()->first_field_offset(),\n+                                    pending_field_access()->offset() + field->offset_in_bytes() - field->holder()->as_inline_klass()->first_field_offset(),\n@@ -2101,1 +2101,1 @@\n-                copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(), state_before);\n+                copy_inline_content(inline_klass, obj, field->offset_in_bytes(), new_instance, inline_klass->first_field_offset(), state_before);\n@@ -2171,1 +2171,1 @@\n-  const int offset_modify = !needs_patching ? field_modify->offset() : -1;\n+  const int offset_modify = !needs_patching ? field_modify->offset_in_bytes() : -1;\n@@ -2188,1 +2188,1 @@\n-      int offset = field->offset();\n+      int offset = field->offset_in_bytes();\n@@ -2190,1 +2190,1 @@\n-      if (offset != field_modify->offset()) {\n+      if (offset != field_modify->offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1809,1 +1809,1 @@\n-    int obj_offset = inner_field->offset();\n+    int obj_offset = inner_field->offset_in_bytes();\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,1 @@\n-                   && (all_offsets || lf->field()->offset() == field->offset());\n+                   && (all_offsets || lf->field()->offset_in_bytes() == field->offset_in_bytes());\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2644,0 +2644,1 @@\n+  assert(Arguments::has_jimage(), \"The shared archive file cannot be used with an exploded module build.\");\n@@ -2654,5 +2655,0 @@\n-  if (!Arguments::has_jimage()) {\n-    log_info(cds)(\"The shared archive file cannot be used with an exploded module build.\");\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -887,1 +887,1 @@\n-            set_modified(p, will_link ? field->offset() : OFFSET_ANY, type2size[field_type]*HeapWordSize);\n+            set_modified(p, will_link ? field->offset_in_bytes() : OFFSET_ANY, type2size[field_type]*HeapWordSize);\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1146,4 +1146,0 @@\n-    if (!failing()) {\n-      code_buffer->finalize_stubs();\n-    }\n-\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-  _flags = ciFlags(fd->access_flags());\n+  _flags = ciFlags(fd->access_flags(), fd->field_flags().is_stable(), fd->field_status().is_initialized_final_update());\n@@ -349,1 +349,1 @@\n-    _constant_value = mirror->field_value_impl(type()->basic_type(), offset());\n+    _constant_value = mirror->field_value_impl(type()->basic_type(), offset_in_bytes());\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,2 +114,2 @@\n-  \/\/ What is the offset of this field?\n-  int offset() const {\n+  \/\/ What is the offset of this field? (Fields are aligned to the byte level.)\n+  int offset_in_bytes() const {\n@@ -120,5 +120,0 @@\n-  \/\/ Same question, explicit units.  (Fields are aligned to the byte level.)\n-  int offset_in_bytes() const {\n-    return offset();\n-  }\n-\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+  bool _stable;\n+  bool _intialized_final_update;\n@@ -44,2 +46,3 @@\n-  ciFlags()                  { _flags = 0; }\n-  ciFlags(AccessFlags flags) { _flags = flags.as_int(); }\n+  ciFlags() :_flags(0), _stable(false), _intialized_final_update(false) { }\n+  ciFlags(AccessFlags flags, bool is_stable = false, bool is_initialized_final_update = false) :\n+    _flags(flags.as_int()), _stable(is_stable), _intialized_final_update(is_initialized_final_update) { }\n@@ -60,1 +63,0 @@\n-  bool is_stable               () const { return (_flags & JVM_ACC_FIELD_STABLE              ) != 0; }\n@@ -62,0 +64,1 @@\n+  bool is_stable               () const { return _stable; }\n@@ -66,1 +69,1 @@\n-  bool has_initialized_final_update() const { return (_flags & JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE) != 0; };\n+  bool has_initialized_final_update() const { return _intialized_final_update; };\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    int field_offset = _declared_nonstatic_fields->at(i)->offset();\n+    int field_offset = _declared_nonstatic_fields->at(i)->offset_in_bytes();\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  return field_value_impl(field->type()->basic_type(), field->offset());\n+  return field_value_impl(field->type()->basic_type(), field->offset_in_bytes());\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-        int offset = field_offset + (flattened_field->offset() - vk->first_field_offset());\n+        int offset = field_offset + (flattened_field->offset_in_bytes() - vk->first_field_offset());\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -765,6 +767,8 @@\n-  if (TraceDependencies && target() != nullptr && target() != root_m->get_Method()) {\n-    tty->print(\"found a non-root unique target method\");\n-    tty->print_cr(\"  context = %s\", actual_recv->get_Klass()->external_name());\n-    tty->print(\"  method  = \");\n-    target->print_short_name(tty);\n-    tty->cr();\n+  LogTarget(Debug, dependencies) lt;\n+  if (lt.is_enabled() && target() != nullptr && target() != root_m->get_Method()) {\n+    LogStream ls(&lt);\n+    ls.print(\"found a non-root unique target method\");\n+    ls.print_cr(\"  context = %s\", actual_recv->get_Klass()->external_name());\n+    ls.print(\"  method  = \");\n+    target->print_short_name(&ls);\n+    ls.cr();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -1520,1 +1522,0 @@\n-  assert(nullptr == _fields, \"invariant\");\n@@ -1538,24 +1539,3 @@\n-  \/\/ The field array starts with tuples of shorts\n-  \/\/ [access, name index, sig index, initial value index, byte offset].\n-  \/\/ A generic signature slot only exists for field with generic\n-  \/\/ signature attribute. And the access flag is set with\n-  \/\/ JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic\n-  \/\/ signature slots are at the end of the field array and after all\n-  \/\/ other fields data.\n-  \/\/\n-  \/\/   f1: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/   f2: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/       ...\n-  \/\/   fn: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/       [generic signature index]\n-  \/\/       [generic signature index]\n-  \/\/       ...\n-  \/\/\n-  \/\/ Allocate a temporary resource array for field data. For each field,\n-  \/\/ a slot is reserved in the temporary array for the generic signature\n-  \/\/ index. After parsing all fields, the data are copied to a permanent\n-  \/\/ array and any unused slots will be discarded.\n-  ResourceMark rm(THREAD);\n-  u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,\n-                                              u2,\n-                                              total_fields * (FieldInfo::field_slots + 1));\n+  \/\/ Allocate a temporary resource array to collect field data.\n+  \/\/ After parsing all fields, data are stored in a UNSIGNED5 compressed stream.\n+  _temp_field_info = new GrowableArray<FieldInfo>(total_fields);\n@@ -1563,3 +1543,0 @@\n-  \/\/ The generic signature slots start after all other fields' data.\n-  int generic_signature_slot = total_fields * FieldInfo::field_slots;\n-  int num_generic_signature = 0;\n@@ -1567,0 +1544,1 @@\n+  ResourceMark rm(THREAD);\n@@ -1576,0 +1554,1 @@\n+    FieldInfo::FieldFlags fieldFlags(0);\n@@ -1636,4 +1615,1 @@\n-        access_flags.set_field_has_generic_signature();\n-        fa[generic_signature_slot] = generic_signature_index;\n-        generic_signature_slot ++;\n-        num_generic_signature ++;\n+        fieldFlags.update_generic(true);\n@@ -1643,5 +1619,0 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, n);\n-    field->initialize(access_flags.as_short(),\n-                      name_index,\n-                      signature_index,\n-                      constantvalue_index);\n@@ -1653,6 +1624,4 @@\n-    \/\/ After field is initialized with type, we can augment it with aux info\n-    if (parsed_annotations.has_any_annotations()) {\n-      parsed_annotations.apply_to(field);\n-      if (field->is_contended()) {\n-        _has_contended_fields = true;\n-      }\n+    FieldInfo fi(access_flags, name_index, signature_index, constantvalue_index, fieldFlags);\n+    fi.set_index(n);\n+    if (fieldFlags.is_generic()) {\n+      fi.set_generic_signature_index(generic_signature_index);\n@@ -1660,0 +1629,5 @@\n+    parsed_annotations.apply_to(&fi);\n+    if (fi.field_flags().is_contended()) {\n+      _has_contended_fields = true;\n+    }\n+    _temp_field_info->append(fi);\n@@ -1661,0 +1635,1 @@\n+  assert(_temp_field_info->length() == length, \"Must be\");\n@@ -1671,1 +1646,1 @@\n-          const FieldInfo* const f = FieldInfo::from_field_array(fa, i);\n+          const FieldInfo* const f = _temp_field_info->adr_at(i);\n@@ -1686,7 +1661,6 @@\n-      FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-      field->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n-                        (u2)(injected[n].name_index),\n-                        (u2)(injected[n].signature_index),\n-                        0);\n-\n-      const BasicType type = Signature::basic_type(injected[n].signature());\n+      FieldInfo::FieldFlags fflags(0);\n+      fflags.update_injected(true);\n+      AccessFlags aflags;\n+      FieldInfo fi(aflags, (u2)(injected[n].name_index), (u2)(injected[n].signature_index), 0, fflags);\n+      fi.set_index(index);\n+      _temp_field_info->append(fi);\n@@ -1695,0 +1669,1 @@\n+      const BasicType type = Signature::basic_type(injected[n].signature());\n@@ -1701,5 +1676,12 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-    field->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n-                      (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(default_value_name)),\n-                      (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n-                      0);\n+    \/\/ Inject static \".default\" field\n+    FieldInfo::FieldFlags fflags(0);\n+    fflags.update_injected(true);\n+    AccessFlags aflags(JVM_ACC_STATIC);\n+    FieldInfo fi(aflags,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(default_value_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n+                 0,\n+                 fflags);\n+      fi.set_index(index);\n+      _temp_field_info->append(fi);\n+\n@@ -1712,0 +1694,1 @@\n+    \/\/ Inject \".empty\" dummy field\n@@ -1713,5 +1696,12 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-    field->initialize(JVM_ACC_FIELD_INTERNAL,\n-        (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(empty_marker_name)),\n-        (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)),\n-        0);\n+\n+    FieldInfo::FieldFlags fflags(0);\n+    fflags.update_injected(true);\n+    AccessFlags aflags;\n+    FieldInfo fi(aflags,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(empty_marker_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)),\n+                 0,\n+                 fflags);\n+    fi.set_index(index);\n+    _temp_field_info->append(fi);\n+\n@@ -1727,21 +1717,1 @@\n-  assert(nullptr == _fields, \"invariant\");\n-\n-  _fields =\n-    MetadataFactory::new_array<u2>(_loader_data,\n-                                   index * FieldInfo::field_slots + num_generic_signature,\n-                                   CHECK);\n-  \/\/ Sometimes injected fields already exist in the Java source so\n-  \/\/ the fields array could be too long.  In that case the\n-  \/\/ fields array is trimmed. Also unused slots that were reserved\n-  \/\/ for generic signature indexes are discarded.\n-  {\n-    int i = 0;\n-    for (; i < index * FieldInfo::field_slots; i++) {\n-      _fields->at_put(i, fa[i]);\n-    }\n-    for (int j = total_fields * FieldInfo::field_slots;\n-         j < generic_signature_slot; j++) {\n-      _fields->at_put(i++, fa[j]);\n-    }\n-    assert(_fields->length() == i, \"\");\n-  }\n+  assert(_temp_field_info->length() == index, \"Must be\");\n@@ -1760,3 +1730,3 @@\n-      for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n-        name = fs.name();\n-        sig = fs.signature();\n+      for (int i = 0; i < _temp_field_info->length(); i++) {\n+        name = _temp_field_info->adr_at(i)->name(_cp);\n+        sig = _temp_field_info->adr_at(i)->signature(_cp);\n@@ -2145,0 +2115,1 @@\n+    \/\/ Setting the contended group also sets the contended bit in field flags\n@@ -2147,1 +2118,1 @@\n-    f->set_stable(true);\n+    (f->field_flags_addr())->update_stable(true);\n@@ -4195,1 +4166,2 @@\n-  this_klass->set_fields(_fields, java_fields_count);\n+  this_klass->set_fieldinfo_stream(_fieldinfo_stream);\n+  this_klass->set_fields_status(_fields_status);\n@@ -5685,0 +5657,3 @@\n+  if (ik->is_inline_klass()) {\n+    InlineKlass::cast(ik)->init_fixed_block();\n+  }\n@@ -5693,1 +5668,2 @@\n-  assert(nullptr == _fields, \"invariant\");\n+  assert(nullptr == _fieldinfo_stream, \"invariant\");\n+  assert(nullptr == _fields_status, \"invariant\");\n@@ -5846,1 +5822,1 @@\n-  for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -5956,1 +5932,2 @@\n-  _fields(nullptr),\n+  _fieldinfo_stream(nullptr),\n+  _fields_status(nullptr),\n@@ -5978,0 +5955,1 @@\n+  _temp_field_info(nullptr),\n@@ -6056,1 +6034,2 @@\n-  _fields = nullptr;\n+  _fieldinfo_stream = nullptr;\n+  _fields_status = nullptr;\n@@ -6075,2 +6054,7 @@\n-  if (_fields != nullptr) {\n-    MetadataFactory::free_array<u2>(_loader_data, _fields);\n+\n+  if (_fieldinfo_stream != nullptr) {\n+    MetadataFactory::free_array<u1>(_loader_data, _fieldinfo_stream);\n+  }\n+\n+  if (_fields_status != nullptr) {\n+    MetadataFactory::free_array<FieldStatus>(_loader_data, _fields_status);\n@@ -6344,1 +6328,1 @@\n-  assert(_fields != nullptr, \"invariant\");\n+  assert(_temp_field_info != nullptr, \"invariant\");\n@@ -6572,2 +6556,5 @@\n-    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n-      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT && !fs.access_flags().is_static()) {\n+    for (GrowableArrayIterator<FieldInfo> it = _temp_field_info->begin(); it != _temp_field_info->end(); ++it) {\n+      FieldInfo fieldinfo = *it;\n+      Symbol* sig = fieldinfo.signature(cp);\n+\n+      if (Signature::basic_type(sig) == T_PRIMITIVE_OBJECT && !fieldinfo.access_flags().is_static()) {\n@@ -6575,1 +6562,1 @@\n-        Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n+        Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(sig,\n@@ -6587,1 +6574,1 @@\n-        _inline_type_field_klasses->at_put(fs.index(), InlineKlass::cast(klass));\n+        _inline_type_field_klasses->at_put(fieldinfo.index(), InlineKlass::cast(klass));\n@@ -6593,1 +6580,1 @@\n-  FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,\n+  FieldLayoutBuilder lb(class_name(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n@@ -6603,0 +6590,8 @@\n+\n+  int injected_fields_count = _temp_field_info->length() - _java_fields_count;\n+  _fieldinfo_stream =\n+    FieldInfoStream::create_FieldInfoStream(_temp_field_info, _java_fields_count,\n+                                            injected_fields_count, loader_data(), CHECK);\n+  _fields_status =\n+    MetadataFactory::new_array<FieldStatus>(_loader_data, _temp_field_info->length(),\n+                                            FieldStatus(0), CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":94,"deletions":99,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -126,1 +127,2 @@\n-  Array<u2>* _fields;\n+  Array<u1>* _fieldinfo_stream;\n+  Array<FieldStatus>* _fields_status;\n@@ -149,0 +151,1 @@\n+  GrowableArray<FieldInfo>* _temp_field_info;\n@@ -476,2 +479,2 @@\n-                                 const Symbol* name = NULL,\n-                                 const Symbol* sig  = NULL) const;\n+                                 const Symbol* name = nullptr,\n+                                 const Symbol* sig  = nullptr) const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-void FieldGroup::add_primitive_field(AllFieldStream fs, BasicType type) {\n+void FieldGroup::add_primitive_field(int idx, BasicType type) {\n@@ -90,1 +90,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n@@ -98,1 +98,1 @@\n-void FieldGroup::add_oop_field(AllFieldStream fs) {\n+void FieldGroup::add_oop_field(int idx) {\n@@ -100,1 +100,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n@@ -108,2 +108,2 @@\n-void FieldGroup::add_inlined_field(AllFieldStream fs, InlineKlass* vk) {\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n+void FieldGroup::add_inlined_field(int idx, InlineKlass* vk) {\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n@@ -141,2 +141,2 @@\n-FieldLayout::FieldLayout(Array<u2>* fields, ConstantPool* cp) :\n-  _fields(fields),\n+FieldLayout::FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp) :\n+  _field_info(field_info),\n@@ -268,1 +268,1 @@\n-      FieldInfo::from_field_array(_fields, block->field_index())->set_offset(block->offset());\n+      _field_info->adr_at(block->field_index())->set_offset(block->offset());\n@@ -327,1 +327,1 @@\n-  FieldInfo::from_field_array(_fields, block->field_index())->set_offset(block->offset());\n+  _field_info->adr_at(block->field_index())->set_offset(block->offset());\n@@ -335,1 +335,1 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n@@ -469,47 +469,47 @@\n-    case LayoutRawBlock::REGULAR: {\n-      FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n-      output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n-                       b->offset(),\n-                       fi->name(_cp)->as_C_string(),\n-                       fi->signature(_cp)->as_C_string(),\n-                       b->size(),\n-                       b->alignment(),\n-                       \"REGULAR\");\n-      break;\n-    }\n-    case LayoutRawBlock::INLINED: {\n-      FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n-      output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n-                       b->offset(),\n-                       fi->name(_cp)->as_C_string(),\n-                       fi->signature(_cp)->as_C_string(),\n-                       b->size(),\n-                       b->alignment(),\n-                       \"INLINED\");\n-      break;\n-    }\n-    case LayoutRawBlock::RESERVED: {\n-      output->print_cr(\" @%d %d\/- %s\",\n-                       b->offset(),\n-                       b->size(),\n-                       \"RESERVED\");\n-      break;\n-    }\n-    case LayoutRawBlock::INHERITED: {\n-      assert(!is_static, \"Static fields are not inherited in layouts\");\n-      assert(super != nullptr, \"super klass must be provided to retrieve inherited fields info\");\n-      bool found = false;\n-      const InstanceKlass* ik = super;\n-      while (!found && ik != nullptr) {\n-        for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n-          if (fs.offset() == b->offset()) {\n-            output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n-                b->offset(),\n-                fs.name()->as_C_string(),\n-                fs.signature()->as_C_string(),\n-                b->size(),\n-                b->size(), \/\/ so far, alignment constraint == size, will change with Valhalla\n-                \"INHERITED\");\n-            found = true;\n-            break;\n-          }\n+      case LayoutRawBlock::REGULAR: {\n+        FieldInfo* fi = _field_info->adr_at(b->field_index());\n+        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                         b->offset(),\n+                         fi->name(_cp)->as_C_string(),\n+                         fi->signature(_cp)->as_C_string(),\n+                         b->size(),\n+                         b->alignment(),\n+                         \"REGULAR\");\n+        break;\n+      }\n+      case LayoutRawBlock::INLINED: {\n+        FieldInfo* fi = _field_info->adr_at(b->field_index());\n+        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                         b->offset(),\n+                         fi->name(_cp)->as_C_string(),\n+                         fi->signature(_cp)->as_C_string(),\n+                         b->size(),\n+                         b->alignment(),\n+                         \"INLINED\");\n+        break;\n+      }\n+      case LayoutRawBlock::RESERVED: {\n+        output->print_cr(\" @%d %d\/- %s\",\n+                         b->offset(),\n+                         b->size(),\n+                         \"RESERVED\");\n+        break;\n+      }\n+      case LayoutRawBlock::INHERITED: {\n+        assert(!is_static, \"Static fields are not inherited in layouts\");\n+        assert(super != nullptr, \"super klass must be provided to retrieve inherited fields info\");\n+        bool found = false;\n+        const InstanceKlass* ik = super;\n+        while (!found && ik != nullptr) {\n+          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+            if (fs.offset() == b->offset()) {\n+              output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                  b->offset(),\n+                  fs.name()->as_C_string(),\n+                  fs.signature()->as_C_string(),\n+                  b->size(),\n+                  b->size(), \/\/ so far, alignment constraint == size, will change with Valhalla\n+                  \"INHERITED\");\n+              found = true;\n+              break;\n+            }\n@@ -539,1 +539,1 @@\n-                                       Array<u2>* fields, bool is_contended, bool is_inline_type,\n+                                       GrowableArray<FieldInfo>* field_info, bool is_contended, bool is_inline_type,\n@@ -544,1 +544,1 @@\n-  _fields(fields),\n+  _field_info(field_info),\n@@ -578,1 +578,1 @@\n-  _layout = new FieldLayout(_fields, _constant_pool);\n+  _layout = new FieldLayout(_field_info, _constant_pool);\n@@ -584,1 +584,1 @@\n-  _static_layout = new FieldLayout(_fields, _constant_pool);\n+  _static_layout = new FieldLayout(_field_info, _constant_pool);\n@@ -597,1 +597,3 @@\n-  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n+  int idx = 0;\n+  for (GrowableArrayIterator<FieldInfo> it = _field_info->begin(); it != _field_info->end(); ++it, ++idx) {\n+    FieldInfo ctrl = _field_info->at(0);\n@@ -599,1 +601,2 @@\n-    if (fs.access_flags().is_static()) {\n+    FieldInfo fieldinfo = *it;\n+    if (fieldinfo.access_flags().is_static()) {\n@@ -604,2 +607,2 @@\n-      if (fs.is_contended()) {\n-        int g = fs.contended_group();\n+      if (fieldinfo.field_flags().is_contended()) {\n+        int g = fieldinfo.contended_group();\n@@ -617,1 +620,1 @@\n-    BasicType type = Signature::basic_type(fs.signature());\n+    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n@@ -627,1 +630,1 @@\n-      group->add_primitive_field(fs, type);\n+      group->add_primitive_field(idx, type);\n@@ -632,1 +635,1 @@\n-      group->add_oop_field(fs);\n+      group->add_oop_field(idx);\n@@ -638,1 +641,1 @@\n-        group->add_oop_field(fs);\n+        group->add_oop_field(idx);\n@@ -645,1 +648,1 @@\n-        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+        Klass* klass =  _inline_type_field_klasses->at(idx);\n@@ -651,1 +654,1 @@\n-        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+        bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n@@ -657,2 +660,2 @@\n-        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n-          group->add_inlined_field(fs, vk);\n+        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n+          group->add_inlined_field(idx, vk);\n@@ -660,1 +663,1 @@\n-          fs.set_inlined(true);\n+          _field_info->adr_at(idx)->field_flags_addr()->update_inlined(true);\n@@ -667,1 +670,1 @@\n-          group->add_oop_field(fs);\n+          group->add_oop_field(idx);\n@@ -698,1 +701,1 @@\n-  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n+  for (GrowableArrayIterator<FieldInfo> it = _field_info->begin(); it != _field_info->end(); ++it) {\n@@ -700,0 +703,1 @@\n+    FieldInfo fieldinfo = *it;\n@@ -701,1 +705,1 @@\n-    if (fs.access_flags().is_static()) {\n+    if (fieldinfo.access_flags().is_static()) {\n@@ -709,1 +713,1 @@\n-    BasicType type = Signature::basic_type(fs.signature());\n+    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n@@ -722,1 +726,1 @@\n-      group->add_primitive_field(fs, type);\n+      group->add_primitive_field(fieldinfo.index(), type);\n@@ -730,1 +734,1 @@\n-      group->add_oop_field(fs);\n+      group->add_oop_field(fieldinfo.index());\n@@ -737,1 +741,1 @@\n-        group->add_oop_field(fs);\n+        group->add_oop_field(fieldinfo.index());\n@@ -743,1 +747,1 @@\n-        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+        Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n@@ -749,1 +753,1 @@\n-        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+        bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n@@ -755,2 +759,2 @@\n-        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n-          group->add_inlined_field(fs, vk);\n+        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n+          group->add_inlined_field(fieldinfo.index(), vk);\n@@ -759,1 +763,1 @@\n-          fs.set_inlined(true);\n+          _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_inlined(true);\n@@ -767,1 +771,1 @@\n-          group->add_oop_field(fs);\n+          group->add_oop_field(fieldinfo.index());\n@@ -775,1 +779,1 @@\n-    if (!fs.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n+    if (!fieldinfo.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":93,"deletions":89,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -151,3 +151,3 @@\n-  void add_primitive_field(AllFieldStream fs, BasicType type);\n-  void add_oop_field(AllFieldStream fs);\n-  void add_inlined_field(AllFieldStream fs, InlineKlass* vk);\n+  void add_primitive_field(int idx, BasicType type);\n+  void add_oop_field(int idx);\n+  void add_inlined_field(int idx, InlineKlass* vk);\n@@ -179,1 +179,1 @@\n-  Array<u2>* _fields;\n+  GrowableArray<FieldInfo>* _field_info;\n@@ -186,1 +186,1 @@\n-  FieldLayout(Array<u2>* fields, ConstantPool* cp);\n+  FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp);\n@@ -245,1 +245,1 @@\n-  Array<u2>* _fields;\n+  GrowableArray<FieldInfo>* _field_info;\n@@ -269,1 +269,2 @@\n-      Array<u2>* fields, bool is_contended, bool is_inline_type, FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses);\n+                     GrowableArray<FieldInfo>* field_info, bool is_contended, bool is_inline_type, FieldLayoutInfo* info,\n+                     Array<InlineKlass*>* inline_type_field_klasses);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -868,4 +869,16 @@\n-      for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {\n-        if (fs.access_flags().is_static()) {\n-          int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();\n-          fs.set_offset(real_offset);\n+\n+      \/\/ Unfortunately, the FieldInfo stream is encoded with UNSIGNED5 which doesn't allow\n+      \/\/ content updates. So the FieldInfo stream has to be decompressed into a temporary array,\n+      \/\/ static fields offsets are updated in this array before reencoding everything into\n+      \/\/ a new UNSIGNED5 stream, and substitute it to the old FieldInfo stream.\n+\n+      int java_fields;\n+      int injected_fields;\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      GrowableArray<FieldInfo>* fields =\n+        FieldInfoStream::create_FieldInfoArray(ik->fieldinfo_stream(),\n+                                               &java_fields, &injected_fields);\n+      for (int i = 0; i < fields->length(); i++) {\n+        FieldInfo* fi = fields->adr_at(i);\n+        if (fi->access_flags().is_static()) {\n+          fi->set_offset(fi->offset() + InstanceMirrorKlass::offset_of_static_fields());\n@@ -874,0 +887,5 @@\n+      Array<u1>* old_stream = ik->fieldinfo_stream();\n+      assert(fields->length() == (java_fields + injected_fields), \"Must be\");\n+      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n+      ik->set_fieldinfo_stream(new_fis);\n+      MetadataFactory::free_array<u1>(k->class_loader_data(), old_stream);\n@@ -1992,1 +2010,0 @@\n-int java_lang_VirtualThread::static_notify_jvmti_events_offset;\n@@ -1999,1 +2016,0 @@\n-  macro(static_notify_jvmti_events_offset, k, \"notifyJvmtiEvents\",  bool_signature,              true);  \\\n@@ -2005,1 +2021,0 @@\n-static bool vthread_notify_jvmti_events = JNI_FALSE;\n@@ -2012,8 +2027,0 @@\n-void java_lang_VirtualThread::init_static_notify_jvmti_events() {\n-  if (vthread_notify_jvmti_events) {\n-    InstanceKlass* ik = vmClasses::VirtualThread_klass();\n-    oop base = ik->static_field_base_raw();\n-    base->release_bool_field_put(static_notify_jvmti_events_offset, vthread_notify_jvmti_events);\n-  }\n-}\n-\n@@ -2072,9 +2079,0 @@\n-bool java_lang_VirtualThread::notify_jvmti_events() {\n-  return vthread_notify_jvmti_events == JNI_TRUE;\n-}\n-\n-void java_lang_VirtualThread::set_notify_jvmti_events(bool enable) {\n-  vthread_notify_jvmti_events = enable;\n-}\n-\n-\n@@ -5422,1 +5420,1 @@\n-    if (!may_be_java && !fs.access_flags().is_internal()) {\n+    if (!may_be_java && !fs.field_flags().is_injected()) {\n@@ -5446,1 +5444,0 @@\n-  java_lang_VirtualThread::init_static_notify_jvmti_events();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -526,1 +526,0 @@\n-  static int static_notify_jvmti_events_offset;\n@@ -564,3 +563,0 @@\n-  static bool notify_jvmti_events();\n-  static void set_notify_jvmti_events(bool enable);\n-  static void init_static_notify_jvmti_events();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,3 +143,0 @@\n-  assert(action != PlaceholderTable::LOAD_INSTANCE || !EnableWaitForParallelLoad || seen == nullptr,\n-         \"Only one LOAD_INSTANCE allowed at a time\");\n-\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -502,1 +502,1 @@\n-Klass* SystemDictionary::resolve_inline_type_field_or_fail(AllFieldStream* fs,\n+Klass* SystemDictionary::resolve_inline_type_field_or_fail(Symbol* signature,\n@@ -507,1 +507,1 @@\n-  Symbol* class_name = fs->signature()->fundamental_name(THREAD);\n+  Symbol* class_name = signature->fundamental_name(THREAD);\n@@ -545,44 +545,0 @@\n-\/\/ We only get here if this thread finds that another thread\n-\/\/ has already claimed the placeholder token for the current operation,\n-\/\/ but that other thread either never owned or gave up the\n-\/\/ object lock\n-\/\/ Waits on SystemDictionary_lock to indicate placeholder table updated\n-\/\/ On return, caller must recheck placeholder table state\n-\/\/\n-\/\/ We only get here if\n-\/\/  1) custom classLoader, i.e. not bootstrap classloader\n-\/\/  2) custom classLoader has broken the class loader objectLock\n-\/\/     so another thread got here in parallel\n-\/\/\n-\/\/ lockObject must be held.\n-\/\/ Complicated dance due to lock ordering:\n-\/\/ Must first release the classloader object lock to\n-\/\/ allow initial definer to complete the class definition\n-\/\/ and to avoid deadlock\n-\/\/ Reclaim classloader lock object with same original recursion count\n-\/\/ Must release SystemDictionary_lock after notify, since\n-\/\/ class loader lock must be claimed before SystemDictionary_lock\n-\/\/ to prevent deadlocks\n-\/\/\n-\/\/ The notify allows applications that did an untimed wait() on\n-\/\/ the classloader object lock to not hang.\n-static void double_lock_wait(JavaThread* thread, Handle lockObject) {\n-  assert_lock_strong(SystemDictionary_lock);\n-\n-  assert(EnableWaitForParallelLoad,\n-         \"Only called when enabling legacy parallel class loading logic \"\n-         \"for non-parallel capable class loaders\");\n-  assert(lockObject() != nullptr, \"lockObject must be non-null\");\n-  bool calledholdinglock\n-      = ObjectSynchronizer::current_thread_holds_lock(thread, lockObject);\n-  assert(calledholdinglock, \"must hold lock for notify\");\n-  assert(!is_parallelCapable(lockObject), \"lockObject must not be parallelCapable\");\n-  \/\/ These don't throw exceptions.\n-  ObjectSynchronizer::notifyall(lockObject, thread);\n-  intx recursions = ObjectSynchronizer::complete_exit(lockObject, thread);\n-  SystemDictionary_lock->wait();\n-  SystemDictionary_lock->unlock();\n-  ObjectSynchronizer::reenter(lockObject, recursions, thread);\n-  SystemDictionary_lock->lock();\n-}\n-\n@@ -610,3 +566,1 @@\n-\/\/ wait for parallel class loading and to check for circularity error for Xcomp when loading\n-\/\/ signature classes.\n-\/\/ parallelCapable class loaders do NOT wait for parallel loads to complete\n+\/\/ wait for parallel class loading and\/or to check for circularity error for Xcomp when loading.\n@@ -617,7 +571,6 @@\n-\/\/ For bootstrap and non-parallelCapable class loaders, check and wait for\n-\/\/ another thread to complete loading this class.\n-InstanceKlass* SystemDictionary::handle_parallel_loading(JavaThread* current,\n-                                                         Symbol* name,\n-                                                         ClassLoaderData* loader_data,\n-                                                         Handle lockObject,\n-                                                         bool* throw_circularity_error) {\n+\/\/ Check for other threads loading this class either to throw CCE or wait in the case of the boot loader.\n+static InstanceKlass* handle_parallel_loading(JavaThread* current,\n+                                              Symbol* name,\n+                                              ClassLoaderData* loader_data,\n+                                              bool must_wait_for_class_loading,\n+                                              bool* throw_circularity_error) {\n@@ -633,1 +586,1 @@\n-    } else {\n+    } else if (must_wait_for_class_loading) {\n@@ -639,20 +592,3 @@\n-        \/\/ We only get here if the application has released the\n-        \/\/ classloader lock when another thread was in the middle of loading a\n-        \/\/ superclass\/superinterface for this class, and now\n-        \/\/ this thread is also trying to load this class.\n-        \/\/ To minimize surprises, the first thread that started to\n-        \/\/ load a class should be the one to complete the loading\n-        \/\/ with the classfile it initially expected.\n-        \/\/ This logic has the current thread wait once it has done\n-        \/\/ all the superclass\/superinterface loading it can, until\n-        \/\/ the original thread completes the class loading or fails\n-        \/\/ If it completes we will use the resulting InstanceKlass\n-        \/\/ which we will find below in the systemDictionary.\n-\n-        if (lockObject.is_null()) {\n-          SystemDictionary_lock->wait();\n-        } else if (EnableWaitForParallelLoad) {\n-          double_lock_wait(current, lockObject);\n-        } else {\n-          return nullptr;\n-        }\n+        \/\/ LOAD_INSTANCE placeholders are used to implement parallel capable class loading\n+        \/\/ for the bootclass loader.\n+        SystemDictionary_lock->wait();\n@@ -765,1 +701,0 @@\n-    \/\/ Four cases:\n@@ -774,7 +709,3 @@\n-    \/\/    There should be no need for need for LOAD_INSTANCE, except:\n-    \/\/ case 4. traditional class loaders that break the classloader object lock\n-    \/\/    as a legacy deadlock workaround. Detection of this case requires that\n-    \/\/    this check is done while holding the classloader object lock,\n-    \/\/    and that lock is still held when calling classloader's loadClass.\n-    \/\/    For these classloaders, we ensure that the first requestor\n-    \/\/    completes the load and other requestors wait for completion.\n+    \/\/    There should be no need for need for LOAD_INSTANCE for mutual exclusion,\n+    \/\/    except the LOAD_INSTANCE placeholder is used to detect CCE for -Xcomp.\n+    \/\/    TODO: should also be used to detect CCE for parallel capable class loaders but it's not.\n@@ -787,1 +718,1 @@\n-                                               lockObject,\n+                                               class_loader.is_null(),\n@@ -798,2 +729,1 @@\n-          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread,\n-          \/\/ and check for ClassCircularityError with -Xcomp.\n+          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n@@ -1270,2 +1200,3 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n-      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n+      Symbol* sig = fs.signature();\n+      if (Signature::basic_type(sig) == T_PRIMITIVE_OBJECT) {\n@@ -1274,1 +1205,1 @@\n-          Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n+          Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(sig,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":22,"deletions":91,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  static Klass* resolve_inline_type_field_or_fail(AllFieldStream* fs,\n+  static Klass* resolve_inline_type_field_or_fail(Symbol* signature,\n@@ -312,6 +312,0 @@\n-  static InstanceKlass* handle_parallel_loading(JavaThread* current,\n-                                                Symbol* name,\n-                                                ClassLoaderData* loader_data,\n-                                                Handle lockObject,\n-                                                bool* throw_circularity_error);\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -592,0 +592,5 @@\n+  \/* java\/lang\/VirtualThread *\/                                                                                         \\\n+  do_intrinsic(_notifyJvmtiMount, java_lang_VirtualThread, notifyJvmtiMount_name, bool_bool_void_signature, F_RN)       \\\n+  do_intrinsic(_notifyJvmtiUnmount, java_lang_VirtualThread, notifyJvmtiUnmount_name, bool_bool_void_signature, F_RN)   \\\n+  do_intrinsic(_notifyJvmtiHideFrames, java_lang_VirtualThread, notifyJvmtiHideFrames_name, bool_void_signature, F_RN)  \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -417,0 +417,3 @@\n+  template(notifyJvmtiMount_name,                     \"notifyJvmtiMount\")                         \\\n+  template(notifyJvmtiUnmount_name,                   \"notifyJvmtiUnmount\")                       \\\n+  template(notifyJvmtiHideFrames_name,                \"notifyJvmtiHideFrames\")                    \\\n@@ -557,0 +560,1 @@\n+  template(bool_bool_void_signature,                  \"(ZZ)V\")                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+bool Dependencies::_verify_in_progress = false;  \/\/ don't -Xlog:dependencies\n+\n@@ -641,1 +643,1 @@\n-          deps.print_dependency(witness, true, &st);\n+          deps.print_dependency(&st, witness, true);\n@@ -869,1 +871,1 @@\n-void Dependencies::DepStream::print_dependency(Klass* witness, bool verbose, outputStream* st) {\n+void Dependencies::DepStream::print_dependency(outputStream* st, Klass* witness, bool verbose) {\n@@ -1767,1 +1769,1 @@\n-      FlagSetting fs(TraceDependencies, false);\n+      FlagSetting fs(_verify_in_progress, true);\n@@ -2062,0 +2064,1 @@\n+  if (_verify_in_progress) return;  \/\/ don't log\n@@ -2063,2 +2066,4 @@\n-    if (TraceDependencies) {\n-      print_dependency(witness, \/*verbose=*\/ true);\n+    LogTarget(Debug, dependencies) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(&lt);\n+      print_dependency(&ls, witness, \/*verbose=*\/ true);\n@@ -2174,1 +2179,3 @@\n-void DepChange::print() {\n+void DepChange::print() { print_on(tty); }\n+\n+void DepChange::print_on(outputStream* st) {\n@@ -2180,1 +2187,1 @@\n-      tty->print_cr(\"  dependee = %s\", k->external_name());\n+      st->print_cr(\"  dependee = %s\", k->external_name());\n@@ -2186,1 +2193,1 @@\n-        tty->print_cr(\"  context super = %s\", k->external_name());\n+        st->print_cr(\"  context super = %s\", k->external_name());\n@@ -2193,1 +2200,1 @@\n-        tty->print_cr(\"  context interface = %s\", k->external_name());\n+        st->print_cr(\"  context interface = %s\", k->external_name());\n@@ -2201,1 +2208,1 @@\n-    tty->print_cr(\"  context supers = %d, interfaces = %d\", nsup, nint);\n+    st->print_cr(\"  context supers = %d, interfaces = %d\", nsup, nint);\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1056,1 +1056,1 @@\n-      print_dependencies();\n+      print_dependencies_on(tty);\n@@ -2162,1 +2162,1 @@\n-  NOT_PRODUCT( FlagSetting fs(TraceDependencies, false) );\n+  NOT_PRODUCT( FlagSetting fs(Dependencies::_verify_in_progress, true));\n@@ -2192,1 +2192,1 @@\n-            nm->print_dependencies();\n+            nm->print_dependencies_on(tty);\n@@ -2493,1 +2493,1 @@\n-void nmethod::print_dependencies() {\n+void nmethod::print_dependencies_on(outputStream* out) {\n@@ -2495,2 +2495,2 @@\n-  ttyLocker ttyl;   \/\/ keep the following output all in one block\n-  tty->print_cr(\"Dependencies:\");\n+  stringStream st;\n+  st.print_cr(\"Dependencies:\");\n@@ -2498,1 +2498,1 @@\n-    deps.print_dependency();\n+    deps.print_dependency(&st);\n@@ -2502,1 +2502,1 @@\n-        tty->print_cr(\"   [nmethod<=klass]%s\", ctxk->external_name());\n+        st.print_cr(\"   [nmethod<=klass]%s\", ctxk->external_name());\n@@ -2507,0 +2507,1 @@\n+  out->print_raw(st.as_string());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-  void print_dependencies()                       PRODUCT_RETURN;\n+  void print_dependencies_on(outputStream* out) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1153,1 +1153,1 @@\n-JVM_VirtualThreadMountBegin(JNIEnv* env, jobject vthread, jboolean first_mount);\n+JVM_VirtualThreadMount(JNIEnv* env, jobject vthread, jboolean hide, jboolean first_mount);\n@@ -1156,7 +1156,1 @@\n-JVM_VirtualThreadMountEnd(JNIEnv* env, jobject vthread, jboolean first_mount);\n-\n-JNIEXPORT void JNICALL\n-JVM_VirtualThreadUnmountBegin(JNIEnv* env, jobject vthread, jboolean last_unmount);\n-\n-JNIEXPORT void JNICALL\n-JVM_VirtualThreadUnmountEnd(JNIEnv* env, jobject vthread, jboolean last_unmount);\n+JVM_VirtualThreadUnmount(JNIEnv* env, jobject vthread, jboolean hide, jboolean last_unmount);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1422,1 +1422,1 @@\n-  if ((ik->field_access_flags(index) & JVM_ACC_FIELD_ACCESS_WATCHED) == 0) return;\n+  if (!ik->field_status(index).is_access_watched()) return;\n@@ -1448,1 +1448,1 @@\n-  if ((ik->field_access_flags(index) & JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;\n+  if (!ik->field_status(index).is_modification_watched()) return;\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -813,2 +813,2 @@\n-  if (info.is_null() || JVMCIENV->get_length(info) != 3) {\n-    JVMCI_ERROR_NULL(\"info must not be null and have a length of 3\");\n+  if (info.is_null() || JVMCIENV->get_length(info) != 4) {\n+    JVMCI_ERROR_NULL(\"info must not be null and have a length of 4\");\n@@ -819,0 +819,1 @@\n+  JVMCIENV->put_int_at(info, 3, fd.field_flags().as_uint());\n@@ -1966,0 +1967,19 @@\n+C2V_VMENTRY_NULL(jobjectArray, getDeclaredFieldsInfo, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n+    JVMCI_THROW_0(NullPointerException);\n+  }\n+  if (!klass->is_instance_klass()) {\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"not an InstanceKlass\");\n+  }\n+  InstanceKlass* iklass = InstanceKlass::cast(klass);\n+  int java_fields, injected_fields;\n+  GrowableArray<FieldInfo>* fields = FieldInfoStream::create_FieldInfoArray(iklass->fieldinfo_stream(), &java_fields, &injected_fields);\n+  JVMCIObjectArray array = JVMCIENV->new_FieldInfo_array(fields->length(), JVMCIENV);\n+  for (int i = 0; i < fields->length(); i++) {\n+    JVMCIObject field_info = JVMCIENV->new_FieldInfo(fields->adr_at(i), JVMCI_CHECK_NULL);\n+    JVMCIENV->put_object_at(array, i, field_info);\n+  }\n+  return array.as_jobject();\n+C2V_END\n+\n@@ -2652,2 +2672,1 @@\n-  Array<u2>* fields = iklass->fields();\n-  if (index < 0 ||index > fields->length()) {\n+  if (index < 0 || index > iklass->total_fields_count()) {\n@@ -2817,0 +2836,1 @@\n+#define FIELDINFO               \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl$FieldInfo;\"\n@@ -2915,0 +2935,1 @@\n+  {CC \"getDeclaredFieldsInfo\",                        CC \"(\" HS_KLASS2 \")[\" FIELDINFO,                                                      FN_PTR(getDeclaredFieldsInfo)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  nonstatic_field(InstanceKlass,               _fields,                                       Array<u2>*)                            \\\n+  nonstatic_field(InstanceKlass,               _fieldinfo_stream,                             Array<u1>*)                            \\\n@@ -406,1 +406,0 @@\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_SIZE\", FIELDINFO_TAG_SIZE) \\\n@@ -424,3 +423,2 @@\n-  declare_constant(JVM_ACC_FIELD_INTERNAL)                                \\\n-  declare_constant(JVM_ACC_FIELD_STABLE)                                  \\\n-  declare_constant(JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE)                   \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_injected)                   \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_stable)                     \\\n@@ -434,1 +432,0 @@\n-  declare_preprocessor_constant(\"JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE\", JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE) \\\n@@ -650,7 +647,0 @@\n-  declare_constant(FieldInfo::access_flags_offset)                        \\\n-  declare_constant(FieldInfo::name_index_offset)                          \\\n-  declare_constant(FieldInfo::signature_index_offset)                     \\\n-  declare_constant(FieldInfo::initval_index_offset)                       \\\n-  declare_constant(FieldInfo::low_packed_offset)                          \\\n-  declare_constant(FieldInfo::high_packed_offset)                         \\\n-  declare_constant(FieldInfo::field_slots)                                \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,1 @@\n+  LOG_TAG(dependencies) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"oops\/constantPool.hpp\"\n-#include \"oops\/symbol.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/unsigned5.hpp\"\n@@ -33,0 +33,16 @@\n+static constexpr u4 flag_mask(int pos) {\n+  return (u4)1 << pos;\n+}\n+\n+\n+\/\/ Helper class for access to the underlying Array<u1> used to\n+\/\/ store the compressed stream of FieldInfo\n+template<typename ARR, typename OFF>\n+struct ArrayHelper {\n+  uint8_t operator()(ARR a, OFF i) const { return a->at(i); };\n+  void operator()(ARR a, OFF i, uint8_t b) const { a->at_put(i,b); };\n+  \/\/ So, an expression ArrayWriterHelper() acts like these lambdas:\n+  \/\/ auto get = [&](ARR a, OFF i){ return a[i]; };\n+  \/\/ auto set = [&](ARR a, OFF i, uint8_t x){ a[i] = x; };\n+};\n+\n@@ -43,0 +59,4 @@\n+  friend class FieldInfoStream;\n+  friend class FieldStreamBase;\n+  friend class FieldInfoReader;\n+  friend class VMStructs;\n@@ -45,33 +65,22 @@\n-  \/\/ fields\n-  \/\/ Field info extracted from the class file and stored\n-  \/\/ as an array of 6 shorts.\n-\n-#define FIELDINFO_TAG_SIZE             3\n-#define FIELDINFO_TAG_OFFSET           (1 << 0)\n-#define FIELDINFO_TAG_CONTENDED        (1 << 1)\n-#define FIELDINFO_TAG_INLINED          (1 << 2)\n-\n-  \/\/ Packed field has the tag, and can be either of:\n-  \/\/    hi bits <--------------------------- lo bits\n-  \/\/   |---------high---------|---------low---------|\n-  \/\/    ..........................................CO\n-  \/\/    ..........................................00  - non-contended field\n-  \/\/    [--contention_group--]...................I10  - contended field with contention group\n-  \/\/    [------------------offset---------------]I01  - real field offset\n-\n-  \/\/ Bit O indicates if the packed field contains an offset (O=1) or not (O=0)\n-  \/\/ Bit C indicates if the field is contended (C=1) or not (C=0)\n-  \/\/       (if it is contended, the high packed field contains the contention group)\n-  \/\/ Bit I indicates if the field has been inlined  (I=1) or not (I=0)\n-\n-  enum FieldOffset {\n-    access_flags_offset      = 0,\n-    name_index_offset        = 1,\n-    signature_index_offset   = 2,\n-    initval_index_offset     = 3,\n-    low_packed_offset        = 4,\n-    high_packed_offset       = 5,\n-    field_slots              = 6\n-  };\n- private:\n-  u2 _shorts[field_slots];\n+  class FieldFlags {\n+    friend class VMStructs;\n+    friend class JVMCIVMStructs;\n+\n+    \/\/ The ordering of this enum is totally internal.  More frequent\n+    \/\/ flags should come earlier than less frequent ones, because\n+    \/\/ earlier ones compress better.\n+    enum FieldFlagBitPosition {\n+      _ff_inlined,      \/\/ or \"flattened\"\n+      _ff_initialized,  \/\/ has ConstantValue initializer attribute\n+      _ff_injected,     \/\/ internal field injected by the JVM\n+      _ff_generic,      \/\/ has a generic signature\n+      _ff_stable,       \/\/ trust as stable b\/c declared as @Stable\n+      _ff_contended,    \/\/ is contended, may have contention-group\n+    };\n+\n+    \/\/ Some but not all of the flag bits signal the presence of an\n+    \/\/ additional 32-bit item in the field record.\n+    static const u4 _optional_item_bit_mask =\n+      flag_mask((int)_ff_initialized) |\n+      flag_mask((int)_ff_generic)     |\n+      flag_mask((int)_ff_contended);\n@@ -80,3 +89,2 @@\n-  void set_name_index(u2 val)                    { _shorts[name_index_offset] = val;         }\n-  void set_signature_index(u2 val)               { _shorts[signature_index_offset] = val;    }\n-  void set_initval_index(u2 val)                 { _shorts[initval_index_offset] = val;      }\n+    \/\/ boilerplate:\n+    u4 _flags;\n@@ -84,3 +92,48 @@\n-  u2 name_index() const                          { return _shorts[name_index_offset];        }\n-  u2 signature_index() const                     { return _shorts[signature_index_offset];   }\n-  u2 initval_index() const                       { return _shorts[initval_index_offset];     }\n+    bool test_flag(FieldFlagBitPosition pos) const {\n+      return (_flags & flag_mask(pos)) != 0;\n+    }\n+    void update_flag(FieldFlagBitPosition pos, bool z) {\n+      if (z)    _flags |=  flag_mask(pos);\n+      else      _flags &= ~flag_mask(pos);\n+    }\n+\n+   public:\n+    FieldFlags(u4 flags) {\n+      _flags = flags;\n+    }\n+    u4 as_uint() const { return _flags; }\n+    bool has_any_optionals() const {\n+      return (_flags & _optional_item_bit_mask) != 0;\n+    }\n+\n+    bool is_initialized() const     { return test_flag(_ff_initialized); }\n+    bool is_inlined() const         { return test_flag(_ff_inlined); }\n+    bool is_injected() const        { return test_flag(_ff_injected); }\n+    bool is_generic() const         { return test_flag(_ff_generic); }\n+    bool is_stable() const          { return test_flag(_ff_stable); }\n+    bool is_contended() const       { return test_flag(_ff_contended); }\n+\n+    void update_initialized(bool z) { update_flag(_ff_initialized, z); }\n+    void update_inlined(bool z)     { update_flag(_ff_inlined, z); }\n+    void update_injected(bool z)    { update_flag(_ff_injected, z); }\n+    void update_generic(bool z)     { update_flag(_ff_generic, z); }\n+    void update_stable(bool z)      { update_flag(_ff_stable, z); }\n+    void update_contended(bool z)   { update_flag(_ff_contended, z); }\n+  };\n+\n+ private:\n+  \/\/ The following items are the unpacked bitwise information content\n+  \/\/ of a field record.  Per-field metadata extracted from the class\n+  \/\/ file are stored logically as a group of these items.  The\n+  \/\/ classfile parser produces these records in a temporary array, and\n+  \/\/ then compresses them into a FieldInfoStream.\n+  \/\/\n+  u4 _index;                    \/\/ which field it is\n+  u2 _name_index;               \/\/ index in CP of name\n+  u2 _signature_index;          \/\/ index in CP of descriptor\n+  u4 _offset;                   \/\/ offset in object layout\n+  AccessFlags _access_flags;    \/\/ access flags (JVM spec)\n+  FieldFlags _field_flags;      \/\/ VM defined flags (not JVM spec)\n+  u2 _initializer_index;        \/\/ index from ConstantValue attr (or 0)\n+  u2 _generic_signature_index;  \/\/ index from GenericSignature attr (or 0)\n+  u2 _contention_group;         \/\/ index from @Contended group item (or 0)\n@@ -89,17 +142,8 @@\n-  static FieldInfo* from_field_array(Array<u2>* fields, int index) {\n-    return ((FieldInfo*)fields->adr_at(index * field_slots));\n-  }\n-  static FieldInfo* from_field_array(u2* fields, int index) {\n-    return ((FieldInfo*)(fields + index * field_slots));\n-  }\n-  void initialize(u2 access_flags,\n-                  u2 name_index,\n-                  u2 signature_index,\n-                  u2 initval_index) {\n-    _shorts[access_flags_offset] = access_flags;\n-    _shorts[name_index_offset] = name_index;\n-    _shorts[signature_index_offset] = signature_index;\n-    _shorts[initval_index_offset] = initval_index;\n-    _shorts[low_packed_offset] = 0;\n-    _shorts[high_packed_offset] = 0;\n-  }\n+  FieldInfo() : _name_index(0),\n+                _signature_index(0),\n+                _offset(0),\n+                _access_flags(AccessFlags(0)),\n+                _field_flags(FieldFlags(0)),\n+                _initializer_index(0),\n+                _generic_signature_index(0),\n+                _contention_group(0) { }\n@@ -108,5 +152,30 @@\n-  u2 access_flags() const                        { return _shorts[access_flags_offset];            }\n-  u4 offset() const {\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) != 0, \"Offset must have been set\");\n-    return build_int_from_shorts(_shorts[low_packed_offset], _shorts[high_packed_offset]) >> FIELDINFO_TAG_SIZE;\n-  }\n+  FieldInfo(AccessFlags access_flags, u2 name_index, u2 signature_index, u2 initval_index, FieldInfo::FieldFlags fflags) :\n+            _name_index(name_index),\n+            _signature_index(signature_index),\n+            _offset(0),\n+            _access_flags(access_flags),\n+            _field_flags(fflags),\n+            _initializer_index(initval_index),\n+            _generic_signature_index(0),\n+            _contention_group(0) {\n+              if (initval_index != 0) {\n+                _field_flags.update_initialized(true);\n+              }\n+            }\n+\n+  u4 index() const                           { return _index; }\n+  void set_index(u4 index)                   { _index = index; }\n+  u2 name_index() const                      { return _name_index; }\n+  void set_name_index(u2 index)              { _name_index = index; }\n+  u2 signature_index() const                 { return _signature_index; }\n+  void set_signature_index(u2 index)         { _signature_index = index; }\n+  u4 offset() const                          { return _offset; }\n+  void set_offset(u4 offset)                 { _offset = offset; }\n+  AccessFlags access_flags() const           { return _access_flags; }\n+  FieldFlags field_flags() const             { return _field_flags; }\n+  FieldFlags* field_flags_addr()             { return &_field_flags; }\n+  u2 initializer_index() const               { return _initializer_index; }\n+  void set_initializer_index(u2 index)       { _initializer_index = index; }\n+  u2 generic_signature_index() const         { return _generic_signature_index; }\n+  void set_generic_signature_index(u2 index) { _generic_signature_index = index; }\n+  u2 contention_group() const                { return _contention_group; }\n@@ -115,1 +184,1 @@\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) != 0;\n+    return _field_flags.is_contended();\n@@ -119,7 +188,2 @@\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) == 0, \"Offset must not have been set\");\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) != 0, \"Field must be contended\");\n-    return _shorts[high_packed_offset];\n- }\n-\n-  bool is_offset_set() const {\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET)!= 0;\n+    assert(is_contended(), \"\");\n+    return _contention_group;\n@@ -128,6 +192,3 @@\n-  Symbol* name(ConstantPool* cp) const {\n-    int index = name_index();\n-    if (is_internal()) {\n-      return lookup_symbol(index);\n-    }\n-    return cp->symbol_at(index);\n+  void set_contended_group(u2 group) {\n+    _field_flags.update_contended(true);\n+    _contention_group = group;\n@@ -136,6 +197,2 @@\n-  Symbol* signature(ConstantPool* cp) const {\n-    int index = signature_index();\n-    if (is_internal()) {\n-      return lookup_symbol(index);\n-    }\n-    return cp->symbol_at(index);\n+  bool is_offset_set() const {\n+    return _offset != 0;\n@@ -144,9 +201,1 @@\n-  void set_access_flags(u2 val)                  { _shorts[access_flags_offset] = val;             }\n-  void set_offset(u4 val)                        {\n-    val = val << FIELDINFO_TAG_SIZE; \/\/ make room for tag\n-    bool inlined = is_inlined();\n-    _shorts[low_packed_offset] = extract_low_short_from_int(val) | FIELDINFO_TAG_OFFSET;\n-    if (inlined) set_inlined(true);\n-    _shorts[high_packed_offset] = extract_high_short_from_int(val);\n-    assert(is_inlined() || !inlined, \"just checking\");\n-  }\n+  inline Symbol* name(ConstantPool* cp) const;\n@@ -154,7 +203,1 @@\n-  void set_inlined(bool b) {\n-    if (b) {\n-      _shorts[low_packed_offset] |= FIELDINFO_TAG_INLINED;\n-    } else {\n-      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_INLINED;\n-    }\n-  }\n+  inline Symbol* signature(ConstantPool* cp) const;\n@@ -162,3 +205,1 @@\n-  bool is_inlined() {\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_INLINED) != 0;\n-  }\n+  inline Symbol* lookup_symbol(int symbol_index) const;\n@@ -166,6 +207,3 @@\n-  void set_contended_group(u2 val) {\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) == 0, \"Offset must not have been set\");\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) == 0, \"Overwriting contended group\");\n-    _shorts[low_packed_offset] |= FIELDINFO_TAG_CONTENDED;\n-    _shorts[high_packed_offset] = val;\n-  }\n+  void print(outputStream* os, ConstantPool* cp);\n+  void static print_from_growable_array(outputStream* os, GrowableArray<FieldInfo>* array, ConstantPool* cp);\n+};\n@@ -173,3 +211,1 @@\n-  bool is_internal() const {\n-    return (access_flags() & JVM_ACC_FIELD_INTERNAL) != 0;\n-  }\n+class FieldInfoStream;\n@@ -177,7 +213,12 @@\n-  bool is_stable() const {\n-    return (access_flags() & JVM_ACC_FIELD_STABLE) != 0;\n-  }\n-  void set_stable(bool z) {\n-    if (z) _shorts[access_flags_offset] |=  JVM_ACC_FIELD_STABLE;\n-    else   _shorts[access_flags_offset] &= ~JVM_ACC_FIELD_STABLE;\n-  }\n+\/\/ Gadget for sizing and\/or writing a stream of field records.\n+template<typename CON>\n+class Mapper {\n+  CON* _consumer;  \/\/ can be UNSIGNED5::Writer or UNSIGNED5::Sizer\n+  int _next_index;\n+public:\n+  Mapper(CON* consumer) : _consumer(consumer) { _next_index = 0; }\n+  int next_index() const { return _next_index; }\n+  void set_next_index(int next_index) { _next_index = next_index; }\n+  CON* consumer() const { return _consumer; }\n+  void map_field_info(const FieldInfo& fi);\n+};\n@@ -185,4 +226,90 @@\n-  Symbol* lookup_symbol(int symbol_index) const {\n-    assert(is_internal(), \"only internal fields\");\n-    return Symbol::vm_symbol_at(static_cast<vmSymbolID>(symbol_index));\n-  }\n+\n+\/\/ Gadget for decoding and reading the stream of field records.\n+class FieldInfoReader {\n+  friend class FieldInfoStream;\n+  friend class ClassFileParser;\n+  friend class FieldStreamBase;\n+  friend class FieldInfo;\n+\n+  UNSIGNED5::Reader<const u1*, int> _r;\n+  int _next_index;\n+\n+  public:\n+  FieldInfoReader(const Array<u1>* fi);\n+\n+  private:\n+  uint32_t next_uint() { return _r.next_uint(); }\n+  void skip(int n) { int s = _r.try_skip(n); assert(s == n,\"\"); }\n+\n+public:\n+  int has_next() { return _r.has_next(); }\n+  int position() { return _r.position(); }\n+  int next_index() { return _next_index; }\n+  void read_field_info(FieldInfo& fi);\n+  \/\/ skip a whole field record, both required and optional bits\n+  FieldInfoReader&  skip_field_info();\n+\n+  \/\/ Skip to the nth field.  If the reader is freshly initialized to\n+  \/\/ the zero index, this will call skip_field_info() n times.\n+  FieldInfoReader& skip_to_field_info(int n);\n+\n+  \/\/ for random access, if you know where to go up front:\n+  FieldInfoReader& set_position_and_next_index(int position, int next_index);\n+};\n+\n+\/\/ The format of the stream, after decompression, is a series of\n+\/\/ integers organized like this:\n+\/\/\n+\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+\/\/   Field := name sig offset access flags Optionals(flags)\n+\/\/   Optionals(i) := initval?[i&is_init]     \/\/ ConstantValue attr\n+\/\/                   gsig?[i&is_generic]     \/\/ signature attr\n+\/\/                   group?[i&is_contended]  \/\/ Contended anno (group)\n+\/\/   End = 0\n+\/\/\n+class FieldInfoStream : AllStatic {\n+  friend class fieldDescriptor;\n+  friend class JavaFieldStream;\n+  friend class FieldStreamBase;\n+  friend class ClassFileParser;\n+\n+ public:\n+  static int num_java_fields(const Array<u1>* fis);\n+  static int num_injected_java_fields(const Array<u1>* fis);\n+  static int num_total_fields(const Array<u1>* fis);\n+\n+  static Array<u1>* create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+                                                          ClassLoaderData* loader_data, TRAPS);\n+  static GrowableArray<FieldInfo>* create_FieldInfoArray(const Array<u1>* fis, int* java_fields_count, int* injected_fields_count);\n+  static void print_from_fieldinfo_stream(Array<u1>* fis, outputStream* os, ConstantPool* cp);\n+};\n+\n+class FieldStatus {\n+  enum FieldStatusBitPosition {\n+    _fs_access_watched,       \/\/ field access is watched by JVMTI\n+    _fs_modification_watched, \/\/ field modification is watched by JVMTI\n+    _initialized_final_update \/\/ (static) final field updated outside (class) initializer\n+  };\n+\n+  \/\/ boilerplate:\n+  u1 _flags;\n+  static constexpr u1 flag_mask(FieldStatusBitPosition pos) { return (u1)1 << (int)pos; }\n+  bool test_flag(FieldStatusBitPosition pos) { return (_flags & flag_mask(pos)) != 0; }\n+  \/\/ this performs an atomic update on a live status byte!\n+  void update_flag(FieldStatusBitPosition pos, bool z);\n+  \/\/ out-of-line functions do a CAS-loop\n+  static void atomic_set_bits(u1& flags, u1 mask);\n+  static void atomic_clear_bits(u1& flags, u1 mask);\n+\n+  public:\n+  FieldStatus() { _flags = 0; }\n+  FieldStatus(u1 flags) { _flags = flags; }\n+  u1 as_uint() { return _flags; }\n+\n+  bool is_access_watched()        { return test_flag(_fs_access_watched); }\n+  bool is_modification_watched()  { return test_flag(_fs_modification_watched); }\n+  bool is_initialized_final_update() { return test_flag(_initialized_final_update); }\n+\n+  void update_access_watched(bool z);\n+  void update_modification_watched(bool z);\n+  void update_initialized_final_update(bool z);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":250,"deletions":123,"binary":false,"changes":373,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-  Array<u2>*          _fields;\n+  const Array<u1>*    _fieldinfo_stream;\n+  FieldInfoReader     _reader;\n@@ -47,1 +48,2 @@\n-  int                 _generic_signature_slot;\n+\n+  FieldInfo           _fi_buf;\n@@ -50,30 +52,3 @@\n-  FieldInfo* field() const { return FieldInfo::from_field_array(_fields, _index); }\n-\n-  int init_generic_signature_start_slot() {\n-    int length = _fields->length();\n-    int num_fields = _index;\n-    int skipped_generic_signature_slots = 0;\n-    FieldInfo* fi;\n-    AccessFlags flags;\n-    \/* Scan from 0 to the current _index. Count the number of generic\n-       signature slots for field[0] to field[_index - 1]. *\/\n-    for (int i = 0; i < _index; i++) {\n-      fi = FieldInfo::from_field_array(_fields, i);\n-      flags.set_flags(fi->access_flags());\n-      if (flags.field_has_generic_signature()) {\n-        length --;\n-        skipped_generic_signature_slots ++;\n-      }\n-    }\n-    \/* Scan from the current _index. *\/\n-    for (int i = _index; i*FieldInfo::field_slots < length; i++) {\n-      fi = FieldInfo::from_field_array(_fields, i);\n-      flags.set_flags(fi->access_flags());\n-      if (flags.field_has_generic_signature()) {\n-        length --;\n-      }\n-      num_fields ++;\n-    }\n-    _generic_signature_slot = length + skipped_generic_signature_slots;\n-    assert(_generic_signature_slot <= _fields->length(), \"\");\n-    return num_fields;\n+  FieldInfo const * field() const {\n+    assert(!done(), \"no more fields\");\n+    return &_fi_buf;\n@@ -82,1 +57,3 @@\n-  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, int start, int limit);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants, int start, int limit);\n+\n+  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n@@ -84,1 +61,9 @@\n-  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants);\n+  private:\n+   void initialize() {\n+    int java_fields_count = _reader.next_uint();\n+    int injected_fields_count = _reader.next_uint();\n+    assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    if (_limit != 0) {\n+      _reader.read_field_info(_fi_buf);\n+    }\n+   }\n@@ -93,4 +78,2 @@\n-    if (access_flags().field_has_generic_signature()) {\n-      _generic_signature_slot ++;\n-      assert(_generic_signature_slot <= _fields->length(), \"\");\n-    }\n+    if (done()) return;\n+    _reader.read_field_info(_fi_buf);\n@@ -103,3 +86,1 @@\n-    AccessFlags flags;\n-    flags.set_flags(field()->access_flags());\n-    return flags;\n+    return field()->access_flags();\n@@ -108,6 +89,2 @@\n-  void set_access_flags(u2 flags) const {\n-    field()->set_access_flags(flags);\n-  }\n-\n-  void set_access_flags(AccessFlags flags) const {\n-    set_access_flags(flags.as_short());\n+  FieldInfo::FieldFlags field_flags() const {\n+    return field()->field_flags();\n@@ -125,4 +102,2 @@\n-    if (access_flags().field_has_generic_signature()) {\n-      assert(_generic_signature_slot < _fields->length(), \"out of bounds\");\n-      int index = _fields->at(_generic_signature_slot);\n-      return _constants->symbol_at(index);\n+    if (field()->field_flags().is_generic()) {\n+      return _constants->symbol_at(field()->generic_signature_index());\n@@ -139,1 +114,1 @@\n-    return field()->is_inlined();\n+    return field()->field_flags().is_inlined();\n@@ -142,2 +117,2 @@\n-  void set_inlined(bool b) {\n-    field()->set_inlined(b);\n+  bool is_contended() const {\n+    return field()->is_contended();\n@@ -146,2 +121,2 @@\n-  void set_offset(int offset) {\n-    field()->set_offset(offset);\n+  int contended_group() const {\n+    return field()->contended_group();\n@@ -150,3 +125,1 @@\n-  bool is_offset_set() const {\n-    return field()->is_offset_set();\n-  }\n+  \/\/ Convenient methods\n@@ -154,2 +127,2 @@\n-  bool is_contended() const {\n-    return field()->is_contended();\n+  FieldInfo to_FieldInfo() {\n+    return _fi_buf;\n@@ -158,2 +131,2 @@\n-  int contended_group() const {\n-    return field()->contended_group();\n+  int num_total_fields() const {\n+    return FieldInfoStream::num_total_fields(_fieldinfo_stream);\n@@ -173,1 +146,1 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fields(), k->constants(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()) {}\n@@ -176,1 +149,1 @@\n-    assert(!field()->is_internal(), \"regular only\");\n+    assert(!field()->field_flags().is_injected(), \"regular only\");\n@@ -179,4 +152,1 @@\n-  void set_name_index(int index) {\n-    assert(!field()->is_internal(), \"regular only\");\n-    field()->set_name_index(index);\n-  }\n+\n@@ -184,1 +154,1 @@\n-    assert(!field()->is_internal(), \"regular only\");\n+    assert(!field()->field_flags().is_injected(), \"regular only\");\n@@ -186,0 +156,1 @@\n+    return -1;\n@@ -187,4 +158,1 @@\n-  void set_signature_index(int index) {\n-    assert(!field()->is_internal(), \"regular only\");\n-    field()->set_signature_index(index);\n-  }\n+\n@@ -192,13 +160,3 @@\n-    assert(!field()->is_internal(), \"regular only\");\n-    if (access_flags().field_has_generic_signature()) {\n-      assert(_generic_signature_slot < _fields->length(), \"out of bounds\");\n-      return _fields->at(_generic_signature_slot);\n-    } else {\n-      return 0;\n-    }\n-  }\n-  void set_generic_signature_index(int index) {\n-    assert(!field()->is_internal(), \"regular only\");\n-    if (access_flags().field_has_generic_signature()) {\n-      assert(_generic_signature_slot < _fields->length(), \"out of bounds\");\n-      _fields->at_put(_generic_signature_slot, index);\n+    assert(!field()->field_flags().is_injected(), \"regular only\");\n+    if (field()->field_flags().is_generic()) {\n+      return field()->generic_signature_index();\n@@ -206,0 +164,1 @@\n+    return 0;\n@@ -207,0 +166,1 @@\n+\n@@ -208,6 +168,2 @@\n-    assert(!field()->is_internal(), \"regular only\");\n-    return field()->initval_index();\n-  }\n-  void set_initval_index(int index) {\n-    assert(!field()->is_internal(), \"regular only\");\n-    return field()->set_initval_index(index);\n+    assert(!field()->field_flags().is_injected(), \"regular only\");\n+    return field()->initializer_index();\n@@ -221,1 +177,1 @@\n-  InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants(), k->java_fields_count(), 0) {}\n+  InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k->fieldinfo_stream(), k->constants(), k->java_fields_count(), 0) {}\n@@ -227,2 +183,2 @@\n-  AllFieldStream(Array<u2>* fields, ConstantPool* constants): FieldStreamBase(fields, constants) {}\n-  AllFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants()) {}\n+  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n+  AllFieldStream(const InstanceKlass* k):      FieldStreamBase(k->fieldinfo_stream(), k->constants()) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":52,"deletions":96,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -54,0 +54,6 @@\n+  set_prototype_header(markWord::inline_type_prototype());\n+  assert(is_inline_klass(), \"sanity\");\n+  assert(prototype_header().is_inline_type(), \"sanity\");\n+}\n+\n+void InlineKlass::init_fixed_block() {\n@@ -64,3 +70,0 @@\n-  set_prototype_header(markWord::inline_type_prototype());\n-  assert(is_inline_klass(), \"sanity\");\n-  assert(prototype_header().is_inline_type(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/classFileParser.hpp\"\n@@ -40,0 +41,1 @@\n+  friend class ClassFileParser;\n@@ -51,0 +53,1 @@\n+  void init_fixed_block();\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -168,1 +168,3 @@\n-bool InstanceKlass::field_is_null_free_inline_type(int index) const { return Signature::basic_type(field(index)->signature(constants())) == T_PRIMITIVE_OBJECT; }\n+bool InstanceKlass::field_is_null_free_inline_type(int index) const {\n+  return Signature::basic_type(field_signature(index)) == T_PRIMITIVE_OBJECT;\n+}\n@@ -481,1 +483,0 @@\n-  assert(ik->size() == size, \"\");\n@@ -562,4 +563,3 @@\n-    if (parser.has_inline_fields()) {\n-      set_has_inline_type_fields();\n-    }\n-    _java_fields_count = parser.java_fields_count();\n+  if (parser.has_inline_fields()) {\n+    set_has_inline_type_fields();\n+  }\n@@ -699,2 +699,7 @@\n-  if (fields() != nullptr && !fields()->is_shared()) {\n-    MetadataFactory::free_array<jushort>(loader_data, fields());\n+  if (fieldinfo_stream() != nullptr && !fieldinfo_stream()->is_shared()) {\n+    MetadataFactory::free_array<u1>(loader_data, fieldinfo_stream());\n+  }\n+  set_fieldinfo_stream(nullptr);\n+\n+  if (fields_status() != nullptr && !fields_status()->is_shared()) {\n+    MetadataFactory::free_array<FieldStatus>(loader_data, fields_status());\n@@ -702,1 +707,1 @@\n-  set_fields(nullptr, 0);\n+  set_fields_status(nullptr);\n@@ -1588,0 +1593,12 @@\n+instanceOop InstanceKlass::allocate_instance(oop java_class, TRAPS) {\n+  Klass* k = java_lang_Class::as_Klass(java_class);\n+  if (k == nullptr) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n+  }\n+  InstanceKlass* ik = cast(k);\n+  ik->check_valid_for_instantiation(false, CHECK_NULL);\n+  ik->initialize(CHECK_NULL);\n+  return ik->allocate_instance(THREAD);\n+}\n+\n@@ -1712,0 +1729,11 @@\n+\n+FieldInfo InstanceKlass::field(int index) const {\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+    if (fs.index() == index) {\n+      return fs.to_FieldInfo();\n+    }\n+  }\n+  fatal(\"Field not found\");\n+  return FieldInfo();\n+}\n+\n@@ -2641,2 +2669,3 @@\n-  \/\/ _fields might be written into by Rewriter::scan_method() -> fd.set_has_initialized_final_update()\n-  it->push(&_fields, MetaspaceClosure::_writable);\n+  it->push(&_fieldinfo_stream);\n+  \/\/ _fields_status might be written into by Rewriter::scan_method() -> fd.set_has_initialized_final_update()\n+  it->push(&_fields_status, MetaspaceClosure::_writable);\n@@ -2716,1 +2745,1 @@\n-    for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/constantPool.hpp\"\n@@ -244,1 +245,0 @@\n-  u2              _java_fields_count;       \/\/ The number of declared Java fields\n@@ -297,14 +297,4 @@\n-  \/\/ Instance and static variable information, starts with 6-tuples of shorts\n-  \/\/ [access, name index, sig index, initval index, low_offset, high_offset]\n-  \/\/ for all fields, followed by the generic signature data at the end of\n-  \/\/ the array. Only fields with generic signature attributes have the generic\n-  \/\/ signature data set in the array. The fields array looks like following:\n-  \/\/\n-  \/\/ f1: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/ f2: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/      ...\n-  \/\/ fn: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/     [generic signature index]\n-  \/\/     [generic signature index]\n-  \/\/     ...\n-  Array<u2>*      _fields;\n+  \/\/ Fields information is stored in an UNSIGNED5 encoded stream (see fieldInfo.hpp)\n+  Array<u1>*          _fieldinfo_stream;\n+  Array<FieldStatus>* _fields_status;\n+\n@@ -450,1 +440,1 @@\n-  FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }\n+  FieldInfo field(int index) const;\n@@ -453,5 +443,7 @@\n-  int     field_offset      (int index) const { return field(index)->offset(); }\n-  int     field_access_flags(int index) const { return field(index)->access_flags(); }\n-  Symbol* field_name        (int index) const { return field(index)->name(constants()); }\n-  Symbol* field_signature   (int index) const { return field(index)->signature(constants()); }\n-  bool    field_is_inlined(int index) const { return field(index)->is_inlined(); }\n+  int     field_offset      (int index) const { return field(index).offset(); }\n+  int     field_access_flags(int index) const { return field(index).access_flags().as_int(); }\n+  FieldInfo::FieldFlags field_flags(int index) const { return field(index).field_flags(); }\n+  FieldStatus field_status(int index)   const { return fields_status()->at(index); }\n+  inline Symbol* field_name        (int index) const;\n+  inline Symbol* field_signature   (int index) const;\n+  bool    field_is_inlined(int index) const { return field_flags(index).is_inlined(); }\n@@ -461,1 +453,2 @@\n-  int java_fields_count() const           { return (int)_java_fields_count; }\n+  int java_fields_count() const;\n+  int total_fields_count() const;\n@@ -463,6 +456,5 @@\n-  Array<u2>* fields() const            { return _fields; }\n-  void set_fields(Array<u2>* f, u2 java_fields_count) {\n-    guarantee(_fields == nullptr || f == nullptr, \"Just checking\");\n-    _fields = f;\n-    _java_fields_count = java_fields_count;\n-  }\n+  Array<u1>* fieldinfo_stream() const { return _fieldinfo_stream; }\n+  void set_fieldinfo_stream(Array<u1>* fis) { _fieldinfo_stream = fis; }\n+\n+  Array<FieldStatus>* fields_status() const {return _fields_status; }\n+  void set_fields_status(Array<FieldStatus>* array) { _fields_status = array; }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":20,"deletions":28,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/memRegion.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"oops\/fieldInfo.inline.hpp\"\n@@ -36,1 +38,0 @@\n-#include \"utilities\/debug.hpp\"\n@@ -39,1 +40,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -48,0 +48,6 @@\n+inline Symbol* InstanceKlass::field_name(int index) const { return field(index).name(constants()); }\n+inline Symbol* InstanceKlass::field_signature(int index) const { return field(index).signature(constants()); }\n+\n+inline int InstanceKlass::java_fields_count() const { return FieldInfoStream::num_java_fields(fieldinfo_stream()); }\n+inline int InstanceKlass::total_fields_count() const { return FieldInfoStream::num_total_fields(fieldinfo_stream()); }\n+\n@@ -233,12 +239,0 @@\n-inline instanceOop InstanceKlass::allocate_instance(oop java_class, TRAPS) {\n-  Klass* k = java_lang_Class::as_Klass(java_class);\n-  if (k == nullptr) {\n-    ResourceMark rm(THREAD);\n-    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n-  }\n-  InstanceKlass* ik = cast(k);\n-  ik->check_valid_for_instantiation(false, CHECK_NULL);\n-  ik->initialize(CHECK_NULL);\n-  return ik->allocate_instance(THREAD);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -869,6 +869,0 @@\n-  FailedSpeculation* fs = new (fs_size) FailedSpeculation(speculation, speculation_len);\n-  if (fs == nullptr) {\n-    \/\/ no memory -> ignore failed speculation\n-    return false;\n-  }\n-  guarantee(is_aligned(fs, sizeof(FailedSpeculation*)), \"FailedSpeculation objects must be pointer aligned\");\n@@ -879,0 +873,1 @@\n+  FailedSpeculation* fs = nullptr;\n@@ -881,0 +876,9 @@\n+      if (fs == nullptr) {\n+        \/\/ lazily allocate FailedSpeculation\n+        fs = new (fs_size) FailedSpeculation(speculation, speculation_len);\n+        if (fs == nullptr) {\n+          \/\/ no memory -> ignore failed speculation\n+          return false;\n+        }\n+        guarantee(is_aligned(fs, sizeof(FailedSpeculation*)), \"FailedSpeculation objects must be pointer aligned\");\n+      }\n@@ -886,3 +890,9 @@\n-      cursor = old_fs->next_adr();\n-    } else {\n-      cursor = (*cursor)->next_adr();\n+    guarantee(*cursor != nullptr, \"cursor must point to non-null FailedSpeculation\");\n+    \/\/ check if the current entry matches this thread's failed speculation\n+    if ((*cursor)->data_len() == speculation_len && memcmp(speculation, (*cursor)->data(), speculation_len) == 0) {\n+      if (fs != nullptr) {\n+        delete fs;\n+      }\n+      return false;\n+    }\n+    cursor = (*cursor)->next_adr();\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-    Node* off = phase->MakeConX(field->offset());\n+    Node* off = phase->MakeConX(field->offset_in_bytes());\n@@ -424,1 +424,1 @@\n-      int off_in_vt = field->offset() - vk->first_field_offset();\n+      int off_in_vt = field->offset_in_bytes() - vk->first_field_offset();\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -782,0 +782,5 @@\n+#if INCLUDE_JVMTI\n+  case vmIntrinsics::_notifyJvmtiMount:\n+  case vmIntrinsics::_notifyJvmtiUnmount:\n+  case vmIntrinsics::_notifyJvmtiHideFrames:\n+#endif\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1768,1 +1768,1 @@\n-            field->offset() == original_field->offset() &&\n+            field->offset_in_bytes() == original_field->offset_in_bytes() &&\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3965,1 +3965,1 @@\n-          if (field->offset() >= TrackedInitializationLimit * HeapWordSize)\n+          if (field->offset_in_bytes() >= TrackedInitializationLimit * HeapWordSize)\n@@ -3967,1 +3967,1 @@\n-          int off_in_vt = field->offset() - vk->first_field_offset();\n+          int off_in_vt = field->offset_in_bytes() - vk->first_field_offset();\n@@ -3987,1 +3987,1 @@\n-        if (field->offset() >= TrackedInitializationLimit * HeapWordSize)\n+        if (field->offset_in_bytes() >= TrackedInitializationLimit * HeapWordSize)\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  return inline_klass()->declared_nonstatic_field_at(index)->offset();\n+  return inline_klass()->declared_nonstatic_field_at(index)->offset_in_bytes();\n@@ -278,1 +278,1 @@\n-    int offset = vk->nonstatic_field_at(j)->offset();\n+    int offset = vk->nonstatic_field_at(j)->offset_in_bytes();\n@@ -626,1 +626,1 @@\n-      field = field_value_by_offset(f->offset(), true);\n+      field = field_value_by_offset(f->offset_in_bytes(), true);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -486,0 +487,8 @@\n+#if INCLUDE_JVMTI\n+  case vmIntrinsics::_notifyJvmtiMount:         return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_mount()),\n+                                                                                        \"notifyJvmtiMount\");\n+  case vmIntrinsics::_notifyJvmtiUnmount:       return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_unmount()),\n+                                                                                        \"notifyJvmtiUnmount\");\n+  case vmIntrinsics::_notifyJvmtiHideFrames:    return inline_native_notify_jvmti_hide();\n+#endif\n+\n@@ -3058,0 +3067,69 @@\n+\n+#if INCLUDE_JVMTI\n+\n+\/\/ When notifications are disabled then just update the VTMS transition bit and return.\n+\/\/ Otherwise, the bit is updated in the given function call implementing JVMTI notification protocol.\n+bool LibraryCallKit::inline_native_notify_jvmti_funcs(address funcAddr, const char* funcName) {\n+  if (!DoJVMTIVirtualThreadTransitions) {\n+    return true;\n+  }\n+  IdealKit ideal(this);\n+\n+  Node* ONE = ideal.ConI(1);\n+  Node* hide = _gvn.transform(argument(1)); \/\/ hide argument: true for begin and false for end of VTMS transition\n+  Node* addr = makecon(TypeRawPtr::make((address)&JvmtiVTMSTransitionDisabler::_VTMS_notify_jvmti_events));\n+  Node* notify_jvmti_enabled = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+\n+  ideal.if_then(notify_jvmti_enabled, BoolTest::eq, ONE); {\n+    \/\/ if notifyJvmti enabled then make a call to the given SharedRuntime function\n+    const TypeFunc* tf = OptoRuntime::notify_jvmti_Type();\n+    Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n+    Node* cond   = _gvn.transform(argument(2)); \/\/ firstMount or lastUnmount argument\n+\n+    sync_kit(ideal);\n+    make_runtime_call(RC_NO_LEAF, tf, funcAddr, funcName, TypePtr::BOTTOM, vt_oop, hide, cond);\n+    ideal.sync_kit(this);\n+  } ideal.else_(); {\n+    \/\/ set hide value to the VTMS transition bit in current JavaThread\n+    Node* thread = ideal.thread();\n+    Node* addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_VTMS_transition_offset()));\n+    const TypePtr *addr_type = _gvn.type(addr)->isa_ptr();\n+\n+    sync_kit(ideal);\n+    access_store_at(nullptr, addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    ideal.sync_kit(this);\n+  } ideal.end_if();\n+  final_sync(ideal);\n+\n+  return true;\n+}\n+\n+\/\/ If notifications are enabled then just update the temporary VTMS transition bit.\n+bool LibraryCallKit::inline_native_notify_jvmti_hide() {\n+  if (!DoJVMTIVirtualThreadTransitions) {\n+    return true;\n+  }\n+  IdealKit ideal(this);\n+\n+  Node* ONE = ideal.ConI(1);\n+  Node* addr = makecon(TypeRawPtr::make((address)&JvmtiVTMSTransitionDisabler::_VTMS_notify_jvmti_events));\n+  Node* notify_jvmti_enabled = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+\n+  ideal.if_then(notify_jvmti_enabled, BoolTest::eq, ONE); {\n+    \/\/ set the VTMS temporary transition bit in current JavaThread\n+    Node* thread = ideal.thread();\n+    Node* hide = _gvn.transform(argument(1)); \/\/ hide argument for temporary VTMS transition notification\n+    Node* addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_tmp_VTMS_transition_offset()));\n+    const TypePtr *addr_type = _gvn.type(addr)->isa_ptr();\n+\n+    sync_kit(ideal);\n+    access_store_at(nullptr, addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    ideal.sync_kit(this);\n+  } ideal.end_if();\n+  final_sync(ideal);\n+\n+  return true;\n+}\n+\n+#endif \/\/ INCLUDE_JVMTI\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -270,0 +270,5 @@\n+#if INCLUDE_JVMTI\n+  bool inline_native_notify_jvmti_funcs(address funcAddr, const char* funcName);\n+  bool inline_native_notify_jvmti_hide();\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -827,1 +827,1 @@\n-        offset = field->offset();\n+        offset = field->offset_in_bytes();\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -905,0 +905,3 @@\n+    int add1Con = 0;\n+    const_shift_count(phase, add1, &add1Con);\n+\n@@ -906,1 +909,1 @@\n-    if (add1->in(2) == in(2)) {\n+    if (add1Con > 0 && con == add1Con) {\n@@ -910,3 +913,0 @@\n-      int add1Con = 0;\n-      const_shift_count(phase, add1, &add1Con);\n-\n@@ -1081,0 +1081,3 @@\n+    int add1Con = 0;\n+    const_shift_count(phase, add1, &add1Con);\n+\n@@ -1082,1 +1085,1 @@\n-    if (add1->in(2) == in(2)) {\n+    if (add1Con > 0 && con == add1Con) {\n@@ -1086,3 +1089,0 @@\n-      int add1Con = 0;\n-      const_shift_count(phase, add1, &add1Con);\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1817,0 +1817,5 @@\n+  if (!cb->finalize_stubs()) {\n+    C->record_failure(\"CodeCache is full\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    Node* value = vt->field_value_by_offset(field->offset());\n+    Node* value = vt->field_value_by_offset(field->offset_in_bytes());\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-  new_vt->set_field_value_by_offset(field->offset(), val);\n+  new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-\n@@ -115,0 +114,4 @@\n+#if INCLUDE_JVMTI\n+address OptoRuntime::_notify_jvmti_mount                          = nullptr;\n+address OptoRuntime::_notify_jvmti_unmount                        = nullptr;\n+#endif\n@@ -154,0 +157,4 @@\n+#if INCLUDE_JVMTI\n+  gen(env, _notify_jvmti_mount             , notify_jvmti_Type            , SharedRuntime::notify_jvmti_mount,   0 , true, false);\n+  gen(env, _notify_jvmti_unmount           , notify_jvmti_Type            , SharedRuntime::notify_jvmti_unmount, 0 , true, false);\n+#endif\n@@ -1654,0 +1661,18 @@\n+#if INCLUDE_JVMTI\n+const TypeFunc *OptoRuntime::notify_jvmti_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(3);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ VirtualThread oop\n+  fields[TypeFunc::Parms+1] = TypeInt::BOOL;        \/\/ jboolean\n+  fields[TypeFunc::Parms+2] = TypeInt::BOOL;        \/\/ jboolean\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+3,fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+\n+  return TypeFunc::make(domain,range);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -139,0 +139,4 @@\n+#if INCLUDE_JVMTI\n+  static address _notify_jvmti_mount;\n+  static address _notify_jvmti_unmount;\n+#endif\n@@ -213,0 +217,4 @@\n+#if INCLUDE_JVMTI\n+  static address notify_jvmti_mount()                    { return _notify_jvmti_mount; }\n+  static address notify_jvmti_unmount()                  { return _notify_jvmti_unmount; }\n+#endif\n@@ -299,0 +307,3 @@\n+#if INCLUDE_JVMTI\n+  static const TypeFunc* notify_jvmti_Type();\n+#endif\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4005,1 +4005,3 @@\n-JVM_ENTRY(void, JVM_VirtualThreadMountBegin(JNIEnv* env, jobject vthread, jboolean first_mount))\n+\/\/ If notifications are disabled then just update the VTMS transition bit and return.\n+\/\/ Otherwise, the bit is updated in the given jvmtiVTMSTransitionDisabler function call.\n+JVM_ENTRY(void, JVM_VirtualThreadMount(JNIEnv* env, jobject vthread, jboolean hide, jboolean first_mount))\n@@ -4011,12 +4013,2 @@\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n-  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n-  JvmtiVTMSTransitionDisabler::start_VTMS_transition(vthread, \/* is_mount *\/ true);\n-#else\n-  fatal(\"Should only be called with JVMTI enabled\");\n-#endif\n-JVM_END\n-\n-JVM_ENTRY(void, JVM_VirtualThreadMountEnd(JNIEnv* env, jobject vthread, jboolean first_mount))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n+  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+    thread->set_is_in_VTMS_transition(hide);\n@@ -4025,31 +4017,4 @@\n-  oop vt = JNIHandles::resolve(vthread);\n-\n-  thread->rebind_to_jvmti_thread_state_of(vt);\n-\n-  {\n-    MutexLocker mu(JvmtiThreadState_lock);\n-    JvmtiThreadState* state = thread->jvmti_thread_state();\n-    if (state != nullptr && state->is_pending_interp_only_mode()) {\n-      JvmtiEventController::enter_interp_only_mode();\n-    }\n-  }\n-  assert(thread->is_in_VTMS_transition(), \"sanity check\");\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n-  JvmtiVTMSTransitionDisabler::finish_VTMS_transition(vthread, \/* is_mount *\/ true);\n-  if (first_mount) {\n-    \/\/ thread start\n-    if (JvmtiExport::can_support_virtual_threads()) {\n-      JvmtiEventController::thread_started(thread);\n-      if (JvmtiExport::should_post_vthread_start()) {\n-        JvmtiExport::post_vthread_start(vthread);\n-      }\n-    } else { \/\/ compatibility for vthread unaware agents: legacy thread_start\n-      if (PostVirtualThreadCompatibleLifecycleEvents &&\n-          JvmtiExport::should_post_thread_life()) {\n-        \/\/ JvmtiEventController::thread_started is called here\n-        JvmtiExport::post_thread_start(thread);\n-      }\n-    }\n-  }\n-  if (JvmtiExport::should_post_vthread_mount()) {\n-    JvmtiExport::post_vthread_mount(vthread);\n+  if (hide) {\n+   JvmtiVTMSTransitionDisabler::VTMS_mount_begin(vthread, first_mount);\n+  } else {\n+   JvmtiVTMSTransitionDisabler::VTMS_mount_end(vthread, first_mount);\n@@ -4062,1 +4027,3 @@\n-JVM_ENTRY(void, JVM_VirtualThreadUnmountBegin(JNIEnv* env, jobject vthread, jboolean last_unmount))\n+\/\/ If notifications are disabled then just update the VTMS transition bit and return.\n+\/\/ Otherwise, the bit is updated in the given jvmtiVTMSTransitionDisabler function call below.\n+JVM_ENTRY(void, JVM_VirtualThreadUnmount(JNIEnv* env, jobject vthread, jboolean hide, jboolean last_unmount))\n@@ -4068,17 +4035,3 @@\n-  HandleMark hm(thread);\n-  Handle ct(thread, thread->threadObj());\n-\n-  if (JvmtiExport::should_post_vthread_unmount()) {\n-    JvmtiExport::post_vthread_unmount(vthread);\n-  }\n-  if (last_unmount) {\n-    if (JvmtiExport::can_support_virtual_threads()) {\n-      if (JvmtiExport::should_post_vthread_end()) {\n-        JvmtiExport::post_vthread_end(vthread);\n-      }\n-    } else { \/\/ compatibility for vthread unaware agents: legacy thread_end\n-      if (PostVirtualThreadCompatibleLifecycleEvents &&\n-          JvmtiExport::should_post_thread_life()) {\n-        JvmtiExport::post_thread_end(thread);\n-      }\n-    }\n+  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+    thread->set_is_in_VTMS_transition(hide);\n+    return;\n@@ -4086,9 +4039,4 @@\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n-  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n-  JvmtiVTMSTransitionDisabler::start_VTMS_transition(vthread, \/* is_mount *\/ false);\n-\n-  if (last_unmount && thread->jvmti_thread_state() != nullptr) {\n-    JvmtiExport::cleanup_thread(thread);\n-    thread->set_jvmti_thread_state(nullptr);\n-    oop vt = JNIHandles::resolve(vthread);\n-    java_lang_Thread::set_jvmti_thread_state(vt, nullptr);\n+  if (hide) {\n+   JvmtiVTMSTransitionDisabler::VTMS_unmount_begin(vthread, last_unmount);\n+  } else {\n+   JvmtiVTMSTransitionDisabler::VTMS_unmount_end(vthread, last_unmount);\n@@ -4096,1 +4044,0 @@\n-  thread->rebind_to_jvmti_thread_state_of(ct());\n@@ -4102,1 +4049,2 @@\n-JVM_ENTRY(void, JVM_VirtualThreadUnmountEnd(JNIEnv* env, jobject vthread, jboolean last_unmount))\n+\/\/ If notifications are enabled then just update the temporary VTMS transition bit.\n+JVM_ENTRY(void, JVM_VirtualThreadHideFrames(JNIEnv* env, jobject vthread, jboolean hide))\n@@ -4108,12 +4056,1 @@\n-  assert(thread->is_in_VTMS_transition(), \"sanity check\");\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n-  JvmtiVTMSTransitionDisabler::finish_VTMS_transition(vthread, \/* is_mount *\/ false);\n-#else\n-  fatal(\"Should only be called with JVMTI enabled\");\n-#endif\n-JVM_END\n-\n-JVM_ENTRY(void, JVM_VirtualThreadHideFrames(JNIEnv* env, jobject vthread, jboolean hide))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n+  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":22,"deletions":85,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -382,5 +382,1 @@\n-    java_lang_VirtualThread::set_notify_jvmti_events(true);\n-    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {\n-      ThreadInVMfromNative __tiv(JavaThread::current());\n-      java_lang_VirtualThread::init_static_notify_jvmti_events();\n-    }\n+    JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3588,2 +3588,7 @@\n-  for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {\n-    jshort cur_index = fs.name_index();\n+  int java_fields;\n+  int injected_fields;\n+  bool update_required = false;\n+  GrowableArray<FieldInfo>* fields = FieldInfoStream::create_FieldInfoArray(scratch_class->fieldinfo_stream(), &java_fields, &injected_fields);\n+  for (int i = 0; i < java_fields; i++) {\n+    FieldInfo* fi = fields->adr_at(i);\n+    jshort cur_index = fi->name_index();\n@@ -3593,1 +3598,2 @@\n-      fs.set_name_index(new_index);\n+      fi->set_name_index(new_index);\n+      update_required = true;\n@@ -3595,1 +3601,1 @@\n-    cur_index = fs.signature_index();\n+    cur_index = fi->signature_index();\n@@ -3599,1 +3605,2 @@\n-      fs.set_signature_index(new_index);\n+      fi->set_signature_index(new_index);\n+      update_required = true;\n@@ -3601,1 +3608,1 @@\n-    cur_index = fs.initval_index();\n+    cur_index = fi->initializer_index();\n@@ -3605,1 +3612,2 @@\n-      fs.set_initval_index(new_index);\n+      fi->set_initializer_index(new_index);\n+      update_required = true;\n@@ -3607,1 +3615,1 @@\n-    cur_index = fs.generic_signature_index();\n+    cur_index = fi->generic_signature_index();\n@@ -3611,1 +3619,2 @@\n-      fs.set_generic_signature_index(new_index);\n+      fi->set_generic_signature_index(new_index);\n+      update_required = true;\n@@ -3613,1 +3622,8 @@\n-  } \/\/ end for each field\n+  }\n+  if (update_required) {\n+    Array<u1>* old_stream = scratch_class->fieldinfo_stream();\n+    assert(fields->length() == (java_fields + injected_fields), \"Must be\");\n+    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n+    scratch_class->set_fieldinfo_stream(new_fis);\n+    MetadataFactory::free_array<u1>(scratch_class->class_loader_data(), old_stream);\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -546,1 +546,0 @@\n-  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -555,0 +554,1 @@\n+  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -2150,0 +2150,5 @@\n+  \/\/ Disable CDS for exploded image\n+  if (!has_jimage()) {\n+    no_shared_spaces(\"CDS disabled on exploded JDK\");\n+  }\n+\n@@ -3680,1 +3685,1 @@\n-      PrintAssembly || TraceDeoptimization || TraceDependencies ||\n+      PrintAssembly || TraceDeoptimization ||\n@@ -4093,4 +4098,3 @@\n-  if (TraceDependencies && VerifyDependencies) {\n-    if (!FLAG_IS_DEFAULT(TraceDependencies)) {\n-      warning(\"TraceDependencies results may be inflated by VerifyDependencies\");\n-    }\n+  bool trace_dependencies = log_is_enabled(Debug, dependencies);\n+  if (trace_dependencies && VerifyDependencies) {\n+    warning(\"dependency logging results may be inflated by VerifyDependencies\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1502,1 +1502,1 @@\n-      if (!fs.access_flags().is_static() && (!skip_internal || !fs.access_flags().is_internal())) {\n+      if (!fs.access_flags().is_static() && (!skip_internal || !fs.field_flags().is_injected())) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,12 +43,1 @@\n-\n-  int idx = 0;\n-  InstanceKlass* ik = field_holder();\n-  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n-    if (idx == _index) {\n-      return fs.generic_signature();\n-    } else {\n-      idx ++;\n-    }\n-  }\n-  assert(false, \"should never happen\");\n-  return vmSymbols::void_signature(); \/\/ return a default value (for code analyzers)\n+  return _cp->symbol_at(_fieldinfo.generic_signature_index());\n@@ -110,5 +99,3 @@\n-  FieldInfo* f = ik->field(index);\n-  _access_flags = accessFlags_from(f->access_flags());\n-  guarantee(f->name_index() != 0 && f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n-  _index = index;\n-  verify();\n+  _fieldinfo= ik->field(index);\n+  assert((int)_fieldinfo.index() == index, \"just checking\");\n+  guarantee(_fieldinfo.name_index() != 0 && _fieldinfo.signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n@@ -117,14 +104,0 @@\n-#ifndef PRODUCT\n-\n-void fieldDescriptor::verify() const {\n-  if (_cp.is_null()) {\n-    assert(_index == badInt, \"constructor must be called\");  \/\/ see constructor\n-  } else {\n-    assert(_index >= 0, \"good index\");\n-    assert(access_flags().is_internal() ||\n-           _index < field_holder()->java_fields_count(), \"oob\");\n-  }\n-}\n-\n-#endif \/* PRODUCT *\/\n-\n@@ -133,1 +106,1 @@\n-  if (access_flags().is_internal()) st->print(\"internal \");\n+  if (field_flags().is_injected()) st->print(\"injected \");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,1 @@\n-  AccessFlags         _access_flags;\n-  int                 _index; \/\/ the field index\n+  FieldInfo           _fieldinfo;\n@@ -45,4 +44,1 @@\n-  \/\/ update the access_flags for the field in the klass\n-  inline void update_klass_field_access_flag();\n-\n-  inline FieldInfo* field() const;\n+  inline FieldInfo field() const { return _fieldinfo; };\n@@ -51,3 +47,1 @@\n-  fieldDescriptor() {\n-    DEBUG_ONLY(_index = badInt);\n-  }\n+  fieldDescriptor() {}\n@@ -55,1 +49,0 @@\n-    DEBUG_ONLY(_index = badInt);\n@@ -60,1 +53,1 @@\n-  inline InstanceKlass* field_holder() const;\n+  inline InstanceKlass* field_holder() const {return _cp->pool_holder(); };\n@@ -63,1 +56,4 @@\n-  AccessFlags access_flags()      const    { return _access_flags; }\n+  AccessFlags access_flags()      const    { return _fieldinfo.access_flags(); }\n+  FieldInfo::FieldFlags field_flags() const { return _fieldinfo.field_flags(); }\n+  FieldStatus field_status()      const    { return field_holder()->fields_status()->at(_fieldinfo.index()); }\n+  oop loader()                    const;\n@@ -67,1 +63,1 @@\n-  int index()                     const    { return _index; }\n+  int index()                     const    { return _fieldinfo.index(); }\n@@ -90,2 +86,4 @@\n-  bool is_stable()                const    { return access_flags().is_stable(); }\n-  inline bool is_inlined() const;\n+  bool is_stable()                const    { return field_flags().is_stable(); }\n+  bool is_volatile()              const    { return access_flags().is_volatile(); }\n+  bool is_transient()             const    { return access_flags().is_transient(); }\n+  inline bool is_inlined()        const;\n@@ -96,1 +94,1 @@\n-  bool is_field_access_watched()  const    { return access_flags().is_field_access_watched(); }\n+  bool is_field_access_watched()  const    { return field_status().is_access_watched(); }\n@@ -98,3 +96,3 @@\n-                                           { return access_flags().is_field_modification_watched(); }\n-  bool has_initialized_final_update() const { return access_flags().has_field_initialized_final_update(); }\n-  bool has_generic_signature()    const    { return access_flags().field_has_generic_signature(); }\n+                                           { return field_status().is_modification_watched(); }\n+  bool has_initialized_final_update() const { return field_status().is_initialized_final_update(); }\n+  bool has_generic_signature()    const    { return field_flags().is_generic(); }\n@@ -115,1 +113,0 @@\n-  void verify() const                           PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/fieldInfo.inline.hpp\"\n@@ -37,1 +38,1 @@\n-  return field()->name(_cp());\n+  return field().name(_cp());\n@@ -41,5 +42,1 @@\n-  return field()->signature(_cp());\n-}\n-\n-inline InstanceKlass* fieldDescriptor::field_holder() const {\n-  return _cp->pool_holder();\n+  return field().signature(_cp());\n@@ -52,13 +49,3 @@\n-inline FieldInfo* fieldDescriptor::field() const {\n-  InstanceKlass* ik = field_holder();\n-  return ik->field(_index);\n-}\n-\n-inline int fieldDescriptor::offset()                    const    { return field()->offset(); }\n-inline bool fieldDescriptor::has_initial_value()        const    { return field()->initval_index() != 0; }\n-inline int fieldDescriptor::initial_value_index()       const    { return field()->initval_index(); }\n-\n-inline void fieldDescriptor::update_klass_field_access_flag() {\n-  InstanceKlass* ik = field_holder();\n-  ik->field(index())->set_access_flags(_access_flags.as_short());\n-}\n+inline int fieldDescriptor::offset()                    const    { return field().offset(); }\n+inline bool fieldDescriptor::has_initial_value()        const    { return field().field_flags().is_initialized(); }\n+inline int fieldDescriptor::initial_value_index()       const    { return field().initializer_index(); }\n@@ -67,2 +54,1 @@\n-  _access_flags.set_is_field_access_watched(value);\n-  update_klass_field_access_flag();\n+  field_holder()->fields_status()->adr_at(index())->update_access_watched(value);\n@@ -72,2 +58,1 @@\n-  _access_flags.set_is_field_modification_watched(value);\n-  update_klass_field_access_flag();\n+  field_holder()->fields_status()->adr_at(index())->update_modification_watched(value);\n@@ -77,2 +62,1 @@\n-  _access_flags.set_has_field_initialized_final_update(value);\n-  update_klass_field_access_flag();\n+  field_holder()->fields_status()->adr_at(index())->update_initialized_final_update(value);\n@@ -85,2 +69,2 @@\n-inline bool fieldDescriptor::is_inlined()  const  { return field()->is_inlined(); }\n-inline bool fieldDescriptor::is_inline_type() const { return Signature::basic_type(field()->signature(_cp())) == T_PRIMITIVE_OBJECT; }\n+inline bool fieldDescriptor::is_inlined()  const  { return field().field_flags().is_inlined(); }\n+inline bool fieldDescriptor::is_inline_type() const { return field_type() == T_PRIMITIVE_OBJECT; }\n@@ -88,1 +72,1 @@\n-#endif \/\/ SHARE_RUNTIME_FIELDDESCRIPTOR_INLINE_HPP\n+#endif \/\/ SHARE_RUNTIME_FIELDDESCRIPTOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -313,4 +313,6 @@\n-  if (TraceDependencies) {\n-    tty->print(\"checking (%s) \", nm->is_marked_for_deoptimization() ? \"true\" : \"false\");\n-    nm->print_value_on(tty);\n-    tty->cr();\n+  LogTarget(Debug, dependencies) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(&lt);\n+    ls.print(\"checking (%s) \", nm->is_marked_for_deoptimization() ? \"true\" : \"false\");\n+    nm->print_value_on(&ls);\n+    ls.cr();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -691,4 +691,0 @@\n-  product(bool, EnableWaitForParallelLoad, false,                           \\\n-          \"(Deprecated) Enable legacy parallel classloading logic for \"     \\\n-          \"class loaders not registered as parallel capable\")               \\\n-                                                                            \\\n@@ -878,3 +874,0 @@\n-  develop(bool, TraceDependencies, false,                                   \\\n-          \"Trace dependencies\")                                             \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -819,0 +819,5 @@\n+#if INCLUDE_JVMTI\n+  static ByteSize is_in_VTMS_transition_offset()     { return byte_offset_of(JavaThread, _is_in_VTMS_transition); }\n+  static ByteSize is_in_tmp_VTMS_transition_offset() { return byte_offset_of(JavaThread, _is_in_tmp_VTMS_transition); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -70,0 +71,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -629,0 +631,22 @@\n+#if INCLUDE_JVMTI\n+JRT_ENTRY(void, SharedRuntime::notify_jvmti_mount(oopDesc* vt, jboolean hide, jboolean first_mount, JavaThread* current))\n+  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n+\n+  if (hide) {\n+    JvmtiVTMSTransitionDisabler::VTMS_mount_begin(vthread, first_mount);\n+  } else {\n+    JvmtiVTMSTransitionDisabler::VTMS_mount_end(vthread, first_mount);\n+  }\n+JRT_END\n+\n+JRT_ENTRY(void, SharedRuntime::notify_jvmti_unmount(oopDesc* vt, jboolean hide, jboolean last_unmount, JavaThread* current))\n+  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n+\n+  if (hide) {\n+    JvmtiVTMSTransitionDisabler::VTMS_unmount_begin(vthread, last_unmount);\n+  } else {\n+    JvmtiVTMSTransitionDisabler::VTMS_unmount_end(vthread, last_unmount);\n+  }\n+JRT_END\n+#endif \/\/ INCLUDE_JVMTI\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -268,0 +268,6 @@\n+#if INCLUDE_JVMTI\n+  \/\/ Functions for JVMTI notifications\n+  static void notify_jvmti_mount(oopDesc* vt, jboolean hide, jboolean first_mount, JavaThread* current);\n+  static void notify_jvmti_unmount(oopDesc* vt, jboolean hide, jboolean last_unmount, JavaThread* current);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -599,40 +599,0 @@\n-\/\/ -----------------------------------------------------------------------------\n-\/\/ Class Loader  support to workaround deadlocks on the class loader lock objects\n-\/\/ Also used by GC\n-\/\/ complete_exit()\/reenter() are used to wait on a nested lock\n-\/\/ i.e. to give up an outer lock completely and then re-enter\n-\/\/ Used when holding nested locks - lock acquisition order: lock1 then lock2\n-\/\/  1) complete_exit lock1 - saving recursion count\n-\/\/  2) wait on lock2\n-\/\/  3) when notified on lock2, unlock lock2\n-\/\/  4) reenter lock1 with original recursion count\n-\/\/  5) lock lock2\n-\/\/ NOTE: must use heavy weight monitor to handle complete_exit\/reenter()\n-intx ObjectSynchronizer::complete_exit(Handle obj, JavaThread* current) {\n-  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n-\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_vm_internal);\n-  intx recur_count = monitor->complete_exit(current);\n-  current->dec_held_monitor_count(recur_count + 1);\n-  return recur_count;\n-}\n-\n-\/\/ NOTE: must use heavy weight monitor to handle complete_exit\/reenter()\n-void ObjectSynchronizer::reenter(Handle obj, intx recursions, JavaThread* current) {\n-  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n-\n-  \/\/ An async deflation can race after the inflate() call and before\n-  \/\/ reenter() -> enter() can make the ObjectMonitor busy. reenter() ->\n-  \/\/ enter() returns false if we have lost the race to async deflation\n-  \/\/ and we simply try again.\n-  while (true) {\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_vm_internal);\n-    if (monitor->reenter(recursions, current)) {\n-      current->inc_held_monitor_count(recursions + 1);\n-      return;\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -230,2 +231,1 @@\n-  nonstatic_field(InstanceKlass,               _fields,                                       Array<u2>*)                            \\\n-  nonstatic_field(InstanceKlass,               _java_fields_count,                            u2)                                    \\\n+  nonstatic_field(InstanceKlass,               _fieldinfo_stream,                             Array<u1>*)                            \\\n@@ -2100,5 +2100,0 @@\n-  declare_constant(JVM_ACC_FIELD_ACCESS_WATCHED)                          \\\n-  declare_constant(JVM_ACC_FIELD_MODIFICATION_WATCHED)                    \\\n-  declare_constant(JVM_ACC_FIELD_INTERNAL)                                \\\n-  declare_constant(JVM_ACC_FIELD_STABLE)                                  \\\n-  declare_constant(JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE)                   \\\n@@ -2236,18 +2231,0 @@\n-  \/*************************************\/                                 \\\n-  \/* FieldInfo FieldOffset enum        *\/                                 \\\n-  \/*************************************\/                                 \\\n-                                                                          \\\n-  declare_constant(FieldInfo::access_flags_offset)                        \\\n-  declare_constant(FieldInfo::name_index_offset)                          \\\n-  declare_constant(FieldInfo::signature_index_offset)                     \\\n-  declare_constant(FieldInfo::initval_index_offset)                       \\\n-  declare_constant(FieldInfo::low_packed_offset)                          \\\n-  declare_constant(FieldInfo::high_packed_offset)                         \\\n-  declare_constant(FieldInfo::field_slots)                                \\\n-                                                                          \\\n-  \/*************************************\/                                 \\\n-  \/* FieldInfo tag constants           *\/                                 \\\n-  \/*************************************\/                                 \\\n-                                                                          \\\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_SIZE\", FIELDINFO_TAG_SIZE) \\\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_OFFSET\", FIELDINFO_TAG_OFFSET) \\\n@@ -2323,0 +2300,11 @@\n+                                                                          \\\n+  \/******************************\/                                        \\\n+  \/* FieldFlags enum            *\/                                        \\\n+  \/******************************\/                                        \\\n+                                                                          \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_initialized)                \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_injected)                   \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_generic)                    \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_stable)                     \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_contended)                  \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1100,11 +1100,0 @@\n-int ThreadDumpToFileDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ThreadDumpToFileDCmd* dcmd = new ThreadDumpToFileDCmd(nullptr, false);\n-  if (dcmd != nullptr) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  static int num_arguments() { return 2; }\n@@ -116,0 +117,1 @@\n+  static int num_arguments() { return 1; }\n@@ -138,0 +140,1 @@\n+  static int num_arguments() { return 2; }\n@@ -179,0 +182,1 @@\n+  static int num_arguments() { return 2; }\n@@ -219,0 +223,1 @@\n+  static int num_arguments() { return 1; }\n@@ -319,0 +324,1 @@\n+  static int num_arguments() { return 4; }\n@@ -345,0 +351,1 @@\n+  static int num_arguments() { return 2; }\n@@ -369,0 +376,1 @@\n+  static int num_arguments() { return 3; }\n@@ -420,0 +428,1 @@\n+  static int num_arguments() { return 2; }\n@@ -435,1 +444,0 @@\n-  static int num_arguments();\n@@ -446,0 +454,1 @@\n+  static int num_arguments() { return 2; }\n@@ -497,0 +506,2 @@\n+  static int num_arguments() { return 21; }\n+\n@@ -660,0 +671,1 @@\n+  static int num_arguments() { return 2; }\n@@ -724,0 +736,1 @@\n+  static int num_arguments() { return 1; }\n@@ -809,0 +822,1 @@\n+  static int num_arguments() { return 1; }\n@@ -831,0 +845,1 @@\n+  static int num_arguments() { return 1; }\n@@ -853,0 +868,1 @@\n+  static int num_arguments() { return 1; }\n@@ -875,0 +891,1 @@\n+  static int num_arguments() { return 1; }\n@@ -919,0 +936,1 @@\n+  static int num_arguments() { return 2; }\n@@ -945,0 +963,1 @@\n+  static int num_arguments() { return 3; }\n@@ -959,1 +978,0 @@\n-  static int num_arguments();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,24 +77,0 @@\n-\n-  \/\/ field flags\n-  \/\/ Note: these flags must be defined in the low order 16 bits because\n-  \/\/ InstanceKlass only stores a ushort worth of information from the\n-  \/\/ AccessFlags value.\n-  \/\/ These bits must not conflict with any other field-related access flags\n-  \/\/ (e.g., ACC_ENUM).\n-  \/\/ Note that the class-related ACC_ANNOTATION bit conflicts with these flags.\n-  JVM_ACC_FIELD_ACCESS_WATCHED            = 0x00002000, \/\/ field access is watched by JVMTI\n-  JVM_ACC_FIELD_MODIFICATION_WATCHED      = 0x00008000, \/\/ field modification is watched by JVMTI\n-  JVM_ACC_FIELD_INTERNAL                  = 0x00000400, \/\/ internal field, same as JVM_ACC_ABSTRACT\n-  JVM_ACC_FIELD_STABLE                    = 0x00000020, \/\/ @Stable field, same as JVM_ACC_SYNCHRONIZED and JVM_ACC_SUPER\n-  JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE  = 0x00000200, \/\/ (static) final field updated outside (class) initializer, same as JVM_ACC_NATIVE\n-  JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE     = 0x00000800, \/\/ field has generic signature\n-\n-  JVM_ACC_FIELD_INTERNAL_FLAGS       = JVM_ACC_FIELD_ACCESS_WATCHED |\n-                                       JVM_ACC_FIELD_MODIFICATION_WATCHED |\n-                                       JVM_ACC_FIELD_INTERNAL |\n-                                       JVM_ACC_FIELD_STABLE |\n-                                       JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE,\n-\n-                                                    \/\/ flags accepted by set_field_flags()\n-  JVM_ACC_FIELD_FLAGS                = JVM_RECOGNIZED_FIELD_MODIFIERS | JVM_ACC_FIELD_INTERNAL_FLAGS\n-\n@@ -171,10 +147,0 @@\n-  \/\/ field flags\n-  bool is_field_access_watched() const  { return (_flags & JVM_ACC_FIELD_ACCESS_WATCHED) != 0; }\n-  bool is_field_modification_watched() const\n-                                        { return (_flags & JVM_ACC_FIELD_MODIFICATION_WATCHED) != 0; }\n-  bool has_field_initialized_final_update() const\n-                                        { return (_flags & JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE) != 0; }\n-  bool is_internal() const              { return (_flags & JVM_ACC_FIELD_INTERNAL) != 0; }\n-  bool is_stable() const                { return (_flags & JVM_ACC_FIELD_STABLE) != 0; }\n-  bool field_has_generic_signature() const\n-                                        { return (_flags & JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE) != 0; }\n@@ -188,2 +154,2 @@\n-    assert((flags & JVM_ACC_FIELD_FLAGS) == flags, \"only recognized flags\");\n-    _flags = (flags & JVM_ACC_FIELD_FLAGS);\n+    assert((flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == flags, \"only recognized flags\");\n+    _flags = (flags & JVM_RECOGNIZED_FIELD_MODIFIERS);\n@@ -240,31 +206,0 @@\n-  \/\/ field flags\n-  void set_is_field_access_watched(const bool value)\n-                                       {\n-                                         if (value) {\n-                                           atomic_set_bits(JVM_ACC_FIELD_ACCESS_WATCHED);\n-                                         } else {\n-                                           atomic_clear_bits(JVM_ACC_FIELD_ACCESS_WATCHED);\n-                                         }\n-                                       }\n-  void set_is_field_modification_watched(const bool value)\n-                                       {\n-                                         if (value) {\n-                                           atomic_set_bits(JVM_ACC_FIELD_MODIFICATION_WATCHED);\n-                                         } else {\n-                                           atomic_clear_bits(JVM_ACC_FIELD_MODIFICATION_WATCHED);\n-                                         }\n-                                       }\n-\n-  void set_has_field_initialized_final_update(const bool value) {\n-    if (value) {\n-      atomic_set_bits(JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE);\n-    } else {\n-      atomic_clear_bits(JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE);\n-    }\n-  }\n-\n-  void set_field_has_generic_signature()\n-                                       {\n-                                         atomic_set_bits(JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE);\n-                                       }\n-\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":3,"deletions":68,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -259,1 +259,9 @@\n-    for (int i = 0, j = idx; j < length(); i++, j++) {\n+    remove_range(0, idx);\n+  }\n+\n+  \/\/ Remove all elements in the range [start - end). The order is preserved.\n+  void remove_range(int start, int end) {\n+    assert(0 <= start, \"illegal index\");\n+    assert(start < end && end <= _len, \"erase called with invalid range\");\n+\n+    for (int i = start, j = end; j < length(); i++, j++) {\n@@ -262,1 +270,1 @@\n-    trunc_to(length() - idx);\n+    trunc_to(length() - (end - start));\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -1692,1 +1693,1 @@\n-        boolean isObjectConstructor() { return !isPartial() && \"<init>\".equals(name); }\n+        boolean isObjectConstructor() { return !isPartial() && ConstantDescs.INIT_NAME.equals(name); }\n@@ -1694,1 +1695,1 @@\n-        boolean isValueFactoryMethod() { return !isPartial() && \"<vnew>\".equals(name); }\n+        boolean isValueFactoryMethod() { return !isPartial() && ConstantDescs.VNEW_NAME.equals(name); }\n@@ -1698,1 +1699,1 @@\n-                                        && !\"<clinit>\".equals(name); }\n+                                        && !ConstantDescs.CLASS_INIT_NAME.equals(name); }\n@@ -2217,2 +2218,2 @@\n-     * <p> The returned array never contains methods with names \"{@code <init>}\"\n-     * or \"{@code <clinit>}\".\n+     * <p> The returned array never contains methods with names {@value\n+     * ConstantDescs#INIT_NAME} or {@value ConstantDescs#CLASS_INIT_NAME}.\n@@ -2411,2 +2412,2 @@\n-     * <p> This method does not find any method with name \"{@code <init>}\" or\n-     * \"{@code <clinit>}\".\n+     * <p> This method does not find any method with name {@value\n+     * ConstantDescs#INIT_NAME} or {@value ConstantDescs#CLASS_INIT_NAME}.\n@@ -2470,1 +2471,2 @@\n-     *         or if the name is \"&lt;init&gt;\"or \"&lt;clinit&gt;\".\n+     *         or if the name is {@value ConstantDescs#INIT_NAME} or\n+     *         {@value ConstantDescs#CLASS_INIT_NAME}.\n@@ -2726,2 +2728,3 @@\n-     * has a class initialization method {@code <clinit>}, then the returned\n-     * array does <em>not<\/em> have a corresponding {@code Method} object.\n+     * has a class initialization method {@value ConstantDescs#CLASS_INIT_NAME},\n+     * then the returned array does <em>not<\/em> have a corresponding {@code\n+     * Method} object.\n@@ -2898,1 +2901,2 @@\n-     * name is \"&lt;init&gt;\"or \"&lt;clinit&gt;\" a {@code NoSuchMethodException}\n+     * name is {@value ConstantDescs#INIT_NAME} or {@value\n+     * ConstantDescs#CLASS_INIT_NAME} a {@code NoSuchMethodException}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -265,0 +265,16 @@\n+    \/**\n+     * {@link MethodHandleDesc} representing {@link MethodHandles#classData(Lookup, String, Class)} MethodHandles.classData}\n+     * @since 21\n+     *\/\n+    public static final DirectMethodHandleDesc BSM_CLASS_DATA\n+            = ofConstantBootstrap(CD_MethodHandles, \"classData\",\n+            CD_Object);\n+\n+    \/**\n+     * {@link MethodHandleDesc} representing {@link MethodHandles#classDataAt(Lookup, String, Class, int)} MethodHandles.classDataAt}\n+     * @since 21\n+     *\/\n+    public static final DirectMethodHandleDesc BSM_CLASS_DATA_AT\n+            = ofConstantBootstrap(CD_MethodHandles, \"classDataAt\",\n+            CD_Object, CD_int);\n+\n@@ -286,0 +302,36 @@\n+    \/**\n+     * The special name of instance initialization methods, {@value}. An instance\n+     * initialization method has this special name and is {@code void}.\n+     *\n+     * @jvms 2.9.1 Instance Initialization Methods\n+     * @since 21\n+     *\/\n+    public static final String INIT_NAME = \"<init>\";\n+\n+    \/**\n+     * The special name of value object factory methods, {@value}. A value\n+     * object factory method has this special name and is {@code void}.\n+     *\n+     * TODO jvms ref\n+     * @since 21\n+     *\/\n+    public static final String VNEW_NAME = \"<vnew>\";\n+\n+    \/**\n+     * The special name of class initialization methods, {@value}. A class\n+     * initialization method has this special name, {@link java.lang.reflect.AccessFlag#STATIC\n+     * ACC_STATIC} flag set, is {@link #MTD_void void} and takes no arguments.\n+     *\n+     * @jvms 2.9.2 Class Initialization Methods\n+     * @since 21\n+     *\/\n+    public static final String CLASS_INIT_NAME = \"<clinit>\";\n+\n+    \/**\n+     * Nominal descriptor representing the method descriptor {@code ()V},\n+     * taking no argument and returning {@code void}.\n+     *\n+     * @since 21\n+     *\/\n+    public static final MethodTypeDesc MTD_void = MethodTypeDesc.of(CD_void);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    private static final Set<String> pointyNames = Set.of(\"<init>\", \"<vnew>\", \"<clinit>\");\n+    private static final Set<String> pointyNames = Set.of(ConstantDescs.INIT_NAME, ConstantDescs.VNEW_NAME, ConstantDescs.CLASS_INIT_NAME);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-     * For constructors, returns the reserved name {@code \"<init>\"}.\n-     * For static value class instance factory methods, return {@code \"<vnew>\"}.\n+     * For constructors, returns the reserved name {@value ConstantDescs#INIT_NAME}.\n+     * For static value class instance factory methods, return {@value ConstantDescs#VNEW_NAME}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDesc.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -163,2 +163,4 @@\n-     * This is {@code \"<init>\"} if the underlying member was a constructor,\n-     * or {@code \"<vnew>\"} if the underlying member was a value class static\n+     * This is {@value java.lang.constant.ConstantDescs#INIT_NAME}\n+     * if the underlying member was a constructor,\n+     * or {@value java.lang.constant.ConstantDescs#VNEW_NAME}\n+     * if the underlying member was a value class static\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleInfo.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -716,1 +716,2 @@\n-     * with special names ({@code \"<init>\"}, {@code \"<vnew>\"} and {@code \"<clinit>\"}).\n+     * with special names ({@value ConstantDescs#INIT_NAME},\n+     * {@value ConstantDescs#VNEW_NAME} and {@value ConstantDescs#CLASS_INIT_NAME}).\n@@ -2778,1 +2779,1 @@\n-            String name = \"<init>\";\n+            String name = ConstantDescs.INIT_NAME;\n@@ -2974,1 +2975,2 @@\n-         * <em>(Note:  JVM internal methods named {@code \"<init>\"} are not visible to this API,\n+         * <em>(Note:  JVM internal methods named {@value ConstantDescs#INIT_NAME}\n+         * are not visible to this API,\n@@ -4034,1 +4036,1 @@\n-                assert(!method.getName().equals(\"<init>\"));  \/\/ not this code path\n+                assert(!method.getName().equals(ConstantDescs.INIT_NAME));  \/\/ not this code path\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.misc.VM;\n@@ -64,1 +63,1 @@\n-    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n+    private static final int CLASSFILE_VERSION = ClassFileFormatVersion.latest().major();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -198,1 +198,2 @@\n-        jdk.jartool;\n+        jdk.jartool,\n+        jdk.jlink;\n@@ -200,1 +201,2 @@\n-        jdk.jartool;\n+        jdk.jartool,\n+        jdk.jlink;\n@@ -202,0 +204,1 @@\n+        jdk.jlink,\n@@ -204,2 +207,1 @@\n-        jdk.jfr,\n-        jdk.jlink;\n+        jdk.jfr;\n@@ -207,2 +209,1 @@\n-        jdk.jfr,\n-        jdk.jlink;\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -201,0 +201,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -314,0 +315,5 @@\n+        \/**\n+         * Warn about possible 'this' escapes before subclass instance is fully initialized.\n+         *\/\n+        THIS_ESCAPE(\"this-escape\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1040,0 +1040,1 @@\n+        @SuppressWarnings(\"this-escape\")\n@@ -1193,0 +1194,1 @@\n+        @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -408,0 +408,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.function.Function;\n@@ -186,2 +187,1 @@\n-        return getMetadata(TypeMetadata.ConstantValue.class)\n-                .map(ConstantValue::value).orElse(null);\n+        return getMetadata(TypeMetadata.ConstantValue.class, ConstantValue::value, null);\n@@ -434,5 +434,17 @@\n-    public <M extends TypeMetadata> Optional<M> getMetadata(Class<M> metadataClass) {\n-        return metadata.stream()\n-                .filter(m -> metadataClass.isAssignableFrom(m.getClass()))\n-                .map(metadataClass::cast)\n-                .findFirst();\n+    @SuppressWarnings(\"unchecked\")\n+    public <M extends TypeMetadata> M getMetadata(Class<M> metadataClass) {\n+        return getMetadata(metadataClass, Function.identity(), null);\n+    }\n+\n+    \/**\n+     * Get the type metadata of the given kind associated with this type (if any),\n+     * and apply the provided mapping function.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public <M extends TypeMetadata, Z> Z getMetadata(Class<M> metadataClass, Function<M, Z> metadataFunc, Z defaultValue) {\n+        for (TypeMetadata m : metadata) {\n+            if (m.getClass() == metadataClass) {\n+                return metadataFunc.apply((M)m);\n+            }\n+        }\n+        return defaultValue;\n@@ -447,2 +459,2 @@\n-        Assert.check(getMetadata(md.getClass()).isEmpty());\n-        return cloneWithMetadata(metadata.append(md));\n+        Assert.check(getMetadata(md.getClass()) == null);\n+        return cloneWithMetadata(metadata.prepend(md));\n@@ -455,3 +467,6 @@\n-        List<TypeMetadata> newMetadata = metadata.stream()\n-                .filter(m -> !metadataClass.isAssignableFrom(m.getClass()))\n-                .collect(List.collector());\n+        List<TypeMetadata> newMetadata = List.nil();\n+        for (TypeMetadata m : metadata) {\n+            if (m.getClass() != metadataClass) {\n+                newMetadata = newMetadata.prepend(m);\n+            }\n+        }\n@@ -515,1 +530,1 @@\n-        return getMetadata(TypeMetadata.Annotations.class).isPresent();\n+        return getMetadata(TypeMetadata.Annotations.class) != null;\n@@ -520,2 +535,1 @@\n-        return getMetadata(TypeMetadata.Annotations.class)\n-                .map(Annotations::annotations).orElse(List.nil());\n+        return getMetadata(TypeMetadata.Annotations.class, Annotations::annotations, List.nil());\n@@ -1941,0 +1955,1 @@\n+        @SuppressWarnings(\"this-escape\")\n@@ -1953,0 +1968,1 @@\n+        @SuppressWarnings(\"this-escape\")\n@@ -2029,0 +2045,1 @@\n+        @SuppressWarnings(\"this-escape\")\n@@ -2262,0 +2279,1 @@\n+        @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+        new ThisEscapeAnalyzer(names, syms, types, log, lint).analyzeTree(env);\n@@ -329,0 +330,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -1439,1 +1440,1 @@\n-            List<JCVariableDecl> params = make.Params(constructorType().getParameterTypes(), constructorSymbol());\n+            List<JCVariableDecl> params = make.Params(constructorSymbol());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -270,0 +270,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-        if (instance == null)\n+        if (instance == null) {\n@@ -114,0 +114,2 @@\n+            context.put(transValueClass, instance);\n+        }\n@@ -118,1 +120,0 @@\n-        context.put(transValueClass, this);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -374,0 +374,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -671,0 +671,6 @@\n+compiler.warn.possible.this.escape=\\\n+    possible ''this'' escape before subclass is fully initialized\n+\n+compiler.warn.possible.this.escape.location=\\\n+    previous possible ''this'' escape happens here via invocation\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -264,0 +264,4 @@\n+javac.opt.Xlint.desc.this-escape=\\\n+    Warn when a constructor invokes a method that could be overriden in an external subclass.\\n\\\n+\\                         Such a method would execute before the subclass constructor completes its initialization.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -1065,1 +1066,1 @@\n-                Params(mtype.getParameterTypes(), m),\n+                m.params != null ? Params(m) : Params(m, mtype.getParameterTypes()),\n@@ -1094,2 +1095,2 @@\n-    \/** Create a list of value parameter trees x0, ..., xn from a list of\n-     *  their types and their owner.\n+    \/** Create a list of value parameter trees for a method's parameters\n+     *  using the same names as the method's existing parameters.\n@@ -1097,1 +1098,2 @@\n-    public List<JCVariableDecl> Params(List<Type> argtypes, Symbol owner) {\n+    public List<JCVariableDecl> Params(MethodSymbol mth) {\n+        Assert.check(mth.params != null);\n@@ -1099,9 +1101,15 @@\n-        MethodSymbol mth = (owner.kind == MTH) ? ((MethodSymbol)owner) : null;\n-        if (mth != null && mth.params != null && argtypes.length() == mth.params.length()) {\n-            for (VarSymbol param : ((MethodSymbol)owner).params)\n-                params.append(VarDef(param, null));\n-        } else {\n-            int i = 0;\n-            for (List<Type> l = argtypes; l.nonEmpty(); l = l.tail)\n-                params.append(Param(paramName(i++), l.head, owner));\n-        }\n+        for (VarSymbol param : mth.params)\n+            params.append(VarDef(param, null));\n+        return params.toList();\n+    }\n+\n+    \/** Synthesize a list of parameter trees for a method's parameters.\n+     *  Used for methods with no parameters defined, e.g. bridge methods.\n+     *  The placeholder names will be x0, x1, ..., xn.\n+     *\/\n+    public List<JCVariableDecl> Params(MethodSymbol mth, List<Type> argtypes) {\n+        Assert.check(mth.params == null);\n+        ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        int i = 0;\n+        for (List<Type> l = argtypes; l.nonEmpty(); l = l.tail)\n+            params.append(Param(paramName(i++), l.head, mth));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -240,0 +240,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-            short nameIndex    = klass.getFieldNameIndex(index);\n+            int nameIndex = klass.getFieldNameIndex(index);\n@@ -384,1 +384,1 @@\n-            short signatureIndex = klass.getFieldSignatureIndex(index);\n+            int signatureIndex = klass.getFieldSignatureIndex(index);\n@@ -393,1 +393,1 @@\n-            short initvalIndex = klass.getFieldInitialValueIndex(index);\n+            int initvalIndex = klass.getFieldInitialValueIndex(index);\n@@ -397,1 +397,1 @@\n-            short genSigIndex = klass.getFieldGenericSignatureIndex(index);\n+            int genSigIndex = klass.getFieldGenericSignatureIndex(index);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    final int instanceKlassFieldsOffset = getFieldOffset(\"InstanceKlass::_fields\", Integer.class, \"Array<u2>*\");\n+    final int instanceKlassFieldInfoStreamOffset = getFieldOffset(\"InstanceKlass::_fieldinfo_stream\", Integer.class, \"Array<u1>*\");\n@@ -119,13 +119,2 @@\n-    final int fieldInfoAccessFlagsOffset = getConstant(\"FieldInfo::access_flags_offset\", Integer.class);\n-    final int fieldInfoNameIndexOffset = getConstant(\"FieldInfo::name_index_offset\", Integer.class);\n-    final int fieldInfoSignatureIndexOffset = getConstant(\"FieldInfo::signature_index_offset\", Integer.class);\n-    final int fieldInfoConstantValueIndexOffset = getConstant(\"FieldInfo::initval_index_offset\", Integer.class);\n-    final int fieldInfoLowPackedOffset = getConstant(\"FieldInfo::low_packed_offset\", Integer.class);\n-    final int fieldInfoHighPackedOffset = getConstant(\"FieldInfo::high_packed_offset\", Integer.class);\n-    final int fieldInfoFieldSlots = getConstant(\"FieldInfo::field_slots\", Integer.class);\n-\n-    final int fieldInfoTagSize = getConstant(\"FIELDINFO_TAG_SIZE\", Integer.class);\n-\n-    final int jvmAccFieldInternal = getConstant(\"JVM_ACC_FIELD_INTERNAL\", Integer.class);\n-    final int jvmAccFieldStable = getConstant(\"JVM_ACC_FIELD_STABLE\", Integer.class);\n-    final int jvmAccFieldHasGenericSignature = getConstant(\"JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE\", Integer.class);\n+    final int jvmFieldFlagInternalShift = getConstant(\"FieldInfo::FieldFlags::_ff_injected\", Integer.class);\n+    final int jvmFieldFlagStableShift = getConstant(\"FieldInfo::FieldFlags::_ff_stable\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+compiler\/sharedstubs\/SharedStubToInterpTest.java 8304681 generic-all\n+\n@@ -103,0 +105,1 @@\n+runtime\/StackGuardPages\/TestStackGuardPagesNative.java 8303612 linux-all\n@@ -129,1 +132,0 @@\n-serviceability\/sa\/UniqueVtableTest.java 8303921 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -540,2 +540,0 @@\n-java\/net\/SocketOption\/OptionsTest.java                          8304286 windows-all\n-\n@@ -743,1 +741,0 @@\n-javax\/script\/Test7.java                                         8239361 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}