{"files":[{"patch":"@@ -42,1 +42,0 @@\n-define_pd_global(intx, InlineFrequencyCount,     100);\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-define_pd_global(intx,  InlineFrequencyCount,  100);\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-define_pd_global(intx, InlineFrequencyCount,     100);\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-define_pd_global(intx,  InlineFrequencyCount, 100);\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-    uintx FLAG_MASK = 0x03; \/\/ See comments around MetaspaceClosure::FLAG_MASK\n@@ -122,3 +121,1 @@\n-    uintx old_p_and_bits = (uintx)(*ptr_loc);\n-    uintx flag_bits = (old_p_and_bits & FLAG_MASK);\n-    address old_p = (address)(old_p_and_bits & (~FLAG_MASK));\n+    address old_p = *ptr_loc;\n@@ -126,1 +123,0 @@\n-    uintx new_p_and_bits = ((uintx)new_p) | flag_bits;\n@@ -131,1 +127,1 @@\n-    ArchivePtrMarker::set_and_mark_pointer(ptr_loc, (address)(new_p_and_bits));\n+    ArchivePtrMarker::set_and_mark_pointer(ptr_loc, new_p);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-  _metaspace_lock(new Mutex(Mutex::leaf+1, \"Metaspace allocation lock\", true,\n+  _metaspace_lock(new Mutex(Mutex::leaf+1, \"Metaspace allocation lock\",\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -55,0 +57,1 @@\n+                                           PreservedMarks* preserved_marks,\n@@ -82,1 +85,3 @@\n-    _obj_alloc_stat(NULL)\n+    _obj_alloc_stat(NULL),\n+    _preserved_marks(preserved_marks),\n+    _evacuation_failed_info()\n@@ -111,0 +116,4 @@\n+  if (_evacuation_failed_info.has_failed()) {\n+     _g1h->gc_tracer_stw()->report_evacuation_failed(_evacuation_failed_info);\n+  }\n+\n@@ -372,3 +381,3 @@\n-    _g1h->_gc_tracer_stw->report_promotion_in_new_plab_event(old->klass(), word_sz * HeapWordSize, age,\n-                                                             dest_attr.type() == G1HeapRegionAttr::Old,\n-                                                             alloc_buf->word_sz() * HeapWordSize);\n+    _g1h->gc_tracer_stw()->report_promotion_in_new_plab_event(old->klass(), word_sz * HeapWordSize, age,\n+                                                              dest_attr.type() == G1HeapRegionAttr::Old,\n+                                                              alloc_buf->word_sz() * HeapWordSize);\n@@ -376,2 +385,2 @@\n-    _g1h->_gc_tracer_stw->report_promotion_outside_plab_event(old->klass(), word_sz * HeapWordSize, age,\n-                                                              dest_attr.type() == G1HeapRegionAttr::Old);\n+    _g1h->gc_tracer_stw()->report_promotion_outside_plab_event(old->klass(), word_sz * HeapWordSize, age,\n+                                                               dest_attr.type() == G1HeapRegionAttr::Old);\n@@ -404,1 +413,1 @@\n-    if (_g1h->_gc_tracer_stw->should_report_promotion_events()) {\n+    if (_g1h->gc_tracer_stw()->should_report_promotion_events()) {\n@@ -448,1 +457,1 @@\n-      return handle_evacuation_failure_par(old, old_mark);\n+      return handle_evacuation_failure_par(old, old_mark, word_sz);\n@@ -455,2 +464,1 @@\n-#ifndef PRODUCT\n-  if (_g1h->evacuation_should_fail()) {\n+  if (_g1h->evac_failure_injector()->evacuation_should_fail()) {\n@@ -461,1 +469,1 @@\n-    return handle_evacuation_failure_par(old, old_mark);\n+    return handle_evacuation_failure_par(old, old_mark, word_sz);\n@@ -463,1 +471,0 @@\n-#endif \/\/ !PRODUCT\n@@ -535,1 +542,2 @@\n-      new G1ParScanThreadState(_g1h, _rdcqs,\n+      new G1ParScanThreadState(_g1h, rdcqs(),\n+                               _preserved_marks_set->get(worker_id),\n@@ -583,1 +591,1 @@\n-oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m) {\n+oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, size_t word_sz) {\n@@ -595,1 +603,2 @@\n-    _g1h->preserve_mark_during_evac_failure(_worker_id, old, m);\n+    _preserved_marks->push_if_necessary(old, m);\n+    _evacuation_failed_info.register_copy_failure(word_sz);\n@@ -641,0 +650,1 @@\n+                                                 PreservedMarksSet* preserved_marks_set,\n@@ -646,0 +656,1 @@\n+    _preserved_marks_set(preserved_marks_set),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-                                       Mutex::_allow_vm_block_flag, Monitor::_safepoint_check_never);\n+                                       Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -253,1 +253,1 @@\n-      _mutex(Mutex::leaf, \"Parallel heap iteration data merge lock\") {}\n+      _mutex(Mutex::leaf, \"Parallel heap iteration data merge lock\", Mutex::_safepoint_check_always) {}\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,4 +135,1 @@\n-      \/\/ In some rare cases we store some flags in the lowest 2 bits of a\n-      \/\/ MetaspaceObj pointer. Unmask these when manipulating the pointer.\n-      uintx p = (uintx)*mpp();\n-      return (address)(p & (~FLAG_MASK));\n+      return *addr();\n@@ -154,8 +151,0 @@\n-\n-  private:\n-    static const uintx FLAG_MASK = 0x03;\n-\n-    int flag_bits() const {\n-      uintx p = (uintx)*mpp();\n-      return (int)(p & FLAG_MASK);\n-    }\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1253,1 +1253,1 @@\n-    _extra_data_lock(Mutex::leaf, \"MDO extra data lock\"),\n+    _extra_data_lock(Mutex::leaf, \"MDO extra data lock\", Mutex::_safepoint_check_always),\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  int freq = call_site_count \/ invoke_count;\n+  double freq = (double)call_site_count \/ (double)invoke_count;\n@@ -163,1 +163,0 @@\n-      (call_site_count >= InlineFrequencyCount) ||\n@@ -170,1 +169,1 @@\n-      tty->print_cr(\"Inlined frequent method (freq=%d count=%d):\", freq, call_site_count);\n+      tty->print_cr(\"Inlined frequent method (freq=%lf):\", freq);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-  GrowableArray<Node*> storestore_worklist;\n-  GrowableArray<ArrayCopyNode*> arraycopy_worklist;\n+  GrowableArray<MemBarStoreStoreNode*> storestore_worklist;\n+  GrowableArray<ArrayCopyNode*>  arraycopy_worklist;\n@@ -130,0 +130,1 @@\n+  GrowableArray<MergeMemNode*>   mergemem_worklist;\n@@ -175,16 +176,25 @@\n-    if (n->is_MergeMem()) {\n-      \/\/ Collect all MergeMem nodes to add memory slices for\n-      \/\/ scalar replaceable objects in split_unique_types().\n-      _mergemem_worklist.append(n->as_MergeMem());\n-    } else if (OptimizePtrCompare && n->is_Cmp() &&\n-               (n->Opcode() == Op_CmpP || n->Opcode() == Op_CmpN)) {\n-      \/\/ Collect compare pointers nodes.\n-      ptr_cmp_worklist.append(n);\n-    } else if (n->is_MemBarStoreStore()) {\n-      \/\/ Collect all MemBarStoreStore nodes so that depending on the\n-      \/\/ escape status of the associated Allocate node some of them\n-      \/\/ may be eliminated.\n-      storestore_worklist.append(n);\n-    } else if (n->is_MemBar() && (n->Opcode() == Op_MemBarRelease) &&\n-               (n->req() > MemBarNode::Precedent)) {\n-      record_for_optimizer(n);\n+    \/\/ Collect some interesting nodes for futher use.\n+    switch (n->Opcode()) {\n+      case Op_MergeMem:\n+        \/\/ Collect all MergeMem nodes to add memory slices for\n+        \/\/ scalar replaceable objects in split_unique_types().\n+        mergemem_worklist.append(n->as_MergeMem());\n+        break;\n+      case Op_CmpP:\n+      case Op_CmpN:\n+        \/\/ Collect compare pointers nodes.\n+        if (OptimizePtrCompare) {\n+          ptr_cmp_worklist.append(n);\n+        }\n+        break;\n+      case Op_MemBarStoreStore:\n+        \/\/ Collect all MemBarStoreStore nodes so that depending on the\n+        \/\/ escape status of the associated Allocate node some of them\n+        \/\/ may be eliminated.\n+        storestore_worklist.append(n->as_MemBarStoreStore());\n+        break;\n+      case Op_MemBarRelease:\n+        if (n->req() > MemBarNode::Precedent) {\n+          record_for_optimizer(n);\n+        }\n+        break;\n@@ -192,3 +202,4 @@\n-    } else if (n->is_AddP()) {\n-      \/\/ Collect address nodes for graph verification.\n-      addp_worklist.append(n);\n+      case Op_AddP:\n+        \/\/ Collect address nodes for graph verification.\n+        addp_worklist.append(n);\n+        break;\n@@ -196,4 +207,8 @@\n-    } else if (n->is_ArrayCopy()) {\n-      \/\/ Keep a list of ArrayCopy nodes so if one of its input is non\n-      \/\/ escaping, we can record a unique type\n-      arraycopy_worklist.append(n->as_ArrayCopy());\n+      case Op_ArrayCopy:\n+        \/\/ Keep a list of ArrayCopy nodes so if one of its input is non\n+        \/\/ escaping, we can record a unique type\n+        arraycopy_worklist.append(n->as_ArrayCopy());\n+        break;\n+      default:\n+        \/\/ not interested now, ignore...\n+        break;\n@@ -205,1 +220,1 @@\n-    if (n-> is_SafePoint()) {\n+    if (n->is_SafePoint()) {\n@@ -316,1 +331,1 @@\n-    split_unique_types(alloc_worklist, arraycopy_worklist);\n+    split_unique_types(alloc_worklist, arraycopy_worklist, mergemem_worklist);\n@@ -526,2 +541,1 @@\n-      add_local_var_and_edge(n, PointsToNode::NoEscape,\n-                             n->in(1), delayed_worklist);\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), delayed_worklist);\n@@ -596,2 +610,1 @@\n-        add_local_var_and_edge(n, PointsToNode::NoEscape,\n-                               n->in(0), delayed_worklist);\n+        add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), delayed_worklist);\n@@ -606,2 +619,1 @@\n-        add_local_var_and_edge(n, PointsToNode::GlobalEscape,\n-                               n->in(TypeFunc::Parms), delayed_worklist);\n+        add_local_var_and_edge(n, PointsToNode::GlobalEscape, n->in(TypeFunc::Parms), delayed_worklist);\n@@ -652,11 +664,0 @@\n-#ifdef ASSERT\n-#define ELSE_FAIL(name)                               \\\n-      \/* Should not be called for not pointer type. *\/  \\\n-      n->dump(1);                                       \\\n-      assert(false, name);                              \\\n-      break;\n-#else\n-#define ELSE_FAIL(name) \\\n-      break;\n-#endif\n-\n@@ -698,2 +699,1 @@\n-      add_local_var_and_edge(n, PointsToNode::NoEscape,\n-                             n->in(1), NULL);\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), NULL);\n@@ -723,7 +723,3 @@\n-      const Type* t = _igvn->type(n);\n-      if (t->make_ptr() != NULL) {\n-        Node* adr = n->in(MemNode::Address);\n-        add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);\n-        break;\n-      }\n-      ELSE_FAIL(\"Op_LoadP\");\n+      assert(_igvn->type(n)->make_ptr() != NULL, \"Unexpected node type\");\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(MemNode::Address), NULL);\n+      break;\n@@ -734,14 +730,5 @@\n-      const Type* t = n->as_Phi()->type();\n-      if (t->make_ptr() != NULL) {\n-        for (uint i = 1; i < n->req(); i++) {\n-          Node* in = n->in(i);\n-          if (in == NULL) {\n-            continue;  \/\/ ignore NULL\n-          }\n-          Node* uncast_in = in->uncast();\n-          if (uncast_in->is_top() || uncast_in == n) {\n-            continue;  \/\/ ignore top or inputs which go back this node\n-          }\n-          PointsToNode* ptn = ptnode_adr(in->_idx);\n-          assert(ptn != NULL, \"node should be registered\");\n-          add_edge(n_ptn, ptn);\n+      assert(n->as_Phi()->type()->make_ptr() != NULL, \"Unexpected node type\");\n+      for (uint i = 1; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in == NULL) {\n+          continue;  \/\/ ignore NULL\n@@ -749,1 +736,7 @@\n-        break;\n+        Node* uncast_in = in->uncast();\n+        if (uncast_in->is_top() || uncast_in == n) {\n+          continue;  \/\/ ignore top or inputs which go back this node\n+        }\n+        PointsToNode* ptn = ptnode_adr(in->_idx);\n+        assert(ptn != NULL, \"node should be registered\");\n+        add_edge(n_ptn, ptn);\n@@ -751,1 +744,1 @@\n-      ELSE_FAIL(\"Op_Phi\");\n+      break;\n@@ -755,8 +748,4 @@\n-      if (n->as_Proj()->_con >= TypeFunc::Parms && n->in(0)->is_Call() &&\n-          (n->in(0)->as_Call()->returns_pointer()|| n->bottom_type()->isa_ptr())) {\n-        assert((n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->as_Call()->returns_pointer()) ||\n-               n->in(0)->as_Call()->tf()->returns_inline_type_as_fields(), \"what kind of oop return is it?\");\n-        add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), NULL);\n-        break;\n-      }\n-      ELSE_FAIL(\"Op_Proj\");\n+      assert((n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->as_Call()->returns_pointer()) ||\n+             n->in(0)->as_Call()->tf()->returns_inline_type_as_fields(), \"what kind of oop return is it?\");\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), NULL);\n+      break;\n@@ -766,8 +755,5 @@\n-      if (n->req() > TypeFunc::Parms &&\n-          _igvn->type(n->in(TypeFunc::Parms))->isa_oopptr()) {\n-        \/\/ Treat Return value as LocalVar with GlobalEscape escape state.\n-        add_local_var_and_edge(n, PointsToNode::GlobalEscape,\n-                               n->in(TypeFunc::Parms), NULL);\n-        break;\n-      }\n-      ELSE_FAIL(\"Op_Return\");\n+      assert(n->req() > TypeFunc::Parms && _igvn->type(n->in(TypeFunc::Parms))->isa_oopptr(),\n+             \"Unexpected node type\");\n+      \/\/ Treat Return value as LocalVar with GlobalEscape escape state.\n+      add_local_var_and_edge(n, PointsToNode::GlobalEscape, n->in(TypeFunc::Parms), NULL);\n+      break;\n@@ -775,4 +761,0 @@\n-    case Op_StoreP:\n-    case Op_StoreN:\n-    case Op_StoreNKlass:\n-    case Op_StorePConditional:\n@@ -781,0 +763,6 @@\n+    case Op_GetAndSetP:\n+    case Op_GetAndSetN:{\n+      assert(_igvn->type(n)->make_ptr() != NULL, \"Unexpected node type\");\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(MemNode::Address), NULL);\n+      \/\/ fall-through\n+    }\n@@ -785,6 +773,6 @@\n-    case Op_GetAndSetP:\n-    case Op_GetAndSetN: {\n-      if (add_final_edges_unsafe_access(n, opcode)) {\n-        break;\n-      }\n-      ELSE_FAIL(\"Op_StoreP\");\n+    case Op_StoreP:\n+    case Op_StoreN:\n+    case Op_StoreNKlass:\n+    case Op_StorePConditional:{\n+      add_final_edges_unsafe_access(n, opcode);\n+      break;\n@@ -881,5 +869,0 @@\n-  if (opcode == Op_GetAndSetP || opcode == Op_GetAndSetN ||\n-      opcode == Op_CompareAndExchangeN || opcode == Op_CompareAndExchangeP) {\n-    add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);\n-  }\n-\n@@ -914,0 +897,4 @@\n+#ifdef ASSERT\n+  n->dump(1);\n+  assert(false, \"not unsafe\");\n+#endif\n@@ -2020,1 +2007,1 @@\n-                                           GrowableArray<Node*>& storestore_worklist) {\n+                                           GrowableArray<MemBarStoreStoreNode*>& storestore_worklist) {\n@@ -2072,1 +2059,0 @@\n-    assert(storestore->is_MemBarStoreStore(), \"\");\n@@ -2092,0 +2078,1 @@\n+  assert(n->Opcode() == Op_CmpN || n->Opcode() == Op_CmpP, \"must be\");\n@@ -3147,1 +3134,3 @@\n-void ConnectionGraph::split_unique_types(GrowableArray<Node *>  &alloc_worklist, GrowableArray<ArrayCopyNode*> &arraycopy_worklist) {\n+void ConnectionGraph::split_unique_types(GrowableArray<Node *>  &alloc_worklist,\n+                                         GrowableArray<ArrayCopyNode*> &arraycopy_worklist,\n+                                         GrowableArray<MergeMemNode*> &mergemem_worklist) {\n@@ -3393,1 +3382,1 @@\n-        assert(_mergemem_worklist.contains(use->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n+        assert(mergemem_worklist.contains(use->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n@@ -3399,1 +3388,1 @@\n-          assert(_mergemem_worklist.contains(m->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n+          assert(mergemem_worklist.contains(m->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n@@ -3538,1 +3527,1 @@\n-        assert(_mergemem_worklist.contains(use->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n+        assert(mergemem_worklist.contains(use->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n@@ -3570,1 +3559,1 @@\n-  uint length = _mergemem_worklist.length();\n+  uint length = mergemem_worklist.length();\n@@ -3572,1 +3561,1 @@\n-    MergeMemNode* nmm = _mergemem_worklist.at(next);\n+    MergeMemNode* nmm = mergemem_worklist.at(next);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":97,"deletions":108,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -537,0 +537,1 @@\n+  { \"InlineFrequencyCount\",         JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1421,1 +1421,1 @@\n-  develop(intx, InlineFrequencyRatio,    20,                                \\\n+  product(double, InlineFrequencyRatio, 0.25, DIAGNOSTIC,                   \\\n@@ -1423,6 +1423,0 @@\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product_pd(intx, InlineFrequencyCount, DIAGNOSTIC,                        \\\n-          \"Count of call site execution necessary to trigger frequent \"     \\\n-          \"inlining\")                                                       \\\n-          range(0, max_jint)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -371,2 +371,1 @@\n-  Monitor timer(Mutex::leaf, \"VM_Exit timer\", true,\n-                Monitor::_safepoint_check_never);\n+  Monitor timer(Mutex::leaf, \"VM_Exit timer\", Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -324,2 +326,2 @@\n-     *                     components. Maybe be null, if the {@code methodName}\n-     *                     is {@code \"equals\"} or {@code \"hashCode\"}.\n+     *                     components. This parameter is ignored if the {@code methodName}\n+     *                     parameter is {@code \"equals\"} or {@code \"hashCode\"}\n@@ -331,0 +333,3 @@\n+     * @throws NullPointerException if any argument but {@code lookup} is {@code null},\n+     *                              in the case of the {@code getters} argument, its\n+     *                              contents cannot be {@code null} either\n@@ -337,2 +342,6 @@\n-        Objects.requireNonNull(type);\n-        Objects.requireNonNull(recordClass);\n+        requireNonNull(methodName);\n+        requireNonNull(type);\n+        requireNonNull(recordClass);\n+        requireNonNull(names);\n+        requireNonNull(getters);\n+        Arrays.stream(getters).forEach(Objects::requireNonNull);\n@@ -342,3 +351,3 @@\n-        if (type instanceof MethodType) {\n-            methodType = (MethodType) type;\n-            if (((MethodType) type).parameterType(0) != receiverType) {\n+        if (type instanceof MethodType mt) {\n+            methodType = mt;\n+            if (methodType.parameterType(0) != receiverType) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -633,1 +633,4 @@\n-                    if (pt == Type.recoveryType) {\n+                    boolean needsReport = pt == Type.recoveryType ||\n+                            (details.getDiagnosticPosition() != null &&\n+                            details.getDiagnosticPosition().getTree().hasTag(LAMBDA));\n+                    if (needsReport) {\n@@ -4317,7 +4320,2 @@\n-        \/\/ (1) Also find the environment current for the class where\n-        \/\/     sym is defined (`symEnv').\n-        \/\/ Only for pre-tiger versions (1.4 and earlier):\n-        \/\/ (2) Also determine whether we access symbol out of an anonymous\n-        \/\/     class in a this or super call.  This is illegal for instance\n-        \/\/     members since such classes don't carry a this$n link.\n-        \/\/     (`noOuterThisPath').\n+        \/\/ Also find the environment current for the class where\n+        \/\/ sym is defined (`symEnv').\n@@ -4325,1 +4323,0 @@\n-        boolean noOuterThisPath = false;\n@@ -4334,2 +4331,0 @@\n-                if ((symEnv.enclClass.sym.flags() & NOOUTERTHIS) != 0)\n-                    noOuterThisPath = false;\n@@ -4357,1 +4352,1 @@\n-        if ((symEnv.info.isSelfCall || noOuterThisPath) &&\n+        if (symEnv.info.isSelfCall &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8262386 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  :tier1_gc_epsilon \\\n@@ -223,1 +224,0 @@\n-  :gc_epsilon \\\n@@ -229,1 +229,1 @@\n-  -:gc_epsilon \\\n+  -gc\/CriticalNativeArgs.java \\\n@@ -234,0 +234,1 @@\n+  -gc\/epsilon \\\n@@ -236,2 +237,8 @@\n-gc_epsilon = \\\n-  gc\/epsilon\/ \\\n+hotspot_gc_epsilon = \\\n+  :tier1_gc_epsilon \\\n+  :tier2_gc_epsilon\n+\n+tier1_gc_epsilon = \\\n+  gc\/epsilon\/\n+\n+tier2_gc_epsilon = \\\n@@ -256,2 +263,1 @@\n-  gc\/shenandoah\/oom\/ \\\n-  gc\/CriticalNativeArgs.java\n+  gc\/shenandoah\/oom\/\n@@ -279,0 +285,2 @@\n+  gc\/CriticalNativeArgs.java \\\n+  gc\/stress\/CriticalNativeStress.java \\\n@@ -281,1 +289,0 @@\n-  -gc\/stress\/CriticalNativeStress.java \\\n@@ -290,1 +297,0 @@\n-  gc\/stress\/CriticalNativeStress.java \\\n@@ -315,0 +321,2 @@\n+ -runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT1.java \\\n+ -runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT2.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.List;\n@@ -106,1 +107,1 @@\n-        CallSite cs = (CallSite)ObjectMethods.bootstrap(LOOKUP, \"hashCode\", C.HASHCODE_DESC, C.class, null, C.ACCESSORS);\n+        CallSite cs = (CallSite)ObjectMethods.bootstrap(LOOKUP, \"hashCode\", C.HASHCODE_DESC, C.class, \"x;y\", C.ACCESSORS);\n@@ -154,10 +155,0 @@\n-        assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, \"toString\", C.TO_STRING_DESC, C.class, \"x;y\", null)       );\n-        assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, \"toString\", C.TO_STRING_DESC, C.class, null,  C.ACCESSORS));\n-        assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, \"toString\", C.TO_STRING_DESC, null,    \"x;y\", C.ACCESSORS));\n-        assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, \"equals\",   C.EQUALS_DESC,    null,    \"x;y\", C.ACCESSORS));\n-        assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, \"hashCode\", C.HASHCODE_DESC,  null,    \"x;y\", C.ACCESSORS));\n-\n-        assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, \"toString\", null,             C.class, \"x;y\", C.ACCESSORS));\n-        assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, null,       C.TO_STRING_DESC, C.class, \"x;y\", C.ACCESSORS));\n-      \/\/assertThrows(NPE, () -> ObjectMethods.bootstrap(null,   \"toString\", C.TO_STRING_DESC, C.class, \"x;y\", C.ACCESSORS));\n-\n@@ -170,0 +161,15 @@\n+        record NamePlusType(String mn, MethodType mt) {}\n+        List<NamePlusType> namePlusTypeList = List.of(\n+                new NamePlusType(\"toString\", C.TO_STRING_DESC),\n+                new NamePlusType(\"equals\", C.EQUALS_DESC),\n+                new NamePlusType(\"hashCode\", C.HASHCODE_DESC)\n+        );\n+\n+        for (NamePlusType npt : namePlusTypeList) {\n+            assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, npt.mn(), npt.mt(), C.class, \"x;y\", null));\n+            assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, npt.mn(), npt.mt(), C.class, \"x;y\", new MethodHandle[]{null}));\n+            assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, npt.mn(), npt.mt(), C.class, null,  C.ACCESSORS));\n+            assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, npt.mn(), npt.mt(), null,    \"x;y\", C.ACCESSORS));\n+            assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, npt.mn(), null,     C.class, \"x;y\", C.ACCESSORS));\n+            assertThrows(NPE, () -> ObjectMethods.bootstrap(LOOKUP, null,     npt.mt(), C.class, \"x;y\", C.ACCESSORS));\n+        }\n","filename":"test\/jdk\/java\/lang\/runtime\/ObjectMethodsTest.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"}]}