{"files":[{"patch":"@@ -164,1 +164,2 @@\n-  assert(unswitch_iff != NULL && unswitch_iffs.size() > 0, \"should be at least one\");\n+  assert(unswitch_iff != NULL && unswitch_iff == unswitch_iffs.at(0), \"should be at least one\");\n+  bool flat_array_checks = unswitch_iffs.size() > 1;\n@@ -182,1 +183,3 @@\n-  ProjNode* proj_true = create_slow_version_of_loop(loop, old_new, unswitch_iff->Opcode(), CloneIncludesStripMined);\n+  IfNode* invar_iff = create_slow_version_of_loop(loop, old_new, unswitch_iffs, CloneIncludesStripMined);\n+  ProjNode* proj_true = invar_iff->proj_out(1);\n+  ProjNode* proj_false = invar_iff->proj_out(0);\n@@ -218,33 +221,0 @@\n-  \/\/ TODO: reimplement JDK-8267151, dropped from jdk->lworld merge\n-\n-  \/\/ Add test to new \"if\" outside of loop\n-  IfNode* invar_iff   = proj_true->in(0)->as_If();\n-  Node* invar_iff_c   = invar_iff->in(0);\n-  invar_iff->_prob    = unswitch_iff->_prob;\n-  BoolNode* bol       = unswitch_iff->in(1)->as_Bool();\n-  bool flat_array_checks = unswitch_iffs.size() > 1;\n-  if (flat_array_checks) {\n-    \/\/ Flattened array checks are used on array access to switch between\n-    \/\/ a legacy object array access and a flattened inline type array\n-    \/\/ access. We want the performance impact on legacy accesses to be\n-    \/\/ as small as possible so we make two copies of the loop: a fast\n-    \/\/ one where all accesses are known to be legacy, a slow one where\n-    \/\/ some accesses are to flattened arrays. Flattened array checks\n-    \/\/ can be removed from the fast loop (true proj) but not from the\n-    \/\/ slow loop (false proj) as it can have a mix of flattened\/legacy accesses.\n-    assert(bol->_test._test == BoolTest::ne, \"IfTrue proj must point to flat array\");\n-    bol = bol->clone()->as_Bool();\n-    register_new_node(bol, invar_iff_c);\n-    FlatArrayCheckNode* cmp = bol->in(1)->clone()->as_FlatArrayCheck();\n-    register_new_node(cmp, invar_iff_c);\n-    bol->set_req(1, cmp);\n-    \/\/ Combine all checks into a single one that fails if one array is flattened\n-    assert(cmp->req() == 3, \"unexpected number of inputs for FlatArrayCheck\");\n-    cmp->add_req_batch(C->top(), unswitch_iffs.size() - 1);\n-    for (uint i = 0; i < unswitch_iffs.size(); i++) {\n-      Node* array = unswitch_iffs.at(i)->in(1)->in(1)->in(FlatArrayCheckNode::Array);\n-      cmp->set_req(FlatArrayCheckNode::Array + i, array);\n-    }\n-  }\n-  invar_iff->set_req(1, bol);\n-\n@@ -321,5 +291,5 @@\n-\/\/ Return control projection of the entry to the fast version.\n-ProjNode* PhaseIdealLoop::create_slow_version_of_loop(IdealLoopTree *loop,\n-                                                      Node_List &old_new,\n-                                                      int opcode,\n-                                                      CloneLoopMode mode) {\n+\/\/ Return the inserted if.\n+IfNode* PhaseIdealLoop::create_slow_version_of_loop(IdealLoopTree *loop,\n+                                                    Node_List &old_new,\n+                                                    Node_List &unswitch_iffs,\n+                                                    CloneLoopMode mode) {\n@@ -334,8 +304,29 @@\n-  Node *cont      = _igvn.intcon(1);\n-  set_ctrl(cont, C->root());\n-  Node* opq       = new Opaque1Node(C, cont);\n-  register_node(opq, outer_loop, entry, dom_depth(entry));\n-  Node *bol       = new Conv2BNode(opq);\n-  register_node(bol, outer_loop, entry, dom_depth(entry));\n-  IfNode* iff = (opcode == Op_RangeCheck) ? new RangeCheckNode(entry, bol, PROB_MAX, COUNT_UNKNOWN) :\n-    new IfNode(entry, bol, PROB_MAX, COUNT_UNKNOWN);\n+  \/\/ Add test to new \"if\" outside of loop\n+  IfNode* unswitch_iff = unswitch_iffs.at(0)->as_If();\n+  BoolNode* bol = unswitch_iff->in(1)->as_Bool();\n+  if (unswitch_iffs.size() > 1) {\n+    \/\/ Flattened array checks are used on array access to switch between\n+    \/\/ a legacy object array access and a flattened inline type array\n+    \/\/ access. We want the performance impact on legacy accesses to be\n+    \/\/ as small as possible so we make two copies of the loop: a fast\n+    \/\/ one where all accesses are known to be legacy, a slow one where\n+    \/\/ some accesses are to flattened arrays. Flattened array checks\n+    \/\/ can be removed from the fast loop (true proj) but not from the\n+    \/\/ slow loop (false proj) as it can have a mix of flattened\/legacy accesses.\n+    assert(bol->_test._test == BoolTest::ne, \"IfTrue proj must point to flat array\");\n+    bol = bol->clone()->as_Bool();\n+    register_new_node(bol, entry);\n+    FlatArrayCheckNode* cmp = bol->in(1)->clone()->as_FlatArrayCheck();\n+    register_new_node(cmp, entry);\n+    bol->set_req(1, cmp);\n+    \/\/ Combine all checks into a single one that fails if one array is flattened\n+    assert(cmp->req() == 3, \"unexpected number of inputs for FlatArrayCheck\");\n+    cmp->add_req_batch(C->top(), unswitch_iffs.size() - 1);\n+    for (uint i = 0; i < unswitch_iffs.size(); i++) {\n+      Node* array = unswitch_iffs.at(i)->in(1)->in(1)->in(FlatArrayCheckNode::Array);\n+      cmp->set_req(FlatArrayCheckNode::Array + i, array);\n+    }\n+  }\n+\n+  IfNode* iff = (unswitch_iff->Opcode() == Op_RangeCheck) ? new RangeCheckNode(entry, bol, unswitch_iff->_prob, unswitch_iff->_fcnt) :\n+      new IfNode(entry, bol, unswitch_iff->_prob, unswitch_iff->_fcnt);\n@@ -368,1 +359,1 @@\n-  return iffast;\n+  return iff;\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":40,"deletions":49,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -1350,4 +1350,4 @@\n-  ProjNode* create_slow_version_of_loop(IdealLoopTree *loop,\n-                                        Node_List &old_new,\n-                                        int opcode,\n-                                        CloneLoopMode mode);\n+  IfNode* create_slow_version_of_loop(IdealLoopTree *loop,\n+                                      Node_List &old_new,\n+                                      Node_List &unswitch_iffs,\n+                                      CloneLoopMode mode);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}