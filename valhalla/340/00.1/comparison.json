{"files":[{"patch":"@@ -3310,0 +3310,14 @@\n+\n+  Label notRestricted;\n+  __ movl(rdx, flags);\n+  __ shrl(rdx, ConstantPoolCacheEntry::has_restricted_type_shift);\n+  __ andl(rdx, 0x1);\n+  __ testl(rdx, rdx);\n+  __ jcc(Assembler::zero, notRestricted);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::check_restricted_type));\n+  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+\n+  __ bind(notRestricted);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1379,0 +1379,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1474,0 +1476,12 @@\n+      } else if (attribute_name == vmSymbols::tag_restricted_field()) {\n+        check_property(\n+          attribute_length == 2,\n+          \"Invalid RestrictedField field attribute length %u in class file %s\",\n+          attribute_length, CHECK);\n+          const u2 type_index = cfs->get_u2_fast();\n+          check_property(valid_symbol_at(type_index),\n+                         \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                          type_index, CHECK);\n+          *restricted_field_info = type_index;\n+          *has_restricted_type = true;\n+          set_has_restricted_fields();\n@@ -1665,0 +1679,2 @@\n+  _descriptor_signature_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1695,0 +1711,1 @@\n+\n@@ -1727,0 +1744,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1736,0 +1755,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1770,0 +1791,26 @@\n+    \/\/ RestrictedField:\n+    \/\/ The current model for restricted field is that such a field has a descriptor signature used\n+    \/\/ as the normal signature for this field (for instance in field access bytecodes) but it also\n+    \/\/ has a restricted type that will be used internally by the VM as the real type of the field.\n+    \/\/ Current constraints are that the restricted type must be an inline type and the descriptor\n+    \/\/ type must be a super type of the restricted type.\n+    \/\/ The code below verifies that the restricted type is an inline type. The property that the\n+    \/\/ descriptor type is a super type of the restricted type is verified just after the pre-loading\n+    \/\/ of the restricted type (inline type field preloading)\n+    if (has_restricted_type && cp->basic_type_for_signature_at(restricted_type_index) != T_INLINE_TYPE) {\n+      \/\/ Probably not the right error to throw\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Field %s.%s has a RestricteField attribute but its restricted type is not an inline type\",\n+                _class_name->as_C_string(),\n+                _cp->symbol_at(restricted_type_index)->as_C_string()));\n+    }\n+\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1773,1 +1820,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1775,0 +1822,3 @@\n+    _descriptor_signature_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1824,0 +1874,1 @@\n+      _descriptor_signature_info->append(0);\n@@ -1827,0 +1878,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1834,0 +1886,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1836,0 +1889,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1838,0 +1892,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1846,0 +1903,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1848,0 +1906,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -5888,0 +5947,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_descriptor_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _descriptor_signature_info->at(i);\n+    }\n+  }\n+\n@@ -6086,0 +6153,1 @@\n+  _descriptor_signature_info(NULL),\n@@ -6125,0 +6193,1 @@\n+  _has_restricted_fields(false),\n@@ -6703,0 +6772,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6705,1 +6775,0 @@\n-      \/\/ Pre-load inline class\n@@ -6718,0 +6787,13 @@\n+      if (fs.has_restricted_type()) {\n+        \/\/ descriptor type supposed to be a super type of the restricted type, so after the pre-loading\n+        \/\/ of the restricted type above, the descriptor type should be loaded at this point\n+        Symbol* descriptor_name = _cp->symbol_at(_descriptor_signature_info->at(fs.index()));\n+        ResolvingSignatureStream rss(descriptor_name, Handle(THREAD, _loader_data->class_loader()), _protection_domain, false);\n+        Klass* desc_klass = rss.as_klass(SignatureStream::ReturnNull, CHECK);\n+        if (desc_klass == NULL || !klass->is_subtype_of(desc_klass)) {\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Restricted type %s should be a subtype of the descriptor type %s, but it is not\",\n+                    fs.signature()->as_C_string(),\n+                    descriptor_name->as_C_string()));\n+        }\n+      }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":84,"deletions":2,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  static void check_restricted_type(JavaThread* thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+                                       bool has_restricted_type,\n@@ -151,1 +152,2 @@\n-                  ((is_inline_type ? 1 : 0) << is_inline_type_shift),\n+                  ((is_inline_type ? 1 : 0) << is_inline_type_shift) |\n+                  ((has_restricted_type ? 1 : 0) << has_restricted_type_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -476,1 +476,2 @@\n-                                       parser.is_inline_type());\n+                                       parser.is_inline_type(),\n+                                       parser.has_restricted_fields());\n@@ -511,0 +512,4 @@\n+  if (parser.has_restricted_fields()) {\n+    ik->set_has_restricted_fields(); \/\/ required to get the size right when calling size()\n+  }\n+\n@@ -1658,4 +1663,14 @@\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n-      return true;\n+    if (f_name == name) {\n+      Symbol* f_sig = NULL;\n+      f_sig  = fs.signature();\n+      if (f_sig == sig) {\n+        fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+        return true;\n+      }\n+      if (fs.has_restricted_type()) {\n+        f_sig = fs.descriptor_signature();\n+        if (f_sig == sig) {\n+          fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+          return true;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\/\/    [EMBEDDED restricted_fields_info] only if has_restricted_fields() == true\n@@ -295,1 +296,2 @@\n-    _misc_has_injected_identityObject         = 1 << 22  \/\/ IdentityObject has been injected by the JVM\n+    _misc_has_injected_identityObject         = 1 << 22, \/\/ IdentityObject has been injected by the JVM\n+    _misc_has_restricted_fields               = 1 << 23  \/\/ class has fields with type restrictions\n@@ -479,1 +481,1 @@\n-    return (_misc_flags & _misc_has_injected_identityObject);\n+    return (_misc_flags & _misc_has_injected_identityObject) != 0;\n@@ -486,0 +488,8 @@\n+  bool has_restricted_fields() const {\n+    return (_misc_flags & _misc_has_restricted_fields) != 0;\n+  }\n+\n+  void set_has_restricted_fields() {\n+    _misc_flags |= _misc_has_restricted_fields;\n+  }\n+\n@@ -550,0 +560,1 @@\n+  bool    field_has_restricted_type(int index) const { return field(index)->has_restricted_type(); }\n@@ -1180,1 +1191,1 @@\n-                  int java_fields, bool is_inline_type) {\n+                  int java_fields, bool is_inline_type, bool has_restricted_fields) {\n@@ -1189,1 +1200,2 @@\n-           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0) +\n+           (has_restricted_fields ? (align_up(java_fields * (int)sizeof(u2), wordSize)\/wordSize) : 0));\n@@ -1198,1 +1210,2 @@\n-                                               is_inline_klass());\n+                                               is_inline_klass(),\n+                                               has_restricted_fields());\n@@ -1214,0 +1227,2 @@\n+  inline u2* fields_descriptor_type() const;\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2272,0 +2272,3 @@\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_CONTENDED\", FIELDINFO_TAG_CONTENDED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_INLINED\", FIELDINFO_TAG_INLINED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_RESTRICTED\", FIELDINFO_TAG_RESTRICTED) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -389,0 +389,3 @@\n+                if (c.isPrimitiveClass() && c.projection != null) {\n+                    c.projection.flags_field = (c.flags_field & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | SEALED;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,0 +142,4 @@\n+    \/** Flag is set for a type restricted field.\n+     *\/\n+    public static final int RESTRICTED_FIELD       = 1<<19;\n+\n@@ -518,0 +522,1 @@\n+        RESTRICTED_FIELD(Flags.RESTRICTED_FIELD),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-            return new MethodType(t.getParameterTypes().prepend(outerThisType),\n+            t = new MethodType(t.getParameterTypes().prepend(outerThisType),\n@@ -364,1 +364,2 @@\n-        } else {\n+        }\n+        if (!types.flattenWithTypeRestrictions) {\n@@ -367,0 +368,26 @@\n+        List<Type> rpt = List.nil();\n+        Type rrt = null;\n+        boolean mutateExternalType = false;\n+        \/\/ Computed restricted parameter types\n+        for (Type pt: t.getParameterTypes()) {\n+            if (pt.isPrimitiveClass()) {\n+                mutateExternalType = true;\n+                rpt = rpt.append(pt.referenceProjection());\n+            } else {\n+                rpt = rpt.append(pt);\n+            }\n+        }\n+        Type rt = t.getReturnType();\n+        if (rt.isPrimitiveClass()) {\n+            mutateExternalType = true;\n+            rrt = rt.referenceProjection();\n+        } else {\n+            rrt = rt;\n+        }\n+        if (mutateExternalType) {\n+            t = new MethodType(rpt,\n+                    rrt,\n+                    t.getThrownTypes(),\n+                    t.tsym);\n+        }\n+        return t;\n@@ -1678,3 +1705,0 @@\n-            if (!isPrimitiveClass())\n-                return null;\n-\n@@ -1695,1 +1719,1 @@\n-            long projectionFlags = (this.flags() & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | SEALED;\n+            long projectionFlags = (this.flags_field & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | SEALED;\n@@ -1699,14 +1723,17 @@\n-            for (Symbol s : this.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    valMethod.projection = refMethod;\n-                    refMethod.projection = valMethod;\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    valVar.projection = refVar;\n-                    refVar.projection = valVar;\n-                    clone = refVar;\n+            if (this.completer == Completer.NULL_COMPLETER) {\n+                for (Symbol s : this.members().getSymbols(s -> (s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n+                    Symbol clone = null;\n+                    if (s.kind == MTH) {\n+                        MethodSymbol valMethod = (MethodSymbol)s;\n+                        MethodSymbol refMethod = valMethod.clone(projection);\n+                        valMethod.projection = refMethod;\n+                        refMethod.projection = valMethod;\n+                        clone = refMethod;\n+                    } else if (s.kind == VAR) {\n+                        VarSymbol valVar = (VarSymbol)s;\n+                        VarSymbol refVar = valVar.clone(projection);\n+                        valVar.projection = refVar;\n+                        refVar.projection = valVar;\n+                        clone = refVar;\n+                    }\n+                    projection.members_field.enter(clone);\n@@ -1714,2 +1741,13 @@\n-                projection.members_field.enter(clone);\n-            projection.completer = Completer.NULL_COMPLETER;\n+\n+            projection.completer = new Completer() {\n+                @Override\n+                public void complete(Symbol sym) throws CompletionFailure {\n+                    ClassSymbol.this.complete();\n+                }\n+\n+                @Override\n+                public boolean isTerminal() {\n+                    return ClassSymbol.this.completer.isTerminal();\n+                }\n+            };\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":60,"deletions":22,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+    public final Type restrictedTypeType;\n@@ -599,0 +600,1 @@\n+        restrictedTypeType = enterClass(\"java.lang.invoke.RestrictedType\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+    \/** enable alternate code generation to faciliate specialization experiments using type restrictions *\/\n+    public boolean flattenWithTypeRestrictions;\n+\n@@ -129,0 +132,1 @@\n+        flattenWithTypeRestrictions = options.isSet(\"flattenWithTypeRestrictions\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1280,0 +1280,47 @@\n+            new AttributeReader(names.RestrictedField, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowPrimitiveClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind == VAR && sym.owner.kind == TYP) {\n+                        final Type type = poolReader.getType(nextChar());\n+                        if (types.flattenWithTypeRestrictions) {\n+                            Assert.check(((ClassSymbol)((ClassType)sym.type).tsym).projection == type.tsym);\n+                            sym.flags_field |= RESTRICTED_FIELD;\n+                        }\n+                    }\n+                }\n+            },\n+\n+            new AttributeReader(names.RestrictedMethod, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowPrimitiveClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (!types.flattenWithTypeRestrictions) {\n+                        bp = bp + attrLen;\n+                        return;\n+                    }\n+                    int paramCount = nextByte();\n+                    if (sym.name == names.init && sym.owner.hasOuterInstance())\n+                        paramCount --;\n+                    List<Type> paramTypes = List.nil();\n+                    for (int i = 0; i < paramCount; i++) {\n+                        int restrictedParamTypeIndex = nextChar();\n+                        paramTypes = paramTypes.append(\n+                                  restrictedParamTypeIndex == 0 ?\n+                                  sym.type.getParameterTypes().get(i)\n+                                : poolReader.getType(restrictedParamTypeIndex));\n+                    }\n+                    int restrictedReturnTypeIndex = nextChar();\n+                    Type returnType =\n+                            restrictedReturnTypeIndex == 0 || sym.isConstructor() ?\n+                                    sym.type.getReturnType()\n+                                    : poolReader.getType(restrictedReturnTypeIndex);\n+                    if (sym.kind == MTH && sym.owner.kind == TYP) {\n+                        sym.type = new MethodType(paramTypes, returnType, sym.type.getThrownTypes(), sym.type.tsym);\n+                    }\n+                }\n+            },\n@@ -2245,1 +2292,2 @@\n-        return v;\n+        return (v.flags_field & RESTRICTED_FIELD) == RESTRICTED_FIELD ?\n+                new VarSymbol(flags, name, ((ClassSymbol)v.type.tsym).projection.type, currentOwner) : v;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -976,1 +976,18 @@\n-        databuf.appendChar(poolWriter.putDescriptor(v));\n+        boolean emitRestrictedField = false;\n+        int restrictedFieldDescriptor = 0;\n+        if (types.flattenWithTypeRestrictions && v.type.isPrimitiveClass()) {\n+            emitRestrictedField = true;\n+            databuf.appendChar(poolWriter.putDescriptor(v.type.referenceProjection()));\n+        } else {\n+            databuf.appendChar(poolWriter.putDescriptor(v));\n+            for (Attribute.Compound anno : v.type.getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    Attribute member = anno.member(names.value);\n+                    Assert.check(member.type.tsym == syms.stringType.tsym);\n+                    String utf8 = (String) member.getValue();\n+                    restrictedFieldDescriptor = poolWriter.putName(names.fromString(utf8));\n+                    emitRestrictedField = true;\n+                }\n+            }\n+        }\n+\n@@ -985,0 +1002,10 @@\n+        if (emitRestrictedField) {\n+            int alenIdx = writeAttr(names.RestrictedField);\n+            if (types.flattenWithTypeRestrictions && v.type.isPrimitiveClass()) {\n+                databuf.appendChar(poolWriter.putDescriptor(v));\n+            }   else {\n+                databuf.appendChar(restrictedFieldDescriptor);\n+            }\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n@@ -1030,0 +1057,75 @@\n+        \/\/ See if we need to emit a RestrictedMethod attribute\n+        boolean emitRestrictedMethod = false;\n+\n+        if (types.flattenWithTypeRestrictions && m.name == m.name.table.names.init && m.owner.hasOuterInstance()) {\n+            Type outerThisType = types.erasure(m.owner.type.getEnclosingType());\n+            if (outerThisType.isPrimitiveClass()) {\n+                emitRestrictedMethod = true;\n+            }\n+        }\n+        CheckTypeRestrictedParameters:\n+        for (Type pt : m.type.getParameterTypes()) {\n+            if (pt.isPrimitiveClass() && types.flattenWithTypeRestrictions) {\n+                emitRestrictedMethod = true;\n+                break;\n+            }\n+            for (Attribute.Compound anno : pt.getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    emitRestrictedMethod = true;\n+                    break CheckTypeRestrictedParameters;\n+                }\n+            }\n+        }\n+        if (m.type.getReturnType().isPrimitiveClass() && types.flattenWithTypeRestrictions) {\n+            emitRestrictedMethod = true;\n+        } else {\n+            for (Attribute.Compound anno : m.type.getReturnType().getAnnotationMirrors()) {\n+                if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                    emitRestrictedMethod = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (emitRestrictedMethod) {\n+            int alenIdx = writeAttr(names.RestrictedMethod);\n+            databuf.appendByte(m.externalType(types).getParameterTypes().size());\n+            if (types.flattenWithTypeRestrictions) {\n+                if (m.name == names.init && m.owner.hasOuterInstance()) {\n+                    Type outerThisType = types.erasure(m.owner.type.getEnclosingType());\n+                    databuf.appendChar(outerThisType.isPrimitiveClass() ? poolWriter.putDescriptor(outerThisType) : 0);\n+                }\n+                for (Type pt : m.erasure(types).getParameterTypes()) {\n+                    databuf.appendChar(pt.isPrimitiveClass() ? poolWriter.putDescriptor(pt) : 0);\n+                }\n+                Type rt = m.erasure(types).getReturnType();\n+                databuf.appendChar(rt.isPrimitiveClass() ? poolWriter.putDescriptor(rt) : 0);\n+            } else {\n+                int restrictedTypeDescriptor;\n+                for (Type pt : m.type.getParameterTypes()) {\n+                    restrictedTypeDescriptor = 0;\n+                    for (Attribute.Compound anno : pt.getAnnotationMirrors()) {\n+                        if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                            Attribute member = anno.member(names.value);\n+                            Assert.check(member.type.tsym == syms.stringType.tsym);\n+                            String utf8 = (String) member.getValue();\n+                            restrictedTypeDescriptor = poolWriter.putName(names.fromString(utf8));\n+                        }\n+                    }\n+                    databuf.appendChar(restrictedTypeDescriptor);\n+                }\n+                restrictedTypeDescriptor = 0;\n+                Type rt = m.type.getReturnType();\n+                for (Attribute.Compound anno : rt.getAnnotationMirrors()) {\n+                    if (anno.type.tsym == syms.restrictedTypeType.tsym) {\n+                        Attribute member = anno.member(names.value);\n+                        Assert.check(member.type.tsym == syms.stringType.tsym);\n+                        String utf8 = (String) member.getValue();\n+                        restrictedTypeDescriptor = poolWriter.putName(names.fromString(utf8));\n+                    }\n+                }\n+                databuf.appendChar(restrictedTypeDescriptor);\n+            }\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -37,0 +38,2 @@\n+import java.util.HashMap;\n+\n@@ -148,1 +151,5 @@\n-        return new StaticItem(member);\n+        if (this.types.flattenWithTypeRestrictions && member.kind == Kind.VAR && member.type.isPrimitiveClass()) {\n+            return new StaticItem(getFlattenedField(member));\n+        } else {\n+            return new StaticItem(member);\n+        }\n@@ -157,1 +164,5 @@\n-        return new MemberItem(member, nonvirtual);\n+        if (this.types.flattenWithTypeRestrictions && member.kind == Kind.VAR && member.type.isPrimitiveClass()) {\n+            return new MemberItem(getFlattenedField(member), nonvirtual);\n+        } else {\n+            return new MemberItem(member, nonvirtual);\n+        }\n@@ -159,0 +170,15 @@\n+        \/\/ where\n+        private Symbol getFlattenedField(Symbol member) {\n+            if (flatFieldsMap == null)\n+                flatFieldsMap = new HashMap<>();\n+            Symbol flatField = flatFieldsMap.get(member);\n+            if (flatField == null) {\n+                flatFieldsMap.put(member, flatField = new VarSymbol(member.flags(),\n+                                                        member.name,\n+                                                        member.type.referenceProjection(),\n+                                                        member.owner));\n+            }\n+            return flatField;\n+        }\n+\n+     private HashMap<Symbol, Symbol> flatFieldsMap;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Items.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+    public final Name RestrictedField;\n+    public final Name RestrictedMethod;\n@@ -340,0 +342,2 @@\n+        RestrictedField = fromString(\"RestrictedField\");\n+        RestrictedMethod = fromString(\"RestrictedMethod\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+class PointBox {\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    static public Point.ref p84;\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    static public Object p71;\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    static primitive class Rec {\n+        @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+        public Point.ref p37;\n+\n+        @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+        public Object p23;\n+\n+        public Rec() { this.p37 = new Point(0.0, 0.0); this.p23 = new Point(0.0, 0.0);}\n+\n+        Rec setp37(Point.ref p) {\n+            Rec r = Rec.default;\n+            r = __WithField(r.p37, p);\n+            r = __WithField(r.p23, this.p23);\n+            return r;\n+        }\n+\n+        Rec setp23(Object o) {\n+            Rec r = Rec.default;\n+            r = __WithField(r.p37, this.p37);\n+            r = __WithField(r.p23, o);\n+            return r;\n+        }\n+    }\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    public Point.ref p368;\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    public Object p397;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/PointBox.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @summary Simple test about type restrictions\n+ * @library \/test\/lib\n+ * @compile  -XDflattenWithTypeRestrictions SimpleTest.java\n+ * @run main\/othervm -Xint runtime.valhalla.typerestrictions.SimpleTest\n+ *\/\n+public class SimpleTest {\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public Point p;\n+\n+    public static void main(String... args) {\n+        SimpleTest b = new SimpleTest();\n+        if (b.p != new Point(0,0)) throw new RuntimeException();\n+        b.p = new Point(1.0, 2.0);\n+        if (b.p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/SimpleTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260870\n+ * @summary Generate RestrictedMethod attributes from annotations\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @run main AnnotatedRestrictedMethodTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+public class AnnotatedRestrictedMethodTest {\n+\n+    primitive class Point {}\n+    primitive class Line {}\n+\n+    Point foo(int x, Point p, int y, Line l) {\n+        return p;\n+    }\n+\n+    @RestrictedType(\"QAnnotatedRestrictedMethodTest$Point;\")\n+    Object goo(int x,\n+               @RestrictedType(\"QAnnotatedRestrictedMethodTest$Point;\") Object p,\n+               int y,\n+               @RestrictedType(\"QAnnotatedRestrictedMethodTest$Line;\") Object l) {\n+        return p;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(AnnotatedRestrictedMethodTest.class.getResourceAsStream(\"AnnotatedRestrictedMethodTest.class\"));\n+\n+        for (Method meth: cls.methods) {\n+            if (meth.getName(cls.constant_pool).equals(\"foo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(IQAnnotatedRestrictedMethodTest$Point;IQAnnotatedRestrictedMethodTest$Line;)QAnnotatedRestrictedMethodTest$Point;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method\");\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma != null) {\n+                    throw new AssertionError(\"Unexpected restricted method attribute\");\n+                }\n+            } else if (meth.getName(cls.constant_pool).equals(\"goo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(ILjava\/lang\/Object;ILjava\/lang\/Object;)Ljava\/lang\/Object;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method \" + desc);\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma == null) {\n+                    throw new AssertionError(\"Missing restricted method attribute\");\n+                }\n+\n+                if (rma.getParameterCount() != 4) {\n+                    throw new AssertionError(\"Wrong parameter count\");\n+                }\n+                int typeindex;\n+                String type;\n+                for (int i = 0; i < 4; i++) {\n+                    typeindex = rma.getRestrictedParameterType(i);\n+                    switch(i) {\n+                        case 0:\n+                        case 2:\n+                            if (typeindex != 0) {\n+                                throw new AssertionError(\"Unexpected type restriction\");\n+                            }\n+                            break;\n+                        case 1:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Point;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                        case 3:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Line;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                    }\n+                }\n+                typeindex = rma.getRestrictedReturnType();\n+                if (typeindex == 0) {\n+                    throw new AssertionError(\"Missing type restriction\");\n+                }\n+                if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QAnnotatedRestrictedMethodTest$Point;\")) {\n+                    throw new AssertionError(\"Unexpected type restriction \" + type);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AnnotatedRestrictedMethodTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260870\n+ * @summary Generate RestrictedMethod attributes triggered via compile time flag\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDflattenWithTypeRestrictions FlaggedRestrictedMethodTest.java\n+ * @run main FlaggedRestrictedMethodTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+public class FlaggedRestrictedMethodTest {\n+\n+    primitive class Point {}\n+    primitive class Line {}\n+\n+    static Point foo(int x, Point p, int y, Line l) {\n+        return p;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(FlaggedRestrictedMethodTest.class.getResourceAsStream(\"FlaggedRestrictedMethodTest.class\"));\n+\n+        for (Method meth: cls.methods) {\n+            if (meth.getName(cls.constant_pool).equals(\"foo\")) {\n+                String desc = meth.descriptor.getValue(cls.constant_pool);\n+                if (!desc.equals(\"(ILFlaggedRestrictedMethodTest$Point$ref;ILFlaggedRestrictedMethodTest$Line$ref;)LFlaggedRestrictedMethodTest$Point$ref;\"))\n+                    throw new AssertionError(\"Unexpected descriptor for method\" + desc);\n+                RestrictedMethod_attribute rma =\n+                    (RestrictedMethod_attribute) meth.attributes.get(Attribute.RestrictedMethod);\n+                if (rma == null) {\n+                    throw new AssertionError(\"Missing restricted method attribute\");\n+                }\n+\n+                if (rma.getParameterCount() != 4) {\n+                    throw new AssertionError(\"Wrong parameter count\");\n+                }\n+                int typeindex;\n+                String type;\n+                for (int i = 0; i < 4; i++) {\n+                    typeindex = rma.getRestrictedParameterType(i);\n+                    switch(i) {\n+                        case 0:\n+                        case 2:\n+                            if (typeindex != 0) {\n+                                throw new AssertionError(\"Unexpected type restriction\");\n+                            }\n+                            break;\n+                        case 1:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Point;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                        case 3:\n+                            if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Line;\")) {\n+                                throw new AssertionError(\"Unexpected type restriction \" + type);\n+                            }\n+                            break;\n+                    }\n+                }\n+                typeindex = rma.getRestrictedReturnType();\n+                if (typeindex == 0) {\n+                    throw new AssertionError(\"Missing type restriction\");\n+                }\n+                if (!(type = cls.constant_pool.getUTF8Value(typeindex)).equals(\"QFlaggedRestrictedMethodTest$Point;\")) {\n+                    throw new AssertionError(\"Unexpected type restriction \" + type);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/FlaggedRestrictedMethodTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.RestrictedType;\n+\n+class PointBox {\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    @RestrictedType(\"QPoint;\")\n+    public Object p368;\n+\n+    public static void main(String... args) {\n+        PointBox b = new PointBox();\n+        if (b.p368 != new Point(0,0)) throw new RuntimeException();\n+        b.p368 = new Point(1.0, 2.0);\n+        if (b.p368 != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/PointBox.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253312\n+ * @summary Enable JVM experiments in specialization under an opt-in mode\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions RestrictedFieldCodegenTest.java\n+ * @run main\/othervm -Xverify:none RestrictedFieldCodegenTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+class PointBox {\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public Point p;\n+\n+    public static void main(String... args) {\n+        PointBox b = new PointBox();\n+        if (b.p != new Point(0,0)) throw new RuntimeException();\n+        b.p = new Point(1.0, 2.0);\n+        if (b.p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n+\n+public class RestrictedFieldCodegenTest {\n+\n+    public static void main(String [] args) {\n+        new RestrictedFieldCodegenTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"PointBox.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+         \"public PointBox$Point$ref p;\",\n+         \"descriptor: LPointBox$Point$ref;\",\n+         \"RestrictedField: #25                    \/\/ QPointBox$Point;\",\n+         \" 9: getfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         \"36: putfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         \"40: getfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         });\n+\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        System.out.println(\"Checking javap\");\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        System.out.println(\"Javap = \" + out);\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldCodegenTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253760\n+ * @summary [type-restrictions] Static primitive value type fields are not \"erased\" to the ref type\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions RestrictedStaticFieldCodegenTest.java\n+ * @run main\/othervm -Xverify:none RestrictedStaticFieldCodegenTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+class PointBox {\n+\n+    static primitive class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public static Point p;\n+\n+    public static void main(String... args) {\n+        if (p != new Point(0,0)) throw new RuntimeException();\n+        p = new Point(1.0, 2.0);\n+        if (p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n+\n+public class RestrictedStaticFieldCodegenTest {\n+\n+    public static void main(String [] args) {\n+        new RestrictedStaticFieldCodegenTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"PointBox.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+         \"public static PointBox$Point$ref p;\",\n+         \"descriptor: LPointBox$Point$ref;\",\n+         \"RestrictedField: #24                    \/\/ QPointBox$Point;\",\n+         \" 0: getstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         \"26: putstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         \"29: getstatic     #7                  \/\/ Field p:LPointBox$Point$ref;\",\n+         });\n+\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        System.out.println(\"Checking javap\");\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        System.out.println(\"Javap = \" + out);\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedStaticFieldCodegenTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255856 8257028\n+ * @summary Generate RestrictedField attributes from annotations\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @compile -XDallowWithFieldOperator Point.java\n+ * @run main RestrictedTypeAnnotationCodegenTest\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+public class RestrictedTypeAnnotationCodegenTest {\n+\n+    primitive class Point {}\n+    primitive class Line {}\n+\n+    @RestrictedType(\"QRestrictedTypeAnnotationCodegenTest$Line;\")\n+    public Object jloFld = null;\n+\n+    @RestrictedType(\"QRestrictedTypeAnnotationCodegenTest$Point;\")\n+    public Point.ref refProjFld = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassFile cls = ClassFile.read(InlineNestingAttributesTest.class.getResourceAsStream(\"RestrictedTypeAnnotationCodegenTest.class\"));\n+\n+        int goodFlds = 0;\n+        for (Field fld: cls.fields) {\n+            if (fld.getName(cls.constant_pool).equals(\"jloFld\")) {\n+               String desc = fld.descriptor.getValue(cls.constant_pool);\n+               RestrictedField_attribute rfa =\n+                    (RestrictedField_attribute) fld.attributes.get(Attribute.RestrictedField);\n+               if (rfa.getRestrictedType(cls.constant_pool).equals(\"QRestrictedTypeAnnotationCodegenTest$Line;\") && desc.equals(\"Ljava\/lang\/Object;\"))\n+                    goodFlds++;\n+            } else if (fld.getName(cls.constant_pool).equals(\"refProjFld\")) {\n+               String desc = fld.descriptor.getValue(cls.constant_pool);\n+               RestrictedField_attribute rfa =\n+                    (RestrictedField_attribute) fld.attributes.get(Attribute.RestrictedField);\n+               if (rfa.getRestrictedType(cls.constant_pool).equals(\"QRestrictedTypeAnnotationCodegenTest$Point;\") && desc.equals(\"LRestrictedTypeAnnotationCodegenTest$Point$ref;\"))\n+                    goodFlds++;\n+            }\n+        }\n+        if (goodFlds != 2) {\n+            throw new AssertionError(\"Lookup for 2 fields failed: Found only \" + goodFlds);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedTypeAnnotationCodegenTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}