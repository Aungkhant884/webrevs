{"files":[{"patch":"@@ -205,1 +205,1 @@\n-JVM_Sleep\n+JVM_SleepNanos\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -481,0 +481,9 @@\n+  if (AbortVMOnException) {\n+    __ mov(rscratch1, exception_oop);\n+    __ enter();\n+    save_live_registers(sasm);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, check_abort_on_vm_exception), rscratch1);\n+    restore_live_registers(sasm);\n+    __ leave();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1025,1 +1025,1 @@\n-  assert(arg_1 != c_rarg2, \"smashed arg\");\n+  assert_different_registers(arg_1, c_rarg2);\n@@ -1037,2 +1037,2 @@\n-  assert(arg_1 != c_rarg3, \"smashed arg\");\n-  assert(arg_2 != c_rarg3, \"smashed arg\");\n+  assert_different_registers(arg_1, c_rarg2, c_rarg3);\n+  assert_different_registers(arg_2, c_rarg3);\n@@ -1041,1 +1041,0 @@\n-  assert(arg_1 != c_rarg2, \"smashed arg\");\n@@ -1072,1 +1071,1 @@\n-  assert(arg_1 != c_rarg2, \"smashed arg\");\n+  assert_different_registers(arg_1, c_rarg2);\n@@ -1085,2 +1084,2 @@\n-  assert(arg_1 != c_rarg3, \"smashed arg\");\n-  assert(arg_2 != c_rarg3, \"smashed arg\");\n+  assert_different_registers(arg_1, c_rarg2, c_rarg3);\n+  assert_different_registers(arg_2, c_rarg3);\n@@ -1088,1 +1087,0 @@\n-  assert(arg_1 != c_rarg2, \"smashed arg\");\n@@ -1662,1 +1660,1 @@\n-  assert(arg_0 != c_rarg1, \"smashed arg\");\n+  assert_different_registers(arg_0, c_rarg1);\n@@ -1669,2 +1667,2 @@\n-  assert(arg_0 != c_rarg2, \"smashed arg\");\n-  assert(arg_1 != c_rarg2, \"smashed arg\");\n+  assert_different_registers(arg_0, c_rarg1, c_rarg2);\n+  assert_different_registers(arg_1, c_rarg2);\n@@ -1672,1 +1670,0 @@\n-  assert(arg_0 != c_rarg1, \"smashed arg\");\n@@ -1679,3 +1676,3 @@\n-  assert(arg_0 != c_rarg3, \"smashed arg\");\n-  assert(arg_1 != c_rarg3, \"smashed arg\");\n-  assert(arg_2 != c_rarg3, \"smashed arg\");\n+  assert_different_registers(arg_0, c_rarg1, c_rarg2, c_rarg3);\n+  assert_different_registers(arg_1, c_rarg2, c_rarg3);\n+  assert_different_registers(arg_2, c_rarg3);\n@@ -1683,3 +1680,0 @@\n-  assert(arg_0 != c_rarg2, \"smashed arg\");\n-  assert(arg_1 != c_rarg2, \"smashed arg\");\n-  assert(arg_0 != c_rarg1, \"smashed arg\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -157,44 +157,1 @@\n-          \"Write 0x0101... to empty memory. Use this to ease debugging.\")   \\\n-                                                                            \\\n-  \/* Use Restricted Transactional Memory for lock elision *\/                \\\n-  product(bool, UseRTMLocking, false,                                       \\\n-          \"Enable RTM lock eliding for inflated locks in compiled code\")    \\\n-                                                                            \\\n-  product(bool, UseRTMForStackLocks, false, EXPERIMENTAL,                   \\\n-          \"Enable RTM lock eliding for stack locks in compiled code\")       \\\n-                                                                            \\\n-  product(bool, UseRTMDeopt, false,                                         \\\n-          \"Perform deopt and recompilation based on RTM abort ratio\")       \\\n-                                                                            \\\n-  product(int, RTMRetryCount, 5,                                            \\\n-          \"Number of RTM retries on lock abort or busy\")                    \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMSpinLoopCount, 100, EXPERIMENTAL,                         \\\n-          \"Spin count for lock to become free before RTM retry\")            \\\n-          range(0, 32767) \/* immediate operand limit on ppc *\/              \\\n-                                                                            \\\n-  product(int, RTMAbortThreshold, 1000, EXPERIMENTAL,                       \\\n-          \"Calculate abort ratio after this number of aborts\")              \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMLockingThreshold, 10000, EXPERIMENTAL,                    \\\n-          \"Lock count at which to do RTM lock eliding without \"             \\\n-          \"abort ratio calculation\")                                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMAbortRatio, 50, EXPERIMENTAL,                             \\\n-          \"Lock abort ratio at which to stop use RTM lock eliding\")         \\\n-          range(0, 100) \/* natural range *\/                                 \\\n-                                                                            \\\n-  product(int, RTMTotalCountIncrRate, 64, EXPERIMENTAL,                     \\\n-          \"Increment total RTM attempted lock count once every n times\")    \\\n-          range(1, 32767) \/* immediate operand limit on ppc *\/              \\\n-          constraint(RTMTotalCountIncrRateConstraintFunc,AfterErgo)         \\\n-                                                                            \\\n-  product(intx, RTMLockingCalculationDelay, 0, EXPERIMENTAL,                \\\n-          \"Number of milliseconds to wait before start calculating aborts \" \\\n-          \"for RTM locking\")                                                \\\n-                                                                            \\\n-  product(bool, UseRTMXendForLockBusy, true, EXPERIMENTAL,                  \\\n-          \"Use RTM Xend instead of Xabort when lock busy\")\n+          \"Write 0x0101... to empty memory. Use this to ease debugging.\")\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":44,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -801,0 +801,8 @@\n+  if (AbortVMOnException) {\n+    __ enter();\n+    save_live_registers(sasm, 2);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, check_abort_on_vm_exception), rax);\n+    restore_live_registers(sasm);\n+    __ leave();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1400,1 +1400,1 @@\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n@@ -1422,2 +1422,2 @@\n-  LP64_ONLY(assert(arg_1 != c_rarg3, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_2 != c_rarg3, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2, c_rarg3));\n+  LP64_ONLY(assert_different_registers(arg_2, c_rarg3));\n@@ -1425,3 +1425,0 @@\n-\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n-\n@@ -1461,1 +1458,1 @@\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n@@ -1474,2 +1471,2 @@\n-  LP64_ONLY(assert(arg_1 != c_rarg3, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_2 != c_rarg3, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2, c_rarg3));\n+  LP64_ONLY(assert_different_registers(arg_2, c_rarg3));\n@@ -1477,1 +1474,0 @@\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n@@ -1508,1 +1504,1 @@\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n@@ -1521,2 +1517,2 @@\n-  LP64_ONLY(assert(arg_1 != c_rarg3, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_2 != c_rarg3, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2, c_rarg3));\n+  LP64_ONLY(assert_different_registers(arg_2, c_rarg3));\n@@ -1524,1 +1520,0 @@\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n@@ -1666,1 +1661,1 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg1, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_0, c_rarg1));\n@@ -1673,2 +1668,2 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg2, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_0, c_rarg1, c_rarg2));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n@@ -1676,1 +1671,0 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg1, \"smashed arg\"));\n@@ -1683,3 +1677,3 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg3, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_1 != c_rarg3, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_2 != c_rarg3, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_0, c_rarg1, c_rarg2, c_rarg3));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2, c_rarg3));\n+  LP64_ONLY(assert_different_registers(arg_2, c_rarg3));\n@@ -1687,3 +1681,0 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg2, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_0 != c_rarg1, \"smashed arg\"));\n@@ -1706,2 +1697,1 @@\n-\n-  LP64_ONLY(assert(arg_0 != c_rarg1, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_0, c_rarg1));\n@@ -1714,2 +1704,2 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg2, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_0, c_rarg1, c_rarg2));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n@@ -1717,1 +1707,0 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg1, \"smashed arg\"));\n@@ -1724,3 +1713,3 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg3, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_1 != c_rarg3, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_2 != c_rarg3, \"smashed arg\"));\n+  LP64_ONLY(assert_different_registers(arg_0, c_rarg1, c_rarg2, c_rarg3));\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2, c_rarg3));\n+  LP64_ONLY(assert_different_registers(arg_2, c_rarg3));\n@@ -1728,3 +1717,0 @@\n-  LP64_ONLY(assert(arg_0 != c_rarg2, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_1 != c_rarg2, \"smashed arg\"));\n-  LP64_ONLY(assert(arg_0 != c_rarg1, \"smashed arg\"));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":21,"deletions":35,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -8349,1 +8349,1 @@\n-instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+instruct xaddB_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n@@ -8353,1 +8353,13 @@\n-  format %{ \"ADDB  [$mem],$add\" %}\n+  format %{ \"addb_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addb($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddB_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddB mem add));\n+  effect(KILL cr);\n+  format %{ \"addb_lock   $mem, $add\" %}\n@@ -8358,1 +8370,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8361,1 +8373,2 @@\n-instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{\n+instruct xaddB(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n@@ -8364,1 +8377,1 @@\n-  format %{ \"XADDB  [$mem],$newval\" %}\n+  format %{ \"xaddb_lock  $mem, $newval\" %}\n@@ -8369,1 +8382,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8372,1 +8385,1 @@\n-instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+instruct xaddS_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n@@ -8376,1 +8389,13 @@\n-  format %{ \"ADDW  [$mem],$add\" %}\n+  format %{ \"addw_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addw($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddS_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(UseStoreImmI16 && n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddS mem add));\n+  effect(KILL cr);\n+  format %{ \"addw_lock   $mem, $add\" %}\n@@ -8381,1 +8406,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8384,1 +8409,2 @@\n-instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{\n+instruct xaddS(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n@@ -8387,1 +8413,1 @@\n-  format %{ \"XADDW  [$mem],$newval\" %}\n+  format %{ \"xaddw_lock  $mem, $newval\" %}\n@@ -8392,1 +8418,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8395,1 +8421,1 @@\n-instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+instruct xaddI_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n@@ -8399,1 +8425,13 @@\n-  format %{ \"ADDL  [$mem],$add\" %}\n+  format %{ \"addl_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addl($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddI_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddI mem add));\n+  effect(KILL cr);\n+  format %{ \"addl_lock   $mem, $add\" %}\n@@ -8404,1 +8442,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8407,1 +8445,2 @@\n-instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{\n+instruct xaddI(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n@@ -8410,1 +8449,1 @@\n-  format %{ \"XADDL  [$mem],$newval\" %}\n+  format %{ \"xaddl_lock  $mem, $newval\" %}\n@@ -8415,1 +8454,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8418,1 +8457,1 @@\n-instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{\n+instruct xaddL_reg_no_res(memory mem, Universe dummy, rRegL add, rFlagsReg cr) %{\n@@ -8422,1 +8461,13 @@\n-  format %{ \"ADDQ  [$mem],$add\" %}\n+  format %{ \"addq_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addq($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddL_imm_no_res(memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddL mem add));\n+  effect(KILL cr);\n+  format %{ \"addq_lock   $mem, $add\" %}\n@@ -8427,1 +8478,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n@@ -8430,1 +8481,2 @@\n-instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{\n+instruct xaddL(memory mem, rRegL newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n@@ -8433,1 +8485,1 @@\n-  format %{ \"XADDQ  [$mem],$newval\" %}\n+  format %{ \"xaddq_lock  $mem, $newval\" %}\n@@ -8438,1 +8490,1 @@\n-  ins_pipe( pipe_cmpxchg );\n+  ins_pipe(pipe_cmpxchg);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":76,"deletions":24,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  char        _index;           \/\/ my section number (SECT_INST, etc.)\n+  int8_t      _index;           \/\/ my section number (SECT_INST, etc.)\n@@ -131,1 +131,1 @@\n-    debug_only(_index = (char)-1);\n+    debug_only(_index = -1);\n@@ -135,1 +135,1 @@\n-  void initialize_outer(CodeBuffer* outer, int index) {\n+  void initialize_outer(CodeBuffer* outer, int8_t index) {\n@@ -183,1 +183,1 @@\n-  int         index() const         { return _index; }\n+  int8_t      index() const         { return _index; }\n@@ -406,1 +406,1 @@\n-  enum {\n+  enum : int8_t {\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1230,1 +1230,2 @@\n-                 reference, LIR_OprFact::intConst(referent_offset), result);\n+                 reference, LIR_OprFact::intConst(referent_offset), result,\n+                 nullptr, info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1646,0 +1646,13 @@\n+\/\/ Check exception if AbortVMOnException flag set\n+JRT_LEAF(void, Runtime1::check_abort_on_vm_exception(oopDesc* ex))\n+  ResourceMark rm;\n+  const char* message = nullptr;\n+  if (ex->is_a(vmClasses::Throwable_klass())) {\n+    oop msg = java_lang_Throwable::message(ex);\n+    if (msg != nullptr) {\n+      message = java_lang_String::as_utf8_string(msg);\n+    }\n+  }\n+  Exceptions::debug_check_abort(ex->klass()->external_name(), message);\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,0 +218,2 @@\n+  static void check_abort_on_vm_exception(oopDesc* ex);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1352,7 +1352,1 @@\n-  if (dyno_loc(ik, loc0)) {\n-    \/\/ TODO: found multiple references, see if we can improve\n-    if (Verbose) {\n-      tty->print_cr(\"existing call site @ %s for %s\",\n-                     loc0, ik->external_name());\n-    }\n-  } else {\n+  if (!dyno_loc(ik, loc0)) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-    mirror()->byte_field_put(fd->offset(), checked_cast<jbyte>(fd->int_initial_value()));\n+    mirror()->byte_field_put(fd->offset(), (jbyte)(fd->int_initial_value()));\n@@ -827,1 +827,1 @@\n-    mirror()->bool_field_put(fd->offset(), checked_cast<jboolean>(fd->int_initial_value()));\n+    mirror()->bool_field_put(fd->offset(), (jboolean)(fd->int_initial_value()));\n@@ -830,1 +830,1 @@\n-    mirror()->char_field_put(fd->offset(), checked_cast<jchar>(fd->int_initial_value()));\n+    mirror()->char_field_put(fd->offset(), (jchar)(fd->int_initial_value()));\n@@ -833,1 +833,1 @@\n-    mirror()->short_field_put(fd->offset(), checked_cast<jshort>(fd->int_initial_value()));\n+    mirror()->short_field_put(fd->offset(), (jshort)(fd->int_initial_value()));\n@@ -2859,1 +2859,1 @@\n-    log_info(class, init)(\"Exception thrown while saving initialization exception %s\",\n+    log_info(class, init)(\"Exception %s thrown while saving initialization exception\",\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -693,1 +693,1 @@\n-  int exception_offset = pc - code_begin();\n+  int exception_offset = int(pc - code_begin());\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,5 +219,5 @@\n-  enum { not_installed = -1, \/\/ in construction, only the owner doing the construction is\n-                             \/\/ allowed to advance state\n-         in_use        = 0,  \/\/ executable nmethod\n-         not_used      = 1,  \/\/ not entrant, but revivable\n-         not_entrant   = 2,  \/\/ marked for deoptimization but activations may still exist\n+  enum : signed char { not_installed = -1, \/\/ in construction, only the owner doing the construction is\n+                                           \/\/ allowed to advance state\n+                       in_use        = 0,  \/\/ executable nmethod\n+                       not_used      = 1,  \/\/ not entrant, but revivable\n+                       not_entrant   = 2,  \/\/ marked for deoptimization but activations may still exist\n@@ -282,1 +282,1 @@\n-  int scopes_data_size() const { return scopes_data_end() - scopes_data_begin(); }\n+  int scopes_data_size() const { return int(scopes_data_end() - scopes_data_begin()); }\n@@ -286,1 +286,1 @@\n-  int scopes_pcs_size() const { return (intptr_t) scopes_pcs_end() - (intptr_t) scopes_pcs_begin(); }\n+  int scopes_pcs_size() const { return int((intptr_t) scopes_pcs_end() - (intptr_t) scopes_pcs_begin()); }\n@@ -295,1 +295,1 @@\n-  int insts_size() const { return insts_end() - insts_begin(); }\n+  int insts_size() const { return int(insts_end() - insts_begin()); }\n@@ -300,1 +300,1 @@\n-  int consts_size() const { return consts_end() - consts_begin(); }\n+  int consts_size() const { return int(consts_end() - consts_begin()); }\n@@ -307,1 +307,1 @@\n-  int stub_size() const { return stub_end() - stub_begin(); }\n+  int stub_size() const { return int(stub_end() - stub_begin()); }\n@@ -312,1 +312,1 @@\n-  int handler_table_size() const { return handler_table_end() - handler_table_begin(); }\n+  int handler_table_size() const { return int(handler_table_end() - handler_table_begin()); }\n@@ -319,1 +319,1 @@\n-  int nul_chk_table_size() const { return nul_chk_table_end() - nul_chk_table_begin(); }\n+  int nul_chk_table_size() const { return int(nul_chk_table_end() - nul_chk_table_begin()); }\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1144,1 +1144,1 @@\n-  int oopmap_slot = nm->oop_maps()->find_slot_for_offset((intptr_t) pc - (intptr_t) nm->code_begin());\n+  int oopmap_slot = nm->oop_maps()->find_slot_for_offset(int((intptr_t) pc - (intptr_t) nm->code_begin()));\n@@ -1286,1 +1286,1 @@\n-bool nmethod::try_transition(int new_state_int) {\n+bool nmethod::try_transition(signed char new_state_int) {\n@@ -1683,1 +1683,1 @@\n-    state &= ~_is_unloading_mask;\n+    state &= (uint8_t)~_is_unloading_mask;\n@@ -1692,2 +1692,2 @@\n-    state &= ~_unloading_cycle_mask;\n-    state |= value << _unloading_cycle_shift;\n+    state &= (uint8_t)~_unloading_cycle_mask;\n+    state |= (uint8_t)(value << _unloading_cycle_shift);\n@@ -2707,1 +2707,1 @@\n-      n = (uintptr_t)cp&(bytes_per_line-1);\n+      n = (int)((uintptr_t)cp & (bytes_per_line-1));\n@@ -2895,1 +2895,1 @@\n-      compressed_format_idx += p - p0;\n+      compressed_format_idx += (int)(p - p0);\n@@ -3178,1 +3178,1 @@\n-  int cont_offset = ImplicitExceptionTable(this).continuation_offset(begin - code_begin());\n+  int cont_offset = ImplicitExceptionTable(this).continuation_offset((uint)(begin - code_begin()));\n@@ -3186,1 +3186,1 @@\n-  int pc_offset = begin - code_begin();\n+  int pc_offset = (int)(begin - code_begin());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-  int code_offset() const { return (address) code_begin() - header_begin(); }\n+  int code_offset() const { return int(code_begin() - header_begin()); }\n@@ -314,1 +314,1 @@\n-  bool try_transition(int new_state);\n+  bool try_transition(signed char new_state);\n@@ -328,1 +328,1 @@\n-  int content_offset() const                  { return content_begin() - header_begin(); }\n+  int content_offset() const                  { return int(content_begin() - header_begin()); }\n@@ -414,3 +414,3 @@\n-  int oops_size         () const                  { return (address)  oops_end         () - (address)  oops_begin         (); }\n-  int metadata_size     () const                  { return (address)  metadata_end     () - (address)  metadata_begin     (); }\n-  int dependencies_size () const                  { return            dependencies_end () -            dependencies_begin (); }\n+  int oops_size         () const                  { return int((address)  oops_end         () - (address)  oops_begin         ()); }\n+  int metadata_size     () const                  { return int((address)  metadata_end     () - (address)  metadata_begin     ()); }\n+  int dependencies_size () const                  { return int(           dependencies_end () -            dependencies_begin ()); }\n@@ -418,2 +418,2 @@\n-  int speculations_size () const                  { return            speculations_end () -            speculations_begin (); }\n-  int jvmci_data_size   () const                  { return            jvmci_data_end   () -            jvmci_data_begin   (); }\n+  int speculations_size () const                  { return int(           speculations_end () -            speculations_begin ()); }\n+  int jvmci_data_size   () const                  { return int(           jvmci_data_end   () -            jvmci_data_begin   ()); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -452,2 +452,2 @@\n-  os::trace_page_sizes(\"Parallel Compact Data\", raw_bytes, raw_bytes, page_sz, rs.base(),\n-                       rs.size());\n+  os::trace_page_sizes(\"Parallel Compact Data\", raw_bytes, raw_bytes, rs.base(),\n+                       rs.size(), page_sz);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,3 +241,8 @@\n-      if (!tq->try_push_to_taskqueue(task)) {\n-        process_popped_location_depth(task);\n-      }\n+      \/\/ In PSCardTable::scavenge_contents_parallel(), when work is distributed\n+      \/\/ among different workers, an object is never split between multiple workers.\n+      \/\/ Therefore, if a worker gets owned a large objArray, it may accumulate\n+      \/\/ many tasks (corresponding to every element in this array) in its\n+      \/\/ task queue. When there are too many overflow tasks, publishing them\n+      \/\/ (via try_push_to_taskqueue()) can incur noticeable overhead in Young GC\n+      \/\/ pause, so it is better to process them locally until large-objArray-splitting is implemented.\n+      process_popped_location_depth(task);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-JVM_Sleep(JNIEnv *env, jclass threadClass, jlong nanos);\n+JVM_SleepNanos(JNIEnv *env, jclass threadClass, jlong nanos);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"oops\/generateOopMap.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -201,0 +201,1 @@\n+  LOG_TAG(unmap) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+OopHandle Universe:: _class_init_stack_overflow_error;\n@@ -620,0 +621,3 @@\n+\n+oop Universe::class_init_out_of_memory_error()         { return out_of_memory_errors()->obj_at(_oom_java_heap); }\n+oop Universe::class_init_stack_overflow_error()        { return _class_init_stack_overflow_error.resolve(); }\n@@ -1050,0 +1054,5 @@\n+  \/\/ Setup preallocated StackOverflowError for use with class initialization failure\n+  k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_StackOverflowError(), true, CHECK_false);\n+  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n+  Universe::_class_init_stack_overflow_error = OopHandle(Universe::vm_global(), instance);\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  static OopHandle    _class_init_stack_overflow_error;\n@@ -322,0 +323,5 @@\n+  \/\/ Saved StackOverflowError and OutOfMemoryError for use when\n+  \/\/ class initialization can't create ExceptionInInitializerError.\n+  static oop class_init_stack_overflow_error();\n+  static oop class_init_out_of_memory_error();\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"interpreter\/bytecodeStream.hpp\"\n@@ -36,0 +35,1 @@\n+class BytecodeStream;\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -1119,4 +1120,1 @@\n-  \/\/ If the initialization error is OOM, this might not work, but if GC kicks in\n-  \/\/ this would be still be helpful.\n-  JavaThread* THREAD = current;\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -1125,2 +1123,14 @@\n-    log_trace(class, init)(\"Initialization error is null for class %s\", external_name());\n-    return;\n+    log_trace(class, init)(\"Unable to create the desired initialization error for class %s\", external_name());\n+\n+    \/\/ We failed to create the new exception, most likely due to either out-of-memory or\n+    \/\/ a stackoverflow error. If the original exception was either of those then we save\n+    \/\/ the shared, pre-allocated, stackless, instance of that exception.\n+    if (exception->klass() == vmClasses::StackOverflowError_klass()) {\n+      log_debug(class, init)(\"Using shared StackOverflowError as initialization error for class %s\", external_name());\n+      init_error = Handle(current, Universe::class_init_stack_overflow_error());\n+    } else if (exception->klass() == vmClasses::OutOfMemoryError_klass()) {\n+      log_debug(class, init)(\"Using shared OutOfMemoryError as initialization error for class %s\", external_name());\n+      init_error = Handle(current, Universe::class_init_out_of_memory_error());\n+    } else {\n+      return;\n+    }\n@@ -1129,1 +1139,1 @@\n-  MutexLocker ml(THREAD, ClassInitError_lock);\n+  MutexLocker ml(current, ClassInitError_lock);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-      set_bci_displacement(row, mdp - dp());\n+      set_bci_displacement(row, checked_cast<int>(mdp - dp()));\n@@ -1019,1 +1019,1 @@\n-  int tag = DataLayout::no_tag;\n+  u1 tag = DataLayout::no_tag;\n@@ -1137,1 +1137,1 @@\n-    data_layout->initialize(tag, stream->bci(), cell_count);\n+    data_layout->initialize(tag, checked_cast<u2>(stream->bci()), cell_count);\n@@ -1357,2 +1357,2 @@\n-  _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n-  _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n+  _invoke_mask = (int)right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n+  _backedge_mask = (int)right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) << InvocationCounter::count_shift;\n@@ -1526,1 +1526,1 @@\n-    temp.initialize(tag, bci, 0);\n+    temp.initialize(tag, checked_cast<u2>(bci), 0);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  enum {\n+  enum : u1 {\n@@ -209,1 +209,1 @@\n-    _header._struct._flags |= (0x1 << flag_number);\n+    _header._struct._flags |= (u1)(0x1 << flag_number);\n@@ -238,1 +238,1 @@\n-  static u8 flag_mask_to_header_mask(uint byte_constant) {\n+  static u8 flag_mask_to_header_mask(u1 byte_constant) {\n@@ -351,1 +351,1 @@\n-  void set_flag_at(int flag_number) {\n+  void set_flag_at(u1 flag_number) {\n@@ -354,1 +354,1 @@\n-  bool flag_at(int flag_number) const {\n+  bool flag_at(u1 flag_number) const {\n@@ -362,1 +362,1 @@\n-  static int flag_number_to_constant(int flag_number) {\n+  static u1 flag_number_to_constant(u1 flag_number) {\n@@ -504,1 +504,1 @@\n-  enum {\n+  enum : u1 {\n@@ -542,1 +542,1 @@\n-  static int null_seen_byte_constant() {\n+  static u1 null_seen_byte_constant() {\n@@ -1144,1 +1144,1 @@\n-    return TypeProfileWidth;\n+    return (uint) TypeProfileWidth;\n@@ -1448,1 +1448,1 @@\n-    return BciProfileWidth;\n+    return (uint) BciProfileWidth;\n@@ -2174,1 +2174,1 @@\n-        _trap_hist._array[reason] = cnt1;\n+        _trap_hist._array[reason] = (u1)cnt1;\n@@ -2426,1 +2426,1 @@\n-  void set_num_loops(int n)                   { _num_loops = n;     }\n+  void set_num_loops(short n)                 { _num_loops = n;     }\n@@ -2428,1 +2428,1 @@\n-  void set_num_blocks(int n)                  { _num_blocks = n;    }\n+  void set_num_blocks(short n)                { _num_blocks = n;    }\n@@ -2490,1 +2490,1 @@\n-    return dp - ((address)_data);\n+    return (int)(dp - ((address)_data));\n@@ -2530,1 +2530,1 @@\n-  int extra_data_size() const          { return (address)extra_data_limit() - (address)extra_data_base(); }\n+  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)extra_data_base()); }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -314,3 +314,4 @@\n-  assert(!mark().is_marked(), \"Attempt to read age from forwarded mark\");\n-  if (has_displaced_mark()) {\n-    return displaced_mark().age();\n+  markWord m = mark();\n+  assert(!m.is_marked(), \"Attempt to read age from forwarded mark\");\n+  if (m.has_displaced_mark_helper()) {\n+    return m.displaced_mark_helper().age();\n@@ -318,1 +319,1 @@\n-    return mark().age();\n+    return m.age();\n@@ -323,3 +324,4 @@\n-  assert(!mark().is_marked(), \"Attempt to increment age of forwarded mark\");\n-  if (has_displaced_mark()) {\n-    set_displaced_mark(displaced_mark().incr_age());\n+  markWord m = mark();\n+  assert(!m.is_marked(), \"Attempt to increment age of forwarded mark\");\n+  if (m.has_displaced_mark_helper()) {\n+    m.set_displaced_mark_helper(m.displaced_mark_helper().incr_age());\n@@ -327,1 +329,1 @@\n-    set_mark(mark().incr_age());\n+    set_mark(m.incr_age());\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-                  _dead_node_list(comp_arena()),\n+                  _unique(0),\n@@ -644,2 +644,4 @@\n-                  _node_arena(mtCompiler),\n-                  _old_arena(mtCompiler),\n+                  _dead_node_list(comp_arena()),\n+                  _node_arena_one(mtCompiler),\n+                  _node_arena_two(mtCompiler),\n+                  _node_arena(&_node_arena_one),\n@@ -940,1 +942,1 @@\n-    _dead_node_list(comp_arena()),\n+    _unique(0),\n@@ -942,2 +944,4 @@\n-    _node_arena(mtCompiler),\n-    _old_arena(mtCompiler),\n+    _dead_node_list(comp_arena()),\n+    _node_arena_one(mtCompiler),\n+    _node_arena_two(mtCompiler),\n+    _node_arena(&_node_arena_one),\n@@ -2418,1 +2422,1 @@\n-          if (Verbose) {\n+          if (PrintOpto && Verbose) {\n@@ -3476,0 +3480,1 @@\n+    print_method(PHASE_FINAL_CODE, 1); \/\/ Compile::_output is not null here\n@@ -3478,2 +3483,0 @@\n-  print_method(PHASE_FINAL_CODE, 1);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -345,0 +345,1 @@\n+  bool                  _clinit_barrier_on_entry; \/\/ True if clinit barrier is needed on nmethod entry\n@@ -347,1 +348,0 @@\n-  bool                  _clinit_barrier_on_entry; \/\/ True if clinit barrier is needed on nmethod entry\n@@ -379,1 +379,0 @@\n-  VectorSet             _dead_node_list;        \/\/ Set of dead nodes\n@@ -382,0 +381,1 @@\n+  VectorSet             _dead_node_list;        \/\/ Set of dead nodes\n@@ -385,2 +385,15 @@\n-  Arena                 _node_arena;            \/\/ Arena for new-space Nodes\n-  Arena                 _old_arena;             \/\/ Arena for old-space Nodes, lifetime during xform\n+  \/\/ Arenas for new-space and old-space nodes.\n+  \/\/ Swapped between using _node_arena.\n+  \/\/ The lifetime of the old-space nodes is during xform.\n+  Arena                 _node_arena_one;\n+  Arena                 _node_arena_two;\n+  Arena*                _node_arena;\n+public:\n+  Arena* swap_old_and_new() {\n+    Arena* filled_arena_ptr = _node_arena;\n+    Arena* old_arena_ptr = old_arena();\n+    old_arena_ptr->destruct_contents();\n+    _node_arena = old_arena_ptr;\n+    return filled_arena_ptr;\n+  }\n+private:\n@@ -830,2 +843,2 @@\n-  Arena*       node_arena()                { return &_node_arena; }\n-  Arena*       old_arena()                 { return &_old_arena; }\n+  Arena*       node_arena()                { return _node_arena; }\n+  Arena*       old_arena()                 { return (&_node_arena_one == _node_arena) ? &_node_arena_two : &_node_arena_one; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -866,1 +866,1 @@\n-      if ((Verbose || WizardMode) && extype->is_loaded()) {\n+      if (PrintOpto && (Verbose || WizardMode) && extype->is_loaded()) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-  Arena *old = C->node_arena()->move_contents(C->old_arena());\n+  Arena* old = C->swap_old_and_new();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3100,0 +3100,5 @@\n+\/\/ This method conservatively checks if the result of a LoadStoreNode is\n+\/\/ used, that is, if it returns true, then it is definitely the case that\n+\/\/ the result of the node is not needed.\n+\/\/ For example, GetAndAdd can be matched into a lock_add instead of a\n+\/\/ lock_xadd if the result of LoadStoreNode::result_not_used() is true\n@@ -3101,1 +3106,1 @@\n-  for( DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++ ) {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n@@ -3103,1 +3108,8 @@\n-    if (x->Opcode() == Op_SCMemProj) continue;\n+    if (x->Opcode() == Op_SCMemProj) {\n+      continue;\n+    }\n+    if (x->bottom_type() == TypeTuple::MEMBAR &&\n+        !x->is_Call() &&\n+        x->Opcode() != Op_Blackhole) {\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -191,0 +191,9 @@\n+    if (obj_or_subklass->bottom_type() == Type::TOP) {\n+      \/\/ The bottom type of obj_or_subklass is TOP, despite its recorded type\n+      \/\/ being an OOP or a klass pointer. This can happen for example in\n+      \/\/ transient scenarios where obj_or_subklass is a projection of the TOP\n+      \/\/ node. In such cases, skip verification to avoid violating the contract\n+      \/\/ of LoadKlassNode::make(). This does not weaken the effect of verify(),\n+      \/\/ as SubTypeCheck nodes with TOP obj_or_subklass inputs are dead anyway.\n+      return true;\n+    }\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1426,3 +1426,2 @@\n-      if ((holder == resolver.Carrier_klass\n-           || holder == vmClasses::VirtualThread_klass()\n-           || holder == vmClasses::Thread_klass())) {\n+      if (holder == vmClasses::Thread_klass()\n+          || holder == resolver.Carrier_klass) {\n@@ -3128,1 +3127,1 @@\n-JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong nanos))\n+JVM_ENTRY(void, JVM_SleepNanos(JNIEnv* env, jclass threadClass, jlong nanos))\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1302,0 +1302,5 @@\n+WB_ENTRY(jboolean, WB_IsDefaultVMFlag(JNIEnv* env, jobject o, jstring name))\n+  const JVMFlag* flag = getVMFlag(thread, env, name);\n+  return (flag != nullptr) && flag->is_default();\n+WB_END\n+\n@@ -2786,0 +2791,1 @@\n+  {CC\"isDefaultVMFlag\",    CC\"(Ljava\/lang\/String;)Z\", (void*)&WB_IsDefaultVMFlag},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -516,1 +516,0 @@\n-  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -524,1 +523,0 @@\n-  { \"G1UsePreventiveGC\",            JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -1941,1 +1939,1 @@\n-#if (defined(X86) || defined(PPC64)) && !defined(ZERO)\n+#if defined(X86) && !defined(ZERO)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-\/\/ EXPERIMENTAL flags are in support of features that are not\n-\/\/    part of the officially supported product, but are available\n+\/\/ EXPERIMENTAL flags are in support of features that may not be\n+\/\/    an officially supported part of a product, but may be available\n@@ -78,0 +78,2 @@\n+\/\/    Refer to the documentation of any products using this code for details\n+\/\/    on support and fitness for production.\n@@ -83,2 +85,1 @@\n-\/\/    and they are not supported on production loads, except under explicit\n-\/\/    direction from support engineers.\n+\/\/    Refer to the documentation of any products using this code for details.\n@@ -1130,1 +1131,1 @@\n-  product(intx, TypeProfileArgsLimit,     2,                                \\\n+  product(int, TypeProfileArgsLimit,     2,                                 \\\n@@ -1134,1 +1135,1 @@\n-  product(intx, TypeProfileParmsLimit,    2,                                \\\n+  product(int, TypeProfileParmsLimit,    2,                                 \\\n@@ -1397,1 +1398,1 @@\n-  product(intx, SpecTrapLimitExtraEntries,  3, EXPERIMENTAL,                \\\n+  product(int, SpecTrapLimitExtraEntries,  3, EXPERIMENTAL,                 \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -530,1 +530,1 @@\n-  \/* StubRoutines (NOTE: incomplete) *\/                                                                                              \\\n+  \/* StubRoutine for stack walking.  *\/                                                                                              \\\n@@ -533,69 +533,0 @@\n-     static_field(StubRoutines,                _verify_oop_count,                             jint)                                  \\\n-     static_field(StubRoutines,                _aescrypt_encryptBlock,                        address)                               \\\n-     static_field(StubRoutines,                _aescrypt_decryptBlock,                        address)                               \\\n-     static_field(StubRoutines,                _cipherBlockChaining_encryptAESCrypt,          address)                               \\\n-     static_field(StubRoutines,                _cipherBlockChaining_decryptAESCrypt,          address)                               \\\n-     static_field(StubRoutines,                _electronicCodeBook_encryptAESCrypt,           address)                               \\\n-     static_field(StubRoutines,                _electronicCodeBook_decryptAESCrypt,           address)                               \\\n-     static_field(StubRoutines,                _counterMode_AESCrypt,                         address)                               \\\n-     static_field(StubRoutines,                _galoisCounterMode_AESCrypt,                   address)                               \\\n-     static_field(StubRoutines,                _ghash_processBlocks,                          address)                               \\\n-     static_field(StubRoutines,                _chacha20Block,                                address)                               \\\n-     static_field(StubRoutines,                _base64_encodeBlock,                           address)                               \\\n-     static_field(StubRoutines,                _base64_decodeBlock,                           address)                               \\\n-     static_field(StubRoutines,                _poly1305_processBlocks,                       address)                               \\\n-     static_field(StubRoutines,                _updateBytesCRC32,                             address)                               \\\n-     static_field(StubRoutines,                _crc_table_adr,                                address)                               \\\n-     static_field(StubRoutines,                _crc32c_table_addr,                            address)                               \\\n-     static_field(StubRoutines,                _updateBytesCRC32C,                            address)                               \\\n-     static_field(StubRoutines,                _updateBytesAdler32,                           address)                               \\\n-     static_field(StubRoutines,                _multiplyToLen,                                address)                               \\\n-     static_field(StubRoutines,                _squareToLen,                                  address)                               \\\n-     static_field(StubRoutines,                _bigIntegerRightShiftWorker,                   address)                               \\\n-     static_field(StubRoutines,                _bigIntegerLeftShiftWorker,                    address)                               \\\n-     static_field(StubRoutines,                _mulAdd,                                       address)                               \\\n-     static_field(StubRoutines,                _dexp,                                         address)                               \\\n-     static_field(StubRoutines,                _dlog,                                         address)                               \\\n-     static_field(StubRoutines,                _dlog10,                                       address)                               \\\n-     static_field(StubRoutines,                _dpow,                                         address)                               \\\n-     static_field(StubRoutines,                _fmod,                                         address)                               \\\n-     static_field(StubRoutines,                _dsin,                                         address)                               \\\n-     static_field(StubRoutines,                _dcos,                                         address)                               \\\n-     static_field(StubRoutines,                _dtan,                                         address)                               \\\n-     static_field(StubRoutines,                _vectorizedMismatch,                           address)                               \\\n-     static_field(StubRoutines,                _jbyte_arraycopy,                              address)                               \\\n-     static_field(StubRoutines,                _jshort_arraycopy,                             address)                               \\\n-     static_field(StubRoutines,                _jint_arraycopy,                               address)                               \\\n-     static_field(StubRoutines,                _jlong_arraycopy,                              address)                               \\\n-     static_field(StubRoutines,                _oop_arraycopy,                                address)                               \\\n-     static_field(StubRoutines,                _oop_arraycopy_uninit,                         address)                               \\\n-     static_field(StubRoutines,                _jbyte_disjoint_arraycopy,                     address)                               \\\n-     static_field(StubRoutines,                _jshort_disjoint_arraycopy,                    address)                               \\\n-     static_field(StubRoutines,                _jint_disjoint_arraycopy,                      address)                               \\\n-     static_field(StubRoutines,                _jlong_disjoint_arraycopy,                     address)                               \\\n-     static_field(StubRoutines,                _oop_disjoint_arraycopy,                       address)                               \\\n-     static_field(StubRoutines,                _oop_disjoint_arraycopy_uninit,                address)                               \\\n-     static_field(StubRoutines,                _arrayof_jbyte_arraycopy,                      address)                               \\\n-     static_field(StubRoutines,                _arrayof_jshort_arraycopy,                     address)                               \\\n-     static_field(StubRoutines,                _arrayof_jint_arraycopy,                       address)                               \\\n-     static_field(StubRoutines,                _arrayof_jlong_arraycopy,                      address)                               \\\n-     static_field(StubRoutines,                _arrayof_oop_arraycopy,                        address)                               \\\n-     static_field(StubRoutines,                _arrayof_oop_arraycopy_uninit,                 address)                               \\\n-     static_field(StubRoutines,                _arrayof_jbyte_disjoint_arraycopy,             address)                               \\\n-     static_field(StubRoutines,                _arrayof_jshort_disjoint_arraycopy,            address)                               \\\n-     static_field(StubRoutines,                _arrayof_jint_disjoint_arraycopy,              address)                               \\\n-     static_field(StubRoutines,                _arrayof_jlong_disjoint_arraycopy,             address)                               \\\n-     static_field(StubRoutines,                _arrayof_oop_disjoint_arraycopy,               address)                               \\\n-     static_field(StubRoutines,                _arrayof_oop_disjoint_arraycopy_uninit,        address)                               \\\n-     static_field(StubRoutines,                _checkcast_arraycopy,                          address)                               \\\n-     static_field(StubRoutines,                _checkcast_arraycopy_uninit,                   address)                               \\\n-     static_field(StubRoutines,                _unsafe_arraycopy,                             address)                               \\\n-     static_field(StubRoutines,                _generic_arraycopy,                            address)                               \\\n-                                                                                                                                     \\\n-  \/*****************\/                                                                                                                \\\n-  \/* SharedRuntime *\/                                                                                                                \\\n-  \/*****************\/                                                                                                                \\\n-                                                                                                                                     \\\n-     static_field(SharedRuntime,               _wrong_method_blob,                            RuntimeStub*)                          \\\n-     static_field(SharedRuntime,               _ic_miss_blob,                                 RuntimeStub*)                          \\\n-     static_field(SharedRuntime,               _deopt_blob,                                   DeoptimizationBlob*)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":70,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1466,6 +1466,1 @@\n-        if (!breaksOutOf(tree, tree.body)) {\n-            \/\/include condition's body when false after the while, if cannot get out of the loop\n-            MatchBindings condBindings = matchBindings;\n-            condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);\n-            condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);\n-        }\n+        handleLoopConditionBindings(matchBindings, tree, tree.body);\n@@ -1485,5 +1480,1 @@\n-        if (!breaksOutOf(tree, tree.body)) {\n-            \/\/include condition's bindings when false after the while, if cannot get out of the loop\n-            condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);\n-            condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);\n-        }\n+        handleLoopConditionBindings(condBindings, tree, tree.body);\n@@ -1493,5 +1484,0 @@\n-    private boolean breaksOutOf(JCTree loop, JCTree body) {\n-        preFlow(body);\n-        return flow.breaksOutOf(env, loop, body, make);\n-    }\n-\n@@ -1522,4 +1508,12 @@\n-        if (!breaksOutOf(tree, tree.body)) {\n-            \/\/include condition's body when false after the while, if cannot get out of the loop\n-            condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);\n-            condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);\n+        handleLoopConditionBindings(condBindings, tree, tree.body);\n+    }\n+\n+    \/**\n+     * Include condition's bindings when false after the loop, if cannot get out of the loop\n+     *\/\n+    private void handleLoopConditionBindings(MatchBindings condBindings,\n+                                             JCStatement loop,\n+                                             JCStatement loopBody) {\n+        if (condBindings.bindingsWhenFalse.nonEmpty() &&\n+            !breaksTo(env, loop, loopBody)) {\n+            addBindings2Scope(loop, condBindings.bindingsWhenFalse);\n@@ -1529,0 +1523,31 @@\n+    private boolean breaksTo(Env<AttrContext> env, JCTree loop, JCTree body) {\n+        preFlow(body);\n+        return flow.breaksToTree(env, loop, body, make);\n+    }\n+\n+    \/**\n+     * Add given bindings to the current scope, unless there's a break to\n+     * an immediately enclosing labeled statement.\n+     *\/\n+    private void addBindings2Scope(JCStatement introducingStatement,\n+                                   List<BindingSymbol> bindings) {\n+        if (bindings.isEmpty()) {\n+            return ;\n+        }\n+\n+        var searchEnv = env;\n+        while (searchEnv.tree instanceof JCLabeledStatement labeled &&\n+               labeled.body == introducingStatement) {\n+            if (breaksTo(env, labeled, labeled.body)) {\n+                \/\/breaking to an immediately enclosing labeled statement\n+                return ;\n+            }\n+            searchEnv = searchEnv.next;\n+            introducingStatement = labeled;\n+        }\n+\n+        \/\/include condition's body when false after the while, if cannot get out of the loop\n+        bindings.forEach(env.info.scope::enter);\n+        bindings.forEach(BindingSymbol::preserveBinding);\n+    }\n+\n@@ -2263,2 +2288,1 @@\n-        afterIfBindings.forEach(env.info.scope::enter);\n-        afterIfBindings.forEach(BindingSymbol::preserveBinding);\n+        addBindings2Scope(tree, afterIfBindings);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":46,"deletions":22,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-    public boolean breaksOutOf(Env<AttrContext> env, JCTree loop, JCTree body, TreeMaker make) {\n+    public boolean breaksToTree(Env<AttrContext> env, JCTree breakTo, JCTree body, TreeMaker make) {\n@@ -300,1 +300,1 @@\n-            SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();\n+            SnippetBreakToAnalyzer analyzer = new SnippetBreakToAnalyzer(breakTo);\n@@ -303,1 +303,1 @@\n-            return analyzer.breaksOut();\n+            return analyzer.breaksTo();\n@@ -1914,3 +1914,3 @@\n-    class SnippetBreakAnalyzer extends AliveAnalyzer {\n-        private final Set<JCTree> seenTrees = new HashSet<>();\n-        private boolean breaksOut;\n+    class SnippetBreakToAnalyzer extends AliveAnalyzer {\n+        private final JCTree breakTo;\n+        private boolean breaksTo;\n@@ -1918,31 +1918,2 @@\n-        public SnippetBreakAnalyzer() {\n-        }\n-\n-        @Override\n-        public void visitLabelled(JCTree.JCLabeledStatement tree) {\n-            seenTrees.add(tree);\n-            super.visitLabelled(tree);\n-        }\n-\n-        @Override\n-        public void visitWhileLoop(JCTree.JCWhileLoop tree) {\n-            seenTrees.add(tree);\n-            super.visitWhileLoop(tree);\n-        }\n-\n-        @Override\n-        public void visitForLoop(JCTree.JCForLoop tree) {\n-            seenTrees.add(tree);\n-            super.visitForLoop(tree);\n-        }\n-\n-        @Override\n-        public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n-            seenTrees.add(tree);\n-            super.visitForeachLoop(tree);\n-        }\n-\n-        @Override\n-        public void visitDoLoop(JCTree.JCDoWhileLoop tree) {\n-            seenTrees.add(tree);\n-            super.visitDoLoop(tree);\n+        public SnippetBreakToAnalyzer(JCTree breakTo) {\n+            this.breakTo = breakTo;\n@@ -1953,3 +1924,1 @@\n-            breaksOut |= (super.alive == Liveness.ALIVE &&\n-                          !seenTrees.contains(tree.target));\n-            super.visitBreak(tree);\n+            breaksTo |= breakTo == tree.target && super.alive == Liveness.ALIVE;\n@@ -1958,2 +1927,2 @@\n-        public boolean breaksOut() {\n-            return breaksOut;\n+        public boolean breaksTo() {\n+            return breaksTo;\n@@ -3303,1 +3272,1 @@\n-                    sym.pos < currentTree.getStartPosition()) {\n+                    sym.pos < getCurrentTreeStartPosition()) {\n@@ -3315,0 +3284,5 @@\n+        int getCurrentTreeStartPosition() {\n+            return currentTree instanceof JCCase cse ? cse.guard.getStartPosition()\n+                                                     : currentTree.getStartPosition();\n+        }\n+\n@@ -3571,3 +3545,1 @@\n-            Type type = types.isSubtype(selectorType, syms.objectType)\n-                    ? selectorType : syms.objectType;\n-            return new BindingPattern(type);\n+            return new BindingPattern(selectorType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":18,"deletions":46,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -974,0 +974,7 @@\n+\n+            \/\/ In case an Abort was thrown before processAnnotations could be called,\n+            \/\/ we could have deferred diagnostics that haven't been reported.\n+            if (deferredDiagnosticHandler != null) {\n+                deferredDiagnosticHandler.reportDeferredDiagnostics();\n+                log.popDiagnosticHandler(deferredDiagnosticHandler);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4098,0 +4098,1 @@\n+                    checkSourceLevel(token.pos, Feature.UNNAMED_CLASSES);\n@@ -4128,2 +4129,0 @@\n-        checkSourceLevel(Feature.UNNAMED_CLASSES);\n-\n@@ -4143,1 +4142,1 @@\n-        int primaryPos = defs.first().pos;\n+        int primaryPos = getStartPos(defs.first());\n@@ -4154,1 +4153,1 @@\n-        JCModifiers unnamedMods = F.at(primaryPos)\n+        JCModifiers unnamedMods = F.at(Position.NOPOS)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n+compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64,generic-i586\n@@ -60,1 +60,1 @@\n-compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n+compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64,generic-i586\n@@ -63,2 +63,2 @@\n-compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n-compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n+compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64,generic-i586\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -812,0 +812,5 @@\n+    public static final String NOP = PREFIX + \"NOP\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(NOP, \"Nop\");\n+    }\n+\n@@ -1549,0 +1554,60 @@\n+    public static final String X86_LOCK_ADDB_REG = PREFIX + \"X86_LOCK_ADDB_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDB_REG, \"xaddB_reg_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_ADDB_IMM = PREFIX + \"X86_LOCK_ADDB_IMM\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDB_IMM, \"xaddB_imm_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_XADDB = PREFIX + \"X86_LOCK_XADDB\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_XADDB, \"xaddB\");\n+    }\n+\n+    public static final String X86_LOCK_ADDS_REG = PREFIX + \"X86_LOCK_ADDS_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDS_REG, \"xaddS_reg_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_ADDS_IMM = PREFIX + \"X86_LOCK_ADDS_IMM\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDS_IMM, \"xaddS_imm_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_XADDS = PREFIX + \"X86_LOCK_XADDS\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_XADDS, \"xaddS\");\n+    }\n+\n+    public static final String X86_LOCK_ADDI_REG = PREFIX + \"X86_LOCK_ADDI_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDI_REG, \"xaddI_reg_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_ADDI_IMM = PREFIX + \"X86_LOCK_ADDI_IMM\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDI_IMM, \"xaddI_imm_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_XADDI = PREFIX + \"X86_LOCK_XADDI\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_XADDI, \"xaddI\");\n+    }\n+\n+    public static final String X86_LOCK_ADDL_REG = PREFIX + \"X86_LOCK_ADDL_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDL_REG, \"xaddL_reg_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_ADDL_IMM = PREFIX + \"X86_LOCK_ADDL_IMM\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_ADDL_IMM, \"xaddL_imm_no_res\");\n+    }\n+\n+    public static final String X86_LOCK_XADDL = PREFIX + \"X86_LOCK_XADDL\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_LOCK_XADDL, \"xaddL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -490,2 +490,0 @@\n-java\/lang\/ScopedValue\/StressStackOverflow.java                  8303498 linux-s390x\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.function.Predicate;\n@@ -297,0 +298,3 @@\n+        Predicate<GC> vmGCProperty = (GC gc) -> (gc.isSupported()\n+                                        && (!isJVMCIEnabled || gc.isSupportedByJVMCICompiler())\n+                                        && (gc.isSelected() || GC.isSelectedErgonomically()));\n@@ -298,4 +302,1 @@\n-            map.put(\"vm.gc.\" + gc.name(),\n-                    () -> \"\" + (gc.isSupported()\n-                            && (!isJVMCIEnabled || gc.isSupportedByJVMCICompiler())\n-                            && (gc.isSelected() || GC.isSelectedErgonomically())));\n+            map.put(\"vm.gc.\" + gc.name(), () -> \"\" + vmGCProperty.test(gc));\n@@ -303,0 +304,11 @@\n+\n+        \/\/ Special handling for ZGC modes\n+        var vmGCZ = vmGCProperty.test(GC.Z);\n+        var genZ = WB.getBooleanVMFlag(\"ZGenerational\");\n+        var genZIsDefault = WB.isDefaultVMFlag(\"ZGenerational\");\n+        \/\/ vm.gc.ZGenerational=true means:\n+        \/\/    vm.gc.Z is true and ZGenerational is either explicitly true, or default\n+        map.put(\"vm.gc.ZGenerational\", () -> \"\" + (vmGCZ && (genZ || genZIsDefault)));\n+        \/\/ vm.gc.ZSinglegen=true means:\n+        \/\/    vm.gc.Z is true and ZGenerational is either explicitly false, or default\n+        map.put(\"vm.gc.ZSinglegen\", () -> \"\" + (vmGCZ && (!genZ || genZIsDefault)));\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -638,0 +638,1 @@\n+  public native boolean isDefaultVMFlag(String name);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}