{"files":[{"patch":"@@ -793,3 +793,2 @@\n-    \/\/ FIXME: VectorBoxes are neither scalarized nor buffered upfront, currently buffering happens during\n-    \/\/ box expansions if they are live after box-unbox optimizations. This can be optimized by removing\n-    \/\/ VectorBoxAllocation IR altogether.\n+    \/\/ Upfront buffering for VectorBox may cause problems in sweeping allocation\n+    \/\/ graph pallets if boxes are removed during unbox-box optimization.\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2605,1 +2605,1 @@\n-    progress = merge_through_phi(this, phase->is_IterGVN());\n+    progress = merge_through_phi(this, phase);\n@@ -2639,1 +2639,1 @@\n-      } else if (def->Opcode() == Op_VectorBox) { \/\/ leaf\n+      } else if (def->is_InlineType()) { \/\/ leaf\n@@ -2656,1 +2656,2 @@\n-Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {\n+Node* PhiNode::merge_through_phi(Node* root_phi, PhaseGVN *phase) {\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -2699,0 +2700,12 @@\n+\n+  ciInlineKlass* vk = static_cast<ciInlineKlass*>(btype->inline_klass());\n+  ciInlineKlass* payload = vk->declared_nonstatic_field_at(0)->type()->as_inline_klass();\n+\n+  Node* payload_oop = payload->is_initialized() ? InlineTypeNode::default_oop(*igvn, payload) : igvn->zerocon(T_PRIMITIVE_OBJECT);\n+  Node* payload_value = InlineTypeNode::make_uninitialized(*igvn, payload, true);\n+\n+  Node* new_payload_phi = igvn->transform(clone_through_phi(root_phi, payload_value->bottom_type(), 3, igvn));\n+  Node* new_vector_phi = igvn->transform(clone_through_phi(new_payload_phi, vtype, 3, igvn));\n+  payload_value->as_InlineType()->set_field_value(0, new_vector_phi);\n+  payload_value = igvn->transform(payload_value);\n+\n@@ -2700,2 +2713,7 @@\n-  Node* new_vect_phi = clone_through_phi(root_phi, vtype, 3, igvn);\n-  return VectorBoxNode::make_box_node(*igvn, igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n+  Node* new_box_node = new VectorBoxNode(phase->C, vk, NULL, btype, vtype, false, vk->is_empty() && vk->is_initialized());\n+  new_box_node->as_InlineType()->set_is_init(*igvn);\n+  new_box_node->as_InlineType()->set_oop(new_vbox_phi);\n+  new_box_node->as_InlineType()->set_is_buffered();\n+  new_box_node->as_InlineType()->set_field_value(0, payload_value);\n+  new_box_node = igvn->transform(new_box_node);\n+  return new_box_node;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  static Node* merge_through_phi(Node* root_phi, PhaseIterGVN* igvn);\n+  static Node* merge_through_phi(Node* root_phi, PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-class VectorBoxAllocateNode;\n@@ -648,1 +647,0 @@\n-              DEFINE_CLASS_ID(VectorBoxAllocate, CallStaticJava, 0)\n@@ -960,1 +958,0 @@\n-  DEFINE_CLASS_QUERY(VectorBoxAllocate)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -317,3 +317,8 @@\n-    Node* vbox_alloc = vec_box->get_oop();\n-    assert(vbox_alloc->is_Proj() && vbox_alloc->in(0)->isa_VectorBoxAllocate(), \"\");\n-    VectorBoxAllocateNode* vba = vbox_alloc->in(0)->as_VectorBoxAllocate();\n+    Node* vbox = vec_box->get_oop();\n+    Node* vect = vec_box->get_vec();\n+    Node* result = expand_vbox_node_helper(vec_box, vbox, vect, vec_box->box_type(), vec_box->vec_type());\n+    C->gvn_replace_by(vec_box, result);\n+    C->print_method(PHASE_EXPAND_VBOX, 3, vec_box);\n+  }\n+  C->remove_macro_node(vec_box);\n+}\n@@ -321,2 +326,38 @@\n-    JVMState* jvms = clone_jvms(C, vba);\n-    GraphKit kit(jvms);\n+Node* PhaseVector::expand_vbox_node_helper(Node* vec_box,\n+                                           Node* vbox,\n+                                           Node* vect,\n+                                           const TypeInstPtr* box_type,\n+                                           const TypeVect* vect_type) {\n+  if (vbox->is_Phi() && vect->is_Phi()) {\n+    assert(vbox->as_Phi()->region() == vect->as_Phi()->region(), \"\");\n+    Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);\n+    for (uint i = 1; i < vbox->req(); i++) {\n+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect->in(i), box_type, vect_type);\n+      new_phi->set_req(i, new_box);\n+    }\n+    new_phi = C->initial_gvn()->transform(new_phi);\n+    return new_phi;\n+  } else if (vbox->is_Phi() && (vect->is_Vector() || vect->is_LoadVector())) {\n+    \/\/ Handle the case when the allocation input to VectorBoxNode is a phi\n+    \/\/ but the vector input is not, which can definitely be the case if the\n+    \/\/ vector input has been value-numbered. It seems to be safe to do by\n+    \/\/ construction because VectorBoxNode and VectorBoxAllocate come in a\n+    \/\/ specific order as a result of expanding an intrinsic call. After that, if\n+    \/\/ any of the inputs to VectorBoxNode are value-numbered they can only\n+    \/\/ move up and are guaranteed to dominate.\n+    Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);\n+    for (uint i = 1; i < vbox->req(); i++) {\n+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect, box_type, vect_type);\n+      new_phi->set_req(i, new_box);\n+    }\n+    new_phi = C->initial_gvn()->transform(new_phi);\n+    return new_phi;\n+  } else if (vbox->is_Proj() && vbox->in(0)->Opcode() == Op_VectorBoxAllocate) {\n+    VectorBoxAllocateNode* vbox_alloc = static_cast<VectorBoxAllocateNode*>(vbox->in(0));\n+    return expand_vbox_alloc_node(vbox_alloc, vect, box_type, vect_type);\n+  } else {\n+    assert(!vbox->is_Phi(), \"\");\n+    \/\/ TODO: assert that expanded vbox is initialized with the same value (vect).\n+    return vbox; \/\/ already expanded\n+  }\n+}\n@@ -324,4 +365,27 @@\n-    ciInlineKlass* vk = vec_box->inline_klass();\n-    Node* klass_node = kit.makecon(TypeKlassPtr::make(vk));\n-    Node* alloc_oop  = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true);\n-    vec_box->store(&kit, alloc_oop, alloc_oop, vk);\n+Node* PhaseVector::expand_vbox_alloc_node_vector(VectorBoxAllocateNode* vbox_alloc,\n+                                                 Node* value,\n+                                                 const TypeInstPtr* box_type,\n+                                                 const TypeVect* vect_type) {\n+  JVMState* jvms = clone_jvms(C, vbox_alloc);\n+  GraphKit kit(jvms);\n+  PhaseGVN& gvn = kit.gvn();\n+\n+  ciInlineKlass* box_klass = static_cast<ciInlineKlass*>(box_type->inline_klass());\n+\n+  BasicType bt = vect_type->element_basic_type();\n+  int num_elem = vect_type->length();\n+  int elem_size = type2aelembytes(bt);\n+\n+  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n+  Node* klass_node = kit.makecon(klass_type);\n+  Node* buffer_mem = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true);\n+\n+  assert(VectorSupport::is_vector(box_klass), \"\");\n+  ciField* payload_field = box_klass->declared_nonstatic_field_at(0);\n+  int offset = payload_field->offset();\n+  if (!payload_field->is_flattened()) {\n+    ciInlineKlass* payload_klass = static_cast<ciInlineKlass*>(payload_field->type());\n+    assert(VectorSupport::is_vector_payload_mf(payload_klass), \"\");\n+    ciField* mutifield = payload_klass->declared_nonstatic_field_at(0);\n+    offset += mutifield->offset();\n+  }\n@@ -329,5 +393,16 @@\n-    \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n-    \/\/ store that would make this buffer accessible by other threads.\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &kit.gvn());\n-    assert(alloc != NULL, \"must have an allocation node\");\n-    kit.insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+  Node* buffer_start_adr = kit.basic_plus_adr(buffer_mem, offset);\n+  const TypePtr* buffer_adr_type = buffer_start_adr->bottom_type()->is_ptr();\n+  Node* buffer_mem_start = kit.memory(buffer_start_adr);\n+  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n+                                                     kit.control(),\n+                                                     buffer_mem_start,\n+                                                     buffer_start_adr,\n+                                                     buffer_adr_type,\n+                                                     value,\n+                                                     num_elem));\n+  kit.set_memory(vstore, buffer_adr_type);\n+\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));\n+\n+  kit.replace_call(vbox_alloc, buffer_mem, true);\n+  C->remove_macro_node(vbox_alloc);\n@@ -335,2 +410,2 @@\n-    kit.replace_call(vba, alloc_oop, true);\n-    C->remove_macro_node(vba);\n+  return buffer_mem;\n+}\n@@ -338,2 +413,85 @@\n-    C->gvn_replace_by(vec_box, alloc_oop);\n-    C->print_method(PHASE_EXPAND_VBOX, 3, vec_box);\n+\/\/ FIXME: To be removed when mask and shuffle use multi-field backed storage.\n+\/\/ Since intrinsification is skipped upfront for  mask\/shuffle related operations\n+\/\/ this is anyways a dead code currently.\n+Node* PhaseVector::expand_vbox_alloc_node_mask_shuffle(VectorBoxAllocateNode* vbox_alloc,\n+                                                       Node* value,\n+                                                       const TypeInstPtr* box_type,\n+                                                       const TypeVect* vect_type) {\n+  JVMState* jvms = clone_jvms(C, vbox_alloc);\n+  GraphKit kit(jvms);\n+  PhaseGVN& gvn = kit.gvn();\n+\n+  ciInstanceKlass* box_klass = box_type->instance_klass();\n+  BasicType bt = vect_type->element_basic_type();\n+  int num_elem = vect_type->length();\n+\n+  bool is_mask = is_vector_mask(box_klass);\n+  \/\/ If boxed mask value is present in a predicate register, it must be\n+  \/\/ spilled to a vector though a VectorStoreMaskOperation before actual StoreVector\n+  \/\/ operation to vector payload field.\n+  if (is_mask && (value->bottom_type()->isa_vectmask() || bt != T_BOOLEAN)) {\n+    value = gvn.transform(VectorStoreMaskNode::make(gvn, value, bt, num_elem));\n+    \/\/ Although type of mask depends on its definition, in terms of storage everything is stored in boolean array.\n+    bt = T_BOOLEAN;\n+    assert(value->bottom_type()->is_vect()->element_basic_type() == bt,\n+           \"must be consistent with mask representation\");\n+  }\n+\n+  \/\/ Generate array allocation for the field which holds the values.\n+  const TypeKlassPtr* array_klass = TypeKlassPtr::make(ciTypeArrayKlass::make(bt));\n+  Node* arr = kit.new_array(kit.makecon(array_klass), kit.intcon(num_elem), 1);\n+\n+  \/\/ Store the vector value into the array.\n+  \/\/ (The store should be captured by InitializeNode and turned into initialized store later.)\n+  Node* arr_adr = kit.array_element_address(arr, kit.intcon(0), bt);\n+  const TypePtr* arr_adr_type = arr_adr->bottom_type()->is_ptr();\n+  Node* arr_mem = kit.memory(arr_adr);\n+  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n+                                                     kit.control(),\n+                                                     arr_mem,\n+                                                     arr_adr,\n+                                                     arr_adr_type,\n+                                                     value,\n+                                                     num_elem));\n+  kit.set_memory(vstore, arr_adr_type);\n+\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));\n+\n+  \/\/ Generate the allocate for the Vector object.\n+  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n+  Node* klass_node = kit.makecon(klass_type);\n+  Node* vec_obj = kit.new_instance(klass_node);\n+\n+  \/\/ Store the allocated array into object.\n+  ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n+                                                                                     ciSymbols::object_signature(),\n+                                                                                     false);\n+  assert(field != NULL, \"\");\n+  Node* vec_field = kit.basic_plus_adr(vec_obj, field->offset_in_bytes());\n+  const TypePtr* vec_adr_type = vec_field->bottom_type()->is_ptr();\n+\n+  \/\/ The store should be captured by InitializeNode and turned into initialized store later.\n+  Node* field_store = gvn.transform(kit.access_store_at(vec_obj,\n+                                                        vec_field,\n+                                                        vec_adr_type,\n+                                                        arr,\n+                                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n+                                                        T_OBJECT,\n+                                                        IN_HEAP));\n+  kit.set_memory(field_store, vec_adr_type);\n+\n+  kit.replace_call(vbox_alloc, vec_obj, true);\n+  C->remove_macro_node(vbox_alloc);\n+\n+  return vec_obj;\n+}\n+\n+Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n+                                          Node* value,\n+                                          const TypeInstPtr* box_type,\n+                                          const TypeVect* vect_type) {\n+  ciInstanceKlass* box_klass = box_type->instance_klass();\n+  if (is_vector(box_klass)) {\n+    return expand_vbox_alloc_node_vector(vbox_alloc, value, box_type, vect_type);\n+  } else {\n+    return expand_vbox_alloc_node_mask_shuffle(vbox_alloc, value, box_type, vect_type);\n@@ -341,1 +499,0 @@\n-  C->remove_macro_node(vec_box);\n@@ -355,1 +512,1 @@\n-void PhaseVector::expand_vunbox_node_mf(VectorUnboxNode* vec_unbox) {\n+void PhaseVector::expand_vunbox_node_vector(VectorUnboxNode* vec_unbox) {\n@@ -360,9 +517,0 @@\n-    Node* obj = vec_unbox->obj();\n-    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n-    ciInstanceKlass* from_kls = tinst->instance_klass();\n-    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n-    BasicType bt = vt->element_basic_type();\n-    BasicType masktype = bt;\n-    int num_elem = vt->length();\n-\n-    int elem_size = type2aelembytes(bt);\n@@ -370,0 +518,1 @@\n+\n@@ -371,4 +520,18 @@\n-      assert(obj->isa_InlineType(), \"\");\n-      ciSymbol* payload_sig = ciSymbol::make(VectorSupport::get_vector_payload_field_signature(bt, num_elem)->as_C_string());\n-      ciSymbol* payload_name = ciSymbol::make(vmSymbols::payload_name()->as_C_string());\n-      ciField* payload = from_kls->get_field_by_name(payload_name, payload_sig, false);\n+      Node* obj = vec_unbox->obj();\n+      const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n+      assert(VectorSupport::is_vector(tinst->instance_klass()), \"\");\n+      ciInlineKlass* box_klass = static_cast<ciInlineKlass*>(tinst->instance_klass());\n+\n+      const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n+      BasicType bt = vt->element_basic_type();\n+      int num_elem = vt->length();\n+\n+      assert(VectorSupport::is_vector(box_klass), \"\");\n+      ciField* payload_field = box_klass->declared_nonstatic_field_at(0);\n+      int offset = payload_field->offset();\n+      if (!payload_field->is_flattened()) {\n+        ciInlineKlass* payload_klass = static_cast<ciInlineKlass*>(payload_field->type());\n+        assert(VectorSupport::is_vector_payload_mf(payload_klass), \"\");\n+        ciField* mutifield = payload_klass->declared_nonstatic_field_at(0);\n+        offset += mutifield->offset();\n+      }\n@@ -378,2 +541,1 @@\n-      Node* vec_adr = gvn.transform(kit.basic_plus_adr(obj, payload->offset()));\n-\n+      Node* vec_adr = gvn.transform(kit.basic_plus_adr(obj, offset));\n@@ -382,1 +544,0 @@\n-      int num_elem = vt->length();\n@@ -393,2 +554,1 @@\n-    C->set_max_vector_size(MAX2(C->max_vector_size(), vt->length_in_bytes()));\n-\n+    C->set_max_vector_size(MAX2(C->max_vector_size(), vec_val_load->bottom_type()->is_vect()->length_in_bytes()));\n@@ -402,1 +562,4 @@\n-void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {\n+\/\/ FIXME: To be removed when mask and shuffle use multi-field backed storage.\n+\/\/ Since intrinsification is skipped upfront for mask\/shuffle related operations\n+\/\/ this is anyways a dead code currently.\n+void PhaseVector::expand_vunbox_node_mask_shuffle(VectorUnboxNode* vec_unbox) {\n@@ -414,4 +577,0 @@\n-    if (is_vector(from_kls)) {\n-      return expand_vunbox_node_mf(vec_unbox);\n-    }\n-\n@@ -478,0 +637,17 @@\n+void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {\n+  if (vec_unbox->outcnt() > 0) {\n+    GraphKit kit;\n+    PhaseGVN& gvn = kit.gvn();\n+    Node* obj = vec_unbox->obj();\n+    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n+    ciInstanceKlass* from_kls = tinst->instance_klass();\n+\n+    if (is_vector(from_kls)) {\n+      return expand_vunbox_node_vector(vec_unbox);\n+    } else {\n+      return expand_vunbox_node_mask_shuffle(vec_unbox);\n+    }\n+  }\n+  C->remove_macro_node(vec_unbox);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":219,"deletions":43,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -44,0 +44,16 @@\n+\n+  Node* expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n+                               Node* value,\n+                               const TypeInstPtr* box_type,\n+                               const TypeVect* vect_type);\n+\n+  Node* expand_vbox_alloc_node_vector(VectorBoxAllocateNode* vbox_alloc,\n+                                      Node* value,\n+                                      const TypeInstPtr* box_type,\n+                                      const TypeVect* vect_type);\n+\n+  Node* expand_vbox_alloc_node_mask_shuffle(VectorBoxAllocateNode* vbox_alloc,\n+                                            Node* value,\n+                                            const TypeInstPtr* box_type,\n+                                            const TypeVect* vect_type);\n+\n@@ -50,1 +66,2 @@\n-  void expand_vunbox_node_mf(VectorUnboxNode* vec_unbox);\n+  void expand_vunbox_node_vector(VectorUnboxNode* vec_unbox);\n+  void expand_vunbox_node_mask_shuffle(VectorUnboxNode* vec_unbox);\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1636,3 +1636,6 @@\n-  if (n->is_InlineType() && !n->is_VectorBox()) {\n-    n = n->as_InlineType()->get_oop();\n-  }\n+  \/\/ Vector APIs are lazily intrinsified, during parsing compiler emits a\n+  \/\/ call to intrinsic function, since most of the APIs return an abstract vector\n+  \/\/ hence a subsequent checkcast results into a graph shape comprising of CheckPP\n+  \/\/ and CheckCastPP chain. During lazy inline expansion, call gets replaced by\n+  \/\/ a VectorBox but we still need to traverse back through chain of cast nodes\n+  \/\/ to get to the VectorBox.\n@@ -1678,2 +1681,10 @@\n-    n = n->as_InlineType()->get_oop();\n-  }\n+    \/\/ FIXME: Directly return Vector loaded from multi-field for concrete\n+    \/\/ vector InlineType nodes. This can save deferring unbox expansion.\n+    \/\/ For masks\/shuffle emit additional pruning IR to match the vector size.\n+  }\n+  \/\/ Vector APIs are lazily intrinsified, during parsing compiler emits a\n+  \/\/ call to intrinsic function, since most of the APIs return an abstract vector\n+  \/\/ hence a subsequent checkcast results into a graph shape comprising of CheckPP\n+  \/\/ and CheckCastPP chain. During lazy inline expansion, call gets replaced by\n+  \/\/ a VectorBox but we still need to traverse back through chain of cast nodes\n+  \/\/ to get to the VectorBox.\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1678,2 +1678,8 @@\n-  VectorBoxNode(ciInlineKlass* vk, Node* oop, bool null_free, bool is_buffered) :\n-    InlineTypeNode(vk, oop, null_free, is_buffered) {}\n+  VectorBoxNode(Compile* C, ciInlineKlass* vk, Node* oop, const TypeInstPtr* box_type, const TypeVect* vt, bool null_free, bool is_buffered) :\n+    InlineTypeNode(vk, oop, null_free, is_buffered) {\n+      init_flags(Flag_is_macro);\n+      init_class_id(Class_VectorBox);\n+      set_vec_type(vt);\n+      set_box_type(box_type);\n+      C->add_macro_node(this);\n+  }\n@@ -1685,0 +1691,1 @@\n+\n@@ -1689,6 +1696,2 @@\n-    VectorBoxNode* box_node = new VectorBoxNode(vk, box, false, vk->is_empty() && vk->is_initialized());\n-    box_node->set_is_init(gvn);\n-    box_node->set_vec_type(vt);\n-    box_node->set_box_type(box_type);\n-    box_node->init_flags(Flag_is_macro);\n-    box_node->init_class_id(Class_VectorBox);\n+\n+    VectorBoxNode* box_node = new VectorBoxNode(C, vk, box, box_type, vt, false, vk->is_empty() && vk->is_initialized());\n@@ -1696,1 +1699,1 @@\n-    C->add_macro_node(box_node);\n+    box_node->set_is_init(gvn);\n@@ -1703,1 +1706,5 @@\n-  Node*  get_vec() { return field_value(0)->as_InlineType()->field_value(0); }\n+\n+  Node*  get_vec() {\n+    assert(field_value(0)->is_InlineType(), \"\");\n+    return field_value(0)->as_InlineType()->field_value(0);\n+  }\n@@ -1717,1 +1724,0 @@\n-    init_class_id(Class_VectorBoxAllocate);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"}]}