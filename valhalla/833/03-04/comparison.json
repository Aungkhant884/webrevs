{"files":[{"patch":"@@ -171,0 +171,1 @@\n+class VectorBoxAllocateNode;\n@@ -647,0 +648,1 @@\n+              DEFINE_CLASS_ID(VectorBoxAllocate, CallStaticJava, 0)\n@@ -958,0 +960,1 @@\n+  DEFINE_CLASS_QUERY(VectorBoxAllocate)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -317,8 +317,3 @@\n-    Node* vbox = vec_box->get_oop();\n-    Node* vect = vec_box->get_vec();\n-    Node* result = expand_vbox_node_helper(vec_box, vbox, vect, vec_box->box_type(), vec_box->vec_type());\n-    C->gvn_replace_by(vec_box, result);\n-    C->print_method(PHASE_EXPAND_VBOX, 3, vec_box);\n-  }\n-  C->remove_macro_node(vec_box);\n-}\n+    Node* vbox_alloc = vec_box->get_oop();\n+    assert(vbox_alloc->is_Proj() && vbox_alloc->in(0)->isa_VectorBoxAllocate(), \"\");\n+    VectorBoxAllocateNode* vba = vbox_alloc->in(0)->as_VectorBoxAllocate();\n@@ -326,38 +321,2 @@\n-Node* PhaseVector::expand_vbox_node_helper(Node* vec_box,\n-                                           Node* vbox,\n-                                           Node* vect,\n-                                           const TypeInstPtr* box_type,\n-                                           const TypeVect* vect_type) {\n-  if (vbox->is_Phi() && vect->is_Phi()) {\n-    assert(vbox->as_Phi()->region() == vect->as_Phi()->region(), \"\");\n-    Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);\n-    for (uint i = 1; i < vbox->req(); i++) {\n-      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect->in(i), box_type, vect_type);\n-      new_phi->set_req(i, new_box);\n-    }\n-    new_phi = C->initial_gvn()->transform(new_phi);\n-    return new_phi;\n-  } else if (vbox->is_Phi() && (vect->is_Vector() || vect->is_LoadVector())) {\n-    \/\/ Handle the case when the allocation input to VectorBoxNode is a phi\n-    \/\/ but the vector input is not, which can definitely be the case if the\n-    \/\/ vector input has been value-numbered. It seems to be safe to do by\n-    \/\/ construction because VectorBoxNode and VectorBoxAllocate come in a\n-    \/\/ specific order as a result of expanding an intrinsic call. After that, if\n-    \/\/ any of the inputs to VectorBoxNode are value-numbered they can only\n-    \/\/ move up and are guaranteed to dominate.\n-    Node* new_phi = new PhiNode(vbox->as_Phi()->region(), box_type);\n-    for (uint i = 1; i < vbox->req(); i++) {\n-      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect, box_type, vect_type);\n-      new_phi->set_req(i, new_box);\n-    }\n-    new_phi = C->initial_gvn()->transform(new_phi);\n-    return new_phi;\n-  } else if (vbox->is_Proj() && vbox->in(0)->Opcode() == Op_VectorBoxAllocate) {\n-    VectorBoxAllocateNode* vbox_alloc = static_cast<VectorBoxAllocateNode*>(vbox->in(0));\n-    return expand_vbox_alloc_node(vec_box, vbox_alloc, vect, box_type, vect_type);\n-  } else {\n-    assert(!vbox->is_Phi(), \"\");\n-    \/\/ TODO: assert that expanded vbox is initialized with the same value (vect).\n-    return vbox; \/\/ already expanded\n-  }\n-}\n+    JVMState* jvms = clone_jvms(C, vba);\n+    GraphKit kit(jvms);\n@@ -365,50 +324,4 @@\n-Node* PhaseVector::expand_vbox_alloc_node_mf(Node* vbox,\n-                                             VectorBoxAllocateNode* vbox_alloc,\n-                                             Node* value,\n-                                             const TypeInstPtr* box_type,\n-                                             const TypeVect* vect_type) {\n-  assert(vbox->isa_InlineType(), \"\");\n-  JVMState* jvms = clone_jvms(C, vbox_alloc);\n-  GraphKit kit(jvms);\n-  PhaseGVN& gvn = kit.gvn();\n-\n-  ciInstanceKlass* box_klass = box_type->instance_klass();\n-  BasicType bt = vect_type->element_basic_type();\n-  int num_elem = vect_type->length();\n-  int elem_size = type2aelembytes(bt);\n-\n-  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n-  Node* klass_node = kit.makecon(klass_type);\n-  Node* buffer_mem = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true, vbox->as_InlineType());\n-  \/\/ TODO: Re-use existing value storage routine from InlineTypeNode.\n-  \/\/vbox->as_InlineType()->store(&kit, buffer, buffer, box_klass);\n-\n-  \/\/ Store the vector value into the array.\n-  \/\/ (The store should be captured by InitializeNode and turned into initialized store later.)\n-  ciSymbol* payload_sig = ciSymbol::make(VectorSupport::get_vector_payload_field_signature(bt, num_elem)->as_C_string());\n-  ciSymbol* payload_name = ciSymbol::make(vmSymbols::payload_name()->as_C_string());\n-  ciField* payload = box_klass->get_field_by_name(payload_name, payload_sig, false);\n-\n-  Node* buffer_start_adr = kit.basic_plus_adr(buffer_mem, payload->offset());\n-  const TypePtr* buffer_adr_type = buffer_start_adr->bottom_type()->is_ptr();\n-  Node* buffer_mem_start = kit.memory(buffer_start_adr);\n-  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n-                                                     kit.control(),\n-                                                     buffer_mem_start,\n-                                                     buffer_start_adr,\n-                                                     buffer_adr_type,\n-                                                     value,\n-                                                     num_elem));\n-  \/\/ TODO: With respect to aliasing behaviour multi-field alias type should be same as that of\n-  \/\/ array, since multi-field is a bundle of scalars. An alias type determines the size of\n-  \/\/ memory slice updated in global memory at a particular alias index, subsequent memory read\n-  \/\/ with same alias type can directly fetch the value thus saving an extra load operation.\n-  kit.set_memory(vstore, buffer_adr_type);\n-\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));\n-\n-  kit.replace_call(vbox_alloc, buffer_mem, true);\n-  C->remove_macro_node(vbox_alloc);\n-\n-  return buffer_mem;\n-}\n+    ciInlineKlass* vk = vec_box->inline_klass();\n+    Node* klass_node = kit.makecon(TypeKlassPtr::make(vk));\n+    Node* alloc_oop  = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true, vec_box);\n+    vec_box->store(&kit, alloc_oop, alloc_oop, vk);\n@@ -416,0 +329,5 @@\n+    \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+    \/\/ store that would make this buffer accessible by other threads.\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &kit.gvn());\n+    assert(alloc != NULL, \"must have an allocation node\");\n+    kit.insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n@@ -417,9 +335,2 @@\n-Node* PhaseVector::expand_vbox_alloc_node(Node* vbox,\n-                                          VectorBoxAllocateNode* vbox_alloc,\n-                                          Node* value,\n-                                          const TypeInstPtr* box_type,\n-                                          const TypeVect* vect_type) {\n-  ciInstanceKlass* box_klass = box_type->instance_klass();\n-  if (is_vector(box_klass)) {\n-    return expand_vbox_alloc_node_mf(vbox, vbox_alloc, value, box_type, vect_type);\n-  }\n+    kit.replace_call(vba, alloc_oop, true);\n+    C->remove_macro_node(vba);\n@@ -427,17 +338,2 @@\n-  JVMState* jvms = clone_jvms(C, vbox_alloc);\n-  GraphKit kit(jvms);\n-  PhaseGVN& gvn = kit.gvn();\n-\n-  BasicType bt = vect_type->element_basic_type();\n-  int num_elem = vect_type->length();\n-\n-  bool is_mask = is_vector_mask(box_klass);\n-  \/\/ If boxed mask value is present in a predicate register, it must be\n-  \/\/ spilled to a vector though a VectorStoreMaskOperation before actual StoreVector\n-  \/\/ operation to vector payload field.\n-  if (is_mask && (value->bottom_type()->isa_vectmask() || bt != T_BOOLEAN)) {\n-    value = gvn.transform(VectorStoreMaskNode::make(gvn, value, bt, num_elem));\n-    \/\/ Although type of mask depends on its definition, in terms of storage everything is stored in boolean array.\n-    bt = T_BOOLEAN;\n-    assert(value->bottom_type()->is_vect()->element_basic_type() == bt,\n-           \"must be consistent with mask representation\");\n+    C->gvn_replace_by(vec_box, alloc_oop);\n+    C->print_method(PHASE_EXPAND_VBOX, 3, vec_box);\n@@ -445,48 +341,1 @@\n-\n-  \/\/ Generate array allocation for the field which holds the values.\n-  const TypeKlassPtr* array_klass = TypeKlassPtr::make(ciTypeArrayKlass::make(bt));\n-  Node* arr = kit.new_array(kit.makecon(array_klass), kit.intcon(num_elem), 1);\n-\n-  \/\/ Store the vector value into the array.\n-  \/\/ (The store should be captured by InitializeNode and turned into initialized store later.)\n-  Node* arr_adr = kit.array_element_address(arr, kit.intcon(0), bt);\n-  const TypePtr* arr_adr_type = arr_adr->bottom_type()->is_ptr();\n-  Node* arr_mem = kit.memory(arr_adr);\n-  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n-                                                     kit.control(),\n-                                                     arr_mem,\n-                                                     arr_adr,\n-                                                     arr_adr_type,\n-                                                     value,\n-                                                     num_elem));\n-  kit.set_memory(vstore, arr_adr_type);\n-\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));\n-\n-  \/\/ Generate the allocate for the Vector object.\n-  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n-  Node* klass_node = kit.makecon(klass_type);\n-  Node* vec_obj = kit.new_instance(klass_node);\n-\n-  \/\/ Store the allocated array into object.\n-  ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n-                                                                                     ciSymbols::object_signature(),\n-                                                                                     false);\n-  assert(field != NULL, \"\");\n-  Node* vec_field = kit.basic_plus_adr(vec_obj, field->offset_in_bytes());\n-  const TypePtr* vec_adr_type = vec_field->bottom_type()->is_ptr();\n-\n-  \/\/ The store should be captured by InitializeNode and turned into initialized store later.\n-  Node* field_store = gvn.transform(kit.access_store_at(vec_obj,\n-                                                        vec_field,\n-                                                        vec_adr_type,\n-                                                        arr,\n-                                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                                        T_OBJECT,\n-                                                        IN_HEAP));\n-  kit.set_memory(field_store, vec_adr_type);\n-\n-  kit.replace_call(vbox_alloc, vec_obj, true);\n-  C->remove_macro_node(vbox_alloc);\n-\n-  return vec_obj;\n+  C->remove_macro_node(vec_box);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":19,"deletions":170,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -44,10 +44,0 @@\n-  Node* expand_vbox_alloc_node(Node* vbox,\n-                               VectorBoxAllocateNode* vbox_alloc,\n-                               Node* value,\n-                               const TypeInstPtr* box_type,\n-                               const TypeVect* vect_type);\n-  Node* expand_vbox_alloc_node_mf(Node* vbox,\n-                                  VectorBoxAllocateNode* vbox_alloc,\n-                                  Node* value,\n-                                  const TypeInstPtr* box_type,\n-                                  const TypeVect* vect_type);\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1684,1 +1684,6 @@\n-    VectorBoxNode* box_node = new VectorBoxNode(vk, box, true, vk->is_empty() && vk->is_initialized());\n+    ciInlineKlass* payload = vk->declared_nonstatic_field_at(0)->type()->as_inline_klass();\n+    Node* payload_oop = payload->is_initialized() ? default_oop(gvn, payload) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n+    Node* payload_value = InlineTypeNode::make_uninitialized(gvn, payload, true);\n+    payload_value->as_InlineType()->set_field_value(0, val);\n+    payload_value = gvn.transform(payload_value);\n+    VectorBoxNode* box_node = new VectorBoxNode(vk, box, false, vk->is_empty() && vk->is_initialized());\n@@ -1690,1 +1695,1 @@\n-    box_node->init_req(InlineTypeNode::Values, val);\n+    box_node->set_field_value(0, payload_value);\n@@ -1698,1 +1703,1 @@\n-  Node*  get_vec() { return field_value(0); }\n+  Node*  get_vec() { return field_value(0)->as_InlineType()->field_value(0); }\n@@ -1712,0 +1717,1 @@\n+    init_class_id(Class_VectorBoxAllocate);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"}]}