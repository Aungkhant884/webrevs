{"files":[{"patch":"@@ -755,0 +755,12 @@\n+    \/**\n+     * Returns a {@code Class} object representing the null restricted type\n+     * of this class or interface.\n+     *\n+     * @return the {@code Class} representing the null restricted type of\n+     *         this class or interface\n+     * @since Valhalla\n+     *\/\n+    public Class<?> asNullRestrictedType() {\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * A restricted interface optionally implemented by value objects.\n+ *\n+ * A value object is an instance of a value class, lacking identity.\n+ *\n+ * Every object is either an *identity object* or a *value object*. Identity\n+ * objects have a unique identity determined for them at instance creation time and\n+ * preserved throughout their life.\n+ *\n+ * value objects do *not* have an identity. Instead, they simply aggregate a\n+ * set of immutable field values. The lack of identity enables certain performance\n+ * optimizations by Java Virtual Machine implementations.\n+ * The following operations have special behavior when applied to value\n+ * objects:\n+ *\n+ * - The `==` operator, and the default implementation of the `Object.equals`\n+ * method, compare the values of the operands' fields. Value objects\n+ * created at different points in a program may be `==`.\n+ *\n+ * - The `System.identityHashCode` method, and the default implementation of the\n+ * `Object.hashCode` method, generate a hash code from the hash codes of a\n+ * value object's fields.\n+ *\n+ * - The `synchronized` modifier and `synchronized` statement always fail when\n+ * applied to a value object.\n+ *\n+ * A value class with an `implicit` constructor may also declare that it tolerates\n+ * implicit creation of instances via non-atomic field and array updates.\n+ * This means that, in a race condition, new class instances may be accidentally\n+ * created by intermixing field values from other instances, without any code\n+ * execution or other additional cooperation from the value class. A value class\n+ * opts in to allowing this behavior by implementing this interface.\n+ *\n+ * @since Valhalla\n+ *\/\n+\n+public interface LooselyConsistentValue {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LooselyConsistentValue.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -82,6 +82,0 @@\n-    \/**\n-     * The modifier {@code primitive}\n-     * @since 18\n-     *\/\n-    PRIMITIVE,\n-\n@@ -100,0 +94,6 @@\n+    \/**\n+     * The modifier {@code implicit}\n+     * @since 21\n+     *\/\n+    IMPLICIT,\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1141,1 +1141,1 @@\n-                                  classType.tsym, classType.getMetadata(), classType.getFlavor()) {\n+                                  classType.tsym, classType.getMetadata()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,4 +115,6 @@\n-    public static final int ACC_IDENTITY = 0x0020;\n-    public static final int ACC_VALUE    = 0x0040;\n-    public static final int ACC_BRIDGE   = 0x0040;\n-    public static final int ACC_VARARGS  = 0x0080;\n+    public static final int ACC_DEFAULT    = 0x0001;\n+    public static final int ACC_NON_ATOMIC = 0x0002;\n+    public static final int ACC_IDENTITY   = 0x0020;\n+    public static final int ACC_VALUE      = 0x0040;\n+    public static final int ACC_BRIDGE     = 0x0040;\n+    public static final int ACC_VARARGS    = 0x0080;\n@@ -120,1 +122,1 @@\n-    public static final int ACC_MODULE   = 0x8000;\n+    public static final int ACC_MODULE     = 0x8000;\n@@ -430,0 +432,5 @@\n+    \/**\n+     * Flag to indicate that a value class constructor is implicit\n+     *\/\n+    public static final int IMPLICIT    = 1<<59; \/\/ MethodSymbols\n+\n@@ -453,0 +460,1 @@\n+        ImplicitConstructorFlags          = PUBLIC | IMPLICIT,\n@@ -458,1 +466,1 @@\n-        AdjustedClassFlags                = ClassFlags | ACC_PRIMITIVE | ACC_VALUE;\n+        AdjustedClassFlags                = ClassFlags | ACC_VALUE;\n@@ -460,7 +468,7 @@\n-        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedLocalClassFlags           = (long) LocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedLocalClassFlags           = (long) LocalClassFlags | VALUE_CLASS,\n+        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS | IMPLICIT,\n@@ -492,1 +500,0 @@\n-            if (0 != (flags & PRIMITIVE_CLASS))     modifiers.add(Modifier.PRIMITIVE);\n@@ -494,0 +501,2 @@\n+            if (0 != (flags & IDENTITY_TYPE))   modifiers.add(Modifier.IDENTITY);\n+            if (0 != (flags & IMPLICIT))        modifiers.add(Modifier.IMPLICIT);\n@@ -515,1 +524,0 @@\n-\n@@ -543,0 +551,1 @@\n+        IMPLICIT(Flags.IMPLICIT),\n@@ -544,0 +553,2 @@\n+        PRIMITIVE(Flags.PRIMITIVE_CLASS),\n+        VALUE(Flags.VALUE_CLASS),\n@@ -548,2 +559,0 @@\n-        PRIMITIVE(Flags.PRIMITIVE_CLASS),\n-        VALUE(Flags.VALUE_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -233,0 +233,5 @@\n+        \/**\n+         * Warn about operations on null-restricted and nullable types.\n+         *\/\n+        NULL(\"null\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -237,10 +237,0 @@\n-        boolean isReferenceProjection;\n-        try {\n-            isReferenceProjection = t.isReferenceProjection();\n-        } catch (CompletionFailure cf) {\n-            isReferenceProjection = false; \/\/ handle missing types gracefully.\n-        }\n-        if (isReferenceProjection) {\n-            buf.append('.');\n-            buf.append(t.tsym.name.table.names.ref);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-        PRIMITIVE_CLASSES(JDK21, Fragments.FeaturePrimitiveClasses, DiagKind.PLURAL),\n@@ -308,3 +307,0 @@\n-            if (this == PRIMITIVE_CLASSES) {\n-                return Errors.PrimitiveClassesNotSupported(minLevel.name);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -360,0 +359,5 @@\n+        if (isValueObjectFactory()) {\n+            if (((MethodType)t).restype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                ((MethodType)t).restype = ((MethodType)t).restype.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+            }\n+        }\n@@ -408,1 +412,1 @@\n-        return (flags() & INTERFACE) != 0;\n+        return (flags_field & INTERFACE) != 0;\n@@ -419,4 +423,0 @@\n-    public boolean isPrimitiveClass() {\n-        return (flags() & PRIMITIVE_CLASS) != 0;\n-    }\n-\n@@ -424,1 +424,1 @@\n-        return !isInterface() && (flags() & VALUE_CLASS) != 0;\n+        return !isInterface() && (flags_field & VALUE_CLASS) != 0;\n@@ -432,1 +432,1 @@\n-        return !isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+        return !isInterface() && (flags_field & IDENTITY_TYPE) != 0;\n@@ -436,1 +436,1 @@\n-        return isInterface() && (flags() & VALUE_CLASS) != 0;\n+        return isInterface() && (flags_field & VALUE_CLASS) != 0;\n@@ -440,1 +440,1 @@\n-        return isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+        return isInterface() && (flags_field & IDENTITY_TYPE) != 0;\n@@ -493,0 +493,6 @@\n+    \/** Is this symbol an implicit constructor?\n+     *\/\n+    public boolean isImplicitConstructor() {\n+        return isInitOrVNew() && ((flags() & IMPLICIT) != 0);\n+    }\n+\n@@ -1359,1 +1365,1 @@\n-                new ClassType(Type.noType, null, null, List.nil(), Flavor.X_Typeof_X),\n+                new ClassType(Type.noType, null, null, List.nil()),\n@@ -1396,2 +1402,1 @@\n-                                              type.getMetadata(),\n-                                              type.getFlavor());\n+                                              type.getMetadata());\n@@ -1463,8 +1468,0 @@\n-            } finally {\n-                if (this.type != null && this.type.hasTag(CLASS)) {\n-                    ClassType ct = (ClassType) this.type;\n-                    ct.flavor = ct.flavor.metamorphose((this.flags_field & PRIMITIVE_CLASS) != 0);\n-                    if (!this.type.isIntersection() && this.erasure_field != null && this.erasure_field.hasTag(CLASS)) {\n-                        ((ClassType) this.erasure_field).flavor = ct.flavor;\n-                    }\n-                }\n@@ -1658,1 +1655,0 @@\n-                classType.flavor = Flavor.X_Typeof_X;\n@@ -1697,0 +1693,14 @@\n+\n+        public MethodSymbol getImplicitConstructor() {\n+            for (Symbol s : members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case MTH:\n+                        if (s.isInitOrVNew()) {\n+                            if (s.isImplicitConstructor()) {\n+                                return (MethodSymbol) s;\n+                            }\n+                        }\n+                }\n+            }\n+            return null;\n+        }\n@@ -2091,1 +2101,1 @@\n-                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null &&\n+                types.asSuper(owner.type, other.owner) != null &&\n@@ -2160,1 +2170,1 @@\n-                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null) {\n+                types.asSuper(owner.type, other.owner) != null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":34,"deletions":24,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Type.WildcardType;\n@@ -69,1 +68,0 @@\n-import com.sun.tools.javac.util.Options;\n@@ -98,2 +96,0 @@\n-    private final boolean allowPrimitiveClasses;\n-\n@@ -253,0 +249,4 @@\n+    \/\/ for value objects\n+    public final Type looselyConsistentValueType;\n+    public final Type reflectArrayType;\n+\n@@ -293,12 +293,3 @@\n-                Type arg = null;\n-                if (type.getTag() == ARRAY || type.getTag() == CLASS) {\n-                    \/* Temporary treatment for primitive class: Given a primitive class V that implements\n-                       I1, I2, ... In, V.class is typed to be Class<? extends Object & I1 & I2 .. & In>\n-                    *\/\n-                    if (allowPrimitiveClasses && type.isPrimitiveClass()) {\n-                        List<Type> bounds = List.of(objectType).appendList(((ClassSymbol) type.tsym).getInterfaces());\n-                        arg = new WildcardType(bounds.size() > 1 ? types.makeIntersectionType(bounds) : objectType, BoundKind.EXTENDS, boundClass);\n-                    } else {\n-                        arg = types.erasure(type);\n-                    }\n-                }\n+                Type arg;\n+                if (type.getTag() == ARRAY || type.getTag() == CLASS)\n+                    arg = types.erasure(type);\n@@ -659,0 +650,4 @@\n+        \/\/ for value objects\n+        looselyConsistentValueType = enterClass(\"java.lang.LooselyConsistentValue\");\n+        reflectArrayType = enterClass(\"java.lang.reflect.Array\");\n+\n@@ -693,2 +688,0 @@\n-        Options options = Options.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Optional;\n@@ -40,1 +39,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -48,0 +46,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -235,1 +234,1 @@\n-    public boolean isPrimitiveClass() {\n+    public boolean isValueClass() {\n@@ -239,1 +238,1 @@\n-    public boolean isValueClass() {\n+    public boolean hasImplicitConstructor() {\n@@ -259,43 +258,1 @@\n-        if (this.isReferenceProjection())\n-            return true;\n-        return this.isValueClass() && !this.isPrimitiveClass();\n-    }\n-\n-    \/**\n-     * Return the `flavor' associated with a ClassType.\n-     * @see ClassType.Flavor\n-     *\/\n-    public Flavor getFlavor() {\n-        throw new AssertionError(\"Unexpected call to getFlavor() on a Type that is not a ClassType: \" + this);\n-    }\n-\n-    \/**\n-     * @return true IFF the receiver is a reference projection of a primitive class type and false\n-     * for primitives or plain references\n-     *\/\n-    public boolean isReferenceProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n-     * and null otherwise\n-     *\/\n-    public Type valueProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * @return the reference projection type IFF the receiver is a primitive class type\n-     * and null otherwise\n-     *\/\n-    public Type referenceProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * @return the reference projection type IFF the receiver is a primitive class type or self otherwise.\n-     *\/\n-    public Type referenceProjectionOrSelf() {\n-        Type projection = referenceProjection();\n-        return projection != null ? projection : this;\n+        return this.isValueClass();\n@@ -318,1 +275,1 @@\n-            else return new ClassType(outer1, typarams1, t.tsym, t.metadata, t.getFlavor()) {\n+            else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {\n@@ -593,0 +550,7 @@\n+        if (isNullable()) {\n+            sb.append(\"?\");\n+        } else if (isNonNullable()) {\n+            sb.append(\"!\");\n+        } else if (isParametric()) {\n+            sb.append(\"*\");\n+        }\n@@ -797,0 +761,31 @@\n+    \/\/ support for null-marked types\n+\n+    public Type asNullMarked(NullMarker nullMarker) {\n+        if (nullMarker == NullMarker.UNSPECIFIED) {\n+            return this;\n+        } else {\n+            return addMetadata(new TypeMetadata.NullMarker(nullMarker));\n+        }\n+    }\n+\n+    public boolean isNullable() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.NULLABLE;\n+    }\n+\n+    public boolean isNonNullable() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.NOT_NULL;\n+    }\n+\n+    public boolean isParametric() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.PARAMETRIC;\n+    }\n+\n+    public boolean isNullUnspecified() {\n+        return getMetadata(TypeMetadata.NullMarker.class) == null;\n+    }\n+\n+    \/\/ end of support for null-marked types\n+\n@@ -1092,79 +1087,0 @@\n-\n-        \/**\n-         * The 'flavor' of a ClassType indicates its reference\/primitive projectionness\n-         * viewed against the default nature of the associated class.\n-         *\/\n-        public enum Flavor {\n-\n-            \/**\n-             * Classic reference type. Also reference projection type of a reference-favoring aka\n-             * reference-default primitive class type\n-             *\/\n-            L_TypeOf_L,\n-\n-            \/**\n-             * Reference projection type of a primitive-favoring aka primitive-default\n-             * plain vanilla primitive class type,\n-             *\/\n-            L_TypeOf_Q,\n-\n-            \/**\n-             * Value projection type of a primitive-favoring aka primitive-default\n-             * plain vanilla primitive class type,\n-             *\/\n-            Q_TypeOf_Q,\n-\n-            \/**\n-             * Value projection type of a reference-favoring aka\n-             * reference-default primitive class type\n-             *\/\n-            Q_TypeOf_L,\n-\n-            \/**\n-             * Reference projection type of a class type of an as yet unknown default provenance, 'X' will be\n-             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n-             *\/\n-            L_TypeOf_X,\n-\n-            \/**\n-             * Value projection type of a class type of an as yet unknown default provenance, 'X' will be\n-             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n-             *\/\n-            Q_TypeOf_X,\n-\n-            \/**\n-             *  As yet unknown projection type of an as yet unknown default provenance class.\n-             *\/\n-            X_Typeof_X,\n-\n-            \/**\n-             *  An error type - we don't care to discriminate them any further.\n-             *\/\n-             E_Typeof_X;\n-\n-            \/\/ We don't seem to need X_Typeof_L or X_Typeof_Q so far.\n-\n-            \/\/ Transform a larval form into a more evolved form\n-            public Flavor metamorphose(boolean isPrimtiveClass) {\n-\n-                switch (this) {\n-\n-                    case E_Typeof_X:  \/\/ stunted form\n-                    case L_TypeOf_L:\n-                    case L_TypeOf_Q:\n-                    case Q_TypeOf_L:\n-                    case Q_TypeOf_Q:\n-                            \/\/ These are fully evolved sealed forms or stunted - no futher transformation\n-                            return this;\n-                    case L_TypeOf_X:\n-                            return isPrimtiveClass ? L_TypeOf_Q : L_TypeOf_L;\n-                    case Q_TypeOf_X:\n-                            return isPrimtiveClass ? Q_TypeOf_Q : Q_TypeOf_L;\n-                    case X_Typeof_X:\n-                            return isPrimtiveClass ? Q_TypeOf_Q : L_TypeOf_L;\n-                    default:\n-                            throw new AssertionError(\"Unexpected class type flavor\");\n-                }\n-            }\n-        }\n-\n@@ -1199,9 +1115,0 @@\n-        \/** The 'other' projection: If 'this' is type of a primitive class, then 'projection' is the\n-         *  reference projection type and vice versa. Lazily initialized, not to be accessed directly.\n-        *\/\n-        public ClassType projection;\n-\n-        \/** Is this L of default {L, Q, X} or Q of default {L, Q, X} ?\n-         *\/\n-        public Flavor flavor;\n-\n@@ -1213,5 +1120,1 @@\n-            this(outer, typarams, tsym, List.nil(), Flavor.L_TypeOf_L);\n-        }\n-\n-        public ClassType(Type outer, List<Type> typarams, TypeSymbol tsym, Flavor flavor) {\n-            this(outer, typarams, tsym, List.nil(), flavor);\n+            this(outer, typarams, tsym, List.nil());\n@@ -1221,1 +1124,1 @@\n-                         List<TypeMetadata> metadata, Flavor flavor) {\n+                         List<TypeMetadata> metadata) {\n@@ -1228,1 +1131,0 @@\n-            this.flavor = flavor;\n@@ -1237,1 +1139,1 @@\n-            return new ClassType(outer_field, typarams_field, tsym, md, flavor) {\n+            return new ClassType(outer_field, typarams_field, tsym, md) {\n@@ -1288,9 +1190,6 @@\n-            boolean isReferenceProjection;\n-            try {\n-                isReferenceProjection = isReferenceProjection();\n-            } catch (CompletionFailure cf) {\n-                isReferenceProjection = false; \/\/ handle missing types gracefully.\n-            }\n-            if (isReferenceProjection) {\n-                buf.append('.');\n-                buf.append(tsym.name.table.names.ref);\n+            if (isNullable()) {\n+                buf.append(\"?\");\n+            } else if (isNonNullable()) {\n+                buf.append(\"!\");\n+            } else if (isParametric()) {\n+                buf.append(\"*\");\n@@ -1337,4 +1236,0 @@\n-        public Flavor getFlavor() {\n-            return flavor;\n-        }\n-\n@@ -1357,3 +1252,0 @@\n-            if (outer_field != null && outer_field.isReferenceProjection()) {\n-                outer_field = outer_field.valueProjection();\n-            }\n@@ -1392,2 +1284,2 @@\n-        public boolean isPrimitiveClass() {\n-            return !isReferenceProjection() && tsym != null && tsym.isPrimitiveClass();\n+        public boolean isValueClass() {\n+            return tsym != null && tsym.isValueClass();\n@@ -1397,2 +1289,2 @@\n-        public boolean isValueClass() {\n-            return !isReferenceProjection() && tsym != null && tsym.isValueClass();\n+        public boolean hasImplicitConstructor() {\n+            return tsym != null && tsym.kind == TYP && ((ClassSymbol)tsym).getImplicitConstructor() != null;\n@@ -1408,1 +1300,1 @@\n-            return !isReferenceProjection() && tsym != null && tsym.isIdentityClass();\n+            return tsym != null && tsym.isIdentityClass();\n@@ -1416,49 +1308,0 @@\n-        @Override\n-        public boolean isReferenceProjection() {\n-            \/\/ gaurd against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.L_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.isPrimitiveClass());\n-                }\n-            }\n-            return flavor == Flavor.L_TypeOf_Q;\n-        }\n-\n-        @Override\n-        public Type valueProjection() {\n-            if (!isReferenceProjection())\n-                return null;\n-\n-            if (projection !=  null)\n-                return projection;\n-\n-            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.Q_TypeOf_Q);\n-            projection.allparams_field = allparams_field;\n-            projection.supertype_field = supertype_field;\n-\n-            projection.interfaces_field = interfaces_field;\n-            projection.all_interfaces_field = all_interfaces_field;\n-            projection.projection = this;\n-            return projection;\n-        }\n-\n-        \/\/ return the reference projection type preserving parameterizations\n-        @Override\n-        public ClassType referenceProjection() {\n-\n-            if (!isPrimitiveClass())\n-                return null;\n-\n-            if (projection != null)\n-                return projection;\n-\n-            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.L_TypeOf_Q);\n-            projection.allparams_field = allparams_field;\n-            projection.supertype_field = supertype_field;\n-\n-            projection.interfaces_field = interfaces_field;\n-            projection.all_interfaces_field = all_interfaces_field;\n-            projection.projection = this;\n-            return projection;\n-        }\n-\n@@ -1513,1 +1356,1 @@\n-            super(outer, List.nil(), tsym, metadata, tsym.type.getFlavor());\n+            super(outer, List.nil(), tsym, metadata);\n@@ -1680,0 +1523,7 @@\n+                if (t.isNullable()) {\n+                    sb.append(\"?\");\n+                } else if (t.isNonNullable()) {\n+                    sb.append(\"!\");\n+                } else if (t.isParametric()) {\n+                    sb.append(\"*\");\n+                }\n@@ -2624,1 +2474,1 @@\n-            super(noType, List.nil(), tsym, List.nil(), Flavor.E_Typeof_X);\n+            super(noType, List.nil(), tsym, List.nil());\n@@ -2629,2 +2479,2 @@\n-                          List<TypeMetadata> metadata, Flavor flavor) {\n-            super(noType, List.nil(), null, metadata, flavor);\n+                          List<TypeMetadata> metadata) {\n+            super(noType, List.nil(), null, metadata);\n@@ -2637,1 +2487,1 @@\n-            return new ErrorType(originalType, tsym, md, getFlavor()) {\n+            return new ErrorType(originalType, tsym, md) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":69,"deletions":219,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-                                                      t.getMetadata(), t.getFlavor());\n+                                                      t.getMetadata());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression;\n+import com.sun.tools.javac.util.Assert;\n@@ -79,0 +81,5 @@\n+\n+    record NullMarker(JCNullableTypeExpression.NullMarker nullMarker) implements TypeMetadata {\n+        @Override\n+        public String toString() { return \"NULL_MARKER [ \" + nullMarker.typeSuffix() + \" ]\"; }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeMetadata.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.BiFunction;\n@@ -45,1 +46,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -94,1 +94,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -103,0 +102,2 @@\n+    private boolean emitQDesc;\n+\n@@ -122,1 +123,6 @@\n-        noWarnings = new Warner(null);\n+        noWarnings = new Warner(null) {\n+            @Override\n+            public String toString() {\n+                return \"NO_WARNINGS\";\n+            }\n+        };\n@@ -124,1 +130,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -273,1 +279,1 @@\n-                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.getFlavor()) {\n+                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {\n@@ -605,10 +611,0 @@\n-        if (allowPrimitiveClasses) {\n-            boolean tValue = t.isPrimitiveClass();\n-            boolean sValue = s.isPrimitiveClass();\n-            if (tValue != sValue) {\n-                return tValue ?\n-                        isSubtype(t.referenceProjection(), s) :\n-                        !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n-            }\n-        }\n-\n@@ -1048,27 +1044,5 @@\n-            if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n-                if (((ArrayType)t).elemtype.isPrimitive()) {\n-                    return isSameType(elemtype(t), elemtype(s));\n-                } else {\n-                    \/\/ if T.ref <: S, then T[] <: S[]\n-                    Type es = elemtype(s);\n-                    Type et = elemtype(t);\n-                    if (allowPrimitiveClasses) {\n-                        if (et.isPrimitiveClass()) {\n-                            et = et.referenceProjection();\n-                            if (es.isPrimitiveClass())\n-                                es = es.referenceProjection();  \/\/ V <: V, surely\n-                        }\n-                    }\n-                    if (!isSubtypeUncheckedInternal(et, es, false, warn))\n-                        return false;\n-                    return true;\n-                }\n-            } else if (isSubtype(t, s, capture)) {\n-                return true;\n-            } else if (t.hasTag(TYPEVAR)) {\n-                return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n-            } else if (!s.isRaw()) {\n-                Type t2 = asSuper(t, s.tsym);\n-                if (t2 != null && t2.isRaw()) {\n-                    if (isReifiable(s)) {\n-                        warn.silentWarn(LintCategory.UNCHECKED);\n+            try {\n+                warnStack = warnStack.prepend(warn);\n+                if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n+                    if (((ArrayType)t).elemtype.isPrimitive()) {\n+                        return isSameType(elemtype(t), elemtype(s));\n@@ -1076,1 +1050,6 @@\n-                        warn.warn(LintCategory.UNCHECKED);\n+                        \/\/ if T.ref <: S, then T[] <: S[]\n+                        Type es = elemtype(s);\n+                        Type et = elemtype(t);\n+                        if (!isSubtypeUncheckedInternal(et, es, false, warn))\n+                            return false;\n+                        return true;\n@@ -1078,0 +1057,1 @@\n+                } else if (isSubtype(t, s, capture)) {\n@@ -1079,0 +1059,12 @@\n+                } else if (t.hasTag(TYPEVAR)) {\n+                    return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n+                } else if (!s.isRaw()) {\n+                    Type t2 = asSuper(t, s.tsym);\n+                    if (t2 != null && t2.isRaw()) {\n+                        if (isReifiable(s)) {\n+                            warn.silentWarn(LintCategory.UNCHECKED);\n+                        } else {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                        }\n+                        return true;\n+                    }\n@@ -1080,0 +1072,3 @@\n+                return false;\n+            } finally {\n+                warnStack = warnStack.tail;\n@@ -1081,1 +1076,0 @@\n-            return false;\n@@ -1117,1 +1111,2 @@\n-        if (t.equalsIgnoreMetadata(s))\n+        if (t.equalsIgnoreMetadata(s)) {\n+            new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n@@ -1119,0 +1114,1 @@\n+        }\n@@ -1139,1 +1135,0 @@\n-\n@@ -1143,2 +1138,2 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        private IsSubtype isSubtype = new IsSubtype();\n+        class IsSubtype extends TypeRelation {\n@@ -1159,1 +1154,4 @@\n-                 case BOT:\n+                 case BOT: {\n+                     if (s.isNonNullable()) {\n+                         return false;\n+                     }\n@@ -1161,2 +1159,3 @@\n-                         s.hasTag(BOT) || (s.hasTag(CLASS) && (!allowPrimitiveClasses || !s.isPrimitiveClass())) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                 }\n@@ -1227,2 +1226,1 @@\n-                return sup.tsym == s.tsym\n-                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n+                boolean result = sup.tsym == s.tsym\n@@ -1233,0 +1231,4 @@\n+                if (result) {\n+                    new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+                }\n+                return result;\n@@ -1244,5 +1246,0 @@\n-                        if (allowPrimitiveClasses && et.isPrimitiveClass()) {\n-                            et = et.referenceProjection();\n-                            if (es.isPrimitiveClass())\n-                                es = es.referenceProjection();  \/\/ V <: V, surely\n-                        }\n@@ -1282,1 +1279,47 @@\n-        };\n+        }\n+\n+        public class NullabilityComparator extends TypeRelation {\n+            BiFunction<Type, Type, Boolean> differentNullability;\n+\n+            NullabilityComparator(BiFunction<Type, Type, Boolean> differentNullability) {\n+                this.differentNullability = differentNullability;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return s != null && (!s.isParameterized() || compareTypeArgsRecursive(t, s))\n+                            && visit(t.getEnclosingType(), s.getEnclosingType());\n+                }\n+            }\n+            \/\/ where\n+            boolean compareTypeArgsRecursive(Type t, Type s) {\n+                return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n+            }\n+\n+            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()) {\n+                    if (visit(ts.head, ss.head)) {\n+                        return true;\n+                    }\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return false;\n+            }\n+        }\n@@ -1469,12 +1512,5 @@\n-                return t.tsym == s.tsym\n-                    && t.isReferenceProjection() == s.isReferenceProjection()\n-                    && visit(getEnclosingType(t), getEnclosingType(s))\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n-            }\n-                \/\/ where\n-                private Type getEnclosingType(Type t) {\n-                    Type et = t.getEnclosingType();\n-                    if (et.isReferenceProjection()) {\n-                        et = et.valueProjection();\n-                    }\n-                    return et;\n+                boolean equal = t.tsym == s.tsym\n+                        && visit(t.getEnclosingType(), s.getEnclosingType())\n+                        && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                if (equal) {\n+                    new NullabilityComparator((t1, t2) -> !hasSameNullability(t1, t2)).visit(s, t);\n@@ -1482,0 +1518,2 @@\n+                return equal;\n+            }\n@@ -1739,1 +1777,1 @@\n-            if (isSubtype(erasure(ts.type.referenceProjectionOrSelf()), erasure(ss.type))) {\n+            if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n@@ -1794,1 +1832,1 @@\n-                if (s.hasTag(ERROR) || (s.hasTag(BOT) && (!allowPrimitiveClasses || !t.isPrimitiveClass())))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT) && (!t.hasImplicitConstructor() || !t.isNonNullable()))\n@@ -1813,10 +1851,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        if (t.isPrimitiveClass()) {\n-                            \/\/ (s) Value ? == (s) Value.ref\n-                            t = t.referenceProjection();\n-                        }\n-                        if (s.isPrimitiveClass()) {\n-                            \/\/ (Value) t ? == (Value.ref) t\n-                            s = s.referenceProjection();\n-                        }\n-                    }\n@@ -2199,0 +2227,4 @@\n+        return makeArrayType(t, 1);\n+    }\n+\n+    public ArrayType makeArrayType(Type t, int dimensions) {\n@@ -2202,1 +2234,15 @@\n-        return new ArrayType(t, syms.arrayClass);\n+        ArrayType result = new ArrayType(t, syms.arrayClass);\n+        for (int i = 1; i < dimensions; i++) {\n+            result = new ArrayType(result, syms.arrayClass);\n+        }\n+        return result;\n+    }\n+    \/\/ <\/editor-fold>\n+\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n+    public void pushWarner(Warner warner) {\n+        warnStack = warnStack.prepend(warner);\n+    }\n+\n+    public void popWarner() {\n+        warnStack = warnStack.tail;\n@@ -2216,29 +2262,0 @@\n-     * Further caveats in Valhalla: There are two \"hazards\" we need to watch out for when using\n-     * this method.\n-     *\n-     * 1. Since Foo.ref and Foo.val share the same symbol, that of Foo.class, a call to\n-     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This MAY NOT BE correct\n-     *    depending on the call site. Foo.val is NOT a super type of Foo.ref either in the language\n-     *    model or in the VM's world view. An example of such an hazardous call used to exist in\n-     *    Gen.visitTypeCast. When we emit code for  (Foo) Foo.ref.instance a check for whether we\n-     *    really need the cast cannot\/shouldn't be gated on\n-     *\n-     *        asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n-     *\n-     *    but use !types.isSubtype(tree.expr.type, tree.clazz.type) which operates in terms of\n-     *    types. When we operate in terms of symbols, there is a loss of type information leading\n-     *    to a hazard. Whether a call to asSuper should be transformed into a isSubtype call is\n-     *    tricky. isSubtype returns just a boolean while asSuper returns richer information which\n-     *    may be required at the call site. Also where the concerned symbol corresponds to a\n-     *    generic class, an asSuper call cannot be conveniently rewritten as an isSubtype call\n-     *    (see that asSuper(ArrayList<String>.type, List<T>.tsym) != null while\n-     *    isSubType(ArrayList<String>.type, List<T>.type) is false;) So care needs to be exercised.\n-     *\n-     * 2. Given a primitive class Foo, a call to asSuper(Foo.type, SuperclassOfFoo.tsym) and\/or\n-     *    a call to asSuper(Foo.type, SuperinterfaceOfFoo.tsym) would answer null. In many places\n-     *    that is NOT what we want. An example of such a hazardous call used to occur in\n-     *    Attr.visitForeachLoop when checking to make sure the for loop's control variable of a type\n-     *    that implements Iterable: viz: types.asSuper(exprType, syms.iterableType.tsym);\n-     *    These hazardous calls should be rewritten as\n-     *    types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym); instead.\n-     *\n@@ -2257,6 +2274,0 @@\n-\n-        if (allowPrimitiveClasses && t.isPrimitiveClass()) {\n-            \/\/ No man may be an island, but the bell tolls for a value.\n-            return t.tsym == sym ? t : null;\n-        }\n-\n@@ -2393,12 +2404,3 @@\n-\n-        if ((sym.flags() & STATIC) != 0)\n-            return sym.type;\n-\n-        \/* If any primitive class types are involved, switch over to the reference universe,\n-           where the hierarchy is navigable. V and V.ref have identical membership\n-           with no bridging needs.\n-        *\/\n-        if (allowPrimitiveClasses && t.isPrimitiveClass())\n-            t = t.referenceProjection();\n-\n-        return memberType.visit(t, sym);\n+        return (sym.flags() & STATIC) != 0\n+            ? sym.type\n+            : memberType.visit(t, sym);\n@@ -2533,1 +2535,1 @@\n-                        default: return s.dropMetadata(Annotations.class);\n+                        default: return s.cloneWithMetadata(t.getMetadata()).dropMetadata(Annotations.class);\n@@ -2557,19 +2559,7 @@\n-                \/\/ erasure(projection(primitive)) = projection(erasure(primitive))\n-                Type erased = eraseClassType(t, recurse);\n-                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n-                    erased = new ClassType(erased.getEnclosingType(),\n-                            List.nil(), erased.tsym,\n-                            erased.getMetadata(), t.flavor);\n-                }\n-                return erased;\n-            }\n-                \/\/ where\n-                private Type eraseClassType(ClassType t, Boolean recurse) {\n-                    Type erased = t.tsym.erasure(Types.this);\n-                    if (recurse) {\n-                        erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n-                                                     t.dropMetadata(Annotations.class).getMetadata());\n-                        return erased;\n-                    } else {\n-                        return combineMetadata(erased, t);\n-                    }\n+                Type erased = t.tsym.erasure(Types.this);\n+                if (recurse) {\n+                    erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n+                            t.dropMetadata(Annotations.class).getMetadata());\n+                    return erased;\n+                } else {\n+                    return combineMetadata(erased, t);\n@@ -2577,0 +2567,1 @@\n+            }\n@@ -2896,1 +2887,1 @@\n-                                         t.getMetadata(), t.getFlavor());\n+                                         t.getMetadata());\n@@ -2926,1 +2917,10 @@\n-        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        return isSubSignature(t, s, noWarnings);\n+    }\n+\n+    public boolean isSubSignature(Type t, Type s, Warner warn) {\n+        try {\n+            warnStack = warnStack.prepend(warn);\n+            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -3826,1 +3826,1 @@\n-     * (that is, subclasses come first, arbitrarily but fixed\n+     * (that is, subclasses come first, arbitrary but fixed\n@@ -4017,1 +4017,1 @@\n-                                 class1.tsym, List.nil(), class1.getFlavor());\n+                                 class1.tsym, List.nil());\n@@ -4397,4 +4397,6 @@\n-        if (isSameType(r1.getReturnType(), r2res))\n-            return true;\n-        if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())\n-            return false;\n+        try {\n+            warnStack = warnStack.prepend(warner);\n+            if (isSameType(r1.getReturnType(), r2res))\n+                return true;\n+            if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())\n+                return false;\n@@ -4402,3 +4404,7 @@\n-        if (hasSameArgs(r1, r2))\n-            return covariantReturnType(r1.getReturnType(), r2res, warner);\n-        if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))\n+            if (hasSameArgs(r1, r2))\n+                return covariantReturnType(r1.getReturnType(), r2res, warner);\n+            if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))\n+                return true;\n+            if (!isSubtype(r1.getReturnType(), erasure(r2res), false))\n+                return false;\n+            warner.warn(LintCategory.UNCHECKED);\n@@ -4406,4 +4412,3 @@\n-        if (!isSubtype(r1.getReturnType(), erasure(r2res)))\n-            return false;\n-        warner.warn(LintCategory.UNCHECKED);\n-        return true;\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -4577,1 +4582,1 @@\n-                                 cls.getMetadata(), cls.getFlavor());\n+                                 cls.getMetadata());\n@@ -5251,1 +5256,1 @@\n-                    if (types.allowPrimitiveClasses && type.isPrimitiveClass())\n+                    if (types.emitQDesc && type.hasImplicitConstructor() && type.isNonNullable())\n@@ -5400,0 +5405,28 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"nullability methods\">\n+    \/**\n+     * Do t and s have the same nullability?\n+     *\/\n+    public boolean hasSameNullability(Type t, Type s) {\n+        if (s == null) {\n+            return t.isNullUnspecified();\n+        }\n+        if (t.isNullUnspecified()) {\n+            return s.isNullUnspecified();\n+        }\n+        if (t.isNonNullable()) {\n+            return s.isNonNullable();\n+        }\n+        throw new AssertionError(\"shouldn't get here\");\n+    }\n+\n+    \/**\n+     * Does t has narrower nullability than s?\n+     *\/\n+    public boolean hasNarrowerNullability(Type t, Type s) {\n+        if (t.isNonNullable()) {\n+            return s != null && !s.isNonNullable();\n+        }\n+        return false;\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":201,"deletions":168,"binary":false,"changes":369,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -65,0 +64,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -170,1 +170,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -191,1 +191,1 @@\n-    boolean allowPrimitiveClasses;\n+    boolean allowValueClasses;\n@@ -735,0 +735,4 @@\n+        if (tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -808,1 +812,1 @@\n-                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));\n+                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env)));\n@@ -810,1 +814,1 @@\n-                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));\n+                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env)));\n@@ -1171,0 +1175,8 @@\n+            if (tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -1336,0 +1348,11 @@\n+            Type elemOrType = result;\n+            while (!elemOrType.hasTag(ERROR) && types.elemtype(elemOrType) != null) {\n+                elemOrType = types.elemtype(elemOrType);\n+            }\n+            if ((result.isNonNullable() || elemOrType.isNonNullable()) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor())) {\n+                log.error(tree.pos(),\n+                        types.elemtype(result) == null?\n+                                Errors.TypeCantBeNullRestricted(result) :\n+                                Errors.TypeCantBeNullRestricted2(result)\n+                );\n+            }\n@@ -1566,1 +1589,1 @@\n-                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n+                Type base = types.asSuper(exprType, syms.iterableType.tsym);\n@@ -1582,1 +1605,1 @@\n-                    if (types.asSuper(iterSymbol.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym) == null) {\n+                    if (types.asSuper(iterSymbol.type.getReturnType(), syms.iteratorType.tsym) == null) {\n@@ -2019,1 +2042,1 @@\n-            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n+            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&\n@@ -2208,2 +2231,1 @@\n-            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n-            \/\/ value conversions bring about a convergence.\n+            \/\/ Those were all the cases that could result in a primitive\n@@ -2211,2 +2233,1 @@\n-                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type\n-                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n+                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type : t)\n@@ -2223,1 +2244,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), allowPrimitiveClasses && t.isPrimitiveClass() ? t.referenceProjection() : t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), t))\n@@ -2226,1 +2247,1 @@\n-            \/\/ both are known to be reference types (or projections).  The result is\n+            \/\/ both are known to be reference types.  The result is\n@@ -2666,2 +2687,1 @@\n-                Type wcb = types.erasure(allowPrimitiveClasses && qualifierType.isPrimitiveClass() ?\n-                                         qualifierType.referenceProjection() : qualifierType.baseType());\n+                Type wcb = types.erasure(qualifierType.baseType());\n@@ -2673,2 +2693,1 @@\n-                        restype.getMetadata(),\n-                        restype.getFlavor());\n+                        restype.getMetadata());\n@@ -2843,10 +2862,0 @@\n-            \/\/ Check that it is an instantiation of a class and not a projection type\n-            if (allowPrimitiveClasses) {\n-                if (clazz.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n-                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n-                    }\n-                }\n-            }\n@@ -2877,2 +2886,1 @@\n-                                               clazztype.getMetadata(),\n-                                               clazztype.getFlavor());\n+                                               clazztype.getMetadata());\n@@ -2939,1 +2947,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -2941,0 +2949,4 @@\n+                if (owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -3032,3 +3044,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n-                    }\n@@ -3107,3 +3116,0 @@\n-        \/\/ Likewise arg can't be null if it is a primitive class instance.\n-        if (allowPrimitiveClasses && arg.type.isPrimitiveClass())\n-            return arg;\n@@ -4447,9 +4453,0 @@\n-        if (allowPrimitiveClasses && tree.name == names._class && site.isPrimitiveClass()) {\n-            \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-             * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-             * always matching the behavior of Object::getClass\n-             *\/\n-             if (!tree.selected.hasTag(SELECT) || ((JCFieldAccess) tree.selected).name != names.val) {\n-                 tree.selected.setType(site = site.referenceProjection());\n-             }\n-        }\n@@ -4459,0 +4456,9 @@\n+        \/\/ check nullness of site\n+        if (site.isNullable()) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (site.isParametric()) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -4572,1 +4578,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n@@ -4615,2 +4621,0 @@\n-                } else if (allowPrimitiveClasses && site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n-                    return site.tsym;\n@@ -4723,3 +4727,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n-                    }\n@@ -4729,8 +4730,1 @@\n-                    \/\/ (a) If symbol is a primitive class and its reference projection\n-                    \/\/ is requested via the .ref notation, then adjust the computed type to\n-                    \/\/ reflect this.\n-                    if (allowPrimitiveClasses && owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n-                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n-                    }\n-\n-                    \/\/ (b) If the symbol's type is parameterized, erase it\n+                    \/\/ If the symbol's type is parameterized, erase it\n@@ -4763,1 +4757,1 @@\n-                                owntype.getMetadata(), owntype.getFlavor());\n+                                owntype.getMetadata());\n@@ -4794,0 +4788,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n@@ -5081,1 +5080,1 @@\n-        if (!allowPrimitiveClasses) {\n+        if (!allowValueClasses) {\n@@ -5083,1 +5082,1 @@\n-                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n+                    Feature.VALUE_CLASSES.error(sourceName));\n@@ -5090,1 +5089,1 @@\n-        if (!allowPrimitiveClasses) {\n+        if (!allowValueClasses) {\n@@ -5198,1 +5197,1 @@\n-                                        clazztype.getMetadata(), clazztype.getFlavor());\n+                                        clazztype.getMetadata());\n@@ -5325,1 +5324,1 @@\n-                make.Modifiers(PUBLIC | ABSTRACT | (extending != null && TreeInfo.symbol(extending).isPrimitiveClass() ? PRIMITIVE_CLASS : 0)),\n+                make.Modifiers(PUBLIC | ABSTRACT),\n@@ -5348,1 +5347,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),\n@@ -5466,1 +5465,1 @@\n-            if (allowPrimitiveClasses && c.type.isPrimitiveClass()) {\n+            if (c.type.isValueClass()) {\n@@ -5468,1 +5467,1 @@\n-                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF))\n+                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n@@ -5648,1 +5647,1 @@\n-                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n+                    chk.checkConstraintsOfValueClass((JCClassDecl) env.tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":69,"deletions":70,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Consumer;\n@@ -40,0 +39,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -82,1 +82,0 @@\n-import javax.lang.model.element.ExecutableElement;\n@@ -85,2 +84,0 @@\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementFilter;\n@@ -187,1 +184,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -231,1 +228,1 @@\n-    \/** Are primitive classes allowed\n+    \/** Are value classes allowed\n@@ -233,2 +230,1 @@\n-    private final boolean allowPrimitiveClasses;\n-\n+    private final boolean allowValueClasses;\n@@ -300,0 +296,10 @@\n+    \/** Warn about operation with bang types.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnNullableTypes(DiagnosticPosition pos, Warning warnKey) {\n+        if (lint.isEnabled(LintCategory.NULL)) {\n+            log.warning(LintCategory.NULL, pos, warnKey);\n+        }\n+    }\n+\n@@ -637,5 +643,0 @@\n-        } else {\n-            if (allowPrimitiveClasses && found.hasTag(CLASS)) {\n-                if (inferenceContext != infer.emptyContext)\n-                    checkParameterizationByPrimitiveClass(pos, found);\n-            }\n@@ -686,3 +687,6 @@\n-                if (lint.isEnabled(LintCategory.CAST))\n-                    log.warning(LintCategory.CAST,\n-                            tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                if (lint.isEnabled(LintCategory.CAST)) {\n+                    if (!lint.isEnabled(LintCategory.NULL) || !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n+                        log.warning(LintCategory.CAST,\n+                                tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                    }\n+                }\n@@ -715,1 +719,1 @@\n-    private boolean checkExtends(Type a, Type bound) {\n+    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n@@ -720,1 +724,11 @@\n-             return types.isSubtype(a, bound);\n+             try {\n+                 if (pos != null) {\n+                     types.pushWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.popWarner();\n+                 }\n+             }\n+\n@@ -772,1 +786,3 @@\n-    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+    void checkConstraintsOfValueClass(JCClassDecl tree, ClassSymbol c) {\n+        DiagnosticPosition pos = tree.pos();\n+        checkConstraintsOfValueClassesWithImplicitConst(tree, c);\n@@ -823,0 +839,22 @@\n+    void checkConstraintsOfValueClassesWithImplicitConst(JCClassDecl classDecl, ClassSymbol c) {\n+        JCMethodDecl implicitConstructor = TreeInfo.getImplicitConstructor(classDecl.defs);\n+        if (implicitConstructor != null) {\n+            Type encl = c.type.getEnclosingType();\n+            if (encl != null && encl.hasTag(CLASS)) {\n+                log.error(classDecl.pos(), Errors.ValueClassWithImplicitCannotBeInner(c));\n+            }\n+            if ((c.flags() & HASINITBLOCK) != 0) {\n+                log.error(classDecl.pos(), Errors.ValueClassWithImplicitDeclaresInitBlock(c));\n+            }\n+            for (Symbol s : c.members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case VAR:\n+                        if ((s.flags() & STATIC) == 0 & (s.flags() & HASINIT) != 0) {\n+                            log.error(classDecl.pos(), Errors.ValueClassWithImplicitInstanceFieldInitializer(c));\n+                        }\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -835,9 +873,0 @@\n-                \/\/ Projection types may not be mentioned in constructor references\n-                if (expr.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n-                    if (allowPrimitiveClasses && fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(expr, Errors.ProjectionCantBeInstantiated);\n-                        t = types.createErrorType(t);\n-                    }\n-                }\n@@ -879,1 +908,0 @@\n-     *  @param primitiveClassOK       If false, a primitive class does not qualify\n@@ -881,2 +909,2 @@\n-    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n-        if (t.isReference() && (!allowPrimitiveClasses || primitiveClassOK || !t.isPrimitiveClass()))\n+    Type checkRefType(DiagnosticPosition pos, Type t) {\n+        if (t.isReference())\n@@ -890,3 +918,3 @@\n-    \/** Check that type is an identity type, i.e. not a primitive\/value type\n-     *  nor its reference projection. When not discernible statically,\n-     *  give it the benefit of doubt and defer to runtime.\n+    \/** Check that type is an identity type, i.e. not a value type.\n+     *  When not discernible statically, give it the benefit of doubt\n+     *  and defer to runtime.\n@@ -908,1 +936,1 @@\n-        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n+        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface())\n@@ -912,9 +940,0 @@\n-    \/** Check that type is a reference type, i.e. a class, interface or array type\n-     *  or a type variable.\n-     *  @param pos           Position to be used for error reporting.\n-     *  @param t             The type to be checked.\n-     *\/\n-    Type checkRefType(DiagnosticPosition pos, Type t) {\n-        return checkRefType(pos, t, true);\n-    }\n-\n@@ -929,1 +948,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head, false);\n+            l.head = checkRefType(tl.head.pos(), l.head);\n@@ -965,49 +984,0 @@\n-    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n-        parameterizationByPrimitiveClassChecker.visit(t, pos);\n-    }\n-\n-    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n-     *  being used as type arguments and issues error against those usages.\n-     *\/\n-    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n-            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n-\n-        @Override\n-        public Void visitType(Type t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitClassType(ClassType t, DiagnosticPosition pos) {\n-            for (Type targ : t.allparams()) {\n-                if (allowPrimitiveClasses && targ.isPrimitiveClass()) {\n-                    log.error(pos, Errors.GenericParameterizationWithPrimitiveClass(t));\n-                }\n-                visit(targ, pos);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {\n-             return null;\n-        }\n-\n-        @Override\n-        public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {\n-            return visit(t.elemtype, pos);\n-        }\n-\n-        @Override\n-        public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {\n-            return visit(t.type, pos);\n-        }\n-    };\n-\n-\n-\n@@ -1162,5 +1132,1 @@\n-        Type varType = types.upward(t, types.captures(t)).baseType();\n-        if (allowPrimitiveClasses && varType.hasTag(CLASS)) {\n-            checkParameterizationByPrimitiveClass(pos, varType);\n-        }\n-        return varType;\n+        return types.upward(t, types.captures(t)).baseType();\n@@ -1189,1 +1155,0 @@\n-        \/\/ TODO - is enum so <init>\n@@ -1257,1 +1222,5 @@\n-        return firstIncompatibleTypeArg(t) == null;\n+        return checkValidGenericType(null, t);\n+    }\n+\n+    public boolean checkValidGenericType(JCTree pos, Type t) {\n+        return firstIncompatibleTypeArg(pos, t) == null;\n@@ -1260,1 +1229,1 @@\n-        private Type firstIncompatibleTypeArg(Type type) {\n+        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n@@ -1297,1 +1266,1 @@\n-                        !checkExtends(actual, bounds.head)) {\n+                        !checkExtends(pos, actual, bounds.head)) {\n@@ -1380,1 +1349,9 @@\n-                } else\n+                } else if ((flags & IMPLICIT) != 0) {\n+                    if ((flags & PUBLIC) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBePublic);\n+                    }\n+                    if ((sym.owner.flags_field & VALUE_CLASS) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBeDeclaredInValueClass);\n+                    }\n+                    mask = ImplicitConstructorFlags;\n+                } else {\n@@ -1382,0 +1359,1 @@\n+                }\n@@ -1438,2 +1416,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE_CLASS);\n@@ -1453,4 +1431,0 @@\n-            \/\/ primitive classes are implicitly final value classes.\n-            if ((flags & PRIMITIVE_CLASS) != 0)\n-                implicit |= VALUE_CLASS | FINAL;\n-\n@@ -1497,1 +1471,1 @@\n-                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                               FINAL | NATIVE | SYNCHRONIZED)\n@@ -1501,1 +1475,1 @@\n-                        PRIMITIVE_CLASS | VALUE_CLASS)\n+                        VALUE_CLASS)\n@@ -1647,1 +1621,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n@@ -1706,2 +1680,1 @@\n-                tree.selected.type.isParameterized() &&\n-                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n+                tree.selected.type.isParameterized()) {\n@@ -1711,2 +1684,0 @@\n-                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n-                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -2057,0 +2028,9 @@\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n+        }\n+        overrideWarner.remove(LintCategory.NULL);\n+        \/\/ at this point we know this will be true but to gather the warnings\n+        types.isSubSignature(mt, ot, overrideWarner);\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n+        }\n@@ -2534,0 +2514,1 @@\n+    \/\/ TODO, update this method once we have null restricted types\n@@ -2535,10 +2516,11 @@\n-        if (allowPrimitiveClasses) {\n-            Assert.check((tree.sym.flags_field & LOCKED) == 0);\n-            try {\n-                tree.sym.flags_field |= LOCKED;\n-                for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (l.head.hasTag(VARDEF)) {\n-                        JCVariableDecl field = (JCVariableDecl) l.head;\n-                        if (cyclePossible(field.sym)) {\n-                            checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n-                        }\n+        if (!tree.sym.type.hasImplicitConstructor()) {\n+            return;\n+        }\n+        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        try {\n+            tree.sym.flags_field |= LOCKED;\n+            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                if (l.head.hasTag(VARDEF)) {\n+                    JCVariableDecl field = (JCVariableDecl) l.head;\n+                    if (cyclePossible(field.sym)) {\n+                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n@@ -2547,2 +2529,0 @@\n-            } finally {\n-                tree.sym.flags_field &= ~LOCKED;\n@@ -2550,0 +2530,2 @@\n+        } finally {\n+            tree.sym.flags_field &= ~LOCKED;\n@@ -2569,1 +2551,1 @@\n-            return (symbol.flags() & STATIC) == 0 && allowPrimitiveClasses && symbol.type.isPrimitiveClass();\n+            return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n@@ -2821,0 +2803,6 @@\n+        boolean implementsLooselyConsistentValue = false;\n+        try {\n+            implementsLooselyConsistentValue = allowValueClasses ? types.asSuper(c, syms.looselyConsistentValueType.tsym) != null : false;\n+        } catch (CompletionFailure cf) {\n+            \/\/ ignore\n+        }\n@@ -2823,0 +2811,5 @@\n+        if (c.getKind() == TypeKind.DECLARED && implementsLooselyConsistentValue && !c.tsym.isAbstract()) {\n+            if (!cIsValue || ((ClassSymbol)c.tsym).getImplicitConstructor() == null) {\n+                log.error(pos, Errors.CantImplementInterface(c.tsym));\n+            }\n+        }\n@@ -4461,0 +4454,20 @@\n+    private class NullnessWarner extends Warner {\n+        public NullnessWarner(DiagnosticPosition pos) {\n+            super(pos);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            boolean warned = this.warned;\n+            super.warn(lint);\n+            if (warned) return; \/\/ suppress redundant diagnostics\n+            switch (lint) {\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    break;\n+                default:\n+                    throw new AssertionError(\"Unexpected lint: \" + lint);\n+            }\n+        }\n+    }\n+\n@@ -4489,0 +4502,3 @@\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    break;\n@@ -4492,0 +4508,21 @@\n+            this.warned = true;\n+        }\n+    }\n+\n+    private class CastWarner extends ConversionWarner {\n+        public CastWarner(DiagnosticPosition pos, String key, Type found, Type expected) {\n+            super(pos, key, found, expected);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (lint != LintCategory.NULL) {\n+                super.warn(lint);\n+            } else {\n+                boolean warned = this.warned;\n+                if (warned) return;\n+                if (expected.isParametric()) {\n+                    \/\/ not sure this is the right warning\n+                    Check.this.warnNullableTypes(pos(), Warnings.NarrowingNullnessConversion);\n+                }\n+            }\n@@ -4496,1 +4533,1 @@\n-        return new ConversionWarner(pos, \"unchecked.cast.to.type\", found, expected);\n+        return new CastWarner(pos, \"unchecked.cast.to.type\", found, expected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":168,"deletions":131,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -108,1 +107,0 @@\n-    boolean allowPrimitiveClasses;\n@@ -149,2 +147,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -512,4 +508,0 @@\n-        if (allowPrimitiveClasses) {\n-            ct.flavor = ct.flavor.metamorphose((c.flags_field & PRIMITIVE_CLASS) != 0);\n-        }\n-\n@@ -534,6 +526,0 @@\n-        if (allowPrimitiveClasses && ct.isPrimitiveClass()) {\n-            if (ct.projection != null) {\n-                ct.projection.typarams_field = ct.typarams_field;\n-                ct.projection.allparams_field = ct.allparams_field;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1601,1 +1601,1 @@\n-                    if (types.asSuper(sup.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null) {\n+                    if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {\n@@ -2151,1 +2151,2 @@\n-                isFinalUninitializedField(sym)));\n+                isFinalUninitializedField(sym)) ||\n+                isUninitializedNonNullableOrParametricField(sym));\n@@ -2164,0 +2165,7 @@\n+        boolean isUninitializedNonNullableOrParametricField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            (sym.type.isNonNullable() || sym.type.isParametric()));\n+        }\n+\n@@ -2274,0 +2282,9 @@\n+                if (isUninitializedNonNullableOrParametricField(sym)) {\n+                    if (lint.isEnabled(Lint.LintCategory.NULL)) {\n+                        if (sym.type.isNonNullable()) {\n+                            log.warning(pos, Warnings.NonNullableShouldBeInitialized);\n+                        } else {\n+                            log.warning(pos, Warnings.ParametricShouldBeInitialized);\n+                        }\n+                    }\n+                } else {\n@@ -2275,0 +2292,1 @@\n+                }\n@@ -2534,1 +2552,1 @@\n-                                } else {\n+                                } else if (!tree.sym.isImplicitConstructor()) { \/\/ implicit constructors are special, ignore them\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1875,1 +1875,1 @@\n-                return types.asSuper(tree.target.referenceProjectionOrSelf(), syms.serializableType.tsym) != null;\n+                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-    private final boolean allowPrimitiveClasses;\n@@ -106,0 +105,1 @@\n+    private final boolean emitQDesc;\n@@ -134,1 +134,0 @@\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -138,0 +137,1 @@\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -1237,3 +1237,0 @@\n-                \/\/ Make sure not to lose type fidelity due to symbol sharing between projections\n-                boolean requireReferenceProjection = allowPrimitiveClasses &&\n-                        tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref && tree.type.isReferenceProjection();\n@@ -1255,3 +1252,0 @@\n-                    if (requireReferenceProjection) {\n-                        tree.setType(tree.type.referenceProjection());\n-                    }\n@@ -1261,3 +1255,0 @@\n-                    if (requireReferenceProjection) {\n-                        tree.setType(tree.type.referenceProjection());\n-                    }\n@@ -1820,1 +1811,1 @@\n-        if (types.asSuper(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) == null) {\n+        if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {\n@@ -2204,2 +2195,1 @@\n-        return (tree == null) ? null :\n-                applyPrimitiveConversionsAsNeeded(boxIfNeeded(translate(tree), type), type);\n+        return (tree == null) ? null : boxIfNeeded(translate(tree), type);\n@@ -3233,11 +3223,0 @@\n-    \/** Apply primitive value\/reference conversions as needed *\/\n-    @SuppressWarnings(\"unchecked\")\n-    <T extends JCExpression> T applyPrimitiveConversionsAsNeeded(T tree, Type type) {\n-        boolean haveValue = tree.type.isPrimitiveClass();\n-        if (haveValue == type.isPrimitiveClass())\n-            return tree;\n-        \/\/ For narrowing conversion, insert a cast which should trigger a null check\n-        \/\/ For widening conversions, insert a cast if emitting a unified class file.\n-        return (T) make.TypeCast(type, tree);\n-    }\n-\n@@ -3642,1 +3621,1 @@\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type.referenceProjectionOrSelf()),\n+            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n@@ -3652,1 +3631,1 @@\n-            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n+            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n@@ -4229,0 +4208,2 @@\n+        \/\/ nullness info could be lost in the translation process, let's keep the original element type\n+        JCExpression originalElemType = tree.elemtype;\n@@ -4230,1 +4211,2 @@\n-        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail)\n+        int noOfDims = 0;\n+        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail) {\n@@ -4232,0 +4214,2 @@\n+            noOfDims++;\n+        }\n@@ -4233,1 +4217,26 @@\n-        result = tree;\n+        if (emitQDesc || tree.elemtype == null || !originalElemType.type.isNonNullable()) {\n+            result = tree;\n+        } else {\n+            Symbol elemClass = syms.getClassField(tree.elemtype.type, types);\n+            JCFieldAccess elemClassExpr = make.Select(make.Ident(tree.elemtype.type.tsym).setType(tree.elemtype.type), elemClass);\n+            MethodSymbol asNullRestrictedTypeMeth = lookupMethod(tree.pos(), names.asNullRestrictedType, syms.classType, List.nil());\n+            JCExpression asNullRestrictedTypeCall = make.Apply(\n+                        null,\n+                        make.Select(elemClassExpr, asNullRestrictedTypeMeth).setType(syms.classType), List.nil()).setType(syms.classType);\n+            List<JCExpression> dimsExp = tree.dims;\n+            if (noOfDims > 1) {\n+                JCNewArray dimsArr = make.NewArray(make.Type(syms.intType), List.nil(), tree.dims);\n+                dimsArr.type = types.makeArrayType(syms.intType);\n+                dimsExp = List.of(dimsArr);\n+            }\n+            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.newInstance,\n+                syms.reflectArrayType, List.of(syms.classType, noOfDims == 1 ? syms.intType : types.makeArrayType(syms.intType)));\n+            JCExpression call =\n+                    make.Apply(\n+                            null,\n+                            make.Select(make.Ident(syms.reflectArrayType.tsym).setType(syms.reflectArrayType), appyMeth).setType(syms.objectType),\n+                            dimsExp.prepend(asNullRestrictedTypeCall))\n+                            .setType(syms.objectType);\n+            JCExpression cast = make.TypeCast(types.makeArrayType(tree.elemtype.type, noOfDims), call);\n+            result = cast;\n+        }\n@@ -4244,5 +4253,0 @@\n-        \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-         * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-         * always matching the behavior of Object::getClass\n-         *\/\n-        boolean needPrimaryMirror = tree.name == names._class && tree.selected.type.isReferenceProjection();\n@@ -4250,3 +4254,0 @@\n-        if (needPrimaryMirror && allowPrimitiveClasses && tree.selected.type.isPrimitiveClass()) {\n-            tree.selected.setType(tree.selected.type.referenceProjection());\n-        }\n@@ -4260,1 +4261,1 @@\n-            Assert.checkNonNull(types.asSuper(currentClass.type.referenceProjectionOrSelf(), supSym));\n+            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -247,1 +247,2 @@\n-            int statsSize = tree.body.stats.size();\n+            \/\/ implicit constructors are empty bodied\n+            int statsSize = (tree.body == null) && ((tree.mods.flags & IMPLICIT) != 0) ? 0 : tree.body.stats.size();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -154,1 +153,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -423,14 +421,0 @@\n-        if (allowPrimitiveClasses) {\n-            if (sym.kind == MTH || sym.kind == VAR) {\n-                \/* If any primitive class types are involved, ask the same question in the reference universe,\n-                   where the hierarchy is navigable\n-                *\/\n-                if (site.isPrimitiveClass())\n-                    site = site.referenceProjection();\n-            } else if (sym.kind == TYP) {\n-                \/\/ A type is accessible in a reference projection if it was\n-                \/\/ accessible in the value projection.\n-                if (site.isReferenceProjection())\n-                    site = site.valueProjection();\n-            }\n-        }\n@@ -491,7 +475,0 @@\n-        \/* If any primitive class types are involved, ask the same question in the reference universe,\n-           where the hierarchy is navigable\n-        *\/\n-        if (allowPrimitiveClasses && site.isPrimitiveClass()) {\n-            site = site.referenceProjection();\n-        }\n-\n@@ -1720,1 +1697,1 @@\n-                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n+                    if (types.asSuper(m1Owner.type, m2Owner) != null &&\n@@ -1725,1 +1702,1 @@\n-                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n+                    if (types.asSuper(m2Owner.type, m1Owner) != null &&\n@@ -3627,1 +3604,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n@@ -3680,1 +3657,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n+                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);\n@@ -3742,1 +3719,1 @@\n-                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata(), site.getFlavor());\n+                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata());\n@@ -3832,1 +3809,1 @@\n-                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1073,0 +1073,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -64,0 +63,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -77,0 +78,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n@@ -112,4 +114,0 @@\n-    \/** Switch: allow primitive classes.\n-     *\/\n-    boolean allowPrimitiveClasses;\n-\n@@ -140,0 +138,8 @@\n+    \/** Switch: does this value class has an implicit constructor\n+     *\/\n+    public boolean hasImplicitConstructor;\n+\n+    \/** Switch: emit Q descriptors\n+     *\/\n+    private boolean emitQDesc;\n+\n@@ -294,1 +300,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -308,0 +313,2 @@\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n+\n@@ -518,1 +525,1 @@\n-                if ((char) signature[sigp] == 'Q' && !allowPrimitiveClasses) {\n+                if ((char) signature[sigp] == 'Q' && !emitQDesc) {\n@@ -580,1 +587,1 @@\n-        if (prefix != 'L' && (!allowPrimitiveClasses || prefix != 'Q'))\n+        if (prefix != 'L' && (!emitQDesc || prefix != 'Q'))\n@@ -585,1 +592,0 @@\n-        ClassType.Flavor flavor;\n@@ -598,1 +604,0 @@\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -602,2 +607,1 @@\n-                        \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n-                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n@@ -605,1 +609,1 @@\n-                    return new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    return new ClassType(outer, List.nil(), t, List.nil());\n@@ -616,2 +620,1 @@\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                outer = new ClassType(outer, sigToTypes('>'), t, List.nil(), flavor) {\n+                outer = new ClassType(outer, sigToTypes('>'), t, List.nil()) {\n@@ -681,2 +684,1 @@\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                    outer = new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    outer = new ClassType(outer, List.nil(), t, List.nil());\n@@ -1351,0 +1353,21 @@\n+            new AttributeReader(names.ImplicitCreation, V63, CLASS_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind == TYP) {\n+                        nextChar();\n+                        hasImplicitConstructor = true;\n+                    }\n+                }\n+            },\n+            new AttributeReader(names.NullRestricted, V63, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    sym.type = sym.type.asNullMarked(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL);\n+                }\n+            },\n@@ -2360,0 +2383,4 @@\n+            if (hasImplicitConstructor && type.getParameterTypes().size() == 0) {\n+                \/\/ this has to be the implicit constructor\n+                flags |= IMPLICIT;\n+            }\n@@ -2639,1 +2666,1 @@\n-            if (!allowPrimitiveClasses || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n+            if (!emitQDesc || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n@@ -2702,1 +2729,3 @@\n-        for (int i = 0; i < fieldCount; i++) enterMember(c, readField());\n+        for (int i = 0; i < fieldCount; i++) {\n+            enterMember(c, readField());\n+        }\n@@ -2871,0 +2900,2 @@\n+        \/\/ we need to do some checks now that the class has been loaded\n+        checkNonCyclicMembership(c);\n@@ -2907,6 +2938,0 @@\n-        if ((flags & ACC_PRIMITIVE) != 0) {\n-            flags &= ~ACC_PRIMITIVE;\n-            if (allowPrimitiveClasses) {\n-                flags |= PRIMITIVE_CLASS;\n-            }\n-        }\n@@ -3153,0 +3178,51 @@\n+\n+    \/\/ A value class cannot contain a non-nullable instance field of its own type either directly or indirectly.\n+    void checkNonCyclicMembership(ClassSymbol csym) {\n+        if (!allowValueClasses || !csym.type.hasImplicitConstructor()) {\n+            \/\/ nothing to see here\n+            return;\n+        }\n+        Assert.check((csym.flags_field & LOCKED) == 0);\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol field : csym.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(field);\n+            }\n+            csym.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            csym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembershipHelper(ClassSymbol c) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            JavaFileObject prevSource = log.useSource(currentClassFile);\n+            try {\n+                log.error(CompilerProperties.Errors.CyclicPrimitiveClassMembership(c));\n+                return;\n+            } finally {\n+                log.useSource(prevSource);\n+            }\n+        }\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(fld);\n+            }\n+            c.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private boolean cyclePossible(VarSymbol symbol) {\n+        return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":101,"deletions":25,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-import com.sun.tools.javac.code.Scope.WriteableScope;\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -86,0 +84,4 @@\n+    \/** Switch: emit Q descriptors\n+     *\/\n+    private boolean emitQDesc;\n+\n@@ -113,2 +115,0 @@\n-    private boolean allowPrimitiveClasses;\n-\n@@ -200,2 +200,1 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -385,0 +384,3 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeNullRestrictedIfNeeded(sym);\n+        }\n@@ -846,1 +848,1 @@\n-            int flags = adjustFlags(inner.flags_field);\n+            int flags = adjustFlags(inner, inner.flags_field);\n@@ -956,0 +958,24 @@\n+    \/** Write \"ImplicitCreation\" attribute.\n+     *\/\n+    int writeImplicitCreationIfNeeded(ClassSymbol csym) {\n+        if (csym.isValueClass() && csym.getImplicitConstructor() != null) {\n+            int alenIdx = writeAttr(names.ImplicitCreation);\n+            int flags = ACC_DEFAULT | (csym.isSubClass(syms.looselyConsistentValueType.tsym, types) ? ACC_NON_ATOMIC : 0);\n+            databuf.appendChar(flags);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/** Write \"NullRestricted\" attribute.\n+     *\/\n+    int writeNullRestrictedIfNeeded(Symbol sym) {\n+        if (sym.kind == VAR && sym.type.isNonNullable()) {\n+            int alenIdx = writeAttr(names.NullRestricted);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n@@ -987,1 +1013,1 @@\n-        int flags = adjustFlags(v.flags());\n+        int flags = adjustFlags(v, v.flags());\n@@ -1016,1 +1042,1 @@\n-        int flags = adjustFlags(m.flags());\n+        int flags = adjustFlags(m, m.flags());\n@@ -1303,1 +1329,1 @@\n-                databuf.appendChar(allowPrimitiveClasses && t.isPrimitiveClass() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n+                databuf.appendChar(emitQDesc && t.hasImplicitConstructor() && t.isNonNullable() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n@@ -1616,1 +1642,1 @@\n-            flags = adjustFlags(c.flags() & ~(DEFAULT | STRICTFP));\n+            flags = adjustFlags(c, c.flags() & ~(DEFAULT | STRICTFP));\n@@ -1734,0 +1760,4 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeImplicitCreationIfNeeded(c);\n+        }\n+\n@@ -1779,1 +1809,1 @@\n-    int adjustFlags(final long flags) {\n+    int adjustFlags(Symbol sym, final long flags) {\n@@ -1792,2 +1822,6 @@\n-        if ((flags & PRIMITIVE_CLASS) != 0)\n-            result |= ACC_PRIMITIVE;\n+        if (emitQDesc && sym.kind == TYP) {\n+            ClassSymbol csym = (ClassSymbol)sym;\n+            if (csym.isValueClass() && csym.getImplicitConstructor() != null) {\n+                result |= ACC_PRIMITIVE;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":48,"deletions":14,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-    private boolean allowPrimitiveClasses;\n@@ -199,2 +198,1 @@\n-                PoolWriter poolWriter,\n-                boolean allowPrimitiveClasses) {\n+                PoolWriter poolWriter) {\n@@ -222,1 +220,0 @@\n-        this.allowPrimitiveClasses = allowPrimitiveClasses;\n@@ -1786,6 +1783,2 @@\n-                if (!allowPrimitiveClasses) {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)));\n-                } else {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||\n-                            (old.isPrimitiveClass() != t.isPrimitiveClass() && types.isConvertible(types.erasure(old), types.erasure(t))));\n-                }\n+                Assert.check(types.isSubtype(types.erasure(old),\n+                                       types.erasure(t)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -138,2 +138,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -141,0 +139,1 @@\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -150,0 +149,1 @@\n+    private final boolean emitQDesc;\n@@ -184,2 +184,0 @@\n-    boolean allowPrimitiveClasses;\n-\n@@ -280,0 +278,4 @@\n+    int makeRef(DiagnosticPosition pos, Type type) {\n+        return makeRef(pos, type, false);\n+    }\n+\n@@ -289,9 +291,0 @@\n-    \/** Insert a reference to given type in the constant pool,\n-     *  checking for an array with too many dimensions;\n-     *  return the reference's index.\n-     *  @param type   The type for which a reference is inserted.\n-     *\/\n-    int makeRef(DiagnosticPosition pos, Type type) {\n-        return makeRef(pos, type, false);\n-    }\n-\n@@ -932,0 +925,4 @@\n+            if (pts.head.isNonNullable() && !l.head.type.isNonNullable()) {\n+                code.emitop0(dup);\n+                genNullCheck(l.head);\n+            }\n@@ -1072,2 +1069,1 @@\n-                                        poolWriter,\n-                                        allowPrimitiveClasses);\n+                                        poolWriter);\n@@ -1083,0 +1079,2 @@\n+                selfType = selfType.hasImplicitConstructor() ?\n+                        selfType.addMetadata(new TypeMetadata.NullMarker(JCNullableTypeExpression.NullMarker.NOT_NULL)) : selfType;\n@@ -1087,1 +1085,3 @@\n-                            new VarSymbol(FINAL, names._this, selfType, meth.owner)));\n+                            new VarSymbol(FINAL, names._this,\n+                                    selfType,\n+                                    meth.owner)));\n@@ -1115,0 +1115,4 @@\n+                if (tree.type.isNonNullable() && !tree.init.type.isNonNullable()) {\n+                    code.emitop0(dup);\n+                    genNullCheck(tree.init);\n+                }\n@@ -2120,1 +2124,1 @@\n-                code.emitAnewarray(makeRef(pos, elemtype, elemtype.isPrimitiveClass()), type);\n+                code.emitAnewarray(makeRef(pos, elemtype, emitQDesc && elemtype.hasImplicitConstructor() && elemtype.isNonNullable()), type);\n@@ -2136,0 +2140,4 @@\n+        if (tree.lhs.type.isNonNullable() && !tree.rhs.type.isNonNullable()) {\n+            code.emitop0(dup);\n+            genNullCheck(tree.rhs);\n+        }\n@@ -2341,0 +2349,4 @@\n+        if (tree.clazz.type.isNonNullable() && !tree.expr.type.isNonNullable()) {\n+            code.emitop0(dup);\n+            genNullCheck(tree.expr);\n+        }\n@@ -2346,1 +2358,0 @@\n-        \/\/ primitive reference conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n@@ -2349,2 +2360,1 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n-           !types.isSubtype(tree.expr.type, tree.clazz.type)) {\n+           types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {\n@@ -2352,1 +2362,1 @@\n-            if (tree.clazz.type.isPrimitiveClass()) {\n+            if (emitQDesc && tree.clazz.type.hasImplicitConstructor() && tree.clazz.type.isNonNullable()) {\n@@ -2357,1 +2367,0 @@\n-\n@@ -2419,1 +2428,2 @@\n-            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type,\n+                    emitQDesc && tree.selected.type.hasImplicitConstructor() && tree.selected.type.isNonNullable()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -128,2 +128,0 @@\n-        if (t.isReferenceProjection())\n-            t = t.valueProjection();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,0 +214,6 @@\n+    \/** Does the target VM support value classes\n+     *\/\n+    public boolean hasValueClasses() {\n+        return compareTo(JDK1_19) >= 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.code.TypeMetadata;\n@@ -57,0 +58,1 @@\n+import com.sun.tools.javac.util.Options;\n@@ -93,0 +95,2 @@\n+    private boolean emitQDesc;\n+\n@@ -124,0 +128,2 @@\n+        Options options = Options.instance(context);\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -195,1 +201,6 @@\n-                VarSymbol product = currentMethod.factoryProduct = new VarSymbol(0, names.dollarValue, currentClass.sym.type, currentMethod.sym); \/\/ TODO: owner needs rewiring\n+                VarSymbol product = currentMethod.factoryProduct =\n+                        new VarSymbol(0, names.dollarValue,\n+                                currentClass.sym.type.hasImplicitConstructor() ?\n+                                        currentClass.sym.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n+                                        currentClass.sym.type,\n+                                currentMethod.sym); \/\/ TODO: owner needs rewiring\n@@ -203,1 +214,5 @@\n-                    final JCExpression type = make.Type(currentClass.type);\n+                    final JCExpression type = make.Type(\n+                            currentClass.sym.type.hasImplicitConstructor() ?\n+                                    currentClass.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n+                                    currentClass.type\n+                            );\n@@ -205,1 +220,3 @@\n-                    rhs.type = currentClass.type;\n+                    rhs.type = currentClass.sym.type.hasImplicitConstructor() ?\n+                            currentClass.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)) :\n+                            currentClass.type;\n@@ -224,1 +241,3 @@\n-                currentMethod.setType(factorySym.type);\n+                MethodType mt = (MethodType) factorySym.type;\n+                mt.restype = mt.restype.addMetadata((new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL)));\n+                currentMethod.setType(mt);\n@@ -277,1 +296,5 @@\n-                result = make.Assign(facHandle, make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type)).setType(currentClass.type);\n+                JCTree.JCWithField withField = (JCTree.JCWithField) make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type);\n+                if (withField.type.hasImplicitConstructor()) {\n+                    withField.type = withField.type.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+                }\n+                result = make.Assign(facHandle, withField).setType(currentClass.type);\n@@ -333,13 +356,0 @@\n-            if (selectedType.isReferenceProjection()) {\n-                switch (sym.kind) {\n-                    case MTH:\n-                    case VAR:\n-                        if (sym.isStatic() && sitesym != null && sitesym.kind == TYP) {\n-                            fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n-                        }\n-                        break;\n-                    case TYP:\n-                        fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n-                        break;\n-                }\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym, sym.type.getFlavor());\n+            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym);\n@@ -301,1 +301,1 @@\n-        if (types.asSuper(site.referenceProjectionOrSelf(), sym.getEnclosingElement()) == null)\n+        if (types.asSuper(site, sym.getEnclosingElement()) == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -71,0 +72,1 @@\n+import java.util.function.BiFunction;\n@@ -198,1 +200,0 @@\n-        this.allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && fac.options.isSet(\"enablePrimitiveClasses\");\n@@ -223,1 +224,0 @@\n-        this.allowPrimitiveClasses = parser.allowPrimitiveClasses;\n@@ -262,4 +262,0 @@\n-    \/** Switch: are primitive classes allowed in this source level?\n-     *\/\n-     boolean allowPrimitiveClasses;\n-\n@@ -284,0 +280,1 @@\n+     *     mode |= NOQUES     : nullable types are not allowed\n@@ -291,0 +288,1 @@\n+    protected static final int NOQUES        = 1 << 6;\n@@ -309,1 +307,1 @@\n-        setMode((mode & NOLAMBDA) | EXPR);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | EXPR);\n@@ -313,1 +311,1 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | TYPE);\n@@ -724,0 +722,4 @@\n+        if (EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            setNullMarker(t);\n+            nextToken();\n+        }\n@@ -1160,1 +1162,12 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, NOQUES | TYPE);\n+                    if (token.kind == QUES && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        if (peekToken(IDENTIFIER, COMMA) || peekToken(IDENTIFIER, SEMI) ||\n+                                peekToken(IDENTIFIER, RPAREN) || peekToken(IDENTIFIER, INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        } else if (peekToken(COMMA) || peekToken(SEMI) ||\n+                                peekToken(RPAREN) || peekToken(QUES) || peekToken(INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        }\n+                    }\n@@ -1341,0 +1354,1 @@\n+        boolean emotionalMarkersOK = false;\n@@ -1490,0 +1504,6 @@\n+                if (EMOTIONAL_QUALIFIER.test(token.kind) && (peekToken(LBRACKET) || peekToken(LT))) {\n+                    emotionalMarkersOK = true;\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                }\n@@ -1509,0 +1529,4 @@\n+                            if (EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                setNullMarker(t);\n+                                nextToken();\n+                            }\n@@ -1649,0 +1673,10 @@\n+            if (EMOTIONAL_QUALIFIER.test(token.kind) && (token.kind == QUES || token.kind == BANG || (token.kind == STAR))) {\n+                if (peekToken(LBRACKET) || peekToken(LT) || emotionalMarkersOK) {\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                } else {\n+                    \/\/ not a type\n+                    break;\n+                }\n+            }\n@@ -1765,1 +1799,6 @@\n-            if (token.kind == LBRACKET) {\n+            if (isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree)) {\n+                setNullMarker(t);\n+                selectTypeMode();\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1774,0 +1813,4 @@\n+                        if (isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1858,0 +1901,13 @@\n+    void setNullMarker(JCExpression exp) {\n+        setNullMarker(exp, token);\n+    }\n+\n+    void setNullMarker(JCExpression exp, Token tk) {\n+        ((JCNullableTypeExpression)exp).setNullMarker(\n+                tk.kind == QUES ?\n+                        NullMarker.NULLABLE :\n+                        token.kind == BANG ?\n+                                NullMarker.NOT_NULL :\n+                                NullMarker.PARAMETRIC);\n+    }\n+\n@@ -1923,1 +1979,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -1991,0 +2047,15 @@\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW)) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET) ) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' or\n+                        \/\/ Identifier, '!'\/'?', '[' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -2013,0 +2084,1 @@\n+                            peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, RPAREN) ||\n@@ -2015,0 +2087,1 @@\n+                        \/\/ '[', ']', '!', ')' -> cast\n@@ -2017,0 +2090,6 @@\n+                    } else if (peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER)) {\n+                        \/\/consume the ']' and the '!' and skip\n+                        type = true;\n+                        lookahead++;\n+                        lookahead++;\n+                        break;\n@@ -2035,0 +2114,1 @@\n+                                peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN) ||\n@@ -2094,0 +2174,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> INSTANCEOF_INFIX = t -> t == AMPAMP || t == BARBAR ||\n+                                                           t == EQEQ || t == BANGEQ;\n@@ -2433,0 +2517,6 @@\n+        } else if (EMOTIONAL_QUALIFIER.test(token.kind) && peekToken(LBRACKET)) {\n+            Token nullMarker = token;\n+            nextToken();\n+            int pos = token.pos;\n+            nextToken();\n+            t = bracketsOptCont(t, pos, nextLevelAnnotations, nullMarker);\n@@ -2455,0 +2545,5 @@\n+        return bracketsOptCont(t, pos, annotations, null);\n+    }\n+\n+    private JCExpression bracketsOptCont(JCExpression t, int pos,\n+                                         List<JCAnnotation> annotations, Token nullMarker) {\n@@ -2458,0 +2553,3 @@\n+        if (nullMarker != null) {\n+            setNullMarker(t, nullMarker);\n+        }\n@@ -2615,1 +2713,1 @@\n-            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS | Flags.FINAL);\n+            long badModifiers = mods.flags & ~(Flags.VALUE_CLASS | Flags.FINAL);\n@@ -2972,1 +3070,1 @@\n-        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+        if ((isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n@@ -3379,0 +3477,12 @@\n+                    } else if (typeDepth == 0 &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON))) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } else if (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3393,0 +3503,2 @@\n+                case BANG:\n+                    if (!peekToken(lookahead, LPAREN)) break;\n@@ -3567,4 +3679,0 @@\n-                if (isPrimitiveModifier()) {\n-                    flag = Flags.PRIMITIVE_CLASS;\n-                    break;\n-                }\n@@ -3579,0 +3687,4 @@\n+                if (isImplicitModifier()) {\n+                    flag = Flags.IMPLICIT;\n+                    break;\n+                }\n@@ -3845,5 +3957,0 @@\n-        if (name == names.primitive) {\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            }\n-        }\n@@ -3858,1 +3965,6 @@\n-            if (allowPrimitiveClasses) {\n+            if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n+        if (name == names.implicit) {\n+            if (allowValueClasses) {\n@@ -4930,26 +5042,0 @@\n-    protected boolean isPrimitiveModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.primitive) {\n-            boolean isPrimitiveModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n-                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n-                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n-                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n-                case CLASS: case INTERFACE: case ENUM:\n-                    isPrimitiveModifier = true;\n-                    break;\n-                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n-                            || next.name() == names.value || (mode & EXPR) != 0)\n-                        isPrimitiveModifier = true;\n-                    break;\n-            }\n-            if (isPrimitiveModifier) {\n-                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -4968,1 +5054,1 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || new value Comparable() {} ??\n@@ -4970,1 +5056,1 @@\n-                            || next.name() == names.primitive || (mode & EXPR) != 0)\n+                            || (mode & EXPR) != 0)\n@@ -4995,1 +5081,1 @@\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                    if (next.name() == names.record || next.name() == names.identity\n@@ -5008,0 +5094,19 @@\n+    protected boolean isImplicitModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.implicit) {\n+            boolean isImplicitModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case MONKEYS_AT:\n+                case STATIC: case FINAL: case ABSTRACT: case NATIVE:\n+                case SYNCHRONIZED: case STRICTFP: case DEFAULT: case IDENTIFIER:\n+                    isImplicitModifier = true;\n+                    break;\n+            }\n+            if (isImplicitModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -5525,4 +5630,1 @@\n-        if (feature == Feature.PRIMITIVE_CLASSES && !allowPrimitiveClasses) {\n-            \/\/ primitive classes are special\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n-        } else if (preview.isPreview(feature) && !preview.isEnabled()) {\n+        if (preview.isPreview(feature) && !preview.isEnabled()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":158,"deletions":56,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -1344,1 +1343,1 @@\n-                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil(), Flavor.X_Typeof_X);\n+                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -483,0 +483,4 @@\n+            case CLASS:\n+                modifiers.remove(Modifier.IDENTITY);\n+                break;\n+\n@@ -486,0 +490,1 @@\n+                modifiers.remove(Modifier.IDENTITY);\n@@ -492,0 +497,1 @@\n+                modifiers.remove(Modifier.IDENTITY);\n@@ -496,0 +502,1 @@\n+                modifiers.remove(Modifier.IDENTITY);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3204,0 +3204,3 @@\n+compiler.misc.feature.bang.types=\\\n+    bang types\n+\n@@ -4051,6 +4054,1 @@\n-    cyclic primitive class membership involving {0}\n-\n-# 0: string (expected version)\n-compiler.err.primitive.classes.not.supported=\\\n-    primitive classes are not supported\\n\\\n-     (use -source {0} or higher to enable primitive classes and pass compiler option: -XDenablePrimitiveClasses)\n+    cyclic value class membership involving {0}\n@@ -4117,0 +4115,14 @@\n+# 0: symbol\n+compiler.err.value.class.with.implicit.cannot.be.inner=\\\n+    The value class {0} declares an implicit constructor. It cannot be an inner class.\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.declares.init.block=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    It cannot declare one or more non-empty instance initializer blocks\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.instance.field.initializer=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    And it defines an instance field with an initializer. This is disallowed.\n+\n@@ -4125,3 +4137,0 @@\n-compiler.err.projection.cant.be.instantiated=\\\n-    Illegal attempt to instantiate a projection type\n-\n@@ -4131,0 +4140,14 @@\n+compiler.err.implicit.const.cant.have.body=\\\n+    implicit constructors cannot have a body\n+\n+compiler.err.implicit.const.must.be.public=\\\n+    implicit constructors must be public\n+\n+compiler.err.implicit.const.must.be.declared.in.value.class=\\\n+    only value classes can declare implicit constructors\n+\n+# 0: symbol\n+compiler.err.cant.implement.interface=\\\n+    class {0} cannot implement LooselyConsistentValue interface. Concrete classes implementing this interface must:\\n\\\n+     be value classes and declare an implicit constructor.\n+\n@@ -4155,0 +4178,39 @@\n+\n+### null-restricted types\n+\n+compiler.err.non.nullable.cannot.be.assigned.null=\\\n+    non-nullable type cannot be assigned null\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    it must be a value class with an implicit constructor\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted.2=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    its element type must be a value class with an implicit constructor\n+\n+compiler.warn.narrowing.nullness.conversion=\\\n+    narrowing nullness conversion\n+\n+compiler.warn.unchecked.nullness.conversion=\\\n+    unchecked nullness conversion\n+\n+compiler.warn.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+compiler.warn.parametric.should.be.initialized=\\\n+    field of parametric type should be initialized\n+\n+compiler.warn.accessing.member.of.nullable=\\\n+    accessing member of nullable type\n+\n+compiler.warn.accessing.member.of.parametric=\\\n+    accessing member of parametric type\n+\n+compiler.warn.overrides.with.different.nullness.1=\\\n+    overriding method''s return type does not match nullness of overridden method\n+\n+compiler.warn.overrides.with.different.nullness.2=\\\n+    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":71,"deletions":9,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -225,0 +225,3 @@\n+javac.opt.Xlint.desc.null=\\\n+    Warn about operations on null-restricted and nullable types.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2639,1 +2639,1 @@\n-    public static class JCFieldAccess extends JCExpression implements MemberSelectTree {\n+    public static class JCFieldAccess extends JCNullableTypeExpression implements MemberSelectTree {\n@@ -2776,1 +2776,1 @@\n-    public static class JCIdent extends JCExpression implements IdentifierTree {\n+    public static class JCIdent extends JCNullableTypeExpression implements IdentifierTree {\n@@ -2885,1 +2885,1 @@\n-    public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {\n+    public static class JCArrayTypeTree extends JCNullableTypeExpression implements ArrayTypeTree {\n@@ -2910,1 +2910,1 @@\n-    public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {\n+    public static class JCTypeApply extends JCNullableTypeExpression implements ParameterizedTypeTree {\n@@ -2968,0 +2968,34 @@\n+    \/**\n+     * A nullable type expression. Supported nullable expression types are: simple type names,\n+     * qualified type names, parameterized types and array types.\n+     *\/\n+\n+    public static abstract class JCNullableTypeExpression extends JCExpression {\n+        private NullMarker nullMarker = NullMarker.UNSPECIFIED;\n+\n+        public NullMarker getNullMarker() {\n+            return nullMarker;\n+        }\n+\n+        public void setNullMarker(NullMarker nullMarker) {\n+            this.nullMarker = nullMarker;\n+        }\n+\n+        public enum NullMarker {\n+            NOT_NULL(\"!\"),\n+            NULLABLE(\"?\"),\n+            PARAMETRIC(\"*\"),\n+            UNSPECIFIED(\"\");\n+\n+            private final String typeSuffix;\n+\n+            NullMarker(String typeSuffix) {\n+                this.typeSuffix = typeSuffix;\n+            }\n+\n+            public String typeSuffix() {\n+                return typeSuffix;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -194,0 +194,3 @@\n+                if (tree instanceof JCNullableTypeExpression nullableType) {\n+                    print(nullableType.getNullMarker().typeSuffix());\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -127,0 +127,6 @@\n+    public static JCMethodDecl getImplicitConstructor(List<JCTree> trees) {\n+        for (List<JCTree> l = trees; l.nonEmpty(); l = l.tail)\n+            if (isConstructor(l.head) && (((JCMethodDecl)l.head).mods.flags & IMPLICIT) != 0) return (JCMethodDecl) l.head;\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -877,22 +877,7 @@\n-                if (t.isReferenceProjection()) {\n-                    \/\/ For parameterized types, we want V.ref<A1 ... An> not V<A1 ... An>.ref\n-                    JCExpression vp = Type(t.valueProjection());\n-                    if (vp.hasTag(Tag.TYPEAPPLY)) {\n-                        \/\/ vp now is V<A1 ... An>, build V.ref<A1 ... An>\n-                        JCFieldAccess f = Select(((JCTypeApply) vp).clazz, t.tsym);\n-                        f.name = names.ref;\n-                        tp = TypeApply(f, ((JCTypeApply) vp).arguments);\n-                    } else {\n-                        JCFieldAccess f = Select(vp, t.tsym);\n-                        f.name = names.ref;\n-                        tp = f;\n-                    }\n-                } else {\n-                    Type outer = t.getEnclosingType();\n-                    JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n-                            ? Select(Type(outer), t.tsym)\n-                            : QualIdent(t.tsym);\n-                    tp = t.getTypeArguments().isEmpty()\n-                            ? clazz\n-                            : TypeApply(clazz, Types(t.getTypeArguments()));\n-                }\n+                Type outer = t.getEnclosingType();\n+                JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n+                        ? Select(Type(outer), t.tsym)\n+                        : QualIdent(t.tsym);\n+                tp = t.getTypeArguments().isEmpty()\n+                        ? clazz\n+                        : TypeApply(clazz, Types(t.getTypeArguments()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-    public final Name primitive;\n@@ -177,0 +176,2 @@\n+    public final Name ImplicitCreation;\n+    public final Name NullRestricted;\n@@ -217,2 +218,0 @@\n-    public final Name ref;\n-    public final Name val;\n@@ -251,0 +250,5 @@\n+    \/\/ value classes\n+    public final Name implicit;\n+    public final Name newInstance;\n+    public final Name asNullRestrictedType;\n+\n@@ -316,1 +320,0 @@\n-        primitive = fromString(\"primitive\");\n@@ -386,0 +389,2 @@\n+        ImplicitCreation = fromString(\"ImplicitCreation\");\n+        NullRestricted = fromString(\"NullRestricted\");\n@@ -423,1 +428,0 @@\n-        \/\/ primitive classes\n@@ -425,2 +429,0 @@\n-        ref = fromString(\"ref\");\n-        val = fromString(\"val\");\n@@ -453,0 +455,5 @@\n+\n+        \/\/value classes\n+        implicit = fromString(\"implicit\");\n+        newInstance = fromString(\"newInstance\");\n+        asNullRestrictedType = fromString(\"asNullRestrictedType\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -83,0 +83,5 @@\n+    public void remove(LintCategory lint) {\n+        nonSilentLintSet.remove(lint);\n+        silentLintSet.remove(lint);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -286,0 +286,8 @@\n+                void addValue(TypeElement e) {\n+                    if (e.getModifiers().contains(Modifier.VALUE)) {\n+                        list.add(\"value\");\n+                    } else if (e.getModifiers().contains(Modifier.IDENTITY)) {\n+                        list.add(\"identity\");\n+                    }\n+                }\n+\n@@ -297,0 +305,1 @@\n+                    addValue(e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -64,1 +64,4 @@\n-    public static enum Kind { Class, InnerClass, Field, Method}\n+    public static final int ACC_DEFAULT       = 0x0001; \/\/ ImplicitCreation attribute\n+    public static final int ACC_NON_ATOMIC    = 0x0002; \/\/ ImplicitCreation attribute\n+\n+    public static enum Kind { Class, InnerClass, Field, Method, ImplicitCreationAttr}\n@@ -160,0 +163,6 @@\n+    private static final int[] implicitCreationAttrFlags = { ACC_DEFAULT, ACC_NON_ATOMIC };\n+\n+    public Set<String> getImplicitCreationAttrFlags() {\n+        return getFlags(implicitCreationAttrFlags, Kind.ImplicitCreationAttr);\n+    }\n+\n@@ -224,1 +233,1 @@\n-            return \"ACC_PUBLIC\";\n+            return t == Kind.ImplicitCreationAttr ? \"ACC_DEFAULT\" : \"ACC_PUBLIC\";\n@@ -226,1 +235,1 @@\n-            return \"ACC_PRIVATE\";\n+            return t == Kind.ImplicitCreationAttr ? \"ACC_NON_ATOMIC\" : \"ACC_PRIVATE\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    public static final String ImplicitCreation         = \"ImplicitCreation\";\n@@ -63,0 +64,1 @@\n+    public static final String NullRestricted           = \"NullRestricted\";\n@@ -127,0 +129,1 @@\n+            standardAttributes.put(ImplicitCreation, ImplicitCreation_attribute.class);\n@@ -140,0 +143,1 @@\n+            standardAttributes.put(NullRestricted, NullRestricted_attribute.class);\n@@ -195,0 +199,1 @@\n+        R visitImplicitCreation(ImplicitCreation_attribute attr, P p);\n@@ -208,0 +213,1 @@\n+        R visitNullRestricted(NullRestricted_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -469,0 +469,6 @@\n+        @Override\n+        public Void visitImplicitCreation(ImplicitCreation_attribute attr, ClassOutputStream out) {\n+            out.writeShort(attr.flags);\n+            return null;\n+        }\n+\n@@ -535,0 +541,5 @@\n+        @Override\n+        public Void visitNullRestricted(NullRestricted_attribute attr, ClassOutputStream out) {\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+\n+public class ImplicitCreation_attribute extends Attribute {\n+\n+    public int flags;\n+\n+    ImplicitCreation_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        flags = cr.readUnsignedShort();\n+    }\n+\n+    public ImplicitCreation_attribute(int name_index, int flags) {\n+        super(name_index, 2);\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitImplicitCreation(this, data);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ImplicitCreation_attribute.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+public class NullRestricted_attribute extends Attribute {\n+    NullRestricted_attribute(ClassReader cr, int name_index, int length) {\n+        super(name_index, length);\n+    }\n+\n+    public NullRestricted_attribute(int name_index) {\n+        super(name_index, 0);\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitNullRestricted(this, data);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/NullRestricted_attribute.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.classfile.ClassWriter;\n@@ -49,0 +50,1 @@\n+import com.sun.tools.classfile.ImplicitCreation_attribute;\n@@ -63,0 +65,1 @@\n+import com.sun.tools.classfile.NullRestricted_attribute;\n@@ -318,0 +321,9 @@\n+    @Override\n+    public Void visitImplicitCreation(ImplicitCreation_attribute attr, Void ignore) {\n+        println(\"ImplicitCreation:\");\n+        indent(+1);\n+        AccessFlags flags = new AccessFlags(attr.flags);\n+        writeList(String.format(\"flags: (0x%04x) \", attr.flags), flags.getImplicitCreationAttrFlags(), \"\\n\");\n+        indent(-1);\n+        return null;\n+    }\n@@ -420,0 +432,6 @@\n+    @Override\n+    public Void visitNullRestricted(NullRestricted_attribute attr, Void ignore) {\n+        println(\"NullRestricted\");\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">DeprecatedClassByAnnotation<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">DeprecatedClassByAnnotation<\/span>\n@@ -140,1 +140,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestClass<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestClass<\/span>\n@@ -238,1 +238,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestError<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestError<\/span>\n@@ -249,1 +249,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestException<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestException<\/span>\n@@ -260,1 +260,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestInterface<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestInterface<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public static class <\/span><\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public static identity class <\/span><\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/TestHiddenTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">C1<\/span>\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">C1<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -185,1 +185,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlTag\/TestHtmlTag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public static class <\/span><\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public static identity class <\/span><\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -191,1 +191,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestLinkOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1358,1 +1358,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -543,1 +543,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-l\\\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-l\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/TestNewLanguageFeatures.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -267,1 +267,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/TestOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -239,1 +239,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -244,1 +244,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\"> class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -97,1 +97,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -118,1 +118,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -143,1 +143,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -174,1 +174,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R&lt;T&gt;<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R&lt;T&gt;<\/span>\"\"\",\n@@ -472,1 +472,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public record <\/span><span c\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity record <\/span><span c\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -97,1 +97,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -102,1 +102,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public non-sealed class <\/span><span class=\"element-name type-name-label\">B<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public non-sealed identity class <\/span><span class=\"element-name type-name-label\">B<\/span>\n@@ -144,1 +144,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -192,1 +192,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -215,1 +215,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -238,1 +238,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -263,1 +263,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -288,1 +288,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -312,1 +312,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -336,1 +336,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSealedTypes\/TestSealedTypes.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -95,1 +95,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -469,1 +469,1 @@\n-                    <\/span><span class=\"modifiers\">class <\/span><span class=\"element-name type-name-\\\n+                    <\/span><span class=\"modifiers\">identity class <\/span><span class=\"element-name type-name-\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeAnnotations\/TestTypeAnnotations.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                    public class <\/span><span class=\"element-name\"><a href=\"..\/src-html\/pkg\/ClassUse\\\n+                    public identity class <\/span><span class=\"element-name\"><a href=\"..\/src-html\/pkg\/ClassUse\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/TestTypeParameters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8308590\n+ * @summary  value classes\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestValueClasses\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestValueClasses extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestValueClasses();\n+        tester.runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testValueClassModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public value class ValueClass {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueClass.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public value final class <\/span><span class=\"element-name type-name-label\">ValueClass<\/span>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testIdentityClassModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public identity class IdentityClass {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/IdentityClass.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">IdentityClass<\/span>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testValueInterfaceModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public value interface ValueInterface {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueInterface.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public value interface <\/span><span class=\"element-name type-name-label\">ValueInterface<\/span><\/div>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testIdentityInterfaceModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public identity interface IdentityInterface {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/IdentityInterface.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public identity interface <\/span><span class=\"element-name type-name-label\">IdentityInterface<\/span><\/div>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    public void testImplicitConstModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+\n+                public value class ValueClassWithImplicitConst {\n+                    public implicit ValueClassWithImplicitConst();\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueClassWithImplicitConst.html\", true,\n+                \"\"\"\n+                <div class=\"member-signature\"><span class=\"modifiers\">public implicit<\/span>&nbsp;<span class=\"element-name\">ValueClassWithImplicitConst<\/span>()<\/div>\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueClasses\/TestValueClasses.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -1235,0 +1235,5 @@\n+        @Override\n+        public Void visitImplicitCreation(ImplicitCreation_attribute attr, T p) {\n+            return null;\n+        }\n+\n@@ -1256,1 +1261,6 @@\n-          public Void visitNestHost(NestHost_attribute attr, T p) {\n+        public Void visitNestHost(NestHost_attribute attr, T p) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitNullRestricted(NullRestricted_attribute attr, T p) {\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -132,0 +132,4 @@\n+    protected void assertOKWithWarning(String warning, int numberOfTimes, String... constructs) {\n+        assertCompile(expandMarkers(constructs), () -> assertCompileSucceededWithWarning(warning, numberOfTimes), false);\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/CompilationTestCase.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,6 @@\n+    public boolean containsWarningKey(String key, int numberOfWarnings) {\n+        return diags.stream()\n+                .filter(d -> d.getKind() == Diagnostic.Kind.WARNING || d.getKind() == Diagnostic.Kind.MANDATORY_WARNING)\n+                .filter(d -> d.getCode().equals(key)).count() == numberOfWarnings;\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/Diagnostics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -193,0 +193,8 @@\n+        }\n+    }\n+\n+    protected void assertCompileSucceededWithWarning(String warning, int numberOfWarnings) {\n+        if (diags.errorsFound())\n+            fail(\"Expected successful compilation\");\n+        if (!diags.containsWarningKey(warning, numberOfWarnings)) {\n+            fail(String.format(\"Expected compilation warning with %s, found %s\", warning, diags.keys()));\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/JavacTemplateTestBase.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+    public R visitImplicitCreation(ImplicitCreation_attribute attr, P p) { return null; }\n@@ -54,0 +55,1 @@\n+    public R visitNullRestricted(NullRestricted_attribute attr, P p) { return null; }\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AttributeVisitor.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-            \"0: #118(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n-            \"1: #118(): LOCAL_VARIABLE, {start_pc=2, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #120(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n+            \"1: #120(): LOCAL_VARIABLE, {start_pc=5, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n@@ -84,1 +84,1 @@\n-            \"0: #118(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #120(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/BridgeShouldHaveNoInteriorAnnotationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        return \"void eqtestObject() { if (null == new @TA String()); }\";\n+        return \"void eqtestObject(String s) { if (s == new @TA String()); }\";\n@@ -71,1 +71,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @TA ArrayList<@TB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList<String> as) { if (as == new @TA ArrayList<@TB String >()); }\";\n@@ -168,1 +168,1 @@\n-        return \"void eqtestObject() { if (null == new @RTA @RTA String()); }\";\n+        return \"void eqtestObject(String s) { if (s == new @RTA @RTA String()); }\";\n@@ -175,1 +175,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList<String> as) { if (as == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/NewObjects.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/api\/TestApisWithProjections.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,0 +229,11 @@\n+#nullable types\n+compiler.misc.feature.bang.types\n+compiler.warn.accessing.member.of.nullable\n+compiler.warn.narrowing.nullness.conversion\n+compiler.warn.non.nullable.should.be.initialized\n+compiler.warn.accessing.member.of.parametric\n+compiler.warn.parametric.should.be.initialized\n+compiler.err.non.nullable.cannot.be.assigned.null\n+compiler.warn.unchecked.nullness.conversion\n+compiler.warn.overrides.with.different.nullness.1\n+compiler.warn.overrides.with.different.nullness.2\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.type.cant.be.null.restricted\n+\/\/ key: compiler.err.type.cant.be.null.restricted.2\n+\n+public class CantBeNonNullableType {\n+    String! s;\n+    String[]! sa;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantBeNonNullableType.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.cant.implement.interface\n+\n+class CantImplementInterface implements LooselyConsistentValue {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantImplementInterface.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.cant.have.body\n+\n+value class ImplicitConstructorWithBody {\n+    public implicit ImplicitConstructorWithBody() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitConstructorWithBody.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.must.be.declared.in.value.class\n+\n+class ImplicitMustBeInValueClass {\n+    public implicit ImplicitMustBeInValueClass();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitMustBeInValueClass.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.must.be.public\n+\n+value class ImplicitMustBePublic {\n+    implicit ImplicitMustBePublic();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitMustBePublic.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.primitive.classes.not.supported\n-\n-public primitive class PrimitiveClassesNotSupported {\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveClassesNotSupported.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.projection.cant.be.instantiated\n-\/\/ options: -XDenablePrimitiveClasses\n-\n-public primitive class ProjectionCantBeInstantiated {\n-    int x = 42;\n-    public static void main(String[] args) {\n-        new ProjectionCantBeInstantiated();\n-        new ProjectionCantBeInstantiated.ref();\n-        new ProjectionCantBeInstantiated.val();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProjectionCantBeInstantiated.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -25,1 +25,0 @@\n-\/\/ options: -XDenablePrimitiveClasses\n@@ -27,3 +26,2 @@\n-primitive class SuperNotAllowedInPrimitiveCtor {\n-\n-    SuperNotAllowedInPrimitiveCtor() {\n+value class SuperNotAllowedInValueClassCtor {\n+    SuperNotAllowedInValueClassCtor() {\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SuperNotAllowedInPrimitiveCtor.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-\/\/ options: -XDenablePrimitiveClasses\n@@ -28,1 +27,1 @@\n-primitive class TypeReqIdentity {\n+value class TypeReqIdentity {\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqIdentity.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.cannot.be.inner\n+\n+class ValueClassWithImplicitCannotBeInner {\n+    value class V {\n+        public implicit V();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCannotBeInner.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.declares.init.block\n+\n+value class ValueClassWithImplicitCantDeclareInitBlock {\n+    int i;\n+    {\n+        i = 0;\n+    }\n+    public implicit ValueClassWithImplicitCantDeclareInitBlock();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCantDeclareInitBlock.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.instance.field.initializer\n+\n+value class ValueClassWithImplicitCantHaveFieldInit {\n+    int i = 0;\n+    public implicit ValueClassWithImplicitCantHaveFieldInit ();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCantHaveFieldInit.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,688 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * NullabilityCompilationTests\n+ *\n+ * @test\n+ * @enablePreview\n+ * @summary compilation tests for bang types\n+ * @library \/lib\/combo \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ *      jdk.jdeps\/com.sun.tools.classfile\n+ * @run testng\/othervm NullabilityCompilationTests\n+ *\/\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.tools.Diagnostic;\n+\n+import org.testng.annotations.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class NullabilityCompilationTests extends CompilationTestCase {\n+    private static String[] EMPTY_OPTIONS = {};\n+    private static String[] LINT_OPTIONS = { \"-Xlint:null\" };\n+\n+    public NullabilityCompilationTests() {\n+        setDefaultFilename(\"Test.java\");\n+    }\n+\n+    enum TestResult {\n+        COMPILE_OK,\n+        COMPILE_WITH_WARNING,\n+        ERROR\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, null);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code, Consumer<Diagnostic<?>> diagConsumer) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, diagConsumer);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String diagsMessage, int diagsCount, TestResult testResult, String code,\n+                    Consumer<Diagnostic<?>> diagConsumer) {\n+        setCompileOptions(compilerOptions);\n+        try {\n+            if (testResult != TestResult.COMPILE_OK) {\n+                if (testResult == TestResult.COMPILE_WITH_WARNING) {\n+                    assertOKWithWarning(diagsMessage, diagsCount, code);\n+                } else {\n+                    assertFail(diagsMessage, code);\n+                }\n+            } else {\n+                if (diagConsumer == null) {\n+                    assertOK(code);\n+                } else {\n+                    assertOK(diagConsumer, code);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            System.err.println(\"error while compiling code:\\n\" + code);\n+            throw t;\n+        }\n+    }\n+\n+    void testList(List<DiagAndCode> testList) {\n+        for (DiagAndCode diagAndCode : testList) {\n+            if (diagAndCode.result == Result.Clean) {\n+                testHelper(LINT_OPTIONS, diagAndCode.code);\n+            } else if (diagAndCode.result == Result.Warning) {\n+                testHelper(LINT_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.COMPILE_WITH_WARNING, diagAndCode.code, null);\n+                testHelper(EMPTY_OPTIONS, diagAndCode.code,\n+                        d -> {\n+                            if (d.getKind() == Diagnostic.Kind.WARNING) {\n+                                \/\/ shouldn't issue any warnings if the -Xlint:null option is not passed\n+                                throw new AssertionError(\"unexpected warning for \" + diagAndCode.code);\n+                            }\n+                        });\n+            } else {\n+                testHelper(EMPTY_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.ERROR, diagAndCode.code, null);\n+            }\n+            if (diagAndCode.result != Result.Error) {\n+                testHelper(EMPTY_OPTIONS, diagAndCode.code);\n+            }\n+        }\n+    }\n+\n+    enum Result { Warning, Error, Clean}\n+\n+    record DiagAndCode(String code, Result result, String diag, int diagsCount) {\n+        DiagAndCode(String code, Result result, String diag) {\n+            this(code, result, diag, 1);\n+        }\n+    }\n+\n+    public void testErrorNonNullableCantBeAssignedNull() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[]! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        \/*new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T!> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),*\/\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class MyList<T> {\n+                                    void add(T e) {}\n+                                }\n+                                class Test {\n+                                    void m(MyList<? super Point!> ls) {\n+                                        ls.add(null);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\")\n+                )\n+        );\n+    }\n+\n+    public void testWarnUninitialized() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point![]![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[][]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[][][]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\")\n+                )\n+        );\n+    }\n+\n+    public void testUncheckedNullnessConversions () {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void m(Point! s1, Point s3) {\n+                                        s1 = s3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        \/*new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m(Object! s1, String s3) {\n+                                        s1 = s3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),*\/\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void m(Point! s1, Point s3) {\n+                                        s3 = s1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        \/*\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends String!> {\n+                                    Foo<String> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends Object!> {\n+                                    Foo<String> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        *\/\n+\n+                        \/\/ wildcards\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void test(List<? extends Point!> ls1, List<? extends Point> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends Object!> ls1, List<? extends String> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static value class Atom {}\n+                                    static class Box<X> {}\n+                                    void test(Box<? extends Atom!> t1, Box<Atom> t2) {\n+                                        t1 = t2;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Wrapper<T> {}\n+                                class Test<T> {\n+                                    Wrapper<T> newWrapper() { return null; }\n+                                    void m() {\n+                                        Wrapper<T!> w = newWrapper();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String, String> f) {}\n+                                    void m(Function<String!, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String!, String> f) {}\n+                                    void m(Function<String, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T!> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T!>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(Consumer<? super T!> action) {\n+                                        action.accept(field);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T!>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    class Box<X> {}\n+                                    static value class Point { public implicit Point(); }\n+                                    @SafeVarargs\n+                                    private <Z> Z make_box_uni(Z... bs) {\n+                                        return bs[0];\n+                                    }\n+                                    void test(Box<Point!> bref, Box<Point> bval) {\n+                                        Box<? extends Point!> res = make_box_uni(bref, bval);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends String> ls3) {\n+                                        ls3 = ls1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends Object> ls3) {\n+                                        ls3 = ls1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+    }\n+\n+    public void testNoWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape { public implicit Point(); }\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Point!> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? extends Shape> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape { public implicit Point(); }\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Shape> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? super Point!> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class C<T> {\n+                                    T x = null;\n+                                    void set(T arg) { x = arg; }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyList<T> {\n+                                    static <E> MyList<E> of(E e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class MyCollection<T> {}\n+                                class MyList<T> extends MyCollection<T!> {\n+                                    static <E> MyList<E> of(E e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyCollection<Point> mpc = MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(T t) {\n+                                        field = t;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        \/* we are testing that the compiler won't infer the arguments of\n+                                         * VarHandle::setVolatile as (Cell, String!)\n+                                         *\/\n+                                        VALUE.setVolatile(this, \"\");\n+                                    }\n+                                    final void reset(String identity) {\n+                                        \/* if that were the case, see comment above, then this invocation would generate\n+                                         * a warning, VarHandle::setVolatile is a polymorphic signature method\n+                                         *\/\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        VALUE.setVolatile(this, 0L);\n+                                    }\n+                                    final void reset(long identity) {\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Test {\n+                                    public implicit Test();\n+                                    void m(Test t1, Test[] t2, Test[][] t3, Test[][][] t4) {\n+                                        Test! l1 = (Test!) t1;\n+                                        Test![] l2 = (Test![]) t2;\n+                                        Test![][] l3 = (Test![][]) t3;\n+                                        Test![][][] l4 = (Test![][][]) t4;\n+\n+                                        Test[]! l5 = (Test[]!) t2;\n+                                        Test[][]! l6 = (Test[][]!) t3;\n+                                        Test[][][]! l7 = (Test[][][]!) t4;\n+\n+                                        Test[]![]! l8 = (Test[]![]!) t3;\n+                                        Test[]![]![]! l9 = (Test[]![]![]!) t4;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+    }\n+\n+    public void testOverridingWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                abstract class A {\n+                                    abstract String! lookup(String arg);\n+                                }\n+\n+                                abstract class B extends A {\n+                                    abstract String lookup(String arg);\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.overrides.with.different.nullness.1\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                abstract class A {\n+                                    abstract String lookup(Point! arg);\n+                                }\n+\n+                                abstract class B extends A {\n+                                    abstract String lookup(Point arg);\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.overrides.with.different.nullness.2\")\n+                )\n+        );\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityCompilationTests.java","additions":688,"deletions":0,"binary":false,"changes":688,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary Smoke test for parsing of bang types\n+ * @compile NullabilityParsingTest.java\n+ *\/\n+\n+import java.util.function.*;\n+import java.util.*;\n+\n+class NullabilityParsingTest {\n+    static value class Point { public implicit Point(); }\n+    static value class Shape { public implicit Shape(); }\n+    \/\/ fields\n+    Point! o2;\n+\n+    \/\/ method parameters\n+    void m2(Point! o) { }\n+\n+    \/\/ method returns\n+    Point! m2() { return new Point(); }\n+\n+    \/\/ locals\n+    void testLocals() {\n+        Point! o2;\n+    }\n+\n+    \/\/ generics - field\n+    Consumer<Point!> co2;\n+\n+    \/\/ generics - method param\n+    void m4(Consumer<Point!> co) { }\n+\n+    \/\/ generics - method return\n+    Consumer<Point!> m4() { return null; }\n+\n+    \/\/ generics - local\n+    void testGenericLocals() {\n+        Consumer<Point!> co2;\n+    }\n+\n+    \/\/ lambdas\n+    void testLambdas() {\n+        Consumer<Point!> co2 = (Point! co) -> {};\n+    }\n+\n+    void testGenericLambdas() {\n+        Consumer<Consumer<Point!>> co2 = (Consumer<Point!> co) -> {};\n+        Consumer<Function<Point!, Point!>> co3 = (Function<Point!, Point!> co) -> {};\n+        Consumer<Consumer<Consumer<Consumer<Point!>>>> co6 = (Consumer<Consumer<Consumer<Point!>>> co) -> {};\n+    }\n+\n+    \/\/ type test patterns\n+\n+    void testTypeTestPatterns(Object o) {\n+        switch (o) {\n+            case Point! i -> throw new AssertionError();\n+            case Shape! s -> throw new AssertionError();\n+            default -> throw new AssertionError();\n+        }\n+    }\n+\n+    sealed interface I<X> {}\n+    final class A implements I<Point> { }\n+\n+    void genericTypeTestPatterns(A o) {\n+        switch (o) {\n+            case I<Point!> i -> { }\n+        }\n+    }\n+\n+    sealed interface I2<X> {}\n+    final class A2 implements I2<I<Point>> { }\n+\n+    void genericTypeTestPatterns(A2 o) {\n+        switch (o) {\n+            case I2<I<Point!>> i -> { }\n+        }\n+    }\n+\n+    sealed interface I3<X> {}\n+    final class A3 implements I3<I2<I<Point>>> { }\n+\n+    void genericTypeTestPatterns(A3 o) {\n+        switch (o) {\n+            case I3<I2<I<Point!>>> i -> { }\n+        }\n+    }\n+\n+    \/\/ record patterns\n+\n+    record R(A a) { }\n+\n+    void genericRecordPatterns(R o) {\n+        switch (o) {\n+            case R!(I<Point!> i) -> { }\n+        }\n+    }\n+\n+    record R2(A2 a2) { }\n+\n+    void genericRecordPatterns(R2 o) {\n+        switch (o) {\n+            case R2!(I2<I<Point!>> i) -> { }\n+        }\n+    }\n+\n+    record R3(A3 a3) { }\n+\n+    void genericRecordPatterns(R3 o) {\n+        switch (o) {\n+            case R3!(I3<I2<I<Point!>>> i) -> { }\n+        }\n+    }\n+\n+    \/\/ instanceof\/cast\n+\n+    void testInstanceOf(Object o) {\n+        boolean r2 = o instanceof Point!;\n+    }\n+\n+    void testInstanceRecord(R r) {\n+        boolean r2 = r instanceof R(I<Point!> i);\n+    }\n+\n+    void testCast(Object o) {\n+        Point! s2 = (Point!)o;\n+    }\n+\n+    void testGenericCast(A a) {\n+        I<Point!> i2 = (I<Point!>)a;\n+    }\n+\/*\n+    void testGenericCast2(A a) {\n+        I<Point!> i2 = (I<Point!>)a;\n+    }\n+*\/\n+    \/\/ arrays\n+\n+    Point![]![]![]! oarr;\n+    Function<Point![]![]!, Function<Point![]![]!, Point![]![]!>>[][] garr;\n+\n+    void mBad1(Object o) {\n+        Point s1 = o instanceof Point ? (Point)o : null;\n+        Point s2 = o instanceof Point! ? (Point)o : null;\n+    }\n+\n+    void mBad2(Object o) {\n+        Point s1 = o instanceof Point ? null : null;\n+        Point s2 = o instanceof Point! ? null : null;\n+    }\n+\n+    void testPatternRule(Object o) {\n+        switch (o) {\n+            case Point! s -> { }\n+                default -> { }\n+        }\n+    }\n+\n+    void testPatternCol(Object o) {\n+        switch (o) {\n+            case Point! s: { }\n+            default: { }\n+        }\n+    }\n+\n+    void testInstanceOfAndInfix1(Object a, boolean b) {\n+        boolean x2 = a instanceof Point! && b;\n+    }\n+\n+    void testInstanceOfAndInfix2(Object a, boolean b) {\n+        boolean x2 = a instanceof Point! s && b;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingTest.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test runtime null checks\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RuntimeNullChecks\n+ *\/\n+\n+import java.util.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.IntStream;\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+\n+public class RuntimeNullChecks extends TestRunner {\n+    ToolBox tb;\n+\n+    RuntimeNullChecks() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        RuntimeNullChecks t = new RuntimeNullChecks();\n+        t.runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testRuntimeChecks(Path base) throws Exception {\n+        for (String code: new String[] {\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Point! o = s; \/\/ NPE at runtime, variable initialization\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Point! o;\n+                        o = s; \/\/ NPE at runtime, assignment, it doesn't stress the same code path as the case above\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Point![] sr = new Point![10];\n+                        sr[0] = s; \/\/ NPE at runtime, assignment\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    static Point id(Point! arg) { return arg; }\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Object o = id(s); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Object o = (Point!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            testHelper(base, code, true, NullPointerException.class);\n+        }\n+    }\n+\n+    private void testHelper(Path base, String testCode, boolean shouldFail, Class<?> expectedError) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path testSrc = src.resolve(\"Test\");\n+\n+        tb.writeJavaFiles(testSrc, testCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(src))\n+                .run();\n+\n+        if (shouldFail) {\n+            \/\/ let's check that we get the expected error\n+            String output = new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"Test\")\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.STDERR);\n+            if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError.getName())) {\n+                throw new AssertionError(expectedError.getName() + \" expected\");\n+            }\n+        } else {\n+            new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"Test\")\n+                    .run(Task.Expect.SUCCESS);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -119,1 +119,1 @@\n-                \"- compiler.note.proc.messager: visiting: NonSealedClass1 Modifiers: [non-sealed]\",\n+                \"- compiler.note.proc.messager: visiting: NonSealedClass1 Modifiers: [non-sealed, identity]\",\n@@ -121,1 +121,1 @@\n-                \"- compiler.note.proc.messager: visiting: SealedClass Modifiers: [sealed]\",\n+                \"- compiler.note.proc.messager: visiting: SealedClass Modifiers: [sealed, identity]\",\n@@ -125,1 +125,1 @@\n-                \"- compiler.note.proc.messager: visiting: FinalClass Modifiers: [final]\",\n+                \"- compiler.note.proc.messager: visiting: FinalClass Modifiers: [identity, final]\",\n@@ -127,1 +127,1 @@\n-                \"- compiler.note.proc.messager: visiting: NonSealedClass2 Modifiers: [non-sealed]\",\n+                \"- compiler.note.proc.messager: visiting: NonSealedClass2 Modifiers: [non-sealed, identity]\",\n@@ -129,1 +129,1 @@\n-                \"- compiler.note.proc.messager: visiting: ClassOutOfSealedHierarchy Modifiers: []\",\n+                \"- compiler.note.proc.messager: visiting: ClassOutOfSealedHierarchy Modifiers: [identity]\",\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestSealed.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308590\n+ * @summary Test basic modeling for value classes\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask JavacTestingAbstractProcessor\n+ * @run main TestValueClasses\n+ *\/\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.type.*;\n+import javax.lang.model.util.*;\n+import java.time.*;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Mode;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TestValueClasses extends TestRunner {\n+\n+    protected ToolBox tb;\n+\n+    TestValueClasses() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestValueClasses().runTests();\n+    }\n+\n+    \/**\n+     * Run all methods annotated with @Test, and throw an exception if any\n+     * errors are reported..\n+     *\n+     * @throws Exception if any errors occurred\n+     *\/\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    void checkOutputContains(String log, String... expect) throws Exception {\n+        for (String e : expect) {\n+            if (!log.contains(e)) {\n+                throw new Exception(\"expected output not found: \" + e);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void TestValueClassesProcessor(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path r = src.resolve(\"Test\");\n+\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(r,\n+                \"\"\"\n+                value interface ValueInterface {}\n+\n+                identity interface IdentityInterface {}\n+\n+                value class ValueClass {}\n+\n+                identity class IdentityClass {}\n+\n+                value class ValueClassWithImplicitConst {\n+                    public implicit ValueClassWithImplicitConst();\n+                }\n+                \"\"\"\n+        );\n+\n+        List<String> expected = List.of(\n+                \"- compiler.note.proc.messager: visiting: ValueInterface Modifiers: [abstract, value]\",\n+                \"- compiler.note.proc.messager: visiting: IdentityInterface Modifiers: [abstract, identity]\",\n+                \"- compiler.note.proc.messager: visiting: ValueClass Modifiers: [value, final]\",\n+                \"- compiler.note.proc.messager:     constructor modifiers: []\",\n+                \"- compiler.note.proc.messager: visiting: IdentityClass Modifiers: [identity]\",\n+                \"- compiler.note.proc.messager:     constructor modifiers: []\",\n+                \"- compiler.note.proc.messager: visiting: ValueClassWithImplicitConst Modifiers: [value, final]\",\n+                \"- compiler.note.proc.messager:     constructor modifiers: [public, implicit]\"\n+        );\n+\n+        for (Mode mode : new Mode[] {Mode.API}) {\n+            List<String> log = new JavacTask(tb, mode)\n+                    .options(\"-processor\", ValueClassesProcessor.class.getName(),\n+                            \"-XDrawDiagnostics\")\n+                    .files(findJavaFiles(src))\n+                    .outdir(classes)\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+            System.out.println(\"log:\" +log);\n+\n+            if (!expected.equals(log)) {\n+                if (expected.size() == log.size()) {\n+                    for (int i = 0; i < expected.size(); i++) {\n+                        if (!expected.get(i).equals(log.get(i))) {\n+                            System.err.println(\"failing at line \" + (i + 1));\n+                            System.err.println(\"    expecting \" + expected.get(i));\n+                            System.err.println(\"    found \" + log.get(i));\n+                        }\n+                    }\n+                } else {\n+                    System.err.println(\"expected and log lists differ in length\");\n+                }\n+                throw new AssertionError(\"Unexpected output: \" + log);\n+            }\n+        }\n+    }\n+\n+    public static final class ValueClassesProcessor extends JavacTestingAbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver()) {\n+                Messager messager = processingEnv.getMessager();\n+                ElementScanner scanner = new ValueClassesScanner(messager);\n+                for(Element rootElement : roundEnv.getRootElements()) {\n+                    scanner.visit(rootElement);\n+                }\n+            }\n+            return true;\n+        }\n+\n+        class ValueClassesScanner extends ElementScanner<Void, Void> {\n+\n+            Messager messager;\n+\n+            public ValueClassesScanner(Messager messager) {\n+                this.messager = messager;\n+            }\n+\n+            @Override\n+            public Void visitType(TypeElement element, Void p) {\n+                messager.printNote(\"visiting: \" + element.getSimpleName() + \" Modifiers: \" + element.getModifiers());\n+                List<? extends Element> enclosedElements = element.getEnclosedElements();\n+                for (Element elem : enclosedElements) {\n+                    System.out.println(\"visiting \" + elem.getSimpleName());\n+                    switch (elem.getSimpleName().toString()) {\n+                        case \"<vnew>\": case \"<init>\":\n+                            messager.printNote(\"    constructor modifiers: \" + elem.getModifiers());\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                }\n+                return super.visitType(element, p);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestValueClasses.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -129,64 +129,0 @@\n-\n-    @Test\n-    public void testPrimitiveRecordClassFileReading(Path base) throws Exception {\n-        Path src = base.resolve(\"src\");\n-\n-        tb.writeJavaFiles(src,\n-                           \"\"\"\n-                           public primitive record R(int i, @A long j, java.util.List<String> l) {}\n-                           \"\"\",\n-                           \"\"\"\n-                           public @interface A {}\n-                           \"\"\");\n-\n-        Path out = base.resolve(\"out\");\n-        Files.createDirectories(out);\n-\n-        new JavacTask(tb)\n-                .outdir(out)\n-                .options(\"-XDenablePrimitiveClasses\")\n-                .files(findJavaFiles(src))\n-                .run();\n-\n-        \/\/read the class file back, to verify javac's ClassReader\n-        \/\/reads the Record attribute properly:\n-        String output = new JavacTask(tb)\n-                .options(\"-Xprint\", \"-XDenablePrimitiveClasses\")\n-                .classpath(out.toString())\n-                .classes(\"R\")\n-                .run()\n-                .writeAll()\n-                .getOutput(Task.OutputKind.STDOUT)\n-                .replaceAll(\"\\\\R\", \"\\n\");\n-\n-        String expected =\n-                \"\"\"\n-                \\n\\\n-                public primitive value record R(int i, @A long j, java.util.List<java.lang.String> l) {\n-                  private final int i;\n-                  @A\n-                  private final long j;\n-                  private final java.util.List<java.lang.String> l;\n-                \\n\\\n-                  public final java.lang.String toString();\n-                \\n\\\n-                  public final int hashCode();\n-                \\n\\\n-                  public final boolean equals(java.lang.Object arg0);\n-                \\n\\\n-                  public int i();\n-                \\n\\\n-                  @A\n-                  public long j();\n-                \\n\\\n-                  public java.util.List<java.lang.String> l();\n-                \\n\\\n-                  public R(int i,\n-                    @A long j,\n-                    java.util.List<java.lang.String> l);\n-                }\n-                \"\"\";\n-        if (!Objects.equals(expected, output)) {\n-            throw new AssertionError(\"Unexpected output: \" + output);\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/records\/RecordReading.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile -XDenablePrimitiveClasses AnonymousValue.java\n+ * @compile -XDemitQDesc AnonymousValue.java\n@@ -35,2 +35,2 @@\n-\t static Function<String, String> capitalizer() {\n-        return new primitive Function<>() {\n+    static Function<String, String> capitalizer() {\n+        return new value Function<>() {\n@@ -38,4 +38,4 @@\n-\t\t\t@Override\n-\t\t\tpublic String apply(String t) {\n-\t\t\t\treturn t.toUpperCase();\n-\t\t\t}\n+            @Override\n+            public String apply(String t) {\n+                return t.toUpperCase();\n+            }\n@@ -43,3 +43,3 @@\n-\t }\n-     public static void main(String[] args) {\n-\t\t if (!capitalizer().apply(\"blah\").equals(\"BLAH\"))\n+    }\n+    public static void main(String[] args) {\n+        if (!capitalizer().apply(\"blah\").equals(\"BLAH\"))\n@@ -47,2 +47,2 @@\n-\t }\n-}\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValue.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile -XDenablePrimitiveClasses AnonymousValueType.java\n+ * @compile -XDemitQDesc AnonymousValueType.java\n@@ -35,1 +35,1 @@\n-        Object o = new primitive Comparable<String>() {\n+        Object o = new value Comparable<String>() {\n@@ -45,1 +45,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValueType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @compile -XDenablePrimitiveClasses ArrayCreationWithQuestion.java\n+ * @compile -XDemitQDesc ArrayCreationWithQuestion.java\n@@ -40,5 +40,14 @@\n-    static primitive class VT {\n-        VT.ref[] a1 = new VT.ref[42];\n-        VT.ref[] a2 = new VT.ref[42];\n-        VT[] a3 = new VT[42];\n-        VT[] a4 = new VT[42];\n+    static value class VT {\n+        VT[] a1;\n+        VT[] a2;\n+        VT![] a3;\n+        VT![] a4;\n+\n+        public implicit VT();\n+\n+        VT(boolean non_implicit) {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+            a3 = new VT![42];\n+            a4 = new VT![42];\n+        }\n@@ -83,1 +92,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayCreationWithQuestion.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses ArrayRelationsTest.java\n+ * @compile -XDemitQDesc ArrayRelationsTest.java\n@@ -34,1 +34,1 @@\n-public primitive class ArrayRelationsTest {\n+public value class ArrayRelationsTest {\n@@ -36,1 +36,3 @@\n-    int x = 42;\n+    int x;\n+\n+    public implicit ArrayRelationsTest();\n@@ -39,2 +41,2 @@\n-        ArrayRelationsTest.ref [] la = new ArrayRelationsTest.ref[10];\n-        ArrayRelationsTest [] qa = new ArrayRelationsTest[10];\n+        ArrayRelationsTest [] la = new ArrayRelationsTest[10];\n+        ArrayRelationsTest! [] qa = new ArrayRelationsTest![10];\n@@ -51,2 +53,2 @@\n-        ArrayRelationsTest.ref[] la2 = qa;\n-        ArrayRelationsTest [] qa2 = (ArrayRelationsTest []) la2;\n+        ArrayRelationsTest[] la2 = qa;\n+        ArrayRelationsTest! [] qa2 = (ArrayRelationsTest! []) la2;\n@@ -75,1 +77,1 @@\n-        qa = (ArrayRelationsTest[]) (la = (ArrayRelationsTest.ref []) (oa = (Object []) o));\n+        qa = (ArrayRelationsTest![]) (la = (ArrayRelationsTest []) (oa = (Object []) o));\n@@ -87,12 +89,0 @@\n-\n-        la = new ArrayRelationsTest.ref [10];\n-\n-        cce = false;\n-        try {\n-            qa = (ArrayRelationsTest[]) la;\n-        } catch (ClassCastException c) {\n-            cce = true;\n-        }\n-        if (!cce) {\n-            throw new AssertionError(\"Unexpected CCE behavior\");\n-        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayRelationsTest.java","additions":10,"deletions":20,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses AsSuperTests.java\n+ * @compile -XDemitQDesc AsSuperTests.java\n@@ -52,1 +52,1 @@\n-       String m(Foo f);\n+        String m(Foo! f);\n@@ -61,1 +61,3 @@\n-    static primitive class Foo<X> extends Base {}\n+    static value class Foo<X> extends Base {\n+        public implicit Foo();\n+    }\n@@ -64,1 +66,2 @@\n-primitive class X extends Base implements I {\n+value class X extends Base implements I {\n+    public implicit X();\n@@ -73,1 +76,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AsSuperTests.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses AssortedTests.java\n+ * @compile -XDemitQDesc AssortedTests.java\n@@ -33,2 +33,3 @@\n-primitive class MyValue1 {\n-    final int x = 0;\n+value class MyValue1 {\n+    final int x;\n+    public implicit MyValue1();\n@@ -38,1 +39,1 @@\n-    static final MyValue1 vField = new MyValue1();\n+    static final MyValue1! vField = new MyValue1();\n@@ -40,6 +41,3 @@\n-    primitive class MyValue2 {\n-        final MyValue1.ref vBoxField;\n-\n-        public MyValue2() {\n-            vBoxField = new MyValue1();\n-        }\n+    static value class MyValue2 {\n+        final MyValue1! vBoxField;\n+        public implicit MyValue2();\n@@ -51,2 +49,3 @@\n-primitive class MyValue3 {\n-    final int x = 0;\n+value class MyValue3 {\n+    final int x;\n+    public implicit MyValue3();\n@@ -58,2 +57,2 @@\n-    primitive class MyValue4 {\n-        final MyValue3.ref vBoxField = null;\n+    value class MyValue4 {\n+        final MyValue3 vBoxField = null;\n@@ -70,1 +69,1 @@\n-    public void test(MyValue5.ref vt);\n+    public void test(MyValue5 vt);\n@@ -73,2 +72,4 @@\n-primitive class MyValue5 implements MyInterface {\n-    final int x = 0;\n+value class MyValue5 implements MyInterface {\n+    final int x;\n+\n+    public implicit MyValue5();\n@@ -77,1 +78,1 @@\n-    public void test(MyValue5.ref vt) { }\n+    public void test(MyValue5 vt) { }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AssortedTests.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @compile -XDenablePrimitiveClasses AttributesTest.java\n+ * @compile -XDemitQDesc AttributesTest.java\n@@ -42,1 +42,3 @@\n-        primitive class V<T> {}\n+        static value class V<T> {\n+            public implicit V();\n+        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AttributesTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses AutoCloseableTest.java\n+ * @compile -XDemitQDesc AutoCloseableTest.java\n@@ -36,1 +36,1 @@\n-    primitive static class Foo implements AutoCloseable {\n+    value static class Foo implements AutoCloseable {\n@@ -38,1 +38,7 @@\n-        String s = \"Exception while closing AutoCloseable\";\n+        String s;\n+\n+        public implicit Foo();\n+\n+        public Foo(boolean dummy) {\n+            s = \"Exception while closing AutoCloseable\";\n+        }\n@@ -50,1 +56,1 @@\n-        try (Foo foo = new Foo()) {\n+        try (Foo! foo = new Foo(false)) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AutoCloseableTest.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @compile -XDenablePrimitiveClasses BogusIncompatibility.java\n- * @compile -XDenablePrimitiveClasses BogusIncompatibility.java\n+ * @compile -XDemitQDesc BogusIncompatibility.java\n+ * @compile -XDemitQDesc BogusIncompatibility.java\n@@ -33,2 +33,2 @@\n-  MyValue.ref field = MyValue.create();\n-  MyValue.ref field2 = MyValue.create();\n+  MyValue field = MyValue.create();\n+  MyValue field2 = MyValue.create();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BogusIncompatibility.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8214421 8221545 8222792\n- * @summary Q<->L mixing should be OK for upcasts and should use checkcasts for downcasts.\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile -XDenablePrimitiveClasses BoxValCastTest.java\n- * @run main\/othervm -Xverify:none -XX:+EnableValhalla -XX:+EnablePrimitiveClasses BoxValCastTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class BoxValCastTest {\n-\n-    static primitive class VT {\n-        int f = 0;\n-        static final VT.ref vtbox = (VT.ref) new VT(); \/\/ no binary cast\n-        static VT vt = (VT) vtbox; \/\/ binary cast\n-        static VT.ref box = vt; \/\/ no binary cast\n-        static VT.ref box2 = (VT) box; \/\/ binary cast\n-        static VT.ref box3 = id(new VT()); \/\/ no binary cast + no binary cast\n-\n-        static VT id(VT.ref vtb) {\n-            return (VT) vtb; \/\/ binary\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new BoxValCastTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"BoxValCastTest$VT.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-        \"checkcast     #7                  \/\/ class \\\"QBoxValCastTest$VT;\\\"\"\n-\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-         int errors = 0;\n-         for (String eo: expectedOut) {\n-             if (!out.contains(eo)) {\n-                 System.err.println(\"Match not found for string: \" + eo);\n-                 errors++;\n-             }\n-         }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-        String [] splits = out.split(\"checkcast     #7\", -1);\n-        if (splits.length != 4) {\n-             throw new AssertionError(\"Unexpected javap output: \" + splits.length);\n-        }\n-        splits = out.split(\"checkcast\", -1);\n-        if (splits.length != 9) {\n-             throw new AssertionError(\"Unexpected javap output: \" + splits.length);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BoxValCastTest.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile -XDenablePrimitiveClasses CanonicalCtorTest.java\n+ * @compile -XDemitQDesc CanonicalCtorTest.java\n@@ -32,1 +32,1 @@\n-public primitive class CanonicalCtorTest {\n+public value class CanonicalCtorTest {\n@@ -34,1 +34,1 @@\n-\tprivate final int x, ymx;\n+    private final int x, ymx;\n@@ -36,1 +36,1 @@\n-\tCanonicalCtorTest(int x, int y) {\n+    public implicit CanonicalCtorTest();\n@@ -38,2 +38,4 @@\n-\t\tymx = y - x;\n-\t\tthis.x = x;\n+    CanonicalCtorTest(int x, int y) {\n+\n+        ymx = y - x;\n+        this.x = x;\n@@ -43,3 +45,3 @@\n-\t\tvalidate();                 \/\/ OK: DU = {}\n-\t\tthis.validate();            \/\/ OK: DU = {}\n-\t\tCanonicalCtorTest.this.validate();          \/\/ OK: DU = {}\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        CanonicalCtorTest.this.validate();          \/\/ OK: DU = {}\n@@ -47,3 +49,3 @@\n-\t\tassert (this.x > 0);        \/\/ OK: DU = {}\n-\t\tassert (this.y() > 0);      \/\/ OK: DU = {}\n-\t}\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n@@ -51,3 +53,3 @@\n-\tint x() {\n-\t\treturn x;\n-\t}\n+    int x() {\n+        return x;\n+    }\n@@ -55,3 +57,3 @@\n-\tint y() {\n-\t\treturn ymx + x;\n-\t}\n+    int y() {\n+        return ymx + x;\n+    }\n@@ -59,3 +61,3 @@\n-\tvoid validate() {\n-\t\tassert (x() > 0 && y() > 0);\n-\t}\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n@@ -63,5 +65,5 @@\n-\tpublic static void main(String... av) {\n-\t\tCanonicalCtorTest z = new CanonicalCtorTest(1, 10);\n-\t\tassert (z.x() == 1);\n-\t\tassert (z.y() == 10);\n-\t}\n+    public static void main(String... av) {\n+        CanonicalCtorTest! z = new CanonicalCtorTest(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CanonicalCtorTest.java","additions":28,"deletions":26,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -38,2 +38,7 @@\n-    final primitive class XX {\n-        final int x = 10;\n+    static final value class XX {\n+        final int x;\n+\n+        public implicit XX();\n+        XX(boolean dummy) {\n+            x = 10;\n+        }\n@@ -47,1 +52,1 @@\n-            XX x = (XX) o;\n+            XX! x = (XX!) o;\n@@ -53,1 +58,1 @@\n-            Point p = (Point) o;\n+            Point! p = (Point!) o;\n@@ -60,1 +65,1 @@\n-            Point p = (Point) o;\n+            Point! p = (Point!) o;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNullCheckTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    static primitive class Point {\n+    static value class Point {\n@@ -37,1 +37,2 @@\n-        Point() {\n+        public implicit Point();\n+        Point(boolean foo) {\n@@ -42,1 +43,1 @@\n-    static primitive class LongPoint {\n+    static value class LongPoint {\n@@ -45,1 +46,2 @@\n-        LongPoint() {\n+        public implicit LongPoint();\n+        LongPoint(boolean foo) {\n@@ -50,1 +52,1 @@\n-        Point p = new Point();\n+        Point! p = new Point(false);\n@@ -54,1 +56,1 @@\n-        LongPoint lp = new LongPoint();\n+        LongPoint! lp = new LongPoint(false);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ChainedAssignmentTest.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -8,2 +8,2 @@\n-primitive final class Point {\n-\n+value final class Point {\n+    public implicit Point();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckBadSelector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-final primitive class CheckCyclicMembership {\n+final value class CheckCyclicMembership {\n@@ -11,2 +11,20 @@\n-    primitive final class InnerValue {\n-        final CheckCyclicMembership ccm = CheckCyclicMembership.default; \/\/ Error.\n+    static value final class InnerValue {\n+        final CheckCyclicMembership! ccm;\n+        public implicit InnerValue();\n+        InnerValue(boolean dummy) {\n+            ccm = CheckCyclicMembership.default;  \/\/ Error.\n+        }\n+    }\n+    final CheckCyclicMembership! ccm;\n+    final int i;\n+    final String s;\n+    final InnerRef ir;\n+    final InnerValue! iv;\n+\n+    public implicit CheckCyclicMembership();\n+    CheckCyclicMembership(boolean foo) {\n+        ccm = CheckCyclicMembership.default; \/\/ Error.\n+        i = 10;\n+        s = \"blah\";\n+        ir = new InnerRef(); \/\/ OK.\n+        iv = InnerValue.default; \/\/ Error\n@@ -14,5 +32,0 @@\n-    final CheckCyclicMembership ccm = CheckCyclicMembership.default; \/\/ Error.\n-    final int i = 10;\n-    final String s = \"blah\";\n-    final InnerRef ir = new InnerRef(); \/\/ OK.\n-    final InnerValue iv = InnerValue.default; \/\/ Error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckCyclicMembership.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,3 +1,3 @@\n-CheckCyclicMembership.java:12:37: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership.InnerValue\n-CheckCyclicMembership.java:14:33: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n-CheckCyclicMembership.java:18:22: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n+CheckCyclicMembership.java:12:38: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership.InnerValue\n+CheckCyclicMembership.java:18:34: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n+CheckCyclicMembership.java:22:23: compiler.err.cyclic.primitive.class.membership: CheckCyclicMembership\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckCyclicMembership.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-final primitive class CheckExtends extends Object {\n+final value class CheckExtends extends Object {\n@@ -10,1 +10,1 @@\n-    static primitive class NestedPrimitive extends NestedConcrete {}\n+    static value class NestedPrimitive extends NestedConcrete {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckExtends.java:10:22: compiler.err.concrete.supertype.for.value.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n+CheckExtends.java:10:18: compiler.err.concrete.supertype.for.value.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    static primitive class Val {\n+    static value class Val {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckFeatureGate1.java:10:12: compiler.err.primitive.classes.not.supported: 21\n+CheckFeatureGate1.java:10:12: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.value.classes), 13, 21\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckFeatureGate2.java:11:17: compiler.err.primitive.classes.not.supported: 21\n+CheckFeatureGate2.java:11:17: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.value.classes), 13, 21\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,3 +37,1 @@\n-public primitive class CheckFieldDescriptors {\n-\n-    int x = 10;\n+public value class CheckFieldDescriptors {\n@@ -41,0 +39,1 @@\n+    public implicit CheckFieldDescriptors();\n@@ -86,3 +85,3 @@\n-    CheckFieldDescriptors f1;\n-    CheckFieldDescriptors.ref f2;\n-    CheckFieldDescriptors.ref f3;\n+    CheckFieldDescriptors! f1;\n+    CheckFieldDescriptors f2;\n+    CheckFieldDescriptors f3;\n@@ -90,4 +89,4 @@\n-    CheckFieldDescriptors.ref[] a1 = new CheckFieldDescriptors.ref[42];\n-    CheckFieldDescriptors.ref[] a2 = new CheckFieldDescriptors.ref[42];\n-    CheckFieldDescriptors[] a3 = new CheckFieldDescriptors[42];\n-    CheckFieldDescriptors[] a4 = new CheckFieldDescriptors[42];\n+    CheckFieldDescriptors[] a1 = new CheckFieldDescriptors[42];\n+    CheckFieldDescriptors[] a2 = new CheckFieldDescriptors[42];\n+    CheckFieldDescriptors![] a3 = new CheckFieldDescriptors![42];\n+    CheckFieldDescriptors![] a4 = new CheckFieldDescriptors![42];\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFieldDescriptors.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-primitive class CheckFinal { \/\/ implicitly final\n+value class CheckFinal { \/\/ implicitly final\n@@ -11,0 +11,1 @@\n+    public implicit CheckFinal();\n@@ -19,1 +20,1 @@\n-        CheckFinal cf = new CheckFinal() {}; \/\/ Error, final class cannot be extended.\n+        CheckFinal! cf = new CheckFinal!() {}; \/\/ Error, final class cannot be extended.\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,6 +1,7 @@\n-CheckFinal.java:14:13: compiler.err.cant.assign.val.to.var: final, fi\n-CheckFinal.java:15:13: compiler.err.cant.assign.val.to.var: final, fe\n-CheckFinal.java:17:13: compiler.err.cant.assign.val.to.var: static final, xsf\n-CheckFinal.java:19:29: compiler.err.cant.inherit.from.final: CheckFinal\n-CheckFinal.java:19:42: compiler.err.identity.type.has.value.super.type: compiler.misc.anonymous.class: CheckFinal, CheckFinal\n-5 errors\n+CheckFinal.java:8:7: compiler.err.value.class.with.implicit.instance.field.initializer: CheckFinal\n+CheckFinal.java:15:13: compiler.err.cant.assign.val.to.var: final, fi\n+CheckFinal.java:16:13: compiler.err.cant.assign.val.to.var: final, fe\n+CheckFinal.java:18:13: compiler.err.cant.assign.val.to.var: static final, xsf\n+CheckFinal.java:20:30: compiler.err.cant.inherit.from.final: CheckFinal\n+CheckFinal.java:20:44: compiler.err.identity.type.has.value.super.type: compiler.misc.anonymous.class: CheckFinal, CheckFinal\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.out","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-final primitive class CheckFlattenableCycles {\n+final value class CheckFlattenableCycles {\n@@ -12,2 +12,3 @@\n-    primitive final class InnerValue {\n-        final CheckFlattenableCycles     cfc = CheckFlattenableCycles.default; \/\/ Error.\n+    static final value class InnerValue {\n+        final CheckFlattenableCycles! cfc; \/\/ Error.\n+        public implicit InnerValue();\n@@ -15,5 +16,4 @@\n-    final CheckFlattenableCycles cfc = CheckFlattenableCycles.default; \/\/ Error.\n-    final int i = 10;\n-    final String s = \"blah\";\n-    final InnerRef ir = new InnerRef(); \/\/ OK.\n-    final InnerValue     iv = InnerValue.default; \/\/ Error\n+    final CheckFlattenableCycles! cfc; \/\/ Error.\n+    final InnerValue! iv; \/\/ Error\n+\n+    public implicit CheckFlattenableCycles();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableCycles.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,3 +1,3 @@\n-CheckFlattenableCycles.java:13:42: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles.InnerValue\n-CheckFlattenableCycles.java:15:34: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n-CheckFlattenableCycles.java:19:26: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n+CheckFlattenableCycles.java:13:39: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles.InnerValue\n+CheckFlattenableCycles.java:16:35: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n+CheckFlattenableCycles.java:17:23: compiler.err.cyclic.primitive.class.membership: CheckFlattenableCycles\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableCycles.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-        f.va[0] = null; \/\/ Error.\n+        f.va = null; \/\/f.va[0] = null; \/\/ Error.  we currently can't represent that elements inside an array are non-nullable\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableFlagFromClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-CheckFlattenableFlagFromClass.java:12:19: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableFlagFromClass.V)\n+CheckFlattenableFlagFromClass.java:12:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, FlattenableFlagFromClass.V[])\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableFlagFromClass.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        primitive  class Inner {\n+        static value class Inner {\n@@ -41,0 +41,1 @@\n+            public implicit Inner();\n@@ -46,3 +47,4 @@\n-    public primitive class ValueOuter {\n-        int x = 10;\n-        primitive  class Inner {\n+    static public value class ValueOuter {\n+        int x; \/\/10\n+        public implicit ValueOuter();\n+        static value class Inner {\n@@ -50,0 +52,1 @@\n+            public implicit Inner();\n@@ -72,1 +75,0 @@\n-\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableSyntheticFields.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n-final primitive class CheckIdentityHash {\n-    int identityHashCode(CheckIdentityHash x) {\n+final value class CheckIdentityHash {\n+    public implicit CheckIdentityHash();\n+    int identityHashCode(CheckIdentityHash! x) {\n@@ -35,1 +36,1 @@\n-    void test(CheckIdentityHash v) {\n+    void test(CheckIdentityHash! v) {\n@@ -42,1 +43,1 @@\n-    int x = 10;\n+    int x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,3 +32,3 @@\n-public final primitive class CheckIdentityHash01 {\n-    void test(CheckIdentityHash01 v) {\n-\n+public final value class CheckIdentityHash01 {\n+    public implicit CheckIdentityHash01();\n+    void test(CheckIdentityHash01! v) {\n@@ -48,1 +48,0 @@\n-    int x = 10;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash01.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-            primitive  class Inner {\n+            value class Inner {\n@@ -50,2 +50,2 @@\n-    public primitive class ValueOuter {\n-        int x = 10;\n+    static public value class ValueOuter {\n+        public implicit ValueOuter();\n@@ -53,2 +53,2 @@\n-            ValueOuter o = new ValueOuter();\n-            primitive class Inner {\n+            ValueOuter! o = new ValueOuter();\n+            value class Inner {\n@@ -67,2 +67,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n-            throw new Exception(\"Value flag not set\");\n+        \/*if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n+            throw new Exception(\"Value flag not set\");*\/\n@@ -75,2 +75,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n-            throw new Exception(\"Value flag not set\");\n+        \/*if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n+            throw new Exception(\"Value flag not set\");*\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckLocalClasses.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -7,4 +7,3 @@\n-primitive final class Point {\n-\n-    primitive interface I { int x = 10; } \/\/ Error\n-    primitive abstract class A { int x = 10; } \/\/ Error\n+value final class Point {\n+    value interface I { int x = 10; } \/\/ Error\n+    value abstract class A { int x = 10; } \/\/ Error\n@@ -17,1 +16,2 @@\n-    primitive static final class SinnerValue {\n+    value static final class SinnerValue {\n+        public implicit SinnerValue();\n@@ -20,1 +20,1 @@\n-        } int x = 10;\n+        }\n@@ -26,10 +26,10 @@\n-    final int nonbool = boolean.default;\n-    final boolean nonbyte = byte.default;\n-    final boolean nonchar = char.default;\n-    final boolean nonint = int.default;\n-    final boolean nonshort = short.default;\n-    final boolean nonlong = long.default;\n-    final boolean nonfloat = float.default;\n-    final boolean nondouble = double.default;\n-    final int nonString = String.default;\n-    final int nonbyteArray = byte[].default;\n+    final int nonbool;\n+    final boolean nonbyte;\n+    final boolean nonchar;\n+    final boolean nonint;\n+    final boolean nonshort;\n+    final boolean nonlong;\n+    final boolean nonfloat;\n+    final boolean nondouble;\n+    final int nonString;\n+    final int nonbyteArray;\n@@ -37,2 +37,13 @@\n-    Point() {}\n-    Point (int x, int y) {}\n+    public implicit Point();\n+    Point (int x, int y) {\n+        final int nonbool = boolean.default;\n+        final boolean nonbyte = byte.default;\n+        final boolean nonchar = char.default;\n+        final boolean nonint = int.default;\n+        final boolean nonshort = short.default;\n+        final boolean nonlong = long.default;\n+        final boolean nonfloat = float.default;\n+        final boolean nondouble = double.default;\n+        final int nonString = String.default;\n+        final int nonbyteArray = byte[].default;\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMakeDefault.java","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,13 +1,12 @@\n-CheckMakeDefault.java:9:15: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-CheckMakeDefault.java:10:24: compiler.err.illegal.combination.of.modifiers: abstract, primitive\n-CheckMakeDefault.java:26:32: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: boolean, int)\n-CheckMakeDefault.java:27:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte, boolean)\n-CheckMakeDefault.java:28:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: char, boolean)\n-CheckMakeDefault.java:29:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, boolean)\n-CheckMakeDefault.java:30:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: short, boolean)\n-CheckMakeDefault.java:31:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, boolean)\n-CheckMakeDefault.java:32:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, boolean)\n-CheckMakeDefault.java:33:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, boolean)\n-CheckMakeDefault.java:34:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-CheckMakeDefault.java:35:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte[], int)\n-12 errors\n+CheckMakeDefault.java:9:20: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.abstract.value.class: Point.A)\n+CheckMakeDefault.java:39:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: boolean, int)\n+CheckMakeDefault.java:40:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte, boolean)\n+CheckMakeDefault.java:41:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: char, boolean)\n+CheckMakeDefault.java:42:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, boolean)\n+CheckMakeDefault.java:43:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: short, boolean)\n+CheckMakeDefault.java:44:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, boolean)\n+CheckMakeDefault.java:45:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, boolean)\n+CheckMakeDefault.java:46:41: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, boolean)\n+CheckMakeDefault.java:47:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n+CheckMakeDefault.java:48:40: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte[], int)\n+11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMakeDefault.out","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -8,2 +8,2 @@\n-    primitive final class V {\n-        final int x = 10;\n+    static value final class V {\n+        public implicit V();\n@@ -11,2 +11,3 @@\n-            V [][][] va = new V[][][] {{{ null }}};\n-            V [][] va2 =  {{ null }};\n+            V! []![]![]! va = new V![][][] {{{ null }}};\n+            V! []![]![]! vb = new V[][][] {{{ null }}};  \/\/ OK?\n+            V! []![]! va2 =  {{ null }};\n@@ -14,1 +15,1 @@\n-                va = new V[][][] {{{ null }}};\n+                va = new V![][][] {{{ null }}};\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMultiDimensionalArrayStore.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-CheckMultiDimensionalArrayStore.java:11:43: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:12:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:14:38: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:15:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n+CheckMultiDimensionalArrayStore.java:11:48: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n+CheckMultiDimensionalArrayStore.java:13:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n+CheckMultiDimensionalArrayStore.java:15:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n+CheckMultiDimensionalArrayStore.java:16:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMultiDimensionalArrayStore.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -8,2 +8,2 @@\n-final primitive class CheckNullAssign {\n-    CheckNullAssign foo(CheckNullAssign cna) {\n+final value class CheckNullAssign {\n+    CheckNullAssign! foo(CheckNullAssign! cna) {\n@@ -13,1 +13,1 @@\n-        if (null instanceof CheckNullAssign) {}\n+        if (null instanceof CheckNullAssign!) {}\n@@ -16,1 +16,1 @@\n-    int x = 10;\n+    public implicit CheckNullAssign();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullAssign.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -8,3 +8,3 @@\n-primitive final class CheckNullCastable {\n-    void foo(CheckNullCastable cnc) {\n-        CheckNullCastable cncl = (CheckNullCastable) null;\n+value final class CheckNullCastable {\n+    void foo(CheckNullCastable! cnc) {\n+        CheckNullCastable! cncl = (CheckNullCastable!) null;\n@@ -14,1 +14,1 @@\n-    int x = 10;\n+    public implicit CheckNullCastable();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullCastable.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckNullCastable.java:10:54: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullCastable)\n+CheckNullCastable.java:10:56: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckNullCastable)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullCastable.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-primitive class CheckNullWithQuestion {\n-    final int x = 0;\n+value class CheckNullWithQuestion {\n+    public implicit CheckNullWithQuestion();\n@@ -36,1 +36,1 @@\n-        CheckNullWithQuestion.ref vBox = null;\n+        CheckNullWithQuestion vBox = null;\n@@ -38,1 +38,1 @@\n-        CheckNullWithQuestion.ref val = flag ? vBox : null;\n+        CheckNullWithQuestion val = flag ? vBox : null;\n@@ -44,1 +44,1 @@\n-        CheckNullWithQuestion.ref vBox = null;\n+        CheckNullWithQuestion vBox = null;\n@@ -46,1 +46,1 @@\n-        CheckNullWithQuestion.ref val = flag ? vBox : null;\n+        CheckNullWithQuestion val = flag ? vBox : null;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullWithQuestion.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -11,3 +11,6 @@\n-primitive class X {\n-    List<X.ref> ls = new Object();\n-    X.ref[] xa = new Object[10];  \/\/ no support for Object.ref yet, but they are the same.\n+value class X {\n+    void m() {\n+        List<X> ls = new Object();\n+        X[] xa = new Object[10];  \/\/ no support for Object.ref yet, but they are the same.\n+    }\n+    public implicit X();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckQuestionInMessages.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-CheckQuestionInMessages.java:12:22: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, java.util.List<X.ref>)\n-CheckQuestionInMessages.java:13:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], X.ref[])\n+CheckQuestionInMessages.java:13:22: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, java.util.List<X>)\n+CheckQuestionInMessages.java:14:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], X[])\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckQuestionInMessages.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-        if (new CheckSeparateCompile0().new O().new M().new I().foo().i != 890)\n+        if (new CheckSeparateCompile0.O.M.I(false).foo().i != 890)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSeparateCompile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,4 +34,5 @@\n-            public primitive class I {\n-                int i = 890;\n-                I() {\n-\n+            static public value class I {\n+                int i;\n+                public implicit I();\n+                public I(boolean dummy) {\n+                    this.i = 890;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSeparateCompile0.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-primitive final class CheckStaticFinalAssign {\n+value final class CheckStaticFinalAssign {\n@@ -18,1 +18,1 @@\n-    int ix = 10;\n+    public implicit CheckStaticFinalAssign();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckStaticFinalAssign.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-primitive final class CheckSynchronized implements java.io.Serializable {\n+value final class CheckSynchronized implements java.io.Serializable {\n@@ -18,1 +18,1 @@\n-        CheckSynchronized.ref csr = cs;\n+        CheckSynchronized csr = cs;\n@@ -38,1 +38,1 @@\n-    primitive record CheckSynchronizedRecord(int x, int y) {\n+    value record CheckSynchronizedRecord(int x, int y) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSynchronized.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized.ref, (compiler.misc.type.req.identity)\n+CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized, (compiler.misc.type.req.identity)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSynchronized.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-primitive class V {\n+value class V {\n@@ -10,1 +10,1 @@\n-\tprivate final int x, ymx;\n+    private final int x, ymx;\n@@ -12,1 +12,1 @@\n-\tV(int x, int y) {\n+    V(int x, int y) {\n@@ -14,2 +14,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -17,3 +17,3 @@\n-\t\tvalidate();                 \/\/ BAD to call instance method DU = {x, ymx}\n-\t\tthis.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n-\t\tV.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n+        validate();                 \/\/ BAD to call instance method DU = {x, ymx}\n+        this.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n+        V.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n@@ -21,2 +21,2 @@\n-\t\tSystem.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n-\t\tSystem.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n+        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n+        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n@@ -24,2 +24,2 @@\n-\t\tV v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n-\t\tv = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n+        V v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n+        v = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n@@ -27,2 +27,2 @@\n-\t\tymx = y - x;                \/\/ OK, implicit this for field write.\n-\t\tint l = this.ymx;           \/\/ OK, explicit this for DA field read.\n+        ymx = y - x;                \/\/ OK, implicit this for field write.\n+        int l = this.ymx;           \/\/ OK, explicit this for DA field read.\n@@ -30,2 +30,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -33,3 +33,3 @@\n-\t\tvalidate();                 \/\/ BAD to call instance method DU = {x}\n-\t\tthis.validate();            \/\/ BAD to call instance method DU = {x}\n-\t\tV.this.validate();          \/\/ BAD to call instance method DU = {x}\n+        validate();                 \/\/ BAD to call instance method DU = {x}\n+        this.validate();            \/\/ BAD to call instance method DU = {x}\n+        V.this.validate();          \/\/ BAD to call instance method DU = {x}\n@@ -37,2 +37,2 @@\n-\t\tSystem.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n-\t\tSystem.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n+        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n+        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n@@ -40,2 +40,2 @@\n-\t\tv = this;                   \/\/ BAD to create alias  DU = {x}\n-\t\tv = V.this;                 \/\/ BAD to create alias  DU = {x}\n+        v = this;                   \/\/ BAD to create alias  DU = {x}\n+        v = V.this;                 \/\/ BAD to create alias  DU = {x}\n@@ -43,1 +43,1 @@\n-\t\tthis.x = x;\n+        this.x = x;\n@@ -47,2 +47,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -50,3 +50,3 @@\n-\t\tvalidate();                 \/\/ OK: DU = {}\n-\t\tthis.validate();            \/\/ OK: DU = {}\n-\t\tV.this.validate();          \/\/ OK: DU = {}\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        V.this.validate();          \/\/ OK: DU = {}\n@@ -54,2 +54,2 @@\n-\t\tSystem.out.println(this);   \/\/ OK: DU = {}\n-\t\tSystem.out.println(V.this); \/\/ OK: DU = {}\n+        System.out.println(this);   \/\/ OK: DU = {}\n+        System.out.println(V.this); \/\/ OK: DU = {}\n@@ -57,5 +57,5 @@\n-\t\tv = this;                   \/\/ OK: DU = {}\n-\t\tv = V.this;                 \/\/ OK: DU = {}\n-\t\tassert (this.x > 0);        \/\/ OK: DU = {}\n-\t\tassert (this.y() > 0);      \/\/ OK: DU = {}\n-\t}\n+        v = this;                   \/\/ OK: DU = {}\n+        v = V.this;                 \/\/ OK: DU = {}\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n@@ -63,1 +63,1 @@\n-\tV() { \/\/ non-initial constructor. All, statements below are OK.\n+    V() { \/\/ non-initial constructor. All, statements below are OK.\n@@ -65,2 +65,2 @@\n-\t\tOK();                       \n-\t\tthis.OK();                  \n+        OK();\n+        this.OK();\n@@ -68,3 +68,3 @@\n-\t\tvalidate();                 \n-\t\tthis.validate();            \n-\t\tV.this.validate();          \n+        validate();\n+        this.validate();\n+        V.this.validate();\n@@ -72,2 +72,2 @@\n-\t\tSystem.out.println(this);   \n-\t\tSystem.out.println(V.this); \n+        System.out.println(this);\n+        System.out.println(V.this);\n@@ -75,2 +75,2 @@\n-\t\tV v = this;                 \n-\t\tv = V.this;                 \n+        V v = this;\n+        v = V.this;\n@@ -78,1 +78,1 @@\n-\t\tint l = this.ymx;           \n+        int l = this.ymx;\n@@ -80,3 +80,3 @@\n-\t\tassert (this.x > 0);        \n-\t\tassert (this.y() > 0);      \n-\t}\n+        assert (this.x > 0);\n+        assert (this.y() > 0);\n+    }\n@@ -84,2 +84,2 @@\n-\tstatic void OK() {\n-\t}\n+    static void OK() {\n+    }\n@@ -87,3 +87,3 @@\n-\tint x() {\n-\t\treturn x;\n-\t}\n+    int x() {\n+        return x;\n+    }\n@@ -91,3 +91,3 @@\n-\tint y() {\n-\t\treturn ymx + x;\n-\t}\n+    int y() {\n+        return ymx + x;\n+    }\n@@ -95,3 +95,3 @@\n-\tvoid validate() {\n-\t\tassert (x() > 0 && y() > 0);\n-\t}\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n@@ -99,5 +99,5 @@\n-\tpublic static void main(String... av) {\n-\t\tV z = new V(1, 10);\n-\t\tassert (z.x() == 1);\n-\t\tassert (z.y() == 10);\n-\t}\n+    public static void main(String... av) {\n+        V z = new V(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.java","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -1,14 +1,14 @@\n-CheckThisLeak.java:17:25: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:18:17: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:19:18: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:21:36: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:22:37: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:24:23: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:25:22: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:33:25: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:34:17: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:35:18: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:37:36: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:38:37: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:40:21: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:41:22: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:17:17: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:18:9: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:19:10: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:21:28: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:22:29: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:24:15: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:25:14: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:33:17: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:34:9: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:35:10: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:37:28: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:38:29: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:40:13: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:41:14: compiler.err.this.exposed.prematurely\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.out","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -15,2 +15,2 @@\n-   primitive int x;\n-   primitive int foo() {\n+   value int x;\n+   value int foo() {\n@@ -18,4 +18,4 @@\n-   primitive interface IFace {}\n-   primitive @interface Annot {}\n-   primitive enum Enum {}\n-   primitive abstract class Inner {}\n+   value interface IFace {}\n+   value @interface Annot {}\n+   value enum Enum {}\n+   value abstract class Inner {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckValueModifier.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,7 +1,6 @@\n-CheckValueModifier.java:18:14: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-CheckValueModifier.java:19:15: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-CheckValueModifier.java:20:14: compiler.err.mod.not.allowed.here: primitive\n-CheckValueModifier.java:21:23: compiler.err.illegal.combination.of.modifiers: abstract, primitive\n-CheckValueModifier.java:15:18: compiler.err.mod.not.allowed.here: primitive\n-CheckValueModifier.java:16:18: compiler.err.mod.not.allowed.here: primitive\n-6 errors\n+CheckValueModifier.java:19:11: compiler.err.illegal.combination.of.modifiers: value, annotation\n+CheckValueModifier.java:20:10: compiler.err.mod.not.allowed.here: value\n+CheckValueModifier.java:15:14: compiler.err.mod.not.allowed.here: value\n+CheckValueModifier.java:16:14: compiler.err.mod.not.allowed.here: value\n+CheckValueModifier.java:21:19: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.abstract.value.class: CheckValueModifier.Inner)\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckValueModifier.out","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=ClassLiteralNegativeTest.out -XDrawDiagnostics -XDenablePrimitiveClasses ClassLiteralNegativeTest.java\n+ * @compile -XDenablePrimitiveClasses ClassLiteralNegativeTest.java\n@@ -8,4 +8,4 @@\n-final primitive class ClassLiteralNegativeTest {\n-    Class<ClassLiteralNegativeTest> c1 = null; \/\/ error\n-    Class<? extends ClassLiteralNegativeTest> c2 = null; \/\/ error\n-    Class<? super ClassLiteralNegativeTest> c3 = null; \/\/ error\n+final value class ClassLiteralNegativeTest {\n+    Class<ClassLiteralNegativeTest> c1 = null; \/\/ OK\n+    Class<? extends ClassLiteralNegativeTest> c2 = null; \/\/ OK\n+    Class<? super ClassLiteralNegativeTest> c3 = null; \/\/ OK\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralNegativeTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,4 +0,0 @@\n-ClassLiteralNegativeTest.java:9:11: compiler.err.type.found.req: ClassLiteralNegativeTest, (compiler.misc.type.req.ref)\n-ClassLiteralNegativeTest.java:10:11: compiler.err.type.found.req: ClassLiteralNegativeTest, (compiler.misc.type.req.ref)\n-ClassLiteralNegativeTest.java:11:11: compiler.err.type.found.req: ClassLiteralNegativeTest, (compiler.misc.type.req.ref)\n-3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralNegativeTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -47,2 +47,2 @@\n-    static primitive class V implements I {\n-        int x = 42;\n+    static value class V implements I {\n+        public implicit V();\n@@ -52,2 +52,2 @@\n-        if (size(V.class) != 0 || size(new V().getClass()) != 0 ||\n-             foo(V.class) != 1 ||  foo(new V().getClass()) != 1)\n+        if (size(V.class) != 0 || size(new V!().getClass()) != 0 ||\n+             foo(V.class) != 1 ||  foo(new V!().getClass()) != 1)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralTypingTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    static primitive class Point {\n+    static value class Point {\n@@ -40,0 +40,1 @@\n+        public implicit Point();\n@@ -47,1 +48,1 @@\n-    static void testCastingFromBoxToVal(Point.ref p) {\n+    static void testCastingFromBoxToVal(Point p) {\n@@ -50,1 +51,1 @@\n-            Point pv = (Point) p;\n+            Point! pv = (Point!) p;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilerNoBogusAssert.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    static Point.ref nfspQm;\n+    static Point nfspQm;\n@@ -41,1 +41,1 @@\n-primitive final class Point {\n+value final class Point {\n@@ -45,4 +45,1 @@\n-    Point() {\n-        x = 0;\n-        y = 0;\n-    }\n+    public implicit Point();\n@@ -53,2 +50,4 @@\n-    static final primitive class Value {\n-        final PointBug2.ref nfpQm;\n+    static final value class Value {\n+        final PointBug2 nfpQm;\n+\n+        public implicit Value();\n@@ -56,1 +55,1 @@\n-        private Value() {\n+        private Value(boolean dummy){\n@@ -61,1 +60,1 @@\n-primitive final class PointBug2 {\n+value final class PointBug2 {\n@@ -65,0 +64,2 @@\n+    public implicit PointBug2();\n+\n@@ -70,1 +71,1 @@\n-    public static PointBug2 createPoint(int x, int y) {\n+    public static PointBug2! createPoint(int x, int y) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilesJustFine.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -36,1 +36,3 @@\n-    static primitive class V {}\n+    static value class V {\n+        public implicit V();\n+    }\n@@ -43,1 +45,1 @@\n-        var r2 = args.length == 0 ? (V.ref) new V() : (V.ref) new V();\n+        var r2 = args.length == 0 ? (V) new V!() : (V) new V!();\n@@ -48,1 +50,1 @@\n-            var r3 = args.length != 0 ? new V() : (V.ref) null;\n+            var r3 = args.length != 0 ? new V!() : (V) null;\n@@ -54,1 +56,1 @@\n-            var r4 = args.length == 0 ? (V.ref) null : new V();\n+            var r4 = args.length == 0 ? (V) null : new V!();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConditionalInlineTypeTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    static final primitive class X {\n+    static final value class X {\n@@ -41,1 +41,5 @@\n-        final int ifif = 9999;\n+        final int ifif;\n+        public implicit X();\n+        X(boolean dummy) {\n+            ifif = 9999;\n+        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConstantPropagationTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n- * @summary Enhance javac to consume unified primitive class files\n+ * @summary Enhance javac to consume unified primitive class files, also see that we lose nullability information with separate compilation\n+ * @compile\/fail\/ref=ConsumeUnifiedClass.out -XDrawDiagnostics -XDenablePrimitiveClasses Point.java Rectangle.java ConsumeUnifiedClass.java\n@@ -31,1 +32,1 @@\n- * @compile\/fail\/ref=ConsumeUnifiedClass.out -XDrawDiagnostics -XDenablePrimitiveClasses ConsumeUnifiedClass.java\n+ * @compile\/fail\/ref=ConsumeUnifiedClass2.out -XDrawDiagnostics -XDenablePrimitiveClasses ConsumeUnifiedClass.java\n@@ -34,1 +35,2 @@\n-public primitive class ConsumeUnifiedClass {\n+public value class ConsumeUnifiedClass {\n+    public implicit ConsumeUnifiedClass();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-ConsumeUnifiedClass.java:36:23: compiler.err.cant.apply.symbol: kindname.constructor, Rectangle, Point,Point, compiler.misc.type.null,compiler.misc.type.null, kindname.class, Rectangle, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point))\n-ConsumeUnifiedClass.java:38:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)\n+ConsumeUnifiedClass.java:38:23: compiler.err.cant.apply.symbols: kindname.constructor, Rectangle, compiler.misc.type.null,compiler.misc.type.null,{(compiler.misc.inapplicable.method: kindname.constructor, Rectangle, Rectangle(), (compiler.misc.arg.length.mismatch)),(compiler.misc.inapplicable.method: kindname.constructor, Rectangle, Rectangle(Point,Point), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)))}\n+ConsumeUnifiedClass.java:40:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+ConsumeUnifiedClass.java:40:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class CtorChain {\n+public value class CtorChain {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CtorChain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,4 @@\n-    static primitive class Val {\n-        public int v = 42;\n+    static value class Val {\n+        public int v;\n+        public implicit Val();\n+        Val(int v) { this.v = v; }\n@@ -48,1 +50,1 @@\n-        while ((new Val()).v != 42)\n+        while ((new Val(42)).v != 42)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultNonInlines.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8268671\n- * @summary Wrong code generated for PrimitiveClass.ref.default\n- * @compile -XDenablePrimitiveClasses DefaultOfPrimitiveReference.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses DefaultOfPrimitiveReference\n- *\/\n-\n-public primitive class DefaultOfPrimitiveReference {\n-    public static void main(String [] args) {\n-        Object o = DefaultOfPrimitiveReference.ref.default;\n-        if (o != null)\n-            throw new AssertionError(\"Expected NPE is missing\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultOfPrimitiveReference.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8210122\n- * @summary [lworld] javac issues bogus \"no comment\" doclint warning while compiling primitive class\n- * @compile -Xdoclint:all -Werror -XDenablePrimitiveClasses DocLintSyntheticsTest.java\n- *\/\n-\n-\/**\n- * NOTE: This test is not relevant as we don't inject synthetic methods into primitive\n- *       classes anymore, but is still left in just the same.\n- *\/\n-public primitive class DocLintSyntheticsTest {\n-  \/** field *\/\n-  private final int value;\n-  \/**\n-   * Constructor\n-   *\/\n-  public DocLintSyntheticsTest() { this.value = 0; }\n- \n-  \/**\n-   * test method\n-   *\/\n-  public static void test() {\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DocLintSyntheticsTest.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -8,1 +8,1 @@\n-public primitive class DualNonDuplicateErrors {\n+public value class DualNonDuplicateErrors {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DualNonDuplicateErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public final primitive class EmptyValueTest {\n+public final value class EmptyValueTest {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EmptyValueTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    static primitive class PrimitiveIterator<V> implements Iterator<V> {\n+    static value class PrimitiveIterator<V> implements Iterator<V> {\n@@ -68,1 +68,1 @@\n-    primitive static class Foo<V> implements Iterable<V> {\n+    value static class Foo<V> implements Iterable<V> {\n@@ -80,1 +80,1 @@\n-       public PrimitiveIterator<V> iterator() {\n+        public PrimitiveIterator<V> iterator() {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EnhancedForLoopTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-primitive class OptionalInt {\n+value class OptionalInt {\n@@ -80,1 +80,1 @@\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n+       List<OptionalInt> opts = new ArrayList<>();\n@@ -88,1 +88,1 @@\n-           .map((OptionalInt.ref o) -> {\n+           .map((OptionalInt o) -> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-primitive class OptionalInt {\n-    \/\/ private static final OptionalInt EMPTY = OptionalInt.default;\n+value class OptionalInt {\n@@ -44,0 +43,2 @@\n+    public implicit OptionalInt();\n+\n@@ -81,1 +82,1 @@\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n+       List<OptionalInt> opts = new ArrayList<>();\n@@ -88,2 +89,2 @@\n-       Stream<OptionalInt.ref> soi = opts.stream();\n-       ToIntFunction<OptionalInt.ref> f = (OptionalInt.ref o) -> {\n+       Stream<OptionalInt> soi = opts.stream();\n+       ToIntFunction<OptionalInt> f = (OptionalInt o) -> {\n@@ -91,1 +92,1 @@\n-            OptionalInt op = (OptionalInt)o;\n+            OptionalInt! op = (OptionalInt!)o;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes2.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,3 +38,1 @@\n-primitive class OptionalInt {\n-    \/\/ private static final OptionalInt EMPTY = OptionalInt.default;\n-\n+value class OptionalInt {\n@@ -81,1 +79,1 @@\n-       List<OptionalInt.ref> opts = new ArrayList<>();\n+       List<OptionalInt> opts = new ArrayList<>();\n@@ -88,2 +86,2 @@\n-       Stream<OptionalInt.ref> soi = opts.stream();\n-       ToIntFunction<OptionalInt.ref> f = o -> {\n+       Stream<OptionalInt> soi = opts.stream();\n+       ToIntFunction<OptionalInt> f = o -> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes3.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,3 @@\n-    public primitive final class V {\n-        final int x = 10;\n+    static public value final class V {\n+        final int x;\n+        public implicit V();\n@@ -30,2 +31,2 @@\n-    public V v;\n-    public V[] va;\n+    public V! v;\n+    public V[]! va;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/FlattenableFlagFromClass.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-   static primitive class Entry<E> {\n+   static value class Entry<E> {\n@@ -36,1 +36,1 @@\n-\n+     public implicit Entry();\n@@ -41,2 +41,2 @@\n-     public static <E> Entry<E>[] of() {\n-       return (Entry<E>[])new Entry<?>[0];\n+     public static <E> Entry!<E>[] of() {\n+       return (Entry!<E>[])new Entry!<?>[0];\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericArrayRegression.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- primitive class Foo implements Comparable<Foo.ref>{\n+value class Foo implements Comparable<Foo>{\n@@ -35,1 +35,1 @@\n-  \n+\n@@ -41,1 +41,1 @@\n-    public int compareTo(Foo.ref o) {\n+    public int compareTo(Foo o) {\n@@ -44,1 +44,1 @@\n- }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues1.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  primitive class CaptureBug {\n+value class CaptureBug {\n@@ -37,1 +37,1 @@\n-  \n+\n@@ -41,2 +41,2 @@\n-  \n-    private static void accept(Consumer<? super CaptureBug.ref> consumer) {\n+\n+    private static void accept(Consumer<? super CaptureBug> consumer) {\n@@ -45,1 +45,1 @@\n-  \n+\n@@ -49,2 +49,1 @@\n-  }\n-\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues2.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-primitive class StreamBug {\n+value class StreamBug {\n@@ -37,1 +37,1 @@\n-  \n+\n@@ -41,1 +41,1 @@\n-  \n+\n@@ -43,2 +43,0 @@\n-    \/\/var bug = new StreamBug?(7);\n-    \n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues3.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-primitive class InlineType<E> {\n+value class InlineType<E> {\n@@ -37,1 +37,1 @@\n-        void doesNotCompile(java.util.Map.Entry<InlineType.ref<? extends K>, ? extends V> arg);\n+        void doesNotCompile(java.util.Map.Entry<InlineType<? extends K>, ? extends V> arg);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues4.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-primitive class Optional<T> {\n+value class Optional<T> {\n@@ -90,1 +90,1 @@\n-       List<Optional.ref<Integer>> opts = new ArrayList<>();\n+       List<Optional<Integer>> opts = new ArrayList<>();\n@@ -93,1 +93,1 @@\n-           opts.add((Optional.ref<Integer>)oi);\n+           opts.add((Optional<Integer>)oi);\n@@ -95,1 +95,1 @@\n-           opts.add((Optional.ref<Integer>)oe);\n+           opts.add((Optional<Integer>)oe);\n@@ -99,1 +99,1 @@\n-           .map((Optional.ref<Integer> o) -> {\n+           .map((Optional<Integer> o) -> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues5.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    static primitive class Primitive {}\n+    static value class Primitive {}\n@@ -38,1 +38,1 @@\n-    static void foo(Class<? extends Primitive.ref> c) {}\n+    static void foo(Class<? extends Primitive> c) {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GetClassTypingTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * @test\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ImplicitIdentityTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- *\n@@ -39,3 +38,2 @@\n-public primitive class InferredValueParameterizationTest {\n-    int x = 10;\n-\n+public value class InferredValueParameterizationTest {\n+    public implicit InferredValueParameterizationTest();\n@@ -51,4 +49,4 @@\n-       var list = List.of(new InferredValueParameterizationTest());\n-       Object o = new Y<>(new InferredValueParameterizationTest());\n-       o = new Y<>(new InferredValueParameterizationTest()) {};\n-       foo(new InferredValueParameterizationTest());\n+       var list = List.of(new InferredValueParameterizationTest!());\n+       Object o = new Y<>(new InferredValueParameterizationTest!());\n+       o = new Y<>(new InferredValueParameterizationTest!()) {};\n+       foo(new InferredValueParameterizationTest!());\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InferredValueParameterizationTest.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222745\n- * @summary Test inline modifier\n- * @compile -XDenablePrimitiveClasses InlineClassTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses InlineClassTest\n- *\/\n-\n-public primitive class InlineClassTest {\n-    int x = 42;\n-    public static void main(String [] args) {\n-        if (new InlineClassTest().x != 42)\n-            throw new AssertionError(\"Unexpected state\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineClassTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-\n@@ -43,2 +42,3 @@\n-    private primitive class Y<U> implements I<U> {\n-        int x = 42;\n+    private static value class Y<U> implements I<U> {\n+        int x;\n+        public implicit Y();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineDiamondTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    static primitive class Inner {\n+    static value class Inner {\n@@ -39,1 +39,1 @@\n-        private Inner() { f=0; }\n+        public implicit Inner();\n@@ -47,2 +47,2 @@\n-        public static final Inner.ref ZERO = Inner.create(0);\n-        public static final Inner.ref ZERO2 = Inner.create(0);\n+        public static final Inner ZERO = Inner.create(0);\n+        public static final Inner ZERO2 = Inner.create(0);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerClassAttributeValuenessTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    final primitive class Y {\n+    final value class Y {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerValueNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public primitive class InstanceofProjectionArray {\n+public value class InstanceofProjectionArray {\n@@ -40,2 +40,2 @@\n-        InstanceofProjectionArray.ref[] foos = new InstanceofProjectionArray.ref[1];\n-        if (!(foos instanceof InstanceofProjectionArray.ref[])) {\n+        InstanceofProjectionArray[] foos = new InstanceofProjectionArray[1];\n+        if (!(foos instanceof InstanceofProjectionArray[])) {\n@@ -44,2 +44,2 @@\n-        InstanceofProjectionArray.ref[][] xx = null;\n-        if (xx instanceof InstanceofProjectionArray.ref[][]) {}\n+        InstanceofProjectionArray[][] xx = null;\n+        if (xx instanceof InstanceofProjectionArray[][]) {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InstanceofProjectionArray.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class IntercastTest {\n+public value class IntercastTest {\n@@ -36,1 +36,1 @@\n-    static primitive class Tuple {\n+    static value class Tuple {\n@@ -46,1 +46,1 @@\n-    static primitive class Cursor {\n+    static value class Cursor {\n@@ -59,1 +59,1 @@\n-        Cursor.ref next() {\n+        Cursor next() {\n@@ -67,1 +67,1 @@\n-    private static Cursor.ref indexedElements(int[] array) {\n+    private static Cursor indexedElements(int[] array) {\n@@ -76,1 +76,1 @@\n-        for (Cursor.ref cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n+        for (Cursor cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n@@ -88,1 +88,1 @@\n-        IntercastTest.ref xbox = (IntercastTest.ref) x;\n+        IntercastTest xbox = (IntercastTest) x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class IntercastTest2 {\n+public value class IntercastTest2 {\n@@ -36,1 +36,1 @@\n-    static primitive class Tuple {\n+    static value class Tuple {\n@@ -46,1 +46,1 @@\n-    static primitive class Cursor {\n+    static value class Cursor {\n@@ -59,1 +59,1 @@\n-        Cursor.ref next() {\n+        Cursor next() {\n@@ -67,1 +67,1 @@\n-    private static Cursor.ref indexedElements(int[] array) {\n+    private static Cursor indexedElements(int[] array) {\n@@ -76,1 +76,1 @@\n-        for (Cursor.ref cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n+        for (Cursor cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n@@ -88,1 +88,1 @@\n-        IntercastTest2.ref xbox = (IntercastTest2.ref) x;\n+        IntercastTest2 xbox = (IntercastTest2) x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest2.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        final primitive class Y {\n+        final value class Y {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LocalValueNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class LookupOnLoxTest {\n+public value class LookupOnLoxTest {\n@@ -36,1 +36,1 @@\n-    static primitive class Tuple {\n+    static value class Tuple {\n@@ -46,1 +46,1 @@\n-    static primitive class Cursor {\n+    static value class Cursor {\n@@ -59,1 +59,1 @@\n-        Cursor.ref next() {\n+        Cursor next() {\n@@ -67,1 +67,1 @@\n-    private static Cursor.ref indexedElements(int[] array) {\n+    private static Cursor indexedElements(int[] array) {\n@@ -76,1 +76,1 @@\n-        for (Cursor.ref cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n+        for (Cursor cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n@@ -88,1 +88,1 @@\n-        LookupOnLoxTest.ref xbox = x;\n+        LookupOnLoxTest xbox = x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class LookupOnLoxTest2 {\n+public value class LookupOnLoxTest2 {\n@@ -36,1 +36,1 @@\n-    static primitive class Tuple {\n+    static value class Tuple {\n@@ -46,1 +46,1 @@\n-    static primitive class Cursor {\n+    static value class Cursor {\n@@ -59,1 +59,1 @@\n-        Cursor.ref next() {\n+        Cursor next() {\n@@ -67,1 +67,1 @@\n-    private static Cursor.ref indexedElements(int[] array) {\n+    private static Cursor indexedElements(int[] array) {\n@@ -76,1 +76,1 @@\n-        for (Cursor.ref cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n+        for (Cursor cursor = indexedElements(ARRAY); cursor != null; cursor = cursor.next()) {\n@@ -88,1 +88,1 @@\n-        LookupOnLoxTest2.ref xbox = x;\n+        LookupOnLoxTest2 xbox = x;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest2.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    static primitive class XNodeWrapper implements I {\n+    static value class XNodeWrapper implements I {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LubWithInlines.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,2 +24,3 @@\n-primitive public final class MyValue {\n-  final int f = 0;\n+value public final class MyValue {\n+  final int f;\n+  public implicit MyValue();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/MyValue.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,1 +39,3 @@\n-    static primitive final class V implements I { int x = 0; }\n+    static value final class V implements I {\n+        public implicit V();\n+    }\n@@ -41,1 +43,1 @@\n-    static void triggerNPE(V.ref [] vra) {\n+    static void triggerNPE(V [] vra) {\n@@ -45,1 +47,2 @@\n-    static String foo(V[] va) {\n+    \/*\n+    static String foo(V![] va) {\n@@ -52,0 +55,1 @@\n+    *\/\n@@ -60,1 +64,1 @@\n-        triggerNPE(new V.ref[1]); \/\/ NO NPE.\n+        triggerNPE(new V[1]); \/\/ NO NPE.\n@@ -62,1 +66,1 @@\n-            triggerNPE(new V[1]);\n+            triggerNPE(new V![1]);\n@@ -67,3 +71,3 @@\n-\n-        V [] v = new V[0];\n-        if (!foo((V.ref []) v).equals(\"array of nullable o's\"))\n+\/*\n+        V! [] v = new V![0];  \/\/nullability is not considered during overload resolution\n+        if (!foo((V []) v).equals(\"array of nullable o's\"))\n@@ -71,0 +75,1 @@\n+ *\/\n@@ -72,1 +77,1 @@\n-        ArrayList<V.ref> vList = new ArrayList<V.ref>(Arrays.asList(new V.ref[10]));\n+        ArrayList<V> vList = new ArrayList<V>(Arrays.asList(new V[10]));\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoCrashTest.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -52,2 +52,3 @@\n-    static primitive class Point {\n-        int x = 0, y = 0;\n+    static value class Point {\n+        int x, y;\n+        public implicit Point();\n@@ -55,1 +56,1 @@\n-            Point p0 = new Point();\n+            Point! p0 = new Point();\n@@ -58,1 +59,1 @@\n-            Point.ref p1 = null;\n+            Point p1 = null;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoUnnecessaryCast.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    static primitive class X {\n+    static value class X {\n@@ -41,1 +41,1 @@\n-        static int m(X.ref xr, A a) {\n+        static int m(X xr, A a) {\n@@ -45,1 +45,1 @@\n-        static int m(X.ref xr, B b) {\n+        static int m(X xr, B b) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest2.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class ParameterizedDefault<E> {\n+public value class ParameterizedDefault<E> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ParameterizedDefault.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n-primitive class Point {\n-    static final Point.ref origin = makePoint(10, 20);\n-    static final Point.ref origin2 = makePoint(10, 20);\n+value class Point {\n+    static final Point origin = makePoint(10, 20);\n+    static final Point origin2 = makePoint(10, 20);\n@@ -38,0 +38,3 @@\n+\n+    public implicit Point();\n+\n@@ -42,1 +45,1 @@\n-    static Point makePoint(int x, int y) {\n+    static Point! makePoint(int x, int y) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Point.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,8 +38,8 @@\n-    public primitive class P1 {}\n-    public primitive class P2 {}\n-    public primitive class P3 {}\n-    public primitive class P4 {}\n-    public primitive class P5 {}\n-    public primitive class P6 {}\n-    public primitive class P7 {}\n-    public primitive class P8 {}\n+    public static value class P1 { public implicit P1(); }\n+    public static value class P2 { public implicit P2(); }\n+    public static value class P3 { public implicit P3(); }\n+    public static value class P4 { public implicit P4(); }\n+    public static value class P5 { public implicit P5(); }\n+    public static value class P6 { public implicit P6(); }\n+    public static value class P7 { public implicit P7(); }\n+    public static value class P8 { public implicit P8(); }\n@@ -48,4 +48,4 @@\n-    P1 p1;\n-    P2 foo(P3 p3) {\n-        P4 p4;\n-        return new P2();\n+    P1! p1;\n+    P2! foo(P3! p3) {\n+        P4! p4;\n+        return new P2!();\n@@ -55,3 +55,3 @@\n-    P5.ref p5;\n-    P6.ref foo(P7.ref p7) {\n-        P8.ref p8;\n+    P5 p5;\n+    P6 foo(P7 p7) {\n+        P8 p8;\n@@ -73,1 +73,1 @@\n-        if (preloads.number_of_classes != 4) {\n+        if (preloads.number_of_classes != 8) {\n@@ -76,1 +76,1 @@\n-\n+        \/*\n@@ -97,0 +97,1 @@\n+        *\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PreloadAttributeTest.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                primitive class PC extends GoodSuper implements GoodSuperInterface {}\n+                value class PC extends GoodSuper implements GoodSuperInterface {}\n@@ -92,1 +92,1 @@\n-                primitive class PC extends Integer {}\n+                value class PC extends Integer {}\n@@ -97,1 +97,1 @@\n-                primitive class PC extends Number {\n+                value class PC extends Number {\n@@ -110,1 +110,1 @@\n-                primitive class PC extends SuperWithStaticField {}\n+                value class PC extends SuperWithStaticField {}\n@@ -128,1 +128,1 @@\n-                primitive class PC extends SuperWithEmptyNoArgCtor_02 {}\n+                value class PC extends SuperWithEmptyNoArgCtor_02 {}\n@@ -134,1 +134,1 @@\n-                primitive class PC extends BadSuper {}\n+                value class PC extends BadSuper {}\n@@ -143,1 +143,1 @@\n-                primitive class PC extends SuperWithInstanceField_01 {}\n+                value class PC extends SuperWithInstanceField_01 {}\n@@ -154,1 +154,1 @@\n-                primitive class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n+                value class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n@@ -165,1 +165,1 @@\n-                primitive class PC extends SuperWithArgedCtor_01 {}\n+                value class PC extends SuperWithArgedCtor_01 {}\n@@ -180,1 +180,1 @@\n-                primitive class PC extends SuperWithInstanceInit_01 {}\n+                value class PC extends SuperWithInstanceInit_01 {}\n@@ -189,1 +189,1 @@\n-                primitive class PC extends SuperWithSynchronizedMethod_1 {}\n+                value class PC extends SuperWithSynchronizedMethod_1 {}\n@@ -197,1 +197,1 @@\n-                primitive class PC extends Outer.InnerSuper {}\n+                value class PC extends Outer.InnerSuper {}\n@@ -204,1 +204,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -212,1 +212,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -226,1 +226,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -240,1 +240,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -242,1 +242,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -251,1 +251,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -253,1 +253,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -262,1 +262,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -264,1 +264,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -273,1 +273,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -281,1 +281,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -289,1 +289,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -297,1 +297,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -305,1 +305,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -313,1 +313,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -327,1 +327,0 @@\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\", \"primitive interface I {}\");\n@@ -331,1 +330,1 @@\n-                    primitive public void m() {}\n+                    value public void m() {}\n@@ -338,1 +337,1 @@\n-                        int[] ia = new primitive int[10];\n+                        int[] ia = new value int[10];\n@@ -346,1 +345,1 @@\n-                        new primitive String(\"Hello\");\n+                        new value String(\"Hello\");\n@@ -357,1 +356,1 @@\n-                        new primitive I() {};\n+                        new value I() {};\n@@ -364,1 +363,1 @@\n-    public void testPrimitivesAsTypeParams() {\n+    public void testValueClassesAsTypeParams() {\n@@ -368,1 +367,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -374,1 +373,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -380,1 +379,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -388,1 +387,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -395,2 +394,2 @@\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n+                import java.io.Serializable;\n+                value class ValueOverGenericsTest {\n@@ -404,1 +403,1 @@\n-            assertFail(\"compiler.err.type.found.req\", source);\n+            assertOK(source);\n@@ -414,1 +413,1 @@\n-                        primitive class Value {}\n+                        value class Value {}\n@@ -424,2 +423,2 @@\n-                        primitive class Value {}\n-                        new primitive Value() {};\n+                        value class Value {}\n+                        new value Value() {};\n@@ -457,1 +456,1 @@\n-                    primitive class UncheckedDefault<E> {\n+                    value class UncheckedDefault<E> {\n@@ -468,74 +467,0 @@\n-    public void testRefProjection() {\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC x) {\n-                        PC.ref xq = null;\n-                        xq = x;\n-                        xq = (PC.ref) x;\n-                        xq = (PC) x;\n-                        x = xq;\n-                        x = (PC.ref) xq;\n-                        x = (PC) xq;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC[] xa = new PC[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref [] xqa = new PC.ref[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa) {\n-                        PC.ref[] xqa = xa;\n-                        xqa = (PC.ref[]) xa;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = xqa;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = (PC[]) xqa;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n@@ -545,1 +470,1 @@\n-                primitive class PC {\n+                value class PC {\n@@ -553,49 +478,0 @@\n-    public void testProjectionInstantiation() {\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.ref();\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.val();\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.ref::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.val::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-    }\n-\n@@ -603,1 +479,1 @@\n-        assertFail(\"compiler.err.ref.ambiguous\",\n+        assertOK(\n@@ -606,2 +482,2 @@\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n+                    static value class V {}\n+                    static String roo(V v, int i) {\n@@ -610,1 +486,1 @@\n-                    static String roo(V.ref v, Integer i) {\n+                    static String roo(V v, Integer i) {\n@@ -618,1 +494,1 @@\n-        assertFail(\"compiler.err.ref.ambiguous\",\n+        assertOK(\n@@ -621,2 +497,2 @@\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n+                    static value class V {}\n+                    static String roo(V v, int i) {\n@@ -625,1 +501,1 @@\n-                    static String roo(V.ref v, Integer i) {\n+                    static String roo(V v, Integer i) {\n@@ -638,1 +514,1 @@\n-                primitive class Bar {\n+                value class Bar {\n@@ -647,1 +523,1 @@\n-                primitive class DualPathInnerType  {\n+                value class DualPathInnerType  {\n@@ -651,1 +527,1 @@\n-                    DualPathInnerType.ref.Inner xri = xi;\n+                    DualPathInnerType.Inner xri = xi;\n@@ -654,1 +530,1 @@\n-                    void f (DualPathInnerType.ref.Inner xri) {}\n+                    void f (DualPathInnerType.Inner xri) {}\n@@ -667,1 +543,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -678,1 +554,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -689,1 +565,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -700,1 +576,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -711,1 +587,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -722,1 +598,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -733,1 +609,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -753,1 +629,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -765,1 +641,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -777,1 +653,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -789,1 +665,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -801,1 +677,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -813,1 +689,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -825,1 +701,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -837,1 +713,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -850,1 +726,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -863,2 +739,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<String, Integer> r1) {\n@@ -875,2 +751,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -887,2 +763,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<String, Integer> r1) {\n@@ -900,2 +776,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -913,2 +789,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -922,58 +798,0 @@\n-    public void testValRefTokensNegative() {\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    ValRefTokensNegativeTest.ref aa = null;\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    static ValRefTokensNegativeTest.val bb = ValRefTokensNegativeTest.default;\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    EmptyValue empty = EmptyValue.default;\n-\n-                    static class ValRefTokensTestWrapper {\n-                        ValRefTokensNegativeTest val = ValRefTokensNegativeTest.default;\n-                        ValRefTokensNegativeTest ref = ValRefTokensNegativeTest.default;\n-                    }\n-\n-                    public EmptyValue test(int x) {\n-                        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n-                        return x == 0 ? w.val.empty : w.ref.empty;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int valx() {\n-                        return EmptyValue.val.x;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int refx() {\n-                        return EmptyValue.ref.x;\n-                    }\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n@@ -985,1 +803,1 @@\n-            assertFail(\"compiler.err.primitive.classes.not.supported\",\n+            assertFail(\"compiler.err.feature.not.supported.in.source.plural\",\n@@ -987,4 +805,4 @@\n-                    class primitive {\n-                        primitive x;\n-                        primitive foo(int l) {}\n-                        Object o = new primitive primitive() {};\n+                    class value {\n+                        value x;\n+                        value foo(int l) {}\n+                        Object o = new value value() {};\n@@ -996,1 +814,1 @@\n-                    class primitive {}\n+                    class value {}\n@@ -1010,1 +828,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1026,1 +844,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1044,1 +862,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1063,1 +881,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1082,1 +900,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1100,1 +918,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1112,1 +930,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1124,1 +942,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1138,1 +956,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1153,1 +971,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1173,1 +991,1 @@\n-                    primitive static class Foo extends S implements I<Integer> {\n+                    value static class Foo extends S implements I<Integer> {\n@@ -1179,90 +997,0 @@\n-\n-    public void testClassLiteralTypingNegativeTest() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\", \"-XDenablePrimitiveClasses\"};\n-            setCompileOptions(testOptions);\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = PrimitiveClass.asValueType(Foo.class);\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = new Foo().getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.ref.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.val.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.val xv = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xv.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.ref xr = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xr.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":99,"deletions":371,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectedArrayDotClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProperTypeApplySelectTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,3 +24,5 @@\n-primitive class QPoint {\n-    int x = 0;\n-    int y = 0;\n+value class QPoint {\n+    int x;\n+    int y;\n+\n+    public implicit QPoint();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QPoint.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n@@ -34,0 +35,2 @@\n+\/* This test is very fragile should be replaced \/ removed\n+ *\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypeTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-primitive class QTypedValue {\n+value class QTypedValue {\n@@ -26,2 +26,2 @@\n-    QTypedValue [] f1 = new QTypedValue[10];\n-    QTypedValue [] f2 = new QTypedValue[10];\n+    QTypedValue! []! f1;\n+    QTypedValue! []! f2;\n@@ -29,2 +29,2 @@\n-    QTypedValue [][][] f3 = new QTypedValue[10][10][];\n-    QTypedValue [][][] f4 = new QTypedValue[10][10][];\n+    QTypedValue! [][][]! f3;\n+    QTypedValue! [][][]! f4;\n@@ -32,1 +32,9 @@\n-    void foo(QTypedValue x, int i) {\n+    public QTypedValue(boolean dummy) {\n+        f1 = new QTypedValue![10];\n+        f2 = new QTypedValue![10];\n+\n+        f3 = new QTypedValue![10][10][];\n+        f4 = new QTypedValue![10][10][];\n+    }\n+\n+    void foo(QTypedValue! x, int i) {\n@@ -34,1 +42,1 @@\n-        QTypedValue x1, x2, x4, x5, x6;\n+        QTypedValue! x1, x2, x4, x5, x6;\n@@ -40,1 +48,1 @@\n-            QTypedValue x9 = new QTypedValue();\n+            QTypedValue! x9 = new QTypedValue();\n@@ -43,0 +51,2 @@\n+\n+    public implicit QTypedValue();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypedValue.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,3 +32,7 @@\n-primitive class A {\n-    int x = 1000000;\n-    class Inner { \n+value class A {\n+    int x;\n+    public implicit A();\n+    A(boolean dummy) {\n+        x = 1000000;\n+    }\n+    class Inner {\n@@ -52,1 +56,1 @@\n-        if (new QualifiedSuperCtor(new A()).getADotThis().x !=1000000)\n+        if (new QualifiedSuperCtor(new A(false)).getADotThis().x !=1000000)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedSuperCtor.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class QualifiedThisTest {\n+public value class QualifiedThisTest {\n@@ -39,0 +39,2 @@\n+    public implicit QualifiedThisTest();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedThisTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-public primitive class Range<T> {\n+public value class Range<T> {\n@@ -30,0 +30,2 @@\n+    public implicit Range();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Range.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-public primitive class Rectangle {\n+public value class Rectangle {\n@@ -28,1 +28,1 @@\n-    Point topLeft, bottomRight;\n+    Point! topLeft, bottomRight;\n@@ -30,1 +30,1 @@\n-    static Point origin;\n+    static Point! origin;\n@@ -32,1 +32,1 @@\n-    static Rectangle from (Point.ref topLeft, Point.ref bottomRight) {\n+    static Rectangle! from (Point topLeft, Point bottomRight) {\n@@ -36,1 +36,2 @@\n-    Rectangle (Point topLeft, Point bottomRight) {\n+    public implicit Rectangle();\n+    Rectangle (Point! topLeft, Point! bottomRight) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Rectangle.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public primitive class RefDotClass {\n+public value class RefDotClass {\n@@ -37,0 +37,2 @@\n+    public implicit RefDotClass();\n+\n@@ -46,2 +48,6 @@\n-        foo(RefDotClass.ref.class);\n-        String tName = RefDotClass.ref.class.getTypeName();\n+        foo(RefDotClass.class);\n+        String tName = RefDotClass.class.getTypeName();\n+        \/* this is printing .ref due to code in java.lang.Class, there are several references to primitive classes\n+         * that should be removed. Also class: jdk.internal.value.PrimitiveClass\n+         *\/\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/RefDotClass.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        Pointer<Point.ref> p_ref = Point.TYPE.allocate();\n+        Pointer<Point> p_ref = Point.TYPE.allocate();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-primitive class Point {\n+value class Point {\n@@ -47,0 +47,2 @@\n+    public implicit Point();\n+\n@@ -52,1 +54,1 @@\n-    public static ForeignType<Point.ref> TYPE = new ForeignType<>() { };\n+    public static ForeignType<Point> TYPE = new ForeignType<>() { };\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest01.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\n@@ -35,1 +34,1 @@\n-    static primitive class V {\n+    static value class V {\n@@ -41,1 +40,3 @@\n-        V() {\n+        public implicit V();\n+\n+        V(boolean dummy) {\n@@ -46,1 +47,1 @@\n-            int l = 1234; \n+            int l = 1234;\n@@ -56,1 +57,1 @@\n-        V v = new V();\n+        V v = new V(false);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-public primitive class SignatureTest<T> implements java.io.Serializable {\n+public value class SignatureTest<T> implements java.io.Serializable {\n+    public implicit SignatureTest();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SignatureTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-public primitive class SmallSet {\n+public value class SmallSet {\n@@ -30,0 +30,2 @@\n+  public implicit SmallSet();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SmallSet.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8247567\n- * @summary Javac chokes on static member selection via the reference projection.\n- * @compile -XDenablePrimitiveClasses StaticSelectedThroughProjection.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses StaticSelectedThroughProjection\n- *\/\n-\n-public class StaticSelectedThroughProjection {\n-    static primitive class MyValue {\n-        int x = 42;\n-        static String test() {\n-            return \"OK\";\n-        };\n-    }\n-    public static void main(String[] args) {\n-        if (!MyValue.ref.test().equals(\"OK\"))\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StaticSelectedThroughProjection.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -36,1 +36,1 @@\n-    public static primitive class X {\n+    public static value class X {\n@@ -61,1 +61,1 @@\n-                        .map(X.ref::data)\n+                        .map(X::data)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StreamsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    static primitive class Prime {\n+    static value class Prime {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperHashCodeEqualsToStringTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    primitive class Bar implements Foo { }\n+    value class Bar implements Foo { }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/T8279655.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-primitive final class TestValue1 {\n+value final class TestValue1 {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestQualifierOnInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8269956\n- * @summary  javac should generate `ldc LPoint;` for class literal Point.class\n- * @modules java.base\/jdk.internal.value\n- * @compile -XDenablePrimitiveClasses TestReflectiveMirrors.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses TestReflectiveMirrors\n- *\/\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-public class TestReflectiveMirrors {\n-\n-    static primitive class ValDefault {}\n-\n-    public static void main(String [] args) {\n-\n-        if (ValDefault.class != new ValDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (ValDefault.ref.class != new ValDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (ValDefault.val.class != PrimitiveClass.asValueType(new ValDefault().getClass())) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (TestReflectiveMirrors.ValDefault.class != new ValDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (TestReflectiveMirrors.ValDefault.ref.class != new ValDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (TestReflectiveMirrors.ValDefault.val.class != PrimitiveClass.asValueType(new ValDefault().getClass())) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestReflectiveMirrors.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-public primitive class ThisIsNotAnInstanceField {\n+public value class ThisIsNotAnInstanceField {\n@@ -38,1 +38,1 @@\n-    Inner.ref i2 = new Inner();\n+    Inner i2 = new Inner();\n@@ -40,1 +40,1 @@\n-    primitive class Inner {\n+    value class Inner {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ThisIsNotAnInstanceField.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222792\n- * @summary Javac should enforce the latest relationship rules between an inline type and its nullable projection\n- * @compile -XDenablePrimitiveClasses TypeRelationsTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses TypeRelationsTest\n- *\/\n-\n-public primitive class TypeRelationsTest {\n-\n-    int x = 42;\n-\n-    static boolean foo(TypeRelationsTest x, TypeRelationsTest.ref xq, boolean nullPassed) {\n-        TypeRelationsTest xl;\n-        TypeRelationsTest.ref xql;\n-        boolean npe = false;\n-\n-        xl = x;\n-        xl = (TypeRelationsTest) x;\n-        try {\n-            xl = (TypeRelationsTest) xq;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-\n-        xql = x;\n-        xql = (TypeRelationsTest.ref ) x;\n-        xql = xq;\n-        xql = (TypeRelationsTest.ref) xq;\n-        return npe;\n-    }\n-\n-    static String foo(Object o) {\n-        return \"Object\";\n-    }\n-\n-    static String foo(TypeRelationsTest x) {\n-        return \"TypeRelationsTest\";\n-    }\n-\n-    static String foo(TypeRelationsTest.ref xq) {\n-        return \"TypeRelationsTest.ref\";\n-    }\n-\n-    public static void main(String [] args) {\n-       if (foo(new TypeRelationsTest(), new TypeRelationsTest(), false))\n-            throw new AssertionError(\"Unexpected NPE\");\n-       if (!foo(new TypeRelationsTest(), null, true))\n-            throw new AssertionError(\"Missing NPE\");\n-\n-       TypeRelationsTest x = new TypeRelationsTest();\n-       TypeRelationsTest.ref xq = null;\n-       if (!foo(x).equals(\"TypeRelationsTest\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       if (!foo(xq).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       if (!foo((TypeRelationsTest.ref) x).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-\n-       boolean npe = false;\n-       try  {\n-           foo((TypeRelationsTest) xq);\n-       } catch (NullPointerException e) {\n-            npe = true;\n-       }\n-       if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-       }\n-       xq = x;\n-       if (!foo((TypeRelationsTest.ref) xq).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       checkArrays();\n-    }\n-\n-    static void checkArrays() {\n-        TypeRelationsTest [] xa = new TypeRelationsTest[10];\n-        TypeRelationsTest.ref [] xqa;\n-        Object [] oa;\n-        Object o;\n-\n-        o = oa = xqa = xa;\n-        xa = (TypeRelationsTest []) (xqa = (TypeRelationsTest.ref[]) (oa = (Object []) o));\n-        xa[0] = new TypeRelationsTest(); \/\/ OK, after round trip back and forth.\n-\n-\n-        xqa = (TypeRelationsTest.ref[]) xa;\n-        boolean npe = false;\n-        try {\n-            xqa[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-           throw new AssertionError(\"Missing NPE\");\n-        }\n-        npe = false;\n-\n-        oa = xa;\n-        try {\n-            oa[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-           throw new AssertionError(\"Missing NPE\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsTest.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -57,1 +57,1 @@\n-    public primitive class V<@TA @TARR T> {}\n+    public value class V<@TA @TARR T> {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnannotatedProjection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -33,0 +32,1 @@\n+ * @ignore\n@@ -41,1 +41,1 @@\n-    public primitive class X {\n+    public value class X {\n@@ -43,1 +43,1 @@\n-        X.ref xr = null;\n+        X xr = null;\n@@ -45,1 +45,1 @@\n-        public void foo(X.ref[] xra, X[] xa) {\n+        public void foo(X[] xra, X[] xa) {\n@@ -47,1 +47,1 @@\n-            xra = new X.ref[10];\n+            xra = new X[10];\n@@ -50,2 +50,2 @@\n-            Class<?> c = X.val.class;\n-            c = X.ref.class;\n+            Class<?> c = X.class;\n+            c = X.class;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassBytecodeTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    primitive class V<T> implements java.io.Serializable {}\n+    value class V<T> implements java.io.Serializable {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassInnerClassesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public primitive class UnifiedPrimitiveClassNestHostTest implements java.io.Serializable {\n+public value class UnifiedPrimitiveClassNestHostTest implements java.io.Serializable {\n@@ -40,1 +40,1 @@\n-    primitive class Inner {}\n+    value class Inner {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassNestHostTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    primitive class V {\n+    value class V {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnrelatedThisLeak.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8264977\n- * @summary A primitive class field by name val confuses javac\n- * @compile -XDenablePrimitiveClasses ValRefTokensTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ValRefTokensTest\n- *\/\n-\n-public primitive class ValRefTokensTest  {\n-\n-    ValRefTokensTest.ref aa = null;\n-    static ValRefTokensTest.val bb = ValRefTokensTest.default;\n-\n-    EmptyValue empty = EmptyValue.default;\n-\n-    static primitive class ValRefTokensTestWrapper {\n-       ValRefTokensTest val = ValRefTokensTest.default;\n-       ValRefTokensTest ref = ValRefTokensTest.default;\n-    }\n-\n-    public EmptyValue test139(int x) {\n-        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n-        return x == 0 ? w.val.empty : w.ref.empty;\n-    }\n-\n-    int valx() {\n-        return EmptyValue.val.x;\n-    }\n-\n-    int refx() {\n-        return EmptyValue.ref.x;\n-    }\n-\n-    static primitive class EmptyValue {\n-        static int x = 42;\n-    }\n-\n-    public static void main(String [] args) {\n-        if (new ValRefTokensTest().valx() != new ValRefTokensTest().refx())\n-            throw new AssertionError(\"Broken\");\n-        if (new ValRefTokensTest().test139(0).x != new ValRefTokensTest().test139(1).x)\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValRefTokensTest.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8244233\n- * @summary Nested types are not handled properly across projections\n- * @compile -XDenablePrimitiveClasses ValueAsEnclosingClass.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ValueAsEnclosingClass\n- *\/\n-\n-public primitive class ValueAsEnclosingClass {\n-\n-    static primitive class V {\n-        int y = 52;\n-\n-        class Bar { }\n-        static class Baz { }\n-    }\n-\n-    class Inner { }\n-\n-    static ValueAsEnclosingClass.Inner xi = new ValueAsEnclosingClass().new Inner();\n-    ValueAsEnclosingClass.ref.Inner xri = xi;\n-\n-    public static void main(String[] args) {\n-        new V().new Bar();\n-        V.Baz baz1 = new V.Baz();\n-        V.ref.Baz baz2 = baz1;\n-        new ValueAsEnclosingClass();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAsEnclosingClass.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -39,1 +39,1 @@\n-    public static final primitive class Value {\n+    public static final value class Value {\n@@ -51,0 +51,2 @@\n+        public implicit Value();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueBootstrapMethodsTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public primitive class ValueConstructorRef {\n+public value class ValueConstructorRef {\n@@ -40,2 +40,2 @@\n-    \tx = 1234;\n-    \ty = 5678;\n+        x = 1234;\n+        y = 5678;\n@@ -43,4 +43,4 @@\n-    \n-    public static void main(String [] args) {   \n-       Supplier<ValueConstructorRef.ref> sx = ValueConstructorRef::new;\n-    \tValueConstructorRef x = (ValueConstructorRef) sx.get();\n+\n+    public static void main(String [] args) {\n+        Supplier<ValueConstructorRef> sx = ValueConstructorRef::new;\n+        ValueConstructorRef x = (ValueConstructorRef) sx.get();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueConstructorRef.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n@@ -37,0 +38,1 @@\n+\/\/ very fragile test\n@@ -39,1 +41,1 @@\n-    primitive\n+    value\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueCreationTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class ValueNewReadWrite {\n+public value class ValueNewReadWrite {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueNewReadWrite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public final primitive class ValuesAsRefs {\n+public final value class ValuesAsRefs {\n@@ -35,1 +35,1 @@\n-    final ArrayList<? extends ValuesAsRefs.ref> ao = null; \/\/ values can be wildcard bounds.\n+    final ArrayList<? extends ValuesAsRefs> ao = null; \/\/ values can be wildcard bounds.\n@@ -37,2 +37,2 @@\n-    final primitive class I implements java.io.Serializable {\n-        final int y = 42;\n+    static final value class I implements java.io.Serializable {\n+        public implicit I();\n@@ -42,1 +42,1 @@\n-        I i = this.new I();  \/\/ values can be enclosing instances.\n+        I i = new I();  \/\/ values can be enclosing instances.\n@@ -44,1 +44,1 @@\n-        Object o = (I.ref & java.io.Serializable) i; \/\/ values can be used in intersection casts\n+        Object o = (I & java.io.Serializable) i; \/\/ values can be used in intersection casts\n@@ -47,1 +47,1 @@\n-        this.<ValuesAsRefs.ref>goo(); \/\/ values can be type arguments to generic method calls\n+        this.<ValuesAsRefs>goo(); \/\/ values can be type arguments to generic method calls\n@@ -52,9 +52,1 @@\n-        ArrayList<ValuesAsRefs.I.ref> aloi = new ArrayList<>(); \/\/ values can be type arguments.\n-        boolean OK = false;\n-        try {\n-            aloi.add((ValuesAsRefs.I) o);\n-        } catch (NullPointerException npe) {\n-            OK = true;\n-        }\n-        if (!OK)\n-            throw new AssertionError(\"Missing NPE\");\n+        ArrayList<ValuesAsRefs.I> aloi = new ArrayList<>(); \/\/ values can be type arguments.\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValuesAsRefs.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public final primitive class WithFieldOfGenericType<E> {\n+public final value class WithFieldOfGenericType<E> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldOfGenericType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-public final primitive class WithFieldRuntimeTest {\n+public final value class WithFieldRuntimeTest {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldRuntimeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-public primitive record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n+public value record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8212175\n+ * @summary Trouble creating an anonymous value class with diamond syntax\n+ *\/\n+\n+import java.util.function.Function;\n+\n+public class AnonymousValue {\n+    static Function<String, String> capitalizer() {\n+        return new value Function<>() {\n+            int x = 10;\n+            @Override\n+            public String apply(String t) {\n+                return t.toUpperCase();\n+            }\n+        };\n+    }\n+    public static void main(String[] args) {\n+        if (!capitalizer().apply(\"blah\").equals(\"BLAH\"))\n+            throw new AssertionError(\"Failed\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValue.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8209400 8215246\n+ * @summary Allow anonymous classes to be value types\n+ *\/\n+\n+public class AnonymousValueType {\n+    public static void main(String[] args) {\n+        Object o = new value Comparable<String>() {\n+            int x = 10;\n+            @Override\n+            public int compareTo(String o) {\n+                return 0;\n+            }\n+        };\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n+            throw new AssertionError(\"Broken\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValueType.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8222634\n+ * @summary Check array creation with V and V.ref\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+public class ArrayCreationWithQuestion {\n+\n+    static value class VT {\n+        VT[] a1;\n+        VT[] a2;\n+        VT![] a3;\n+        VT![] a4;\n+\n+        public implicit VT();\n+\n+        VT(boolean non_implicit) {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+            a3 = new VT![42];\n+            a4 = new VT![42];\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new ArrayCreationWithQuestion().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                Paths.get(System.getProperty(\"test.classes\"),\n+                        \"ArrayCreationWithQuestion$VT.class\").toString() };\n+        runCheck(params, new String [] {\n+                \"         6: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"        17: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"        33: invokestatic  #16                 \/\/ Method java\/lang\/reflect\/Array.newInstance:(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n+                \"        52: invokestatic  #16                 \/\/ Method java\/lang\/reflect\/Array.newInstance:(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n+        });\n+\n+    }\n+\n+    void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+        if (errors > 0) {\n+            throw new AssertionError(\"Unexpected javap output: \" + out);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8208067\n+ * @summary Verify that instance methods are callable from ctor after all instance fields are DA.\n+ *\/\n+\n+public value class CanonicalCtorTest {\n+\n+    private final int x, ymx;\n+\n+    CanonicalCtorTest(int x, int y) {\n+\n+        ymx = y - x;\n+        this.x = x;\n+\n+        \/\/ ALL fields are assigned now.\n+\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        CanonicalCtorTest.this.validate();          \/\/ OK: DU = {}\n+\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n+\n+    int x() {\n+        return x;\n+    }\n+\n+    int y() {\n+        return ymx + x;\n+    }\n+\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n+\n+    public static void main(String... av) {\n+        CanonicalCtorTest z = new CanonicalCtorTest(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-    public static primitive class P {\n+    public static class P {\n@@ -62,1 +62,1 @@\n-        Supplier<P.ref> sxp = P::new;\n+        Supplier<P> sxp = P::new;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConstructorRefTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,4 @@\n+import com.sun.tools.javac.util.Assert;\n+\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.Attributes;\n@@ -51,0 +55,2 @@\n+import com.sun.tools.classfile.ImplicitCreation_attribute;\n+import com.sun.tools.classfile.NullRestricted_attribute;\n@@ -190,15 +196,7 @@\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-XDenablePrimitiveClasses\"};\n-            setCompileOptions(testOptions);\n-            String[] sources = new String[] {\n-                    \"static static class StaticTest {}\",\n-                    \"native native class NativeTest {}\",\n-                    \"value value primitive class ValueTest {}\",\n-                    \"primitive primitive value class PrimitiveTest {}\"\n-            };\n-            for (String source : sources) {\n-                assertFail(\"compiler.err.repeated.modifier\", source);\n-            }\n-        } finally {\n-            setCompileOptions(previousOptions);\n+        String[] sources = new String[] {\n+                \"static static class StaticTest {}\",\n+                \"native native class NativeTest {}\",\n+                \"value value class ValueTest {}\"\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.repeated.modifier\", source);\n@@ -849,0 +847,220 @@\n+\n+    public void testSelectors() throws Exception {\n+        assertOK(\n+                \"\"\"\n+                value class V {\n+                    void selector() {\n+                        Class<?> c = int.class;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                value class V {\n+                    void selector() {\n+                        int i = int.default;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.expected2\",\n+                \"\"\"\n+                value class V {\n+                    void selector() {\n+                        int i = int.some_selector;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testImplicitConstructor() {\n+        assertOK(\n+                \"\"\"\n+                value class V {\n+                    public implicit V();\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.implicit.const.must.be.public\",\n+                \"\"\"\n+                value class V {\n+                    implicit V();\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.implicit.const.cant.have.body\",\n+                \"\"\"\n+                value class V {\n+                    public implicit V() {}\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.implicit.const.must.be.public\",\n+                \"\"\"\n+                value class V {\n+                    private implicit V();\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.implicit.const.must.be.public\",\n+                \"\"\"\n+                value class V {\n+                    protected implicit V();\n+                }\n+                \"\"\"\n+        );\n+\n+        assertFail(\"compiler.err.already.defined\",\n+                \"\"\"\n+                value class V {\n+                    public implicit V();\n+                    public V() {}\n+                }\n+                \"\"\"\n+        );\n+\n+        assertFail(\"compiler.err.implicit.const.must.be.declared.in.value.class\",\n+                \"\"\"\n+                class V {\n+                    public implicit V();\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.value.class.with.implicit.cannot.be.inner\",\n+                \"\"\"\n+                class Outer {\n+                    value class V {\n+                        public implicit V();\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.value.class.with.implicit.cannot.be.inner\",\n+                \"\"\"\n+                class Outer {\n+                    new value class V() {\n+                        public implicit V();\n+                    };\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.value.class.with.implicit.cannot.be.inner\",\n+                \"\"\"\n+                class Outer {\n+                    void m() {\n+                        value class V {\n+                            public implicit V();\n+                        }\n+                    }\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.cyclic.primitive.class.membership\",\n+                \"\"\"\n+                value class V {\n+                    V! v;\n+                    public implicit V();\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.value.class.with.implicit.instance.field.initializer\",\n+                \"\"\"\n+                value class V {\n+                    String s = \"\";\n+                    public implicit V();\n+                }\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.value.class.with.implicit.declares.init.block\",\n+                \"\"\"\n+                value class V {\n+                    String s;\n+                    {\n+                        s = \"\";\n+                    }\n+                    public implicit V();\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    private File findClassFileOrFail(File dir, String name) {\n+        for (final File fileEntry : dir.listFiles()) {\n+            if (fileEntry.getName().equals(name)) {\n+                return fileEntry;\n+            }\n+        }\n+        throw new AssertionError(\"file not found\");\n+    }\n+\n+    private Attribute findAttributeOrFail(Attributes attributes, Class<? extends Attribute> attrClass) {\n+        for (Attribute attribute : attributes) {\n+            if (attribute.getClass() == attrClass) {\n+                return attribute;\n+            }\n+        }\n+        throw new AssertionError(\"attribute not found\");\n+    }\n+\n+    public void testClassAttributes() throws Exception {\n+        String code =\n+                \"\"\"\n+                value class V0 {\n+                    public implicit V0();\n+                }\n+\n+                value class V1 {\n+                    V0! f1;\n+                    V0 f2;\n+                    public implicit V1();\n+                }\n+\n+                value class V2 {\n+                    public V2() {}\n+                }\n+                \"\"\";\n+\n+        File dir = assertOK(true, code);\n+\n+        \/\/ test for V1\n+        ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"V1.class\"));\n+\n+        Field field1 = classFile.fields[0];\n+        findAttributeOrFail(field1.attributes, NullRestricted_attribute.class);\n+        Field field2 = classFile.fields[1];\n+        try {\n+            findAttributeOrFail(field2.attributes, NullRestricted_attribute.class);\n+            throw new AssertionError(\"NullRestricted attribute shouldn't be here\");\n+        } catch (Throwable t) {\n+            \/\/ good\n+        }\n+        findAttributeOrFail(classFile.attributes, ImplicitCreation_attribute.class);\n+\n+        classFile = ClassFile.read(findClassFileOrFail(dir, \"V2.class\"));\n+        try {\n+            findAttributeOrFail(classFile.attributes, ImplicitCreation_attribute.class);\n+            throw new AssertionError(\"ImplicitCreation attribute shouldn't be here\");\n+        } catch (Throwable t) {\n+            \/\/ good\n+        }\n+    }\n+\n+    public void testImplementingLooselyConsistentValue() {\n+        assertFail(\"compiler.err.cant.implement.interface\",\n+                \"\"\"\n+                class V implements LooselyConsistentValue {}\n+                \"\"\"\n+        );\n+        assertFail(\"compiler.err.cant.implement.interface\",\n+                \"\"\"\n+                value class V implements LooselyConsistentValue {}\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                abstract class V implements LooselyConsistentValue {}\n+                \"\"\"\n+        );\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":233,"deletions":15,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8314165\n+ * @summary check for illegal circularity at class loading time\n+ * @build CyclicValueClass\n+ * @compile\/fail\/ref=CheckForCyclesAtClassLoadingTimeTest.out -XDrawDiagnostics CheckForCyclesAtClassLoadingTimeTest.java\n+ *\/\n+class CheckForCyclesAtClassLoadingTimeTest {\n+    CyclicValueClass cyclicValueClass;\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CheckForCyclesAtClassLoadingTimeTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CyclicValueClass.class:-:-: compiler.err.cyclic.primitive.class.membership: CyclicValueClass\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CheckForCyclesAtClassLoadingTimeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class CyclicValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"CyclicValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"cyclicField\"; \/\/ #5\n+    Utf8 \"LCyclicValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LCyclicValueClass;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"CyclicValueClass.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class CyclicValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CyclicValueClass.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}