{"files":[{"patch":"@@ -348,1 +348,1 @@\n-    const int is_value_mask = markWord::always_locked_pattern;\n+    const int is_value_mask = markWord::inline_type_pattern;\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2044,1 +2044,1 @@\n-  \/\/ (2) Value object check -- if either of the operands is not a value object,\n+  \/\/ (2) Inline type check -- if either of the operands is not a inline type,\n@@ -2046,1 +2046,1 @@\n-  \/\/     operands are value objects\n+  \/\/     operands are inline type\n@@ -2050,1 +2050,1 @@\n-    __ movptr(tmp1, (intptr_t)markWord::always_locked_pattern);\n+    __ movptr(tmp1, (intptr_t)markWord::inline_type_pattern);\n@@ -2053,1 +2053,1 @@\n-    __ cmpptr(tmp1, (intptr_t)markWord::always_locked_pattern);\n+    __ cmpptr(tmp1, (intptr_t)markWord::inline_type_pattern);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,3 +74,4 @@\n-  if (EnableValhalla && !UseBiasedLocking) {\n-    \/\/ Mask always_locked bit such that we go to the slow path if object is an inline type\n-    andptr(hdr, ~((int) markWord::biased_lock_bit_in_place));\n+  if (EnableValhalla) {\n+    assert(!UseBiasedLocking, \"Not compatible with biased-locking\");\n+    \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+    andptr(hdr, ~((int) markWord::inline_type_bit_in_place));\n@@ -167,2 +168,2 @@\n-  if ((UseBiasedLocking || EnableValhalla) && !len->is_valid()) {\n-    \/\/ Need to copy markWord::always_locked_pattern for values.\n+  if (EnableValhalla) {\n+    \/\/ Need to copy markWord::prototype header for klass\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -519,3 +519,4 @@\n-  if (EnableValhalla && !UseBiasedLocking) {\n-    \/\/ Mask always_locked bit such that we go to the slow path if object is an inline type\n-    andptr(tmpReg, ~((int) markWord::biased_lock_bit_in_place));\n+  if (EnableValhalla) {\n+    assert(!UseBiasedLocking, \"Not compatible with biased-locking\");\n+    \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+    andptr(tmpReg, ~((int) markWord::inline_type_bit_in_place));\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1376,3 +1376,4 @@\n-    if (EnableValhalla && !UseBiasedLocking) {\n-      \/\/ For slow path is_always_locked, using biased, which is never natural for !UseBiasLocking\n-      andptr(swap_reg, ~((int) markWord::biased_lock_bit_in_place));\n+    if (EnableValhalla) {\n+      assert(!UseBiasedLocking, \"Not compatible with biased-locking\");\n+      \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+      andptr(swap_reg, ~((int) markWord::inline_type_bit_in_place));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2674,0 +2674,6 @@\n+void MacroAssembler::test_markword_is_inline_type(Register markword, Label& is_inline_type) {\n+  andptr(markword, markWord::inline_type_mask_in_place);\n+  cmpptr(markword, markWord::inline_type_pattern);\n+  jcc(Assembler::equal, is_inline_type);\n+}\n+\n@@ -2683,1 +2689,1 @@\n-  const int is_inline_type_mask = markWord::always_locked_pattern;\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n@@ -2728,0 +2734,17 @@\n+void MacroAssembler::test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label) {\n+  Label test_mark_word;\n+  \/\/ load mark word\n+  movptr(temp_reg, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  \/\/ check displaced\n+  testl(temp_reg, markWord::unlocked_value);\n+  jccb(Assembler::notZero, test_mark_word);\n+  \/\/ slow path use klass prototype\n+  push(rscratch1);\n+  load_prototype_header(temp_reg, oop, rscratch1);\n+  pop(rscratch1);\n+\n+  bind(test_mark_word);\n+  testl(temp_reg, test_bit);\n+  jcc((jmp_set) ? Assembler::notZero : Assembler::zero, jmp_label);\n+}\n+\n@@ -2730,2 +2753,4 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  load_klass(temp_reg, oop, tmp_load_klass);\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flattened_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n@@ -2734,0 +2759,1 @@\n+#endif\n@@ -2738,2 +2764,4 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  load_klass(temp_reg, oop, tmp_load_klass);\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flattened_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n@@ -2742,0 +2770,1 @@\n+#endif\n@@ -2745,2 +2774,4 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  load_klass(temp_reg, oop, tmp_load_klass);\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, true, is_null_free_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n@@ -2749,0 +2780,1 @@\n+#endif\n@@ -2752,2 +2784,4 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  load_klass(temp_reg, oop, tmp_load_klass);\n+#ifdef _LP64\n+  test_oop_prototype_bit(oop, temp_reg, markWord::nullfree_array_bit_in_place, false, is_non_null_free_array);\n+#else\n+  load_klass(temp_reg, oop, noreg);\n@@ -2756,0 +2790,1 @@\n+#endif\n@@ -2762,0 +2797,1 @@\n+\n@@ -5416,1 +5452,1 @@\n-    movptr(Address(r13, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::always_locked_prototype().value());\n+    movptr(Address(r13, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::inline_type_prototype().value());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -104,1 +104,4 @@\n-  \/\/ valueKlass queries, kills temp_reg\n+  \/\/ markWord tests, kills markWord reg\n+  void test_markword_is_inline_type(Register markword, Label& is_inline_type);\n+\n+  \/\/ inlineKlass queries, kills temp_reg\n@@ -119,1 +122,2 @@\n-  \/\/ Check oops array storage properties, i.e. flattened and\/or null-free\n+  \/\/ Check oops for special arrays, i.e. flattened and\/or null-free\n+  void test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2749,3 +2749,4 @@\n-    if (EnableValhalla && !UseBiasedLocking) {\n-      \/\/ For slow path is_always_locked, using biased, which is never natural for !UseBiasLocking\n-      __ andptr(swap_reg, ~((int) markWord::biased_lock_bit_in_place));\n+    if (EnableValhalla) {\n+      assert(!UseBiasedLocking, \"Not compatible with biased-locking\");\n+      \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+      __ andptr(swap_reg, ~((int) markWord::inline_type_bit_in_place));\n@@ -2754,0 +2755,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2487,1 +2487,1 @@\n-  const int is_inline_type_mask = markWord::always_locked_pattern;\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n@@ -4667,2 +4667,1 @@\n-  const int is_inline_type_mask = markWord::always_locked_pattern;\n-  Label has_identity;\n+  Label is_inline_type;\n@@ -4670,7 +4669,1 @@\n-  __ andptr(rbx, is_inline_type_mask);\n-  __ cmpl(rbx, is_inline_type_mask);\n-  __ jcc(Assembler::notEqual, has_identity);\n-  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n-                     InterpreterRuntime::throw_illegal_monitor_state_exception));\n-  __ should_not_reach_here();\n-  __ bind(has_identity);\n+  __ test_markword_is_inline_type(rbx, is_inline_type);\n@@ -4767,0 +4760,5 @@\n+\n+  __ bind(is_inline_type);\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                    InterpreterRuntime::throw_illegal_monitor_state_exception));\n+  __ should_not_reach_here();\n@@ -4777,1 +4775,1 @@\n-  const int is_inline_type_mask = markWord::always_locked_pattern;\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    assert(new_obj != NULL ||                      \/\/ is forwarding ptr?\n-           obj->mark() == markWord::prototype() || \/\/ not gc marked?\n+    assert(new_obj != NULL ||                          \/\/ is forwarding ptr?\n+           obj->mark() == markWord::prototype_for_klass(obj->klass()) || \/\/ not gc marked?\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-    archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original));\n+    archived_oop->set_mark(markWord::prototype_for_klass(archived_oop->klass()).copy_set_hash(hash_original));\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,0 +140,2 @@\n+    assert(oop == NULL || oop->is_flatArray(), \"sanity\");\n+    assert(oop == NULL || oop->klass()->is_flatArray_klass(), \"sanity\");\n@@ -143,1 +145,2 @@\n-  assert(oop == NULL || oop->klass()->is_null_free_array_klass(), \"Bad array storage encoding\");\n+  assert(oop == NULL || oop->klass()->is_null_free_array_klass(), \"sanity\");\n+  assert(oop == NULL || oop->is_nullfreeArray(), \"sanity\");\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-  set_layout_helper(array_layout_helper(InlineKlass::cast(element_klass)));\n@@ -65,0 +64,1 @@\n+  set_layout_helper(array_layout_helper(InlineKlass::cast(element_klass)));\n@@ -67,0 +67,4 @@\n+  assert(is_null_free_array_klass(), \"sanity\");\n+\n+  set_prototype_header(markWord::flat_array_prototype());\n+  assert(prototype_header().is_flat_array(), \"sanity\");\n@@ -68,1 +72,0 @@\n-  CMH(\"tweak name symbol refcnt ?\")\n@@ -184,1 +187,1 @@\n-  assert(obj->is_flatArray(),\"must be an flat array\");\n+  assert(obj->klass()->is_flatArray_klass(),\"must be an flat array\");\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  assert(obj->is_flatArray(),\"must be a flat array\");\n+  assert(obj->klass()->is_flatArray_klass(),\"must be a flat array\");\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,2 +63,3 @@\n-  set_prototype_header(markWord::always_locked_prototype());\n-  assert(is_inline_type_klass(), \"invariant\");\n+  set_prototype_header(markWord::inline_type_prototype());\n+  assert(is_inline_type_klass(), \"sanity\");\n+  assert(prototype_header().is_inline_type(), \"sanity\");\n@@ -131,1 +132,1 @@\n-  assert(oop->mark().is_always_locked(), \"Unlocked inline type\");\n+  assert(oop->mark().is_inline_type(), \"Expected inline type\");\n@@ -139,1 +140,1 @@\n-  assert(oop->mark().is_always_locked(), \"Unlocked inline type\");\n+  assert(oop->mark().is_inline_type(), \"Expected inline type\");\n@@ -552,1 +553,1 @@\n-  guarantee(prototype_header().is_always_locked(), \"Prototype header is not always locked\");\n+  guarantee(prototype_header().is_inline_type(), \"Prototype header is not inline type\");\n@@ -557,1 +558,1 @@\n-  guarantee(obj->mark().is_always_locked(), \"Header is not always locked\");\n+  guarantee(obj->mark().is_inline_type(), \"Header is not inline type\");\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  assert(!is_inline_klass() || header.is_always_locked(), \"Unexpected prototype\");\n+  assert(!is_inline_klass() || header.is_inline_type(), \"Unexpected prototype\");\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-\/\/             \"1\"        :23 epoch:2 age:4    biased_lock:1 lock:2 (biased always locked object)\n@@ -47,1 +46,0 @@\n-\/\/  \"1\"        :54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased always locked object)\n@@ -92,11 +90,0 @@\n-\/\/    Always locked: since displaced and monitor references require memory at a\n-\/\/    fixed address, and hash code can be displaced, an efficiently providing a\n-\/\/    *permanent lock* leaves us with specializing the biased pattern (even when\n-\/\/    biased locking isn't enabled). Since biased_lock_alignment for the thread\n-\/\/    reference doesn't use the lowest bit (\"2 << thread_shift\"), we can use\n-\/\/    this illegal thread pointer alignment to denote \"always locked\" pattern.\n-\/\/\n-\/\/    [ <unused> | larval |1| epoch | age | 1 | 01]       permanently locked\n-\/\/\n-\/\/    A private buffered value is always locked and can be in a larval state.\n-\/\/\n@@ -107,0 +94,68 @@\n+\/\/\n+\/\/\n+\/\/\n+\/\/  Valhalla\n+\/\/\n+\/\/  <CMH: merge this doc into the text above>\n+\/\/\n+\/\/  Project Valhalla has mark word encoding requirements for the following oops:\n+\/\/\n+\/\/  * inline types: have alternative bytecode behavior, e.g. can not be locked\n+\/\/    - \"larval state\": mutable state, but only during object init, observable\n+\/\/      by only by a single thread (generally do not mutate markWord)\n+\/\/\n+\/\/  * flat arrays: load\/decode of klass layout helper is expensive for aaload\n+\/\/\n+\/\/  * \"null free\" arrays: load\/decode of klass layout helper again for aaload\n+\/\/\n+\/\/  UseBiasedLocking \/ EnableValhalla\n+\/\/\n+\/\/  Making the assumption that \"biased locking\" will be removed before inline types\n+\/\/  are introduced to mainline. However, to ease future merge conflict work, left\n+\/\/  bias locking code in place for now. UseBiasedLocking cannot be enabled.\n+\/\/\n+\/\/  \"biased lock bit\" is free to use: using this bit to indicate inline type,\n+\/\/  combined with \"unlocked\" lock bits, means we will not interfere with lock\n+\/\/  encodings (displaced, inflating, and monitor), since inline types can't be\n+\/\/  locked.\n+\/\/\n+\/\/  Further state encoding\n+\/\/\n+\/\/  32 bit plaforms currently have no further room for encoding. No room for\n+\/\/  \"denormalized layout helper bits\", these fast mark word tests can only be made on\n+\/\/  64 bit platforms. 32-bit platforms need to load the klass->_layout_helper. This\n+\/\/  said, the larval state bit is still required for operation, stealing from the hash\n+\/\/  code is simplest mechanism.\n+\/\/\n+\/\/  Valhalla specific encodings\n+\/\/\n+\/\/  Revised Bit-format of an object header (most significant first, big endian layout below):\n+\/\/\n+\/\/  32 bits:\n+\/\/  --------\n+\/\/  hash:24 ------------>| larval:1 age:4 inline_type:1 lock:2\n+\/\/\n+\/\/  64 bits:\n+\/\/  --------\n+\/\/  unused:1 | <-- hash:31 -->| unused:22 larval:1 age:4 flat_array:1 nullfree_array:1 inline_type:1 lock:2\n+\/\/\n+\/\/  The \"fast\" static type bits (flat_array, nullfree_array, and inline_type)\n+\/\/  are placed lowest next to lock bits to more easily decode forwarding pointers.\n+\/\/  G1 for example, implicitly clears age bits (\"G1FullGCCompactionPoint::forward()\")\n+\/\/  using \"oopDesc->forwardee()\", so it necessary for \"markWord::decode_pointer()\"\n+\/\/  to return a non-NULL for this case, but not confuse the static type bits for\n+\/\/  a pointer.\n+\/\/\n+\/\/  Static types bits are recorded in the \"klass->prototype_header()\", displaced\n+\/\/  mark should simply use the prototype header as \"slow path\", rather chasing\n+\/\/  monitor or stack lock races.\n+\/\/\n+\/\/  Lock patterns (note inline types can't be locked\/monitor\/inflating)...\n+\/\/\n+\/\/  [ptr            | 000]  locked             ptr points to real header on stack\n+\/\/  [header         | ?01]  unlocked           regular object header\n+\/\/  [ptr            | 010]  monitor            inflated lock (header is wapped out)\n+\/\/  [ptr            | ?11]  marked             used to mark an object\n+\/\/  [0 ............ | 000]  inflating          inflation in progress\n+\/\/\n+\/\/\n@@ -142,2 +197,1 @@\n-  \/\/ Constants\n-  static const int age_bits                       = 4;\n+  \/\/ Constants, in least significant bit order\n@@ -145,6 +199,7 @@\n-  static const int biased_lock_bits               = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - biased_lock_bits;\n-  static const int hash_bits                      = max_hash_bits > 31 ? 31 : max_hash_bits;\n-  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);\n-  static const int epoch_bits                     = 2;\n-  static const int always_locked_bits             = 1;\n+  static const int biased_lock_bits               = 1; \/\/ Valhalla: unused\n+  \/\/ static prototype header bits (fast path instead of klass layout_helper)\n+  static const int inline_type_bits               = 1;\n+  static const int nullfree_array_bits            = LP64_ONLY(1) NOT_LP64(0);\n+  static const int flat_array_bits                = LP64_ONLY(1) NOT_LP64(0);\n+  \/\/ instance state\n+  static const int age_bits                       = 4;\n@@ -152,1 +207,4 @@\n-\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - inline_type_bits - larval_bits - flat_array_bits - nullfree_array_bits;\n+  static const int hash_bits                      = max_hash_bits > 31 ? 31 : max_hash_bits;\n+  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0); \/\/ Valhalla: unused\n+  static const int epoch_bits                     = 2; \/\/ Valhalla: unused\n@@ -158,6 +216,8 @@\n-  static const int age_shift                      = lock_bits + biased_lock_bits;\n-  static const int unused_gap_shift               = age_shift + age_bits;\n-  static const int hash_shift                     = unused_gap_shift + unused_gap_bits;\n-  static const int epoch_shift                    = hash_shift;\n-  static const int thread_shift                   = epoch_shift + epoch_bits;\n-  static const int larval_shift                   = thread_shift + always_locked_bits;\n+  static const int inline_type_shift              = lock_bits;\n+  static const int nullfree_array_shift           = inline_type_shift + inline_type_bits;\n+  static const int flat_array_shift               = nullfree_array_shift + nullfree_array_bits;\n+  static const int age_shift                      = flat_array_shift + flat_array_bits;\n+  static const int unused_gap_shift               = age_shift + age_bits; \/\/ Valhalla: unused\n+  static const int larval_shift                   = age_shift + age_bits;\n+  static const int hash_shift                     = LP64_ONLY(32) NOT_LP64(larval_shift + larval_bits);\n+  static const int epoch_shift                    = unused_gap_shift + unused_gap_bits \/*hash_shift*\/; \/\/ Valhalla: unused\n@@ -167,3 +227,13 @@\n-  static const uintptr_t biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits);\n-  static const uintptr_t biased_lock_mask_in_place= biased_lock_mask << lock_shift;\n-  static const uintptr_t biased_lock_bit_in_place = 1 << biased_lock_shift;\n+  static const uintptr_t biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits); \/\/ Valhalla: unused\n+  static const uintptr_t biased_lock_mask_in_place= biased_lock_mask << lock_shift; \/\/ Valhalla: unused\n+  static const uintptr_t biased_lock_bit_in_place = 1 << biased_lock_shift; \/\/ Valhalla: unused\n+  static const uintptr_t inline_type_mask         = right_n_bits(lock_bits + inline_type_bits);\n+  static const uintptr_t inline_type_mask_in_place = inline_type_mask << lock_shift;\n+  static const uintptr_t inline_type_bit_in_place = 1 << inline_type_shift;\n+  static const uintptr_t nullfree_array_mask      = right_n_bits(nullfree_array_bits);\n+  static const uintptr_t nullfree_array_mask_in_place = (nullfree_array_mask << nullfree_array_shift) | lock_mask_in_place;\n+  static const uintptr_t nullfree_array_bit_in_place = (1 << nullfree_array_shift);\n+  static const uintptr_t flat_array_mask          = right_n_bits(flat_array_bits);\n+  static const uintptr_t flat_array_mask_in_place = (flat_array_mask << flat_array_shift) | nullfree_array_mask_in_place | lock_mask_in_place;\n+  static const uintptr_t flat_array_bit_in_place  = (1 << flat_array_shift);\n+\n@@ -172,2 +242,1 @@\n-  static const uintptr_t epoch_mask               = right_n_bits(epoch_bits);\n-  static const uintptr_t epoch_mask_in_place      = epoch_mask << epoch_shift;\n+\n@@ -175,1 +244,5 @@\n-  static const uintptr_t larval_mask_in_place     = larval_mask << larval_shift;\n+  static const uintptr_t larval_mask_in_place     = (larval_mask << larval_shift) | inline_type_mask_in_place;\n+  static const uintptr_t larval_bit_in_place      = (1 << larval_shift);\n+\n+  static const uintptr_t epoch_mask               = right_n_bits(epoch_bits); \/\/ Valhalla: unused\n+  static const uintptr_t epoch_mask_in_place      = epoch_mask << epoch_shift;\/\/ Valhalla: unused\n@@ -181,1 +254,1 @@\n-  static const size_t biased_lock_alignment       = 2 << thread_shift;\n+  static const size_t biased_lock_alignment       = 2 << (epoch_shift + epoch_bits); \/\/ Valhalla: unused\n@@ -187,2 +260,10 @@\n-  static const uintptr_t biased_lock_pattern      = 5;\n-  static const uintptr_t always_locked_pattern    = 1 << thread_shift | biased_lock_pattern;\n+  static const uintptr_t biased_lock_pattern      = 5; \/\/ Valhalla: unused\n+\n+  static const uintptr_t inline_type_pattern      = inline_type_bit_in_place | unlocked_value;\n+  static const uintptr_t nullfree_array_pattern   = nullfree_array_bit_in_place | unlocked_value;\n+  static const uintptr_t flat_array_pattern       = flat_array_bit_in_place | nullfree_array_pattern;\n+  static const uintptr_t static_prototype_mask    = LP64_ONLY(right_n_bits(inline_type_bits + flat_array_bits + nullfree_array_bits)) NOT_LP64(right_n_bits(inline_type_bits));\n+  static const uintptr_t static_prototype_mask_in_place = static_prototype_mask << lock_bits;\n+  static const uintptr_t static_prototype_value_max = (1 << age_shift) - 1;\n+\n+  static const uintptr_t larval_pattern           = larval_bit_in_place | inline_type_pattern;\n@@ -201,4 +282,2 @@\n-  enum { larval_state_pattern     = (1 << larval_shift) };\n-\n-  static markWord always_locked_prototype() {\n-    return markWord(always_locked_pattern);\n+  bool is_inline_type() const {\n+    return (mask_bits(value(), inline_type_mask_in_place) == inline_type_pattern);\n@@ -207,2 +286,0 @@\n-  bool is_always_locked() const { return mask_bits(value(), always_locked_pattern) == always_locked_pattern; }\n-\n@@ -220,1 +297,0 @@\n-    assert(!is_always_locked(), \"invariant\");\n@@ -238,1 +314,0 @@\n-    assert(!is_always_locked(), \"Rebias needs to fail\");\n@@ -383,1 +458,1 @@\n-    return markWord((value() & ~larval_mask_in_place) | larval_state_pattern);\n+    return markWord(value() | larval_bit_in_place);\n@@ -386,1 +461,1 @@\n-    return markWord(value() & ~larval_mask_in_place);\n+    return markWord(value() & ~larval_bit_in_place);\n@@ -389,1 +464,6 @@\n-    return (value() & larval_mask_in_place) == larval_state_pattern;\n+    return (mask_bits(value(), larval_mask_in_place) == larval_pattern);\n+  }\n+\n+#ifdef _LP64 \/\/ 64 bit encodings only\n+  bool is_flat_array() const {\n+    return (mask_bits(value(), flat_array_mask_in_place) == flat_array_pattern);\n@@ -392,0 +472,4 @@\n+  bool is_nullfree_array() const {\n+    return (mask_bits(value(), nullfree_array_mask_in_place) == nullfree_array_pattern);\n+  }\n+#endif\n@@ -397,1 +481,14 @@\n-  \/\/ Helper function for restoration of unmarked mark oops during GC\n+  static markWord inline_type_prototype() {\n+    return markWord(inline_type_pattern);\n+  }\n+\n+#ifdef _LP64 \/\/ 64 bit encodings only\n+  static markWord flat_array_prototype() {\n+    return markWord(flat_array_pattern);\n+  }\n+\n+  static markWord nullfree_array_prototype() {\n+    return markWord(nullfree_array_pattern);\n+  }\n+#endif\n+    \/\/ Helper function for restoration of unmarked mark oops during GC\n@@ -407,1 +504,1 @@\n-  inline void* decode_pointer() { if (has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }\n+  inline void* decode_pointer() { return (EnableValhalla && _value < static_prototype_value_max) ? NULL : (void*) (clear_lock_bits().value()); }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":147,"deletions":50,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  return (!is_unlocked() || !has_no_hash());\n+  return (!is_unlocked() || !has_no_hash() || (EnableValhalla && is_larval_state()));\n@@ -68,1 +68,1 @@\n-  return (!is_unlocked() || !has_no_hash());\n+  return (!is_unlocked() || !has_no_hash() || (EnableValhalla && is_larval_state()));\n@@ -73,1 +73,5 @@\n-  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n+  assert(prototype_header == prototype() ||\n+         prototype_header.has_bias_pattern() ||\n+         prototype_header.is_inline_type() ||\n+         prototype_header.is_flat_array() ||\n+         prototype_header.is_nullfree_array(), \"corrupt prototype header\");\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+    set_prototype_header(markWord::nullfree_array_prototype());\n+    assert(prototype_header().is_nullfree_array(), \"sanity\");\n@@ -507,0 +509,1 @@\n+  guarantee(obj->is_nullfreeArray() || (!is_null_free_array_klass()), \"null-free klass but not object\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+bool oopDesc::is_nullfreeArray_noinline()     const { return is_nullfreeArray();       }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+  inline bool is_nullfreeArray()       const;\n@@ -125,0 +126,1 @@\n+  bool is_nullfreeArray_noinline()     const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,2 +206,9 @@\n-bool oopDesc::is_inline_type() const { return klass()->is_inline_klass(); }\n-bool oopDesc::is_flatArray() const { return klass()->is_flatArray_klass(); }\n+\n+bool oopDesc::is_inline_type() const { return mark().is_inline_type(); }\n+#if _LP64\n+bool oopDesc::is_flatArray()     const { return mark().is_flat_array(); }\n+bool oopDesc::is_nullfreeArray() const { return mark().is_nullfree_array(); }\n+#else\n+bool oopDesc::is_flatArray()     const { return klass()->is_flatArray_klass(); }\n+bool oopDesc::is_nullfreeArray() const { return klass()->is_null_free_array_klass(); }\n+#endif\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1651,2 +1651,1 @@\n-  \/\/ For now only enable fast locking for non-array types\n-  if ((EnableValhalla || UseBiasedLocking) && Opcode() == Op_Allocate) {\n+  if (EnableValhalla) {\n@@ -1661,1 +1660,1 @@\n-  return new OrXNode(mark_node, phase->MakeConX(_larval ? markWord::larval_state_pattern : 0));\n+  return new OrXNode(mark_node, phase->MakeConX(_larval ? markWord::larval_bit_in_place : 0));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3550,1 +3550,1 @@\n-\/\/ Check if 'obj' is an inline type by checking if it has the always_locked markWord pattern set.\n+\/\/ Check if 'obj' is an inline type by checking if it has the inline_type_pattern markWord pattern set.\n@@ -3554,1 +3554,1 @@\n-  Node* mask = _gvn.MakeConX(markWord::always_locked_pattern);\n+  Node* mask = _gvn.MakeConX(markWord::inline_type_pattern);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-  mark = kit->gvn().transform(new AndXNode(mark, kit->MakeConX(~markWord::larval_mask_in_place)));\n+  mark = kit->gvn().transform(new AndXNode(mark, kit->MakeConX(~markWord::larval_bit_in_place)));\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2525,1 +2525,1 @@\n-    Node* value_mask = _igvn.MakeConX(markWord::always_locked_pattern);\n+    Node* value_mask = _igvn.MakeConX(markWord::inline_type_pattern);\n@@ -2780,1 +2780,1 @@\n-  Node* mark_node = makecon(TypeRawPtr::make((address)markWord::always_locked_prototype().value()));\n+  Node* mark_node = makecon(TypeRawPtr::make((address)markWord::inline_type_prototype().value()));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2079,4 +2079,5 @@\n-\n-  Node* alloc = is_new_object_mark_load(phase);\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n-    return TypeX::make(markWord::prototype().value());\n+  if (!EnableValhalla) { \/\/ CMH: Fix JDK-8255045\n+    Node* alloc = is_new_object_mark_load(phase);\n+    if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n+      return TypeX::make(markWord::prototype().value());\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-    if (con == markWord::always_locked_pattern) {\n+    if (con == markWord::inline_type_pattern) {\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -971,7 +971,2 @@\n-    \/\/ Inline types instances don't support synchronization operations\n-    \/\/ they are marked as always locked and no attempt to remove a\n-    \/\/ potential bias (which cannot exist) should be made\n-    if (!hobj()->mark().is_always_locked()) {\n-      \/\/ Revoke any biases before querying the mark word\n-      BiasedLocking::revoke_at_safepoint(hobj);\n-    }\n+    \/\/ Revoke any biases before querying the mark word\n+    BiasedLocking::revoke_at_safepoint(hobj);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3231,0 +3231,5 @@\n+  if (UseBiasedLocking) {\n+    jio_fprintf(defaultStream::error_stream(), \"Valhalla does not support use with UseBiasedLocking\");\n+    return JNI_ERR;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -810,1 +810,1 @@\n-  product(bool, UseBiasedLocking, true,                                     \\\n+  product(bool, UseBiasedLocking, false,                                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  if ((obj)->mark().is_always_locked()) {  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n@@ -169,1 +169,1 @@\n-    if ((obj)->mark().is_always_locked()) {  \\\n+    if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n@@ -672,1 +672,1 @@\n-  if (EnableValhalla && mark.is_always_locked()) {\n+  if (EnableValhalla && mark.is_inline_type()) {\n@@ -1216,1 +1216,1 @@\n-  if (EnableValhalla && h_obj->mark().is_always_locked()) {\n+  if (EnableValhalla && h_obj->mark().is_inline_type()) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,7 +29,0 @@\n-class ScopedDisabledBiasedLocking {\n-  bool _orig;\n-public:\n-  ScopedDisabledBiasedLocking() : _orig(UseBiasedLocking) { UseBiasedLocking = false; }\n-  ~ScopedDisabledBiasedLocking() { UseBiasedLocking = _orig; }\n-};\n-\n@@ -53,1 +46,1 @@\n-  static markWord changedMark()  { return markWord(0x4711); }\n+  static markWord changedMark()  { return markWord((uintptr_t)0x4711 << markWord::hash_shift); }\n@@ -59,4 +52,0 @@\n-  \/\/ Need to disable biased locking to easily\n-  \/\/ create oops that \"must_be_preseved\"\n-  ScopedDisabledBiasedLocking dbl;\n-\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -205,0 +205,1 @@\n+serviceability\/sa\/ClhsdbLongConstant.java 8190936 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of UseRTMLocking and UseBiasedLocking\n- *          options combination on CPU, OS, and VM with rtm support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMLockingOptionWithBiasedLocking\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMLockingOptionWithBiasedLocking {\n-\n-    public void runTestCases() throws Throwable {\n-        String warningMessage\n-                = RTMGenericCommandLineOptionTest.RTM_BIASED_LOCKING_WARNING;\n-        String shouldPassMessage = \"JVM startup should pass with both \"\n-                + \"-XX:+UseRTMLocking and \"\n-                + \"-XX:-UseBiasedLocking flags set without any warnings\";\n-        \/\/ verify that we will not get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[] { warningMessage }, shouldPassMessage,\n-                shouldPassMessage, ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:-UseBiasedLocking\");\n-\n-        \/\/ verify that we will get a warning\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { warningMessage }, null,\n-                \"JVM startup should pass when both -XX:+UseRTMLocking and \"\n-                        + \"-XX:+UseBiasedLocking flags set\",\n-                \"Flags -XX:+UseRTMLocking\"\n-                        + \" and -XX:+UseBiasedLocking conflicts. \"\n-                        + \"Warning should be shown.\", ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-        \/\/ verify that UseBiasedLocking is false when we use rtm locking\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseBiasedLocking\",\n-                \"false\",\n-                \"Value of option 'UseBiasedLocking' should be false if\"\n-                        + \"-XX:+UseRTMLocking flag set.\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-        \/\/ verify that we can't turn on biased locking when\n-        \/\/ using rtm locking\n-        CommandLineOptionTest\n-                .verifyOptionValueForSameVM(\n-                        \"UseBiasedLocking\",\n-                        \"false\",\n-                        \"Value of option 'UseBiasedLocking' should be false if\"\n-                                + \"both -XX:+UseRTMLocking and \"\n-                                + \"-XX:+UseBiasedLocking flags set.\",\n-                        CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                        \"-XX:+UseRTMLocking\", \"-XX:+UseBiasedLocking\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockingOptionWithBiasedLocking().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionWithBiasedLocking.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n- * @run main\/othervm -XX:NewSize=10m -XX:+FullGCALot -XX:FullGCALotInterval=120 -XX:+UseBiasedLocking gc.TestFullGCALot\n","filename":"test\/hotspot\/jtreg\/gc\/TestFullGCALot.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-        {\"-Xint\", \"-XX:+UseBiasedLocking\"},\n@@ -47,1 +46,0 @@\n-        {\"-Xcomp\", \"-XX:TieredStopAtLevel=1\", \"-XX:+UseBiasedLocking\"},\n@@ -50,2 +48,0 @@\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:+UseOptoBiasInlining\"},\n-        {\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseBiasedLocking\", \"-XX:-UseOptoBiasInlining\"}\n@@ -167,1 +163,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/SyncOnPrimitiveWrapperTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        for (int i = 0; i < 3; i++) {\n+        for (int i = 0; i < 2; i++) {\n@@ -62,1 +62,0 @@\n-            \/\/ i = 2 -- dump with agent = enable BiasedLocking\n@@ -66,1 +65,0 @@\n-            String biasedLock = (i != 2) ? \"-showversion\" : \"-XX:+UseBiasedLocking\";\n@@ -71,1 +69,1 @@\n-                                    agentArg, agentArg2, biasedLock);\n+                                    agentArg, agentArg2);\n@@ -78,1 +76,1 @@\n-                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2, biasedLock,\n+                \"-XX:+UnlockDiagnosticVMOptions\", agentArg2,\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDump.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test HandshakeDirectTest\n- * @bug 8240918\n- * @summary This test tries to stress direct handshakes between threads while suspending them.\n- * @library \/testlibrary \/test\/lib\n- * @build HandshakeDirectTest\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseBiasedLocking -XX:GuaranteedSafepointInterval=10 -XX:+HandshakeALot -XX:+SafepointALot -XX:BiasedLockingDecayTime=100000000 -XX:BiasedLockingBulkRebiasThreshold=1000000 -XX:BiasedLockingBulkRevokeThreshold=1000000 HandshakeDirectTest\n- *\/\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.Semaphore;\n-import java.io.*;\n-\n-public class HandshakeDirectTest  implements Runnable {\n-    static final int WORKING_THREADS = 32;\n-    static final int DIRECT_HANDSHAKES_MARK = 500000;\n-    static Thread[] workingThreads = new Thread[WORKING_THREADS];\n-    static Semaphore[] handshakeSem = new Semaphore[WORKING_THREADS];\n-    static Object[] locks = new Object[WORKING_THREADS];\n-    static boolean[] isBiased = new boolean[WORKING_THREADS];\n-    static AtomicInteger handshakeCount = new AtomicInteger(0);\n-\n-    @Override\n-    public void run() {\n-        int me = Integer.parseInt(Thread.currentThread().getName());\n-\n-        while (true) {\n-            try {\n-                if (!isBiased[me]) {\n-                    handshakeSem[me].acquire();\n-                    synchronized(locks[me]) {\n-                        isBiased[me] = true;\n-                    }\n-                    handshakeSem[me].release();\n-                }\n-\n-                \/\/ Handshake directly some other worker\n-                int handshakee = ThreadLocalRandom.current().nextInt(0, WORKING_THREADS - 1);\n-                if (handshakee == me) {\n-                    \/\/ Pick another thread instead of me.\n-                    handshakee = handshakee != 0 ? handshakee - 1 : handshakee + 1;\n-                }\n-                handshakeSem[handshakee].acquire();\n-                if (isBiased[handshakee]) {\n-                    \/\/ Revoke biased lock\n-                    synchronized(locks[handshakee]) {\n-                        handshakeCount.incrementAndGet();\n-                    }\n-                    \/\/ Create new lock to be biased\n-                    locks[handshakee] = new Object();\n-                    isBiased[handshakee] = false;\n-                }\n-                handshakeSem[handshakee].release();\n-                if (handshakeCount.get() >= DIRECT_HANDSHAKES_MARK) {\n-                    break;\n-                }\n-            } catch(InterruptedException ie) {\n-                throw new Error(\"Unexpected interrupt\");\n-            }\n-        }\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        HandshakeDirectTest test = new HandshakeDirectTest();\n-\n-        \/\/ Initialize semaphores\n-        for (int i = 0; i < WORKING_THREADS; i++) {\n-            handshakeSem[i] = new Semaphore(1);\n-        }\n-\n-        \/\/ Initialize locks\n-        for (int i = 0; i < WORKING_THREADS; i++) {\n-            locks[i] = new Object();\n-        }\n-\n-        \/\/ Fire-up working threads.\n-        for (int i = 0; i < WORKING_THREADS; i++) {\n-            workingThreads[i] = new Thread(test, Integer.toString(i));\n-            workingThreads[i].start();\n-        }\n-\n-        \/\/ Fire-up suspend-resume thread\n-        Thread suspendResumeThread = new Thread() {\n-            @Override\n-            public void run() {\n-                while (true) {\n-                    int i = ThreadLocalRandom.current().nextInt(0, WORKING_THREADS - 1);\n-                    workingThreads[i].suspend();\n-                    try {\n-                        Thread.sleep(1); \/\/ sleep for 1 ms\n-                    } catch(InterruptedException ie) {\n-                    }\n-                    workingThreads[i].resume();\n-                }\n-            }\n-        };\n-        suspendResumeThread.setDaemon(true);\n-        suspendResumeThread.start();\n-\n-        \/\/ Wait until the desired number of direct handshakes is reached\n-        \/\/ and check that all workers exited\n-        for (int i = 0; i < WORKING_THREADS; i++) {\n-            workingThreads[i].join();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8149383\n- * @summary -Xlog:biasedlocking should have logging from statements in the source code\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver BiasedLockingTest\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class BiasedLockingTest {\n-    static void analyzeOutputOn(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Biased locking enabled\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    static void analyzeOutputOff(ProcessBuilder pb) throws Exception {\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"[biasedlocking]\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                                  \"-Xlog:biasedlocking\",\n-                                                                  \"-XX:BiasedLockingStartupDelay=0\",\n-                                                                  InnerClass.class.getName());\n-        analyzeOutputOn(pb);\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                   \"-XX:+TraceBiasedLocking\",\n-                                                   \"-XX:BiasedLockingStartupDelay=0\",\n-                                                   InnerClass.class.getName());\n-        analyzeOutputOn(pb);\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                   \"-Xlog:biasedlocking=off\",\n-                                                   \"-XX:BiasedLockingStartupDelay=0\",\n-                                                   InnerClass.class.getName());\n-        analyzeOutputOff(pb);\n-\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseBiasedLocking\",\n-                                                   \"-XX:-TraceBiasedLocking\",\n-                                                   \"-XX:BiasedLockingStartupDelay=0\",\n-                                                   InnerClass.class.getName());\n-        analyzeOutputOff(pb);\n-    }\n-\n-    public static class InnerClass {\n-        public static void main(String[] args) {\n-            System.out.println(\"Biased Locking test\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/BiasedLockingTest.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -43,48 +43,0 @@\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoWithEATest.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -39,48 +39,0 @@\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n- *                  -XX:+PrintInlining\n- *                  -XX:-TieredCompilation\n- *                  -Xbatch\n- *                  -XX:CICompilerCount=1\n- *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n- *                  GetOwnedMonitorStackDepthInfoWithEATest\n- * @run main\/othervm\/native\n- *                  -agentlib:GetOwnedMonitorStackDepthInfoWithEATest\n- *                  -XX:+UnlockDiagnosticVMOptions\n- *                  -Xms128m -Xmx128m\n- *                  -XX:CompileCommand=dontinline,*::dontinline_*\n- *                  -XX:+PrintCompilation\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorStackDepthInfo\/GetOwnedMonitorStackDepthInfoWithEATest.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"}]}