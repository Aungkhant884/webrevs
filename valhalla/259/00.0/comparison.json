{"files":[{"patch":"@@ -1630,1 +1630,1 @@\n-  FieldAllocationType update(bool is_static, BasicType type, bool is_inline_type) {\n+  void update(bool is_static, BasicType type, bool is_inline_type) {\n@@ -1637,1 +1637,0 @@\n-    return atype;\n@@ -1805,1 +1804,1 @@\n-    \/\/ \/\/ Remember how many oops we encountered\n+    \/\/ Update FieldAllocationCount for this kind of field\n@@ -1849,1 +1848,1 @@\n-      \/\/ Remember how many oops we encountered\n+      \/\/ Update FieldAllocationCount for this kind of field\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1550,1 +1550,4 @@\n-JRT_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *thread))\n+\/\/ This is a JRT_BLOCK_ENTRY because we have to stash away the return oop\n+\/\/ before transitioning to VM, and restore it after transitioning back\n+\/\/ to Java. The return oop at the top-of-stack, is not walked by the GC.\n+JRT_BLOCK_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *thread))\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3803,1 +3803,7 @@\n-      java_lang_invoke_MemberName::clazz(obj)->print_value_on(st);\n+      oop clazz = java_lang_invoke_MemberName::clazz(obj);\n+      oop name  = java_lang_invoke_MemberName::name(obj);\n+      if (clazz != NULL) {\n+        clazz->print_value_on(st);\n+      } else {\n+        st->print(\"NULL\");\n+      }\n@@ -3805,1 +3811,5 @@\n-      java_lang_invoke_MemberName::name(obj)->print_value_on(st);\n+      if (name != NULL) {\n+        name->print_value_on(st);\n+      } else {\n+        st->print(\"NULL\");\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+#include \"runtime\/monitorDeflationThread.hpp\"\n@@ -890,1 +891,0 @@\n-  static_field(ObjectSynchronizer,             g_block_list,                                  PaddedObjectMonitor*)                  \\\n@@ -1341,0 +1341,1 @@\n+        declare_type(MonitorDeflationThread, JavaThread)                  \\\n@@ -1465,1 +1466,0 @@\n-  declare_toplevel_type(PaddedObjectMonitor)                              \\\n@@ -1997,1 +1997,0 @@\n-  declare_toplevel_type(PaddedObjectMonitor*)                             \\\n@@ -2531,6 +2530,0 @@\n-  \/* ObjectSynchronizer *\/                                                \\\n-  \/**********************\/                                                \\\n-                                                                          \\\n-  declare_constant(ObjectSynchronizer::_BLOCKSIZE)                        \\\n-                                                                          \\\n-  \/**********************\/                                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1918,0 +1918,2 @@\n+        private final boolean isVarargs;\n+\n@@ -1925,0 +1927,6 @@\n+            \/* it is better to store the original information for this one, instead of relying\n+             * on the info in the type of the symbol. This is because on the presence of APs\n+             * the symbol will be blown out and we won't be able to know if the original\n+             * record component was declared varargs or not.\n+             *\/\n+            this.isVarargs = type.hasTag(TypeTag.ARRAY) && ((ArrayType)type).isVarargs();\n@@ -1930,1 +1938,1 @@\n-            return type.hasTag(TypeTag.ARRAY) && ((ArrayType)type).isVarargs();\n+            return isVarargs;\n@@ -1980,1 +1988,1 @@\n-            super(Flags.FINAL | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);\n+            super(Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2643,0 +2643,2 @@\n+        boolean previewClassFile =\n+                minorVersion == ClassFile.PREVIEW_MINOR_VERSION;\n@@ -2646,1 +2648,1 @@\n-            if (majorVersion == (maxMajor + 1))\n+            if (majorVersion == (maxMajor + 1) && !previewClassFile)\n@@ -2658,1 +2660,1 @@\n-        if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {\n+        if (previewClassFile) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}