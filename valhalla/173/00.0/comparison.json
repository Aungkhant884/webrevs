{"files":[{"patch":"@@ -661,0 +661,2 @@\n+b0817631d2f4395508cb10e81c3858a94d9ae4de jdk-15+34\n+0a73d6f3aab48ff6d7e61e47f0bc2d87a054f217 jdk-16+8\n","filename":".hgtags","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1065,2 +1065,2 @@\n-            \/\/ build to support classfile version 57.\n-            \/\/ See CODETOOLS-7902358 for more info.\n+            \/\/ build to support classfile version 60.\n+            \/\/ See CODETOOLS-7902734 for more info.\n@@ -1073,1 +1073,1 @@\n-            revision: \"3.0-59-support+1.0\",\n+            revision: \"3.0-60-support+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1556,1 +1556,1 @@\n-  assert(imm64 < (1ul << 48), \"48-bit overflow in address constant\");\n+  assert(imm64 < (1ull << 48), \"48-bit overflow in address constant\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -570,164 +570,0 @@\n-  \/\/ Implementation of jint atomic_xchg(jint add_value, volatile jint* dest)\n-  \/\/ used by Atomic::xchg(volatile jint* dest, jint exchange_value)\n-  \/\/\n-  \/\/ Arguments :\n-  \/\/    c_rarg0: exchange_value\n-  \/\/    c_rarg0: dest\n-  \/\/\n-  \/\/ Result:\n-  \/\/    *dest <- ex, return (orig *dest)\n-  address generate_atomic_xchg() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_xchg\");\n-    address start = __ pc();\n-\n-    __ movl(rax, c_rarg0); \/\/ Copy to eax we need a return value anyhow\n-    __ xchgl(rax, Address(c_rarg1, 0)); \/\/ automatic LOCK\n-    __ ret(0);\n-\n-    return start;\n-  }\n-\n-  \/\/ Implementation of intptr_t atomic_xchg(jlong add_value, volatile jlong* dest)\n-  \/\/ used by Atomic::xchg(volatile jlong* dest, jlong exchange_value)\n-  \/\/\n-  \/\/ Arguments :\n-  \/\/    c_rarg0: exchange_value\n-  \/\/    c_rarg1: dest\n-  \/\/\n-  \/\/ Result:\n-  \/\/    *dest <- ex, return (orig *dest)\n-  address generate_atomic_xchg_long() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_xchg_long\");\n-    address start = __ pc();\n-\n-    __ movptr(rax, c_rarg0); \/\/ Copy to eax we need a return value anyhow\n-    __ xchgptr(rax, Address(c_rarg1, 0)); \/\/ automatic LOCK\n-    __ ret(0);\n-\n-    return start;\n-  }\n-\n-  \/\/ Support for jint atomic::atomic_cmpxchg(jint exchange_value, volatile jint* dest,\n-  \/\/                                         jint compare_value)\n-  \/\/\n-  \/\/ Arguments :\n-  \/\/    c_rarg0: exchange_value\n-  \/\/    c_rarg1: dest\n-  \/\/    c_rarg2: compare_value\n-  \/\/\n-  \/\/ Result:\n-  \/\/    if ( compare_value == *dest ) {\n-  \/\/       *dest = exchange_value\n-  \/\/       return compare_value;\n-  \/\/    else\n-  \/\/       return *dest;\n-  address generate_atomic_cmpxchg() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_cmpxchg\");\n-    address start = __ pc();\n-\n-    __ movl(rax, c_rarg2);\n-    __ lock();\n-    __ cmpxchgl(c_rarg0, Address(c_rarg1, 0));\n-    __ ret(0);\n-\n-    return start;\n-  }\n-\n-  \/\/ Support for int8_t atomic::atomic_cmpxchg(int8_t exchange_value, volatile int8_t* dest,\n-  \/\/                                           int8_t compare_value)\n-  \/\/\n-  \/\/ Arguments :\n-  \/\/    c_rarg0: exchange_value\n-  \/\/    c_rarg1: dest\n-  \/\/    c_rarg2: compare_value\n-  \/\/\n-  \/\/ Result:\n-  \/\/    if ( compare_value == *dest ) {\n-  \/\/       *dest = exchange_value\n-  \/\/       return compare_value;\n-  \/\/    else\n-  \/\/       return *dest;\n-  address generate_atomic_cmpxchg_byte() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_cmpxchg_byte\");\n-    address start = __ pc();\n-\n-    __ movsbq(rax, c_rarg2);\n-    __ lock();\n-    __ cmpxchgb(c_rarg0, Address(c_rarg1, 0));\n-    __ ret(0);\n-\n-    return start;\n-  }\n-\n-  \/\/ Support for int64_t atomic::atomic_cmpxchg(int64_t exchange_value,\n-  \/\/                                            volatile int64_t* dest,\n-  \/\/                                            int64_t compare_value)\n-  \/\/ Arguments :\n-  \/\/    c_rarg0: exchange_value\n-  \/\/    c_rarg1: dest\n-  \/\/    c_rarg2: compare_value\n-  \/\/\n-  \/\/ Result:\n-  \/\/    if ( compare_value == *dest ) {\n-  \/\/       *dest = exchange_value\n-  \/\/       return compare_value;\n-  \/\/    else\n-  \/\/       return *dest;\n-  address generate_atomic_cmpxchg_long() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_cmpxchg_long\");\n-    address start = __ pc();\n-\n-    __ movq(rax, c_rarg2);\n-    __ lock();\n-    __ cmpxchgq(c_rarg0, Address(c_rarg1, 0));\n-    __ ret(0);\n-\n-    return start;\n-  }\n-\n-  \/\/ Implementation of jint atomic_add(jint add_value, volatile jint* dest)\n-  \/\/ used by Atomic::add(volatile jint* dest, jint add_value)\n-  \/\/\n-  \/\/ Arguments :\n-  \/\/    c_rarg0: add_value\n-  \/\/    c_rarg1: dest\n-  \/\/\n-  \/\/ Result:\n-  \/\/    *dest += add_value\n-  \/\/    return *dest;\n-  address generate_atomic_add() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_add\");\n-    address start = __ pc();\n-\n-    __ movl(rax, c_rarg0);\n-    __ lock();\n-    __ xaddl(Address(c_rarg1, 0), c_rarg0);\n-    __ addl(rax, c_rarg0);\n-    __ ret(0);\n-\n-    return start;\n-  }\n-\n-  \/\/ Implementation of intptr_t atomic_add(intptr_t add_value, volatile intptr_t* dest)\n-  \/\/ used by Atomic::add(volatile intptr_t* dest, intptr_t add_value)\n-  \/\/\n-  \/\/ Arguments :\n-  \/\/    c_rarg0: add_value\n-  \/\/    c_rarg1: dest\n-  \/\/\n-  \/\/ Result:\n-  \/\/    *dest += add_value\n-  \/\/    return *dest;\n-  address generate_atomic_add_long() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"atomic_add_long\");\n-    address start = __ pc();\n-\n-    __ movptr(rax, c_rarg0); \/\/ Copy to eax we need a return value anyhow\n-    __ lock();\n-    __ xaddptr(Address(c_rarg1, 0), c_rarg0);\n-    __ addptr(rax, c_rarg0);\n-    __ ret(0);\n-\n-    return start;\n-  }\n-\n@@ -6493,7 +6329,0 @@\n-    StubRoutines::_atomic_xchg_entry          = generate_atomic_xchg();\n-    StubRoutines::_atomic_xchg_long_entry     = generate_atomic_xchg_long();\n-    StubRoutines::_atomic_cmpxchg_entry       = generate_atomic_cmpxchg();\n-    StubRoutines::_atomic_cmpxchg_byte_entry  = generate_atomic_cmpxchg_byte();\n-    StubRoutines::_atomic_cmpxchg_long_entry  = generate_atomic_cmpxchg_long();\n-    StubRoutines::_atomic_add_entry           = generate_atomic_add();\n-    StubRoutines::_atomic_add_long_entry      = generate_atomic_add_long();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":171,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -1222,2 +1222,2 @@\n-  HandleMark hm;\n-  ResourceMark rm;\n+  HandleMark hm(THREAD);\n+  ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -885,1 +885,0 @@\n-    HandleMark hm;\n@@ -955,1 +954,0 @@\n-    HandleMark hm;\n@@ -2432,0 +2430,1 @@\n+\n@@ -2442,0 +2441,2 @@\n+  HandleMark hm(Thread::current());\n+\n@@ -2581,1 +2582,0 @@\n-  HandleMark hm;\n@@ -2611,1 +2611,0 @@\n-  HandleMark hm;\n@@ -2637,1 +2636,0 @@\n-  HandleMark hm;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,1 +259,3 @@\n-  ResourceMark rm;\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -326,1 +326,0 @@\n-  HandleMark hm;\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -184,0 +184,2 @@\n+CompilerStatistics CompileBroker::_stats_per_level[CompLevel_full_optimization];\n+\n@@ -1602,0 +1604,1 @@\n+  assert(UseJVMCICompiler, \"sanity\");\n@@ -2461,0 +2464,1 @@\n+  const int comp_level = task->comp_level();\n@@ -2509,2 +2513,16 @@\n-#if INCLUDE_JVMCI\n-      AbstractCompiler* comp = compiler(task->comp_level());\n+      \/\/ Collect statistic per compilation level\n+      if (comp_level > CompLevel_none && comp_level <= CompLevel_full_optimization) {\n+        CompilerStatistics* stats = &_stats_per_level[comp_level-1];\n+        if (is_osr) {\n+          stats->_osr.update(time, bytes_compiled);\n+        } else {\n+          stats->_standard.update(time, bytes_compiled);\n+        }\n+        stats->_nmethods_size += code->total_size();\n+        stats->_nmethods_code_size += code->insts_size();\n+      } else {\n+        assert(false, \"CompilerStatistics object does not exist for compilation level %d\", comp_level);\n+      }\n+\n+      \/\/ Collect statistic per compiler\n+      AbstractCompiler* comp = compiler(comp_level);\n@@ -2513,10 +2531,4 @@\n-        if (stats) {\n-          if (is_osr) {\n-            stats->_osr.update(time, bytes_compiled);\n-          } else {\n-            stats->_standard.update(time, bytes_compiled);\n-          }\n-          stats->_nmethods_size += code->total_size();\n-          stats->_nmethods_code_size += code->insts_size();\n-        } else { \/\/ if (!stats)\n-          assert(false, \"Compiler statistics object must exist\");\n+        if (is_osr) {\n+          stats->_osr.update(time, bytes_compiled);\n+        } else {\n+          stats->_standard.update(time, bytes_compiled);\n@@ -2524,0 +2536,2 @@\n+        stats->_nmethods_size += code->total_size();\n+        stats->_nmethods_code_size += code->insts_size();\n@@ -2527,1 +2541,0 @@\n-#endif \/\/ INCLUDE_JVMCI\n@@ -2546,3 +2559,4 @@\n-      float bytes_per_sec = 1.0 * (method->code_size() + task->num_inlined_bytecodes()) \/ time.seconds();\n-      tty->print_cr(\"%3d   seconds: %f bytes\/sec : %f (bytes %d + %d inlined)\",\n-                    compile_id, time.seconds(), bytes_per_sec, method->code_size(), task->num_inlined_bytecodes());\n+      double compile_time = time.seconds();\n+      double bytes_per_sec = compile_time == 0.0 ? 0.0 : (double)(method->code_size() + task->num_inlined_bytecodes()) \/ compile_time;\n+      tty->print_cr(\"%3d   seconds: %6.3f bytes\/sec : %f (bytes %d + %d inlined)\",\n+                    compile_id, compile_time, bytes_per_sec, method->code_size(), task->num_inlined_bytecodes());\n@@ -2583,6 +2597,3 @@\n-#if INCLUDE_JVMCI\n-void CompileBroker::print_times(AbstractCompiler* comp) {\n-  CompilerStatistics* stats = comp->stats();\n-  if (stats) {\n-    tty->print_cr(\"  %s {speed: %d bytes\/s; standard: %6.3f s, %d bytes, %d methods; osr: %6.3f s, %d bytes, %d methods; nmethods_size: %d bytes; nmethods_code_size: %d bytes}\",\n-                comp->name(), stats->bytes_per_second(),\n+void CompileBroker::print_times(const char* name, CompilerStatistics* stats) {\n+  tty->print_cr(\"  %s {speed: %6.3f bytes\/s; standard: %6.3f s, %d bytes, %d methods; osr: %6.3f s, %d bytes, %d methods; nmethods_size: %d bytes; nmethods_code_size: %d bytes}\",\n+                name, stats->bytes_per_second(),\n@@ -2592,5 +2603,0 @@\n-  } else { \/\/ if (!stats)\n-    assert(false, \"Compiler statistics object must exist\");\n-  }\n-  comp->print_timers();\n-#endif \/\/ INCLUDE_JVMCI\n@@ -2600,46 +2606,11 @@\n-#if INCLUDE_JVMCI\n-  elapsedTimer standard_compilation;\n-  elapsedTimer total_compilation;\n-  elapsedTimer osr_compilation;\n-\n-  int standard_bytes_compiled = 0;\n-  int osr_bytes_compiled = 0;\n-\n-  int standard_compile_count = 0;\n-  int osr_compile_count = 0;\n-  int total_compile_count = 0;\n-\n-  int nmethods_size = 0;\n-  int nmethods_code_size = 0;\n-  bool printedHeader = false;\n-\n-  for (unsigned int i = 0; i < sizeof(_compilers) \/ sizeof(AbstractCompiler*); i++) {\n-    AbstractCompiler* comp = _compilers[i];\n-    if (comp != NULL) {\n-      if (per_compiler && aggregate && !printedHeader) {\n-        printedHeader = true;\n-        tty->cr();\n-        tty->print_cr(\"Individual compiler times (for compiled methods only)\");\n-        tty->print_cr(\"------------------------------------------------\");\n-        tty->cr();\n-      }\n-      CompilerStatistics* stats = comp->stats();\n-\n-      if (stats) {\n-        standard_compilation.add(stats->_standard._time);\n-        osr_compilation.add(stats->_osr._time);\n-\n-        standard_bytes_compiled += stats->_standard._bytes;\n-        osr_bytes_compiled += stats->_osr._bytes;\n-\n-        standard_compile_count += stats->_standard._count;\n-        osr_compile_count += stats->_osr._count;\n-\n-        nmethods_size += stats->_nmethods_size;\n-        nmethods_code_size += stats->_nmethods_code_size;\n-      } else { \/\/ if (!stats)\n-        assert(false, \"Compiler statistics object must exist\");\n-      }\n-\n-      if (per_compiler) {\n-        print_times(comp);\n+  if (per_compiler) {\n+    if (aggregate) {\n+      tty->cr();\n+      tty->print_cr(\"Individual compiler times (for compiled methods only)\");\n+      tty->print_cr(\"------------------------------------------------\");\n+      tty->cr();\n+    }\n+    for (unsigned int i = 0; i < sizeof(_compilers) \/ sizeof(AbstractCompiler*); i++) {\n+      AbstractCompiler* comp = _compilers[i];\n+      if (comp != NULL) {\n+        print_times(comp->name(), comp->stats());\n@@ -2648,0 +2619,12 @@\n+    if (aggregate) {\n+      tty->cr();\n+      tty->print_cr(\"Individual compilation Tier times (for compiled methods only)\");\n+      tty->print_cr(\"------------------------------------------------\");\n+      tty->cr();\n+    }\n+    char tier_name[256];\n+    for (int tier = CompLevel_simple; tier <= CompLevel_highest_tier; tier++) {\n+      CompilerStatistics* stats = &_stats_per_level[tier-1];\n+      sprintf(tier_name, \"Tier%d\", tier);\n+      print_times(tier_name, stats);\n+    }\n@@ -2649,3 +2632,1 @@\n-  total_compile_count = osr_compile_count + standard_compile_count;\n-  total_compilation.add(osr_compilation);\n-  total_compilation.add(standard_compilation);\n+#if INCLUDE_JVMCI\n@@ -2654,1 +2635,1 @@\n-  if (!UseJVMCICompiler) {\n+  if (EnableJVMCI && !UseJVMCICompiler) {\n@@ -2657,1 +2638,6 @@\n-#else \/\/ INCLUDE_JVMCI\n+#endif\n+\n+  if (!aggregate) {\n+    return;\n+  }\n+\n@@ -2668,0 +2654,2 @@\n+  int total_bailout_count = CompileBroker::_total_bailout_count;\n+  int total_invalidated_count = CompileBroker::_total_invalidated_count;\n@@ -2671,4 +2659,0 @@\n-#endif \/\/ INCLUDE_JVMCI\n-  if (!aggregate) {\n-    return;\n-  }\n@@ -2684,1 +2668,1 @@\n-                standard_compilation.seconds() \/ standard_compile_count);\n+                standard_compile_count == 0 ? 0.0 : standard_compilation.seconds() \/ standard_compile_count);\n@@ -2687,1 +2671,1 @@\n-                CompileBroker::_t_bailedout_compilation.seconds() \/ CompileBroker::_total_bailout_count);\n+                total_bailout_count == 0 ? 0.0 : CompileBroker::_t_bailedout_compilation.seconds() \/ total_bailout_count);\n@@ -2690,1 +2674,1 @@\n-                osr_compilation.seconds() \/ osr_compile_count);\n+                osr_compile_count == 0 ? 0.0 : osr_compilation.seconds() \/ osr_compile_count);\n@@ -2693,1 +2677,1 @@\n-                CompileBroker::_t_invalidated_compilation.seconds() \/ CompileBroker::_total_invalidated_count);\n+                total_invalidated_count == 0 ? 0.0 : CompileBroker::_t_invalidated_compilation.seconds() \/ total_invalidated_count);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":70,"deletions":86,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -1011,1 +1011,0 @@\n-    HandleMark hm;  \/\/ Discard invalid handles created during verification\n@@ -1792,1 +1791,0 @@\n-    HandleMark hm;\n@@ -1949,1 +1947,0 @@\n-    HandleMark hm;  \/\/ Discard invalid handles created during verification\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1352,2 +1352,0 @@\n-    ResetNoHandleMark rnm; \/\/ In a LEAF entry.\n-    HandleMark hm;\n@@ -1374,1 +1372,0 @@\n-  HandleMark hm(thread);\n@@ -1736,2 +1733,0 @@\n-  ResetNoHandleMark rnm; \/\/ In a LEAF entry.\n-  HandleMark hm;\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -324,1 +324,0 @@\n-  HandleMark hm;\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -791,1 +791,1 @@\n-  HandleMark hm;\n+  HandleMark hm(Thread::current());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-  ResourceMark rm;\n-  HandleMark hm;\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n@@ -147,0 +147,1 @@\n+  tty->print_cr(\"    JVMCI Compile Time:      %7.3f s\", stats()->total_time());\n@@ -152,2 +153,5 @@\n-  JVMCI_event_1(\"JVMCICompiler::print_timers\");\n-  tty->print_cr(\"       JVMCI code install time:        %6.3f s\",    _codeInstallTimer.seconds());\n+  double code_install_time = _codeInstallTimer.seconds();\n+  if (code_install_time != 0.0) {\n+    tty->cr();\n+    tty->print_cr(\"    JVMCI code install time:        %6.3f s\", code_install_time);\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -822,1 +822,1 @@\n-  HandleMark hm;\n+  HandleMark hm(THREAD);\n@@ -883,1 +883,1 @@\n-  HandleMark hm;\n+  HandleMark hm(THREAD);\n@@ -971,1 +971,1 @@\n-  HandleMark hm;\n+  HandleMark hm(THREAD);\n@@ -1009,1 +1009,1 @@\n-  HandleMark hm;\n+  HandleMark hm(THREAD);\n@@ -1021,1 +1021,1 @@\n-  HandleMark hm;\n+  HandleMark hm(THREAD);\n@@ -1160,1 +1160,1 @@\n-  HandleMark hm;\n+  HandleMark hm(THREAD);\n@@ -2249,1 +2249,1 @@\n-    HandleMark hm;\n+    HandleMark hm(THREAD);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -578,1 +578,0 @@\n-      HandleMark hm;\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -336,0 +336,1 @@\n+  HandleMark   hm(THREAD);\n@@ -1179,2 +1180,3 @@\n-  ResourceMark rm;\n-  HandleMark hm;  \/\/ Handles created during verification can be zapped\n+  Thread* thread = Thread::current();\n+  ResourceMark rm(thread);\n+  HandleMark hm(thread);  \/\/ Handles created during verification can be zapped\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1202,1 +1202,1 @@\n-  HandleMark hm;\n+  HandleMark hm(THREAD);\n@@ -1606,1 +1606,0 @@\n-  HandleMark hm;\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1618,0 +1618,3 @@\n+  bool is_sub = sub->Opcode() == Op_SubF || sub->Opcode() == Op_SubD ||\n+                sub->Opcode() == Op_SubI || sub->Opcode() == Op_SubL;\n+\n@@ -1619,4 +1622,3 @@\n-  if( tzero == TypeF::ZERO ) {\n-    if( sub->Opcode() != Op_SubF ||\n-        sub->in(2) != x ||\n-        phase->type(sub->in(1)) != tzero ) return NULL;\n+  if (!is_sub || phase->type(sub->in(1)) != tzero || sub->in(2) != x) return NULL;\n+\n+  if (tzero == TypeF::ZERO) {\n@@ -1628,3 +1630,0 @@\n-    if( sub->Opcode() != Op_SubD ||\n-        sub->in(2) != x ||\n-        phase->type(sub->in(1)) != tzero ) return NULL;\n@@ -1635,4 +1634,1 @@\n-  } else if (tzero == TypeInt::ZERO) {\n-    if (sub->Opcode() != Op_SubI ||\n-        sub->in(2) != x ||\n-        phase->type(sub->in(1)) != tzero) return NULL;\n+  } else if (tzero == TypeInt::ZERO && Matcher::match_rule_supported(Op_AbsI)) {\n@@ -1643,4 +1639,1 @@\n-  } else {\n-    if (sub->Opcode() != Op_SubL ||\n-        sub->in(2) != x ||\n-        phase->type(sub->in(1)) != tzero) return NULL;\n+  } else if (tzero == TypeLong::ZERO && Matcher::match_rule_supported(Op_AbsL)) {\n@@ -1651,1 +1644,1 @@\n-  }\n+  } else return NULL;\n@@ -2264,1 +2257,1 @@\n-        \/\/ (directly or through data nodes) - it is dead loop.\n+        \/\/ (directly or through data nodes) - it is a dead loop.\n@@ -2267,3 +2260,8 @@\n-          Node *n = in(j);\n-          if (n->is_MergeMem() && n->as_MergeMem()->base_memory() == this)\n-            continue;              \/\/ skip known cases\n+          Node* n = in(j);\n+          if (n->is_MergeMem()) {\n+            MergeMemNode* mm = n->as_MergeMem();\n+            if (mm->base_memory() == this || mm->base_memory() == mm->empty_memory()) {\n+              \/\/ Skip this input if it references back to this phi or if the memory path is dead\n+              continue;\n+            }\n+          }\n@@ -2275,2 +2273,4 @@\n-        if (!saw_safe_input)\n-          return top; \/\/ all inputs reference back to this phi - dead loop\n+        if (!saw_safe_input) {\n+          \/\/ There is a dead loop: All inputs are either dead or reference back to this phi\n+          return top;\n+        }\n@@ -2280,1 +2280,1 @@\n-        PhaseIterGVN *igvn = phase->is_IterGVN();\n+        PhaseIterGVN* igvn = phase->is_IterGVN();\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2835,2 +2835,8 @@\n-  func1 = eval_operand(n->in(1), eval_map);\n-  if (is_vector_binary_bitwise_op(n)) {\n+  if (is_vector_unary_bitwise_op(n)) {\n+    Node* opnd = n->in(1);\n+    if (VectorNode::is_vector_bitwise_not_pattern(n) && VectorNode::is_all_ones_vector(opnd)) {\n+      opnd = n->in(2);\n+    }\n+    func1 = eval_operand(opnd, eval_map);\n+  } else if (is_vector_binary_bitwise_op(n)) {\n+    func1 = eval_operand(n->in(1), eval_map);\n@@ -2839,1 +2845,3 @@\n-  } else if (is_vector_ternary_bitwise_op(n)) {\n+  } else {\n+    assert(is_vector_ternary_bitwise_op(n), \"unknown operation\");\n+    func1 = eval_operand(n->in(1), eval_map);\n@@ -2842,2 +2850,0 @@\n-  } else {\n-    assert(is_vector_unary_bitwise_op(n), \"not unary\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -996,0 +996,2 @@\n+    Node* hook = new Node(1);\n+    hook->init_req(0, lo); \/\/ Add a use to lo to prevent him from dying\n@@ -1001,0 +1003,2 @@\n+    hook->del_req(0); \/\/ Just yank bogus edge\n+    hook->destruct();\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3257,1 +3257,1 @@\n-        _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);\n+        _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(bt);\n@@ -3265,1 +3265,1 @@\n-      } else { \/\/ exclude unsafe ops\n+      } else {\n@@ -3282,0 +3282,1 @@\n+           _is_ptr_to_narrowoop = UseCompressedOops;\n@@ -3284,2 +3285,7 @@\n-            assert(field != NULL, \"missing field\");\n-            basic_elem_type = field->layout_type();\n+            if (field != NULL) {\n+              BasicType basic_elem_type = field->layout_type();\n+              _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            } else {\n+              \/\/ unsafe access\n+              _is_ptr_to_narrowoop = UseCompressedOops;\n+            }\n@@ -3287,1 +3293,0 @@\n-          _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4197,1 +4197,1 @@\n-            HandleMark hm;\n+            HandleMark hm(THREAD);\n@@ -4231,1 +4231,1 @@\n-        HandleMark hm;\n+        HandleMark hm(THREAD);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -542,1 +542,9 @@\n-\n+JVM_ENTRY_NO_ENV(jboolean, JVM_IsUseContainerSupport(void))\n+  JVMWrapper(\"JVM_IsUseContainerSupport\");\n+#ifdef LINUX\n+  if (UseContainerSupport) {\n+    return JNI_TRUE;\n+  }\n+#endif\n+  return JNI_FALSE;\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -663,1 +663,1 @@\n-    HandleMark hm;\n+    HandleMark hm(thread);\n@@ -700,1 +700,2 @@\n-    HandleMark hm;\n+    Thread* THREAD = Thread::current();\n+    HandleMark hm(THREAD);\n@@ -711,2 +712,0 @@\n-    Thread* THREAD = Thread::current();\n-\n@@ -918,2 +917,3 @@\n-  ResourceMark rm;\n-  HandleMark hm;\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n@@ -922,1 +922,1 @@\n-  ThreadsListEnumerator tle(Thread::current(), true);\n+  ThreadsListEnumerator tle(current_thread, true);\n@@ -1128,3 +1128,3 @@\n-  ResourceMark rm;\n-  HandleMark hm;\n-\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n@@ -1403,4 +1403,3 @@\n-  ResourceMark rm;\n-  HandleMark hm;\n-\n-  JavaThread* current_thread = JavaThread::current();\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n@@ -3186,1 +3185,0 @@\n-  HandleMark hm;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -625,2 +625,3 @@\n-  ResourceMark rm;\n-  HandleMark   hm;\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark   hm(current_thread);\n@@ -678,1 +679,1 @@\n-    HandleMark hm;\n+    HandleMark hm(current_jt);\n@@ -696,2 +697,2 @@\n-    ResourceMark rm;\n-    HandleMark   hm;\n+    ResourceMark rm(current_jt);\n+    HandleMark   hm(current_jt);\n@@ -726,2 +727,3 @@\n-  ResourceMark rm;\n-  HandleMark hm;\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark   hm(current_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -700,1 +700,2 @@\n-    HandleMark hm;\n+    Thread* current_thread = Thread::current();\n+    HandleMark hm(current_thread);\n@@ -709,1 +710,1 @@\n-        Handle ob_h(Thread::current(), JNIHandles::resolve_external_guard(_value.l));\n+        Handle ob_h(current_thread, JNIHandles::resolve_external_guard(_value.l));\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2128,1 +2128,1 @@\n-    TraceSelfClosure() : HandshakeClosure(\"WB_TraceSelf\"), _num_threads_completed(0) {}\n+    TraceSelfClosure(Thread* thread) : HandshakeClosure(\"WB_TraceSelf\"), _num_threads_completed(0) {}\n@@ -2132,1 +2132,1 @@\n-  TraceSelfClosure tsc;\n+  TraceSelfClosure tsc(Thread::current());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -244,1 +244,2 @@\n-  HandleMark hm;\n+  assert(thread == Thread::current(), \"should be\");\n+  HandleMark hm(thread);\n@@ -664,1 +665,1 @@\n-  HandleMark hm;\n+  HandleMark hm(thread);\n@@ -1624,2 +1625,3 @@\n-  ResourceMark rm;\n-  HandleMark hm;\n+  assert(thread == Thread::current(), \"should be\");\n+  ResourceMark rm(thread);\n+  HandleMark hm(thread);\n@@ -1857,1 +1859,1 @@\n-  HandleMark hm;\n+  HandleMark hm(thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  _thread = thread;\n+  _thread = thread;  \/\/ Not the current thread during thread creation.\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-\/\/     HandleMark hm;\n+\/\/     HandleMark hm(THREAD);\n@@ -262,1 +262,0 @@\n-  HandleMark();                            \/\/ see handles_inline.hpp\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,4 +71,0 @@\n-inline HandleMark::HandleMark() {\n-  initialize(Thread::current());\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-  HandleMark hm;\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3274,2 +3274,4 @@\n-  ResourceMark rm;\n-  HandleMark   hm;\n+\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n@@ -3404,2 +3406,3 @@\n-  ResourceMark rm;\n-  HandleMark   hm;\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n@@ -3928,2 +3931,0 @@\n-  HandleMark hm;\n-\n@@ -3976,0 +3977,1 @@\n+  HandleMark hm(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -833,1 +833,0 @@\n-  HandleMark hm;\n@@ -846,1 +845,0 @@\n-  HandleMark hm;\n@@ -889,1 +887,0 @@\n-  HandleMark hm;\n@@ -933,1 +930,0 @@\n-  HandleMark hm;\n@@ -946,1 +942,0 @@\n-  HandleMark hm;\n@@ -958,1 +953,0 @@\n-  HandleMark hm;\n@@ -1780,1 +1774,0 @@\n-  HandleMark hm;\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -673,1 +673,4 @@\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_FINAL,\n+            int accessFlags = ACC_PUBLIC | ACC_FINAL;\n+            if (method.isVarArgs()) accessFlags |= ACC_VARARGS;\n+\n+            MethodVisitor mv = cw.visitMethod(accessFlags,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-        StaticLocalFlags      = LocalClassFlags | STATIC | INTERFACE | ANNOTATION,\n+        StaticLocalFlags      = LocalClassFlags | STATIC | INTERFACE,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1392,1 +1392,1 @@\n-                mask = staticOrImplicitlyStatic && allowRecords ? StaticLocalFlags : LocalClassFlags;\n+                mask = staticOrImplicitlyStatic && allowRecords && (flags & ANNOTATION) == 0 ? StaticLocalFlags : LocalClassFlags;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3508,1 +3508,1 @@\n-        return variableDeclaratorId(mods, type, false);\n+        return variableDeclaratorId(mods, type, false, false);\n@@ -3511,1 +3511,1 @@\n-    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {\n+    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {\n@@ -3556,0 +3556,3 @@\n+        if (recordComponent && token.kind == LBRACKET) {\n+            log.error(token.pos, Errors.RecordComponentAndOldArraySyntax);\n+        }\n@@ -4701,1 +4704,1 @@\n-        return variableDeclaratorId(mods, type, lambdaParameter);\n+        return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);\n@@ -4706,1 +4709,1 @@\n-        return variableDeclaratorId(mods, null, true);\n+        return variableDeclaratorId(mods, null, true, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3518,0 +3518,3 @@\n+compiler.err.record.component.and.old.array.syntax=\\\n+    legacy array notation not allowed on record components\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -157,1 +157,7 @@\n-        JCTree body = copy(t.body, p);\n+        JCTree body;\n+        if (node.getCaseKind() == CaseTree.CaseKind.RULE) {\n+            body = t.body instanceof JCExpression && t.stats.head.hasTag(Tag.YIELD)\n+                    ? ((JCYield) t.stats.head).value : t.stats.head;\n+        } else {\n+            body = null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -165,0 +165,1 @@\n+containers\/docker\/TestMemoryAwareness.java 8250984 linux-5.4.0-1019-oracle\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}