{"files":[{"patch":"@@ -138,1 +138,1 @@\n-         * of fields that are not of its own type.  If true, then compares the\n+         * of fields whose type is not recursively-typed.  If true, then compares the\n@@ -146,3 +146,3 @@\n-         * @param mh    a MethodHandle that tests substitutability of all fields that are\n-         *              not of its own type.  The method type is (V, V)boolean\n-         * @param getters all getters for the fields that are of the same value class\n+         * @param mh    a MethodHandle that tests substitutability of all fields whose type\n+         *              is not recursively-typed.  The method type is (V, V)boolean\n+         * @param getters all getters for the fields whose type is a recursive data type\n@@ -150,2 +150,2 @@\n-         *              to test if two objects of the given value class are substitutable\n-         *              The method type is (Object,Object)boolean.\n+         *              to test if two objects of the given value class are substitutable.\n+         *              The method type is (Object, Object, AtomicInteger)boolean.\n@@ -158,3 +158,3 @@\n-        private static <V> boolean base(Class<V> type, MethodHandle mh, MethodHandle[] getters,\n-                                        MethodHandle recur, Object o1, Object o2,\n-                                        AtomicInteger counter) throws Throwable {\n+        private static <V> boolean substitutableBase(Class<V> type, MethodHandle mh, MethodHandle[] getters,\n+                                                     MethodHandle recur, Object o1, Object o2,\n+                                                     AtomicInteger counter) throws Throwable {\n@@ -170,2 +170,2 @@\n-            \/\/ test if all fields that are not of the same value type are substitutable\n-            boolean result = (boolean) mh.invoke(o1, o2);\n+            \/\/ test if the substitutability of all fields whose type is not recursively-typed\n+            var result = (boolean) mh.invoke(o1, o2);\n@@ -178,2 +178,2 @@\n-                    Object f1 = getter.invoke(o1);\n-                    Object f2 = getter.invoke(o2);\n+                    var f1 = getter.invoke(o1);\n+                    var f2 = getter.invoke(o2);\n@@ -185,1 +185,1 @@\n-                        MethodHandle recur2 = RECUR_METHOD_HANDLES.get(ftype);\n+                        MethodHandle recur2 = RECUR_SUBST_METHOD_HANDLES.get(ftype);\n@@ -196,0 +196,59 @@\n+\n+        \/**\n+         * A base method for computing the hashcode for a recursive data type,\n+         * a value class with cyclic membership.\n+         *\n+         * This method will first invoke a method handle to compute the hash code\n+         * of the fields whose type is not recursively-typed.  Then compute the\n+         * hash code of the remaining fields whose type is a recursive data type.\n+         * For a field of its own type {@code f}, invoke the method handle for\n+         * this base method on the field value of the given object.\n+         * For a field of other recursive data type, invoke {@link Object#hashCode()}\n+         * on the field value of the given object.\n+         *\n+         * @param type  a value class\n+         * @param mh    a MethodHandle that computes the hash code of all fields whose\n+         *              type is not recursively-typed.  The method type is (V)int\n+         * @param getters all getters for the fields whose type is a recursive data type\n+         * @param recur MethodHandle that is capable of recursively calling itself\n+         *              to compute the hash code of a field of the same type.\n+         *              The method type is (Object, AtomicInteger)int.\n+         * @param obj   an object\n+         * @param counter an AtomicInteger counter to keep track of the traversal count\n+         * @return the hash code of a value object of the given type\n+         * @param <V>   a value class\n+         *\/\n+        private static <V> int hashCodeBase(Class<V> type, MethodHandle mh, MethodHandle[] getters,\n+                                            MethodHandle recur, Object obj,\n+                                            AtomicInteger counter) throws Throwable {\n+            assert isValueClass(type) : type.getName() + \" not a value class\";\n+\n+            if (obj == null) return 0;\n+\n+            if (counter.getAndDecrement() == 0) {\n+                throw new StackOverflowError(\"fail to evaluate hashCode of a value object: \" + type.getName());\n+            }\n+\n+            \/\/ compute the hash code of all fields whose type is not recursively-typed\n+            var result = (int) mh.invoke(obj);\n+            if (obj != null) {\n+                assert obj.getClass() == type;\n+\n+                \/\/ test if the fields of a recursive data type are substitutable\n+                for (MethodHandle getter : getters) {\n+                    Class<?> ftype = fieldType(getter);\n+                    var f = getter.invoke(obj);\n+\n+                    int hc;\n+                    if (ftype == type) {\n+                        hc = (int)recur.invokeExact(f, counter);\n+                    } else {\n+                        MethodHandle recur2 = RECUR_HASHCODE_METHOD_HANDLES.get(ftype);\n+                        hc = (int)recur2.invokeExact(f, counter);\n+                    }\n+                    result = hashCombiner(result, hc);\n+                }\n+            }\n+            return result;\n+        }\n+\n@@ -263,2 +322,8 @@\n-        private static final ConcurrentHashMap<Class<?>, Boolean> inProgress = new ConcurrentHashMap<>();\n-        private static final ClassValue<MethodHandle> RECUR_METHOD_HANDLES = new ClassValue<>() {\n+        private static final ClassValue<MethodHandle> RECUR_SUBST_METHOD_HANDLES = new ClassValue<>() {\n+            \/*\n+             * Produces a MethodHandle that returns boolean if two value objects of\n+             * a recursive data type are substitutable.  This method is invoked by\n+             * the substitutableBase method.\n+             *\n+             * The method type is (Object, Object, AtomicInteger)boolean.\n+             *\/\n@@ -266,1 +331,1 @@\n-                return MethodHandleBuilder.recurValueTypeEquals(type);\n+                return recurValueTypeEquals(type, recursiveValueTypes(type));\n@@ -278,15 +343,7 @@\n-            try {\n-                if (inProgress.putIfAbsent(type, true) != null) {\n-                    throw new StackOverflowError(\"cyclic class membership: \" + type.getName());\n-                }\n-\n-                Set<Class<?>> recursiveTypes = recursiveValueTypes(type);\n-                if (recursiveTypes.isEmpty()) {\n-                    return valueTypeEquals(type, getters(type, TYPE_SORTER));\n-                } else {\n-                    MethodHandle target = recurValueTypeEquals(type, recursiveValueTypes(type));\n-                    return MethodHandles.insertArguments(target, 2, new AtomicInteger(THRESHOLD))\n-                                        .asType(methodType(boolean.class, type, type));\n-                }\n-            } finally {\n-                inProgress.remove(type);\n+            Set<Class<?>> recursiveTypes = recursiveValueTypes(type);\n+            if (recursiveTypes.isEmpty()) {\n+                return valueTypeEquals(type, getters(type, TYPE_SORTER));\n+            } else {\n+                MethodHandle target = recurValueTypeEquals(type, recursiveTypes);\n+                return MethodHandles.insertArguments(target, 2, new AtomicInteger(THRESHOLD))\n+                                    .asType(methodType(boolean.class, type, type));\n@@ -305,34 +362,8 @@\n-                MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);\n-                MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);\n-                MethodHandle accumulator = dropArguments(TRUE, 0, type, type);\n-                for (MethodHandle getter : getters) {\n-                    Class<?> ftype = fieldType(getter);\n-                    MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n-                    MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n-                    accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n-                }\n-\n-                \/\/ if both arguments are null, return true;\n-                \/\/ otherwise return accumulator;\n-                return guardWithTest(IS_NULL.asType(mt),\n-                                     instanceTrue,\n-                                     guardWithTest(IS_SAME_VALUE_CLASS.asType(mt),\n-                                                   accumulator,\n-                                                   instanceFalse));\n-        }\n-\n-        \/*\n-         * Produces a MethodHandle that returns boolean if two value objects of\n-         * a recursive data type are substitutable.  This method is invoked by\n-         * the base method.\n-         *\n-         * The method type is (Object, Object, AtomicInteger)boolean.\n-         *\/\n-        static MethodHandle recurValueTypeEquals(Class<?> type) {\n-            try {\n-                if (inProgress.putIfAbsent(type, true) != null) {\n-                    throw new StackOverflowError(\"cyclic class membership: \" + type.getName());\n-                }\n-                return recurValueTypeEquals(type, recursiveValueTypes(type));\n-            } finally {\n-                inProgress.remove(type);\n+            MethodHandle instanceTrue = dropArguments(TRUE, 0, type, Object.class).asType(mt);\n+            MethodHandle instanceFalse = dropArguments(FALSE, 0, type, Object.class).asType(mt);\n+            MethodHandle accumulator = dropArguments(TRUE, 0, type, type);\n+            for (MethodHandle getter : getters) {\n+                Class<?> ftype = fieldType(getter);\n+                MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n+                MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n+                accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n@@ -340,0 +371,8 @@\n+\n+            \/\/ if both arguments are null, return true;\n+            \/\/ otherwise return accumulator;\n+            return guardWithTest(IS_NULL.asType(mt),\n+                                 instanceTrue,\n+                                 guardWithTest(IS_SAME_VALUE_CLASS.asType(mt),\n+                                               accumulator,\n+                                               instanceFalse));\n@@ -369,2 +408,2 @@\n-            \/\/ - the base method first calls the method handle that tests the substitutability of\n-            \/\/   all fields that are not a recursive data type\n+            \/\/ - the substitutableBase method first calls the method handle that tests\n+            \/\/   the substitutability of all fields that are not a recursive data type\n@@ -378,0 +417,12 @@\n+        private static final ClassValue<MethodHandle> RECUR_HASHCODE_METHOD_HANDLES = new ClassValue<>() {\n+            \/*\n+             * Produces a MethodHandle that returns the hashcode of a value object of\n+             * a recursive data type.  This method is invoked by the hashCodeBase method.\n+             *\n+             * The method type is (Object, AtomicInteger)int.\n+             *\/\n+            @Override protected MethodHandle computeValue(Class<?> type) {\n+                return recurValueTypeHashCode(type, recursiveValueTypes(type));\n+            }\n+        };\n+\n@@ -379,1 +430,2 @@\n-         * Produces a MethodHandle that computes the hash code for a value object.\n+         * Produces a MethodHandle that computes the hash code of a value object.\n+         * The method type of the return MethodHandle is (V)int.\n@@ -385,0 +437,18 @@\n+            Set<Class<?>> recursiveTypes = recursiveValueTypes(type);\n+            if (recursiveTypes.isEmpty()) {\n+                return valueTypeHashCode(type, getterStream(type, null).toList());\n+            } else {\n+                MethodHandle target = recurValueTypeHashCode(type, recursiveTypes);\n+                return MethodHandles.insertArguments(target, 1, new AtomicInteger(THRESHOLD))\n+                                    .asType(methodType(int.class, type));\n+            }\n+        }\n+\n+        \/*\n+         * Produces a MethodHandle that returns the hash code computed from\n+         * the given fields of a value object. The method type is (V)int.\n+         *\/\n+        static MethodHandle valueTypeHashCode(Class<?> type, List<MethodHandle> getters) {\n+            \/\/ ensure the reference type of a primitive class not used in the method handle\n+            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n+\n@@ -391,5 +461,5 @@\n-            MethodHandle[] getters = getterStream(type, null).toArray(MethodHandle[]::new);\n-            MethodHandle iterations = dropArguments(constant(int.class, getters.length), 0, type);\n-            MethodHandle[] hashers = new MethodHandle[getters.length];\n-            for (int i=0; i < getters.length; i++) {\n-                MethodHandle getter = getters[i];\n+            int length = getters.size();\n+            MethodHandle iterations = dropArguments(constant(int.class, length), 0, type);\n+            MethodHandle[] hashers = new MethodHandle[length];\n+            for (int i=0; i < length; i++) {\n+                MethodHandle getter = getters.get(i);\n@@ -413,0 +483,38 @@\n+        \/*\n+         * Produces a MethodHandle that returns the hashcode of a value object of\n+         * a recursive data type.  This method is invoked by the hashCodeBase method.\n+         *\n+         * The method type is (Object, AtomicInteger)int.\n+         *\/\n+        static MethodHandle recurValueTypeHashCode(Class<?> type, Set<Class<?>> recursiveTypes) {\n+            Stream<MethodHandle> getterStream = getterStream(type, null);;\n+            List<MethodHandle> nonRecurTypeGetters = new ArrayList<>();\n+            List<MethodHandle> recurTypeGetters = new ArrayList<>();\n+            getterStream.forEach(getter -> {\n+                Class<?> ftype = fieldType(getter);\n+                if (recursiveTypes.contains(ftype)) {\n+                    \/\/ skip the value class that is involved in a cyclic membership\n+                    recurTypeGetters.add(getter);\n+                } else {\n+                    nonRecurTypeGetters.add(getter);\n+                }\n+            });\n+\n+            if (recurTypeGetters.isEmpty()) {\n+                throw new InternalError(\"must be a recursive data type: \" + type.getName());\n+            }\n+\n+            MethodHandle target = valueTypeHashCode(type, nonRecurTypeGetters);\n+            System.out.println(type.getName() + \" valueHashCode \" + nonRecurTypeGetters + \" \" + recurTypeGetters);\n+\n+            \/\/ This value class contains cyclic membership\n+            \/\/ Create a method handle that is capable of calling itself.\n+            \/\/ - the hashCodeBase method first calls the method handle that computes the hash code\n+            \/\/   of all fields whose type is not recursively-typed\n+            \/\/ - for a field of its own type, call the recursive method\n+            \/\/ - for a field of a recursive data type, call valueObjectHashCode\n+            Object[] arguments = new Object[]{type, target, recurTypeGetters.toArray(MethodHandle[]::new)};\n+            target = MethodHandles.insertArguments(RECUR_HASHCODE, 0, arguments);\n+            return recursive(target);\n+        }\n+\n@@ -487,1 +595,0 @@\n-\n@@ -489,2 +596,7 @@\n-                findStatic(\"base\", methodType(boolean.class, Class.class, MethodHandle.class, MethodHandle[].class,\n-                                                MethodHandle.class, Object.class, Object.class, AtomicInteger.class));\n+            findStatic(\"substitutableBase\",\n+                       methodType(boolean.class, Class.class, MethodHandle.class, MethodHandle[].class,\n+                                  MethodHandle.class, Object.class, Object.class, AtomicInteger.class));\n+        private static final MethodHandle RECUR_HASHCODE =\n+            findStatic(\"hashCodeBase\",\n+                       methodType(int.class, Class.class, MethodHandle.class, MethodHandle[].class,\n+                                  MethodHandle.class, Object.class, AtomicInteger.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":189,"deletions":77,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -183,0 +183,55 @@\n+    static Stream<Arguments> hashCodeProvider() {\n+        var n1 = Node.default;\n+        var n2 = new Node(n1, null);\n+        var n3 = new Node(n2, n1);\n+        var p1 = new P(n3);\n+\n+        var e1 = new E(F.default);\n+        var f1 = new F(e1);\n+        var e2 = new E(f1);\n+        var f2 = new F(e2);\n+\n+        var a = new A(B.default, E.default);\n+\n+        var d1 = new D(1);\n+        var d2 = new D(2);\n+        var c1 = new C(a);\n+\n+        var b1 = new B(c1, d1);\n+        var b2 = new B(c1, d2);\n+        var a1 = new A(b1, e1);\n+        var a2 = new A(b2, e2);\n+\n+        return Stream.of(\n+                \/\/ Node -> Node left & right\n+                Arguments.of(n1),\n+                Arguments.of(n2),\n+                Arguments.of(n3),\n+\n+\n+                \/\/ primitive class P -> value class V -> P.ref\n+                Arguments.of(p1),\n+\n+                \/\/ E -> F -> E\n+                Arguments.of(e1),\n+                Arguments.of(e2),\n+                Arguments.of(f1),\n+                Arguments.of(f2),\n+\n+                \/\/ two cyclic memberships from A\n+                \/\/ A -> B -> C -> A and E -> F -> E\n+                Arguments.of(a1),\n+                Arguments.of(a2),\n+                Arguments.of(b1),\n+                Arguments.of(b2),\n+                Arguments.of(c1)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"hashCodeProvider\")\n+    public void testHashCode(Object o) {\n+        int hc = o.hashCode();\n+        assertEquals(System.identityHashCode(o), hc, o.toString());\n+    }\n+\n@@ -214,0 +269,1 @@\n+        assertThrows(StackOverflowError.class, () -> { int hc = node.hashCode(); });\n","filename":"test\/jdk\/valhalla\/valuetypes\/RecursiveValueClass.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"}]}