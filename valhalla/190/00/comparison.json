{"files":[{"patch":"@@ -63,1 +63,0 @@\n-  *((Klass**)adr_flat_array_klass()) = NULL;\n@@ -214,1 +213,0 @@\n-  *((Klass**)adr_flat_array_klass()) = NULL;\n@@ -221,1 +219,0 @@\n-\n@@ -223,14 +220,2 @@\n-  if (flatten_array()) {\n-    return flat_array_klass(or_null, n, THREAD);\n-  } else {\n-    return InstanceKlass::array_klass_impl(or_null, n, THREAD);\n-  }\n-}\n-\n-Klass* InlineKlass::array_klass_impl(bool or_null, TRAPS) {\n-  return array_klass_impl(or_null, 1, THREAD);\n-}\n-\n-Klass* InlineKlass::flat_array_klass(bool or_null, int rank, TRAPS) {\n-  Klass* vak = acquire_flat_array_klass();\n-  if (vak == NULL) {\n+  \/\/ Need load-acquire for lock-free read\n+  if (array_klasses_acquire() == NULL) {\n@@ -238,1 +223,3 @@\n-    ResourceMark rm;\n+\n+    ResourceMark rm(THREAD);\n+    JavaThread *jt = (JavaThread *)THREAD;\n@@ -242,3 +229,11 @@\n-      if (get_flat_array_klass() == NULL) {\n-        vak = allocate_flat_array_klass(CHECK_NULL);\n-        Atomic::release_store((Klass**)adr_flat_array_klass(), vak);\n+\n+      ArrayKlass* k = NULL;\n+      \/\/ Check if update has already taken place\n+      if (array_klasses() == NULL) {\n+        if (flatten_array()) {\n+          k = FlatArrayKlass::allocate_klass(this, CHECK_NULL);\n+        } else {\n+          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+        }\n+        \/\/ use 'release' to pair with lock-free load\n+        release_set_array_klasses(k);\n@@ -248,0 +243,2 @@\n+  \/\/ _this will always be set at this point\n+  ArrayKlass* ak = array_klasses();\n@@ -249,8 +246,1 @@\n-    return vak->array_klass_or_null(rank);\n-  }\n-  return vak->array_klass(rank, THREAD);\n-}\n-\n-Klass* InlineKlass::allocate_flat_array_klass(TRAPS) {\n-  if (flatten_array()) {\n-    return FlatArrayKlass::allocate_klass(this, THREAD);\n+    return ak->array_klass_or_null(n);\n@@ -258,1 +248,1 @@\n-  return ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, THREAD);\n+  return ak->array_klass(n, THREAD);\n@@ -261,10 +251,2 @@\n-void InlineKlass::array_klasses_do(void f(Klass* k, TRAPS), TRAPS) {\n-  InstanceKlass::array_klasses_do(f, THREAD);\n-  if (get_flat_array_klass() != NULL)\n-    ArrayKlass::cast(get_flat_array_klass())->array_klasses_do(f, THREAD);\n-}\n-\n-void InlineKlass::array_klasses_do(void f(Klass* k)) {\n-  InstanceKlass::array_klasses_do(f);\n-  if (get_flat_array_klass() != NULL)\n-    ArrayKlass::cast(get_flat_array_klass())->array_klasses_do(f);\n+Klass* InlineKlass::array_klass_impl(bool or_null, TRAPS) {\n+  return array_klass_impl(or_null, 1, THREAD);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":22,"deletions":40,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -103,15 +103,0 @@\n-  address adr_flat_array_klass() const {\n-    assert(_adr_inlineklass_fixed_block != NULL, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _flat_array_klass));\n-  }\n-\n-  Klass* get_flat_array_klass() const {\n-    return *(Klass**)adr_flat_array_klass();\n-  }\n-\n-  Klass* acquire_flat_array_klass() const {\n-    return Atomic::load_acquire((Klass**)adr_flat_array_klass());\n-  }\n-\n-  Klass* allocate_flat_array_klass(TRAPS);\n-\n@@ -179,3 +164,0 @@\n-  \/\/ Specifically flat array klass\n-  Klass* flat_array_klass(bool or_null, int rank, TRAPS);\n-\n@@ -195,4 +177,0 @@\n-  \/\/ Metadata iterators\n-  void array_klasses_do(void f(Klass* k));\n-  void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);\n-\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1595,1 +1595,1 @@\n-  ObjArrayKlass* oak = array_klasses();\n+  ArrayKlass* oak = array_klasses();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-  Klass** _flat_array_klass;\n@@ -195,1 +194,1 @@\n-  ObjArrayKlass* volatile _array_klasses;\n+  ArrayKlass* volatile _array_klasses;\n@@ -497,4 +496,4 @@\n-  ObjArrayKlass* array_klasses() const     { return _array_klasses; }\n-  inline ObjArrayKlass* array_klasses_acquire() const; \/\/ load with acquire semantics\n-  void set_array_klasses(ObjArrayKlass* k) { _array_klasses = k; }\n-  inline void release_set_array_klasses(ObjArrayKlass* k); \/\/ store with release semantics\n+  ArrayKlass* array_klasses() const     { return _array_klasses; }\n+  inline ArrayKlass* array_klasses_acquire() const; \/\/ load with acquire semantics\n+  void set_array_klasses(ArrayKlass* k) { _array_klasses = k; }\n+  inline void release_set_array_klasses(ArrayKlass* k); \/\/ store with release semantics\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-inline ObjArrayKlass* InstanceKlass::array_klasses_acquire() const {\n+inline ArrayKlass* InstanceKlass::array_klasses_acquire() const {\n@@ -42,1 +42,1 @@\n-inline void InstanceKlass::release_set_array_klasses(ObjArrayKlass* k) {\n+inline void InstanceKlass::release_set_array_klasses(ArrayKlass* k) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ObjArrayKlass*)                        \\\n+  volatile_nonstatic_field(InstanceKlass,      _array_klasses,                                ArrayKlass*)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}