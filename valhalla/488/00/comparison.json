{"files":[{"patch":"@@ -573,0 +573,2 @@\n+     * @see #asPrimaryType()\n+     * @see #asValueType()\n@@ -583,2 +585,2 @@\n-     * If this {@code Class} object represents a reference type, then\n-     * this method returns this class.\n+     * If this {@code Class} object represents a primitive type or an array type,\n+     * then this method returns this class.\n@@ -590,1 +592,2 @@\n-     * If this is a primitive type, then this method returns this class.\n+     * Otherwise, this {@code Class} object represents a non-primitive class or interface\n+     * and this method returns this class.\n@@ -604,2 +607,5 @@\n-     * @return the {@code Class} representing the primitive value type of\n-     *         this class if this class is a primitive class\n+     * @apiNote Alternatively, this method returns null if this class is not\n+     *          a primitive class rather than throwing UOE.\n+     *\n+     * @return the {@code Class} representing the {@linkplain #isValueType()\n+     * primitive value type} of this class if this class is a primitive class\n@@ -621,4 +627,2 @@\n-     * If this is a primitive type, then this method returns {@code true}.\n-     * <p>\n-     * If this {@code Class} object represents a reference type, then\n-     * this method returns {@code true}.\n+     * If this {@code Class} object represents a primitive type or an array type,\n+     * then this method returns {@code true}.\n@@ -627,2 +631,6 @@\n-     * primitive} reference type, then this method returns {@code true};\n-     * otherwise, this method returns {@code false}.\n+     * primitive}, then this method returns {@code true} if this {@code Class}\n+     * object represents a primitive reference type, or returns {@code false}\n+     * if this {@code Class} object represents a primitive value type.\n+     * <p>\n+     * If this {@code Class} object represents a non-primitive class or interface,\n+     * then this method returns {@code true}.\n@@ -3999,1 +4007,1 @@\n-     * @throws NullPointerException if this is an {@linkplain #isValueType()\n+     * @throws NullPointerException if this class is an {@linkplain #isValueType()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-                ReferenceClassDescImpl {\n+                ClassDescImpl {\n@@ -68,1 +68,2 @@\n-     * {@link ConstantDescs}).\n+     * {@link ConstantDescs}; to create a descriptor for a primitive value type,\n+     * use {@link #ofDescriptor(String)}).\n@@ -113,1 +114,2 @@\n-     * ({@code \"J\", \"I\", \"C\", \"S\", \"B\", \"D\", \"F\", \"Z\", \"V\"}), or the letter {@code \"L\"}, followed\n+     * ({@code \"J\", \"I\", \"C\", \"S\", \"B\", \"D\", \"F\", \"Z\", \"V\"}),\n+     * or the letter {@code \"L\"} or {@code \"Q\"} followed\n@@ -117,2 +119,3 @@\n-     * valid type descriptor strings include {@code \"Ljava\/lang\/String;\"}, {@code \"I\"},\n-     * {@code \"[I\"}, {@code \"V\"}, {@code \"[Ljava\/lang\/String;\"}, etc.\n+     * valid type descriptor strings include {@code \"Ljava\/lang\/String;\"},\n+     * {@code \"QPoint;}, {@code \"I\"}, {@code \"[I\"}, {@code \"V\"},\n+     * {@code \"[Ljava\/lang\/String;\"}, {@code \"[LPoint;\"}, {@code \"[[QPoint;} etc.\n@@ -143,1 +146,1 @@\n-               : new ReferenceClassDescImpl(descriptor);\n+               : new ClassDescImpl(descriptor);\n@@ -255,1 +258,12 @@\n-        return descriptorString().startsWith(\"L\");\n+        return descriptorString().startsWith(\"L\") || descriptorString().startsWith(\"Q\");\n+    }\n+\n+    \/**\n+     * Returns whether this {@linkplain ClassDesc} describes a\n+     * {@linkplain Class#isValueType() primitive value type}.\n+     *\n+     * @return whether this {@linkplain ClassDesc} describes a primitive value type.\n+     * @since Valhalla\n+     *\/\n+    default boolean isValueType() {\n+        return descriptorString().startsWith(\"Q\");\n@@ -300,1 +314,2 @@\n-                                                descriptorString().length() - 1);\n+                                                descriptorString().length() - 1) +\n+                   (isValueType() ? \"\" : \".ref\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.constant;\n+\n+import sun.invoke.util.Wrapper;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static java.lang.constant.ConstantUtils.dropFirstAndLastChar;\n+import static java.lang.constant.ConstantUtils.internalToBinary;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n+ * interface, or array type.  A {@linkplain ClassDescImpl} corresponds to a\n+ * {@code Constant_Class_info} entry in the constant pool of a classfile.\n+ *\/\n+final class ClassDescImpl implements ClassDesc {\n+    private final String descriptor;\n+    private final boolean isValue;\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n+     * interface type\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @throws IllegalArgumentException if the descriptor string is not a valid\n+     * field descriptor string, or does not describe a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    ClassDescImpl(String descriptor) {\n+        requireNonNull(descriptor);\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false);\n+        if (len == 0 || len == 1\n+            || len != descriptor.length())\n+            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n+        this.descriptor = descriptor;\n+        this.isValue = ConstantUtils.basicType(descriptor, 0, descriptor.length(), false) == 'Q';\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        return descriptor;\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        ClassDesc c = this;\n+        int depth = ConstantUtils.arrayDepth(descriptorString());\n+        for (int i=0; i<depth; i++)\n+            c = c.componentType();\n+\n+        if (c.isPrimitive())\n+            return lookup.findClass(descriptorString());\n+        else {\n+            Class<?> clazz = lookup.findClass(internalToBinary(dropFirstAndLastChar(c.descriptorString())));\n+            if (isValue) {\n+                if (!clazz.isPrimitiveClass()) {\n+                    throw new LinkageError(clazz.getName() + \" is not a primitive class\");\n+                }\n+                clazz = clazz.asValueType();\n+            }\n+            for (int i = 0; i < depth; i++)\n+                clazz = clazz.arrayType();\n+            return clazz;\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@linkplain ClassDescImpl} is\n+     * equal to another {@linkplain ClassDescImpl}.  Equality is\n+     * determined by the two class descriptors having equal class descriptor\n+     * strings.\n+     *\n+     * @param o the {@code ClassDesc} to compare to this\n+     *       {@code ClassDesc}\n+     * @return {@code true} if the specified {@code ClassDesc}\n+     *      is equal to this {@code ClassDesc}.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        ClassDesc constant = (ClassDesc) o;\n+        return descriptor.equals(constant.descriptorString());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptor.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ClassDesc[%s]\", displayName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDescImpl.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -150,0 +150,1 @@\n+    private static final char JVM_SIGNATURE_VALUE_TYPE = 'Q';\n@@ -189,1 +190,2 @@\n-                    \/\/ Skip leading 'L' and ignore first appearance of ';'\n+                case JVM_SIGNATURE_VALUE_TYPE:\n+                    \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n@@ -218,0 +220,56 @@\n+    \/**\n+     * Returns the basic type of the given descriptor.  If {@code verifyClassName}\n+     * is true, then this method will validate that the characters at [start, end)\n+     * within the given string describe a valid field type descriptor.\n+     *\n+     * @return the character represents the basic type that the descriptor string\n+     * references\n+     * @throws IllegalArgumentException if the descriptor string is not valid\n+     *\/\n+    static char basicType(String descriptor, int start, int end, boolean verifyClassName) {\n+        int arrayDim = 0;\n+        int index = start;\n+        while (index < end) {\n+            char c = descriptor.charAt(index);\n+            switch (c) {\n+                case JVM_SIGNATURE_VOID:\n+                case JVM_SIGNATURE_BOOLEAN:\n+                case JVM_SIGNATURE_BYTE:\n+                case JVM_SIGNATURE_CHAR:\n+                case JVM_SIGNATURE_SHORT:\n+                case JVM_SIGNATURE_INT:\n+                case JVM_SIGNATURE_FLOAT:\n+                case JVM_SIGNATURE_LONG:\n+                case JVM_SIGNATURE_DOUBLE:\n+                    return c;\n+                case JVM_SIGNATURE_CLASS:\n+                case JVM_SIGNATURE_VALUE_TYPE:\n+                    index++;\n+                    int indexOfSemi = descriptor.indexOf(';', index);\n+                    if (indexOfSemi != -1) {\n+                        if (verifyClassName) {\n+                            String unqualifiedName = descriptor.substring(index, indexOfSemi);\n+                            boolean legal = verifyUnqualifiedClassName(unqualifiedName);\n+                            if (!legal) {\n+                                throw new IllegalArgumentException(String.format(\"not a valid type descriptor: %s\", descriptor));\n+                            }\n+                        }\n+                        return c;\n+                    }\n+                    throw new IllegalArgumentException(String.format(\"not a valid type descriptor: %s\", descriptor));\n+                case JVM_SIGNATURE_ARRAY:\n+                    arrayDim++;\n+                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n+                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n+                    }\n+                    \/\/ The rest of what's there better be a legal descriptor\n+                    index++;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(String.format(\"not a valid type descriptor: %s\", descriptor));\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"not a valid type descriptor: %s\", descriptor));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.constant.ConstantUtils.dropFirstAndLastChar;\n-import static java.lang.constant.ConstantUtils.internalToBinary;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n- * interface, or array type.  A {@linkplain ReferenceClassDescImpl} corresponds to a\n- * {@code Constant_Class_info} entry in the constant pool of a classfile.\n- *\/\n-final class ReferenceClassDescImpl implements ClassDesc {\n-    private final String descriptor;\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n-     * interface type\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @throws IllegalArgumentException if the descriptor string is not a valid\n-     * field descriptor string, or does not describe a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    ReferenceClassDescImpl(String descriptor) {\n-        requireNonNull(descriptor);\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false);\n-        if (len == 0 || len == 1\n-            || len != descriptor.length())\n-            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n-        this.descriptor = descriptor;\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        return descriptor;\n-    }\n-\n-    @Override\n-    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        ClassDesc c = this;\n-        int depth = ConstantUtils.arrayDepth(descriptorString());\n-        for (int i=0; i<depth; i++)\n-            c = c.componentType();\n-\n-        if (c.isPrimitive())\n-            return lookup.findClass(descriptorString());\n-        else {\n-            Class<?> clazz = lookup.findClass(internalToBinary(dropFirstAndLastChar(c.descriptorString())));\n-            for (int i = 0; i < depth; i++)\n-                clazz = clazz.arrayType();\n-            return clazz;\n-        }\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@linkplain ReferenceClassDescImpl} is\n-     * equal to another {@linkplain ReferenceClassDescImpl}.  Equality is\n-     * determined by the two class descriptors having equal class descriptor\n-     * strings.\n-     *\n-     * @param o the {@code ClassDesc} to compare to this\n-     *       {@code ClassDesc}\n-     * @return {@code true} if the specified {@code ClassDesc}\n-     *      is equal to this {@code ClassDesc}.\n-     *\/\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        ClassDesc constant = (ClassDesc) o;\n-        return descriptor.equals(constant.descriptorString());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return descriptor.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"ClassDesc[%s]\", displayName());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ReferenceClassDescImpl.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -24,0 +24,2 @@\n+import java.util.Objects;\n+\n@@ -25,1 +27,1 @@\n-    static final Object STATIC_FIELD = new Object();\n+    static final Object STATIC_FIELD = Objects.newIdentity();\n","filename":"test\/jdk\/valhalla\/valuetypes\/Point.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary Test ConstantDesc for primitive classes\n+ * @compile --enable-preview --source ${jdk.version} Point.java ValueConstantDesc.java\n+ * @run testng\/othervm --enable-preview ValueConstantDesc\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import static org.testng.Assert.*;\n+\n+public class ValueConstantDesc {\n+    private static final String NAME = \"Point\";\n+\n+    @DataProvider(name=\"descs\")\n+    static Object[][] descs() {\n+        return new Object[][]{\n+            new Object[] { Point.class,     ClassDesc.ofDescriptor(\"Q\" + NAME + \";\"), NAME},\n+            new Object[] { Point.ref.class, ClassDesc.ofDescriptor(\"L\" + NAME + \";\"), NAME + \".ref\"},\n+            new Object[] { Point[].class,   ClassDesc.ofDescriptor(\"[Q\" + NAME + \";\"), NAME + \"[]\"},\n+            new Object[] { Point.ref[][].class, ClassDesc.ofDescriptor(\"[[L\" + NAME + \";\"), NAME + \".ref[][]\"},\n+        };\n+    }\n+\n+    @Test(dataProvider=\"descs\")\n+    public void classDesc(Class<?> type, ClassDesc expected, String displayName) {\n+        ClassDesc cd = type.describeConstable().orElseThrow();\n+        if (type.isArray()) {\n+            assertTrue(cd.isArray());\n+            assertFalse(cd.isClassOrInterface());\n+        } else {\n+            assertFalse(cd.isArray());\n+            assertTrue(cd.isClassOrInterface());\n+        }\n+        assertEquals(cd, expected);\n+        assertEquals(cd.displayName(), displayName);\n+        assertEquals(cd.descriptorString(), type.descriptorString());\n+    }\n+\n+    @DataProvider(name=\"componentTypes\")\n+    static Object[][] componentTypes() {\n+        return new Object[][]{\n+            new Object[] { Point.class },\n+            new Object[] { Point.ref.class }\n+        };\n+    }\n+\n+    @Test(dataProvider=\"componentTypes\")\n+    public void arrayType(Class<?> componentType) {\n+        ClassDesc cd = componentType.describeConstable().orElseThrow();\n+        ClassDesc arrayDesc = cd.arrayType();\n+        ClassDesc arrayDesc2 = cd.arrayType(2);\n+\n+        assertTrue(arrayDesc.isArray());\n+        assertEquals(arrayDesc.componentType(), cd);\n+        assertTrue(arrayDesc2.isArray());\n+        assertEquals(arrayDesc2.componentType(), arrayDesc);\n+    }\n+\n+    @DataProvider(name=\"valueDesc\")\n+    static Object[][] valueDesc() {\n+        return new Object[][]{\n+                new Object[] { Point.class,         \"Q\" + NAME + \";\"},\n+                new Object[] { Point.ref.class,     \"L\" + NAME + \";\"},\n+                new Object[] { Point[].class,       \"[Q\" + NAME + \";\"},\n+                new Object[] { Point.ref[][].class, \"[[L\" + NAME + \";\"},\n+        };\n+    }\n+    @Test(dataProvider=\"valueDesc\")\n+    public void asValueType(Class<?> type, String descriptor) throws ReflectiveOperationException {\n+        ClassDesc cd = type.describeConstable().orElseThrow();\n+        ClassDesc valueDesc = ClassDesc.ofDescriptor(descriptor);\n+        assertEquals(cd, valueDesc);\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Class<?> c = (Class<?>) cd.resolveConstantDesc(lookup);\n+        assertTrue(c == type);\n+        assertTrue(cd.isValueType() == type.isValueType());\n+    }\n+\n+    @Test(expectedExceptions = {LinkageError.class})\n+    public void illegalDescriptor() throws ReflectiveOperationException {\n+        \/\/ ValueConstantDesc is not a primitive class\n+        ClassDesc cd = ClassDesc.ofDescriptor(\"QValueConstantDesc;\");\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Class<?> c = (Class<?>) cd.resolveConstantDesc(lookup);\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueConstantDesc.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}