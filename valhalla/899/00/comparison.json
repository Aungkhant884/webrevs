{"files":[{"patch":"@@ -170,0 +170,1 @@\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -188,0 +189,4 @@\n+    \/** Switch: allow primitive classes ?\n+     *\/\n+    boolean allowValueClasses;\n+\n@@ -5029,0 +5034,5 @@\n+        if (!allowValueClasses) {\n+            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                    Feature.VALUE_CLASSES.error(sourceName));\n+        }\n+\n@@ -5033,10 +5043,13 @@\n-        Symbol sym = switch (site.getTag()) {\n-            case WILDCARD -> throw new AssertionError(tree);\n-            case PACKAGE -> {\n-                log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n-                        Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n-                yield syms.errSymbol;\n-            }\n-            case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n-            default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n-        };\n+        if (!allowValueClasses) {\n+            result = types.createErrorType(names._default, site.tsym, site);\n+        } else {\n+            Symbol sym = switch (site.getTag()) {\n+                case WILDCARD -> throw new AssertionError(tree);\n+                case PACKAGE -> {\n+                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n+                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n+                    yield syms.errSymbol;\n+                }\n+                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n+                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n+            };\n@@ -5044,2 +5057,4 @@\n-        if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-            site = types.skipTypeVars(site, true);\n+            if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n+                site = types.skipTypeVars(site, true);\n+            }\n+            result = checkId(tree, site, sym, env, resultInfo);\n@@ -5047,1 +5062,0 @@\n-        result = checkId(tree, site, sym, env, resultInfo);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -89,12 +89,0 @@\n-\n-        la = new ArrayRelationsTest [10];\n-\n-        cce = false;\n-        try {\n-            qa = (ArrayRelationsTest![]) la;\n-        } catch (ClassCastException c) {\n-            cce = true;\n-        }\n-        if (!cce) {\n-            throw new AssertionError(\"Unexpected CCE behavior\");\n-        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayRelationsTest.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8214421 8221545 8222792\n- * @summary Q<->L mixing should be OK for upcasts and should use checkcasts for downcasts.\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile -XDemitQDesc BoxValCastTest.java\n- * @run main\/othervm -Xverify:none -XX:+EnableValhalla -XX:+EnablePrimitiveClasses BoxValCastTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class BoxValCastTest {\n-\n-    static value class VT {\n-        int f;\n-        static final VT vtbox = (VT) new VT(); \/\/ no binary cast\n-        static VT! vt = (VT!) vtbox; \/\/ binary cast\n-        static VT box = vt; \/\/ no binary cast\n-        static VT box2 = (VT!) box; \/\/ binary cast\n-        static VT box3 = id(new VT!()); \/\/ no binary cast + no binary cast\n-\n-        public implicit VT();\n-\n-        static VT! id(VT vtb) {\n-            return (VT!) vtb; \/\/ binary\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new BoxValCastTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"BoxValCastTest$VT.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-        \"checkcast     #7                  \/\/ class \\\"QBoxValCastTest$VT;\\\"\"\n-\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-         int errors = 0;\n-         for (String eo: expectedOut) {\n-             if (!out.contains(eo)) {\n-                 System.err.println(\"Match not found for string: \" + eo);\n-                 errors++;\n-             }\n-         }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-        String [] splits = out.split(\"checkcast     #7\", -1);\n-        if (splits.length != 4) {\n-             throw new AssertionError(\"Unexpected javap output: \" + splits.length);\n-        }\n-        splits = out.split(\"checkcast\", -1);\n-        if (splits.length != 9) {\n-             throw new AssertionError(\"Unexpected javap output: \" + splits.length);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BoxValCastTest.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -8,1 +8,1 @@\n-final primitive class CheckExtends extends Object {\n+final value class CheckExtends extends Object {\n@@ -10,1 +10,1 @@\n-    static primitive class NestedPrimitive extends NestedConcrete {}\n+    static value class NestedPrimitive extends NestedConcrete {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckExtends.java:10:22: compiler.err.concrete.supertype.for.value.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n+CheckExtends.java:10:18: compiler.err.concrete.supertype.for.value.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckFeatureGate2.java:11:17: compiler.err.primitive.classes.not.supported: 21\n+CheckFeatureGate2.java:11:17: compiler.err.feature.not.supported.in.source.plural: (compiler.misc.feature.value.classes), 13, 21\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate2.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                primitive class PC extends GoodSuper implements GoodSuperInterface {}\n+                value class PC extends GoodSuper implements GoodSuperInterface {}\n@@ -92,1 +92,1 @@\n-                primitive class PC extends Integer {}\n+                value class PC extends Integer {}\n@@ -97,1 +97,1 @@\n-                primitive class PC extends Number {\n+                value class PC extends Number {\n@@ -110,1 +110,1 @@\n-                primitive class PC extends SuperWithStaticField {}\n+                value class PC extends SuperWithStaticField {}\n@@ -128,1 +128,1 @@\n-                primitive class PC extends SuperWithEmptyNoArgCtor_02 {}\n+                value class PC extends SuperWithEmptyNoArgCtor_02 {}\n@@ -134,1 +134,1 @@\n-                primitive class PC extends BadSuper {}\n+                value class PC extends BadSuper {}\n@@ -143,1 +143,1 @@\n-                primitive class PC extends SuperWithInstanceField_01 {}\n+                value class PC extends SuperWithInstanceField_01 {}\n@@ -154,1 +154,1 @@\n-                primitive class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n+                value class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n@@ -165,1 +165,1 @@\n-                primitive class PC extends SuperWithArgedCtor_01 {}\n+                value class PC extends SuperWithArgedCtor_01 {}\n@@ -180,1 +180,1 @@\n-                primitive class PC extends SuperWithInstanceInit_01 {}\n+                value class PC extends SuperWithInstanceInit_01 {}\n@@ -189,1 +189,1 @@\n-                primitive class PC extends SuperWithSynchronizedMethod_1 {}\n+                value class PC extends SuperWithSynchronizedMethod_1 {}\n@@ -197,1 +197,1 @@\n-                primitive class PC extends Outer.InnerSuper {}\n+                value class PC extends Outer.InnerSuper {}\n@@ -204,1 +204,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -212,1 +212,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -226,1 +226,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -240,1 +240,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -242,1 +242,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -251,1 +251,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -253,1 +253,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -262,1 +262,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -264,1 +264,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -273,1 +273,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -281,1 +281,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -289,1 +289,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -297,1 +297,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -305,1 +305,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -313,1 +313,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -327,1 +327,0 @@\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\", \"primitive interface I {}\");\n@@ -331,1 +330,1 @@\n-                    primitive public void m() {}\n+                    value public void m() {}\n@@ -338,1 +337,1 @@\n-                        int[] ia = new primitive int[10];\n+                        int[] ia = new value int[10];\n@@ -346,1 +345,1 @@\n-                        new primitive String(\"Hello\");\n+                        new value String(\"Hello\");\n@@ -357,1 +356,1 @@\n-                        new primitive I() {};\n+                        new value I() {};\n@@ -364,1 +363,1 @@\n-    public void testPrimitivesAsTypeParams() {\n+    public void testValueClassesAsTypeParams() {\n@@ -368,1 +367,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -374,1 +373,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -380,1 +379,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -388,1 +387,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -395,2 +394,2 @@\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n+                import java.io.Serializable;\n+                value class ValueOverGenericsTest {\n@@ -404,1 +403,1 @@\n-            assertFail(\"compiler.err.type.found.req\", source);\n+            assertOK(source);\n@@ -414,1 +413,1 @@\n-                        primitive class Value {}\n+                        value class Value {}\n@@ -424,2 +423,2 @@\n-                        primitive class Value {}\n-                        new primitive Value() {};\n+                        value class Value {}\n+                        new value Value() {};\n@@ -457,1 +456,1 @@\n-                    primitive class UncheckedDefault<E> {\n+                    value class UncheckedDefault<E> {\n@@ -468,74 +467,0 @@\n-    public void testRefProjection() {\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC x) {\n-                        PC.ref xq = null;\n-                        xq = x;\n-                        xq = (PC.ref) x;\n-                        xq = (PC) x;\n-                        x = xq;\n-                        x = (PC.ref) xq;\n-                        x = (PC) xq;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC[] xa = new PC[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref [] xqa = new PC.ref[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa) {\n-                        PC.ref[] xqa = xa;\n-                        xqa = (PC.ref[]) xa;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = xqa;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = (PC[]) xqa;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n@@ -545,1 +470,1 @@\n-                primitive class PC {\n+                value class PC {\n@@ -553,49 +478,0 @@\n-    public void testProjectionInstantiation() {\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.ref();\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.val();\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.ref::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.val::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-    }\n-\n@@ -603,1 +479,1 @@\n-        assertFail(\"compiler.err.ref.ambiguous\",\n+        assertOK(\n@@ -606,2 +482,2 @@\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n+                    static value class V {}\n+                    static String roo(V v, int i) {\n@@ -610,1 +486,1 @@\n-                    static String roo(V.ref v, Integer i) {\n+                    static String roo(V v, Integer i) {\n@@ -618,1 +494,1 @@\n-        assertFail(\"compiler.err.ref.ambiguous\",\n+        assertOK(\n@@ -621,2 +497,2 @@\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n+                    static value class V {}\n+                    static String roo(V v, int i) {\n@@ -625,1 +501,1 @@\n-                    static String roo(V.ref v, Integer i) {\n+                    static String roo(V v, Integer i) {\n@@ -638,1 +514,1 @@\n-                primitive class Bar {\n+                value class Bar {\n@@ -647,1 +523,1 @@\n-                primitive class DualPathInnerType  {\n+                value class DualPathInnerType  {\n@@ -651,1 +527,1 @@\n-                    DualPathInnerType.ref.Inner xri = xi;\n+                    DualPathInnerType.Inner xri = xi;\n@@ -654,1 +530,1 @@\n-                    void f (DualPathInnerType.ref.Inner xri) {}\n+                    void f (DualPathInnerType.Inner xri) {}\n@@ -667,1 +543,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -678,1 +554,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -689,1 +565,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -700,1 +576,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -711,1 +587,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -722,1 +598,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -733,1 +609,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -753,1 +629,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -765,1 +641,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -777,1 +653,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -789,1 +665,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -801,1 +677,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -813,1 +689,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -825,1 +701,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -837,1 +713,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -850,1 +726,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -863,2 +739,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<String, Integer> r1) {\n@@ -875,2 +751,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -887,2 +763,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<String, Integer> r1) {\n@@ -900,2 +776,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -913,2 +789,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -922,58 +798,0 @@\n-    public void testValRefTokensNegative() {\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    ValRefTokensNegativeTest.ref aa = null;\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    static ValRefTokensNegativeTest.val bb = ValRefTokensNegativeTest.default;\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    EmptyValue empty = EmptyValue.default;\n-\n-                    static class ValRefTokensTestWrapper {\n-                        ValRefTokensNegativeTest val = ValRefTokensNegativeTest.default;\n-                        ValRefTokensNegativeTest ref = ValRefTokensNegativeTest.default;\n-                    }\n-\n-                    public EmptyValue test(int x) {\n-                        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n-                        return x == 0 ? w.val.empty : w.ref.empty;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int valx() {\n-                        return EmptyValue.val.x;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int refx() {\n-                        return EmptyValue.ref.x;\n-                    }\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n@@ -985,1 +803,1 @@\n-            assertFail(\"compiler.err.primitive.classes.not.supported\",\n+            assertFail(\"compiler.err.feature.not.supported.in.source.plural\",\n@@ -987,4 +805,4 @@\n-                    class primitive {\n-                        primitive x;\n-                        primitive foo(int l) {}\n-                        Object o = new primitive primitive() {};\n+                    class value {\n+                        value x;\n+                        value foo(int l) {}\n+                        Object o = new value value() {};\n@@ -996,1 +814,1 @@\n-                    class primitive {}\n+                    class value {}\n@@ -1010,1 +828,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1026,1 +844,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1044,1 +862,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1063,1 +881,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1082,1 +900,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1100,1 +918,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1112,1 +930,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1124,1 +942,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1138,1 +956,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1153,1 +971,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1173,1 +991,1 @@\n-                    primitive static class Foo extends S implements I<Integer> {\n+                    value static class Foo extends S implements I<Integer> {\n@@ -1179,90 +997,0 @@\n-\n-    public void testClassLiteralTypingNegativeTest() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\", \"-XDenablePrimitiveClasses\"};\n-            setCompileOptions(testOptions);\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = PrimitiveClass.asValueType(Foo.class);\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = new Foo().getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.ref.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.val.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.val xv = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xv.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.ref xr = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xr.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":99,"deletions":371,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProperTypeApplySelectTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,3 +24,5 @@\n-primitive class QPoint {\n-    int x = 0;\n-    int y = 0;\n+value class QPoint {\n+    int x;\n+    int y;\n+\n+    public implicit QPoint();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QPoint.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n@@ -34,0 +35,2 @@\n+\/* This test is very fragile should be replaced \/ removed\n+ *\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypeTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-primitive class QTypedValue {\n+value class QTypedValue {\n@@ -26,2 +26,2 @@\n-    QTypedValue [] f1 = new QTypedValue[10];\n-    QTypedValue [] f2 = new QTypedValue[10];\n+    QTypedValue! []! f1;\n+    QTypedValue! []! f2;\n@@ -29,2 +29,2 @@\n-    QTypedValue [][][] f3 = new QTypedValue[10][10][];\n-    QTypedValue [][][] f4 = new QTypedValue[10][10][];\n+    QTypedValue! [][][]! f3;\n+    QTypedValue! [][][]! f4;\n@@ -32,1 +32,9 @@\n-    void foo(QTypedValue x, int i) {\n+    public QTypedValue(boolean dummy) {\n+        f1 = new QTypedValue![10];\n+        f2 = new QTypedValue![10];\n+\n+        f3 = new QTypedValue![10][10][];\n+        f4 = new QTypedValue![10][10][];\n+    }\n+\n+    void foo(QTypedValue! x, int i) {\n@@ -34,1 +42,1 @@\n-        QTypedValue x1, x2, x4, x5, x6;\n+        QTypedValue! x1, x2, x4, x5, x6;\n@@ -40,1 +48,1 @@\n-            QTypedValue x9 = new QTypedValue();\n+            QTypedValue! x9 = new QTypedValue();\n@@ -43,0 +51,2 @@\n+\n+    public implicit QTypedValue();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypedValue.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,2 +32,6 @@\n-primitive class A {\n-    int x = 1000000;\n+value class A {\n+    int x;\n+    public implicit A();\n+    A(boolean dummy) {\n+        x = 1000000;\n+    }\n@@ -52,1 +56,1 @@\n-        if (new QualifiedSuperCtor(new A()).getADotThis().x !=1000000)\n+        if (new QualifiedSuperCtor(new A(false)).getADotThis().x !=1000000)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedSuperCtor.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class QualifiedThisTest {\n+public value class QualifiedThisTest {\n@@ -39,0 +39,2 @@\n+    public implicit QualifiedThisTest();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedThisTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-public primitive class Range<T> {\n+public value class Range<T> {\n@@ -30,0 +30,2 @@\n+    public implicit Range();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Range.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public primitive class RefDotClass {\n+public value class RefDotClass {\n@@ -37,0 +37,2 @@\n+    public implicit RefDotClass();\n+\n@@ -46,2 +48,6 @@\n-        foo(RefDotClass.ref.class);\n-        String tName = RefDotClass.ref.class.getTypeName();\n+        foo(RefDotClass.class);\n+        String tName = RefDotClass.class.getTypeName();\n+        \/* this is printing .ref due to code in java.lang.Class, there are several references to primitive classes\n+         * that should be removed. Also class: jdk.internal.value.PrimitiveClass\n+         *\/\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/RefDotClass.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-        Pointer<Point.ref> p_ref = Point.TYPE.allocate();\n+        Pointer<Point> p_ref = Point.TYPE.allocate();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-primitive class Point {\n+value class Point {\n@@ -47,0 +47,2 @@\n+    public implicit Point();\n+\n@@ -52,1 +54,1 @@\n-    public static ForeignType<Point.ref> TYPE = new ForeignType<>() { };\n+    public static ForeignType<Point> TYPE = new ForeignType<>() { };\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest01.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\n@@ -35,1 +34,1 @@\n-    static primitive class V {\n+    static value class V {\n@@ -41,1 +40,3 @@\n-        V() {\n+        public implicit V();\n+\n+        V(boolean dummy) {\n@@ -56,1 +57,1 @@\n-        V v = new V();\n+        V v = new V(false);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-public primitive class SignatureTest<T> implements java.io.Serializable {\n+public value class SignatureTest<T> implements java.io.Serializable {\n+    public implicit SignatureTest();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SignatureTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-public primitive class SmallSet {\n+public value class SmallSet {\n@@ -30,0 +30,2 @@\n+  public implicit SmallSet();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SmallSet.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8247567\n- * @summary Javac chokes on static member selection via the reference projection.\n- * @compile -XDenablePrimitiveClasses StaticSelectedThroughProjection.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses StaticSelectedThroughProjection\n- *\/\n-\n-public class StaticSelectedThroughProjection {\n-    static primitive class MyValue {\n-        int x = 42;\n-        static String test() {\n-            return \"OK\";\n-        };\n-    }\n-    public static void main(String[] args) {\n-        if (!MyValue.ref.test().equals(\"OK\"))\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StaticSelectedThroughProjection.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -36,1 +36,1 @@\n-    public static primitive class X {\n+    public static value class X {\n@@ -61,1 +61,1 @@\n-                        .map(X.ref::data)\n+                        .map(X::data)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StreamsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    static primitive class Prime {\n+    static value class Prime {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperHashCodeEqualsToStringTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    primitive class Bar implements Foo { }\n+    value class Bar implements Foo { }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/T8279655.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-primitive final class TestValue1 {\n+value final class TestValue1 {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestQualifierOnInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8269956\n- * @summary  javac should generate `ldc LPoint;` for class literal Point.class\n- * @modules java.base\/jdk.internal.value\n- * @compile -XDenablePrimitiveClasses TestReflectiveMirrors.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses TestReflectiveMirrors\n- *\/\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-public class TestReflectiveMirrors {\n-\n-    static primitive class ValDefault {}\n-\n-    public static void main(String [] args) {\n-\n-        if (ValDefault.class != new ValDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (ValDefault.ref.class != new ValDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (ValDefault.val.class != PrimitiveClass.asValueType(new ValDefault().getClass())) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (TestReflectiveMirrors.ValDefault.class != new ValDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (TestReflectiveMirrors.ValDefault.ref.class != new ValDefault().getClass()) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-\n-        if (TestReflectiveMirrors.ValDefault.val.class != PrimitiveClass.asValueType(new ValDefault().getClass())) {\n-            throw new AssertionError(\"Wrong mirror\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestReflectiveMirrors.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-public primitive class ThisIsNotAnInstanceField {\n+public value class ThisIsNotAnInstanceField {\n@@ -38,1 +38,1 @@\n-    Inner.ref i2 = new Inner();\n+    Inner i2 = new Inner();\n@@ -40,1 +40,1 @@\n-    primitive class Inner {\n+    value class Inner {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ThisIsNotAnInstanceField.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222792\n- * @summary Javac should enforce the latest relationship rules between an inline type and its nullable projection\n- * @compile -XDenablePrimitiveClasses TypeRelationsTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses TypeRelationsTest\n- *\/\n-\n-public primitive class TypeRelationsTest {\n-\n-    int x = 42;\n-\n-    static boolean foo(TypeRelationsTest x, TypeRelationsTest.ref xq, boolean nullPassed) {\n-        TypeRelationsTest xl;\n-        TypeRelationsTest.ref xql;\n-        boolean npe = false;\n-\n-        xl = x;\n-        xl = (TypeRelationsTest) x;\n-        try {\n-            xl = (TypeRelationsTest) xq;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-\n-        xql = x;\n-        xql = (TypeRelationsTest.ref ) x;\n-        xql = xq;\n-        xql = (TypeRelationsTest.ref) xq;\n-        return npe;\n-    }\n-\n-    static String foo(Object o) {\n-        return \"Object\";\n-    }\n-\n-    static String foo(TypeRelationsTest x) {\n-        return \"TypeRelationsTest\";\n-    }\n-\n-    static String foo(TypeRelationsTest.ref xq) {\n-        return \"TypeRelationsTest.ref\";\n-    }\n-\n-    public static void main(String [] args) {\n-       if (foo(new TypeRelationsTest(), new TypeRelationsTest(), false))\n-            throw new AssertionError(\"Unexpected NPE\");\n-       if (!foo(new TypeRelationsTest(), null, true))\n-            throw new AssertionError(\"Missing NPE\");\n-\n-       TypeRelationsTest x = new TypeRelationsTest();\n-       TypeRelationsTest.ref xq = null;\n-       if (!foo(x).equals(\"TypeRelationsTest\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       if (!foo(xq).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       if (!foo((TypeRelationsTest.ref) x).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-\n-       boolean npe = false;\n-       try  {\n-           foo((TypeRelationsTest) xq);\n-       } catch (NullPointerException e) {\n-            npe = true;\n-       }\n-       if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-       }\n-       xq = x;\n-       if (!foo((TypeRelationsTest.ref) xq).equals(\"TypeRelationsTest.ref\"))\n-            throw new AssertionError(\"Wrong overload\");\n-       checkArrays();\n-    }\n-\n-    static void checkArrays() {\n-        TypeRelationsTest [] xa = new TypeRelationsTest[10];\n-        TypeRelationsTest.ref [] xqa;\n-        Object [] oa;\n-        Object o;\n-\n-        o = oa = xqa = xa;\n-        xa = (TypeRelationsTest []) (xqa = (TypeRelationsTest.ref[]) (oa = (Object []) o));\n-        xa[0] = new TypeRelationsTest(); \/\/ OK, after round trip back and forth.\n-\n-\n-        xqa = (TypeRelationsTest.ref[]) xa;\n-        boolean npe = false;\n-        try {\n-            xqa[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-           throw new AssertionError(\"Missing NPE\");\n-        }\n-        npe = false;\n-\n-        oa = xa;\n-        try {\n-            oa[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-           throw new AssertionError(\"Missing NPE\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsTest.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -57,1 +57,1 @@\n-    public primitive class V<@TA @TARR T> {}\n+    public value class V<@TA @TARR T> {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnannotatedProjection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -33,0 +32,1 @@\n+ * @ignore\n@@ -41,1 +41,1 @@\n-    public primitive class X {\n+    public value class X {\n@@ -43,1 +43,1 @@\n-        X.ref xr = null;\n+        X xr = null;\n@@ -45,1 +45,1 @@\n-        public void foo(X.ref[] xra, X[] xa) {\n+        public void foo(X[] xra, X[] xa) {\n@@ -47,1 +47,1 @@\n-            xra = new X.ref[10];\n+            xra = new X[10];\n@@ -50,2 +50,2 @@\n-            Class<?> c = X.val.class;\n-            c = X.ref.class;\n+            Class<?> c = X.class;\n+            c = X.class;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassBytecodeTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    primitive class V<T> implements java.io.Serializable {}\n+    value class V<T> implements java.io.Serializable {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassInnerClassesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public primitive class UnifiedPrimitiveClassNestHostTest implements java.io.Serializable {\n+public value class UnifiedPrimitiveClassNestHostTest implements java.io.Serializable {\n@@ -40,1 +40,1 @@\n-    primitive class Inner {}\n+    value class Inner {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassNestHostTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    primitive class V {\n+    value class V {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnrelatedThisLeak.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8264977\n- * @summary A primitive class field by name val confuses javac\n- * @compile -XDenablePrimitiveClasses ValRefTokensTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ValRefTokensTest\n- *\/\n-\n-public primitive class ValRefTokensTest  {\n-\n-    ValRefTokensTest.ref aa = null;\n-    static ValRefTokensTest.val bb = ValRefTokensTest.default;\n-\n-    EmptyValue empty = EmptyValue.default;\n-\n-    static primitive class ValRefTokensTestWrapper {\n-       ValRefTokensTest val = ValRefTokensTest.default;\n-       ValRefTokensTest ref = ValRefTokensTest.default;\n-    }\n-\n-    public EmptyValue test139(int x) {\n-        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n-        return x == 0 ? w.val.empty : w.ref.empty;\n-    }\n-\n-    int valx() {\n-        return EmptyValue.val.x;\n-    }\n-\n-    int refx() {\n-        return EmptyValue.ref.x;\n-    }\n-\n-    static primitive class EmptyValue {\n-        static int x = 42;\n-    }\n-\n-    public static void main(String [] args) {\n-        if (new ValRefTokensTest().valx() != new ValRefTokensTest().refx())\n-            throw new AssertionError(\"Broken\");\n-        if (new ValRefTokensTest().test139(0).x != new ValRefTokensTest().test139(1).x)\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValRefTokensTest.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8244233\n- * @summary Nested types are not handled properly across projections\n- * @compile -XDenablePrimitiveClasses ValueAsEnclosingClass.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ValueAsEnclosingClass\n- *\/\n-\n-public primitive class ValueAsEnclosingClass {\n-\n-    static primitive class V {\n-        int y = 52;\n-\n-        class Bar { }\n-        static class Baz { }\n-    }\n-\n-    class Inner { }\n-\n-    static ValueAsEnclosingClass.Inner xi = new ValueAsEnclosingClass().new Inner();\n-    ValueAsEnclosingClass.ref.Inner xri = xi;\n-\n-    public static void main(String[] args) {\n-        new V().new Bar();\n-        V.Baz baz1 = new V.Baz();\n-        V.ref.Baz baz2 = baz1;\n-        new ValueAsEnclosingClass();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAsEnclosingClass.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -39,1 +39,1 @@\n-    public static final primitive class Value {\n+    public static final value class Value {\n@@ -51,0 +51,2 @@\n+        public implicit Value();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueBootstrapMethodsTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public primitive class ValueConstructorRef {\n+public value class ValueConstructorRef {\n@@ -40,2 +40,2 @@\n-    \tx = 1234;\n-    \ty = 5678;\n+        x = 1234;\n+        y = 5678;\n@@ -45,2 +45,2 @@\n-       Supplier<ValueConstructorRef.ref> sx = ValueConstructorRef::new;\n-    \tValueConstructorRef x = (ValueConstructorRef) sx.get();\n+        Supplier<ValueConstructorRef> sx = ValueConstructorRef::new;\n+        ValueConstructorRef! x = (ValueConstructorRef) sx.get();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueConstructorRef.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n@@ -37,0 +38,1 @@\n+\/\/ very fragile test\n@@ -39,1 +41,1 @@\n-    primitive\n+    value\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueCreationTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public primitive class ValueNewReadWrite {\n+public value class ValueNewReadWrite {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueNewReadWrite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public final primitive class ValuesAsRefs {\n+public final value class ValuesAsRefs {\n@@ -35,1 +35,1 @@\n-    final ArrayList<? extends ValuesAsRefs.ref> ao = null; \/\/ values can be wildcard bounds.\n+    final ArrayList<? extends ValuesAsRefs> ao = null; \/\/ values can be wildcard bounds.\n@@ -37,2 +37,2 @@\n-    final primitive class I implements java.io.Serializable {\n-        final int y = 42;\n+    static final value class I implements java.io.Serializable {\n+        public implicit I();\n@@ -42,1 +42,1 @@\n-        I i = this.new I();  \/\/ values can be enclosing instances.\n+        I i = new I();  \/\/ values can be enclosing instances.\n@@ -44,1 +44,1 @@\n-        Object o = (I.ref & java.io.Serializable) i; \/\/ values can be used in intersection casts\n+        Object o = (I & java.io.Serializable) i; \/\/ values can be used in intersection casts\n@@ -47,1 +47,1 @@\n-        this.<ValuesAsRefs.ref>goo(); \/\/ values can be type arguments to generic method calls\n+        this.<ValuesAsRefs>goo(); \/\/ values can be type arguments to generic method calls\n@@ -52,9 +52,1 @@\n-        ArrayList<ValuesAsRefs.I.ref> aloi = new ArrayList<>(); \/\/ values can be type arguments.\n-        boolean OK = false;\n-        try {\n-            aloi.add((ValuesAsRefs.I) o);\n-        } catch (NullPointerException npe) {\n-            OK = true;\n-        }\n-        if (!OK)\n-            throw new AssertionError(\"Missing NPE\");\n+        ArrayList<ValuesAsRefs.I> aloi = new ArrayList<>(); \/\/ values can be type arguments.\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValuesAsRefs.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public final primitive class WithFieldOfGenericType<E> {\n+public final value class WithFieldOfGenericType<E> {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldOfGenericType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-public final primitive class WithFieldRuntimeTest {\n+public final value class WithFieldRuntimeTest {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldRuntimeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-public primitive record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n+public value record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}