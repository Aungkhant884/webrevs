{"files":[{"patch":"@@ -105,0 +105,1 @@\n+        --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -621,0 +621,2 @@\n+  do_intrinsic(_isFlattenedArray,         jdk_internal_misc_Unsafe,     isFlattenedArray_name, class_boolean_signature, F_RN)    \\\n+   do_name(     isFlattenedArray_name,                                  \"isFlattenedArray\")                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -714,0 +714,1 @@\n+  case vmIntrinsics::_isFlattenedArray:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -512,0 +512,1 @@\n+  case vmIntrinsics::_isFlattenedArray:         return inline_unsafe_isFlattenedArray();\n@@ -5264,0 +5265,14 @@\n+\/\/----------------------inline_unsafe_isFlattenedArray-------------------\n+\/\/ public native boolean Unsafe.isFlattenedArray(Class<?> arrayClass);\n+\/\/ This intrinsic exploits assumptions made by the native implementation\n+\/\/ (arrayClass is neither null nor primitive) to avoid unnecessary null checks.\n+bool LibraryCallKit::inline_unsafe_isFlattenedArray() {\n+  Node* cls = argument(1);\n+  Node* p = basic_plus_adr(cls, java_lang_Class::klass_offset());\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p,\n+                                                 TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT));\n+  Node* result = flat_array_test(kls);\n+  set_result(result);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -254,0 +254,1 @@\n+  bool inline_unsafe_isFlattenedArray();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2822,1 +2822,1 @@\n-        assert(t->isa_aryklassptr(), \"Unexpected input type\");\n+        assert(t->isa_klassptr(), \"Unexpected input type\");\n@@ -2832,0 +2832,4 @@\n+    Node* m2b = transform_later(new Conv2BNode(masked));\n+    \/\/ The matcher expects the input to If nodes to be produced by a Bool(CmpI..)\n+    \/\/ pattern, but the input to other potential users (e.g. Phi) to be some\n+    \/\/ other pattern (e.g. a Conv2B node, possibly idealized as a CMoveI).\n@@ -2833,1 +2837,9 @@\n-    _igvn.replace_node(old_bol, bol);\n+    for (DUIterator_Last imin, i = old_bol->last_outs(imin); i >= imin; --i) {\n+      Node* user = old_bol->last_out(i);\n+      for (uint j = 0; j < user->req(); j++) {\n+        Node* n = user->in(j);\n+        if (n == old_bol) {\n+          _igvn.replace_input_of(user, j, user->is_If() ? bol : m2b);\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -226,4 +226,1 @@\n-            \/\/ the redundant componentType.isPrimitiveValueType() check is\n-            \/\/ there to minimize the performance impact to non-value array.\n-            \/\/ It should be removed when Unsafe::isFlattenedArray is intrinsified.\n-            return maybeAdapt(PrimitiveClass.isPrimitiveValueType(componentType) && UNSAFE.isFlattenedArray(arrayClass)\n+            return maybeAdapt(UNSAFE.isFlattenedArray(arrayClass)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-compiler\/gcbarriers\/TestZGCBarrierElision.java#ZGen 8313737 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1662,0 +1662,34 @@\n+\n+    \/\/ Test correctness of the Unsafe::isFlattenedArray intrinsic\n+    @Test\n+    public boolean test81(Class<?> cls) {\n+        return U.isFlattenedArray(cls);\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        Asserts.assertEQ(test81(MyValue1[].class), TEST33_FLATTENED_ARRAY, \"test81_1 failed\");\n+        Asserts.assertFalse(test81(String[].class), \"test81_2 failed\");\n+        Asserts.assertFalse(test81(String.class), \"test81_3 failed\");\n+        Asserts.assertFalse(test81(int[].class), \"test81_4 failed\");\n+    }\n+\n+    \/\/ Verify that Unsafe::isFlattenedArray checks with statically known classes\n+    \/\/ are folded\n+    @Test\n+    @IR(failOn = {LOADK})\n+    public boolean test82() {\n+        boolean check1 = U.isFlattenedArray(MyValue1[].class);\n+        if (!TEST33_FLATTENED_ARRAY) {\n+            check1 = !check1;\n+        }\n+        boolean check2 = !U.isFlattenedArray(String[].class);\n+        boolean check3 = !U.isFlattenedArray(String.class);\n+        boolean check4 = !U.isFlattenedArray(int[].class);\n+        return check1 && check2 && check3 && check4;\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        Asserts.assertTrue(test82(), \"test82 failed\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.valhalla.intrinsics;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+import jdk.internal.misc.Unsafe;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 1,\n+      jvmArgsAppend = {\"--add-opens\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                       \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\"})\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+public class IsFlattenedArray {\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final VarHandle objectArrayVarHandle =\n+        MethodHandles.arrayElementVarHandle(Object[].class);\n+\n+    @State(Scope.Benchmark)\n+    public static class ClassState {\n+        public Class flattenedArrayClass = Point[].class;\n+        public Class nonFlattenedArrayClass = String[].class;\n+\n+        public Object[] objectArray = new Object[10];\n+        public Object objectElement = new Object();\n+        public int arrayIndex = 0;\n+    }\n+\n+    @Benchmark\n+    public boolean testKnownFlattenedClass() {\n+        return U.isFlattenedArray(Point[].class);\n+    }\n+\n+    @Benchmark\n+    public boolean testKnownNonFlattenedClass() {\n+        return U.isFlattenedArray(String[].class);\n+    }\n+\n+    @Benchmark\n+    public boolean testUnknownFlattenedClass(ClassState state) {\n+        return U.isFlattenedArray(state.flattenedArrayClass);\n+    }\n+\n+    @Benchmark\n+    public boolean testUnknownNonFlattenedClass(ClassState state) {\n+        return U.isFlattenedArray(state.nonFlattenedArrayClass);\n+    }\n+\n+    @Benchmark\n+    public void setArrayElement(ClassState state) {\n+        objectArrayVarHandle.set(state.objectArray, state.arrayIndex, state.objectElement);\n+    }\n+\n+    @Benchmark\n+    public VarHandle makeArrayVarHandle() {\n+        return MethodHandles.arrayElementVarHandle(Object[].class);\n+    }\n+\n+}\n+\n+primitive class Point {\n+    int x;\n+    int y;\n+    public Point(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/intrinsics\/IsFlattenedArray.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}