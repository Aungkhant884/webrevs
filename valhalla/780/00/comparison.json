{"files":[{"patch":"@@ -880,0 +880,1 @@\n+  \/\/ Interpreter::stackElementSize is the space we need.\n@@ -882,1 +883,0 @@\n-  \/\/ Interpreter::stackElementSize is the space we need.\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  if (!receiver->is_InlineType() && kit.gvn().type(receiver)->higher_equal(TypePtr::NULL_PTR)) {\n+  if (kit.gvn().type(receiver)->higher_equal(TypePtr::NULL_PTR)) {\n@@ -792,1 +792,1 @@\n-    InlineTypeBaseNode* vt = result->isa_InlineTypeBase();\n+    InlineTypeNode* vt = result->isa_InlineType();\n@@ -827,1 +827,1 @@\n-          vt = kit.gvn().transform(vt)->as_InlineTypeBase();\n+          vt = kit.gvn().transform(vt)->as_InlineType();\n@@ -835,1 +835,1 @@\n-        result = vt->as_ptr(&kit.gvn(), inline_method->signature()->returns_null_free_inline_type());\n+        result = vt;\n@@ -1072,1 +1072,2 @@\n-    if (m->is_InlineType() && !t->isa_inlinetype()) {\n+    \/\/ TODO 8284443 still needed?\n+    if (m->is_InlineType() && !t->is_inlinetypeptr()) {\n@@ -1077,1 +1078,1 @@\n-    if (n->is_InlineType() && !t->isa_inlinetype()) {\n+    if (n->is_InlineType() && !t->is_inlinetypeptr()) {\n@@ -1167,1 +1168,1 @@\n-  if (sig_type->is_inlinetypeptr() && !arg->is_InlineType()) {\n+  if (sig_type->is_inlinetypeptr()) {\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1516,2 +1516,2 @@\n-      if (n->is_InlineTypeBase()) {\n-        n->as_InlineTypeBase()->make_scalar_in_safepoints(phase->is_IterGVN());\n+      if (n->is_InlineType()) {\n+        n->as_InlineType()->make_scalar_in_safepoints(phase->is_IterGVN());\n@@ -1745,1 +1745,1 @@\n-                           InlineTypeBaseNode* inline_type_node)\n+                           InlineTypeNode* inline_type_node)\n@@ -1765,1 +1765,1 @@\n-  init_req( InlineTypeNode     , inline_type_node);\n+  init_req( InlineType     , inline_type_node);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -911,1 +911,1 @@\n-    InlineTypeNode,                   \/\/ InlineTypeNode if this is an inline type allocation\n+    InlineType,                   \/\/ InlineTypeNode if this is an inline type allocation\n@@ -923,1 +923,1 @@\n-    fields[InlineTypeNode] = Type::BOTTOM;\n+    fields[InlineType] = Type::BOTTOM;\n@@ -948,1 +948,1 @@\n-               InlineTypeBaseNode* inline_type_node = NULL);\n+               InlineTypeNode* inline_type_node = NULL);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-  \/\/ Push cast through InlineTypePtrNode\n-  InlineTypePtrNode* vt = in(1)->isa_InlineTypePtr();\n+  \/\/ Push cast through InlineTypeNode\n+  InlineTypeNode* vt = in(1)->isa_InlineType();\n@@ -94,1 +94,1 @@\n-    vt = vt->clone()->as_InlineTypePtr();\n+    vt = vt->clone()->as_InlineType();\n@@ -395,1 +395,1 @@\n-  if (in(1)->is_InlineTypeBase() && _type->isa_instptr() && phase->type(in(1))->inline_klass()->is_subtype_of(_type->is_instptr()->instance_klass())) {\n+  if (in(1)->is_InlineType() && _type->isa_instptr() && phase->type(in(1))->inline_klass()->is_subtype_of(_type->is_instptr()->instance_klass())) {\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1966,7 +1966,2 @@\n-InlineTypeBaseNode* PhiNode::push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk, bool is_init) {\n-  InlineTypeBaseNode* vt = NULL;\n-  if (_type->isa_ptr()) {\n-    vt = InlineTypePtrNode::make_null(*phase, vk)->clone_with_phis(phase, in(0), is_init);\n-  } else {\n-    vt = InlineTypeNode::make_null(*phase, vk)->clone_with_phis(phase, in(0), is_init);\n-  }\n+InlineTypeNode* PhiNode::push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk, bool is_init) {\n+  InlineTypeNode* vt = InlineTypeNode::make_null(*phase, vk)->clone_with_phis(phase, in(0), is_init);\n@@ -1983,0 +1978,1 @@\n+    igvn->rehash_node_delayed(this);\n@@ -1994,1 +1990,1 @@\n-      n = InlineTypePtrNode::make_null(*phase, vk);\n+      n = InlineTypeNode::make_null(*phase, vk);\n@@ -2000,1 +1996,1 @@\n-      \/\/ Push the cast(s) through the InlineTypePtrNode\n+      \/\/ Push the cast(s) through the InlineTypeNode\n@@ -2002,1 +1998,1 @@\n-      cast->set_req_X(1, n->as_InlineTypePtr()->get_oop(), phase);\n+      cast->set_req_X(1, n->as_InlineType()->get_oop(), phase);\n@@ -2004,1 +2000,1 @@\n-      n->as_InlineTypePtr()->set_oop(phase->transform(cast));\n+      n->as_InlineType()->set_oop(phase->transform(cast));\n@@ -2008,1 +2004,1 @@\n-    vt->merge_with(phase, n->as_InlineTypeBase(), i, transform);\n+    vt->merge_with(phase, n->as_InlineType(), i, transform);\n@@ -2542,0 +2538,1 @@\n+    \/\/ TODO 8284443 We could revisit the same node over and over again, right?\n@@ -2544,0 +2541,1 @@\n+    bool only_phi = (outcnt() != 0);\n@@ -2546,1 +2544,1 @@\n-      if (n->is_InlineTypePtr() && n->in(1) == this) {\n+      if (n->is_InlineType() && n->in(1) == this) {\n@@ -2550,0 +2548,6 @@\n+      if (!n->is_Phi()) {\n+        only_phi = false;\n+      }\n+    }\n+    if (only_phi) {\n+      can_optimize = false;\n@@ -2551,1 +2555,0 @@\n-    \/\/ TODO 8284443 We could revisit the same node over and over again, right?\n@@ -2570,2 +2573,1 @@\n-        if (n->is_InlineTypeBase() && n->as_InlineTypeBase()->can_merge() &&\n-            (vk == NULL || vk == t->inline_klass())) {\n+        if (n->is_InlineType() && (vk == NULL || vk == t->inline_klass())) {\n@@ -2573,1 +2575,1 @@\n-          if (phase->find_int_con(n->as_InlineTypeBase()->get_is_init(), 0) != 1) {\n+          if (phase->find_int_con(n->as_InlineType()->get_is_init(), 0) != 1) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-  InlineTypeBaseNode* push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk, bool is_init);\n+  InlineTypeNode* push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk, bool is_init);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -369,1 +369,0 @@\n-macro(InlineTypePtr)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-  if (dead->is_InlineTypeBase()) {\n+  if (dead->is_InlineType()) {\n@@ -1939,1 +1939,1 @@\n-  assert(n->is_InlineTypeBase(), \"unexpected node\");\n+  assert(n->is_InlineType(), \"unexpected node\");\n@@ -1944,1 +1944,1 @@\n-  assert(n->is_InlineTypeBase(), \"unexpected node\");\n+  assert(n->is_InlineType(), \"unexpected node\");\n@@ -1958,1 +1958,1 @@\n-    assert(!n->is_InlineType(), \"chain of inline type nodes\");\n+    assert(n == ret_val || !n->is_InlineType(), \"chain of inline type nodes\");\n@@ -1962,1 +1962,1 @@\n-    } else if (n->is_InlineTypePtr()) {\n+    } else if (n->is_InlineType()) {\n@@ -2007,1 +2007,1 @@\n-    _inline_type_nodes.at(i)->as_InlineTypeBase()->make_scalar_in_safepoints(&igvn);\n+    _inline_type_nodes.at(i)->as_InlineType()->make_scalar_in_safepoints(&igvn);\n@@ -2012,1 +2012,1 @@\n-      InlineTypeBaseNode* vt = _inline_type_nodes.pop()->as_InlineTypeBase();\n+      InlineTypeNode* vt = _inline_type_nodes.pop()->as_InlineType();\n@@ -2015,1 +2015,1 @@\n-      } else if (vt->is_InlineTypePtr()) {\n+      } else if (vt->is_InlineType()) {\n@@ -2048,1 +2048,1 @@\n-          assert(vt->fast_out(i)->is_InlineTypeBase(), \"Unexpected inline type user\");\n+          assert(vt->fast_out(i)->is_InlineType(), \"Unexpected inline type user\");\n@@ -4355,1 +4355,0 @@\n-  case Op_InlineTypePtr:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-class InlineTypeBaseNode;\n+class InlineTypeNode;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  if (in(1)->is_InlineTypePtr()) {\n+  if (in(1)->is_InlineType()) {\n@@ -70,1 +70,1 @@\n-    set_req_X(1, in(1)->as_InlineTypePtr()->get_is_init(), phase);\n+    set_req_X(1, in(1)->as_InlineType()->get_is_init(), phase);\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -572,6 +572,1 @@\n-    const TypeOopPtr* receiver_type = NULL;\n-    if (receiver_node->is_InlineType()) {\n-      receiver_type = TypeInstPtr::make(TypePtr::NotNull, _gvn.type(receiver_node)->inline_klass());\n-    } else {\n-      receiver_type = _gvn.type(receiver_node)->isa_oopptr();\n-    }\n+    const TypeOopPtr* receiver_type = _gvn.type(receiver_node)->isa_oopptr();\n@@ -662,1 +657,1 @@\n-  if (receiver != NULL && !receiver->is_InlineType() && !call_does_dispatch && !cg->is_string_late_inline()) {\n+  if (receiver != NULL && !call_does_dispatch && !cg->is_string_late_inline()) {\n@@ -738,1 +733,1 @@\n-            if (arg_type != NULL && !arg_type->higher_equal(sig_type) && !peek()->is_InlineType()) {\n+            if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {\n@@ -784,1 +779,1 @@\n-    if (rtype->basic_type() == T_PRIMITIVE_OBJECT && !peek()->is_InlineTypeBase()) {\n+    if (rtype->basic_type() == T_PRIMITIVE_OBJECT && !peek()->is_InlineType()) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-    case Op_InlineTypePtr:\n+    case Op_InlineType:\n@@ -738,1 +738,1 @@\n-    case Op_InlineTypePtr:\n+    case Op_InlineType:\n@@ -2132,1 +2132,1 @@\n-      if (alloc->in(AllocateNode::InlineTypeNode) != NULL) {\n+      if (alloc->in(AllocateNode::InlineType) != NULL) {\n@@ -3481,1 +3481,1 @@\n-              op == Op_SubTypeCheck || op == Op_InlineType || op == Op_InlineTypePtr || op == Op_FlatArrayCheck ||\n+              op == Op_SubTypeCheck || op == Op_InlineType || op == Op_FlatArrayCheck ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1256,15 +1256,0 @@\n-    InlineTypeNode* vt = value->as_InlineType();\n-    null_check_common(vt->get_is_init(), T_INT, assert_null, null_control, speculative, true);\n-    if (stopped()) {\n-      return top();\n-    }\n-    if (assert_null) {\n-      \/\/ TODO 8284443 Scalarize here (this currently leads to compilation bailouts)\n-      \/\/ vt = InlineTypeNode::make_null(_gvn, vt->type()->inline_klass());\n-      \/\/ replace_in_map(value, vt);\n-      \/\/ return vt;\n-      return null();\n-    }\n-    bool do_replace_in_map = (null_control == NULL || (*null_control) == top());\n-    return cast_not_null(value, do_replace_in_map);\n-  } else if (value->is_InlineTypePtr()) {\n@@ -1273,3 +1258,3 @@\n-    InlineTypePtrNode* vtptr = value->as_InlineTypePtr();\n-    while (vtptr->get_oop()->is_InlineTypePtr()) {\n-      vtptr = vtptr->get_oop()->as_InlineTypePtr();\n+    InlineTypeNode* vtptr = value->as_InlineType();\n+    while (vtptr->get_oop()->is_InlineType()) {\n+      vtptr = vtptr->get_oop()->as_InlineType();\n@@ -1283,1 +1268,1 @@\n-      \/\/ vtptr = InlineTypePtrNode::make_null(_gvn, vtptr->type()->inline_klass());\n+      \/\/ vtptr = InlineTypeNode::make_null(_gvn, vtptr->type()->inline_klass());\n@@ -1474,19 +1459,3 @@\n-    InlineTypeNode* vt = obj->clone()->as_InlineType();\n-    vt->set_is_init(_gvn);\n-    vt = _gvn.transform(vt)->as_InlineType();\n-    if (do_replace_in_map) {\n-      replace_in_map(obj, vt);\n-    }\n-    return vt;\n-  } else if (obj->is_InlineTypePtr()) {\n-    \/\/ Cast oop input instead\n-    Node* cast = cast_not_null(obj->as_InlineTypePtr()->get_oop(), do_replace_in_map);\n-    if (cast->is_top()) {\n-      \/\/ Always null\n-      return top();\n-    }\n-    \/\/ Create a new node with the casted oop input and is_init set\n-    InlineTypeBaseNode* vt = obj->clone()->as_InlineTypePtr();\n-    vt->set_oop(cast);\n-    vt->set_is_init(_gvn);\n-    vt = _gvn.transform(vt)->as_InlineTypePtr();\n+    Node* vt = obj->clone();\n+    vt->as_InlineType()->set_is_init(_gvn);\n+    vt = _gvn.transform(vt);\n@@ -1870,1 +1839,1 @@\n-      if (!arg->is_InlineTypeBase()) {\n+      if (!arg->is_InlineType()) {\n@@ -1874,1 +1843,1 @@\n-      InlineTypeBaseNode* vt = arg->as_InlineTypeBase();\n+      InlineTypeNode* vt = arg->as_InlineType();\n@@ -1886,1 +1855,1 @@\n-        arg = arg->as_InlineTypePtr()->get_oop();\n+        arg = arg->as_InlineType()->get_oop();\n@@ -3028,1 +2997,1 @@\n-        res = InlineTypeNode::make_from_oop(this, res, recv_xtype->inline_klass())->as_InlineTypeBase()->as_ptr(&gvn());\n+        res = InlineTypeNode::make_from_oop(this, res, recv_xtype->inline_klass());\n@@ -3062,2 +3031,5 @@\n-      Node* cast = new CheckCastPPNode(control(), receiver, recv_type);\n-      (*casted_receiver) = _gvn.transform(cast);\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), receiver, recv_type));\n+      if (recv_type->is_inlinetypeptr()) {\n+        cast = InlineTypeNode::make_from_oop(this, cast, recv_type->inline_klass());\n+      }\n+      (*casted_receiver) = cast;\n@@ -3293,1 +3265,0 @@\n-  bool is_value = obj->is_InlineType();\n@@ -3297,5 +3268,0 @@\n-  if (is_value) {\n-    \/\/ TODO 8284443 Enable this\n-    safe_for_replace = false;\n-    never_see_null = false;\n-  }\n@@ -3320,9 +3286,7 @@\n-  if (!is_value) {\n-    bool known_statically = false;\n-    if (_gvn.type(superklass)->singleton()) {\n-      const TypeKlassPtr* superk = _gvn.type(superklass)->is_klassptr();\n-      const TypeKlassPtr* subk = _gvn.type(obj)->is_oopptr()->as_klass_type();\n-      if (subk != NULL && subk->is_loaded()) {\n-        int static_res = C->static_subtype_check(superk, subk);\n-        known_statically = (static_res == Compile::SSC_always_true || static_res == Compile::SSC_always_false);\n-      }\n+  bool known_statically = false;\n+  if (_gvn.type(superklass)->singleton()) {\n+    const TypeKlassPtr* superk = _gvn.type(superklass)->is_klassptr();\n+    const TypeKlassPtr* subk = _gvn.type(obj)->is_oopptr()->as_klass_type();\n+    if (subk != NULL && subk->is_loaded()) {\n+      int static_res = C->static_subtype_check(superk, subk);\n+      known_statically = (static_res == Compile::SSC_always_true || static_res == Compile::SSC_always_false);\n@@ -3330,0 +3294,1 @@\n+  }\n@@ -3331,15 +3296,13 @@\n-    if (!known_statically) {\n-      const TypeOopPtr* obj_type = _gvn.type(obj)->is_oopptr();\n-      \/\/ We may not have profiling here or it may not help us. If we\n-      \/\/ have a speculative type use it to perform an exact cast.\n-      ciKlass* spec_obj_type = obj_type->speculative_type();\n-      if (spec_obj_type != NULL || (ProfileDynamicTypes && data != NULL)) {\n-        Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);\n-        if (stopped()) {            \/\/ Profile disagrees with this path.\n-          set_control(null_ctl);    \/\/ Null is the only remaining possibility.\n-          return intcon(0);\n-        }\n-        if (cast_obj != NULL) {\n-          not_null_obj = cast_obj;\n-          is_value = not_null_obj->is_InlineType();\n-        }\n+  if (!known_statically) {\n+    const TypeOopPtr* obj_type = _gvn.type(obj)->is_oopptr();\n+    \/\/ We may not have profiling here or it may not help us. If we\n+    \/\/ have a speculative type use it to perform an exact cast.\n+    ciKlass* spec_obj_type = obj_type->speculative_type();\n+    if (spec_obj_type != NULL || (ProfileDynamicTypes && data != NULL)) {\n+      Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);\n+      if (stopped()) {            \/\/ Profile disagrees with this path.\n+        set_control(null_ctl);    \/\/ Null is the only remaining possibility.\n+        return intcon(0);\n+      }\n+      if (cast_obj != NULL) {\n+        not_null_obj = cast_obj;\n@@ -3368,1 +3331,1 @@\n-  if (safe_for_replace && !is_value) {\n+  if (safe_for_replace) {\n@@ -3388,1 +3351,0 @@\n-  bool from_inline = obj->is_InlineType();\n@@ -3402,1 +3364,1 @@\n-    } else if (obj->is_InlineTypeBase()) {\n+    } else if (obj->is_InlineType()) {\n@@ -3412,3 +3374,1 @@\n-        if (!from_inline) {\n-          obj = record_profiled_receiver_for_speculation(obj);\n-        }\n+        obj = record_profiled_receiver_for_speculation(obj);\n@@ -3419,1 +3379,1 @@\n-        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineTypeBase(), \"should have been scalarized\");\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType(), \"should have been scalarized\");\n@@ -3473,3 +3433,0 @@\n-  } else if (from_inline) {\n-    \/\/ TODO 8284443 obj can be null and null should pass\n-    not_null_obj = obj;\n@@ -3484,1 +3441,1 @@\n-      return InlineTypePtrNode::make_null(_gvn, toop->inline_klass());\n+      return InlineTypeNode::make_null(_gvn, toop->inline_klass());\n@@ -3499,1 +3456,1 @@\n-  if (!from_inline && tk->klass_is_exact()) {\n+  if (tk->klass_is_exact()) {\n@@ -3524,1 +3481,1 @@\n-    cast_obj = from_inline ? not_null_obj : _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));\n+    cast_obj = _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));\n@@ -3531,1 +3488,1 @@\n-        if (not_null_obj->is_InlineTypeBase()) {\n+        if (not_null_obj->is_InlineType()) {\n@@ -3603,1 +3560,1 @@\n-  if (!stopped() && !res->is_InlineTypeBase()) {\n+  if (!stopped() && !res->is_InlineType()) {\n@@ -3609,3 +3566,0 @@\n-        if (vt->is_InlineType() && C->inlining_incrementally()) {\n-          vt = vt->as_InlineType()->as_ptr(&_gvn);\n-        }\n@@ -3827,1 +3781,1 @@\n-  assert(!obj->is_InlineTypeBase(), \"should not unlock on inline type\");\n+  assert(!obj->is_InlineType(), \"should not unlock on inline type\");\n@@ -4039,1 +3993,1 @@\n-                             InlineTypeBaseNode* inline_type_node) {\n+                             InlineTypeNode* inline_type_node) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":48,"deletions":94,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -701,2 +701,0 @@\n-    \/\/ TODO Remove this code once InlineTypeNodes are replaced by InlineTypePtrNodes\n-    set_argument(0, n);\n@@ -704,14 +702,0 @@\n-    \/\/ Scalarize inline type receiver\n-    const Type* recv_type = gvn().type(n);\n-    if (recv_type->is_inlinetypeptr()) {\n-      assert(!recv_type->maybe_null(), \"should never be null\");\n-      Node* vt = InlineTypeNode::make_from_oop(this, n, recv_type->inline_klass());\n-      set_argument(0, vt);\n-      if (replace_value && is_Parse()) {\n-        \/\/ Only replace in map if we are not incrementally inlining because we\n-        \/\/ share a map with the caller which might expect the inline type as oop.\n-        assert(!Compile::current()->inlining_incrementally(), \"sanity\");\n-        replace_in_map(n, vt);\n-      }\n-      n = vt;\n-    }\n@@ -894,1 +878,1 @@\n-                     InlineTypeBaseNode* inline_type_node = NULL);\n+                     InlineTypeNode* inline_type_node = NULL);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,12 @@\n+uint InlineTypeNode::size_of() const {\n+  return sizeof(*this);\n+}\n+\n+uint InlineTypeNode::hash() const {\n+  return TypeNode::hash() + _is_buffered;\n+}\n+\n+bool InlineTypeNode::cmp(const Node& n) const {\n+  return TypeNode::cmp(n) && ((InlineTypeNode&)n)._is_buffered == _is_buffered;\n+}\n+\n@@ -38,3 +50,3 @@\n-InlineTypeBaseNode* InlineTypeBaseNode::clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init) {\n-  InlineTypeBaseNode* vt = clone()->as_InlineTypeBase();\n-  if (vt->is_InlineTypePtr()) {\n+InlineTypeNode* InlineTypeNode::clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init) {\n+  InlineTypeNode* vt = clone()->as_InlineType();\n+  if (vt->is_InlineType()) {\n@@ -44,1 +56,1 @@\n-    vt->as_InlineTypePtr()->set_type(t);\n+    vt->as_InlineType()->set_type(t);\n@@ -70,1 +82,1 @@\n-    if (value->is_InlineTypeBase()) {\n+    if (value->is_InlineType()) {\n@@ -72,1 +84,1 @@\n-      value = value->as_InlineTypeBase()->clone_with_phis(gvn, region);\n+      value = value->as_InlineType()->clone_with_phis(gvn, region);\n@@ -86,3 +98,3 @@\n-\/\/ Checks if the inputs of the InlineTypeBaseTypeNode were replaced by PhiNodes\n-\/\/ for the given region (see InlineTypeBaseTypeNode::clone_with_phis).\n-bool InlineTypeBaseNode::has_phi_inputs(Node* region) {\n+\/\/ Checks if the inputs of the InlineTypeNode were replaced by PhiNodes\n+\/\/ for the given region (see InlineTypeNode::clone_with_phis).\n+bool InlineTypeNode::has_phi_inputs(Node* region) {\n@@ -96,2 +108,2 @@\n-      if (n->is_InlineTypeBase()) {\n-        assert(n->as_InlineTypeBase()->has_phi_inputs(region), \"inconsistent phi inputs\");\n+      if (n->is_InlineType()) {\n+        assert(n->as_InlineType()->has_phi_inputs(region), \"inconsistent phi inputs\");\n@@ -107,13 +119,0 @@\n-\/\/ Check if all inline type fields have inline type node values\n-bool InlineTypeBaseNode::can_merge() {\n-  for (uint i = 0; i < field_count(); ++i) {\n-    ciType* type = field_type(i);\n-    Node* val = field_value(i);\n-    if (type->is_inlinetype() &&\n-        (!val->is_InlineTypeBase() || !val->as_InlineTypeBase()->can_merge())) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -121,1 +120,2 @@\n-InlineTypeBaseNode* InlineTypeBaseNode::merge_with(PhaseGVN* gvn, const InlineTypeBaseNode* other, int pnum, bool transform) {\n+InlineTypeNode* InlineTypeNode::merge_with(PhaseGVN* gvn, const InlineTypeNode* other, int pnum, bool transform) {\n+  _is_buffered = _is_buffered && other->_is_buffered;\n@@ -144,2 +144,2 @@\n-    if (val1->is_InlineTypeBase()) {\n-      val1->as_InlineTypeBase()->merge_with(gvn, val2->as_InlineTypeBase(), pnum, transform);\n+    if (val1->is_InlineType()) {\n+      val1->as_InlineType()->merge_with(gvn, val2->as_InlineType(), pnum, transform);\n@@ -158,1 +158,1 @@\n-void InlineTypeBaseNode::add_new_path(Node* region) {\n+void InlineTypeNode::add_new_path(Node* region) {\n@@ -171,2 +171,2 @@\n-    if (val->is_InlineTypeBase()) {\n-      val->as_InlineTypeBase()->add_new_path(region);\n+    if (val->is_InlineType()) {\n+      val->as_InlineType()->add_new_path(region);\n@@ -180,1 +180,1 @@\n-Node* InlineTypeBaseNode::field_value(uint index) const {\n+Node* InlineTypeNode::field_value(uint index) const {\n@@ -187,1 +187,1 @@\n-Node* InlineTypeBaseNode::field_value_by_offset(int offset, bool recursive) const {\n+Node* InlineTypeNode::field_value_by_offset(int offset, bool recursive) const {\n@@ -194,1 +194,1 @@\n-  if (recursive && value->is_InlineTypeBase()) {\n+  if (recursive && value->is_InlineType()) {\n@@ -197,1 +197,1 @@\n-      InlineTypeBaseNode* vt = value->as_InlineTypeBase();\n+      InlineTypeNode* vt = value->as_InlineType();\n@@ -205,1 +205,1 @@\n-  assert(!(recursive && value->is_InlineTypeBase()), \"should not be an inline type\");\n+  assert(!(recursive && value->is_InlineType()), \"should not be an inline type\");\n@@ -210,1 +210,1 @@\n-void InlineTypeBaseNode::set_field_value(uint index, Node* value) {\n+void InlineTypeNode::set_field_value(uint index, Node* value) {\n@@ -215,1 +215,1 @@\n-void InlineTypeBaseNode::set_field_value_by_offset(int offset, Node* value) {\n+void InlineTypeNode::set_field_value_by_offset(int offset, Node* value) {\n@@ -219,1 +219,1 @@\n-int InlineTypeBaseNode::field_offset(uint index) const {\n+int InlineTypeNode::field_offset(uint index) const {\n@@ -224,1 +224,1 @@\n-uint InlineTypeBaseNode::field_index(int offset) const {\n+uint InlineTypeNode::field_index(int offset) const {\n@@ -231,1 +231,1 @@\n-ciType* InlineTypeBaseNode::field_type(uint index) const {\n+ciType* InlineTypeNode::field_type(uint index) const {\n@@ -236,1 +236,1 @@\n-bool InlineTypeBaseNode::field_is_flattened(uint index) const {\n+bool InlineTypeNode::field_is_flattened(uint index) const {\n@@ -243,1 +243,1 @@\n-bool InlineTypeBaseNode::field_is_null_free(uint index) const {\n+bool InlineTypeNode::field_is_null_free(uint index) const {\n@@ -250,1 +250,1 @@\n-void InlineTypeBaseNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List& worklist, SafePointNode* sfpt) {\n+void InlineTypeNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List& worklist, SafePointNode* sfpt) {\n@@ -257,1 +257,1 @@\n-  SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(inline_ptr(),\n+  SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(type()->isa_instptr(),\n@@ -275,1 +275,1 @@\n-    if (value->is_InlineTypeBase()) {\n+    if (value->is_InlineType()) {\n@@ -292,1 +292,1 @@\n-void InlineTypeBaseNode::make_scalar_in_safepoints(PhaseIterGVN* igvn, bool allow_oop) {\n+void InlineTypeNode::make_scalar_in_safepoints(PhaseIterGVN* igvn, bool allow_oop) {\n@@ -296,1 +296,1 @@\n-  bool use_oop = allow_oop && (is_InlineTypePtr() || is_allocated(igvn)) &&\n+  bool use_oop = allow_oop && is_allocated(igvn) &&\n@@ -333,1 +333,1 @@\n-    InlineTypeBaseNode* vt = vt_worklist.at(i)->isa_InlineTypeBase();\n+    InlineTypeNode* vt = vt_worklist.at(i)->isa_InlineType();\n@@ -341,1 +341,1 @@\n-const TypePtr* InlineTypeBaseNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN& gvn) const {\n+const TypePtr* InlineTypeNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN& gvn) const {\n@@ -358,1 +358,1 @@\n-void InlineTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n+void InlineTypeNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n@@ -412,1 +412,1 @@\n-void InlineTypeBaseNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n+void InlineTypeNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n@@ -425,1 +425,1 @@\n-void InlineTypeBaseNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n+void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n@@ -433,1 +433,1 @@\n-      if (!value->is_InlineTypeBase()) {\n+      if (!value->is_InlineType()) {\n@@ -436,1 +436,1 @@\n-      value->as_InlineTypeBase()->store_flattened(kit, base, ptr, holder, offset, decorators);\n+      value->as_InlineType()->store_flattened(kit, base, ptr, holder, offset, decorators);\n@@ -453,2 +453,5 @@\n-InlineTypePtrNode* InlineTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {\n-  assert(is_InlineType(), \"sanity\");\n+InlineTypeNode* InlineTypeNode::buffer(GraphKit* kit, bool safe_for_replace) {\n+  if (_is_buffered) {\n+    \/\/ Already buffered\n+    return this;\n+  }\n@@ -461,1 +464,3 @@\n-    InlineTypePtrNode* ptr = as_ptr(&kit->gvn(), false);\n+    InlineTypeNode* vt = clone()->as_InlineType();\n+    vt->_is_buffered = true;\n+    vt = kit->gvn().transform(vt)->as_InlineType();\n@@ -463,1 +468,1 @@\n-      kit->replace_in_map(this, ptr);\n+      kit->replace_in_map(this, vt);\n@@ -465,1 +470,1 @@\n-    return ptr;\n+    return vt;\n@@ -476,1 +481,1 @@\n-  PhiNode* oop = PhiNode::make(region, not_null_oop, inline_ptr()->join_speculative(null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM));\n+  PhiNode* oop = PhiNode::make(region, not_null_oop, type()->join_speculative(null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM));\n@@ -530,1 +535,2 @@\n-  InlineTypeBaseNode* vt = clone()->as_InlineTypeBase();\n+  InlineTypeNode* vt = clone()->as_InlineType();\n+  vt->_is_buffered = true;\n@@ -532,1 +538,1 @@\n-  vt = kit->gvn().transform(vt)->as_InlineTypeBase();\n+  vt = kit->gvn().transform(vt)->as_InlineType();\n@@ -539,1 +545,1 @@\n-  return vt->as_ptr(&kit->gvn(), null_free);\n+  return vt;\n@@ -542,1 +548,4 @@\n-bool InlineTypeBaseNode::is_allocated(PhaseGVN* phase) const {\n+bool InlineTypeNode::is_allocated(PhaseGVN* phase) const {\n+  if (_is_buffered) {\n+    return true;\n+  }\n@@ -548,8 +557,0 @@\n-InlineTypePtrNode* InlineTypeBaseNode::as_ptr(PhaseGVN* phase, bool null_free) const {\n-  assert(!null_free || is_allocated(phase), \"must be allocated\");\n-  if (is_InlineTypePtr()) {\n-    return as_InlineTypePtr();\n-  }\n-  return phase->transform(new InlineTypePtrNode(this, null_free))->as_InlineTypePtr();\n-}\n-\n@@ -560,1 +561,1 @@\n-void InlineTypeBaseNode::replace_call_results(GraphKit* kit, CallNode* call, Compile* C, bool null_free) {\n+void InlineTypeNode::replace_call_results(GraphKit* kit, CallNode* call, Compile* C, bool null_free) {\n@@ -582,4 +583,0 @@\n-      if (field->is_InlineType()) {\n-        assert(field->as_InlineType()->is_allocated(&kit->gvn()), \"must be allocated\");\n-        field = field->as_InlineType()->get_oop();\n-      }\n@@ -596,2 +593,2 @@\n-Node* InlineTypeBaseNode::allocate_fields(GraphKit* kit) {\n-  InlineTypeBaseNode* vt = clone()->as_InlineTypeBase();\n+Node* InlineTypeNode::allocate_fields(GraphKit* kit) {\n+  InlineTypeNode* vt = clone()->as_InlineType();\n@@ -602,1 +599,1 @@\n-       vt->set_field_value(i, value->as_InlineTypeBase()->allocate_fields(kit));\n+       vt->set_field_value(i, value->as_InlineType()->allocate_fields(kit));\n@@ -608,1 +605,1 @@\n-  vt = kit->gvn().transform(vt)->as_InlineTypeBase();\n+  vt = kit->gvn().transform(vt)->as_InlineType();\n@@ -613,5 +610,24 @@\n-Node* InlineTypeBaseNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  Node* is_init = get_is_init();\n-  if (is_init->isa_InlineTypePtr()) {\n-    set_req(IsInit, is_init->as_InlineTypePtr()->get_is_init());\n-    return this;\n+\/\/ Replace a buffer allocation by a dominating allocation\n+static void replace_allocation(PhaseIterGVN* igvn, Node* res, Node* dom) {\n+  \/\/ Remove initializing stores and GC barriers\n+  for (DUIterator_Fast imax, i = res->fast_outs(imax); i < imax; i++) {\n+    Node* use = res->fast_out(i);\n+    if (use->is_AddP()) {\n+      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n+        Node* store = use->fast_out(j)->isa_Store();\n+        if (store != NULL) {\n+          igvn->rehash_node_delayed(store);\n+          igvn->replace_in_uses(store, store->in(MemNode::Memory));\n+        }\n+      }\n+    } else if (use->Opcode() == Op_CastP2X) {\n+      if (UseG1GC && use->find_out_with(Op_XorX)->in(1) != use) {\n+        \/\/ The G1 pre-barrier uses a CastP2X both for the pointer of the object\n+        \/\/ we store into, as well as the value we are storing. Skip if this is a\n+        \/\/ barrier for storing 'res' into another object.\n+        continue;\n+      }\n+      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+      bs->eliminate_gc_barrier(igvn, use);\n+      --i; --imax;\n+    }\n@@ -619,0 +635,4 @@\n+  igvn->replace_node(res, dom);\n+}\n+\n+Node* InlineTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -620,2 +640,9 @@\n-  if (oop->isa_InlineTypePtr() && !phase->type(oop)->maybe_null()) {\n-    InlineTypePtrNode* vtptr = oop->as_InlineTypePtr();\n+  if (is_default(phase) && inline_klass()->is_initialized() &&\n+      (!oop->is_Con() || phase->type(oop)->is_zero_type())) {\n+    \/\/ Use the pre-allocated oop for default inline types\n+    set_oop(default_oop(*phase, inline_klass()));\n+    assert(is_allocated(phase), \"should now be allocated\");\n+    return this;\n+  }\n+  if (oop->isa_InlineType() && !phase->type(oop)->maybe_null()) {\n+    InlineTypeNode* vtptr = oop->as_InlineType();\n@@ -629,0 +656,34 @@\n+  if (!is_allocated(phase)) {\n+    \/\/ Save base oop if fields are loaded from memory and the inline\n+    \/\/ type is not buffered (in this case we should not use the oop).\n+    Node* base = is_loaded(phase);\n+    if (base != NULL && !phase->type(base)->maybe_null()) {\n+      set_oop(base);\n+      assert(is_allocated(phase), \"should now be allocated\");\n+      return this;\n+    }\n+  }\n+\n+  if (can_reshape) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    if (is_allocated(phase)) {\n+      \/\/ Search for and remove re-allocations of this inline type. Ignore scalar replaceable ones,\n+      \/\/ they will be removed anyway and changing the memory chain will confuse other optimizations.\n+      \/\/ This can happen with late inlining when we first allocate an inline type argument\n+      \/\/ but later decide to inline the call after the callee code also triggered allocation.\n+      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+        AllocateNode* alloc = fast_out(i)->isa_Allocate();\n+        if (alloc != NULL && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+          \/\/ Found a re-allocation\n+          Node* res = alloc->result_cast();\n+          if (res != NULL && res->is_CheckCastPP()) {\n+            \/\/ Replace allocation by oop and unlink AllocateNode\n+            replace_allocation(igvn, res, oop);\n+            igvn->replace_input_of(alloc, AllocateNode::InlineType, igvn->C->top());\n+            --i; --imax;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n@@ -632,1 +693,1 @@\n-InlineTypeNode* InlineTypeNode::make_uninitialized(PhaseGVN& gvn, ciInlineKlass* vk) {\n+InlineTypeNode* InlineTypeNode::make_uninitialized(PhaseGVN& gvn, ciInlineKlass* vk, bool null_free) {\n@@ -635,1 +696,1 @@\n-  InlineTypeNode* vt = new InlineTypeNode(vk, oop);\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop, null_free, vk->is_empty() && vk->is_initialized());\n@@ -640,1 +701,1 @@\n-Node* InlineTypeBaseNode::default_oop(PhaseGVN& gvn, ciInlineKlass* vk) {\n+Node* InlineTypeNode::default_oop(PhaseGVN& gvn, ciInlineKlass* vk) {\n@@ -648,1 +709,1 @@\n-  InlineTypeNode* vt = new InlineTypeNode(vk, oop);\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop, true, vk->is_initialized());\n@@ -658,1 +719,1 @@\n-        value = InlineTypePtrNode::make_null(gvn, vk);\n+        value = InlineTypeNode::make_null(gvn, vk);\n@@ -668,19 +729,1 @@\n-InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n-  InlineTypeNode* vt = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT));\n-  vt->set_req(IsInit, gvn.intcon(0));\n-  for (uint i = 0; i < vt->field_count(); i++) {\n-    ciType* field_type = vt->field_type(i);\n-    Node* value = gvn.zerocon(field_type->basic_type());\n-    if (field_type->is_inlinetype()) {\n-      if (vt->field_is_null_free(i)) {\n-        value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());\n-      } else {\n-        value = InlineTypePtrNode::make_null(gvn, field_type->as_inline_klass());\n-      }\n-    }\n-    vt->set_field_value(i, value);\n-  }\n-  return gvn.transform(vt)->as_InlineType();\n-}\n-\n-bool InlineTypeBaseNode::is_default(PhaseGVN* gvn) const {\n+bool InlineTypeNode::is_default(PhaseGVN* gvn) const {\n@@ -692,0 +735,1 @@\n+    ciType* ft = field_type(i);\n@@ -693,2 +737,7 @@\n-    if (value->is_InlineTypePtr()) {\n-      value = value->as_InlineTypePtr()->get_oop();\n+    if (field_is_null_free(i)) {\n+      if (!value->is_InlineType() || !value->as_InlineType()->is_default(gvn)) {\n+        return false;\n+      }\n+      continue;\n+    } else if (value->is_InlineType()) {\n+      value = value->as_InlineType()->get_oop();\n@@ -696,2 +745,1 @@\n-    if (!gvn->type(value)->is_zero_type() &&\n-        !(field_is_null_free(i) && value->is_InlineType() && value->as_InlineType()->is_default(gvn))) {\n+    if (!gvn->type(value)->is_zero_type()) {\n@@ -704,1 +752,1 @@\n-InlineTypeBaseNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free) {\n+InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free) {\n@@ -714,1 +762,1 @@\n-  InlineTypeBaseNode* vt = NULL;\n+  InlineTypeNode* vt = NULL;\n@@ -716,2 +764,2 @@\n-  if (oop->isa_InlineTypePtr()) {\n-    return oop->as_InlineTypePtr();\n+  if (oop->isa_InlineType()) {\n+    return oop->as_InlineType();\n@@ -728,1 +776,1 @@\n-        vt = InlineTypePtrNode::make_null(gvn, vk);\n+        vt = InlineTypeNode::make_null(gvn, vk);\n@@ -733,1 +781,1 @@\n-    vt = new InlineTypePtrNode(vk, not_null_oop, null_free);\n+    vt = new InlineTypeNode(vk, not_null_oop, null_free, true);\n@@ -738,1 +786,1 @@\n-      InlineTypeBaseNode* null_vt = NULL;\n+      InlineTypeNode* null_vt = NULL;\n@@ -740,1 +788,1 @@\n-        null_vt = make_default(gvn, vk)->as_ptr(&gvn);\n+        null_vt = make_default(gvn, vk);\n@@ -742,1 +790,1 @@\n-        null_vt = InlineTypePtrNode::make_null(gvn, vk);\n+        null_vt = InlineTypeNode::make_null(gvn, vk);\n@@ -757,1 +805,1 @@\n-    vt = new InlineTypePtrNode(vk, oop, \/* null_free= *\/ true);\n+    vt = new InlineTypeNode(vk, oop, \/* null_free= *\/ true, true);\n@@ -761,2 +809,2 @@\n-\/\/ TODO fix with JDK-8278390\n-\/\/    assert(!null_free || vt->as_InlineType()->is_default(&gvn) || init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineTypePtr ||\n+\/\/ TODO 8284443\n+\/\/    assert(!null_free || vt->as_InlineType()->is_default(&gvn) || init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineType ||\n@@ -767,1 +815,1 @@\n-  return gvn.transform(vt)->as_InlineTypeBase();\n+  return gvn.transform(vt)->as_InlineType();\n@@ -786,2 +834,2 @@\n-InlineTypeBaseNode* InlineTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in, bool null_free) {\n-  InlineTypeNode* vt = make_uninitialized(kit->gvn(), vk);\n+InlineTypeNode* InlineTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in, bool null_free) {\n+  InlineTypeNode* vt = make_uninitialized(kit->gvn(), vk, null_free);\n@@ -794,1 +842,1 @@\n-  return kit->gvn().transform(vt)->as_InlineTypeBase();\n+  return kit->gvn().transform(vt)->as_InlineType();\n@@ -797,1 +845,1 @@\n-InlineTypeNode* InlineTypeBaseNode::make_larval(GraphKit* kit, bool allocate) const {\n+InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {\n@@ -816,1 +864,2 @@\n-  res->set_type(TypeInlineType::make(vk, true));\n+  \/\/ TODO 8239003\n+  \/\/res->set_type(TypeInlineType::make(vk, true));\n@@ -822,1 +871,1 @@\n-InlineTypeNode* InlineTypeBaseNode::finish_larval(GraphKit* kit) const {\n+InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit) const {\n@@ -840,1 +889,2 @@\n-  res->set_type(TypeInlineType::make(vk, false));\n+  \/\/ TODO 8239003\n+  \/\/res->set_type(TypeInlineType::make(vk, false));\n@@ -862,2 +912,2 @@\n-    if (value->is_InlineTypeBase()) {\n-      InlineTypeBaseNode* vt = value->as_InlineTypeBase();\n+    if (value->is_InlineType()) {\n+      InlineTypeNode* vt = value->as_InlineType();\n@@ -906,1 +956,1 @@\n-Node* InlineTypeBaseNode::tagged_klass(ciInlineKlass* vk, PhaseGVN& gvn) {\n+Node* InlineTypeNode::tagged_klass(ciInlineKlass* vk, PhaseGVN& gvn) {\n@@ -913,1 +963,1 @@\n-void InlineTypeBaseNode::pass_fields(GraphKit* kit, Node* n, uint& base_input, bool in, bool null_free) {\n+void InlineTypeNode::pass_fields(GraphKit* kit, Node* n, uint& base_input, bool in, bool null_free) {\n@@ -921,1 +971,1 @@\n-      arg->as_InlineTypeBase()->pass_fields(kit, n, base_input, in);\n+      arg->as_InlineType()->pass_fields(kit, n, base_input, in);\n@@ -1020,75 +1070,0 @@\n-\/\/ Replace a buffer allocation by a dominating allocation\n-static void replace_allocation(PhaseIterGVN* igvn, Node* res, Node* dom) {\n-  \/\/ Remove initializing stores and GC barriers\n-  for (DUIterator_Fast imax, i = res->fast_outs(imax); i < imax; i++) {\n-    Node* use = res->fast_out(i);\n-    if (use->is_AddP()) {\n-      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n-        Node* store = use->fast_out(j)->isa_Store();\n-        if (store != NULL) {\n-          igvn->rehash_node_delayed(store);\n-          igvn->replace_in_uses(store, store->in(MemNode::Memory));\n-        }\n-      }\n-    } else if (use->Opcode() == Op_CastP2X) {\n-      if (UseG1GC && use->find_out_with(Op_XorX)->in(1) != use) {\n-        \/\/ The G1 pre-barrier uses a CastP2X both for the pointer of the object\n-        \/\/ we store into, as well as the value we are storing. Skip if this is a\n-        \/\/ barrier for storing 'res' into another object.\n-        continue;\n-      }\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      bs->eliminate_gc_barrier(igvn, use);\n-      --i; --imax;\n-    }\n-  }\n-  igvn->replace_node(res, dom);\n-}\n-\n-Node* InlineTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  Node* oop = get_oop();\n-  if (is_default(phase) && inline_klass()->is_initialized() &&\n-      (!oop->is_Con() || phase->type(oop)->is_zero_type())) {\n-    \/\/ Use the pre-allocated oop for default inline types\n-    set_oop(default_oop(*phase, inline_klass()));\n-    assert(is_allocated(phase), \"should now be allocated\");\n-    return this;\n-  }\n-\n-  if (!is_allocated(phase)) {\n-    \/\/ Save base oop if fields are loaded from memory and the inline\n-    \/\/ type is not buffered (in this case we should not use the oop).\n-    Node* base = is_loaded(phase);\n-    if (base != NULL && !phase->type(base)->maybe_null()) {\n-      set_oop(base);\n-      assert(is_allocated(phase), \"should now be allocated\");\n-      return this;\n-    }\n-  }\n-\n-  if (can_reshape) {\n-    PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-    if (is_allocated(phase)) {\n-      \/\/ Search for and remove re-allocations of this inline type. Ignore scalar replaceable ones,\n-      \/\/ they will be removed anyway and changing the memory chain will confuse other optimizations.\n-      \/\/ This can happen with late inlining when we first allocate an inline type argument\n-      \/\/ but later decide to inline the call after the callee code also triggered allocation.\n-      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-        AllocateNode* alloc = fast_out(i)->isa_Allocate();\n-        if (alloc != NULL && alloc->in(AllocateNode::InlineTypeNode) == this && !alloc->_is_scalar_replaceable) {\n-          \/\/ Found a re-allocation\n-          Node* res = alloc->result_cast();\n-          if (res != NULL && res->is_CheckCastPP()) {\n-            \/\/ Replace allocation by oop and unlink AllocateNode\n-            replace_allocation(igvn, res, oop);\n-            igvn->replace_input_of(alloc, AllocateNode::InlineTypeNode, igvn->C->top());\n-            --i; --imax;\n-          }\n-        }\n-      }\n-    }\n-  }\n-  return InlineTypeBaseNode::Ideal(phase, can_reshape);\n-}\n-\n@@ -1096,1 +1071,3 @@\n-void InlineTypeNode::remove_redundant_allocations(PhaseIterGVN* igvn, PhaseIdealLoop* phase) {\n+\/\/ Equivalent InlineTypeNodes are merged by GVN, so we just need to search for AllocateNode users to find redundant allocations.\n+void InlineTypeNode::remove_redundant_allocations(PhaseIdealLoop* phase) {\n+  PhaseIterGVN* igvn = &phase->igvn();\n@@ -1101,1 +1078,1 @@\n-    if (alloc != NULL && alloc->in(AllocateNode::InlineTypeNode) == this && !alloc->_is_scalar_replaceable) {\n+    if (alloc != NULL && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n@@ -1111,1 +1088,1 @@\n-        if (alloc_other != NULL && alloc_other->in(AllocateNode::InlineTypeNode) == this && !alloc_other->_is_scalar_replaceable) {\n+        if (alloc_other != NULL && alloc_other->in(AllocateNode::InlineType) == this && !alloc_other->_is_scalar_replaceable) {\n@@ -1128,15 +1105,0 @@\n-\n-  \/\/ Process users\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    Node* out = fast_out(i);\n-    if (out->is_InlineType()) {\n-      \/\/ Recursively process inline type users\n-      igvn->rehash_node_delayed(out);\n-      out->as_InlineType()->remove_redundant_allocations(igvn, phase);\n-    } else if (out->isa_Allocate() != NULL) {\n-      \/\/ Unlink AllocateNode\n-      assert(out->in(AllocateNode::InlineTypeNode) == this, \"should be linked\");\n-      igvn->replace_input_of(out, AllocateNode::InlineTypeNode, igvn->C->top());\n-      --i; --imax;\n-    }\n-  }\n@@ -1145,2 +1107,2 @@\n-InlineTypePtrNode* InlineTypePtrNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n-  InlineTypePtrNode* ptr = new InlineTypePtrNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ false);\n+InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n+  InlineTypeNode* ptr = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ false, true);\n@@ -1152,5 +1114,1 @@\n-      if (ptr->field_is_null_free(i)) {\n-        value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());\n-      } else {\n-        value = InlineTypePtrNode::make_null(gvn, field_type->as_inline_klass());\n-      }\n+      value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());\n@@ -1160,1 +1118,1 @@\n-  return gvn.transform(ptr)->as_InlineTypePtr();\n+  return gvn.transform(ptr)->as_InlineType();\n@@ -1163,2 +1121,2 @@\n-Node* InlineTypePtrNode::Identity(PhaseGVN* phase) {\n-  if (get_oop()->is_InlineTypePtr()) {\n+Node* InlineTypeNode::Identity(PhaseGVN* phase) {\n+  if (get_oop()->is_InlineType()) {\n@@ -1170,2 +1128,10 @@\n-const Type* InlineTypePtrNode::Value(PhaseGVN* phase) const {\n-  const Type* t = phase->type(get_oop())->filter_speculative(_type);\n+const Type* InlineTypeNode::Value(PhaseGVN* phase) const {\n+  const Type* toop = phase->type(get_oop());\n+#ifdef ASSERT\n+  if (toop->is_zero_type() && _type->isa_oopptr()->is_known_instance()) {\n+    \/\/ We are not allocated (anymore) and should therefore not have an instance id\n+    dump(1);\n+    assert(false, \"Unbuffered inline type should not have known instance id\");\n+  }\n+#endif\n+  const Type* t = toop->filter_speculative(_type);\n@@ -1173,1 +1139,1 @@\n-    \/\/ Don't replace InlineTypePtr by a constant\n+    \/\/ Don't replace InlineType by a constant\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":214,"deletions":248,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,3 @@\n-class InlineTypeBaseNode : public TypeNode {\n+\/\/------------------------------InlineTypeNode-------------------------------------\n+\/\/ Node representing an inline type in C2 IR\n+class InlineTypeNode : public TypeNode {\n@@ -36,3 +38,9 @@\n-  InlineTypeBaseNode(const Type* t, int nb_fields)\n-    : TypeNode(t, nb_fields) {\n-    init_class_id(Class_InlineTypeBase);\n+  virtual uint hash() const;\n+  virtual bool cmp(const Node &n) const;\n+  virtual uint size_of() const;\n+  bool _is_buffered;\n+\n+  InlineTypeNode(ciInlineKlass* vk, Node* oop, bool null_free, bool is_buffered)\n+      : TypeNode(TypeInstPtr::make(null_free ? TypePtr::NotNull : TypePtr::BotPTR, vk), Values + vk->nof_declared_nonstatic_fields()), _is_buffered(is_buffered) {\n+    init_class_id(Class_InlineType);\n+    init_req(Oop, oop);\n@@ -49,1 +57,0 @@\n-  virtual const TypeInstPtr* inline_ptr() const = 0;\n@@ -60,0 +67,6 @@\n+  \/\/ Checks if the inline type is loaded from memory and if so returns the oop\n+  Node* is_loaded(PhaseGVN* phase, ciInlineKlass* vk = NULL, Node* base = NULL, int holder_offset = 0);\n+\n+  \/\/ Initialize the inline type fields with the inputs or outputs of a MultiNode\n+  void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free = true, Node* null_check_region = NULL);\n+\n@@ -62,0 +75,13 @@\n+  \/\/ Create with default field values\n+  static InlineTypeNode* make_default(PhaseGVN& gvn, ciInlineKlass* vk);\n+  \/\/ Create uninitialized\n+  static InlineTypeNode* make_uninitialized(PhaseGVN& gvn, ciInlineKlass* vk, bool null_free = true);\n+  \/\/ Create and initialize by loading the field values from an oop\n+  static InlineTypeNode* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free = true);\n+  \/\/ Create and initialize by loading the field values from a flattened field or array\n+  static InlineTypeNode* make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = NULL, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n+  \/\/ Create and initialize with the inputs or outputs of a MultiNode (method entry or call)\n+  static InlineTypeNode* make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in, bool null_free = true);\n+\n+  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk);\n+\n@@ -67,3 +93,2 @@\n-  InlineTypeBaseNode* clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init = false);\n-  bool can_merge();\n-  InlineTypeBaseNode* merge_with(PhaseGVN* gvn, const InlineTypeBaseNode* other, int pnum, bool transform);\n+  InlineTypeNode* clone_with_phis(PhaseGVN* gvn, Node* region, bool is_init = false);\n+  InlineTypeNode* merge_with(PhaseGVN* gvn, const InlineTypeNode* other, int pnum, bool transform);\n@@ -101,1 +126,1 @@\n-  InlineTypePtrNode* buffer(GraphKit* kit, bool safe_for_replace = true);\n+  InlineTypeNode* buffer(GraphKit* kit, bool safe_for_replace = true);\n@@ -103,1 +128,0 @@\n-  InlineTypePtrNode* as_ptr(PhaseGVN* phase, bool null_free = true) const;\n@@ -120,37 +144,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-};\n-\n-\/\/------------------------------InlineTypeNode-------------------------------------\n-\/\/ Node representing an inline type in C2 IR\n-class InlineTypeNode : public InlineTypeBaseNode {\n-  friend class InlineTypeBaseNode;\n-  friend class InlineTypePtrNode;\n-private:\n-  InlineTypeNode(ciInlineKlass* vk, Node* oop)\n-    : InlineTypeBaseNode(TypeInlineType::make(vk), Values + vk->nof_declared_nonstatic_fields()) {\n-    init_class_id(Class_InlineType);\n-    init_req(Oop, oop);\n-  }\n-\n-  \/\/ Checks if the inline type is loaded from memory and if so returns the oop\n-  Node* is_loaded(PhaseGVN* phase, ciInlineKlass* vk = NULL, Node* base = NULL, int holder_offset = 0);\n-\n-  const TypeInstPtr* inline_ptr() const { return TypeInstPtr::make(TypePtr::BotPTR, inline_klass()); }\n-\n-public:\n-  \/\/ Create uninitialized\n-  static InlineTypeNode* make_uninitialized(PhaseGVN& gvn, ciInlineKlass* vk);\n-  \/\/ Create with default field values\n-  static InlineTypeNode* make_default(PhaseGVN& gvn, ciInlineKlass* vk);\n-  \/\/ Create with null field values\n-  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk);\n-  \/\/ Create and initialize by loading the field values from an oop\n-  static InlineTypeBaseNode* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free = true);\n-  \/\/ Create and initialize by loading the field values from a flattened field or array\n-  static InlineTypeNode* make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = NULL, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n-  \/\/ Create and initialize with the inputs or outputs of a MultiNode (method entry or call)\n-  static InlineTypeBaseNode* make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in, bool null_free = true);\n-\n-  \/\/ Initialize the inline type fields with the inputs or outputs of a MultiNode\n-  void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free = true, Node* null_check_region = NULL);\n-\n@@ -158,31 +145,1 @@\n-  void remove_redundant_allocations(PhaseIterGVN* igvn, PhaseIdealLoop* phase);\n-\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------InlineTypePtrNode-------------------------------------\n-\/\/ Node representing an inline type as a pointer in C2 IR\n-class InlineTypePtrNode : public InlineTypeBaseNode {\n-  friend class InlineTypeBaseNode;\n-private:\n-  const TypeInstPtr* inline_ptr() const { return type()->isa_instptr(); }\n-\n-public:\n-  InlineTypePtrNode(const InlineTypeBaseNode* vt, bool null_free = true)\n-    : InlineTypeBaseNode(TypeInstPtr::make(null_free ? TypePtr::NotNull : TypePtr::BotPTR, vt->type()->inline_klass()), vt->req()) {\n-    init_class_id(Class_InlineTypePtr);\n-    init_req(Oop, vt->get_oop());\n-    init_req(IsInit, vt->get_is_init());\n-    for (uint i = Values; i < vt->req(); i++) {\n-      init_req(i, vt->in(i));\n-    }\n-  }\n-\n-  InlineTypePtrNode(ciInlineKlass* vk, Node* oop, bool null_free = true)\n-      : InlineTypeBaseNode(TypeInstPtr::make(null_free ? TypePtr::NotNull : TypePtr::BotPTR, vk), Values + vk->nof_declared_nonstatic_fields()) {\n-    init_class_id(Class_InlineTypePtr);\n-    init_req(Oop, oop);\n-  }\n-\n-  static InlineTypePtrNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk);\n+  void remove_redundant_allocations(PhaseIdealLoop* phase);\n@@ -194,0 +151,2 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":38,"deletions":79,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2308,2 +2308,2 @@\n-  if (base->is_InlineTypeBase()) {\n-    InlineTypeBaseNode* vt = base->as_InlineTypeBase();\n+  if (base->is_InlineType()) {\n+    InlineTypeNode* vt = base->as_InlineType();\n@@ -2311,1 +2311,1 @@\n-      if (!vt->is_allocated(&_gvn) || !_gvn.type(vt)->isa_inlinetype() || !_gvn.type(vt)->is_inlinetype()->larval()) {\n+      if (!vt->is_allocated(&_gvn)) {\n@@ -2335,1 +2335,1 @@\n-      if (vt->is_InlineType()) {\n+      {\n@@ -2566,1 +2566,1 @@\n-        val->as_InlineTypeBase()->store_flattened(this, base, base, holder, offset, decorators);\n+        val->as_InlineType()->store_flattened(this, base, base, holder, offset, decorators);\n@@ -2568,1 +2568,1 @@\n-        val->as_InlineTypeBase()->store_flattened(this, base, adr, NULL, 0, decorators);\n+        val->as_InlineType()->store_flattened(this, base, adr, NULL, 0, decorators);\n@@ -2576,1 +2576,1 @@\n-    InlineTypeBaseNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(base)->inline_klass());\n+    InlineTypeNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(argument(1))->inline_klass());\n@@ -2587,1 +2587,1 @@\n-  if (!value->is_InlineTypeBase()) {\n+  if (!value->is_InlineType()) {\n@@ -2596,1 +2596,1 @@\n-  set_result(value->as_InlineTypeBase()->make_larval(this, true));\n+  set_result(value->as_InlineType()->make_larval(this, true));\n@@ -2607,1 +2607,5 @@\n-  if (!vt->is_allocated(&_gvn) || !_gvn.type(vt)->is_inlinetype()->larval()) {\n+  if (!vt->is_allocated(&_gvn)) {\n+    return false;\n+  }\n+  \/\/ TODO 8239003 Why is this needed?\n+  if (AllocateNode::Ideal_allocation(vt->get_oop(), &_gvn) == NULL) {\n@@ -4548,1 +4552,1 @@\n-  if (obj->is_InlineType() || gvn().type(obj)->is_inlinetypeptr()) {\n+  if (gvn().type(obj)->is_inlinetypeptr()) {\n@@ -4668,1 +4672,1 @@\n-  if (obj->is_InlineTypeBase()) {\n+  if (obj->is_InlineType()) {\n@@ -5034,4 +5038,0 @@\n-    if (obj->is_InlineType()) {\n-      return false;\n-    }\n-\n@@ -5598,3 +5598,0 @@\n-    if (toop->isa_aryptr() != NULL) {\n-      toop = toop->is_aryptr()->cast_to_not_flat(false)->cast_to_not_null_free(false);\n-    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1594,1 +1594,1 @@\n-    n->as_InlineType()->remove_redundant_allocations(&_igvn, this);\n+    n->as_InlineType()->remove_redundant_allocations(this);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-    } else  {\n+    } else {\n@@ -575,1 +575,1 @@\n-  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk)->as_InlineType();\n+  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk);\n@@ -694,5 +694,18 @@\n-      } else if (use->is_InlineType() && use->isa_InlineType()->get_oop() == res) {\n-        \/\/ ok to eliminate\n-      } else if (use->is_InlineTypePtr() && use->isa_InlineTypePtr()->get_oop() == res) {\n-        \/\/ Process users\n-        worklist.push(use);\n+      } else if (use->is_InlineType() && use->as_InlineType()->get_oop() == res) {\n+        \/\/ Look at uses\n+        for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++) {\n+          Node* u = use->fast_out(k);\n+          if (u->is_InlineType()) {\n+            \/\/ Use in flat field can be eliminated\n+            InlineTypeNode* vt = u->as_InlineType();\n+            for (uint i = 0; i < vt->field_count(); ++i) {\n+              if (vt->field_value(i) == use && !vt->field_is_flattened(i)) {\n+                can_eliminate = false; \/\/ Use in non-flattened field\n+                break;\n+              }\n+            }\n+          } else {\n+            \/\/ Add other uses to the worklist to process individually\n+            worklist.push(u);\n+          }\n+        }\n@@ -920,1 +933,1 @@\n-        } else if (!field_val->is_InlineTypeBase()) {\n+        } else if (!field_val->is_InlineType()) {\n@@ -924,1 +937,1 @@\n-      if (field_val->is_InlineTypeBase()) {\n+      if (field_val->is_InlineType()) {\n@@ -945,1 +958,1 @@\n-    InlineTypeBaseNode* vt = value_worklist.at(i)->as_InlineTypeBase();\n+    InlineTypeNode* vt = value_worklist.at(i)->as_InlineType();\n@@ -1033,5 +1046,2 @@\n-        assert(use->isa_InlineType()->get_oop() == res, \"unexpected inline type use\");\n-        _igvn.rehash_node_delayed(use);\n-        use->isa_InlineType()->set_oop(_igvn.zerocon(T_PRIMITIVE_OBJECT));\n-      } else if (use->is_InlineTypePtr()) {\n-        assert(use->isa_InlineTypePtr()->get_oop() == res, \"unexpected inline type ptr use\");\n+        assert(use->as_InlineType()->get_oop() == res, \"unexpected inline type ptr use\");\n+        \/\/ Cut off oop input and remove known instance id from type\n@@ -1039,1 +1049,4 @@\n-        use->isa_InlineTypePtr()->set_oop(_igvn.zerocon(T_PRIMITIVE_OBJECT));\n+        use->as_InlineType()->set_oop(_igvn.zerocon(T_PRIMITIVE_OBJECT));\n+        const TypeOopPtr* toop = _igvn.type(use)->is_oopptr()->cast_to_instance_id(TypeOopPtr::InstanceBot);\n+        _igvn.set_type(use, toop);\n+        use->as_InlineType()->set_type(toop);\n@@ -1041,1 +1054,6 @@\n-        worklist.push(use);\n+        for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++) {\n+          Node* u = use->fast_out(k);\n+          if (!u->is_InlineType()) {\n+            worklist.push(u);\n+          }\n+        }\n@@ -2217,1 +2235,1 @@\n-         (obj->is_InlineTypePtr() && obj->in(1) == unc->peek_monitor_obj()) ||\n+         (obj->is_InlineType() && obj->in(1) == unc->peek_monitor_obj()) ||\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1212,1 +1212,1 @@\n-  \/\/ Loading from an InlineTypePtr? The InlineTypePtr has the values of\n+  \/\/ Loading from an InlineType? The InlineType has the values of\n@@ -1217,12 +1217,2 @@\n-  if (base != NULL && base->is_InlineTypePtr() && offset > oopDesc::klass_offset_in_bytes()) {\n-    Node* value = base->as_InlineTypePtr()->field_value_by_offset((int)offset, true);\n-    if (value->is_InlineType()) {\n-      \/\/ Non-flattened inline type field\n-      InlineTypeNode* vt = value->as_InlineType();\n-      if (vt->is_allocated(phase)) {\n-        value = vt->get_oop();\n-      } else {\n-        \/\/ Not yet allocated, bail out\n-        value = NULL;\n-      }\n-    }\n+  if (base != NULL && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n+    Node* value = base->as_InlineType()->field_value_by_offset((int)offset, true);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-  if (n->is_InlineTypeBase()) {\n+  if (n->is_InlineType()) {\n@@ -661,1 +661,1 @@\n-  if (is_InlineTypeBase()) {\n+  if (is_InlineType()) {\n@@ -2719,1 +2719,1 @@\n-             (is_Allocate() && i >= AllocateNode::InlineTypeNode) ||\n+             (is_Allocate() && i >= AllocateNode::InlineType) ||\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-class InlineTypeBaseNode;\n@@ -171,1 +170,0 @@\n-class InlineTypePtrNode;\n@@ -723,3 +721,1 @@\n-      DEFINE_CLASS_ID(InlineTypeBase, Type, 8)\n-        DEFINE_CLASS_ID(InlineType, InlineTypeBase, 0)\n-        DEFINE_CLASS_ID(InlineTypePtr, InlineTypeBase, 1)\n+      DEFINE_CLASS_ID(InlineType, Type, 8)\n@@ -959,2 +955,0 @@\n-  DEFINE_CLASS_QUERY(InlineTypeBase)\n-  DEFINE_CLASS_QUERY(InlineTypePtr)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -930,1 +930,1 @@\n-      InlineTypeBaseNode* vt = res->as_InlineTypeBase();\n+      InlineTypeNode* vt = res->as_InlineType();\n@@ -949,4 +949,0 @@\n-      if (res->is_InlineType()) {\n-        assert(res->as_InlineType()->is_allocated(&kit.gvn()), \"must be allocated\");\n-        res = res->as_InlineType()->get_oop();\n-      }\n@@ -1757,3 +1753,1 @@\n-        if (n->is_InlineType() && (!t->isa_inlinetype() && !t->is_inlinetypeptr())) {\n-          \/\/ TODO Currently, the implementation relies on the assumption that InlineTypePtrNodes\n-          \/\/ are always buffered. We therefore need to allocate here.\n+        if (n->is_InlineType() && !t->is_inlinetypeptr()) {\n@@ -1762,1 +1756,1 @@\n-        } else if (!n->is_InlineTypeBase() && t->is_inlinetypeptr()) {\n+        } else if (!n->is_InlineType() && t->is_inlinetypeptr()) {\n@@ -1765,1 +1759,1 @@\n-          map()->set_req(j, InlineTypePtrNode::make_null(gvn(), t->inline_klass()));\n+          map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n@@ -1869,2 +1863,2 @@\n-      } else if (m->is_InlineTypeBase() && m->as_InlineTypeBase()->has_phi_inputs(r)) {\n-        phi = m->as_InlineTypeBase()->get_oop()->as_Phi();\n+      } else if (m->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n+        phi = m->as_InlineType()->get_oop()->as_Phi();\n@@ -1911,2 +1905,2 @@\n-        InlineTypeBaseNode* vtm = m->as_InlineTypeBase(); \/\/ Current inline type\n-        InlineTypeBaseNode* vtn = n->as_InlineTypeBase(); \/\/ Incoming inline type\n+        InlineTypeNode* vtm = m->as_InlineType(); \/\/ Current inline type\n+        InlineTypeNode* vtn = n->as_InlineType(); \/\/ Incoming inline type\n@@ -1926,10 +1920,0 @@\n-        if (vtm->is_InlineTypePtr() && vtn->is_InlineType()) {\n-          \/\/ TODO 8284443 Remove this\n-          Node* newVal = InlineTypeNode::make_uninitialized(gvn(), vtm->bottom_type()->inline_klass());\n-          for (uint i = 1; i < vtm->req(); ++i) {\n-            newVal->set_req(i, vtm->in(i));\n-          }\n-          _gvn.set_type(newVal, vtm->bottom_type());\n-          vtm->replace_by(newVal);\n-          vtm = newVal->as_InlineTypeBase();\n-        }\n@@ -2112,2 +2096,2 @@\n-      } else if (n->is_InlineTypeBase() && n->as_InlineTypeBase()->has_phi_inputs(r)) {\n-        n->as_InlineTypeBase()->add_new_path(r);\n+      } else if (n->is_InlineType() && n->as_InlineType()->has_phi_inputs(r)) {\n+        n->as_InlineType()->add_new_path(r);\n@@ -2136,1 +2120,1 @@\n-  InlineTypeBaseNode* vt = o->isa_InlineTypeBase();\n+  InlineTypeNode* vt = o->isa_InlineType();\n@@ -2173,1 +2157,1 @@\n-  if (vt != NULL && (t->is_inlinetypeptr() || t->isa_inlinetype())) {\n+  if (vt != NULL && t->is_inlinetypeptr()) {\n@@ -2382,1 +2366,1 @@\n-        value = value->as_InlineTypeBase()->allocate_fields(this);\n+        value = value->as_InlineType()->allocate_fields(this);\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-      cast_val->as_InlineTypeBase()->store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+      cast_val->as_InlineType()->store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -303,1 +303,1 @@\n-          val->as_InlineTypeBase()->store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+          val->as_InlineType()->store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -1942,3 +1942,0 @@\n-  if (cast->is_InlineType()) {\n-    cast = cast->as_InlineType()->get_oop();\n-  }\n@@ -2067,1 +2064,1 @@\n-  if (left->is_InlineTypeBase()) {\n+  if (left->is_InlineType()) {\n@@ -2069,1 +2066,1 @@\n-        (right->is_InlineTypeBase() && _gvn.type(right->as_InlineTypeBase()->get_is_init())->is_zero_type())) {\n+        (right->is_InlineType() && _gvn.type(right->as_InlineType()->get_is_init())->is_zero_type())) {\n@@ -2072,1 +2069,1 @@\n-      Node* cmp = CmpI(left->as_InlineTypeBase()->get_is_init(), intcon(0));\n+      Node* cmp = CmpI(left->as_InlineType()->get_is_init(), intcon(0));\n@@ -2075,1 +2072,1 @@\n-    } else if (left->is_InlineType()){\n+    } else {\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  if (is_field && field_holder->is_inlinetype() && peek()->is_InlineTypeBase()) {\n+  if (is_field && field_holder->is_inlinetype() && peek()->is_InlineType()) {\n@@ -55,1 +55,1 @@\n-    InlineTypeBaseNode* vt = peek()->as_InlineTypeBase();\n+    InlineTypeNode* vt = peek()->as_InlineType();\n@@ -232,1 +232,1 @@\n-  assert(!field->is_null_free() || val->is_InlineType() || !gvn().type(val)->maybe_null(), \"Null store to inline type field\");\n+  assert(!field->is_null_free() || !gvn().type(val)->maybe_null(), \"Null store to inline type field\");\n@@ -242,1 +242,1 @@\n-    val->as_InlineTypeBase()->store_flattened(this, obj, obj, field->holder(), offset);\n+    val->as_InlineType()->store_flattened(this, obj, obj, field->holder(), offset);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -336,2 +336,1 @@\n-  InlineTypeNode* vt = InlineTypeNode::make_default(_gvn, vk);\n-  push(vt);\n+  push(InlineTypeNode::make_default(_gvn, vk));\n@@ -353,1 +352,1 @@\n-  if (!val->is_InlineTypeBase() && field->type()->is_inlinetype()) {\n+  if (!val->is_InlineType() && field->type()->is_inlinetype()) {\n@@ -366,8 +365,0 @@\n-  if (val->is_InlineTypePtr() && field->is_null_free()) {\n-    \/\/ TODO 8284443 Remove this\n-    Node* newVal = InlineTypeNode::make_uninitialized(gvn(), field->type()->as_inline_klass());\n-    for (uint i = 1; i < val->req(); ++i) {\n-      newVal->set_req(i, val->in(i));\n-    }\n-    val = gvn().transform(newVal);\n-  }\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1617,1 +1617,1 @@\n-    if (use->is_InlineTypeBase()) {\n+    if (use->is_InlineType()) {\n@@ -1620,1 +1620,1 @@\n-        if (u->is_InlineTypeBase())\n+        if (u->is_InlineType())\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1110,1 +1110,1 @@\n-  if (in(1)->is_InlineTypePtr() && phase->type(in(2))->is_zero_type()) {\n+  if (in(1)->is_InlineType() && phase->type(in(2))->is_zero_type()) {\n@@ -1113,1 +1113,1 @@\n-    return new CmpINode(in(1)->as_InlineTypePtr()->get_is_init(), phase->intcon(0));\n+    return new CmpINode(in(1)->as_InlineType()->get_is_init(), phase->intcon(0));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,1 +273,0 @@\n-    bool is_null_free = type->is_null_free();\n@@ -275,5 +274,1 @@\n-    if (is_null_free) {\n-      return TypeInlineType::make(vk);\n-    } else {\n-      return TypeOopPtr::make_from_klass(vk)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n-    }\n+    return TypeOopPtr::make_from_klass(vk)->join_speculative(type->is_null_free() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2115,1 +2110,1 @@\n-      \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+      \/\/ InlineTypeNode::IsInit field used for null checking\n@@ -2146,1 +2141,1 @@\n-        \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+        \/\/ InlineTypeNode::IsInit field used for null checking\n@@ -2213,1 +2208,1 @@\n-          \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+          \/\/ InlineTypeNode::IsInit field used for null checking\n@@ -6475,0 +6470,4 @@\n+  \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+  if (tk->klass()->is_inlinetype() && !is_null_free()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -828,1 +828,1 @@\n-\n+\/\/ TODO 8293800 Remove\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2986,1 +2986,1 @@\n-            \/\/ Nullable inline type argument, insert InlineTypeBaseNode::IsInit field right after T_PRIMITIVE_OBJECT\n+            \/\/ Nullable inline type argument, insert InlineTypeNode::IsInit field right after T_PRIMITIVE_OBJECT\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3146,1 +3146,1 @@\n-\/\/ TODO Tobias\n+\/\/ TODO 8293541\n@@ -3185,1 +3185,1 @@\n-\/\/ TODO Tobias\n+\/\/ TODO 8293541\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}