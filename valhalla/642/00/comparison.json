{"files":[{"patch":"@@ -3747,1 +3747,1 @@\n-Node* GraphKit::flat_array_test(Node* ary, bool flat) {\n+Node* GraphKit::flat_array_test(Node* array_or_klass, bool flat) {\n@@ -3752,1 +3752,1 @@\n-  Node* cmp = _gvn.transform(new FlatArrayCheckNode(C, mem, ary));\n+  Node* cmp = _gvn.transform(new FlatArrayCheckNode(C, mem, array_or_klass));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -878,1 +878,1 @@\n-  Node* flat_array_test(Node* ary, bool flat = true);\n+  Node* flat_array_test(Node* array_or_klass, bool flat = true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1242,1 +1242,1 @@\n-      *array = cmp->in(FlatArrayCheckNode::Array);\n+      *array = cmp->in(FlatArrayCheckNode::ArrayOrKlass);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3683,2 +3683,0 @@\n-      case FlatArray:      query = Klass::layout_helper_is_flatArray(layout_con); break;\n-      case NonFlatArray:   query = !Klass::layout_helper_is_flatArray(layout_con); break;\n@@ -3716,7 +3714,0 @@\n-    case FlatArray:\n-    case NonFlatArray: {\n-      value = 0;\n-      layout_val = _gvn.transform(new AndINode(layout_val, intcon(Klass::_lh_array_tag_flat_value_bit_inplace)));\n-      btest = (kind == FlatArray) ? BoolTest::ne : BoolTest::eq;\n-      break;\n-    }\n@@ -3952,1 +3943,1 @@\n-          generate_non_flatArray_guard(klass_node, bailout);\n+          generate_fair_guard(flat_array_test(klass_node, \/* flat = *\/ false), bailout);\n@@ -3959,1 +3950,1 @@\n-        generate_flatArray_guard(original_kls, bailout);\n+        generate_fair_guard(flat_array_test(original_kls), bailout);\n@@ -4668,1 +4659,1 @@\n-        generate_flatArray_guard(obj_klass, slow_region);\n+        generate_fair_guard(flat_array_test(obj_klass), slow_region);\n@@ -5180,1 +5171,1 @@\n-          generate_non_flatArray_guard(dest_klass, slow_region);\n+          generate_fair_guard(flat_array_test(dest_klass, \/* flat = *\/ false), slow_region);\n@@ -5190,1 +5181,1 @@\n-        generate_flatArray_guard(load_object_klass(src), slow_region);\n+        generate_fair_guard(flat_array_test(src), slow_region);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -174,3 +174,1 @@\n-    TypeArray,\n-    FlatArray,\n-    NonFlatArray\n+    TypeArray\n@@ -196,8 +194,0 @@\n-  Node* generate_flatArray_guard(Node* kls, RegionNode* region) {\n-    assert(UseFlatArray, \"can never be flattened\");\n-    return generate_array_guard_common(kls, region, FlatArray);\n-  }\n-  Node* generate_non_flatArray_guard(Node* kls, RegionNode* region) {\n-    assert(UseFlatArray, \"can never be flattened\");\n-    return generate_array_guard_common(kls, region, NonFlatArray);\n-  }\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -326,2 +326,2 @@\n-      Node* array = unswitch_iffs.at(i)->in(1)->in(1)->in(FlatArrayCheckNode::Array);\n-      cmp->set_req(FlatArrayCheckNode::Array + i, array);\n+      Node* array = unswitch_iffs.at(i)->in(1)->in(1)->in(FlatArrayCheckNode::ArrayOrKlass);\n+      cmp->set_req(FlatArrayCheckNode::ArrayOrKlass + i, array);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-  Node* array = n->in(FlatArrayCheckNode::Array)->uncast();\n+  Node* array = n->in(FlatArrayCheckNode::ArrayOrKlass)->uncast();\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2700,1 +2700,2 @@\n-  if (UseArrayMarkWordCheck) {\n+  bool array_inputs = _igvn.type(check->in(FlatArrayCheckNode::ArrayOrKlass))->isa_oopptr() != NULL;\n+  if (UseArrayMarkWordCheck && array_inputs) {\n@@ -2704,1 +2705,1 @@\n-    for (uint i = FlatArrayCheckNode::Array; i < check->req(); ++i) {\n+    for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n@@ -2706,2 +2707,2 @@\n-      if (ary->is_top()) continue;\n-      const TypeAryPtr* t = _igvn.type(ary)->isa_aryptr();\n+      const TypeOopPtr* t = _igvn.type(ary)->isa_oopptr();\n+      assert(t != NULL, \"Mixing array and klass inputs\");\n@@ -2737,1 +2738,1 @@\n-      for (uint i = FlatArrayCheckNode::Array; i < check->req(); ++i) {\n+      for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n@@ -2739,1 +2740,0 @@\n-        if (ary->is_top()) continue;\n@@ -2764,4 +2764,4 @@\n-    for (uint i = FlatArrayCheckNode::Array; i < check->req(); ++i) {\n-      Node* ary = check->in(i);\n-      if (ary->is_top()) continue;\n-      const TypeAryPtr* t = _igvn.type(ary)->isa_aryptr();\n+    for (uint i = FlatArrayCheckNode::ArrayOrKlass; i < check->req(); ++i) {\n+      Node* array_or_klass = check->in(i);\n+      Node* klass = NULL;\n+      const TypePtr* t = _igvn.type(array_or_klass)->is_ptr();\n@@ -2769,2 +2769,7 @@\n-      Node* klass_adr = basic_plus_adr(ary, oopDesc::klass_offset_in_bytes());\n-      Node* klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+      if (t->isa_oopptr() != NULL) {\n+        Node* klass_adr = basic_plus_adr(array_or_klass, oopDesc::klass_offset_in_bytes());\n+        klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+      } else {\n+        assert(t->isa_aryklassptr(), \"Unexpected input type\");\n+        klass = array_or_klass;\n+      }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1399,13 +1399,11 @@\n-  for (uint i = Array; i < req(); ++i) {\n-    Node* array = in(i);\n-    if (!array->is_top()) {\n-      const Type* t = phase->type(array);\n-      if (t == Type::TOP) {\n-        return Type::TOP;\n-      } else if (t->is_aryptr()->is_flat()) {\n-        \/\/ One of the input arrays is flat, check always passes\n-        return TypeInt::CC_EQ;\n-      } else if (!t->is_aryptr()->is_not_flat()) {\n-        \/\/ One of the input arrays might be flat\n-        all_not_flat = false;\n-      }\n+  for (uint i = ArrayOrKlass; i < req(); ++i) {\n+    const Type* t = phase->type(in(i));\n+    if (t == Type::TOP) {\n+      return Type::TOP;\n+    }\n+    if (t->is_ptr()->is_flat()) {\n+      \/\/ One of the input arrays is flat, check always passes\n+      return TypeInt::CC_EQ;\n+    } else if (!t->is_ptr()->is_not_flat()) {\n+      \/\/ One of the input arrays might be flat\n+      all_not_flat = false;\n@@ -1424,5 +1422,5 @@\n-  \/\/ Remove array inputs that are known to be non-flat\n-  for (uint i = Array; i < req(); ++i) {\n-    const TypeAryPtr* t = phase->type(in(i))->isa_aryptr();\n-    if (t != NULL && t->is_not_flat()) {\n-      set_req(i, phase->C->top());\n+  \/\/ Remove inputs that are known to be non-flat\n+  for (uint i = ArrayOrKlass; i < req(); ++i) {\n+    const Type* t = phase->type(in(i));\n+    if (t->isa_ptr() && t->is_ptr()->is_not_flat()) {\n+      del_req(i--);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -285,1 +285,2 @@\n-\/\/ Returns true if one of the input arrays (there can be multiple) is flat.\n+\/\/ Returns true if one of the input array objects or array klass ptrs (there\n+\/\/ can be multiple) is flat.\n@@ -291,1 +292,1 @@\n-    Array\n+    ArrayOrKlass\n@@ -293,1 +294,1 @@\n-  FlatArrayCheckNode(Compile* C, Node* mem, Node* array) : CmpNode(mem, array) {\n+  FlatArrayCheckNode(Compile* C, Node* mem, Node* array_or_klass) : CmpNode(mem, array_or_klass) {\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5910,1 +5910,1 @@\n-        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->null_free());\n+        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_null_free());\n@@ -5929,1 +5929,1 @@\n-                                       tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->null_free());\n+                                       tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_null_free());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1088,3 +1088,5 @@\n-  virtual bool flatten_array() const { return false; }\n-  virtual bool is_not_flat() const { return false; }\n-  virtual bool is_not_null_free() const { return false; }\n+  virtual bool flatten_array()      const { return false; }\n+  virtual bool is_flat()            const { return false; }\n+  virtual bool is_not_flat()        const { return false; }\n+  virtual bool is_null_free()       const { return false; }\n+  virtual bool is_not_null_free()   const { return false; }\n@@ -1667,3 +1669,4 @@\n-  virtual bool is_not_flat() const { return _not_flat; }\n-  virtual bool is_not_null_free() const { return _not_null_free; }\n-  bool null_free() const { return _null_free; }\n+  bool is_flat()          const { return klass()->is_flat_array_klass(); }\n+  bool is_not_flat()      const { return _not_flat; }\n+  bool is_null_free()     const { return _null_free; }\n+  bool is_not_null_free() const { return _not_null_free; }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"}]}