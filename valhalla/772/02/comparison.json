{"files":[{"patch":"@@ -163,0 +163,1 @@\n+          --with-jmod-compress=zip-1\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+          --with-jmod-compress=zip-1\n","filename":".github\/workflows\/build-linux.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+          --with-jmod-compress=zip-1\n","filename":".github\/workflows\/build-macos.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+          --with-jmod-compress=zip-1\n","filename":".github\/workflows\/build-windows.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -235,0 +235,8 @@\n+ifeq ($(INTERIM_JMOD), true)\n+  # Interim JMODs are not shipped anywhere, so there is no reason\n+  # to compress them at all.\n+  JMOD_FLAGS += --compress zip-0\n+else\n+  JMOD_FLAGS += --compress $(JMOD_COMPRESS)\n+endif\n+\n","filename":"make\/CreateJmods.gmk","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,2 +72,0 @@\n-    -tag spec:X \\\n-    -tag specdefault:X \\\n@@ -89,0 +87,1 @@\n+    -tag spec \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -857,1 +857,1 @@\n-          -status:$$$${JTREG_STATUS} \\\n+          $$$${JTREG_STATUS} \\\n","filename":"make\/RunTests.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+JDKOPT_SETUP_JMOD_OPTIONS\n","filename":"make\/autoconf\/configure.ac","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -475,0 +475,25 @@\n+################################################################################\n+#\n+# jmod options.\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_JMOD_OPTIONS],\n+[\n+  # Final JMODs are recompiled often during development, and java.base JMOD\n+  # includes the JVM libraries. In release mode, prefer to compress JMODs fully.\n+  # In debug mode, pay with a little extra space, but win a lot of CPU time back\n+  # with the lightest (but still some) compression.\n+  if test \"x$DEBUG_LEVEL\" = xrelease; then\n+    DEFAULT_JMOD_COMPRESS=\"zip-6\"\n+  else\n+    DEFAULT_JMOD_COMPRESS=\"zip-1\"\n+  fi\n+\n+  UTIL_ARG_WITH(NAME: jmod-compress, TYPE: literal,\n+    VALID_VALUES: [zip-0 zip-1 zip-2 zip-3 zip-4 zip-5 zip-6 zip-7 zip-8 zip-9],\n+    DEFAULT: $DEFAULT_JMOD_COMPRESS,\n+    CHECKING_MSG: [for JMOD compression type],\n+    DESC: [specify JMOD compression type (zip-[0-9])]\n+  )\n+  AC_SUBST(JMOD_COMPRESS)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -705,0 +705,1 @@\n+JMOD_COMPRESS:=@JMOD_COMPRESS@\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -346,0 +346,5 @@\n+    ifneq ($(DISABLE_WARNING_PREFIX), )\n+      $1_WARNINGS_FLAGS := $$(addprefix $(DISABLE_WARNING_PREFIX), \\\n+        $$($$($1_BASE)_DISABLED_WARNINGS_$(TOOLCHAIN_TYPE)_$$($1_FILENAME)))\n+    endif\n+\n@@ -347,1 +352,1 @@\n-        $$($$($1_BASE)_SYSROOT_CFLAGS)\n+        $$($$($1_BASE)_SYSROOT_CFLAGS) $$($1_WARNINGS_FLAGS)\n@@ -349,1 +354,1 @@\n-        $$($$($1_BASE)_SYSROOT_CFLAGS) $$($1_EXTRA_CXXFLAGS)\n+        $$($$($1_BASE)_SYSROOT_CFLAGS) $$($1_EXTRA_CXXFLAGS) $$($1_WARNINGS_FLAGS)\n","filename":"make\/common\/NativeCompilation.gmk","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1145,1 +1145,1 @@\n-            revision: \"1.34+1.0\"\n+            revision: \"1.35+1.0\"\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,1 +198,0 @@\n-JVM_ResumeThread\n@@ -209,1 +208,0 @@\n-JVM_StopThread\n@@ -211,1 +209,0 @@\n-JVM_SuspendThread\n@@ -231,0 +228,1 @@\n+JVM_VirtualThreadHideFrames\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-JOPT_SIMPLE_VERSION=4.6\n+JOPT_SIMPLE_VERSION=5.0.4\n","filename":"make\/devkit\/createJMHBundle.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -922,2 +922,0 @@\n-        } catch (ThreadDeath e) {\n-            error(\"terminated\");\n","filename":"make\/jdk\/src\/classes\/build\/tools\/dtdbuilder\/DTDParser.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-TZDATA_TZFILES := $(addprefix $(TZDATA_DIR)\/,$(TZDATA_TZFILE))\n+TZDATA_TZFILES := $(wildcard $(TZDATA_DIR)\/*)\n","filename":"make\/modules\/java.base\/gendata\/GendataTZDB.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    DISABLED_WARNINGS_gcc_k_rem_pio2.c := maybe-uninitialized, \\\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,13 @@\n+ifeq ($(call isTargetOs, windows), true)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBSSPI_BRIDGE, \\\n+      NAME := sspi_bridge, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKLIB) \\\n+          -I$(TOPDIR)\/src\/java.security.jgss\/share\/native\/libj2gss, \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+          $(call SET_SHARED_LIBRARY_ORIGIN) \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBSSPI_BRIDGE)\n+endif\n+\n@@ -60,11 +73,0 @@\n-\n-    $(eval $(call SetupJdkLibrary, BUILD_LIBSSPI_BRIDGE, \\\n-        NAME := sspi_bridge, \\\n-        OPTIMIZATION := LOW, \\\n-        CFLAGS := $(CFLAGS_JDKLIB) \\\n-            -I$(TOPDIR)\/src\/java.security.jgss\/share\/native\/libj2gss, \\\n-        LDFLAGS := $(LDFLAGS_JDKLIB) \\\n-            $(call SET_SHARED_LIBRARY_ORIGIN) \\\n-    ))\n-\n-    TARGETS += $(BUILD_LIBSSPI_BRIDGE)\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -5694,0 +5694,42 @@\n+\/\/ ------------------------- Vector conditional move --------------------------\n+\n+instruct vcmove_neon(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd) %{\n+  predicate(UseSVE == 0 ||\n+            (VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) &&\n+             n->in(1)->in(2)->get_int() != BoolTest::ne));\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcmove_neon.$copnd $dst, $src1, $src2\\t# vector conditional move fp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n+                    $src2$$FloatRegister, (int)($cond$$constant),\n+                    \/* isQ *\/ length_in_bytes == 16);\n+    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcmove_sve(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd, pRegGov pgtmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) ||\n+            (UseSVE > 0 && n->in(1)->in(2)->get_int() == BoolTest::ne));\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP pgtmp);\n+  format %{ \"vcmove_sve.$copnd $dst, $src1, $src2\\t# vector conditional move fp. KILL $pgtmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_compare($pgtmp$$PRegister, bt, ptrue, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pgtmp$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4066,0 +4066,42 @@\n+\/\/ ------------------------- Vector conditional move --------------------------\n+\n+instruct vcmove_neon(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd) %{\n+  predicate(UseSVE == 0 ||\n+            (VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) &&\n+             n->in(1)->in(2)->get_int() != BoolTest::ne));\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"vcmove_neon.$copnd $dst, $src1, $src2\\t# vector conditional move fp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ neon_compare($dst$$FloatRegister, bt, $src1$$FloatRegister,\n+                    $src2$$FloatRegister, (int)($cond$$constant),\n+                    \/* isQ *\/ length_in_bytes == 16);\n+    __ bsl($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+           $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcmove_sve(vReg dst, vReg src1, vReg src2, immI cond, cmpOp copnd, pRegGov pgtmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)) ||\n+            (UseSVE > 0 && n->in(1)->in(2)->get_int() == BoolTest::ne));\n+  match(Set dst (CMoveVF (Binary copnd cond) (Binary src1 src2)));\n+  match(Set dst (CMoveVD (Binary copnd cond) (Binary src1 src2)));\n+  effect(TEMP pgtmp);\n+  format %{ \"vcmove_sve.$copnd $dst, $src1, $src2\\t# vector conditional move fp. KILL $pgtmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_compare($pgtmp$$PRegister, bt, ptrue, $src1$$FloatRegister,\n+                   $src2$$FloatRegister, (int)($cond$$constant));\n+    __ sve_sel($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+               $pgtmp$$PRegister, $src2$$FloatRegister, $src1$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2573,1 +2573,1 @@\n-#ifdef ASSERT0\n+#ifdef ASSERT\n@@ -2575,2 +2575,1 @@\n-    __ ldr(rscratch1, Address(rthread,\n-                              JavaThread::last_Java_fp_offset()));\n+    __ ldr(rscratch1, Address(rthread, JavaThread::last_Java_fp_offset()));\n@@ -2848,1 +2847,1 @@\n-    __ stop(\"SharedRuntime::generate_deopt_blob: last_Java_fp not cleared\");\n+    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-      movptr_with_offset(temp, dest, offset);                      \\\n+      movptr(temp, dest, offset);                                  \\\n@@ -204,1 +204,1 @@\n-      movptr_with_offset(temp, dest, offset);                     \\\n+      movptr(temp, dest, offset);                                 \\\n@@ -218,1 +218,1 @@\n-        code_section()->relocate(pc(), adr.rspec());           \\\n+        relocate(adr.rspec());                                 \\\n@@ -275,1 +275,1 @@\n-void Assembler::movptr_with_offset(Register Rd, address addr, int32_t &offset) {\n+void Assembler::movptr(Register Rd, address addr, int32_t &offset) {\n@@ -310,1 +310,1 @@\n-  movptr_with_offset(Rd, addr, offset);\n+  movptr(Rd, addr, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-      movptr_with_offset(Rd, (address)(uintptr_t)adr.offset(), offset);\n+      movptr(Rd, (address)(uintptr_t)adr.offset(), offset);\n@@ -324,1 +324,1 @@\n-  void movptr_with_offset(Register Rd, address addr, int32_t &offset);\n+  void movptr(Register Rd, address addr, int32_t &offset);\n@@ -489,1 +489,0 @@\n-    InstructionMark im(this);                                               \\\n@@ -492,1 +491,1 @@\n-    code_section()->relocate(inst_mark(), InternalAddress(dest).rspec());\n+    relocate(InternalAddress(dest).rspec());\n@@ -527,1 +526,1 @@\n-      movptr_with_offset(Rd, dest, offset);                                                        \\\n+      movptr(Rd, dest, offset);                                                                    \\\n@@ -537,1 +536,1 @@\n-        code_section()->relocate(pc(), adr.rspec());                                               \\\n+        relocate(adr.rspec());                                                                     \\\n@@ -601,1 +600,1 @@\n-      movptr_with_offset(temp, dest, offset);                                                      \\\n+      movptr(temp, dest, offset);                                                                  \\\n@@ -611,1 +610,1 @@\n-        code_section()->relocate(pc(), adr.rspec());                                               \\\n+        relocate(adr.rspec());                                                                     \\\n@@ -746,1 +745,1 @@\n-      movptr_with_offset(temp, dest, offset);                                                      \\\n+      movptr(temp, dest, offset);                                                                  \\\n@@ -754,1 +753,1 @@\n-        code_section()->relocate(pc(), adr.rspec());                                               \\\n+        relocate(adr.rspec());                                                                     \\\n@@ -790,1 +789,1 @@\n-      movptr_with_offset(temp, dest, offset);                                                      \\\n+      movptr(temp, dest, offset);                                                                  \\\n@@ -797,1 +796,1 @@\n-        code_section()->relocate(pc(), adr.rspec());                                               \\\n+        relocate(adr.rspec());                                                                     \\\n@@ -885,1 +884,1 @@\n-      movptr_with_offset(temp, dest, off);                                                    \\\n+      movptr(temp, dest, off);                                                                \\\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  __ code_section()->relocate(__ pc(), safepoint_pc.rspec());\n+  __ relocate(safepoint_pc.rspec());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1352,1 +1352,1 @@\n-  __ align(4);\n+  __ align(NativeInstruction::instruction_size);\n@@ -1375,1 +1375,1 @@\n-  assert((__ offset() % 4) == 0, \"bad alignment\");\n+  MacroAssembler::assert_alignment(call_pc);\n@@ -2147,10 +2147,0 @@\n-void LIR_Assembler::add_debug_info_for_branch(address adr, CodeEmitInfo* info) {\n-  _masm->code_section()->relocate(adr, relocInfo::poll_type);\n-  int pc_offset = code_offset();\n-  flush_debug_info(pc_offset);\n-  info->record_debug_info(compilation()->debug_info_recorder(), pc_offset);\n-  if (info->exception_handlers() != NULL) {\n-    compilation()->add_exception_handlers_for_pco(pc_offset, info->exception_handlers());\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  void add_debug_info_for_branch(address adr, CodeEmitInfo* info);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-\n+  assert_alignment(pc());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -251,3 +251,3 @@\n-  int32_t _offset = 0;\n-  movptr_with_offset(t0, StubRoutines::riscv::method_entry_barrier(), _offset);\n-  jalr(ra, t0, _offset);\n+  int32_t offset = 0;\n+  movptr(t0, StubRoutines::riscv::method_entry_barrier(), offset);\n+  jalr(ra, t0, offset);\n@@ -258,1 +258,1 @@\n-  assert(offset() % 4 == 0, \"bad alignment\");\n+  assert_alignment(pc());\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  masm.code_section()->relocate(masm.pc(), safepoint_pc.rspec());\n+  masm.relocate(safepoint_pc.rspec());\n","filename":"src\/hotspot\/cpu\/riscv\/c2_safepointPollStubTable_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-    __ movptr_with_offset(t0, StubRoutines::riscv::method_entry_barrier(), offset);\n+    __ movptr(t0, StubRoutines::riscv::method_entry_barrier(), offset);\n@@ -265,1 +265,1 @@\n-    assert(__ offset() % 4 == 0, \"bad alignment\");\n+    MacroAssembler::assert_alignment(__ pc());\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,1 +243,0 @@\n-    InstructionMark im(this);\n@@ -560,1 +559,1 @@\n-  movptr_with_offset(t0, 0, offset);\n+  movptr(t0, 0, offset);\n@@ -569,1 +568,1 @@\n-  movptr_with_offset(t0, entry_point, offset);\n+  movptr(t0, entry_point, offset);\n@@ -734,4 +733,0 @@\n-  InstructionMark im(this);\n-  code_section()->relocate(inst_mark(), adr.rspec());\n-  relocInfo::relocType rtype = adr.rspec().reloc()->type();\n-\n@@ -740,0 +735,1 @@\n+      relocInfo::relocType rtype = adr.rspec().reloc()->type();\n@@ -743,0 +739,1 @@\n+        relocate(adr.rspec());\n@@ -1354,1 +1351,1 @@\n-  code_section()->relocate(pc(), dest.rspec());\n+  relocate(dest.rspec());\n@@ -2695,1 +2692,0 @@\n-  relocInfo::relocType rtype = dest.rspec().reloc()->type();\n@@ -2705,2 +2701,1 @@\n-  InstructionMark im(this);\n-  code_section()->relocate(inst_mark(), dest.rspec());\n+  relocate(dest.rspec());\n@@ -2716,1 +2711,1 @@\n-    movptr_with_offset(reg1, dest.target(), offset);\n+    movptr(reg1, dest.target(), offset);\n@@ -2769,9 +2764,3 @@\n-address MacroAssembler::read_polling_page(Register r, int32_t offset, relocInfo::relocType rtype) {\n-  address mark;\n-  {\n-    InstructionMark im(this);\n-    code_section()->relocate(inst_mark(), rtype);\n-    lwu(zr, Address(r, offset));\n-    mark = inst_mark();\n-  }\n-  return mark;\n+void MacroAssembler::read_polling_page(Register r, int32_t offset, relocInfo::relocType rtype) {\n+  relocate(rtype);\n+  lwu(zr, Address(r, offset));\n@@ -2791,3 +2780,1 @@\n-  InstructionMark im(this);\n-  RelocationHolder rspec = oop_Relocation::spec(oop_index);\n-  code_section()->relocate(inst_mark(), rspec);\n+  relocate(oop_Relocation::spec(oop_index));\n@@ -2804,3 +2791,0 @@\n-  InstructionMark im(this);\n-  RelocationHolder rspec = metadata_Relocation::spec(index);\n-  code_section()->relocate(inst_mark(), rspec);\n@@ -2808,0 +2792,1 @@\n+  relocate(metadata_Relocation::spec(index));\n@@ -2842,0 +2827,5 @@\n+#ifdef ASSERT\n+  if (entry.rspec().type() != relocInfo::runtime_call_type) {\n+    assert_alignment(call_pc);\n+  }\n+#endif\n@@ -3960,0 +3950,203 @@\n+\n+\/\/ The java_calling_convention describes stack locations as ideal slots on\n+\/\/ a frame with no abi restrictions. Since we must observe abi restrictions\n+\/\/ (like the placement of the register window) the slots must be biased by\n+\/\/ the following value.\n+static int reg2offset_in(VMReg r) {\n+  \/\/ Account for saved fp and ra\n+  \/\/ This should really be in_preserve_stack_slots\n+  return r->reg2stack() * VMRegImpl::stack_slot_size;\n+}\n+\n+static int reg2offset_out(VMReg r) {\n+  return (r->reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;\n+}\n+\n+\/\/ On 64 bit we will store integer like items to the stack as\n+\/\/ 64 bits items (riscv64 abi) even though java would only store\n+\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n+\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+void MacroAssembler::move32_64(VMRegPair src, VMRegPair dst, Register tmp) {\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      \/\/ stack to stack\n+      ld(tmp, Address(fp, reg2offset_in(src.first())));\n+      sd(tmp, Address(sp, reg2offset_out(dst.first())));\n+    } else {\n+      \/\/ stack to reg\n+      lw(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    sd(src.first()->as_Register(), Address(sp, reg2offset_out(dst.first())));\n+  } else {\n+    if (dst.first() != src.first()) {\n+      \/\/ 32bits extend sign\n+      addw(dst.first()->as_Register(), src.first()->as_Register(), zr);\n+    }\n+  }\n+}\n+\n+\/\/ An oop arg. Must pass a handle not the oop itself\n+void MacroAssembler::object_move(OopMap* map,\n+                                 int oop_handle_offset,\n+                                 int framesize_in_slots,\n+                                 VMRegPair src,\n+                                 VMRegPair dst,\n+                                 bool is_receiver,\n+                                 int* receiver_offset) {\n+  assert_cond(map != NULL && receiver_offset != NULL);\n+  \/\/ must pass a handle. First figure out the location we use as a handle\n+  Register rHandle = dst.first()->is_stack() ? t1 : dst.first()->as_Register();\n+\n+  \/\/ See if oop is NULL if it is we need no handle\n+\n+  if (src.first()->is_stack()) {\n+    \/\/ Oop is already on the stack as an argument\n+    int offset_in_older_frame = src.first()->reg2stack() + SharedRuntime::out_preserve_stack_slots();\n+    map->set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));\n+    if (is_receiver) {\n+      *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;\n+    }\n+\n+    ld(t0, Address(fp, reg2offset_in(src.first())));\n+    la(rHandle, Address(fp, reg2offset_in(src.first())));\n+    \/\/ conditionally move a NULL\n+    Label notZero1;\n+    bnez(t0, notZero1);\n+    mv(rHandle, zr);\n+    bind(notZero1);\n+  } else {\n+\n+    \/\/ Oop is in a register we must store it to the space we reserve\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+\n+    const Register rOop = src.first()->as_Register();\n+    int oop_slot = -1;\n+    if (rOop == j_rarg0) {\n+      oop_slot = 0;\n+    } else if (rOop == j_rarg1) {\n+      oop_slot = 1;\n+    } else if (rOop == j_rarg2) {\n+      oop_slot = 2;\n+    } else if (rOop == j_rarg3) {\n+      oop_slot = 3;\n+    } else if (rOop == j_rarg4) {\n+      oop_slot = 4;\n+    } else if (rOop == j_rarg5) {\n+      oop_slot = 5;\n+    } else if (rOop == j_rarg6) {\n+      oop_slot = 6;\n+    } else {\n+      assert(rOop == j_rarg7, \"wrong register\");\n+      oop_slot = 7;\n+    }\n+\n+    oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;\n+    int offset = oop_slot * VMRegImpl::stack_slot_size;\n+\n+    map->set_oop(VMRegImpl::stack2reg(oop_slot));\n+    \/\/ Store oop in handle area, may be NULL\n+    sd(rOop, Address(sp, offset));\n+    if (is_receiver) {\n+      *receiver_offset = offset;\n+    }\n+\n+    \/\/rOop maybe the same as rHandle\n+    if (rOop == rHandle) {\n+      Label isZero;\n+      beqz(rOop, isZero);\n+      la(rHandle, Address(sp, offset));\n+      bind(isZero);\n+    } else {\n+      Label notZero2;\n+      la(rHandle, Address(sp, offset));\n+      bnez(rOop, notZero2);\n+      mv(rHandle, zr);\n+      bind(notZero2);\n+    }\n+  }\n+\n+  \/\/ If arg is on the stack then place it otherwise it is already in correct reg.\n+  if (dst.first()->is_stack()) {\n+    sd(rHandle, Address(sp, reg2offset_out(dst.first())));\n+  }\n+}\n+\n+\/\/ A float arg may have to do float reg int reg conversion\n+void MacroAssembler::float_move(VMRegPair src, VMRegPair dst, Register tmp) {\n+  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n+         src.first()->is_reg() && dst.first()->is_reg() ||\n+         src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      lwu(tmp, Address(fp, reg2offset_in(src.first())));\n+      sw(tmp, Address(sp, reg2offset_out(dst.first())));\n+    } else if (dst.first()->is_Register()) {\n+      lwu(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  } else if (src.first() != dst.first()) {\n+    if (src.is_single_phys_reg() && dst.is_single_phys_reg()) {\n+      fmv_s(dst.first()->as_FloatRegister(), src.first()->as_FloatRegister());\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+\/\/ A long move\n+void MacroAssembler::long_move(VMRegPair src, VMRegPair dst, Register tmp) {\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      \/\/ stack to stack\n+      ld(tmp, Address(fp, reg2offset_in(src.first())));\n+      sd(tmp, Address(sp, reg2offset_out(dst.first())));\n+    } else {\n+      \/\/ stack to reg\n+      ld(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    sd(src.first()->as_Register(), Address(sp, reg2offset_out(dst.first())));\n+  } else {\n+    if (dst.first() != src.first()) {\n+      mv(dst.first()->as_Register(), src.first()->as_Register());\n+    }\n+  }\n+}\n+\n+\/\/ A double move\n+void MacroAssembler::double_move(VMRegPair src, VMRegPair dst, Register tmp) {\n+  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n+         src.first()->is_reg() && dst.first()->is_reg() ||\n+         src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      ld(tmp, Address(fp, reg2offset_in(src.first())));\n+      sd(tmp, Address(sp, reg2offset_out(dst.first())));\n+    } else if (dst.first()-> is_Register()) {\n+      ld(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  } else if (src.first() != dst.first()) {\n+    if (src.is_single_phys_reg() && dst.is_single_phys_reg()) {\n+      fmv_d(dst.first()->as_FloatRegister(), src.first()->as_FloatRegister());\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+void MacroAssembler::rt_call(address dest, Register tmp) {\n+  CodeBlob *cb = CodeCache::find_blob(dest);\n+  if (cb) {\n+    far_call(RuntimeAddress(dest));\n+  } else {\n+    int32_t offset = 0;\n+    la_patchable(tmp, RuntimeAddress(dest), offset);\n+    jalr(x1, tmp, offset);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":220,"deletions":27,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"code\/vmreg.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"nativeInst_riscv.hpp\"\n@@ -51,0 +53,3 @@\n+  static inline void assert_alignment(address pc, int alignment = NativeInstruction::instruction_size) {\n+    assert(is_aligned(pc, alignment), \"bad alignment\");\n+  }\n@@ -643,1 +648,1 @@\n-  address read_polling_page(Register r, int32_t offset, relocInfo::relocType rtype);\n+  void read_polling_page(Register r, int32_t offset, relocInfo::relocType rtype);\n@@ -681,1 +686,1 @@\n-  \/\/   - indirect call: movptr_with_offset + jalr\n+  \/\/   - indirect call: movptr + jalr\n@@ -872,0 +877,16 @@\n+\n+  \/\/ support for argument shuffling\n+  void move32_64(VMRegPair src, VMRegPair dst, Register tmp = t0);\n+  void float_move(VMRegPair src, VMRegPair dst, Register tmp = t0);\n+  void long_move(VMRegPair src, VMRegPair dst, Register tmp = t0);\n+  void double_move(VMRegPair src, VMRegPair dst, Register tmp = t0);\n+  void object_move(OopMap* map,\n+                   int oop_handle_offset,\n+                   int framesize_in_slots,\n+                   VMRegPair src,\n+                   VMRegPair dst,\n+                   bool is_receiver,\n+                   int* receiver_offset);\n+\n+  void rt_call(address dest, Register tmp = t0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -268,0 +268,7 @@\n+  \/\/ Patching to not_entrant can happen while activations of the method are\n+  \/\/ in use. The patching in that instance must happen only when certain\n+  \/\/ alignment restrictions are true. These guarantees check those\n+  \/\/ conditions.\n+\n+  \/\/ Must be 4 bytes aligned\n+  MacroAssembler::assert_alignment(verified_entry);\n@@ -276,1 +283,1 @@\n-  \/\/ As a special case we also use sequence movptr_with_offset(r,0), jalr(r,0)\n+  \/\/ As a special case we also use sequence movptr(r,0), jalr(r,0)\n@@ -358,0 +365,2 @@\n+  check_verified_entry_alignment(entry, verified_entry);\n+\n@@ -386,1 +395,1 @@\n-  a.movptr_with_offset(t0, entry, offset); \/\/ lui, addi, slli, addi, slli\n+  a.movptr(t0, entry, offset); \/\/ lui, addi, slli, addi, slli\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -331,1 +331,0 @@\n-    movptr_with_offset_instruction_size =    5 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli. See movptr_with_offset().\n@@ -345,1 +344,1 @@\n-      if (is_addi_at(addr_at(movptr_with_offset_instruction_size))) {\n+      if (is_addi_at(addr_at(movptr_instruction_size - NativeInstruction::instruction_size))) {\n@@ -350,1 +349,1 @@\n-        return addr_at(movptr_with_offset_instruction_size);\n+        return addr_at(movptr_instruction_size - NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1321,0 +1321,1 @@\n+  MacroAssembler::assert_alignment(__ pc());\n@@ -1738,0 +1739,4 @@\n+\n+  \/\/ These NOPs are critical so that verified entry point is properly\n+  \/\/ 4 bytes aligned for patching by NativeJump::patch_verified_entry()\n+  __ align(NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -222,14 +222,0 @@\n-\/\/ The java_calling_convention describes stack locations as ideal slots on\n-\/\/ a frame with no abi restrictions. Since we must observe abi restrictions\n-\/\/ (like the placement of the register window) the slots must be biased by\n-\/\/ the following value.\n-static int reg2offset_in(VMReg r) {\n-  \/\/ Account for saved fp and ra\n-  \/\/ This should really be in_preserve_stack_slots\n-  return r->reg2stack() * VMRegImpl::stack_slot_size;\n-}\n-\n-static int reg2offset_out(VMReg r) {\n-  return (r->reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;\n-}\n-\n@@ -764,177 +750,0 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (riscv64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n-\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      \/\/ stack to stack\n-      __ ld(t0, Address(fp, reg2offset_in(src.first())));\n-      __ sd(t0, Address(sp, reg2offset_out(dst.first())));\n-    } else {\n-      \/\/ stack to reg\n-      __ lw(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n-    }\n-  } else if (dst.first()->is_stack()) {\n-    \/\/ reg to stack\n-    __ sd(src.first()->as_Register(), Address(sp, reg2offset_out(dst.first())));\n-  } else {\n-    if (dst.first() != src.first()) {\n-      \/\/ 32bits extend sign\n-      __ addw(dst.first()->as_Register(), src.first()->as_Register(), zr);\n-    }\n-  }\n-}\n-\n-\/\/ An oop arg. Must pass a handle not the oop itself\n-static void object_move(MacroAssembler* masm,\n-                        OopMap* map,\n-                        int oop_handle_offset,\n-                        int framesize_in_slots,\n-                        VMRegPair src,\n-                        VMRegPair dst,\n-                        bool is_receiver,\n-                        int* receiver_offset) {\n-  \/\/ must pass a handle. First figure out the location we use as a handle\n-  Register rHandle = dst.first()->is_stack() ? t1 : dst.first()->as_Register();\n-\n-  \/\/ See if oop is NULL if it is we need no handle\n-\n-  if (src.first()->is_stack()) {\n-\n-    \/\/ Oop is already on the stack as an argument\n-    int offset_in_older_frame = src.first()->reg2stack() + SharedRuntime::out_preserve_stack_slots();\n-    map->set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));\n-    if (is_receiver) {\n-      *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;\n-    }\n-\n-    __ ld(t0, Address(fp, reg2offset_in(src.first())));\n-    __ la(rHandle, Address(fp, reg2offset_in(src.first())));\n-    \/\/ conditionally move a NULL\n-    Label notZero1;\n-    __ bnez(t0, notZero1);\n-    __ mv(rHandle, zr);\n-    __ bind(notZero1);\n-  } else {\n-\n-    \/\/ Oop is in a register we must store it to the space we reserve\n-    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n-\n-    const Register rOop = src.first()->as_Register();\n-    int oop_slot = -1;\n-    if (rOop == j_rarg0) {\n-      oop_slot = 0;\n-    } else if (rOop == j_rarg1) {\n-      oop_slot = 1;\n-    } else if (rOop == j_rarg2) {\n-      oop_slot = 2;\n-    } else if (rOop == j_rarg3) {\n-      oop_slot = 3;\n-    } else if (rOop == j_rarg4) {\n-      oop_slot = 4;\n-    } else if (rOop == j_rarg5) {\n-      oop_slot = 5;\n-    } else if (rOop == j_rarg6) {\n-      oop_slot = 6;\n-    } else {\n-      assert(rOop == j_rarg7, \"wrong register\");\n-      oop_slot = 7;\n-    }\n-\n-    oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;\n-    int offset = oop_slot * VMRegImpl::stack_slot_size;\n-\n-    map->set_oop(VMRegImpl::stack2reg(oop_slot));\n-    \/\/ Store oop in handle area, may be NULL\n-    __ sd(rOop, Address(sp, offset));\n-    if (is_receiver) {\n-      *receiver_offset = offset;\n-    }\n-\n-    \/\/rOop maybe the same as rHandle\n-    if (rOop == rHandle) {\n-      Label isZero;\n-      __ beqz(rOop, isZero);\n-      __ la(rHandle, Address(sp, offset));\n-      __ bind(isZero);\n-    } else {\n-      Label notZero2;\n-      __ la(rHandle, Address(sp, offset));\n-      __ bnez(rOop, notZero2);\n-      __ mv(rHandle, zr);\n-      __ bind(notZero2);\n-    }\n-  }\n-\n-  \/\/ If arg is on the stack then place it otherwise it is already in correct reg.\n-  if (dst.first()->is_stack()) {\n-    __ sd(rHandle, Address(sp, reg2offset_out(dst.first())));\n-  }\n-}\n-\n-\/\/ A float arg may have to do float reg int reg conversion\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n-         src.first()->is_reg() && dst.first()->is_reg() || src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      __ lwu(t0, Address(fp, reg2offset_in(src.first())));\n-      __ sw(t0, Address(sp, reg2offset_out(dst.first())));\n-    } else if (dst.first()->is_Register()) {\n-      __ lwu(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  } else if (src.first() != dst.first()) {\n-    if (src.is_single_phys_reg() && dst.is_single_phys_reg()) {\n-      __ fmv_s(dst.first()->as_FloatRegister(), src.first()->as_FloatRegister());\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  }\n-}\n-\n-\/\/ A long move\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      \/\/ stack to stack\n-      __ ld(t0, Address(fp, reg2offset_in(src.first())));\n-      __ sd(t0, Address(sp, reg2offset_out(dst.first())));\n-    } else {\n-      \/\/ stack to reg\n-      __ ld(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n-    }\n-  } else if (dst.first()->is_stack()) {\n-    \/\/ reg to stack\n-    __ sd(src.first()->as_Register(), Address(sp, reg2offset_out(dst.first())));\n-  } else {\n-    if (dst.first() != src.first()) {\n-      __ mv(dst.first()->as_Register(), src.first()->as_Register());\n-    }\n-  }\n-}\n-\n-\/\/ A double move\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  assert(src.first()->is_stack() && dst.first()->is_stack() ||\n-         src.first()->is_reg() && dst.first()->is_reg() || src.first()->is_stack() && dst.first()->is_reg(), \"Unexpected error\");\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      __ ld(t0, Address(fp, reg2offset_in(src.first())));\n-      __ sd(t0, Address(sp, reg2offset_out(dst.first())));\n-    } else if (dst.first()-> is_Register()) {\n-      __ ld(dst.first()->as_Register(), Address(fp, reg2offset_in(src.first())));\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  } else if (src.first() != dst.first()) {\n-    if (src.is_single_phys_reg() && dst.is_single_phys_reg()) {\n-      __ fmv_d(dst.first()->as_FloatRegister(), src.first()->as_FloatRegister());\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  }\n-}\n-\n@@ -1008,11 +817,0 @@\n-static void rt_call(MacroAssembler* masm, address dest) {\n-  CodeBlob *cb = CodeCache::find_blob(dest);\n-  if (cb) {\n-    __ far_call(RuntimeAddress(dest));\n-  } else {\n-    int32_t offset = 0;\n-    __ la_patchable(t0, RuntimeAddress(dest), offset);\n-    __ jalr(x1, t0, offset);\n-  }\n-}\n-\n@@ -1143,0 +941,1 @@\n+    MacroAssembler::assert_alignment(__ pc());\n@@ -1294,0 +1093,1 @@\n+  MacroAssembler::assert_alignment(__ pc());\n@@ -1400,3 +1200,3 @@\n-        object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],\n-                    ((i == 0) && (!is_static)),\n-                    &receiver_offset);\n+        __ object_move(map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],\n+                       ((i == 0) && (!is_static)),\n+                       &receiver_offset);\n@@ -1409,1 +1209,1 @@\n-        float_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ float_move(in_regs[i], out_regs[c_arg]);\n@@ -1417,1 +1217,1 @@\n-        double_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ double_move(in_regs[i], out_regs[c_arg]);\n@@ -1422,1 +1222,1 @@\n-        long_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ long_move(in_regs[i], out_regs[c_arg]);\n@@ -1431,1 +1231,1 @@\n-        move32_64(masm, in_regs[i], out_regs[c_arg]);\n+        __ move32_64(in_regs[i], out_regs[c_arg]);\n@@ -1561,1 +1361,1 @@\n-  rt_call(masm, native_func);\n+  __ rt_call(native_func);\n@@ -1757,1 +1557,1 @@\n-    rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));\n@@ -1784,1 +1584,1 @@\n-  rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n+  __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n@@ -2271,1 +2071,1 @@\n-    __ stop(\"SharedRuntime::generate_deopt_blob: last_Java_fp not cleared\");\n+    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":13,"deletions":213,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -655,1 +655,1 @@\n-    __ movptr_with_offset(t0, CAST_FROM_FN_PTR(address, MacroAssembler::debug64), offset);\n+    __ movptr(t0, CAST_FROM_FN_PTR(address, MacroAssembler::debug64), offset);\n@@ -3744,1 +3744,1 @@\n-    __ movptr_with_offset(t0, runtime_entry, offset);\n+    __ movptr(t0, runtime_entry, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-    __ movptr_with_offset(rarg, Universe::the_null_sentinel_addr(), offset);\n+    __ movptr(rarg, Universe::the_null_sentinel_addr(), offset);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,0 +351,6 @@\n+void Assembler::emit_arith_operand_imm32(int op1, Register rm, Address adr, int32_t imm32) {\n+  assert(op1 == 0x81, \"unexpected opcode\");\n+  emit_int8(op1);\n+  emit_operand(rm, adr, 4);\n+  emit_int32(imm32);\n+}\n@@ -594,1 +600,1 @@\n-                                    int rip_relative_correction) {\n+                                    int post_addr_length) {\n@@ -682,1 +688,1 @@\n-      address next_ip = pc() + sizeof(int32_t) + rip_relative_correction;\n+      address next_ip = pc() + sizeof(int32_t) + post_addr_length;\n@@ -705,1 +711,1 @@\n-                             int rip_relative_correction) {\n+                             int post_addr_length) {\n@@ -708,1 +714,1 @@\n-                      scale, disp, rspec, rip_relative_correction);\n+                      scale, disp, rspec, post_addr_length);\n@@ -713,1 +719,2 @@\n-                             RelocationHolder const& rspec) {\n+                             RelocationHolder const& rspec,\n+                             int post_addr_length) {\n@@ -717,1 +724,1 @@\n-                      scale, disp, rspec);\n+                      scale, disp, rspec, post_addr_length);\n@@ -722,1 +729,2 @@\n-                             RelocationHolder const& rspec) {\n+                             RelocationHolder const& rspec,\n+                             int post_addr_length) {\n@@ -726,1 +734,1 @@\n-                      scale, disp, rspec, \/* rip_relative_correction *\/ 0);\n+                      scale, disp, rspec, post_addr_length);\n@@ -730,1 +738,1 @@\n-                             int rip_relative_correction) {\n+                             int post_addr_length) {\n@@ -733,1 +741,1 @@\n-               rip_relative_correction);\n+               post_addr_length);\n@@ -739,1 +747,1 @@\n-                             int rip_relative_correction) {\n+                             int post_addr_length) {\n@@ -742,1 +750,1 @@\n-                      scale, disp, rspec, rip_relative_correction);\n+                      scale, disp, rspec, post_addr_length);\n@@ -1250,5 +1258,2 @@\n-void Assembler::emit_operand(Register reg, Address adr,\n-                             int rip_relative_correction) {\n-  emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,\n-               adr._rspec,\n-               rip_relative_correction);\n+void Assembler::emit_operand(Register reg, Address adr, int post_addr_length) {\n+  emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec, post_addr_length);\n@@ -1257,1 +1262,1 @@\n-void Assembler::emit_operand(XMMRegister reg, Address adr) {\n+void Assembler::emit_operand(XMMRegister reg, Address adr, int post_addr_length) {\n@@ -1259,1 +1264,1 @@\n-     emit_operand(reg, adr._base, adr._xmmindex, adr._scale, adr._disp, adr._rspec);\n+     emit_operand(reg, adr._base, adr._xmmindex, adr._scale, adr._disp, adr._rspec, post_addr_length);\n@@ -1261,2 +1266,1 @@\n-     emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,\n-     adr._rspec);\n+     emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec, post_addr_length);\n@@ -1278,1 +1282,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -1290,1 +1294,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1313,0 +1317,1 @@\n+  emit_int8(0x66);\n@@ -1330,1 +1335,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -1342,1 +1347,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1406,1 +1411,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1423,1 +1428,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1432,1 +1437,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1457,1 +1462,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1481,1 +1486,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1505,1 +1510,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1527,1 +1532,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -1550,1 +1555,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -1557,1 +1562,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1578,1 +1583,1 @@\n-  emit_operand(dst, src2);\n+  emit_operand(dst, src2, 0);\n@@ -1613,1 +1618,1 @@\n-  emit_operand(rbx, src);\n+  emit_operand(rbx, src, 0);\n@@ -1630,1 +1635,1 @@\n-  emit_operand(rdx, src);\n+  emit_operand(rdx, src, 0);\n@@ -1646,1 +1651,1 @@\n-  emit_operand(rcx, src);\n+  emit_operand(rcx, src, 0);\n@@ -1681,1 +1686,1 @@\n-  emit_operand(rdx, adr);\n+  emit_operand(rdx, adr, 0);\n@@ -1719,1 +1724,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1733,3 +1738,1 @@\n-  emit_int8((unsigned char)0x81);\n-  emit_operand(rdi, dst, 4);\n-  emit_int32(imm32);\n+  emit_arith_operand(0x81, as_Register(7), dst, imm32);\n@@ -1748,1 +1751,1 @@\n-void Assembler::cmpl(Register dst, Address  src) {\n+void Assembler::cmpl(Register dst, Address src) {\n@@ -1752,1 +1755,7 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::cmpl_imm32(Address dst, int32_t imm32) {\n+  InstructionMark im(this);\n+  prefix(dst);\n+  emit_arith_operand_imm32(0x81, as_Register(7), dst, imm32);\n@@ -1770,1 +1779,1 @@\n-  emit_operand(reg, adr);\n+  emit_operand(reg, adr, 0);\n@@ -1778,1 +1787,1 @@\n-  emit_operand(reg, adr);\n+  emit_operand(reg, adr, 0);\n@@ -1788,1 +1797,1 @@\n-  emit_operand(reg, adr);\n+  emit_operand(reg, adr, 0);\n@@ -1801,1 +1810,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1819,1 +1828,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1907,1 +1916,1 @@\n-  emit_operand(crc, adr);\n+  emit_operand(crc, adr, 0);\n@@ -1954,1 +1963,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1971,1 +1980,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -1988,1 +1997,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2012,1 +2021,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2231,1 +2240,1 @@\n-  emit_operand(rcx, dst);\n+  emit_operand(rcx, dst, 0);\n@@ -2242,1 +2251,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2260,1 +2269,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2301,1 +2310,1 @@\n-    emit_operand(dst, src);\n+    emit_operand(dst, src, 1);\n@@ -2305,1 +2314,1 @@\n-    emit_operand(dst, src);\n+    emit_operand(dst, src, 4);\n@@ -2324,1 +2333,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2333,1 +2342,1 @@\n-  emit_operand(rax, dst);\n+  emit_operand(rax, dst, 0);\n@@ -2393,1 +2402,1 @@\n-  emit_operand(rsp, adr);\n+  emit_operand(rsp, adr, 0);\n@@ -2464,1 +2473,1 @@\n-    emit_operand(as_Register(2), src);\n+    emit_operand(as_Register(2), src, 0);\n@@ -2470,1 +2479,1 @@\n-    emit_operand(as_Register(2), src);\n+    emit_operand(as_Register(2), src, 0);\n@@ -2478,1 +2487,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2506,1 +2515,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2554,1 +2563,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2574,1 +2583,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2585,1 +2594,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2629,1 +2638,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2638,1 +2647,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -2675,1 +2684,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2684,1 +2693,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -2964,1 +2973,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -2989,1 +2998,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -2999,1 +3008,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3016,1 +3025,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3026,1 +3035,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3044,1 +3053,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3062,1 +3071,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3075,1 +3084,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3084,1 +3093,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3093,1 +3102,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3102,1 +3111,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3111,1 +3120,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3120,1 +3129,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3129,1 +3138,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3162,1 +3171,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3183,1 +3192,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3203,1 +3212,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3224,1 +3233,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3261,1 +3270,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3282,1 +3291,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3287,1 +3296,0 @@\n-  if (dst->encoding() == src->encoding()) return;\n@@ -3320,1 +3328,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3341,1 +3349,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3361,1 +3369,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3376,1 +3384,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3390,1 +3398,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3401,1 +3409,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3412,1 +3420,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3442,1 +3450,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3467,1 +3475,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3479,1 +3487,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3496,1 +3504,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3507,1 +3515,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3514,1 +3522,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3529,1 +3537,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3539,1 +3547,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3549,1 +3557,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3559,1 +3567,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3577,1 +3585,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3585,1 +3593,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -3592,1 +3600,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3605,1 +3613,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3617,1 +3625,1 @@\n-  emit_operand(rsp, src);\n+  emit_operand(rsp, src, 0);\n@@ -3633,1 +3641,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3651,1 +3659,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -3670,1 +3678,1 @@\n-  emit_operand(as_Register(3), dst);\n+  emit_operand(as_Register(3), dst, 0);\n@@ -4004,1 +4012,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -4016,1 +4024,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -4031,1 +4039,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -4070,1 +4078,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -4133,1 +4141,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -4161,1 +4169,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -4238,1 +4246,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -4292,1 +4300,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 0);\n@@ -4306,1 +4314,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 0);\n@@ -4326,1 +4334,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 1);\n@@ -4339,1 +4347,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 0);\n@@ -4352,1 +4360,1 @@\n-  emit_operand(as_Register(kdst->encoding()), src);\n+  emit_operand(as_Register(kdst->encoding()), src, 0);\n@@ -4390,1 +4398,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 0);\n@@ -4432,1 +4440,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 0);\n@@ -4489,1 +4497,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 0);\n@@ -4542,1 +4550,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -4559,1 +4567,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -4576,1 +4584,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -4593,1 +4601,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -4610,1 +4618,1 @@\n-  emit_operand(dst,src);\n+  emit_operand(dst, src, 1);\n@@ -4634,1 +4642,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -4658,1 +4666,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -4675,1 +4683,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -4714,1 +4722,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -4774,1 +4782,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -4805,1 +4813,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -4896,1 +4904,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -4910,1 +4918,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -4922,1 +4930,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -4989,1 +4997,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5061,1 +5069,1 @@\n-  emit_operand(rax, dst);\n+  emit_operand(rax, dst, 0);\n@@ -5070,1 +5078,1 @@\n-  emit_operand(rax, src); \/\/ 0, src\n+  emit_operand(rax, src, 0); \/\/ 0, src\n@@ -5078,1 +5086,1 @@\n-  emit_operand(rax, src); \/\/ 0, src\n+  emit_operand(rax, src, 0); \/\/ 0, src\n@@ -5086,1 +5094,1 @@\n-  emit_operand(rcx, src); \/\/ 1, src\n+  emit_operand(rcx, src, 0); \/\/ 1, src\n@@ -5094,1 +5102,1 @@\n-  emit_operand(rdx, src); \/\/ 2, src\n+  emit_operand(rdx, src, 0); \/\/ 2, src\n@@ -5102,1 +5110,1 @@\n-  emit_operand(rbx, src); \/\/ 3, src\n+  emit_operand(rbx, src, 0); \/\/ 3, src\n@@ -5110,1 +5118,1 @@\n-  emit_operand(rcx, src); \/\/ 1, src\n+  emit_operand(rcx, src, 0); \/\/ 1, src\n@@ -5152,1 +5160,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5183,1 +5191,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -5212,1 +5220,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -5296,1 +5304,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5315,1 +5323,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5349,1 +5357,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5367,1 +5375,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5407,1 +5415,1 @@\n-  emit_operand(rsi, src);\n+  emit_operand(rsi, src, 0);\n@@ -5567,1 +5575,1 @@\n-    emit_operand(as_Register(4), dst);\n+    emit_operand(as_Register(4), dst, 0);\n@@ -5571,1 +5579,1 @@\n-    emit_operand(as_Register(4), dst);\n+    emit_operand(as_Register(4), dst, 1);\n@@ -5580,1 +5588,1 @@\n-  emit_operand(as_Register(4), dst);\n+  emit_operand(as_Register(4), dst, 0);\n@@ -5604,1 +5612,1 @@\n-    emit_operand(as_Register(7), dst);\n+    emit_operand(as_Register(7), dst, 0);\n@@ -5608,1 +5616,1 @@\n-    emit_operand(as_Register(7), dst);\n+    emit_operand(as_Register(7), dst, 1);\n@@ -5617,1 +5625,1 @@\n-  emit_operand(as_Register(7), dst);\n+  emit_operand(as_Register(7), dst, 0);\n@@ -5651,1 +5659,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5790,1 +5798,1 @@\n-  emit_operand(as_Register(5), dst);\n+  emit_operand(as_Register(5), dst, 0);\n@@ -5799,1 +5807,1 @@\n-    emit_operand(as_Register(5), dst);\n+    emit_operand(as_Register(5), dst, 0);\n@@ -5803,1 +5811,1 @@\n-    emit_operand(as_Register(5), dst);\n+    emit_operand(as_Register(5), dst, 1);\n@@ -5847,1 +5855,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -5867,1 +5875,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5888,1 +5896,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5898,1 +5906,1 @@\n-    emit_operand(as_Register(3), dst);\n+    emit_operand(as_Register(3), dst, 0);\n@@ -5904,1 +5912,1 @@\n-    emit_operand(as_Register(3), dst);\n+    emit_operand(as_Register(3), dst, 0);\n@@ -5918,1 +5926,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -5936,1 +5944,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5960,1 +5968,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -5977,1 +5985,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6000,4 +6008,0 @@\n-  if (imm32 >= 0 && is8bit(imm32)) {\n-    testb(dst, imm32);\n-    return;\n-  }\n@@ -6005,0 +6009,1 @@\n+  prefix(dst);\n@@ -6006,1 +6011,1 @@\n-  emit_operand(as_Register(0), dst);\n+  emit_operand(as_Register(0), dst, 4);\n@@ -6011,4 +6016,0 @@\n-  if (imm32 >= 0 && is8bit(imm32) && dst->has_byte_register()) {\n-    testb(dst, imm32);\n-    return;\n-  }\n@@ -6038,1 +6039,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6056,1 +6057,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6072,1 +6073,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6083,1 +6084,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6101,1 +6102,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6119,1 +6120,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -6127,1 +6128,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -6134,1 +6135,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -6157,1 +6158,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6165,1 +6166,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6172,1 +6173,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6203,1 +6204,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6215,1 +6216,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -6222,1 +6223,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6229,1 +6230,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -6247,1 +6248,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6265,1 +6266,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6283,1 +6284,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6301,1 +6302,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6333,1 +6334,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6351,1 +6352,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6369,1 +6370,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6387,1 +6388,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6417,1 +6418,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6451,1 +6452,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6461,1 +6462,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6502,1 +6503,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6512,1 +6513,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6531,1 +6532,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6564,1 +6565,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6574,1 +6575,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6598,1 +6599,1 @@\n-  emit_operand(dst, src2);\n+  emit_operand(dst, src2, 0);\n@@ -6608,1 +6609,1 @@\n-  emit_operand(dst, src2);\n+  emit_operand(dst, src2, 0);\n@@ -6649,1 +6650,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6659,1 +6660,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6675,1 +6676,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -6696,1 +6697,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -6716,1 +6717,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6733,1 +6734,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6758,1 +6759,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6769,1 +6770,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6795,1 +6796,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6805,1 +6806,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6848,1 +6849,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6858,1 +6859,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6884,1 +6885,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6894,1 +6895,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -6941,1 +6942,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7002,1 +7003,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7012,1 +7013,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7022,1 +7023,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7033,1 +7034,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7108,1 +7109,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7118,1 +7119,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7128,1 +7129,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7139,1 +7140,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7208,1 +7209,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7218,1 +7219,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7229,1 +7230,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7704,1 +7705,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7821,1 +7822,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7858,1 +7859,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7888,1 +7889,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7924,1 +7925,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7952,1 +7953,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7967,1 +7968,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -7994,1 +7995,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8021,1 +8022,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8041,1 +8042,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8163,1 +8164,1 @@\n-  emit_operand(dst, src3);\n+  emit_operand(dst, src3, 1);\n@@ -8278,1 +8279,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -8308,1 +8309,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -8351,1 +8352,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -8379,1 +8380,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -8409,1 +8410,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -8439,1 +8440,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -8470,1 +8471,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -8515,1 +8516,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -8543,1 +8544,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -8574,1 +8575,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -8619,1 +8620,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 1);\n@@ -8642,1 +8643,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8662,1 +8663,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8725,1 +8726,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8752,1 +8753,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8781,1 +8782,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8810,1 +8811,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8839,1 +8840,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8868,1 +8869,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8895,1 +8896,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8922,1 +8923,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8951,1 +8952,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -8980,1 +8981,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9009,1 +9010,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9038,1 +9039,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9065,1 +9066,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9094,1 +9095,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9121,1 +9122,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9150,1 +9151,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9179,1 +9180,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9208,1 +9209,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9237,1 +9238,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9267,1 +9268,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9296,1 +9297,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9325,1 +9326,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9354,1 +9355,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9385,1 +9386,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9416,1 +9417,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9445,1 +9446,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9474,1 +9475,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9500,1 +9501,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9526,1 +9527,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9552,1 +9553,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9578,1 +9579,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9946,1 +9947,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -9972,1 +9973,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10000,1 +10001,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10028,1 +10029,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10055,1 +10056,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10081,1 +10082,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10109,1 +10110,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10137,1 +10138,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10167,1 +10168,1 @@\n-  emit_operand(dst, src3);\n+  emit_operand(dst, src3, 1);\n@@ -10198,1 +10199,1 @@\n-  emit_operand(dst, src3);\n+  emit_operand(dst, src3, 1);\n@@ -10235,1 +10236,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10257,1 +10258,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10271,1 +10272,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10294,1 +10295,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10316,1 +10317,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10340,1 +10341,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10353,1 +10354,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10404,1 +10405,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10417,1 +10418,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10430,1 +10431,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10443,1 +10444,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10460,1 +10461,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10478,1 +10479,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10496,1 +10497,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10514,1 +10515,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -10528,1 +10529,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -10542,1 +10543,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -10556,1 +10557,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -10570,1 +10571,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -10627,1 +10628,1 @@\n-  emit_operand32(rbp, adr);\n+  emit_operand32(rbp, adr, 0);\n@@ -10633,1 +10634,1 @@\n-  emit_operand32(rdi, adr);\n+  emit_operand32(rdi, adr, 0);\n@@ -10636,1 +10637,1 @@\n-void Assembler::emit_operand32(Register reg, Address adr) {\n+void Assembler::emit_operand32(Register reg, Address adr, int post_addr_length) {\n@@ -10639,2 +10640,1 @@\n-  emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,\n-               adr._rspec);\n+  emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec, post_addr_length);\n@@ -10666,1 +10666,1 @@\n-  emit_operand(rdi, src1);\n+  emit_operand(rdi, src1, 4);\n@@ -10676,1 +10676,1 @@\n-  emit_operand(rcx, adr);\n+  emit_operand(rcx, adr, 0);\n@@ -10703,1 +10703,1 @@\n-  emit_operand32(rax, src);\n+  emit_operand32(rax, src, 0);\n@@ -10709,1 +10709,1 @@\n-  emit_operand32(rax, src);\n+  emit_operand32(rax, src, 0);\n@@ -10735,1 +10735,1 @@\n-  emit_operand32(rbx, src);\n+  emit_operand32(rbx, src, 0);\n@@ -10741,1 +10741,1 @@\n-  emit_operand32(rbx, src);\n+  emit_operand32(rbx, src, 0);\n@@ -10763,1 +10763,1 @@\n-  emit_operand32(rsi, src);\n+  emit_operand32(rsi, src, 0);\n@@ -10769,1 +10769,1 @@\n-  emit_operand32(rsi, src);\n+  emit_operand32(rsi, src, 0);\n@@ -10790,1 +10790,1 @@\n-  emit_operand32(rdi, src);\n+  emit_operand32(rdi, src, 0);\n@@ -10796,1 +10796,1 @@\n-  emit_operand32(rdi, src);\n+  emit_operand32(rdi, src, 0);\n@@ -10814,1 +10814,1 @@\n-  emit_operand32(rbp, adr);\n+  emit_operand32(rbp, adr, 0);\n@@ -10820,1 +10820,1 @@\n-  emit_operand32(rax, adr);\n+  emit_operand32(rax, adr, 0);\n@@ -10834,1 +10834,1 @@\n-  emit_operand32(rdx, adr);\n+  emit_operand32(rdx, adr, 0);\n@@ -10840,1 +10840,1 @@\n-  emit_operand32(rdi, adr);\n+  emit_operand32(rdi, adr, 0);\n@@ -10846,1 +10846,1 @@\n-  emit_operand32(rbx, adr);\n+  emit_operand32(rbx, adr, 0);\n@@ -10856,1 +10856,1 @@\n-  emit_operand32(rax, adr);\n+  emit_operand32(rax, adr, 0);\n@@ -10862,1 +10862,1 @@\n-  emit_operand32(rax, adr);\n+  emit_operand32(rax, adr, 0);\n@@ -10873,1 +10873,1 @@\n-  emit_operand32(rbp, src);\n+  emit_operand32(rbp, src, 0);\n@@ -10879,1 +10879,1 @@\n-  emit_operand32(rsp, src);\n+  emit_operand32(rsp, src, 0);\n@@ -10913,1 +10913,1 @@\n-  emit_operand32(rcx, src);\n+  emit_operand32(rcx, src, 0);\n@@ -10919,1 +10919,1 @@\n-  emit_operand32(rcx, src);\n+  emit_operand32(rcx, src, 0);\n@@ -10933,1 +10933,1 @@\n-  emit_operand32(rsi, dst);\n+  emit_operand32(rsi, dst, 0);\n@@ -10939,1 +10939,1 @@\n-  emit_operand32(rdi, src);\n+  emit_operand32(rdi, src, 0);\n@@ -10957,1 +10957,1 @@\n-  emit_operand32(rsp, src);\n+  emit_operand32(rsp, src, 0);\n@@ -10971,1 +10971,1 @@\n-  emit_operand32(rdx, adr);\n+  emit_operand32(rdx, adr, 0);\n@@ -10977,1 +10977,1 @@\n-  emit_operand32(rdx, adr);\n+  emit_operand32(rdx, adr, 0);\n@@ -10983,1 +10983,1 @@\n-  emit_operand32(rbx, adr);\n+  emit_operand32(rbx, adr, 0);\n@@ -10993,1 +10993,1 @@\n-  emit_operand32(rbx, adr);\n+  emit_operand32(rbx, adr, 0);\n@@ -11003,1 +11003,1 @@\n-  emit_operand32(rsp, src);\n+  emit_operand32(rsp, src, 0);\n@@ -11009,1 +11009,1 @@\n-  emit_operand32(rsp, src);\n+  emit_operand32(rsp, src, 0);\n@@ -11027,1 +11027,1 @@\n-  emit_operand32(rbp, src);\n+  emit_operand32(rbp, src, 0);\n@@ -11033,1 +11033,1 @@\n-  emit_operand32(rbp, src);\n+  emit_operand32(rbp, src, 0);\n@@ -11523,1 +11523,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 1);\n@@ -11556,1 +11556,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 1);\n@@ -11591,1 +11591,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 1);\n@@ -11626,1 +11626,1 @@\n-  emit_operand(as_Register(dst_enc), src);\n+  emit_operand(as_Register(dst_enc), src, 1);\n@@ -11855,1 +11855,1 @@\n-  emit_operand(dst, src2);\n+  emit_operand(dst, src2, 0);\n@@ -11864,1 +11864,1 @@\n-  emit_operand(dst, src2);\n+  emit_operand(dst, src2, 0);\n@@ -11873,1 +11873,1 @@\n-  emit_operand(dst, src2);\n+  emit_operand(dst, src2, 0);\n@@ -11882,1 +11882,1 @@\n-  emit_operand(dst, src2);\n+  emit_operand(dst, src2, 0);\n@@ -11898,1 +11898,1 @@\n-  emit_operand(dst, src1);\n+  emit_operand(dst, src1, 0);\n@@ -11914,1 +11914,1 @@\n-  emit_operand(dst, src1);\n+  emit_operand(dst, src1, 0);\n@@ -11930,1 +11930,1 @@\n-  emit_operand(dst, src1);\n+  emit_operand(dst, src1, 0);\n@@ -11946,1 +11946,1 @@\n-  emit_operand(dst, src1);\n+  emit_operand(dst, src1, 0);\n@@ -11962,1 +11962,1 @@\n-  emit_operand(dst, src1);\n+  emit_operand(dst, src1, 0);\n@@ -11978,1 +11978,1 @@\n-  emit_operand(dst, src1);\n+  emit_operand(dst, src1, 0);\n@@ -12137,1 +12137,1 @@\n-  emit_operand(rax, dst);\n+  emit_operand(rax, dst, 4);\n@@ -12557,1 +12557,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12574,1 +12574,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -12585,1 +12585,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12627,1 +12627,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12638,1 +12638,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -12654,1 +12654,1 @@\n-  emit_operand(dst, src2);\n+  emit_operand(dst, src2, 0);\n@@ -12685,1 +12685,1 @@\n-  emit_operand(rbx, src);\n+  emit_operand(rbx, src, 0);\n@@ -12701,1 +12701,1 @@\n-  emit_operand(rdx, src);\n+  emit_operand(rdx, src, 0);\n@@ -12717,1 +12717,1 @@\n-  emit_operand(rcx, src);\n+  emit_operand(rcx, src, 0);\n@@ -12728,1 +12728,1 @@\n-  emit_operand(rdi, adr);\n+  emit_operand(rdi, adr, 0);\n@@ -12743,1 +12743,1 @@\n-  emit_operand(rdi, adr);\n+  emit_operand(rdi, adr, 0);\n@@ -12758,1 +12758,1 @@\n-  emit_operand(rsi, adr);\n+  emit_operand(rsi, adr, 0);\n@@ -12769,1 +12769,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12774,3 +12774,2 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0x81);\n-  emit_operand(rdi, dst, 4);\n-  emit_int32(imm32);\n+  prefixq(dst);\n+  emit_arith_operand(0x81, as_Register(7), dst, imm32);\n@@ -12787,1 +12786,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -12798,1 +12797,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12804,1 +12803,1 @@\n-  emit_operand(reg, adr);\n+  emit_operand(reg, adr, 0);\n@@ -12821,1 +12820,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12831,1 +12830,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12840,1 +12839,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12882,1 +12881,1 @@\n-  emit_operand(rcx, dst);\n+  emit_operand(rcx, dst, 0);\n@@ -12887,1 +12886,1 @@\n-  emit_operand(as_Register(1), src);\n+  emit_operand(as_Register(1), src, 0);\n@@ -12892,1 +12891,1 @@\n-  emit_operand(as_Register(5), src);\n+  emit_operand(as_Register(5), src, 0);\n@@ -12897,1 +12896,1 @@\n-  emit_operand(as_Register(0), dst);\n+  emit_operand(as_Register(0), dst, 0);\n@@ -12902,1 +12901,1 @@\n-  emit_operand(as_Register(4), dst);\n+  emit_operand(as_Register(4), dst, 0);\n@@ -12930,1 +12929,1 @@\n-    emit_operand(dst, src);\n+    emit_operand(dst, src, 1);\n@@ -12934,1 +12933,1 @@\n-    emit_operand(dst, src);\n+    emit_operand(dst, src, 4);\n@@ -12952,1 +12951,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -12973,1 +12972,1 @@\n-  emit_operand(rax, dst);\n+  emit_operand(rax, dst, 0);\n@@ -12983,1 +12982,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13050,1 +13049,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13080,1 +13079,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13086,1 +13085,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -13092,1 +13091,1 @@\n-  emit_operand(as_Register(0), dst);\n+  emit_operand(as_Register(0), dst, 4);\n@@ -13107,1 +13106,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13137,1 +13136,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13150,1 +13149,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13163,1 +13162,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13176,1 +13175,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13187,1 +13186,1 @@\n-  emit_operand(rsp, src);\n+  emit_operand(rsp, src, 0);\n@@ -13210,1 +13209,1 @@\n-  emit_operand(as_Register(3), dst);\n+  emit_operand(as_Register(3), dst, 0);\n@@ -13247,1 +13246,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -13258,1 +13257,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13273,1 +13272,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13286,1 +13285,1 @@\n-  emit_operand(rax, dst);\n+  emit_operand(rax, dst, 0);\n@@ -13424,1 +13423,1 @@\n-  emit_operand(rsi, src);\n+  emit_operand(rsi, src, 0);\n@@ -13460,1 +13459,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -13477,1 +13476,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 1);\n@@ -13487,1 +13486,1 @@\n-    emit_operand(as_Register(4), dst);\n+    emit_operand(as_Register(4), dst, 0);\n@@ -13491,1 +13490,1 @@\n-    emit_operand(as_Register(4), dst);\n+    emit_operand(as_Register(4), dst, 1);\n@@ -13499,1 +13498,1 @@\n-  emit_operand(as_Register(4), dst);\n+  emit_operand(as_Register(4), dst, 0);\n@@ -13522,1 +13521,1 @@\n-    emit_operand(as_Register(7), dst);\n+    emit_operand(as_Register(7), dst, 0);\n@@ -13526,1 +13525,1 @@\n-    emit_operand(as_Register(7), dst);\n+    emit_operand(as_Register(7), dst, 1);\n@@ -13534,1 +13533,1 @@\n-  emit_operand(as_Register(7), dst);\n+  emit_operand(as_Register(7), dst, 0);\n@@ -13567,1 +13566,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13609,1 +13608,1 @@\n-  emit_operand(as_Register(5), dst);\n+  emit_operand(as_Register(5), dst, 0);\n@@ -13617,1 +13616,1 @@\n-    emit_operand(as_Register(5), dst);\n+    emit_operand(as_Register(5), dst, 0);\n@@ -13621,1 +13620,1 @@\n-    emit_operand(as_Register(5), dst);\n+    emit_operand(as_Register(5), dst, 1);\n@@ -13635,1 +13634,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -13652,1 +13651,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13661,4 +13660,0 @@\n-  if (imm32 >= 0) {\n-    testl(dst, imm32);\n-    return;\n-  }\n@@ -13667,1 +13662,1 @@\n-  emit_operand(as_Register(0), dst);\n+  emit_operand(as_Register(0), dst, 4);\n@@ -13672,4 +13667,0 @@\n-  if (imm32 >= 0) {\n-    testl(dst, imm32);\n-    return;\n-  }\n@@ -13699,1 +13690,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13705,1 +13696,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n@@ -13711,1 +13702,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13727,1 +13718,1 @@\n-  emit_operand(dst, src);\n+  emit_operand(dst, src, 0);\n@@ -13744,1 +13735,1 @@\n-  emit_operand(src, dst);\n+  emit_operand(src, dst, 0);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":455,"deletions":464,"binary":false,"changes":919,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-                           int rip_relative_correction = 0);\n+                           int post_addr_length);\n@@ -764,1 +764,1 @@\n-                    int rip_relative_correction = 0);\n+                    int post_addr_length);\n@@ -769,1 +769,2 @@\n-                    RelocationHolder const& rspec);\n+                    RelocationHolder const& rspec,\n+                    int post_addr_length);\n@@ -774,1 +775,2 @@\n-                    RelocationHolder const& rspec);\n+                    RelocationHolder const& rspec,\n+                    int post_addr_length);\n@@ -777,1 +779,1 @@\n-                    int rip_relative_correction = 0);\n+                    int post_addr_length);\n@@ -782,1 +784,2 @@\n-                    RelocationHolder const& rspec);\n+                    RelocationHolder const& rspec,\n+                    int post_addr_length);\n@@ -788,1 +791,1 @@\n-                           int rip_relative_correction = 0);\n+                           int post_addr_length);\n@@ -791,1 +794,1 @@\n-                    int rip_relative_correction = 0);\n+                    int post_addr_length);\n@@ -797,1 +800,1 @@\n-                    int rip_relative_correction = 0);\n+                    int post_addr_length);\n@@ -799,1 +802,1 @@\n-  void emit_operand(XMMRegister reg, Address adr);\n+  void emit_operand(XMMRegister reg, Address adr, int post_addr_length);\n@@ -803,0 +806,1 @@\n+  void emit_arith_operand_imm32(int op1, Register rm, Address adr, int32_t imm32);\n@@ -1102,0 +1106,1 @@\n+  void cmpl_imm32(Address dst, int32_t imm32);\n@@ -1369,1 +1374,1 @@\n-  void emit_operand32(Register reg, Address adr);\n+  void emit_operand32(Register reg, Address adr, int post_addr_length);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  __ cmpl(disarmed_addr, 0);\n+  __ cmpl_imm32(disarmed_addr, 0);\n@@ -333,1 +333,1 @@\n-  __ cmpl(disarmed_addr, 0);\n+  __ cmpl_imm32(disarmed_addr, 0);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3278,0 +3278,16 @@\n+void MacroAssembler::testl(Address dst, int32_t imm32) {\n+  if (imm32 >= 0 && is8bit(imm32)) {\n+    testb(dst, imm32);\n+  } else {\n+    Assembler::testl(dst, imm32);\n+  }\n+}\n+\n+void MacroAssembler::testl(Register dst, int32_t imm32) {\n+  if (imm32 >= 0 && is8bit(imm32) && dst->has_byte_register()) {\n+    testb(dst, imm32);\n+  } else {\n+    Assembler::testl(dst, imm32);\n+  }\n+}\n+\n@@ -3279,1 +3295,1 @@\n-  assert(reachable(src), \"Address should be reachable\");\n+  assert(always_reachable(src), \"Address should be reachable\");\n@@ -3283,0 +3299,20 @@\n+#ifdef _LP64\n+\n+void MacroAssembler::testq(Address dst, int32_t imm32) {\n+  if (imm32 >= 0) {\n+    testl(dst, imm32);\n+  } else {\n+    Assembler::testq(dst, imm32);\n+  }\n+}\n+\n+void MacroAssembler::testq(Register dst, int32_t imm32) {\n+  if (imm32 >= 0) {\n+    testl(dst, imm32);\n+  } else {\n+    Assembler::testq(dst, imm32);\n+  }\n+}\n+\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -894,0 +894,2 @@\n+  void testl(Address dst, int32_t imm32);\n+  void testl(Register dst, int32_t imm32);\n@@ -895,0 +897,3 @@\n+  using Assembler::testq;\n+  void testq(Address dst, int32_t imm32);\n+  void testq(Register dst, int32_t imm32);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2500,1 +2500,1 @@\n-    __ stop(\"SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\");\n+    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3118,1 +3118,1 @@\n-    __ stop(\"SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\");\n+    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2079,1 +2079,1 @@\n-  __ jmp(PRELOOP_START);\n+  __ jcc(Assembler::notEqual, PRELOOP_START);\n@@ -2084,0 +2084,3 @@\n+  __ cmpl(len_reg, 0);\n+  __ jcc(Assembler::equal, EXIT);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-    address pc = os::Posix::ucontext_get_pc(uc);\n","filename":"src\/hotspot\/os\/posix\/safefetch_static_posix.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -627,0 +627,1 @@\n+#ifndef ZERO\n@@ -651,0 +652,1 @@\n+#endif \/\/ !ZERO\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-    *fr_addr = pd_last_frame();\n+    frame last_frame = pd_last_frame();\n+    if (last_frame.pc() == nullptr) return false;\n+    *fr_addr = last_frame;\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/javaThread_aix_ppc.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,3 @@\n-    *fr_addr = pd_last_frame();\n+    frame last_frame = pd_last_frame();\n+    if (last_frame.pc() == nullptr) return false;\n+    *fr_addr = last_frame;\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/javaThread_linux_ppc.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,4 +222,0 @@\n-#ifndef AMD64\n-    \/\/ Halt if SI_KERNEL before more crashes get misdiagnosed as Java bugs\n-    \/\/ This can happen in any running code (currently more frequently in\n-    \/\/ interpreter code but has been seen in compiled code)\n@@ -227,2 +223,3 @@\n-      fatal(\"An irrecoverable SI_KERNEL SIGSEGV has occurred due \"\n-            \"to unstable signal handling in this distribution.\");\n+      \/\/ An irrecoverable SI_KERNEL SIGSEGV has occurred.\n+      \/\/ It's likely caused by dereferencing an address larger than TASK_SIZE.\n+      return false;\n@@ -230,1 +227,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -833,1 +833,1 @@\n-    ClassLoaderExt::process_jar_manifest(current, entry, check_for_duplicates);\n+    ClassLoaderExt::process_jar_manifest(current, entry);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,3 @@\n-  class Process : public ModuleClosure {\n+  GrowableArray<char*>* module_paths = new GrowableArray<char*>(5);\n+\n+  class ModulePathsGatherer : public ModuleClosure {\n@@ -87,0 +89,1 @@\n+    GrowableArray<char*>* _module_paths;\n@@ -88,1 +91,2 @@\n-    Process(JavaThread* current) : _current(current) {}\n+    ModulePathsGatherer(JavaThread* current, GrowableArray<char*>* module_paths) :\n+      _current(current), _module_paths(module_paths) {}\n@@ -93,1 +97,3 @@\n-        ClassLoader::setup_module_search_path(_current, path);\n+        char* path_copy = NEW_RESOURCE_ARRAY(char, strlen(path) + 1);\n+        strcpy(path_copy, path);\n+        _module_paths->append(path_copy);\n@@ -97,2 +103,10 @@\n-  Process process(current);\n-  met->modules_do(&process);\n+\n+  ModulePathsGatherer gatherer(current, module_paths);\n+  {\n+    MutexLocker ml(Module_lock);\n+    met->modules_do(&gatherer);\n+  }\n+\n+  for (int i = 0; i < module_paths->length(); i++) {\n+    ClassLoader::setup_module_search_path(current, module_paths->at(i));\n+  }\n@@ -171,2 +185,1 @@\n-void ClassLoaderExt::process_jar_manifest(JavaThread* current, ClassPathEntry* entry,\n-                                          bool check_for_duplicates) {\n+void ClassLoaderExt::process_jar_manifest(JavaThread* current, ClassPathEntry* entry) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  static void process_jar_manifest(JavaThread* current, ClassPathEntry* entry, bool check_for_duplicates);\n+  static void process_jar_manifest(JavaThread* current, ClassPathEntry* entry);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-    : _klass(klass), _cld(cld) {}\n+    : _next(NULL), _klass(klass), _cld(cld) {}\n@@ -140,1 +140,1 @@\n-  const ClassLoaderData* _cld;\n+  const ClassLoaderData* _cld; \/\/ May be NULL if loader never loaded anything\n@@ -157,2 +157,4 @@\n-  void print_with_childs(outputStream* st, BranchTracker& branchtracker,\n-      bool print_classes, bool verbose) const {\n+  \/\/ Returns Klass of loader; NULL for bootstrap loader\n+  const Klass* loader_klass() const {\n+    return (_loader_oop != NULL) ? _loader_oop->klass() : NULL;\n+  }\n@@ -160,1 +162,5 @@\n-    ResourceMark rm;\n+  \/\/ Returns ResourceArea-allocated class name of loader class; \"\" if there is no klass (bootstrap loader)\n+  const char* loader_class_name() const {\n+    const Klass* klass = loader_klass();\n+    return klass != NULL ? klass->external_name() : \"\";\n+  }\n@@ -162,4 +168,15 @@\n-    if (_cld == NULL) {\n-      \/\/ Not sure how this could happen: we added a preliminary node for a parent but then never encountered\n-      \/\/ its CLD?\n-      return;\n+  \/\/ Returns oop of loader name; NULL for bootstrap; NULL if no name was set\n+  oop loader_name_oop() const {\n+    return (_loader_oop != NULL) ? java_lang_ClassLoader::name(_loader_oop) : NULL;\n+  }\n+\n+  \/\/ Returns ResourceArea-allocated name of loader, \"\" if none is set\n+  const char* loader_name() const {\n+    oop name_oop = loader_name_oop();\n+    return name_oop != NULL ? java_lang_String::as_utf8_string(name_oop) : \"\";\n+  }\n+\n+  bool is_bootstrap() const {\n+    if (_loader_oop == NULL) {\n+      assert(_cld != NULL && _cld->is_boot_class_loader_data(), \"bootstrap loader must have CLD\");\n+      return true;\n@@ -167,0 +184,9 @@\n+    return false;\n+  }\n+\n+  void print_with_child_nodes(outputStream* st, BranchTracker& branchtracker,\n+      bool print_classes, bool verbose) const {\n+\n+    assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+\n+    ResourceMark rm;\n@@ -169,2 +195,3 @@\n-    const Klass* const loader_klass = _cld->class_loader_klass();\n-    const Symbol* const loader_name = _cld->name();\n+    const Klass* const the_loader_klass = loader_klass();\n+    const char* const the_loader_class_name = loader_class_name();\n+    const char* const the_loader_name = loader_name();\n@@ -176,1 +203,1 @@\n-    if (_cld->is_the_null_class_loader_data()) {\n+    if (is_bootstrap()) {\n@@ -179,3 +206,2 @@\n-      assert(!_cld->has_class_mirror_holder(), \"_cld must be the primary cld\");\n-      if (loader_name != NULL) {\n-        st->print(\" \\\"%s\\\",\", loader_name->as_C_string());\n+      if (the_loader_name[0] != '\\0') {\n+        st->print(\" \\\"%s\\\",\", the_loader_name);\n@@ -183,1 +209,1 @@\n-      st->print(\" %s\", loader_klass != NULL ? loader_klass->external_name() : \"??\");\n+      st->print(\" %s\", the_loader_class_name);\n@@ -213,1 +239,1 @@\n-        st->print_cr(\"%*s \" PTR_FORMAT, indentation, \"Loader Klass:\", p2i(loader_klass));\n+        st->print_cr(\"%*s \" PTR_FORMAT, indentation, \"Loader Klass:\", p2i(the_loader_klass));\n@@ -222,0 +248,1 @@\n+          assert(_cld != NULL, \"we have classes, we should have a CLD\");\n@@ -246,0 +273,1 @@\n+          assert(_cld != NULL, \"we have classes, we should have a CLD\");\n@@ -279,1 +307,1 @@\n-      c->print_with_childs(st, branchtracker, print_classes, verbose);\n+      c->print_with_child_nodes(st, branchtracker, print_classes, verbose);\n@@ -288,1 +316,1 @@\n-  bool can_fold_into(LoaderTreeNode* target_node) const {\n+  bool can_fold_into(const LoaderTreeNode* target_node) const {\n@@ -290,2 +318,13 @@\n-    return _cld->class_loader_klass() == target_node->_cld->class_loader_klass() &&\n-           _cld->name() == target_node->_cld->name();\n+\n+    \/\/ Must have the same non-null klass\n+    const Klass* k = loader_klass();\n+    if (k == NULL || k != target_node->loader_klass()) {\n+      return false;\n+    }\n+\n+    \/\/ Must have the same loader name, or none\n+    if (::strcmp(loader_name(), target_node->loader_name()) != 0) {\n+      return false;\n+    }\n+\n+    return true;\n@@ -303,0 +342,1 @@\n+    assert(_cld == NULL, \"there should be only one primary CLD per loader\");\n@@ -337,8 +377,0 @@\n-  const ClassLoaderData* cld() const {\n-    return _cld;\n-  }\n-\n-  const oop loader_oop() const {\n-    return _loader_oop;\n-  }\n-\n@@ -367,0 +399,1 @@\n+    ResourceMark rm;\n@@ -392,1 +425,1 @@\n-  void print_with_childs(outputStream* st, bool print_classes, bool print_add_info) const {\n+  void print_with_child_nodes(outputStream* st, bool print_classes, bool print_add_info) const {\n@@ -394,1 +427,1 @@\n-    print_with_childs(st, bwt, print_classes, print_add_info);\n+    print_with_child_nodes(st, bwt, print_classes, print_add_info);\n@@ -469,1 +502,1 @@\n-    _root->print_with_childs(st, _print_classes, _verbose);\n+    _root->print_with_child_nodes(st, _print_classes, _verbose);\n@@ -486,1 +519,0 @@\n-      assert(info->cld() == NULL, \"there should be only one primary CLD per loader\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":65,"deletions":33,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -1722,1 +1722,0 @@\n-int java_lang_Thread_FieldHolder::_stillborn_offset;\n@@ -1730,1 +1729,0 @@\n-  macro(_stillborn_offset,     k, \"stillborn\",                bool_signature,        false); \\\n@@ -1763,8 +1761,0 @@\n-bool java_lang_Thread_FieldHolder::is_stillborn(oop holder) {\n-  return holder->bool_field(_stillborn_offset) != 0;\n-}\n-\n-void java_lang_Thread_FieldHolder::set_stillborn(oop holder) {\n-  holder->bool_field_put(_stillborn_offset, true);\n-}\n-\n@@ -1934,15 +1924,0 @@\n-bool java_lang_Thread::is_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::is_stillborn(holder);\n-}\n-\n-\n-\/\/ We never have reason to turn the stillborn bit off\n-void java_lang_Thread::set_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_stillborn(holder);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -395,3 +395,0 @@\n-  \/\/ Stillborn\n-  static bool is_stillborn(oop java_thread);\n-  static void set_stillborn(oop java_thread);\n@@ -450,1 +447,0 @@\n-  static int _stillborn_offset;\n@@ -466,3 +462,0 @@\n-  static bool is_stillborn(oop holder);\n-  static void set_stillborn(oop holder);\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -697,0 +697,1 @@\n+  assert_lock_strong(Module_lock);\n@@ -704,0 +705,1 @@\n+  assert_lock_strong(Module_lock);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  do_klass(ThreadDeath_klass,                           java_lang_ThreadDeath                                 ) \\\n@@ -201,1 +200,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  template(java_lang_ThreadDeath,                     \"java\/lang\/ThreadDeath\")                    \\\n@@ -399,1 +398,0 @@\n-  template(stillborn_name,                            \"stillborn\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,2 @@\n+\n+  _deferred_obj_array = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapWord*>(10, mtGC);\n@@ -169,0 +171,9 @@\n+void ParCompactionManager::drain_deferred_objects() {\n+  while (!_deferred_obj_array->is_empty()) {\n+    HeapWord* addr = _deferred_obj_array->pop();\n+    assert(addr != NULL, \"expected a deferred object\");\n+    PSParallelCompact::update_deferred_object(this, addr);\n+  }\n+  _deferred_obj_array->clear_and_deallocate();\n+}\n+\n@@ -199,0 +210,4 @@\n+void ParCompactionManager::push_deferred_object(HeapWord* addr) {\n+  _deferred_obj_array->push(addr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+  GrowableArray<HeapWord*>*    _deferred_obj_array;\n+\n@@ -131,0 +133,2 @@\n+  void push_deferred_object(HeapWord* addr);\n+\n@@ -198,0 +202,1 @@\n+  void drain_deferred_objects();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2431,0 +2431,4 @@\n+\n+    \/\/ At this point all regions have been compacted, so it's now safe\n+    \/\/ to update the deferred objects that cross region boundaries.\n+    cm->drain_deferred_objects();\n@@ -2460,1 +2464,1 @@\n-    \/\/ Verify that all regions have been processed before the deferred updates.\n+    \/\/ Verify that all regions have been processed.\n@@ -2467,9 +2471,0 @@\n-  {\n-    GCTraceTime(Trace, gc, phases) tm(\"Deferred Updates\", &_gc_timer);\n-    \/\/ Update the deferred objects, if any.\n-    ParCompactionManager* cm = ParCompactionManager::get_vmthread_cm();\n-    for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n-      update_deferred_objects(cm, SpaceId(id));\n-    }\n-  }\n-\n@@ -2602,4 +2597,2 @@\n-void PSParallelCompact::update_deferred_objects(ParCompactionManager* cm,\n-                                                SpaceId id) {\n-  assert(id < last_space_id, \"bad space id\");\n-\n+void PSParallelCompact::update_deferred_object(ParCompactionManager* cm, HeapWord *addr) {\n+#ifdef ASSERT\n@@ -2607,2 +2600,4 @@\n-  const SpaceInfo* const space_info = _space_info + id;\n-  ObjectStartArray* const start_array = space_info->start_array();\n+  size_t region_idx = sd.addr_to_region_idx(addr);\n+  assert(sd.region(region_idx)->completed(), \"first region must be completed before deferred updates\");\n+  assert(sd.region(region_idx + 1)->completed(), \"second region must be completed before deferred updates\");\n+#endif\n@@ -2610,17 +2605,4 @@\n-  const MutableSpace* const space = space_info->space();\n-  assert(space_info->dense_prefix() >= space->bottom(), \"dense_prefix not set\");\n-  HeapWord* const beg_addr = space_info->dense_prefix();\n-  HeapWord* const end_addr = sd.region_align_up(space_info->new_top());\n-\n-  const RegionData* const beg_region = sd.addr_to_region_ptr(beg_addr);\n-  const RegionData* const end_region = sd.addr_to_region_ptr(end_addr);\n-  const RegionData* cur_region;\n-  for (cur_region = beg_region; cur_region < end_region; ++cur_region) {\n-    HeapWord* const addr = cur_region->deferred_obj_addr();\n-    if (addr != NULL) {\n-      if (start_array != NULL) {\n-        start_array->allocate_block(addr);\n-      }\n-      cm->update_contents(cast_to_oop(addr));\n-      assert(oopDesc::is_oop_or_null(cast_to_oop(addr)), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n-    }\n+  const SpaceInfo* const space_info = _space_info + space_id(addr);\n+  ObjectStartArray* const start_array = space_info->start_array();\n+  if (start_array != NULL) {\n+    start_array->allocate_block(addr);\n@@ -2628,0 +2610,3 @@\n+\n+  cm->update_contents(cast_to_oop(addr));\n+  assert(oopDesc::is_oop(cast_to_oop(addr)), \"Expected an oop at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n@@ -2874,1 +2859,0 @@\n-      region_ptr->set_deferred_obj_addr(NULL);\n@@ -2919,1 +2903,1 @@\n-      region_ptr->set_deferred_obj_addr(closure.destination());\n+      cm->push_deferred_object(closure.destination());\n@@ -2931,1 +2915,0 @@\n-      region_ptr->set_deferred_obj_addr(NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":19,"deletions":36,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -246,7 +246,0 @@\n-    \/\/ The object (if any) starting in this region and ending in a different\n-    \/\/ region that could not be updated during the main (parallel) compaction\n-    \/\/ phase.  This is different from _partial_obj_addr, which is an object that\n-    \/\/ extends onto a source region.  However, the two uses do not overlap in\n-    \/\/ time, so the same field is used to save space.\n-    HeapWord* deferred_obj_addr() const { return _partial_obj_addr; }\n-\n@@ -315,1 +308,0 @@\n-    void set_deferred_obj_addr(HeapWord* addr) { _partial_obj_addr = addr; }\n@@ -951,2 +943,2 @@\n-\/\/ containing AAA.  These AAA's have there references updated at the end in a\n-\/\/ clean up phase.  See the method PSParallelCompact::update_deferred_objects().\n+\/\/ containing AAA.  These AAA's have their references updated at the end in a\n+\/\/ clean up phase.  See the method PSParallelCompact::update_deferred_object().\n@@ -1251,2 +1243,2 @@\n-  \/\/ Update the deferred objects in the space.\n-  static void update_deferred_objects(ParCompactionManager* cm, SpaceId id);\n+  \/\/ Update a single deferred object.\n+  static void update_deferred_object(ParCompactionManager* cm, HeapWord* addr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -136,0 +136,4 @@\n+  private:\n+    template <typename T>\n+    static void oop_store_common(T* addr, oop value);\n+\n@@ -177,1 +181,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-inline void ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_store_not_in_heap(T* addr, oop value) {\n+inline void ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_store_common(T* addr, oop value) {\n@@ -253,0 +253,6 @@\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline void ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_store_not_in_heap(T* addr, oop value) {\n+  oop_store_common(addr, value);\n+}\n+\n@@ -258,1 +264,0 @@\n-  shenandoah_assert_not_in_cset_except    (addr, value, value == NULL || ShenandoahHeap::heap()->cancelled_gc() || !ShenandoahHeap::heap()->is_concurrent_mark_in_progress());\n@@ -260,1 +265,1 @@\n-  oop_store_not_in_heap(addr, value);\n+  oop_store_common(addr, value);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1241,1 +1241,1 @@\n-      obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      obj = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(obj);\n@@ -1351,1 +1351,1 @@\n-      obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      obj = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -272,3 +272,0 @@\n-JNIEXPORT void JNICALL\n-JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);\n-\n@@ -278,6 +275,0 @@\n-JNIEXPORT void JNICALL\n-JVM_SuspendThread(JNIEnv *env, jobject thread);\n-\n-JNIEXPORT void JNICALL\n-JVM_ResumeThread(JNIEnv *env, jobject thread);\n-\n@@ -1165,0 +1156,3 @@\n+JNIEXPORT void JNICALL\n+JVM_VirtualThreadHideFrames(JNIEnv* env, jobject vthread, jboolean hide);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1042,5 +1042,1 @@\n-  if (!exception->is_a(vmClasses::ThreadDeath_klass())) {\n-    exception = get_preinitialized_exception(\n-                       vmClasses::IllegalMonitorStateException_klass(),\n-                       CATCH);\n-  }\n+  exception = get_preinitialized_exception(vmClasses::IllegalMonitorStateException_klass(), CATCH);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1583,4 +1583,1 @@\n-    if (exception->is_a(vmClasses::ThreadDeath_klass())) {\n-      \/\/ Don't print anything if we are being killed.\n-    } else {\n-      java_lang_Throwable::print_stack_trace(exception, tty);\n+    java_lang_Throwable::print_stack_trace(exception, tty);\n@@ -1588,3 +1585,2 @@\n-      \/\/ Clear and ignore any exceptions raised during printing\n-      CLEAR_PENDING_EXCEPTION;\n-    }\n+    \/\/ Clear and ignore any exceptions raised during printing\n+    CLEAR_PENDING_EXCEPTION;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -119,4 +119,1 @@\n-  \/\/ Similar to AsyncLogMap but on resource_area\n-  ResourceHashtable<LogFileStreamOutput*, uint32_t,\n-                          17\/*table_size*\/, ResourceObj::RESOURCE_AREA,\n-                          mtLogging> snapshot;\n+  AsyncLogMap<ResourceObj::RESOURCE_AREA> snapshot;\n@@ -244,1 +241,1 @@\n-  AsyncLogLocker locker;\n+  AsyncLogWriter::flush();\n@@ -247,4 +244,8 @@\n-  delete p->_buffer;\n-  delete p->_buffer_staging;\n-  p->_buffer = _buf1;\n-  p->_buffer_staging = _buf2;\n+  {\n+    AsyncLogLocker locker;\n+\n+    delete p->_buffer;\n+    delete p->_buffer_staging;\n+    p->_buffer = _buf1;\n+    p->_buffer_staging = _buf2;\n+  }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+\n+  \/\/ account for dropped messages\n+  template <ResourceObj::allocation_type ALLOC_TYPE>\n@@ -62,4 +65,2 @@\n-                          uint32_t,\n-                          17, \/*table_size*\/\n-                          ResourceObj::C_HEAP,\n-                          mtLogging>;\n+                          uint32_t, 17, \/*table_size*\/\n+                          ALLOC_TYPE, mtLogging>;\n@@ -157,1 +158,1 @@\n-  AsyncLogMap _stats; \/\/ statistics for dropped messages\n+  AsyncLogMap<ResourceObj::C_HEAP> _stats;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -80,7 +80,2 @@\n-      add->set_req(1, in11);\n-      add->set_req(2, in12);\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (igvn) {\n-        igvn->_worklist.push(in1);\n-        igvn->_worklist.push(in2);\n-      }\n+      add->set_req_X(1, in11, phase);\n+      add->set_req_X(2, in12, phase);\n@@ -635,6 +630,1 @@\n-      set_req(Offset, add->in(2));\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (add->outcnt() == 0 && igvn) {\n-        \/\/ add disconnected.\n-        igvn->_worklist.push((Node*)add);\n-      }\n+      set_req_X(Offset, add->in(2), phase); \/\/ puts add on igvn worklist if needed\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -546,0 +546,42 @@\n+  \/\/ Update dominator tree information of the new goto block.\n+  block->_idom = in;\n+  block->_dom_depth = in->_dom_depth + 1;\n+  if (out->_idom != in) {\n+    \/\/ The successor block was not immediately dominated by the predecessor\n+    \/\/ block, so there is no dominator subtree to update.\n+    return;\n+  }\n+  \/\/ Update immediate dominator of the successor block.\n+  out->_idom = block;\n+  \/\/ Increment the dominator tree depth of the goto block's descendants. These\n+  \/\/ are found by a depth-first search starting from the successor block. Two\n+  \/\/ domination properties guarantee that only descendant blocks are visited:\n+  \/\/ 1) all dominators of a block b must appear in any path from the root to b;\n+  \/\/ 2) if a block b does not dominate another block b', b cannot dominate any\n+  \/\/    block reachable from b' either.\n+  \/\/ The exploration uses header indices as block identifiers, since\n+  \/\/ Block::_pre_order might not be unique in the context of this function.\n+  ResourceMark rm;\n+  VectorSet descendants;\n+  descendants.set(block->head()->_idx); \/\/ The goto block is a descendant of itself.\n+  Block_List worklist;\n+  worklist.push(out); \/\/ Start exploring from the successor block.\n+  while (worklist.size() > 0) {\n+    Block* b = worklist.pop();\n+    \/\/ The immediate dominator of b is a descendant, hence b is also a\n+    \/\/ descendant. Even though all predecessors of b might not have been visited\n+    \/\/ yet, we know that all dominators of b have been already visited (since\n+    \/\/ they must appear in any path from the goto block to b).\n+    descendants.set(b->head()->_idx);\n+    b->_dom_depth++;\n+    for (uint i = 0; i < b->_num_succs; i++) {\n+      Block* s = b->_succs[i];\n+      if (s != get_root_block() &&\n+          !descendants.test(s->head()->_idx) &&\n+          \/\/ Do not search below non-descendant successors, since any block\n+          \/\/ reachable from them cannot be descendant either.\n+          descendants.test(s->_idom->head()->_idx)) {\n+        worklist.push(s);\n+      }\n+    }\n+  }\n@@ -1275,0 +1317,17 @@\n+void PhaseCFG::verify_dominator_tree() const {\n+  for (uint i = 0; i < number_of_blocks(); i++) {\n+    Block* block = get_block(i);\n+    assert(block->_dom_depth <= number_of_blocks(), \"unexpected dominator tree depth\");\n+    if (block == get_root_block()) {\n+      assert(block->_dom_depth == 1, \"unexpected root dominator tree depth\");\n+      \/\/ The root block does not have an immediate dominator, stop checking.\n+      continue;\n+    }\n+    assert(block->_idom != nullptr, \"non-root blocks must have immediate dominators\");\n+    assert(block->_dom_depth == block->_idom->_dom_depth + 1,\n+           \"the dominator tree depth of a node must succeed that of its immediate dominator\");\n+    assert(block->num_preds() > 2 || block->_idom == get_block_for_node(block->pred(1)),\n+           \"the immediate dominator of a single-predecessor block must be the predecessor\");\n+  }\n+}\n+\n@@ -1344,0 +1403,1 @@\n+  verify_dominator_tree();\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -646,0 +646,2 @@\n+  \/\/ Check local dominator tree invariants.\n+  void verify_dominator_tree() const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1304,1 +1304,1 @@\n-  phase->C->root()->add_req(halt);\n+  igvn->add_input_to(phase->C->root(), halt);\n@@ -1665,1 +1665,1 @@\n-    igvn->C->root()->rm_prec(nb);\n+    igvn->delete_precedence_of(igvn->C->root(), nb);\n@@ -1835,1 +1835,1 @@\n-        phase->C->root()->add_req(halt);\n+        igvn->add_input_to(phase->C->root(), halt);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -577,1 +577,3 @@\n-    root()->dump(9999);\n+    tty->print_cr(\"AFTER: %s\", phase_name);\n+    \/\/ Print out all nodes in ascending order of index.\n+    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\");\n@@ -652,1 +654,1 @@\n-                  _print_inlining_stream(NULL),\n+                  _print_inlining_stream(new stringStream()),\n@@ -933,1 +935,1 @@\n-    _print_inlining_stream(NULL),\n+    _print_inlining_stream(new stringStream()),\n@@ -3466,0 +3468,1 @@\n+    cfg.verify_dominator_tree();\n@@ -4918,7 +4921,0 @@\n-void Compile::print_inlining_stream_free() {\n-  if (_print_inlining_stream != NULL) {\n-    _print_inlining_stream->~stringStream();\n-    _print_inlining_stream = NULL;\n-  }\n-}\n-\n@@ -4936,2 +4932,1 @@\n-    print_inlining_stream_free();\n-    _print_inlining_stream = new stringStream();\n+    print_inlining_reset();\n@@ -4944,3 +4939,1 @@\n-    print_inlining_stream_free();\n-    \/\/ Re allocate buffer when we change ResourceMark\n-    _print_inlining_stream = new stringStream();\n+    print_inlining_reset();\n@@ -5036,1 +5029,1 @@\n-    print_inlining_stream_free();\n+    print_inlining_reset();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -472,1 +472,0 @@\n-  void print_inlining_stream_free();\n@@ -486,1 +485,1 @@\n-  outputStream* print_inlining_stream() const {\n+  stringStream* print_inlining_stream() {\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -390,0 +390,6 @@\n+        if (node == block->head()) {\n+          if (block->_idom != NULL) {\n+            print_prop(\"idom\", block->_idom->_pre_order);\n+          }\n+          print_prop(\"dom_depth\", block->_dom_depth);\n+        }\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1008,1 +1008,0 @@\n-          igvn->_worklist.push(in(1));\n@@ -1058,1 +1057,0 @@\n-    igvn->_worklist.push(in(1));\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,3 +179,2 @@\n-  \/\/ if_uct to rgn\n-  _igvn.hash_delete(rgn);\n-  rgn->add_req(if_uct);\n+  _igvn.add_input_to(rgn, if_uct);\n+\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1571,1 +1571,1 @@\n-  C->root()->add_req(halt);\n+  _igvn.add_input_to(C->root(), halt);\n@@ -3001,1 +3001,1 @@\n-  C->root()->add_req(halt);\n+  _igvn.add_input_to(C->root(), halt);\n@@ -3704,18 +3704,2 @@\n-  \/\/ iteration.  Then the CountedLoopEnd will collapse (backedge never\n-  \/\/ taken) and all loop-invariant uses of the exit values will be correct.\n-  Node *phi = cl->phi();\n-  Node *exact_limit = phase->exact_limit(this);\n-  if (exact_limit != cl->limit()) {\n-    \/\/ We also need to replace the original limit to collapse loop exit.\n-    Node* cmp = cl->loopexit()->cmp_node();\n-    assert(cl->limit() == cmp->in(2), \"sanity\");\n-    \/\/ Duplicate cmp node if it has other users\n-    if (cmp->outcnt() > 1) {\n-      cmp = cmp->clone();\n-      cmp = phase->_igvn.register_new_node_with_optimizer(cmp);\n-      BoolNode *bol = cl->loopexit()->in(CountedLoopEndNode::TestValue)->as_Bool();\n-      phase->_igvn.replace_input_of(bol, 1, cmp); \/\/ put bol on worklist\n-    }\n-    phase->_igvn._worklist.push(cmp->in(2)); \/\/ put limit on worklist\n-    phase->_igvn.replace_input_of(cmp, 2, exact_limit); \/\/ put cmp on worklist\n-  }\n+  \/\/ iteration (exact_limit - stride), to make sure the loop exit value\n+  \/\/ is correct, for any users after the loop.\n@@ -3724,3 +3708,11 @@\n-  Node *final = new SubINode(exact_limit, cl->stride());\n-  phase->register_new_node(final,cl->in(LoopNode::EntryControl));\n-  phase->_igvn.replace_node(phi,final);\n+  Node* phi = cl->phi();\n+  Node* exact_limit = phase->exact_limit(this);\n+  Node* final_iv = new SubINode(exact_limit, cl->stride());\n+  phase->register_new_node(final_iv, cl->in(LoopNode::EntryControl));\n+  phase->_igvn.replace_node(phi, final_iv);\n+\n+  \/\/ Set loop-exit condition to false. Then the CountedLoopEnd will collapse,\n+  \/\/ because the back edge is never taken.\n+  Node* zero = phase->_igvn.intcon(0);\n+  phase->_igvn.replace_input_of(cl->loopexit(), CountedLoopEndNode::TestValue, zero);\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":15,"deletions":23,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-    C->root()->add_req(halt);\n+    _igvn.add_input_to(C->root(), halt);\n@@ -624,1 +624,1 @@\n-static bool no_side_effect_since_safepoint(Compile* C, Node* x, Node* mem, MergeMemNode* mm) {\n+static bool no_side_effect_since_safepoint(Compile* C, Node* x, Node* mem, MergeMemNode* mm, PhaseIdealLoop* phase) {\n@@ -633,0 +633,5 @@\n+            \/\/ MergeMemStream can modify m, for example to adjust the length to mem.\n+            \/\/ This is unfortunate, and probably unnecessary. But as it is, we need\n+            \/\/ to add m to the igvn worklist, else we may have a modified node that\n+            \/\/ is not on the igvn worklist.\n+            phase->igvn()._worklist.push(m);\n@@ -708,1 +713,1 @@\n-    if (!no_side_effect_since_safepoint(C, x, mem, mm)) {\n+    if (!no_side_effect_since_safepoint(C, x, mem, mm, this)) {\n@@ -4174,4 +4179,1 @@\n-          _igvn.hash_delete(n1);\n-          n1->set_req(0, c1);\n-          _igvn.hash_insert(n1);\n-          _igvn._worklist.push(n1);\n+          _igvn.replace_input_of(n1, 0, c1);\n@@ -4181,4 +4183,1 @@\n-          _igvn.hash_delete(n2);\n-          n2->set_req(0, c2);\n-          _igvn.hash_insert(n2);\n-          _igvn._worklist.push(n2);\n+          _igvn.replace_input_of(n2, 0, c2);\n@@ -5112,2 +5111,1 @@\n-          cfg->set_req( k, if_t ); \/\/ Now point to NeverBranch\n-          _igvn._worklist.push(cfg);\n+          _igvn.replace_input_of(cfg, k, if_t); \/\/ Now point to NeverBranch\n@@ -5128,1 +5126,1 @@\n-          C->root()->add_req(halt);\n+          _igvn.add_input_to(C->root(), halt);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2228,1 +2228,1 @@\n-  C->root()->add_req(halt);\n+  _igvn.add_input_to(C->root(), halt);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2400,3 +2400,1 @@\n-    case Op_CMoveP:\n-    case Op_CMoveVF:\n-    case Op_CMoveVD:  {\n+    case Op_CMoveP: {\n@@ -2414,0 +2412,14 @@\n+    case Op_CMoveVF:\n+    case Op_CMoveVD: {\n+      \/\/ Restructure into a binary tree for Matching:\n+      \/\/ CMoveVF (Binary bool mask) (Binary src1 src2)\n+      Node* in_cc = n->in(1);\n+      assert(in_cc->is_Con(), \"The condition input of cmove vector node must be a constant.\");\n+      Node* bol = new BoolNode(in_cc, (BoolTest::mask)in_cc->get_int());\n+      Node* pair1 = new BinaryNode(bol, in_cc);\n+      n->set_req(1, pair1);\n+      Node* pair2 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair2);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -400,4 +400,1 @@\n-    set_req(MemNode::Memory, mem);\n-    if (can_reshape && old_mem->outcnt() == 0 && igvn != NULL) {\n-      igvn->_worklist.push(old_mem);\n-    }\n+    set_req_X(MemNode::Memory, mem, phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,7 +76,2 @@\n-      set_req(1, in1->in(2));\n-      set_req(2, in2->in(2));\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (igvn) {\n-        igvn->_worklist.push(in1);\n-        igvn->_worklist.push(in2);\n-      }\n+      set_req_X(1, in1->in(2), phase);\n+      set_req_X(2, in2->in(2), phase);\n@@ -100,7 +95,2 @@\n-      set_req(1, in11);\n-      set_req(2, in12);\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (igvn) {\n-        igvn->_worklist.push(in1);\n-        igvn->_worklist.push(in2);\n-      }\n+      set_req_X(1, in11, phase);\n+      set_req_X(2, in12, phase);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -578,0 +578,1 @@\n+  Compile::current()->record_modified_node(n);\n@@ -790,0 +791,1 @@\n+  Compile::current()->record_modified_node(this);\n@@ -828,0 +830,1 @@\n+  Compile::current()->record_modified_node(this);\n@@ -874,0 +877,1 @@\n+  Compile::current()->record_modified_node(this);\n@@ -1051,0 +1055,1 @@\n+  Compile::current()->record_modified_node(this);\n@@ -1062,0 +1067,1 @@\n+  Compile::current()->record_modified_node(this);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -568,0 +568,1 @@\n+    Compile::current()->record_modified_node(this);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -536,0 +536,6 @@\n+  \/\/ Add \"in\" as input (req) of \"n\"\n+  void add_input_to(Node* n, Node* in) {\n+    rehash_node_delayed(n);\n+    n->add_req(in);\n+  }\n+\n@@ -542,0 +548,6 @@\n+  \/\/ Delete precedence edge i of \"n\"\n+  void delete_precedence_of(Node* n, int i) {\n+    rehash_node_delayed(n);\n+    n->rm_prec(i);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  flags(ALL,                          \"All\") \\\n@@ -173,0 +174,2 @@\n+      } else if (PHASE_ALL == cpt) {\n+        mask = ~(UINT64_C(0));\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2067,6 +2067,1 @@\n-    }\n-    if (!retValue) {\n-      if (is_cmov_pack(p)) {\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"SWPointer::implemented: found cmpd pack\"); print_pack(p);})\n-        return true;\n-      }\n+      NOT_PRODUCT(if(retValue && is_trace_cmov() && is_cmov_pack(p)) {tty->print_cr(\"SWPointer::implemented: found cmpd pack\"); print_pack(p);})\n@@ -2366,1 +2361,2 @@\n-  Node* last_mem  = find_last_mem_state(pk, first_mem);\n+  bool is_dependent = false;\n+  Node* last_mem  = find_last_mem_state(pk, first_mem, is_dependent);\n@@ -2374,4 +2370,4 @@\n-        \/\/ A later store depends on this load, pick the memory state of the first load. This can happen, for example,\n-        \/\/ if a load pack has interleaving stores that are part of a store pack which, however, is removed at the pack\n-        \/\/ filtering stage. This leaves us with only a load pack for which we cannot take the memory state of the\n-        \/\/ last load as the remaining unvectorized stores could interfere since they have a dependency to the loads.\n+        \/\/ A later unvectorized store depends on this load, pick the memory state of the first load. This can happen,\n+        \/\/ for example, if a load pack has interleaving stores that are part of a store pack which, however, is removed\n+        \/\/ at the pack filtering stage. This leaves us with only a load pack for which we cannot take the memory state\n+        \/\/ of the last load as the remaining unvectorized stores could interfere since they have a dependency to the loads.\n@@ -2380,0 +2376,6 @@\n+        if (my_pack(current) != NULL && is_dependent) {\n+          \/\/ For vectorized store pack, when the load pack depends on\n+          \/\/ some memory operations locating after first_mem, we still\n+          \/\/ take the memory state of the last load.\n+          continue;\n+        }\n@@ -2410,2 +2412,4 @@\n-\/\/ the load we started from is the last load.\n-Node* SuperWord::find_last_mem_state(Node_List* pk, Node* first_mem) {\n+\/\/ the load we started from is the last load. At the same time, the\n+\/\/ function also helps determine if some loads in the pack depend on\n+\/\/ early memory operations which locate after first_mem.\n+Node* SuperWord::find_last_mem_state(Node_List* pk, Node* first_mem, bool &is_dependent) {\n@@ -2417,0 +2421,2 @@\n+      \/\/ Determine if the load pack is dependent on some memory operations locating after first_mem.\n+      is_dependent |= !independent(current, ld);\n@@ -2687,6 +2693,27 @@\n-        int cond = (int)bol->as_Bool()->_test._test;\n-        Node* in_cc  = _igvn.intcon(cond);\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created intcon in_cc node %d\", in_cc->_idx); in_cc->dump();})\n-        Node* cc = bol->clone();\n-        cc->set_req(1, in_cc);\n-        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created bool cc node %d\", cc->_idx); cc->dump();})\n+        BoolTest boltest = bol->as_Bool()->_test;\n+        BoolTest::mask cond = boltest._test;\n+        Node* cmp = bol->in(1);\n+        \/\/ When the src order of cmp node and cmove node are the same:\n+        \/\/   cmp: CmpD src1 src2\n+        \/\/   bool: Bool cmp mask\n+        \/\/   cmove: CMoveD bool scr1 src2\n+        \/\/ =====> vectorized, equivalent to\n+        \/\/   cmovev: CMoveVD mask src_vector1 src_vector2\n+        \/\/\n+        \/\/ When the src order of cmp node and cmove node are different:\n+        \/\/   cmp: CmpD src2 src1\n+        \/\/   bool: Bool cmp mask\n+        \/\/   cmove: CMoveD bool scr1 src2\n+        \/\/ =====> equivalent to\n+        \/\/   cmp: CmpD src1 src2\n+        \/\/   bool: Bool cmp negate(mask)\n+        \/\/   cmove: CMoveD bool scr1 src2\n+        \/\/ (Note: when mask is ne or eq, we don't need to negate it even after swapping.)\n+        \/\/ =====> vectorized, equivalent to\n+        \/\/   cmovev: CMoveVD negate(mask) src_vector1 src_vector2\n+        if (cmp->in(2) == n->in(CMoveNode::IfFalse) && cond != BoolTest::ne && cond != BoolTest::eq) {\n+          assert(cmp->in(1) == n->in(CMoveNode::IfTrue), \"cmpnode and cmovenode don't share the same inputs.\");\n+          cond = boltest.negate();\n+        }\n+        Node* cc  = _igvn.intcon((int)cond);\n+        NOT_PRODUCT(if(is_trace_cmov()) {tty->print(\"SWPointer::output: created intcon in_cc node %d\", cc->_idx); cc->dump();})\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -551,1 +551,1 @@\n-  Node* find_last_mem_state(Node_List* pk, Node* first_mem);\n+  Node* find_last_mem_state(Node_List* pk, Node* first_mem, bool &is_dependent);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-static jint CurrentVersion = JNI_VERSION_19;\n+static jint CurrentVersion = JNI_VERSION_20;\n@@ -591,2 +591,20 @@\n-    if (ex->is_a(vmClasses::ThreadDeath_klass())) {\n-      \/\/ Don't print anything if we are being killed.\n+    jio_fprintf(defaultStream::error_stream(), \"Exception \");\n+    if (thread != NULL && thread->threadObj() != NULL) {\n+      ResourceMark rm(THREAD);\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"in thread \\\"%s\\\" \", thread->name());\n+    }\n+    if (ex->is_a(vmClasses::Throwable_klass())) {\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_virtual(&result,\n+                              ex,\n+                              vmClasses::Throwable_klass(),\n+                              vmSymbols::printStackTrace_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      \/\/ If an exception is thrown in the call it gets thrown away. Not much\n+      \/\/ we can do with it. The native code that calls this, does not check\n+      \/\/ for the exception - hence, it might still be in the thread when DestroyVM gets\n+      \/\/ called, potentially causing a few asserts to trigger - since no pending exception\n+      \/\/ is expected.\n+      CLEAR_PENDING_EXCEPTION;\n@@ -594,26 +612,4 @@\n-      jio_fprintf(defaultStream::error_stream(), \"Exception \");\n-      if (thread != NULL && thread->threadObj() != NULL) {\n-        ResourceMark rm(THREAD);\n-        jio_fprintf(defaultStream::error_stream(),\n-        \"in thread \\\"%s\\\" \", thread->name());\n-      }\n-      if (ex->is_a(vmClasses::Throwable_klass())) {\n-        JavaValue result(T_VOID);\n-        JavaCalls::call_virtual(&result,\n-                                ex,\n-                                vmClasses::Throwable_klass(),\n-                                vmSymbols::printStackTrace_name(),\n-                                vmSymbols::void_method_signature(),\n-                                THREAD);\n-        \/\/ If an exception is thrown in the call it gets thrown away. Not much\n-        \/\/ we can do with it. The native code that calls this, does not check\n-        \/\/ for the exception - hence, it might still be in the thread when DestroyVM gets\n-        \/\/ called, potentially causing a few asserts to trigger - since no pending exception\n-        \/\/ is expected.\n-        CLEAR_PENDING_EXCEPTION;\n-      } else {\n-        ResourceMark rm(THREAD);\n-        jio_fprintf(defaultStream::error_stream(),\n-        \". Uncaught exception of type %s.\",\n-        ex->klass()->external_name());\n-      }\n+      ResourceMark rm(THREAD);\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \". Uncaught exception of type %s.\",\n+                  ex->klass()->external_name());\n@@ -3881,1 +3877,0 @@\n-  \/\/ Since this is not a JVM_ENTRY we have to set the thread state manually before entering.\n@@ -3884,0 +3879,8 @@\n+  \/\/ Make sure we are actually in a newly attached thread, with no\n+  \/\/ existing Java frame.\n+  if (thread->has_last_Java_frame()) {\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Since this is not a JVM_ENTRY we have to set the thread state manually before entering.\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2997,3 +2997,0 @@\n-      \/\/ We could also check the stillborn flag to see if this thread was already stopped, but\n-      \/\/ for historical reasons we let the thread detect that itself when it starts running\n-\n@@ -3052,39 +3049,0 @@\n-\/\/ JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints\n-\/\/ before the quasi-asynchronous exception is delivered.  This is a little obtrusive,\n-\/\/ but is thought to be reliable and simple. In the case, where the receiver is the\n-\/\/ same thread as the sender, no VM_Operation is needed.\n-JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))\n-  ThreadsListHandle tlh(thread);\n-  oop java_throwable = JNIHandles::resolve(throwable);\n-  if (java_throwable == NULL) {\n-    THROW(vmSymbols::java_lang_NullPointerException());\n-  }\n-  oop java_thread = NULL;\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, &java_thread);\n-  Events::log_exception(thread,\n-                        \"JVM_StopThread thread JavaThread \" INTPTR_FORMAT \" as oop \" INTPTR_FORMAT \" [exception \" INTPTR_FORMAT \"]\",\n-                        p2i(receiver), p2i(java_thread), p2i(throwable));\n-\n-  if (is_alive) {\n-    \/\/ jthread refers to a live JavaThread.\n-    if (thread == receiver) {\n-      \/\/ Exception is getting thrown at self so no VM_Operation needed.\n-      THROW_OOP(java_throwable);\n-    } else {\n-      \/\/ Use a VM_Operation to throw the exception.\n-      JavaThread::send_async_exception(receiver, java_throwable);\n-    }\n-  } else {\n-    \/\/ Either:\n-    \/\/ - target thread has not been started before being stopped, or\n-    \/\/ - target thread already terminated\n-    \/\/ We could read the threadStatus to determine which case it is\n-    \/\/ but that is overkill as it doesn't matter. We must set the\n-    \/\/ stillborn flag for the first case, and if the thread has already\n-    \/\/ exited setting this flag has no effect.\n-    java_lang_Thread::set_stillborn(java_thread);\n-  }\n-JVM_END\n-\n-\n@@ -3097,23 +3055,0 @@\n-JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))\n-  ThreadsListHandle tlh(thread);\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, NULL);\n-  if (is_alive) {\n-    \/\/ jthread refers to a live JavaThread, but java_suspend() will\n-    \/\/ detect a thread that has started to exit and will ignore it.\n-    receiver->java_suspend();\n-  }\n-JVM_END\n-\n-\n-JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))\n-  ThreadsListHandle tlh(thread);\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, NULL);\n-  if (is_alive) {\n-    \/\/ jthread refers to a live JavaThread.\n-    receiver->java_resume();\n-  }\n-JVM_END\n-\n-\n@@ -3164,1 +3099,1 @@\n-      \/\/ An asynchronous exception (e.g., ThreadDeathException) could have been thrown on\n+      \/\/ An asynchronous exception could have been thrown on\n@@ -4022,0 +3957,2 @@\n+  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n+  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n@@ -4046,0 +3983,1 @@\n+  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -4094,1 +4032,1 @@\n-\n+  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -4117,0 +4055,1 @@\n+  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -4123,0 +4062,14 @@\n+JVM_ENTRY(void, JVM_VirtualThreadHideFrames(JNIEnv* env, jobject vthread, jboolean hide))\n+#if INCLUDE_JVMTI\n+  if (!DoJVMTIVirtualThreadTransitions) {\n+    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n+    return;\n+  }\n+  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n+  assert(thread->is_in_tmp_VTMS_transition() != (bool)hide, \"sanity check\");\n+  thread->toggle_is_in_tmp_VTMS_transition();\n+#else\n+  fatal(\"Should only be called with JVMTI enabled\");\n+#endif\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":20,"deletions":67,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1266,6 +1266,4 @@\n-            Thread suspended.\n-            <code>java.lang.Thread.suspend()<\/code>\n-            or a <jvmti\/> suspend function\n-            (such as <functionlink id=\"SuspendThread\"><\/functionlink>)\n-            has been called on the thread. If this bit\n-            is set, the other bits refer to the thread state before suspension.\n+            Thread is suspended by a suspend function\n+            (such as <functionlink id=\"SuspendThread\"><\/functionlink>).\n+            If this bit is set, the other bits refer to the thread state before\n+            suspension.\n@@ -1783,1 +1781,0 @@\n-        or <code>java.lang.Thread.suspend()<\/code>\n@@ -1818,1 +1815,0 @@\n-        or <code>java.lang.Thread.suspend()<\/code>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -706,4 +706,8 @@\n-  javaVFrame *jvf = JvmtiEnvBase::is_cthread_with_continuation(jt) ?\n-                        jt->carrier_last_java_vframe(reg_map_p) :\n-                        jt->last_java_vframe(reg_map_p);\n-  jvf = check_and_skip_hidden_frames(jt, jvf);\n+  bool cthread_with_cont = JvmtiEnvBase::is_cthread_with_continuation(jt);\n+  javaVFrame *jvf = cthread_with_cont ? jt->carrier_last_java_vframe(reg_map_p)\n+                                      : jt->last_java_vframe(reg_map_p);\n+  \/\/ Skip hidden frames only for carrier threads\n+  \/\/ which are in non-temporary VTMS transition.\n+  if (jt->is_in_VTMS_transition()) {\n+    jvf = check_and_skip_hidden_frames(jt, jvf);\n+  }\n@@ -1669,1 +1673,1 @@\n-        return JVMTI_ERROR_INTERNAL;\n+        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -896,1 +896,1 @@\n-    assert(!_thread->is_in_VTMS_transition(), \"CFLH events are not allowed in VTMS transition\");\n+    assert(!_thread->is_in_any_VTMS_transition(), \"CFLH events are not allowed in any VTMS transition\");\n@@ -1053,0 +1053,3 @@\n+  if (JavaThread::current()->is_in_tmp_VTMS_transition()) {\n+    return false; \/\/ skip CFLH events in tmp VTMS transition\n+  }\n@@ -1187,2 +1190,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1343,1 +1346,4 @@\n-  assert(!thread->is_in_VTMS_transition(), \"class load events are not allowed in VTMS transition\");\n+  if (thread->is_in_tmp_VTMS_transition()) {\n+    return; \/\/ skip ClassLoad events in tmp VTMS transition\n+  }\n+  assert(!thread->is_in_any_VTMS_transition(), \"class load events are not allowed in any VTMS transition\");\n@@ -1378,1 +1384,4 @@\n-  assert(!thread->is_in_VTMS_transition(), \"class prepare events are not allowed in VTMS transition\");\n+  if (thread->is_in_tmp_VTMS_transition()) {\n+    return; \/\/ skip ClassPrepare events in tmp VTMS transition\n+  }\n+  assert(!thread->is_in_any_VTMS_transition(), \"class prepare events are not allowed in any VTMS transition\");\n@@ -1697,2 +1706,2 @@\n-  if (javaThread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (javaThread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1721,2 +1730,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1764,2 +1773,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1848,2 +1857,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1924,2 +1933,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1961,2 +1970,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2083,2 +2092,2 @@\n-      if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n-        return; \/\/ no events should be posted if thread is in a VTMS transition\n+      if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+        return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2129,2 +2138,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2165,2 +2174,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2215,2 +2224,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2246,2 +2255,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2321,2 +2330,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2360,2 +2369,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2434,1 +2443,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"compiled method load events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"compiled method load events are not allowed in any VTMS transition\");\n@@ -2457,1 +2466,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"compiled method load events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"compiled method load events are not allowed in any VTMS transition\");\n@@ -2482,1 +2491,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n@@ -2530,1 +2539,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n@@ -2554,1 +2563,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n@@ -2684,2 +2693,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2717,2 +2726,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2751,2 +2760,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2785,2 +2794,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2817,2 +2826,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2851,2 +2860,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":57,"deletions":48,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+    assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-  bool is_ThreadDeath()            { return _handshake_cl->is_ThreadDeath(); }\n@@ -448,3 +447,0 @@\n-static bool is_ThreadDeath_filter(HandshakeOperation* op) {\n-  return op->is_ThreadDeath();\n-}\n@@ -506,1 +502,1 @@\n-bool HandshakeState::has_async_exception_operation(bool ThreadDeath_only) {\n+bool HandshakeState::has_async_exception_operation() {\n@@ -509,5 +505,1 @@\n-  if (!ThreadDeath_only) {\n-    return _queue.peek(async_exception_filter) != NULL;\n-  } else {\n-    return _queue.peek(is_ThreadDeath_filter) != NULL;\n-  }\n+  return _queue.peek(async_exception_filter) != NULL;\n@@ -517,1 +509,1 @@\n-  while (has_async_exception_operation(\/* ThreadDeath_only *\/ false)) {\n+  while (has_async_exception_operation()) {\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  virtual bool is_ThreadDeath()                    { return false; }\n@@ -135,1 +134,1 @@\n-  bool has_async_exception_operation(bool ThreadDeath_only);\n+  bool has_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -425,0 +425,1 @@\n+  _is_in_tmp_VTMS_transition(false),\n@@ -691,5 +692,3 @@\n-  \/\/ Execute thread entry point unless this thread has a pending exception\n-  \/\/ or has been stopped before starting.\n-  \/\/ Note: Due to JVM_StopThread we can have pending exceptions already!\n-  if (!this->has_pending_exception() &&\n-      !java_lang_Thread::is_stillborn(this->threadObj())) {\n+  \/\/ Execute thread entry point unless this thread has a pending exception.\n+  \/\/ Note: Due to JVMTI StopThread we can have pending exceptions already!\n+  if (!this->has_pending_exception()) {\n@@ -723,2 +722,0 @@\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n-  thread->clear_pending_exception();\n@@ -731,1 +728,1 @@\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n+  \/\/ Ignore pending exception, since we are exiting anyway\n@@ -1071,22 +1068,17 @@\n-  \/\/ Only overwrite an already pending exception if it is not a ThreadDeath.\n-  if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n-\n-    \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n-    set_pending_exception(java_throwable, __FILE__, __LINE__);\n-\n-    \/\/ Clear any extent-local bindings on ThreadDeath\n-    set_extentLocalCache(NULL);\n-    oop threadOop = threadObj();\n-    assert(threadOop != NULL, \"must be\");\n-    java_lang_Thread::clear_extentLocalBindings(threadOop);\n-\n-    LogTarget(Info, exceptions) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n-      if (has_last_Java_frame()) {\n-        frame f = last_frame();\n-        ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n-      }\n-      ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n+  \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n+  set_pending_exception(java_throwable, __FILE__, __LINE__);\n+\n+  \/\/ Clear any extent-local bindings\n+  set_extentLocalCache(NULL);\n+  oop threadOop = threadObj();\n+  assert(threadOop != NULL, \"must be\");\n+  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+\n+  LogTarget(Info, exceptions) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n+    if (has_last_Java_frame()) {\n+      frame f = last_frame();\n+      ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n@@ -1094,0 +1086,1 @@\n+    ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n@@ -1105,10 +1098,0 @@\n-  \/\/ Don't install a new pending async exception if there is already\n-  \/\/ a pending ThreadDeath one. Just interrupt thread from potential\n-  \/\/ wait()\/sleep()\/park() and return.\n-  if (has_async_exception_condition(true \/* ThreadDeath_only *\/)) {\n-    java_lang_Thread::set_interrupted(threadObj(), true);\n-    this->interrupt();\n-    delete aeh;\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":23,"deletions":40,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  bool has_async_exception_condition(bool ThreadDeath_only = false);\n+  bool has_async_exception_condition();\n@@ -314,0 +314,1 @@\n+  bool                  _is_in_tmp_VTMS_transition;      \/\/ thread is in temporary virtual thread mount state transition\n@@ -647,0 +648,3 @@\n+  bool is_in_tmp_VTMS_transition() const         { return _is_in_tmp_VTMS_transition; }\n+  bool is_in_any_VTMS_transition() const         { return _is_in_VTMS_transition || _is_in_tmp_VTMS_transition; }\n+\n@@ -648,0 +652,2 @@\n+  void toggle_is_in_tmp_VTMS_transition()        { _is_in_tmp_VTMS_transition = !_is_in_tmp_VTMS_transition; };\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  bool _is_ThreadDeath;\n@@ -85,3 +84,1 @@\n-  : AsyncHandshakeClosure(name), _exception(o) {\n-    _is_ThreadDeath = exception()->is_a(vmClasses::ThreadDeath_klass());\n-  }\n+  : AsyncHandshakeClosure(name), _exception(o) { }\n@@ -111,1 +108,0 @@\n-  bool is_ThreadDeath()       { return _is_ThreadDeath; }\n@@ -132,2 +128,2 @@\n-inline bool JavaThread::has_async_exception_condition(bool ThreadDeath_only) {\n-  return handshake_state()->has_async_exception_operation(ThreadDeath_only);\n+inline bool JavaThread::has_async_exception_condition() {\n+  return handshake_state()->has_async_exception_operation();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1169,0 +1169,1 @@\n+  if (version == JNI_VERSION_20) return JNI_TRUE;\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,2 +77,1 @@\n-  if (!_pending_exception->is_a(vmClasses::ThreadDeath_klass()) &&\n-      (_pending_exception->klass() != vmClasses::InternalError_klass() ||\n+  if ((_pending_exception->klass() != vmClasses::InternalError_klass() ||\n@@ -430,1 +429,1 @@\n-      \/\/ of linkage error, or say ThreadDeath\/OutOfMemoryError\n+      \/\/ of linkage error, or say OutOfMemoryError\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError and j.l.ThreadDeath.\n+\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError.\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n+public class FileDispatcherImpl extends UnixFileDispatcherImpl {\n+    FileDispatcherImpl() {\n+        super();\n+    }\n+\n+    int force(FileDescriptor fd, boolean metaData) throws IOException {\n+        return force0(fd, metaData);\n+    }\n+\n+    protected long transferTo(FileDescriptor src, long position,\n+                              long count, FileDescriptor dst,\n+                              boolean append)\n+    {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    \/\/ --- native methods ---\n+\n+    static native int force0(FileDescriptor fd, boolean metaData)\n+        throws IOException;\n+\n+    private static native long transferTo0(FileDescriptor src, long position,\n+                                           long count, FileDescriptor dst,\n+                                           boolean append);\n+}\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -298,90 +298,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/* On fast machines we see that we enter dup2 before the\n-         * accepting thread had a chance to get and process the signal.\n-         * So in case we woke a thread up, give it some time to cope.\n-         * Also see https:\/\/bugs.openjdk.java.net\/browse\/JDK-8006395 *\/\n-        int num_woken = 0;\n-\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, sigWakeup );\n-            num_woken ++;\n-            curr = curr->next;\n-        }\n-\n-        if (num_woken > 0) {\n-          usleep(num_woken * 50);\n-        }\n-\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        do {\n-            if (fd1 < 0) {\n-                rv = close(fd2);\n-            } else {\n-                rv = dup2(fd1, fd2);\n-            }\n-        } while (rv == -1 && errno == EINTR);\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -411,25 +321,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT(s, recv(s, buf, len, MSG_NONBLOCK));\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n@@ -494,55 +379,0 @@\n-\n-\/*\n- * Wrapper for poll(s, timeout).\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    for(;;) {\n-        struct pollfd pfd;\n-        int rv;\n-        threadEntry_t self;\n-\n-        \/*\n-         * Poll the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-        pfd.fd = s;\n-        pfd.events = POLLIN | POLLERR;\n-\n-        startOp(fdEntry, &self);\n-        rv = poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n-        endOp(fdEntry, &self);\n-\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/aix\/native\/libnet\/aix_close.c","additions":1,"deletions":171,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/mman.h>\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+#include <sys\/types.h>\n+#include <unistd.h>\n+\n+#include <string.h>\n+#include <sys\/socket.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"java_lang_Integer.h\"\n+#include <assert.h>\n+\n+static jlong\n+handle(JNIEnv *env, jlong rv, char *msg)\n+{\n+    if (rv >= 0)\n+        return rv;\n+    if (errno == EINTR)\n+        return IOS_INTERRUPTED;\n+    JNU_ThrowIOExceptionWithLastError(env, msg);\n+    return IOS_THROWN;\n+}\n+\n+\/\/ AIX\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_force0(JNIEnv *env, jobject this,\n+                                          jobject fdo, jboolean md)\n+{\n+    jint fd = fdval(env, fdo);\n+    int result = 0;\n+\n+    if (md == JNI_FALSE) {\n+        result = fdatasync(fd);\n+    } else {\n+        \/* Calling fsync on a file descriptor that is opened only for\n+         * reading results in an error (\"EBADF: The FileDescriptor parameter is\n+         * not a valid file descriptor open for writing.\").\n+         * However, at this point it is not possibly anymore to read the\n+         * 'writable' attribute of the corresponding file channel so we have to\n+         * use 'fcntl'.\n+         *\/\n+        int getfl = fcntl(fd, F_GETFL);\n+        if (getfl >= 0 && (getfl & O_ACCMODE) == O_RDONLY) {\n+            return 0;\n+        }\n+        result = fsync(fd);\n+    }\n+\n+    return handle(env, result, \"Force failed\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jobject this,\n+                                                    jobject srcFDO,\n+                                                    jlong position, jlong count,\n+                                                    jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    jlong max = (jlong)java_lang_Integer_MAX_VALUE;\n+    struct sf_parms sf_iobuf;\n+    jlong result;\n+\n+    if (position > max)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    if (count > max)\n+        count = max;\n+\n+    memset(&sf_iobuf, 0, sizeof(sf_iobuf));\n+    sf_iobuf.file_descriptor = srcFD;\n+    sf_iobuf.file_offset = (off_t)position;\n+    sf_iobuf.file_bytes = count;\n+\n+    result = send_file(&dstFD, &sf_iobuf, SF_SYNC_CACHE);\n+\n+    \/* AIX send_file() will return 0 when this operation complete successfully,\n+     * return 1 when partial bytes transferred and return -1 when an error has\n+     * occurred.\n+     *\/\n+    if (result == -1) {\n+        if (errno == EWOULDBLOCK)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        if (errno == ENOTSOCK)\n+            return IOS_UNSUPPORTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    if (sf_iobuf.bytes_sent > 0)\n+        return (jlong)sf_iobuf.bytes_sent;\n+\n+    return IOS_UNSUPPORTED_CASE;\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+\n+class FileDispatcherImpl extends UnixFileDispatcherImpl {\n+    FileDispatcherImpl() {\n+        super();\n+    }\n+\n+    int maxDirectTransferSize() {\n+        return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                      long position, long count, boolean append) {\n+        return transferFrom0(src, dst, position, count, append);\n+    }\n+\n+    \/\/ -- Native methods --\n+\n+    static native long transferTo0(FileDescriptor src, long position,\n+                                   long count, FileDescriptor dst,\n+                                   boolean append);\n+\n+    static native long transferFrom0(FileDescriptor src, FileDescriptor dst,\n+                                     long position, long count, boolean append);\n+\n+    static native void init0();\n+\n+    static {\n+        init0();\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,79 +266,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        if (fd1 < 0) {\n-            rv = close(fd2);\n-        } else {\n-            do {\n-                rv = dup2(fd1, fd2);\n-            } while (rv == -1 && errno == EINTR);\n-        }\n-\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, WAKEUP_SIGNAL);\n-            curr = curr->next;\n-        }\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -368,26 +289,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT) );\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n-\n@@ -401,54 +296,0 @@\n-\n-\/*\n- * Wrapper for poll(s, timeout).\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong)timeout * NET_NSEC_PER_MSEC;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    for(;;) {\n-        struct pollfd pfd;\n-        int rv;\n-        threadEntry_t self;\n-\n-        \/*\n-         * Poll the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-        pfd.fd = s;\n-        pfd.events = POLLIN | POLLERR;\n-\n-        startOp(fdEntry, &self);\n-        rv = poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n-        endOp(fdEntry, &self);\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/linux\/native\/libnet\/linux_close.c","additions":1,"deletions":160,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/sendfile.h>\n+#include <dlfcn.h>\n+\n+#include \"jni.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"sun_nio_ch_FileDispatcherImpl.h\"\n+\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_init0(JNIEnv *env, jclass klass)\n+{\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferFrom0(JNIEnv *env, jobject this,\n+                                              jobject srcFDO, jobject dstFDO,\n+                                              jlong position, jlong count,\n+                                              jboolean append)\n+{\n+    if (my_copy_file_range_func == NULL)\n+        return IOS_UNSUPPORTED;\n+    \/\/ copy_file_range fails with EBADF when appending\n+    if (append == JNI_TRUE)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    off64_t offset = (off64_t)position;\n+    size_t len = (size_t)count;\n+    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, len, 0);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if (errno == ENOSYS)\n+            return IOS_UNSUPPORTED_CASE;\n+        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n+            ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jobject this,\n+                                            jobject srcFDO,\n+                                            jlong position, jlong count,\n+                                            jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    \/\/ copy_file_range fails with EBADF when appending, and sendfile\n+    \/\/ fails with EINVAL\n+    if (append == JNI_TRUE)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    off64_t offset = (off64_t)position;\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        size_t len = (size_t)count;\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n+        if (n < 0) {\n+            switch (errno) {\n+                case EINTR:\n+                    return IOS_INTERRUPTED;\n+                case EINVAL:\n+                case ENOSYS:\n+                case EXDEV:\n+                    \/\/ ignore and try sendfile()\n+                    break;\n+                default:\n+                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                    return IOS_THROWN;\n+            }\n+        }\n+        if (n >= 0)\n+            return n;\n+    }\n+\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n+class FileDispatcherImpl extends UnixFileDispatcherImpl {\n+    FileDispatcherImpl() {\n+        super();\n+    }\n+\n+    int force(FileDescriptor fd, boolean metaData) throws IOException {\n+        return force0(fd, metaData);\n+    }\n+\n+    boolean canTransferToFromOverlappedMap() {\n+        return false;\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    \/\/ -- Native methods --\n+\n+    static native int force0(FileDescriptor fd, boolean metaData)\n+        throws IOException;\n+\n+    static native long transferTo0(FileDescriptor src, long position,\n+                                   long count, FileDescriptor dst,\n+                                   boolean append);\n+}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,80 +269,0 @@\n-\/*\n- * Close or dup2 a file descriptor ensuring that all threads blocked on\n- * the file descriptor are notified via a wakeup signal.\n- *\n- *      fd1 < 0    => close(fd2)\n- *      fd1 >= 0   => dup2(fd1, fd2)\n- *\n- * Returns -1 with errno set if operation fails.\n- *\/\n-static int closefd(int fd1, int fd2) {\n-    int rv, orig_errno;\n-    fdEntry_t *fdEntry = getFdEntry(fd2);\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Lock the fd to hold-off additional I\/O on this fd.\n-     *\/\n-    pthread_mutex_lock(&(fdEntry->lock));\n-\n-    {\n-        \/*\n-         * Send a wakeup signal to all threads blocked on this\n-         * file descriptor.\n-         *\/\n-        threadEntry_t *curr = fdEntry->threads;\n-        while (curr != NULL) {\n-            curr->intr = 1;\n-            pthread_kill( curr->thr, sigWakeup );\n-            curr = curr->next;\n-        }\n-\n-        \/*\n-         * And close\/dup the file descriptor\n-         * (restart if interrupted by signal)\n-         *\/\n-        do {\n-            if (fd1 < 0) {\n-                rv = close(fd2);\n-            } else {\n-                rv = dup2(fd1, fd2);\n-            }\n-        } while (rv == -1 && errno == EINTR);\n-\n-    }\n-\n-    \/*\n-     * Unlock without destroying errno\n-     *\/\n-    orig_errno = errno;\n-    pthread_mutex_unlock(&(fdEntry->lock));\n-    errno = orig_errno;\n-\n-    return rv;\n-}\n-\n-\/*\n- * Wrapper for dup2 - same semantics as dup2 system call except\n- * that any threads blocked in an I\/O system call on fd2 will be\n- * preempted and return -1\/EBADF;\n- *\/\n-int NET_Dup2(int fd, int fd2) {\n-    if (fd < 0) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-    return closefd(fd, fd2);\n-}\n-\n-\/*\n- * Wrapper for close - same semantics as close system call\n- * except that any threads blocked in an I\/O on fd will be\n- * preempted and the I\/O system call will return -1\/EBADF.\n- *\/\n-int NET_SocketClose(int fd) {\n-    return closefd(-1, fd);\n-}\n-\n@@ -372,26 +292,0 @@\n-int NET_Read(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );\n-}\n-\n-int NET_NonBlockingRead(int s, void* buf, size_t len) {\n-    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, MSG_DONTWAIT));\n-}\n-\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-       struct sockaddr *from, socklen_t *fromlen) {\n-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );\n-}\n-\n-int NET_Send(int s, void *msg, int len, unsigned int flags) {\n-    BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );\n-}\n-\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-       flags, const struct sockaddr *to, int tolen) {\n-    BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );\n-}\n-\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {\n-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );\n-}\n-\n@@ -405,91 +299,0 @@\n-\n-\/*\n- * Wrapper for select(s, timeout). We are using select() on Mac OS due to Bug 7131399.\n- * Auto restarts with adjusted timeout if interrupted by\n- * signal other than our wakeup signal.\n- *\/\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {\n-    struct timeval t, *tp = &t;\n-    fd_set fds;\n-    fd_set* fdsp = NULL;\n-    int allocated = 0;\n-    threadEntry_t self;\n-    fdEntry_t *fdEntry = getFdEntry(s);\n-\n-    \/*\n-     * Check that fd hasn't been closed.\n-     *\/\n-    if (fdEntry == NULL) {\n-        errno = EBADF;\n-        return -1;\n-    }\n-\n-    \/*\n-     * Pick up current time as may need to adjust timeout\n-     *\/\n-    if (timeout > 0) {\n-        \/* Timed *\/\n-        t.tv_sec = timeout \/ 1000;\n-        t.tv_usec = (timeout % 1000) * 1000;\n-    } else if (timeout < 0) {\n-        \/* Blocking *\/\n-        tp = 0;\n-    } else {\n-        \/* Poll *\/\n-        t.tv_sec = 0;\n-        t.tv_usec = 0;\n-    }\n-\n-    if (s < FD_SETSIZE) {\n-        fdsp = &fds;\n-        FD_ZERO(fdsp);\n-    } else {\n-        int length = (howmany(s+1, NFDBITS)) * sizeof(int);\n-        fdsp = (fd_set *) calloc(1, length);\n-        if (fdsp == NULL) {\n-            return -1;   \/\/ errno will be set to ENOMEM\n-        }\n-        allocated = 1;\n-    }\n-    FD_SET(s, fdsp);\n-\n-    jlong prevNanoTime = nanoTimeStamp;\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    for(;;) {\n-        int rv;\n-\n-        \/*\n-         * call select on the fd. If interrupted by our wakeup signal\n-         * errno will be set to EBADF.\n-         *\/\n-\n-        startOp(fdEntry, &self);\n-        rv = select(s+1, fdsp, 0, 0, tp);\n-        endOp(fdEntry, &self);\n-\n-        \/*\n-         * If interrupted then adjust timeout. If timeout\n-         * has expired return 0 (indicating timeout expired).\n-         *\/\n-        if (rv < 0 && errno == EINTR) {\n-            if (timeout > 0) {\n-                jlong newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= newNanoTime - prevNanoTime;\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    if (allocated != 0)\n-                        free(fdsp);\n-                    return 0;\n-                }\n-                prevNanoTime = newNanoTime;\n-                t.tv_sec = nanoTimeout \/ NET_NSEC_PER_SEC;\n-                t.tv_usec = (nanoTimeout % NET_NSEC_PER_SEC) \/ NET_NSEC_PER_USEC;\n-            } else {\n-                continue; \/\/ timeout is -1, so  loop again.\n-            }\n-        } else {\n-            if (allocated != 0)\n-                free(fdsp);\n-            return rv;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/macosx\/native\/libnet\/bsd_close.c","additions":1,"deletions":198,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/mount.h>\n+\n+#include \"jni.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"sun_nio_ch_FileDispatcherImpl.h\"\n+\n+static jlong\n+handle(JNIEnv *env, jlong rv, char *msg)\n+{\n+    if (rv >= 0)\n+        return rv;\n+    if (errno == EINTR)\n+        return IOS_INTERRUPTED;\n+    JNU_ThrowIOExceptionWithLastError(env, msg);\n+    return IOS_THROWN;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_force0(JNIEnv *env, jobject this,\n+                                          jobject fdo, jboolean md)\n+{\n+    jint fd = fdval(env, fdo);\n+    int result = 0;\n+\n+    result = fcntl(fd, F_FULLFSYNC);\n+    if (result == -1) {\n+        struct statfs fbuf;\n+        int errno_fcntl = errno;\n+        if (fstatfs(fd, &fbuf) == 0) {\n+            if ((fbuf.f_flags & MNT_LOCAL) == 0) {\n+                \/* Try fsync() in case file is not local. *\/\n+                result = fsync(fd);\n+            }\n+        } else {\n+            \/* fstatfs() failed so restore errno from fcntl(). *\/\n+            errno = errno_fcntl;\n+        }\n+    }\n+\n+    return handle(env, result, \"Force failed\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jobject this,\n+                                               jobject srcFDO,\n+                                               jlong position, jlong count,\n+                                               jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    off_t numBytes;\n+    int result;\n+\n+    numBytes = count;\n+\n+    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n+\n+    if (numBytes > 0)\n+        return numBytes;\n+\n+    if (result == -1) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)\n+            return IOS_UNSUPPORTED_CASE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    return result;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -193,7 +193,0 @@\n-                   \/\/ evaluate possible precedence of flushException over closeException\n-                   if ((flushException instanceof ThreadDeath) &&\n-                       !(closeException instanceof ThreadDeath)) {\n-                       flushException.addSuppressed(closeException);\n-                       throw (ThreadDeath) flushException;\n-                   }\n-\n@@ -203,1 +196,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilterOutputStream.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2433,2 +2433,0 @@\n-                    ThreadDeath t = null;\n-                    boolean reset = false;\n@@ -2453,13 +2451,4 @@\n-                        do {\n-                            try {\n-                                curContext.setUsed();\n-                                if (oldContext!= null)\n-                                    oldContext.check();\n-                                curContext = oldContext;\n-                                reset = true;\n-                            } catch (ThreadDeath x) {\n-                                t = x;  \/\/ defer until reset is true\n-                            }\n-                        } while (!reset);\n-                        if (t != null)\n-                            throw t;\n+                        curContext.setUsed();\n+                        if (oldContext!= null)\n+                            oldContext.check();\n+                        curContext = oldContext;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,0 @@\n- * The {@code ThreadDeath} error, though a \"normal\" condition,\n- * is also a subclass of {@code Error} because most applications\n- * should not try to catch it.\n@@ -45,1 +42,0 @@\n- * @see     java.lang.ThreadDeath\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Error.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n- * for the requested operation. See, for example, the\n- * {@code suspend} and {@code resume} methods in class\n- * {@code Thread}.\n+ * for the requested operation.\n@@ -34,2 +32,1 @@\n- * @see     java.lang.Thread#resume()\n- * @see     java.lang.Thread#suspend()\n+ * @see Thread#start()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/IllegalThreadStateException.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,3 +174,2 @@\n- * {@code interrupt, stop, suspend, resume, setDaemon, setPriority,\n- * setName} and {@code setUncaughtExceptionHandler}\n- * methods<\/td>\n+ * {@code interrupt, setDaemon, setPriority, setName} and\n+ * {@code setUncaughtExceptionHandler} methods<\/td>\n@@ -182,10 +181,0 @@\n- *   <th scope=\"row\">stopThread<\/th>\n- *   <td>Stopping of threads via calls to the Thread {@code stop}\n- * method<\/td>\n- *   <td>This allows code to stop any thread in the system provided that it is\n- * already granted permission to access that thread.\n- * This poses as a threat, because that code may corrupt the system by\n- * killing existing threads.<\/td>\n- * <\/tr>\n- *\n- * <tr>\n@@ -194,3 +183,1 @@\n- * {@code destroy}, {@code getParent}, {@code resume},\n- * {@code setDaemon}, {@code setMaxPriority}, {@code stop},\n- * and {@code suspend} methods<\/td>\n+ * {@code getParent}, {@code setDaemon}, and {@code setMaxPriority} methods<\/td>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/RuntimePermission.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -497,1 +497,0 @@\n-     * {@code stop}, {@code suspend}, {@code resume},\n@@ -526,1 +525,0 @@\n-     * @see        java.lang.Thread#resume() resume\n@@ -530,2 +528,0 @@\n-     * @see        java.lang.Thread#stop() stop\n-     * @see        java.lang.Thread#suspend() suspend\n@@ -550,3 +546,2 @@\n-     * {@code setDaemon}, {@code setMaxPriority},\n-     * {@code stop}, {@code suspend}, {@code resume}, and\n-     * {@code destroy} methods of class {@code ThreadGroup}.\n+     * {@code setDaemon} and {@code setMaxPriority} methods of class\n+     * {@code ThreadGroup}.\n@@ -579,2 +574,0 @@\n-     * @see        java.lang.ThreadGroup#destroy() destroy\n-     * @see        java.lang.ThreadGroup#resume() resume\n@@ -583,2 +576,0 @@\n-     * @see        java.lang.ThreadGroup#stop() stop\n-     * @see        java.lang.ThreadGroup#suspend() suspend\n","filename":"src\/java.base\/share\/classes\/java\/lang\/SecurityManager.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -132,3 +132,1 @@\n-                if (t instanceof ThreadDeath td) {\n-                    throw td;\n-                }\n+                \/\/ ignore\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Shutdown.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -250,1 +250,0 @@\n-        boolean stillborn;\n@@ -1632,49 +1631,9 @@\n-     * Forces the thread to stop executing.\n-     * <p>\n-     * If there is a security manager installed, its {@code checkAccess}\n-     * method is called with {@code this}\n-     * as its argument. This may result in a\n-     * {@code SecurityException} being raised (in the current thread).\n-     * <p>\n-     * If this thread is different from the current thread (that is, the current\n-     * thread is trying to stop a thread other than itself), the\n-     * security manager's {@code checkPermission} method (with a\n-     * {@code RuntimePermission(\"stopThread\")} argument) is called in\n-     * addition.\n-     * Again, this may result in throwing a\n-     * {@code SecurityException} (in the current thread).\n-     * <p>\n-     * The thread represented by this thread is forced to stop whatever\n-     * it is doing abnormally and to throw a newly created\n-     * {@code ThreadDeath} object as an exception.\n-     * <p>\n-     * It is permitted to stop a thread that has not yet been started.\n-     * If the thread is eventually started, it immediately terminates.\n-     * <p>\n-     * An application should not normally try to catch\n-     * {@code ThreadDeath} unless it must do some extraordinary\n-     * cleanup operation (note that the throwing of\n-     * {@code ThreadDeath} causes {@code finally} clauses of\n-     * {@code try} statements to be executed before the thread\n-     * officially terminates).  If a {@code catch} clause catches a\n-     * {@code ThreadDeath} object, it is important to rethrow the\n-     * object so that the thread actually terminates.\n-     * <p>\n-     * The top-level error handler that reacts to otherwise uncaught\n-     * exceptions does not print out a message or otherwise notify the\n-     * application if the uncaught exception is an instance of\n-     * {@code ThreadDeath}.\n-     *\n-     * @throws     SecurityException  if the current thread cannot\n-     *             modify this thread.\n-     * @throws     UnsupportedOperationException if invoked on a virtual thread\n-     * @see        #interrupt()\n-     * @see        #checkAccess()\n-     * @see        ThreadDeath\n-     * @see        ThreadGroup#uncaughtException(Thread,Throwable)\n-     * @see        SecurityManager#checkAccess(Thread)\n-     * @see        SecurityManager#checkPermission\n-     * @deprecated This method is inherently unsafe.  Stopping a thread with\n-     *       Thread.stop causes it to unlock all of the monitors that it\n-     *       has locked (as a natural consequence of the unchecked\n-     *       {@code ThreadDeath} exception propagating up the stack).  If\n+     * Throws {@code UnsupportedOperationException}.\n+     *\n+     * @throws  UnsupportedOperationException always\n+     *\n+     * @deprecated This method was originally specified to \"stop\" a victim\n+     *       thread by causing the victim thread to throw a {@link ThreadDeath}.\n+     *       It was inherently unsafe. Stopping a thread caused it to unlock\n+     *       all of the monitors that it had locked (as a natural consequence\n+     *       of the {@code ThreadDeath} exception propagating up the stack). If\n@@ -1682,3 +1641,3 @@\n-     *       an inconsistent state, the damaged objects become visible to\n-     *       other threads, potentially resulting in arbitrary behavior.  Many\n-     *       uses of {@code stop} should be replaced by code that simply\n+     *       an inconsistent state, the damaged objects became visible to\n+     *       other threads, potentially resulting in arbitrary behavior.\n+     *       Usages of {@code stop} should be replaced by code that simply\n@@ -1698,20 +1657,1 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            checkAccess();\n-            if (this != Thread.currentThread()) {\n-                security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);\n-            }\n-        }\n-\n-        if (isVirtual())\n-            throw new UnsupportedOperationException();\n-\n-        \/\/ A zero status value corresponds to \"NEW\", it can't change to\n-        \/\/ not-NEW because we hold the lock.\n-        if (holder.threadStatus != 0) {\n-            resume(); \/\/ Wake up thread if it was suspended; no-op otherwise\n-        }\n-\n-        \/\/ The VM can handle all thread states\n-        stop0(new ThreadDeath());\n+        throw new UnsupportedOperationException();\n@@ -1860,23 +1800,14 @@\n-     * Suspends this thread.\n-     * <p>\n-     * First, the {@code checkAccess} method of this thread is called\n-     * with no arguments. This may result in throwing a\n-     * {@code SecurityException} (in the current thread).\n-     * <p>\n-     * If the thread is alive, it is suspended and makes no further\n-     * progress unless and until it is resumed.\n-     *\n-     * @throws     SecurityException  if the current thread cannot modify\n-     *             this thread.\n-     * @throws     UnsupportedOperationException if invoked on a virtual thread\n-     * @see #checkAccess\n-     * @deprecated   This method has been deprecated, as it is\n-     *   inherently deadlock-prone.  If the target thread holds a lock on the\n-     *   monitor protecting a critical system resource when it is suspended, no\n-     *   thread can access this resource until the target thread is resumed. If\n-     *   the thread that would resume the target thread attempts to lock this\n-     *   monitor prior to calling {@code resume}, deadlock results.  Such\n-     *   deadlocks typically manifest themselves as \"frozen\" processes.\n-     *   For more information, see\n-     *   <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html\">Why\n-     *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?<\/a>.\n+     * Throws {@code UnsupportedOperationException}.\n+     *\n+     * @throws  UnsupportedOperationException always\n+     *\n+     * @deprecated This method was originally specified to suspend a thread.\n+     *     It was inherently deadlock-prone. If the target thread held a lock on\n+     *     a monitor protecting a critical system resource when it was suspended,\n+     *     no thread could access the resource until the target thread was resumed.\n+     *     If the thread intending to resume the target thread attempted to lock\n+     *     the monitor prior to calling {@code resume}, deadlock would result.\n+     *     Such deadlocks typically manifested themselves as \"frozen\" processes.\n+     *     For more information, see\n+     *     <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html\">Why\n+     *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?<\/a>.\n@@ -1886,4 +1817,1 @@\n-        checkAccess();\n-        if (isVirtual())\n-            throw new UnsupportedOperationException();\n-        suspend0();\n+        throw new UnsupportedOperationException();\n@@ -1893,8 +1821,1 @@\n-     * Resumes a suspended thread.\n-     * <p>\n-     * First, the {@code checkAccess} method of this thread is called\n-     * with no arguments. This may result in throwing a\n-     * {@code SecurityException} (in the current thread).\n-     * <p>\n-     * If the thread is alive but suspended, it is resumed and is\n-     * permitted to make progress in its execution.\n+     * Throws {@code UnsupportedOperationException}.\n@@ -1902,7 +1823,5 @@\n-     * @throws     SecurityException  if the current thread cannot modify this\n-     *             thread.\n-     * @throws     UnsupportedOperationException if invoked on a virtual thread\n-     * @see        #checkAccess\n-     * @see        #suspend()\n-     * @deprecated This method exists solely for use with {@link #suspend},\n-     *     which has been deprecated because it is deadlock-prone.\n+     * @throws  UnsupportedOperationException always\n+     *\n+     * @deprecated This method was originally specified to resume a thread\n+     *     suspended with {@link #suspend()}. Suspending a thread was\n+     *     inherently deadlock-prone.\n@@ -1915,4 +1834,1 @@\n-        checkAccess();\n-        if (isVirtual())\n-            throw new UnsupportedOperationException();\n-        resume0();\n+        throw new UnsupportedOperationException();\n@@ -3097,3 +3013,0 @@\n-    private native void stop0(Object o);\n-    private native void suspend0();\n-    private native void resume0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":35,"deletions":122,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * An instance of {@code ThreadDeath} is thrown in the victim thread\n- * when the (deprecated) {@link Thread#stop()} method is invoked.\n+ * An instance of {@code ThreadDeath} was originally specified to be thrown\n+ * by a victim thread when \"stopped\" with {@link Thread#stop()}.\n@@ -32,13 +32,6 @@\n- * <p>An application should catch instances of this class only if it\n- * must clean up after being terminated asynchronously.  If\n- * {@code ThreadDeath} is caught by a method, it is important that it\n- * be rethrown so that the thread actually dies.\n- *\n- * <p>The {@linkplain ThreadGroup#uncaughtException top-level error\n- * handler} does not print out a message if {@code ThreadDeath} is\n- * never caught.\n- *\n- * <p>The class {@code ThreadDeath} is specifically a subclass of\n- * {@code Error} rather than {@code Exception}, even though it is a\n- * \"normal occurrence\", because many applications catch all\n- * occurrences of {@code Exception} and then discard the exception.\n+ * @deprecated {@link Thread#stop()} was originally specified to \"stop\" a victim\n+ *      thread by causing the victim thread to throw a {@code ThreadDeath}. It\n+ *      was inherently unsafe and deprecated in an early JDK release. The ability\n+ *      to \"stop\" a thread with {@code Thread.stop} has been removed and the\n+ *      {@code Thread.stop} method changed to throw an exception. Consequently,\n+ *      {@code ThreadDeath} is also deprecated, for removal.\n@@ -48,1 +41,1 @@\n-\n+@Deprecated(since=\"20\", forRemoval=true)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadDeath.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -677,6 +677,3 @@\n-     * <li>Otherwise, this method determines if the {@code Throwable}\n-     *     argument is an instance of {@link ThreadDeath}. If so, nothing\n-     *     special is done. Otherwise, a message containing the\n-     *     thread's name, as returned from the thread's {@link\n-     *     Thread#getName getName} method, and a stack backtrace,\n-     *     using the {@code Throwable}'s {@link\n+     * <li>Otherwise, a message containing the thread's name, as returned\n+     *     from the thread's {@link Thread#getName getName} method, and a\n+     *     stack backtrace, using the {@code Throwable}'s {@link\n@@ -702,3 +699,2 @@\n-            } else if (!(e instanceof ThreadDeath)) {\n-                System.err.print(\"Exception in thread \\\"\"\n-                                 + t.getName() + \"\\\" \");\n+            } else {\n+                System.err.print(\"Exception in thread \\\"\" + t.getName() + \"\\\" \");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadGroup.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -357,0 +357,33 @@\n+    \/**\n+     * Sets the current thread to the current carrier thread.\n+     * @return true if JVMTI was notified\n+     *\/\n+    @ChangesCurrentThread\n+    @JvmtiMountTransition\n+    private boolean switchToCarrierThread() {\n+        boolean notifyJvmti = notifyJvmtiEvents;\n+        if (notifyJvmti) {\n+            notifyJvmtiHideFrames(true);\n+        }\n+        Thread carrier = this.carrierThread;\n+        assert Thread.currentThread() == this\n+                && carrier == Thread.currentCarrierThread();\n+        carrier.setCurrentThread(carrier);\n+        return notifyJvmti;\n+    }\n+\n+    \/**\n+     * Sets the current thread to the given virtual thread.\n+     * If {@code notifyJvmti} is true then JVMTI is notified.\n+     *\/\n+    @ChangesCurrentThread\n+    @JvmtiMountTransition\n+    private void switchToVirtualThread(VirtualThread vthread, boolean notifyJvmti) {\n+        Thread carrier = vthread.carrierThread;\n+        assert carrier == Thread.currentCarrierThread();\n+        carrier.setCurrentThread(vthread);\n+        if (notifyJvmti) {\n+            notifyJvmtiHideFrames(false);\n+        }\n+    }\n+\n@@ -529,1 +562,1 @@\n-            Future<?> unparker = scheduleUnpark(nanos);\n+            Future<?> unparker = scheduleUnpark(this::unpark, nanos);\n@@ -582,1 +615,1 @@\n-     * Schedules this thread to be unparked after the given delay.\n+     * Schedule an unpark task to run after a given delay.\n@@ -585,4 +618,3 @@\n-    private Future<?> scheduleUnpark(long nanos) {\n-        Thread carrier = this.carrierThread;\n-        \/\/ need to switch to current platform thread to avoid nested parking\n-        carrier.setCurrentThread(carrier);\n+    private Future<?> scheduleUnpark(Runnable unparker, long nanos) {\n+        \/\/ need to switch to current carrier thread to avoid nested parking\n+        boolean notifyJvmti = switchToCarrierThread();\n@@ -590,1 +622,1 @@\n-            return UNPARKER.schedule(() -> unpark(), nanos, NANOSECONDS);\n+            return UNPARKER.schedule(unparker, nanos, NANOSECONDS);\n@@ -592,1 +624,1 @@\n-            carrier.setCurrentThread(this);\n+            switchToVirtualThread(this, notifyJvmti);\n@@ -602,3 +634,2 @@\n-            Thread carrier = this.carrierThread;\n-            \/\/ need to switch to current platform thread to avoid nested parking\n-            carrier.setCurrentThread(carrier);\n+            \/\/ need to switch to current carrier thread to avoid nested parking\n+            boolean notifyJvmti = switchToCarrierThread();\n@@ -608,1 +639,1 @@\n-                carrier.setCurrentThread(this);\n+                switchToVirtualThread(this, notifyJvmti);\n@@ -628,2 +659,1 @@\n-                    Thread carrier = vthread.carrierThread;\n-                    carrier.setCurrentThread(carrier);\n+                    boolean notifyJvmti = vthread.switchToCarrierThread();\n@@ -633,1 +663,1 @@\n-                        carrier.setCurrentThread(vthread);\n+                        switchToVirtualThread(vthread, notifyJvmti);\n@@ -1008,0 +1038,3 @@\n+    @JvmtiMountTransition\n+    private native void notifyJvmtiHideFrames(boolean hide);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":48,"deletions":15,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+        ptypes.add(null); \/\/placeholder for return type\n@@ -159,1 +160,1 @@\n-        ptypes.add(0, descriptor.substring(cur, cur + rLen));\n+        ptypes.set(0, descriptor.substring(cur, cur + rLen));\n@@ -208,8 +209,20 @@\n-                    \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n-                    index++;\n-                    int indexOfSemi = descriptor.indexOf(';', index);\n-                    if (indexOfSemi != -1) {\n-                        String unqualifiedName = descriptor.substring(index, indexOfSemi);\n-                        boolean legal = verifyUnqualifiedClassName(unqualifiedName);\n-                        if (!legal) {\n-                            return 0;\n+                    \/\/ state variable for detection of illegal states, such as:\n+                    \/\/ empty unqualified name, '\/\/', leading '\/', or trailing '\/'\n+                    boolean legal = false;\n+                    while (++index < end) {\n+                        switch (descriptor.charAt(index)) {\n+                            case ';' -> {\n+                                \/\/ illegal state on parser exit indicates empty unqualified name or trailing '\/'\n+                                return legal ? index - start + 1 : 0;\n+                            }\n+                            case '.', '[' -> {\n+                                \/\/ do not permit '.' or '['\n+                                return 0;\n+                            }\n+                            case '\/' -> {\n+                                \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n+                                if (!legal) return 0;\n+                                legal = false;\n+                            }\n+                            default ->\n+                                legal = true;\n@@ -217,1 +230,0 @@\n-                        return index - start + unqualifiedName.length() + 1;\n@@ -237,0 +249,21 @@\n+    static boolean verifyUnqualifiedClassName(String name) {\n+        for (int index = 0; index < name.length(); index++) {\n+            char ch = name.charAt(index);\n+            if (ch < 128) {\n+                if (ch == '.' || ch == ';' || ch == '[' ) {\n+                    return false;   \/\/ do not permit '.', ';', or '['\n+                }\n+                if (ch == '\/') {\n+                    \/\/ check for '\/\/' or leading or trailing '\/' which are not legal\n+                    \/\/ unqualified name must not be empty\n+                    if (index == 0 || index + 1 >= name.length() || name.charAt(index + 1) == '\/') {\n+                        return false;\n+                    }\n+                }\n+            } else {\n+                index ++;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -293,20 +326,0 @@\n-    static boolean verifyUnqualifiedClassName(String name) {\n-        for (int index = 0; index < name.length(); index++) {\n-            char ch = name.charAt(index);\n-            if (ch < 128) {\n-                if (ch == '.' || ch == ';' || ch == '[' ) {\n-                    return false;   \/\/ do not permit '.', ';', or '['\n-                }\n-                if (ch == '\/') {\n-                    \/\/ check for '\/\/' or leading or trailing '\/' which are not legal\n-                    \/\/ unqualified name must not be empty\n-                    if (index == 0 || index + 1 >= name.length() || name.charAt(index + 1) == '\/') {\n-                        return false;\n-                    }\n-                }\n-            } else {\n-                index ++;\n-            }\n-        }\n-        return true;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":43,"deletions":30,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,5 @@\n-<h2>Why is <code>Thread.stop<\/code> deprecated?<\/h2>\n-<p>Because it is inherently unsafe. Stopping a thread causes it to\n-unlock all the monitors that it has locked. (The monitors are\n-unlocked as the <code>ThreadDeath<\/code> exception propagates up\n+<h2>Why is <code>Thread.stop<\/code> deprecated and the ability to\n+stop a thread removed?<\/h2>\n+<p>Because it was inherently unsafe. Stopping a thread caused it to\n+unlock all the monitors that it had locked. (The monitors were\n+unlocked as the <code>ThreadDeath<\/code> exception propagated up\n@@ -39,1 +40,1 @@\n-monitors were in an inconsistent state, other threads may now view\n+monitors were in an inconsistent state, other threads may have viewed\n@@ -44,2 +45,2 @@\n-<code>ThreadDeath<\/code> kills threads silently; thus, the user has\n-no warning that his program may be corrupted. The corruption can\n+<code>ThreadDeath<\/code> killed threads silently; thus, the user had\n+no warning that their program may be corrupted. The corruption could\n@@ -49,2 +50,2 @@\n-<h2>Couldn't I just catch the <code>ThreadDeath<\/code> exception\n-and fix the damaged object?<\/h2>\n+<h2>Couldn't I have just caught <code>ThreadDeath<\/code> and fixed\n+the damaged object?<\/h2>\n@@ -55,1 +56,1 @@\n-<li>A thread can throw a <code>ThreadDeath<\/code> exception\n+<li>A thread could throw a <code>ThreadDeath<\/code> exception\n@@ -58,1 +59,1 @@\n-<li>A thread can throw a second <code>ThreadDeath<\/code> exception\n+<li>A thread could throw a second <code>ThreadDeath<\/code> exception\n@@ -162,7 +163,8 @@\n-<code>Thread.resume<\/code> deprecated?<\/h2>\n-<p><code>Thread.suspend<\/code> is inherently deadlock-prone. If the\n-target thread holds a lock on the monitor protecting a critical\n-system resource when it is suspended, no thread can access this\n-resource until the target thread is resumed. If the thread that\n-would resume the target thread attempts to lock this monitor prior\n-to calling <code>resume<\/code>, deadlock results. Such deadlocks\n+<code>Thread.resume<\/code> deprecated and the ability to suspend or\n+resume a thread removed?<\/h2>\n+<p><code>Thread.suspend<\/code> was inherently deadlock-prone. If the\n+target thread held a lock on a monitor protecting a critical\n+system resource when it is suspended, no thread could access the\n+resource until the target thread was resumed. If the thread intending\n+to resume the target thread attempted to lock the monitor prior\n+to calling <code>resume<\/code>, deadlock resulted. Such deadlocks\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-            \/\/ method is inaccessible, or say ThreadDeath\/OutOfMemoryError\n+            \/\/ method is inaccessible, or say OutOfMemoryError\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BootstrapMethodInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-            \/\/ method is inaccessible, or say ThreadDeath\/OutOfMemoryError\n+            \/\/ method is inaccessible, or say OutOfMemoryError\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/CallSite.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -808,1 +808,1 @@\n-            if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))\n+            if (!isDirectory(dir))\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.event.SecurityProviderServiceEvent;\n+\n@@ -1284,2 +1286,5 @@\n-        if (s != null) {\n-            return s;\n+        if (s == null) {\n+            s = legacyMap.get(key);\n+            if (s != null && !s.isValid()) {\n+                legacyMap.remove(key, s);\n+            }\n@@ -1288,5 +1293,6 @@\n-        s = legacyMap.get(key);\n-        if (s != null && !s.isValid()) {\n-            legacyMap.remove(key, s);\n-        } else {\n-            return s;\n+        if (s != null && SecurityProviderServiceEvent.isTurnedOn()) {\n+            var e  = new SecurityProviderServiceEvent();\n+            e.provider = getName();\n+            e.type = type;\n+            e.algorithm = algorithm;\n+            e.commit();\n@@ -1295,1 +1301,1 @@\n-        return null;\n+        return s;\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-    static void reverse (StringBuffer result, int from, int to)\n+    static void reverse (StringBuilder result, int from, int to)\n","filename":"src\/java.base\/share\/classes\/java\/text\/RBCollationTables.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -608,3 +608,3 @@\n-            primResult = new StringBuffer();\n-            secResult = new StringBuffer();\n-            terResult = new StringBuffer();\n+            primResult = new StringBuilder();\n+            secResult = new StringBuilder();\n+            terResult = new StringBuilder();\n@@ -684,2 +684,2 @@\n-        secResult.append(terResult.toString());\n-        primResult.append(secResult.toString());\n+        secResult.append(terResult);\n+        primResult.append(secResult);\n@@ -765,3 +765,3 @@\n-    private StringBuffer primResult = null;\n-    private StringBuffer secResult = null;\n-    private StringBuffer terResult = null;\n+    private StringBuilder primResult = null;\n+    private StringBuilder secResult = null;\n+    private StringBuilder terResult = null;\n","filename":"src\/java.base\/share\/classes\/java\/text\/RuleBasedCollator.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1818,1 +1818,1 @@\n-     * @param prevSrc the previous queue stolen from in current phase, or 0\n+     * @param prevSrc the two previous queues (if nonzero) stolen from in current phase, packed as int\n@@ -1820,1 +1820,1 @@\n-     * @return id of queue if taken, negative if none found, prevSrc for retry\n+     * @return the next prevSrc value to use, or negative if none found\n@@ -1838,2 +1838,3 @@\n-                    if (prevSrc == 0 && q.base == nb && a[nk] != null)\n-                        signalWork();           \/\/ propagate\n+                    if (src + (src << SWIDTH) != prevSrc &&\n+                        q.base == nb && a[nk] != null)\n+                        signalWork();           \/\/ propagate at most twice\/run\n@@ -1841,1 +1842,1 @@\n-                    return src;\n+                    return src + (prevSrc << SWIDTH);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.event;\n+\n+\/**\n+ * Event recording details of Provider.getService(String type, String algorithm) calls\n+ *\/\n+\n+public final class SecurityProviderServiceEvent extends Event {\n+    private final static SecurityProviderServiceEvent EVENT = new SecurityProviderServiceEvent();\n+\n+    \/**\n+     * Returns {@code true} if event is enabled, {@code false} otherwise.\n+     *\/\n+    public static boolean isTurnedOn() {\n+        return EVENT.isEnabled();\n+    }\n+\n+    public String type;\n+    public String algorithm;\n+    public String provider;\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SecurityProviderServiceEvent.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2402,1 +2402,1 @@\n-                long digit = Math.multiplyHigh(bits, multiplier);\n+                long digit = Math.unsignedMultiplyHigh(bits, multiplier);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,3 +67,0 @@\n-    \/\/ Memory allocation size for mapping buffers\n-    private static final long allocationGranularity;\n-\n@@ -74,3 +71,0 @@\n-    \/\/ Maximum direct transfer size\n-    private static final int MAX_DIRECT_TRANSFER_SIZE;\n-\n@@ -78,1 +72,1 @@\n-    private final FileDispatcher nd;\n+    private static final FileDispatcher nd = new FileDispatcherImpl();\n@@ -133,0 +127,1 @@\n+        this.path = path;\n@@ -135,2 +130,0 @@\n-        this.parent = parent;\n-        this.path = path;\n@@ -138,1 +131,1 @@\n-        this.nd = new FileDispatcherImpl();\n+        this.parent = parent;\n@@ -154,2 +147,3 @@\n-    \/\/ Used by FileInputStream.getChannel(), FileOutputStream.getChannel\n-    \/\/ and RandomAccessFile.getChannel()\n+\n+    \/\/ Used by FileInputStream::getChannel, FileOutputStream::getChannel,\n+    \/\/ and RandomAccessFile::getChannel\n@@ -577,1 +571,1 @@\n-                    n = transferTo0(fd, position, icount, targetFD, append);\n+                    n = nd.transferTo(fd, position, icount, targetFD, append);\n@@ -782,1 +776,1 @@\n-            int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n+            int icount = (int)Math.min(count, nd.maxDirectTransferSize());\n@@ -816,1 +810,1 @@\n-                    n = transferFrom0(srcFD, fd, position, count, append);\n+                    n = nd.transferFrom(srcFD, fd, position, count, append);\n@@ -1055,3 +1049,0 @@\n-        \/\/ may be required to close file\n-        private static final NativeDispatcher nd = new FileDispatcherImpl();\n-\n@@ -1097,1 +1088,1 @@\n-            unmap0(address, size);\n+            nd.unmap(address, size);\n@@ -1316,1 +1307,1 @@\n-                pagePosition = (int)(position % allocationGranularity);\n+                pagePosition = (int)(position % nd.allocationGranularity());\n@@ -1320,2 +1311,2 @@\n-                    \/\/ If map0 did not throw an exception, the address is valid\n-                    addr = map0(fd, prot, mapPosition, mapSize, isSync);\n+                    \/\/ If map did not throw an exception, the address is valid\n+                    addr = nd.map(fd, prot, mapPosition, mapSize, isSync);\n@@ -1332,1 +1323,1 @@\n-                        addr = map0(fd, prot, mapPosition, mapSize, isSync);\n+                        addr = nd.map(fd, prot, mapPosition, mapSize, isSync);\n@@ -1346,1 +1337,1 @@\n-                unmap0(addr, mapSize);\n+                nd.unmap(addr, mapSize);\n@@ -1351,1 +1342,1 @@\n-            assert (addr % allocationGranularity == 0);\n+            assert (addr % nd.allocationGranularity() == 0);\n@@ -1353,2 +1344,2 @@\n-                           ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition)\n-                           : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition));\n+                ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition)\n+                : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition));\n@@ -1578,33 +1569,0 @@\n-\n-    \/\/ -- Native methods --\n-\n-    \/\/ Creates a new mapping\n-    private native long map0(FileDescriptor fd, int prot, long position,\n-                             long length, boolean isSync)\n-        throws IOException;\n-\n-    \/\/ Removes an existing mapping\n-    private static native int unmap0(long address, long length);\n-\n-    \/\/ Transfers from src to dst, or returns IOStatus.UNSUPPORTED (-4) or\n-    \/\/ IOStatus.UNSUPPORTED_CASE (-6) if the kernel does not support it\n-    private static native long transferTo0(FileDescriptor src, long position,\n-                                           long count, FileDescriptor dst,\n-                                           boolean append);\n-\n-    private static native long transferFrom0(FileDescriptor src,\n-                                             FileDescriptor dst,\n-                                             long position, long count,\n-                                             boolean append);\n-\n-    \/\/ Retrieves the maximum size of a transfer\n-    private static native int maxDirectTransferSize0();\n-\n-    \/\/ Retrieves allocation granularity\n-    private static native long allocationGranularity0();\n-\n-    static {\n-        IOUtil.load();\n-        allocationGranularity = allocationGranularity0();\n-        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":18,"deletions":60,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,16 @@\n+    abstract long allocationGranularity();\n+\n+    abstract long map(FileDescriptor fd, int prot, long position, long length,\n+                      boolean isSync)\n+        throws IOException;\n+\n+    abstract int unmap(long address, long length);\n+\n+    abstract int maxDirectTransferSize();\n+\n+    abstract long transferTo(FileDescriptor src, long position, long count,\n+                             FileDescriptor dst, boolean append);\n+\n+    abstract long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                               long position, long count, boolean append);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileDispatcher.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -127,4 +127,0 @@\n-    \/\/ java.lang.Thread\n-    public static final RuntimePermission STOP_THREAD_PERMISSION =\n-       new RuntimePermission(\"stopThread\");\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityConstants.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1994,0 +1994,1 @@\n+#define JNI_VERSION_20  0x00140000\n","filename":"src\/java.base\/share\/native\/include\/jni.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-    {\"stop0\",            \"(\" OBJ \")V\", (void *)&JVM_StopThread},\n@@ -42,2 +41,0 @@\n-    {\"suspend0\",         \"()V\",        (void *)&JVM_SuspendThread},\n-    {\"resume0\",          \"()V\",        (void *)&JVM_ResumeThread},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    { \"notifyJvmtiHideFrames\",   \"(Z)V\", (void *)&JVM_VirtualThreadHideFrames },\n","filename":"src\/java.base\/share\/native\/libjava\/VirtualThread.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,3 +112,0 @@\n-void NET_ThrowCurrent(JNIEnv *env, char *msg);\n-\n-jfieldID NET_GetFileDescriptorID(JNIEnv *env);\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,197 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-class FileDispatcherImpl extends FileDispatcher {\n-\n-    static {\n-        IOUtil.load();\n-        init();\n-    }\n-\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-            SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    FileDispatcherImpl() {\n-    }\n-\n-    int read(FileDescriptor fd, long address, int len) throws IOException {\n-        return read0(fd, address, len);\n-    }\n-\n-    int pread(FileDescriptor fd, long address, int len, long position)\n-        throws IOException\n-    {\n-        return pread0(fd, address, len, position);\n-    }\n-\n-    long readv(FileDescriptor fd, long address, int len) throws IOException {\n-        return readv0(fd, address, len);\n-    }\n-\n-    int write(FileDescriptor fd, long address, int len) throws IOException {\n-        return write0(fd, address, len);\n-    }\n-\n-    int pwrite(FileDescriptor fd, long address, int len, long position)\n-        throws IOException\n-    {\n-        return pwrite0(fd, address, len, position);\n-    }\n-\n-    long writev(FileDescriptor fd, long address, int len)\n-        throws IOException\n-    {\n-        return writev0(fd, address, len);\n-    }\n-\n-    long seek(FileDescriptor fd, long offset) throws IOException {\n-        return seek0(fd, offset);\n-    }\n-\n-    int force(FileDescriptor fd, boolean metaData) throws IOException {\n-        return force0(fd, metaData);\n-    }\n-\n-    int truncate(FileDescriptor fd, long size) throws IOException {\n-        return truncate0(fd, size);\n-    }\n-\n-    long size(FileDescriptor fd) throws IOException {\n-        return size0(fd);\n-    }\n-\n-    int lock(FileDescriptor fd, boolean blocking, long pos, long size,\n-             boolean shared) throws IOException\n-    {\n-        return lock0(fd, blocking, pos, size, shared);\n-    }\n-\n-    void release(FileDescriptor fd, long pos, long size) throws IOException {\n-        release0(fd, pos, size);\n-    }\n-\n-    void close(FileDescriptor fd) throws IOException {\n-        fdAccess.close(fd);\n-    }\n-\n-    void preClose(FileDescriptor fd) throws IOException {\n-        preClose0(fd);\n-    }\n-\n-    void dup(FileDescriptor fd1, FileDescriptor fd2) throws IOException {\n-        dup0(fd1, fd2);\n-    }\n-\n-    FileDescriptor duplicateForMapping(FileDescriptor fd) {\n-        \/\/ file descriptor not required for mapping operations; okay\n-        \/\/ to return invalid file descriptor.\n-        return new FileDescriptor();\n-    }\n-\n-    boolean canTransferToDirectly(java.nio.channels.SelectableChannel sc) {\n-        return true;\n-    }\n-\n-    boolean transferToDirectlyNeedsPositionLock() {\n-        return false;\n-    }\n-\n-    boolean canTransferToFromOverlappedMap() {\n-        return canTransferToFromOverlappedMap0();\n-    }\n-\n-    int setDirectIO(FileDescriptor fd, String path) {\n-        int result = -1;\n-        try {\n-            result = setDirect0(fd);\n-        } catch (IOException e) {\n-            throw new UnsupportedOperationException\n-                (\"Error setting up DirectIO\", e);\n-        }\n-        return result;\n-    }\n-\n-    \/\/ -- Native methods --\n-\n-    static native int read0(FileDescriptor fd, long address, int len)\n-        throws IOException;\n-\n-    static native int pread0(FileDescriptor fd, long address, int len,\n-                             long position) throws IOException;\n-\n-    static native long readv0(FileDescriptor fd, long address, int len)\n-        throws IOException;\n-\n-    static native int write0(FileDescriptor fd, long address, int len)\n-        throws IOException;\n-\n-    static native int pwrite0(FileDescriptor fd, long address, int len,\n-                             long position) throws IOException;\n-\n-    static native long writev0(FileDescriptor fd, long address, int len)\n-        throws IOException;\n-\n-    static native int force0(FileDescriptor fd, boolean metaData)\n-        throws IOException;\n-\n-    static native long seek0(FileDescriptor fd, long offset)\n-        throws IOException;\n-\n-    static native int truncate0(FileDescriptor fd, long size)\n-        throws IOException;\n-\n-    static native long size0(FileDescriptor fd) throws IOException;\n-\n-    static native int lock0(FileDescriptor fd, boolean blocking, long pos,\n-                            long size, boolean shared) throws IOException;\n-\n-    static native void release0(FileDescriptor fd, long pos, long size)\n-        throws IOException;\n-\n-    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n-    \/\/ NOT used by FileDispatcherImpl\n-    static native void close0(FileDescriptor fd) throws IOException;\n-\n-    static native void preClose0(FileDescriptor fd) throws IOException;\n-\n-    static native void dup0(FileDescriptor fd1, FileDescriptor fd2) throws IOException;\n-\n-    static native void closeIntFD(int fd) throws IOException;\n-\n-    static native boolean canTransferToFromOverlappedMap0();\n-\n-    static native int setDirect0(FileDescriptor fd) throws IOException;\n-\n-    static native void init();\n-\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":0,"deletions":197,"binary":false,"changes":197,"status":"deleted"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+class UnixFileDispatcherImpl extends FileDispatcher {\n+    private static final int MAP_INVALID = -1;\n+    private static final int MAP_RO = 0;\n+    private static final int MAP_RW = 1;\n+    private static final int MAP_PV = 2;\n+\n+    static {\n+        IOUtil.load();\n+        init();\n+    }\n+\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+            SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    UnixFileDispatcherImpl() {\n+    }\n+\n+    int read(FileDescriptor fd, long address, int len) throws IOException {\n+        return read0(fd, address, len);\n+    }\n+\n+    int pread(FileDescriptor fd, long address, int len, long position)\n+        throws IOException\n+    {\n+        return pread0(fd, address, len, position);\n+    }\n+\n+    long readv(FileDescriptor fd, long address, int len) throws IOException {\n+        return readv0(fd, address, len);\n+    }\n+\n+    int write(FileDescriptor fd, long address, int len) throws IOException {\n+        return write0(fd, address, len);\n+    }\n+\n+    int pwrite(FileDescriptor fd, long address, int len, long position)\n+        throws IOException\n+    {\n+        return pwrite0(fd, address, len, position);\n+    }\n+\n+    long writev(FileDescriptor fd, long address, int len)\n+        throws IOException\n+    {\n+        return writev0(fd, address, len);\n+    }\n+\n+    long seek(FileDescriptor fd, long offset) throws IOException {\n+        return seek0(fd, offset);\n+    }\n+\n+    int force(FileDescriptor fd, boolean metaData) throws IOException {\n+        return force0(fd, metaData);\n+    }\n+\n+    int truncate(FileDescriptor fd, long size) throws IOException {\n+        return truncate0(fd, size);\n+    }\n+\n+    long size(FileDescriptor fd) throws IOException {\n+        return size0(fd);\n+    }\n+\n+    int lock(FileDescriptor fd, boolean blocking, long pos, long size,\n+             boolean shared) throws IOException\n+    {\n+        return lock0(fd, blocking, pos, size, shared);\n+    }\n+\n+    void release(FileDescriptor fd, long pos, long size) throws IOException {\n+        release0(fd, pos, size);\n+    }\n+\n+    void close(FileDescriptor fd) throws IOException {\n+        fdAccess.close(fd);\n+    }\n+\n+    void preClose(FileDescriptor fd) throws IOException {\n+        preClose0(fd);\n+    }\n+\n+    void dup(FileDescriptor fd1, FileDescriptor fd2) throws IOException {\n+        dup0(fd1, fd2);\n+    }\n+\n+    FileDescriptor duplicateForMapping(FileDescriptor fd) {\n+        \/\/ file descriptor not required for mapping operations; okay\n+        \/\/ to return invalid file descriptor.\n+        return new FileDescriptor();\n+    }\n+\n+    boolean canTransferToDirectly(java.nio.channels.SelectableChannel sc) {\n+        return true;\n+    }\n+\n+    boolean transferToDirectlyNeedsPositionLock() {\n+        return false;\n+    }\n+\n+    boolean canTransferToFromOverlappedMap() {\n+        return true;\n+    }\n+\n+    long allocationGranularity() {\n+        return allocationGranularity0();\n+    }\n+\n+    long map(FileDescriptor fd, int prot, long position, long length,\n+             boolean isSync)\n+        throws IOException\n+    {\n+        return map0(fd, prot, position, length, isSync);\n+    }\n+\n+    int unmap(long address, long length) {\n+        return unmap0(address, length);\n+    }\n+\n+    int maxDirectTransferSize() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n+    long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                      long position, long count, boolean append) {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n+    int setDirectIO(FileDescriptor fd, String path) {\n+        int result = -1;\n+        try {\n+            result = setDirect0(fd);\n+        } catch (IOException e) {\n+            throw new UnsupportedOperationException\n+                (\"Error setting up DirectIO\", e);\n+        }\n+        return result;\n+    }\n+\n+    \/\/ -- Native methods --\n+\n+    static native int read0(FileDescriptor fd, long address, int len)\n+        throws IOException;\n+\n+    static native int pread0(FileDescriptor fd, long address, int len,\n+                             long position) throws IOException;\n+\n+    static native long readv0(FileDescriptor fd, long address, int len)\n+        throws IOException;\n+\n+    static native int write0(FileDescriptor fd, long address, int len)\n+        throws IOException;\n+\n+    static native int pwrite0(FileDescriptor fd, long address, int len,\n+                             long position) throws IOException;\n+\n+    static native long writev0(FileDescriptor fd, long address, int len)\n+        throws IOException;\n+\n+    static native int force0(FileDescriptor fd, boolean metaData)\n+        throws IOException;\n+\n+    static native long seek0(FileDescriptor fd, long offset)\n+        throws IOException;\n+\n+    static native int truncate0(FileDescriptor fd, long size)\n+        throws IOException;\n+\n+    static native long size0(FileDescriptor fd) throws IOException;\n+\n+    static native int lock0(FileDescriptor fd, boolean blocking, long pos,\n+                            long size, boolean shared) throws IOException;\n+\n+    static native void release0(FileDescriptor fd, long pos, long size)\n+        throws IOException;\n+\n+    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n+    \/\/ NOT used by FileDispatcherImpl\n+    static native void close0(FileDescriptor fd) throws IOException;\n+\n+    static native void preClose0(FileDescriptor fd) throws IOException;\n+\n+    static native void dup0(FileDescriptor fd1, FileDescriptor fd2) throws IOException;\n+\n+    static native void closeIntFD(int fd) throws IOException;\n+\n+    static native long allocationGranularity0();\n+\n+    static native long map0(FileDescriptor fd, int prot, long position,\n+                            long length, boolean isSync)\n+        throws IOException;\n+\n+    static native int unmap0(long address, long length);\n+\n+    static native int setDirect0(FileDescriptor fd) throws IOException;\n+\n+    static native void init();\n+}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixFileDispatcherImpl.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include <signal.h>\n@@ -135,0 +136,1 @@\n+    sigset_t unblock_signals;\n@@ -144,0 +146,5 @@\n+\n+    \/\/ Reset any mask signals from parent\n+    sigemptyset(&unblock_signals);\n+    sigprocmask(SIG_SETMASK, &unblock_signals, NULL);\n+\n","filename":"src\/java.base\/unix\/native\/jspawnhelper\/jspawnhelper.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -776,1 +776,0 @@\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,5 +72,0 @@\n-void\n-NET_ThrowCurrent(JNIEnv *env, char *msg) {\n-    NET_ThrowNew(env, errno, msg);\n-}\n-\n@@ -98,9 +93,0 @@\n-\n-jfieldID\n-NET_GetFileDescriptorID(JNIEnv *env)\n-{\n-    jclass cls = (*env)->FindClass(env, \"java\/io\/FileDescriptor\");\n-    CHECK_NULL_RETURN(cls, NULL);\n-    return (*env)->GetFieldID(env, cls, \"fd\", \"I\");\n-}\n-\n@@ -331,7 +317,0 @@\n-void\n-NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass) {\n-    if (sa->sa.sa_family == AF_INET6) {\n-        sa->sa6.sin6_flowinfo = htonl((trafficClass & 0xff) << 20);\n-    }\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,8 +78,0 @@\n-int NET_Timeout(JNIEnv *env, int s, long timeout, jlong  nanoTimeStamp);\n-int NET_Read(int s, void* buf, size_t len);\n-int NET_NonBlockingRead(int s, void* buf, size_t len);\n-int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,\n-                 struct sockaddr *from, socklen_t *fromlen);\n-int NET_Send(int s, void *msg, int len, unsigned int flags);\n-int NET_SendTo(int s, const void *msg, int len,  unsigned  int\n-               flags, const struct sockaddr *to, int tolen);\n@@ -87,3 +79,0 @@\n-int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen);\n-int NET_SocketClose(int s);\n-int NET_Dup2(int oldfd, int newfd);\n@@ -97,1 +86,0 @@\n-void NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass);\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.h","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,336 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <sys\/mman.h>\n-#include <sys\/stat.h>\n-#include <fcntl.h>\n-#include <sys\/types.h>\n-#include <unistd.h>\n-\n-#if defined(__linux__)\n-#include <sys\/sendfile.h>\n-#include <dlfcn.h>\n-#elif defined(_AIX)\n-#include <string.h>\n-#include <sys\/socket.h>\n-#elif defined(_ALLBSD_SOURCE)\n-#include <sys\/socket.h>\n-#include <sys\/uio.h>\n-#define lseek64 lseek\n-#define mmap64 mmap\n-#endif\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-#include \"sun_nio_ch_FileChannelImpl.h\"\n-#include \"java_lang_Integer.h\"\n-#include <assert.h>\n-\n-#if defined(__linux__)\n-typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n-                                     unsigned int);\n-static copy_file_range_func* my_copy_file_range_func = NULL;\n-#endif\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_allocationGranularity0(JNIEnv *env, jclass clazz)\n-{\n-    jlong pageSize = sysconf(_SC_PAGESIZE);\n-#if defined(__linux__)\n-    my_copy_file_range_func =\n-        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n-#endif\n-    return pageSize;\n-}\n-\n-static jlong\n-handle(JNIEnv *env, jlong rv, char *msg)\n-{\n-    if (rv >= 0)\n-        return rv;\n-    if (errno == EINTR)\n-        return IOS_INTERRUPTED;\n-    JNU_ThrowIOExceptionWithLastError(env, msg);\n-    return IOS_THROWN;\n-}\n-\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this, jobject fdo,\n-                                     jint prot, jlong off, jlong len, jboolean map_sync)\n-{\n-    void *mapAddress = 0;\n-    jint fd = fdval(env, fdo);\n-    int protections = 0;\n-    int flags = 0;\n-\n-    \/\/ should never be called with map_sync and prot == PRIVATE\n-    assert((prot != sun_nio_ch_FileChannelImpl_MAP_PV) || !map_sync);\n-\n-    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {\n-        protections = PROT_READ;\n-        flags = MAP_SHARED;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {\n-        protections = PROT_WRITE | PROT_READ;\n-        flags = MAP_SHARED;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {\n-        protections =  PROT_WRITE | PROT_READ;\n-        flags = MAP_PRIVATE;\n-    }\n-\n-    \/\/ if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is\n-    \/\/ best to define them here. This ensures the code compiles on old\n-    \/\/ OS releases which do not provide the relevant headers. If run\n-    \/\/ on the same machine then it will work if the kernel contains\n-    \/\/ the necessary support otherwise mmap should fail with an\n-    \/\/ invalid argument error\n-\n-#ifndef MAP_SYNC\n-#define MAP_SYNC 0x80000\n-#endif\n-#ifndef MAP_SHARED_VALIDATE\n-#define MAP_SHARED_VALIDATE 0x03\n-#endif\n-\n-    if (map_sync) {\n-        \/\/ ensure\n-        \/\/  1) this is Linux on AArch64, x86_64, or PPC64 LE\n-        \/\/  2) the mmap APIs are available at compile time\n-#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) && defined(_LP64)) || defined(ppc64le))\n-        \/\/ TODO - implement for solaris\/AIX\/BSD\/WINDOWS and for 32 bit\n-        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n-        return IOS_THROWN;\n-#else\n-        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;\n-#endif\n-    }\n-\n-    mapAddress = mmap64(\n-        0,                    \/* Let OS decide location *\/\n-        len,                  \/* Number of bytes to map *\/\n-        protections,          \/* File permissions *\/\n-        flags,                \/* Changes are shared *\/\n-        fd,                   \/* File descriptor of mapped file *\/\n-        off);                 \/* Offset into file *\/\n-\n-    if (mapAddress == MAP_FAILED) {\n-        if (map_sync && errno == ENOTSUP) {\n-            JNU_ThrowIOExceptionWithLastError(env, \"map with mode MAP_SYNC unsupported\");\n-            return IOS_THROWN;\n-        }\n-\n-        if (errno == ENOMEM) {\n-            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n-            return IOS_THROWN;\n-        }\n-        return handle(env, -1, \"Map failed\");\n-    }\n-\n-    return ((jlong) (unsigned long) mapAddress);\n-}\n-\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_unmap0(JNIEnv *env, jobject this,\n-                                       jlong address, jlong len)\n-{\n-    void *a = (void *)jlong_to_ptr(address);\n-    return handle(env,\n-                  munmap(a, (size_t)len),\n-                  \"Unmap failed\");\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n-                                            jobject srcFDO,\n-                                            jlong position, jlong count,\n-                                            jobject dstFDO, jboolean append)\n-{\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-#if defined(__linux__)\n-    \/\/ copy_file_range fails with EBADF when appending, and sendfile\n-    \/\/ fails with EINVAL\n-    if (append == JNI_TRUE)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    off64_t offset = (off64_t)position;\n-    jlong n;\n-    if (my_copy_file_range_func != NULL) {\n-        size_t len = (size_t)count;\n-        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n-        if (n < 0) {\n-            switch (errno) {\n-                case EINTR:\n-                    return IOS_INTERRUPTED;\n-                case EINVAL:\n-                case ENOSYS:\n-                case EXDEV:\n-                    \/\/ ignore and try sendfile()\n-                    break;\n-                default:\n-                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n-                    return IOS_THROWN;\n-            }\n-        }\n-        if (n >= 0)\n-            return n;\n-    }\n-\n-    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#elif defined(__APPLE__)\n-    off_t numBytes;\n-    int result;\n-\n-    numBytes = count;\n-\n-    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n-\n-    if (numBytes > 0)\n-        return numBytes;\n-\n-    if (result == -1) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)\n-            return IOS_UNSUPPORTED_CASE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    return result;\n-\n-#elif defined(_AIX)\n-    jlong max = (jlong)java_lang_Integer_MAX_VALUE;\n-    struct sf_parms sf_iobuf;\n-    jlong result;\n-\n-    if (position > max)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    if (count > max)\n-        count = max;\n-\n-    memset(&sf_iobuf, 0, sizeof(sf_iobuf));\n-    sf_iobuf.file_descriptor = srcFD;\n-    sf_iobuf.file_offset = (off_t)position;\n-    sf_iobuf.file_bytes = count;\n-\n-    result = send_file(&dstFD, &sf_iobuf, SF_SYNC_CACHE);\n-\n-    \/* AIX send_file() will return 0 when this operation complete successfully,\n-     * return 1 when partial bytes transferred and return -1 when an error has\n-     * occurred.\n-     *\/\n-    if (result == -1) {\n-        if (errno == EWOULDBLOCK)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        if (errno == ENOTSOCK)\n-            return IOS_UNSUPPORTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    if (sf_iobuf.bytes_sent > 0)\n-        return (jlong)sf_iobuf.bytes_sent;\n-\n-    return IOS_UNSUPPORTED_CASE;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                              jobject srcFDO, jobject dstFDO,\n-                                              jlong position, jlong count,\n-                                              jboolean append)\n-{\n-#if defined(__linux__)\n-    if (my_copy_file_range_func == NULL)\n-        return IOS_UNSUPPORTED;\n-    \/\/ copy_file_range fails with EBADF when appending\n-    if (append == JNI_TRUE)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-    off64_t offset = (off64_t)position;\n-    size_t len = (size_t)count;\n-    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, len, 0);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if (errno == ENOSYS)\n-            return IOS_UNSUPPORTED_CASE;\n-        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n-            ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jobject this)\n-{\n-#if defined(LINUX)\n-    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n-#else\n-    return java_lang_Integer_MAX_VALUE;\n-#endif\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":0,"deletions":336,"binary":false,"changes":336,"status":"deleted"},{"patch":"@@ -1,404 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <fcntl.h>\n-#include <sys\/uio.h>\n-#include <unistd.h>\n-#ifdef MACOSX\n-#include <sys\/mount.h>\n-#include <sys\/param.h>\n-#endif\n-#include <sys\/stat.h>\n-#include <sys\/statvfs.h>\n-\n-#if defined(__linux__)\n-#include <linux\/fs.h>\n-#include <sys\/ioctl.h>\n-#endif\n-\n-#if defined(_ALLBSD_SOURCE)\n-#define lseek64 lseek\n-#define stat64 stat\n-#define flock64 flock\n-#define off64_t off_t\n-#define F_SETLKW64 F_SETLKW\n-#define F_SETLK64 F_SETLK\n-#define pread64 pread\n-#define pwrite64 pwrite\n-#define ftruncate64 ftruncate\n-#define fstat64 fstat\n-#define fdatasync fsync\n-#endif\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-#include \"sun_nio_ch_FileDispatcherImpl.h\"\n-#include \"java_lang_Long.h\"\n-\n-static int preCloseFD = -1;     \/* File descriptor to which we dup other fd's\n-                                   before closing them for real *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_init(JNIEnv *env, jclass cl)\n-{\n-    int sp[2];\n-    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n-        return;\n-    }\n-    preCloseFD = sp[0];\n-    close(sp[1]);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_read0(JNIEnv *env, jclass clazz,\n-                             jobject fdo, jlong address, jint len)\n-{\n-    jint fd = fdval(env, fdo);\n-    void *buf = (void *)jlong_to_ptr(address);\n-\n-    return convertReturnVal(env, read(fd, buf, len), JNI_TRUE);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_pread0(JNIEnv *env, jclass clazz, jobject fdo,\n-                            jlong address, jint len, jlong offset)\n-{\n-    jint fd = fdval(env, fdo);\n-    void *buf = (void *)jlong_to_ptr(address);\n-\n-    return convertReturnVal(env, pread64(fd, buf, len, offset), JNI_TRUE);\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_readv0(JNIEnv *env, jclass clazz,\n-                              jobject fdo, jlong address, jint len)\n-{\n-    jint fd = fdval(env, fdo);\n-    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);\n-    return convertLongReturnVal(env, readv(fd, iov, len), JNI_TRUE);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_write0(JNIEnv *env, jclass clazz,\n-                              jobject fdo, jlong address, jint len)\n-{\n-    jint fd = fdval(env, fdo);\n-    void *buf = (void *)jlong_to_ptr(address);\n-\n-    return convertReturnVal(env, write(fd, buf, len), JNI_FALSE);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_pwrite0(JNIEnv *env, jclass clazz, jobject fdo,\n-                            jlong address, jint len, jlong offset)\n-{\n-    jint fd = fdval(env, fdo);\n-    void *buf = (void *)jlong_to_ptr(address);\n-\n-    return convertReturnVal(env, pwrite64(fd, buf, len, offset), JNI_FALSE);\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_writev0(JNIEnv *env, jclass clazz,\n-                                       jobject fdo, jlong address, jint len)\n-{\n-    jint fd = fdval(env, fdo);\n-    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);\n-    return convertLongReturnVal(env, writev(fd, iov, len), JNI_FALSE);\n-}\n-\n-static jlong\n-handle(JNIEnv *env, jlong rv, char *msg)\n-{\n-    if (rv >= 0)\n-        return rv;\n-    if (errno == EINTR)\n-        return IOS_INTERRUPTED;\n-    JNU_ThrowIOExceptionWithLastError(env, msg);\n-    return IOS_THROWN;\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_seek0(JNIEnv *env, jclass clazz,\n-                                         jobject fdo, jlong offset)\n-{\n-    jint fd = fdval(env, fdo);\n-    off64_t result;\n-    if (offset < 0) {\n-        result = lseek64(fd, 0, SEEK_CUR);\n-    } else {\n-        result = lseek64(fd, offset, SEEK_SET);\n-    }\n-    return handle(env, (jlong)result, \"lseek64 failed\");\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_force0(JNIEnv *env, jobject this,\n-                                          jobject fdo, jboolean md)\n-{\n-    jint fd = fdval(env, fdo);\n-    int result = 0;\n-\n-#ifdef MACOSX\n-    result = fcntl(fd, F_FULLFSYNC);\n-    if (result == -1) {\n-        struct statfs fbuf;\n-        int errno_fcntl = errno;\n-        if (fstatfs(fd, &fbuf) == 0) {\n-            if ((fbuf.f_flags & MNT_LOCAL) == 0) {\n-                \/* Try fsync() in case file is not local. *\/\n-                result = fsync(fd);\n-            }\n-        } else {\n-            \/* fstatfs() failed so restore errno from fcntl(). *\/\n-            errno = errno_fcntl;\n-        }\n-    }\n-#else \/* end MACOSX, begin not-MACOSX *\/\n-    if (md == JNI_FALSE) {\n-        result = fdatasync(fd);\n-    } else {\n-#ifdef _AIX\n-        \/* On AIX, calling fsync on a file descriptor that is opened only for\n-         * reading results in an error (\"EBADF: The FileDescriptor parameter is\n-         * not a valid file descriptor open for writing.\").\n-         * However, at this point it is not possibly anymore to read the\n-         * 'writable' attribute of the corresponding file channel so we have to\n-         * use 'fcntl'.\n-         *\/\n-        int getfl = fcntl(fd, F_GETFL);\n-        if (getfl >= 0 && (getfl & O_ACCMODE) == O_RDONLY) {\n-            return 0;\n-        }\n-#endif \/* _AIX *\/\n-        result = fsync(fd);\n-    }\n-#endif \/* not-MACOSX *\/\n-    return handle(env, result, \"Force failed\");\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_truncate0(JNIEnv *env, jobject this,\n-                                             jobject fdo, jlong size)\n-{\n-    return handle(env,\n-                  ftruncate64(fdval(env, fdo), size),\n-                  \"Truncation failed\");\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_size0(JNIEnv *env, jobject this, jobject fdo)\n-{\n-    jint fd = fdval(env, fdo);\n-    struct stat64 fbuf;\n-\n-    if (fstat64(fd, &fbuf) < 0)\n-        return handle(env, -1, \"Size failed\");\n-\n-#ifdef BLKGETSIZE64\n-    if (S_ISBLK(fbuf.st_mode)) {\n-        uint64_t size;\n-        if (ioctl(fd, BLKGETSIZE64, &size) < 0)\n-            return handle(env, -1, \"Size failed\");\n-        return (jlong)size;\n-    }\n-#endif\n-\n-    return fbuf.st_size;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_lock0(JNIEnv *env, jobject this, jobject fdo,\n-                                      jboolean block, jlong pos, jlong size,\n-                                      jboolean shared)\n-{\n-    jint fd = fdval(env, fdo);\n-    jint lockResult = 0;\n-    int cmd = 0;\n-    struct flock64 fl;\n-\n-    fl.l_whence = SEEK_SET;\n-    if (size == (jlong)java_lang_Long_MAX_VALUE) {\n-        fl.l_len = (off64_t)0;\n-    } else {\n-        fl.l_len = (off64_t)size;\n-    }\n-    fl.l_start = (off64_t)pos;\n-    if (shared == JNI_TRUE) {\n-        fl.l_type = F_RDLCK;\n-    } else {\n-        fl.l_type = F_WRLCK;\n-    }\n-    if (block == JNI_TRUE) {\n-        cmd = F_SETLKW64;\n-    } else {\n-        cmd = F_SETLK64;\n-    }\n-    lockResult = fcntl(fd, cmd, &fl);\n-    if (lockResult < 0) {\n-        if ((cmd == F_SETLK64) && (errno == EAGAIN || errno == EACCES))\n-            return sun_nio_ch_FileDispatcherImpl_NO_LOCK;\n-        if (errno == EINTR)\n-            return sun_nio_ch_FileDispatcherImpl_INTERRUPTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Lock failed\");\n-    }\n-    return 0;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_release0(JNIEnv *env, jobject this,\n-                                         jobject fdo, jlong pos, jlong size)\n-{\n-    jint fd = fdval(env, fdo);\n-    jint lockResult = 0;\n-    struct flock64 fl;\n-    int cmd = F_SETLK64;\n-\n-    fl.l_whence = SEEK_SET;\n-    if (size == (jlong)java_lang_Long_MAX_VALUE) {\n-        fl.l_len = (off64_t)0;\n-    } else {\n-        fl.l_len = (off64_t)size;\n-    }\n-    fl.l_start = (off64_t)pos;\n-    fl.l_type = F_UNLCK;\n-    lockResult = fcntl(fd, cmd, &fl);\n-    if (lockResult < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Release failed\");\n-    }\n-}\n-\n-\n-static void closeFileDescriptor(JNIEnv *env, int fd) {\n-    if (fd != -1) {\n-        int result = close(fd);\n-        if (result < 0)\n-            JNU_ThrowIOExceptionWithLastError(env, \"Close failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_close0(JNIEnv *env, jclass clazz, jobject fdo)\n-{\n-    jint fd = fdval(env, fdo);\n-    closeFileDescriptor(env, fd);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_preClose0(JNIEnv *env, jclass clazz, jobject fdo)\n-{\n-    jint fd = fdval(env, fdo);\n-    if (preCloseFD >= 0) {\n-        if (dup2(preCloseFD, fd) < 0)\n-            JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_dup0(JNIEnv *env, jobject this, jobject fdo1, jobject fdo2)\n-{\n-    if (dup2(fdval(env, fdo1), fdval(env, fdo2)) < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_closeIntFD(JNIEnv *env, jclass clazz, jint fd)\n-{\n-    closeFileDescriptor(env, fd);\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_canTransferToFromOverlappedMap0(JNIEnv *env, jclass clazz)\n-{\n-#ifdef MACOSX\n-    return JNI_FALSE;\n-#else\n-    return JNI_TRUE;\n-#endif\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_setDirect0(JNIEnv *env, jclass clazz,\n-                                           jobject fdo)\n-{\n-    jint fd = fdval(env, fdo);\n-    jint result;\n-#ifdef MACOSX\n-    struct statvfs file_stat;\n-#else\n-    struct statvfs64 file_stat;\n-#endif\n-\n-#if defined(O_DIRECT) || defined(F_NOCACHE) || defined(DIRECTIO_ON)\n-#ifdef O_DIRECT\n-    jint orig_flag;\n-    orig_flag = fcntl(fd, F_GETFL);\n-    if (orig_flag == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return -1;\n-    }\n-    result = fcntl(fd, F_SETFL, orig_flag | O_DIRECT);\n-    if (result == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return result;\n-    }\n-#elif defined(F_NOCACHE)\n-    result = fcntl(fd, F_NOCACHE, 1);\n-    if (result == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return result;\n-    }\n-#elif defined(DIRECTIO_ON)\n-    result = directio(fd, DIRECTIO_ON);\n-    if (result == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return result;\n-    }\n-#endif\n-#ifdef MACOSX\n-    result = fstatvfs(fd, &file_stat);\n-#else\n-    result = fstatvfs64(fd, &file_stat);\n-#endif\n-    if(result == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return result;\n-    } else {\n-        result = (int)file_stat.f_frsize;\n-    }\n-#else\n-    result = -1;\n-#endif\n-    return result;\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":0,"deletions":404,"binary":false,"changes":404,"status":"deleted"},{"patch":"@@ -0,0 +1,437 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/mman.h>\n+#include <sys\/uio.h>\n+#include <sys\/stat.h>\n+#include <sys\/statvfs.h>\n+\n+#if defined(_ALLBSD_SOURCE)\n+#define lseek64 lseek\n+#define stat64 stat\n+#define flock64 flock\n+#define off64_t off_t\n+#define F_SETLKW64 F_SETLKW\n+#define F_SETLK64 F_SETLK\n+#define pread64 pread\n+#define pwrite64 pwrite\n+#define ftruncate64 ftruncate\n+#define fstat64 fstat\n+#define fdatasync fsync\n+#define mmap64 mmap\n+#define statvfs64 statvfs\n+#define fstatvfs64 fstatvfs\n+#endif\n+\n+#include \"jni.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"sun_nio_ch_UnixFileDispatcherImpl.h\"\n+#include \"java_lang_Long.h\"\n+#include <assert.h>\n+\n+static int preCloseFD = -1;     \/* File descriptor to which we dup other fd's\n+                                   before closing them for real *\/\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_init(JNIEnv *env, jclass cl)\n+{\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n+        return;\n+    }\n+    preCloseFD = sp[0];\n+    close(sp[1]);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_read0(JNIEnv *env, jclass clazz,\n+                             jobject fdo, jlong address, jint len)\n+{\n+    jint fd = fdval(env, fdo);\n+    void *buf = (void *)jlong_to_ptr(address);\n+\n+    return convertReturnVal(env, read(fd, buf, len), JNI_TRUE);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_pread0(JNIEnv *env, jclass clazz, jobject fdo,\n+                            jlong address, jint len, jlong offset)\n+{\n+    jint fd = fdval(env, fdo);\n+    void *buf = (void *)jlong_to_ptr(address);\n+\n+    return convertReturnVal(env, pread64(fd, buf, len, offset), JNI_TRUE);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_readv0(JNIEnv *env, jclass clazz,\n+                              jobject fdo, jlong address, jint len)\n+{\n+    jint fd = fdval(env, fdo);\n+    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);\n+    return convertLongReturnVal(env, readv(fd, iov, len), JNI_TRUE);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_write0(JNIEnv *env, jclass clazz,\n+                              jobject fdo, jlong address, jint len)\n+{\n+    jint fd = fdval(env, fdo);\n+    void *buf = (void *)jlong_to_ptr(address);\n+\n+    return convertReturnVal(env, write(fd, buf, len), JNI_FALSE);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_pwrite0(JNIEnv *env, jclass clazz, jobject fdo,\n+                            jlong address, jint len, jlong offset)\n+{\n+    jint fd = fdval(env, fdo);\n+    void *buf = (void *)jlong_to_ptr(address);\n+\n+    return convertReturnVal(env, pwrite64(fd, buf, len, offset), JNI_FALSE);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_writev0(JNIEnv *env, jclass clazz,\n+                                       jobject fdo, jlong address, jint len)\n+{\n+    jint fd = fdval(env, fdo);\n+    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);\n+    return convertLongReturnVal(env, writev(fd, iov, len), JNI_FALSE);\n+}\n+\n+static jlong\n+handle(JNIEnv *env, jlong rv, char *msg)\n+{\n+    if (rv >= 0)\n+        return rv;\n+    if (errno == EINTR)\n+        return IOS_INTERRUPTED;\n+    JNU_ThrowIOExceptionWithLastError(env, msg);\n+    return IOS_THROWN;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_seek0(JNIEnv *env, jclass clazz,\n+                                         jobject fdo, jlong offset)\n+{\n+    jint fd = fdval(env, fdo);\n+    off64_t result;\n+    if (offset < 0) {\n+        result = lseek64(fd, 0, SEEK_CUR);\n+    } else {\n+        result = lseek64(fd, offset, SEEK_SET);\n+    }\n+    return handle(env, (jlong)result, \"lseek64 failed\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_force0(JNIEnv *env, jobject this,\n+                                          jobject fdo, jboolean md)\n+{\n+    jint fd = fdval(env, fdo);\n+    int result = 0;\n+\n+    if (md == JNI_FALSE) {\n+        result = fdatasync(fd);\n+    } else {\n+        result = fsync(fd);\n+    }\n+\n+    return handle(env, result, \"Force failed\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_truncate0(JNIEnv *env, jobject this,\n+                                             jobject fdo, jlong size)\n+{\n+    return handle(env,\n+                  ftruncate64(fdval(env, fdo), size),\n+                  \"Truncation failed\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_size0(JNIEnv *env, jobject this, jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    struct stat64 fbuf;\n+\n+    if (fstat64(fd, &fbuf) < 0)\n+        return handle(env, -1, \"Size failed\");\n+\n+#ifdef BLKGETSIZE64\n+    if (S_ISBLK(fbuf.st_mode)) {\n+        uint64_t size;\n+        if (ioctl(fd, BLKGETSIZE64, &size) < 0)\n+            return handle(env, -1, \"Size failed\");\n+        return (jlong)size;\n+    }\n+#endif\n+\n+    return fbuf.st_size;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_lock0(JNIEnv *env, jobject this, jobject fdo,\n+                                      jboolean block, jlong pos, jlong size,\n+                                      jboolean shared)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint lockResult = 0;\n+    int cmd = 0;\n+    struct flock64 fl;\n+\n+    fl.l_whence = SEEK_SET;\n+    if (size == (jlong)java_lang_Long_MAX_VALUE) {\n+        fl.l_len = (off64_t)0;\n+    } else {\n+        fl.l_len = (off64_t)size;\n+    }\n+    fl.l_start = (off64_t)pos;\n+    if (shared == JNI_TRUE) {\n+        fl.l_type = F_RDLCK;\n+    } else {\n+        fl.l_type = F_WRLCK;\n+    }\n+    if (block == JNI_TRUE) {\n+        cmd = F_SETLKW64;\n+    } else {\n+        cmd = F_SETLK64;\n+    }\n+    lockResult = fcntl(fd, cmd, &fl);\n+    if (lockResult < 0) {\n+        if ((cmd == F_SETLK64) && (errno == EAGAIN || errno == EACCES))\n+            return sun_nio_ch_UnixFileDispatcherImpl_NO_LOCK;\n+        if (errno == EINTR)\n+            return sun_nio_ch_UnixFileDispatcherImpl_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Lock failed\");\n+    }\n+    return 0;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_release0(JNIEnv *env, jobject this,\n+                                         jobject fdo, jlong pos, jlong size)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint lockResult = 0;\n+    struct flock64 fl;\n+    int cmd = F_SETLK64;\n+\n+    fl.l_whence = SEEK_SET;\n+    if (size == (jlong)java_lang_Long_MAX_VALUE) {\n+        fl.l_len = (off64_t)0;\n+    } else {\n+        fl.l_len = (off64_t)size;\n+    }\n+    fl.l_start = (off64_t)pos;\n+    fl.l_type = F_UNLCK;\n+    lockResult = fcntl(fd, cmd, &fl);\n+    if (lockResult < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Release failed\");\n+    }\n+}\n+\n+\n+static void closeFileDescriptor(JNIEnv *env, int fd) {\n+    if (fd != -1) {\n+        int result = close(fd);\n+        if (result < 0)\n+            JNU_ThrowIOExceptionWithLastError(env, \"Close failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_close0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    closeFileDescriptor(env, fd);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_preClose0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    if (preCloseFD >= 0) {\n+        if (dup2(preCloseFD, fd) < 0)\n+            JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_dup0(JNIEnv *env, jobject this, jobject fdo1, jobject fdo2)\n+{\n+    if (dup2(fdval(env, fdo1), fdval(env, fdo2)) < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_closeIntFD(JNIEnv *env, jclass clazz, jint fd)\n+{\n+    closeFileDescriptor(env, fd);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_allocationGranularity0(JNIEnv *env, jclass klass)\n+{\n+    jlong pageSize = sysconf(_SC_PAGESIZE);\n+    return pageSize;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_map0(JNIEnv *env, jclass klass, jobject fdo,\n+                                        jint prot, jlong off, jlong len,\n+                                        jboolean map_sync)\n+{\n+    void *mapAddress = 0;\n+    jint fd = fdval(env, fdo);\n+    int protections = 0;\n+    int flags = 0;\n+\n+    \/\/ should never be called with map_sync and prot == PRIVATE\n+    assert((prot != sun_nio_ch_UnixFileDispatcherImpl_MAP_PV) || !map_sync);\n+\n+    if (prot == sun_nio_ch_UnixFileDispatcherImpl_MAP_RO) {\n+        protections = PROT_READ;\n+        flags = MAP_SHARED;\n+    } else if (prot == sun_nio_ch_UnixFileDispatcherImpl_MAP_RW) {\n+        protections = PROT_WRITE | PROT_READ;\n+        flags = MAP_SHARED;\n+    } else if (prot == sun_nio_ch_UnixFileDispatcherImpl_MAP_PV) {\n+        protections =  PROT_WRITE | PROT_READ;\n+        flags = MAP_PRIVATE;\n+    }\n+\n+    \/\/ if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is\n+    \/\/ best to define them here. This ensures the code compiles on old\n+    \/\/ OS releases which do not provide the relevant headers. If run\n+    \/\/ on the same machine then it will work if the kernel contains\n+    \/\/ the necessary support otherwise mmap should fail with an\n+    \/\/ invalid argument error\n+\n+#ifndef MAP_SYNC\n+#define MAP_SYNC 0x80000\n+#endif\n+#ifndef MAP_SHARED_VALIDATE\n+#define MAP_SHARED_VALIDATE 0x03\n+#endif\n+\n+    if (map_sync) {\n+        \/\/ ensure\n+        \/\/  1) this is Linux on AArch64, x86_64, or PPC64 LE\n+        \/\/  2) the mmap APIs are available at compile time\n+#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) && defined(_LP64)) || defined(ppc64le))\n+        \/\/ TODO - implement for solaris\/AIX\/BSD\/WINDOWS and for 32 bit\n+        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n+        return IOS_THROWN;\n+#else\n+        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;\n+#endif\n+    }\n+\n+    mapAddress = mmap64(\n+        0,                    \/* Let OS decide location *\/\n+        len,                  \/* Number of bytes to map *\/\n+        protections,          \/* File permissions *\/\n+        flags,                \/* Changes are shared *\/\n+        fd,                   \/* File descriptor of mapped file *\/\n+        off);                 \/* Offset into file *\/\n+\n+    if (mapAddress == MAP_FAILED) {\n+        if (map_sync && errno == ENOTSUP) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"map with mode MAP_SYNC unsupported\");\n+            return IOS_THROWN;\n+        }\n+\n+        if (errno == ENOMEM) {\n+            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n+            return IOS_THROWN;\n+        }\n+        return handle(env, -1, \"Map failed\");\n+    }\n+\n+    return ((jlong) (unsigned long) mapAddress);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_unmap0(JNIEnv *env, jclass klass,\n+                                          jlong address, jlong len)\n+{\n+    void *a = (void *)jlong_to_ptr(address);\n+    return handle(env,\n+                  munmap(a, (size_t)len),\n+                  \"Unmap failed\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_setDirect0(JNIEnv *env, jclass clazz,\n+                                              jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint result;\n+    struct statvfs64 file_stat;\n+\n+#if defined(O_DIRECT) || defined(F_NOCACHE) || defined(DIRECTIO_ON)\n+#ifdef O_DIRECT\n+    jint orig_flag;\n+    orig_flag = fcntl(fd, F_GETFL);\n+    if (orig_flag == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return -1;\n+    }\n+    result = fcntl(fd, F_SETFL, orig_flag | O_DIRECT);\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return result;\n+    }\n+#elif defined(F_NOCACHE)\n+    result = fcntl(fd, F_NOCACHE, 1);\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return result;\n+    }\n+#elif defined(DIRECTIO_ON)\n+    result = directio(fd, DIRECTIO_ON);\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return result;\n+    }\n+#endif\n+    result = fstatvfs64(fd, &file_stat);\n+    if(result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return result;\n+    } else {\n+        result = (int)file_stat.f_frsize;\n+    }\n+#else\n+    result = -1;\n+#endif\n+    return result;\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixFileDispatcherImpl.c","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.File;\n@@ -30,1 +31,1 @@\n-import jdk.internal.access.SharedSecrets;\n+import java.nio.CharBuffer;\n@@ -32,0 +33,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -33,2 +35,0 @@\n-import java.io.File;\n-import java.nio.CharBuffer;\n@@ -37,0 +37,4 @@\n+    private static final int MAP_INVALID = -1;\n+    private static final int MAP_RO = 0;\n+    private static final int MAP_RW = 1;\n+    private static final int MAP_PV = 2;\n@@ -38,2 +42,2 @@\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-        SharedSecrets.getJavaIOFileDescriptorAccess();\n+    private static final long ALLOCATION_GRANULARITY;\n+    private static final int  MAX_DIRECT_TRANSFER_SIZE;\n@@ -42,1 +46,4 @@\n-    private static final boolean fastFileTransfer;\n+    private static final boolean FAST_FILE_TRANSFER;\n+\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+        SharedSecrets.getJavaIOFileDescriptorAccess();\n@@ -121,1 +128,1 @@\n-        return fastFileTransfer && sc.isBlocking();\n+        return FAST_FILE_TRANSFER && sc.isBlocking();\n@@ -132,0 +139,30 @@\n+\n+    long allocationGranularity() {\n+        return ALLOCATION_GRANULARITY;\n+    }\n+\n+    long map(FileDescriptor fd, int prot, long position, long length,\n+             boolean isSync)\n+        throws IOException\n+    {\n+        return map0(fd, prot, position, length, isSync);\n+    }\n+\n+    int unmap(long address, long length) {\n+        return unmap0(address, length);\n+    }\n+\n+    int maxDirectTransferSize() {\n+        return MAX_DIRECT_TRANSFER_SIZE;\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                      long position, long count, boolean append) {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n@@ -154,1 +191,3 @@\n-        fastFileTransfer = isFastFileTransferRequested();\n+        FAST_FILE_TRANSFER       = isFastFileTransferRequested();\n+        ALLOCATION_GRANULARITY   = allocationGranularity0();\n+        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n@@ -197,0 +236,14 @@\n+    static native long allocationGranularity0();\n+\n+    static native long map0(FileDescriptor fd, int prot, long position,\n+                            long length, boolean isSync)\n+        throws IOException;\n+\n+    static native int unmap0(long address, long length);\n+\n+    static native int maxDirectTransferSize0();\n+\n+    static native long transferTo0(FileDescriptor src, long position,\n+                                   long count, FileDescriptor dst,\n+                                   boolean append);\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":62,"deletions":9,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -196,6 +196,0 @@\n-void\n-NET_ThrowCurrent(JNIEnv *env, char *msg)\n-{\n-    NET_ThrowNew(env, WSAGetLastError(), msg);\n-}\n-\n@@ -208,8 +202,0 @@\n-jfieldID\n-NET_GetFileDescriptorID(JNIEnv *env)\n-{\n-    jclass cls = (*env)->FindClass(env, \"java\/io\/FileDescriptor\");\n-    CHECK_NULL_RETURN(cls, NULL);\n-    return (*env)->GetFieldID(env, cls, \"fd\", \"I\");\n-}\n-\n@@ -475,71 +461,0 @@\n-JNIEXPORT int JNICALL\n-NET_SocketClose(int fd) {\n-    struct linger l = {0, 0};\n-    int ret = 0;\n-    int len = sizeof (l);\n-    if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&l, &len) == 0) {\n-        if (l.l_onoff == 0) {\n-            shutdown(fd, SD_SEND);\n-        }\n-    }\n-    ret = closesocket (fd);\n-    return ret;\n-}\n-\n-JNIEXPORT int JNICALL\n-NET_Timeout(int fd, long timeout) {\n-    int ret;\n-    fd_set tbl;\n-    struct timeval t;\n-    t.tv_sec = timeout \/ 1000;\n-    t.tv_usec = (timeout % 1000) * 1000;\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    ret = select (fd + 1, &tbl, 0, 0, &t);\n-    return ret;\n-}\n-\n-\n-\/*\n- * differs from NET_Timeout() as follows:\n- *\n- * If timeout = -1, it blocks forever.\n- *\n- * returns 1 or 2 depending if only one or both sockets\n- * fire at same time.\n- *\n- * *fdret is (one of) the active fds. If both sockets\n- * fire at same time, *fdret = fd always.\n- *\/\n-JNIEXPORT int JNICALL\n-NET_Timeout2(int fd, int fd1, long timeout, int *fdret) {\n-    int ret;\n-    fd_set tbl;\n-    struct timeval t, *tP = &t;\n-    if (timeout == -1) {\n-        tP = 0;\n-    } else {\n-        t.tv_sec = timeout \/ 1000;\n-        t.tv_usec = (timeout % 1000) * 1000;\n-    }\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    FD_SET(fd1, &tbl);\n-    ret = select (0, &tbl, 0, 0, tP);\n-    switch (ret) {\n-    case 0:\n-        return 0; \/* timeout *\/\n-    case 1:\n-        if (FD_ISSET (fd, &tbl)) {\n-            *fdret= fd;\n-        } else {\n-            *fdret= fd1;\n-        }\n-        return 1;\n-    case 2:\n-        *fdret= fd;\n-        return 2;\n-    }\n-    return -1;\n-}\n-\n@@ -570,189 +485,0 @@\n-\/* Macro, which cleans-up the iv6bind structure,\n- * closes the two sockets (if open),\n- * and returns SOCKET_ERROR. Used in NET_BindV6 only.\n- *\/\n-\n-#define CLOSE_SOCKETS_AND_RETURN do {   \\\n-    if (fd != -1) {                     \\\n-        closesocket (fd);               \\\n-        fd = -1;                        \\\n-    }                                   \\\n-    if (ofd != -1) {                    \\\n-        closesocket (ofd);              \\\n-        ofd = -1;                       \\\n-    }                                   \\\n-    if (close_fd != -1) {               \\\n-        closesocket (close_fd);         \\\n-        close_fd = -1;                  \\\n-    }                                   \\\n-    if (close_ofd != -1) {              \\\n-        closesocket (close_ofd);        \\\n-        close_ofd = -1;                 \\\n-    }                                   \\\n-    b->ipv4_fd = b->ipv6_fd = -1;       \\\n-    return SOCKET_ERROR;                \\\n-} while(0)\n-\n-\/*\n- * if ipv6 is available, call NET_BindV6 to bind to the required address\/port.\n- * Because the same port number may need to be reserved in both v4 and v6 space,\n- * this may require socket(s) to be re-opened. Therefore, all of this information\n- * is passed in and returned through the ipv6bind structure.\n- *\n- * If the request is to bind to a specific address, then this (by definition) means\n- * only bind in either v4 or v6, and this is just the same as normal. ie. a single\n- * call to bind() will suffice. The other socket is closed in this case.\n- *\n- * The more complicated case is when the requested address is ::0 or 0.0.0.0.\n- *\n- * Two further cases:\n- * 2. If the requested port is 0 (ie. any port) then we try to bind in v4 space\n- *    first with a wild-card port argument. We then try to bind in v6 space\n- *    using the returned port number. If this fails, we repeat the process\n- *    until a free port common to both spaces becomes available.\n- *\n- * 3. If the requested port is a specific port, then we just try to get that\n- *    port in both spaces, and if it is not free in both, then the bind fails.\n- *\n- * On failure, sockets are closed and an error returned with CLOSE_SOCKETS_AND_RETURN\n- *\/\n-\n-JNIEXPORT int JNICALL\n-NET_BindV6(struct ipv6bind *b, jboolean exclBind) {\n-    int fd=-1, ofd=-1, rv, len;\n-    \/* need to defer close until new sockets created *\/\n-    int close_fd=-1, close_ofd=-1;\n-    SOCKETADDRESS oaddr; \/* other address to bind *\/\n-    int family = b->addr->sa.sa_family;\n-    int ofamily;\n-    u_short port; \/* requested port parameter *\/\n-    u_short bound_port;\n-\n-    if (family == AF_INET && (b->addr->sa4.sin_addr.s_addr != INADDR_ANY)) {\n-        \/* bind to v4 only *\/\n-        int ret;\n-        ret = NET_WinBind((int)b->ipv4_fd, b->addr,\n-                          sizeof(SOCKETADDRESS), exclBind);\n-        if (ret == SOCKET_ERROR) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-        closesocket (b->ipv6_fd);\n-        b->ipv6_fd = -1;\n-        return 0;\n-    }\n-    if (family == AF_INET6 && (!IN6_IS_ADDR_ANY(&b->addr->sa6.sin6_addr))) {\n-        \/* bind to v6 only *\/\n-        int ret;\n-        ret = NET_WinBind((int)b->ipv6_fd, b->addr,\n-                          sizeof(SOCKETADDRESS), exclBind);\n-        if (ret == SOCKET_ERROR) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-        closesocket (b->ipv4_fd);\n-        b->ipv4_fd = -1;\n-        return 0;\n-    }\n-\n-    \/* We need to bind on both stacks, with the same port number *\/\n-\n-    memset (&oaddr, 0, sizeof(oaddr));\n-    if (family == AF_INET) {\n-        ofamily = AF_INET6;\n-        fd = (int)b->ipv4_fd;\n-        ofd = (int)b->ipv6_fd;\n-        port = (u_short)GET_PORT (b->addr);\n-        IN6ADDR_SETANY(&oaddr.sa6);\n-        oaddr.sa6.sin6_port = port;\n-    } else {\n-        ofamily = AF_INET;\n-        ofd = (int)b->ipv4_fd;\n-        fd = (int)b->ipv6_fd;\n-        port = (u_short)GET_PORT (b->addr);\n-        oaddr.sa4.sin_family = AF_INET;\n-        oaddr.sa4.sin_port = port;\n-        oaddr.sa4.sin_addr.s_addr = INADDR_ANY;\n-    }\n-\n-    rv = NET_WinBind(fd, b->addr, sizeof(SOCKETADDRESS), exclBind);\n-    if (rv == SOCKET_ERROR) {\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-\n-    \/* get the port and set it in the other address *\/\n-    len = sizeof(SOCKETADDRESS);\n-    if (getsockname(fd, (struct sockaddr *)b->addr, &len) == -1) {\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-    bound_port = GET_PORT (b->addr);\n-    SET_PORT (&oaddr, bound_port);\n-    if ((rv = NET_WinBind(ofd, &oaddr,\n-                          sizeof(SOCKETADDRESS), exclBind)) == SOCKET_ERROR) {\n-        int retries;\n-        int sotype, arglen=sizeof(sotype);\n-\n-        \/* no retries unless, the request was for any free port *\/\n-\n-        if (port != 0) {\n-            CLOSE_SOCKETS_AND_RETURN;\n-        }\n-\n-        getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen);\n-\n-#define SOCK_RETRIES 50\n-        \/* 50 is an arbitrary limit, just to ensure that this\n-         * cannot be an endless loop. Would expect socket creation to\n-         * succeed sooner.\n-         *\/\n-        for (retries = 0; retries < SOCK_RETRIES; retries ++) {\n-            int len;\n-            close_fd = fd; fd = -1;\n-            close_ofd = ofd; ofd = -1;\n-            b->ipv4_fd = SOCKET_ERROR;\n-            b->ipv6_fd = SOCKET_ERROR;\n-\n-            \/* create two new sockets *\/\n-            fd = (int)socket (family, sotype, 0);\n-            if (fd == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            ofd = (int)socket (ofamily, sotype, 0);\n-            if (ofd == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-\n-            \/* bind random port on first socket *\/\n-            SET_PORT (&oaddr, 0);\n-            rv = NET_WinBind(ofd, &oaddr, sizeof(SOCKETADDRESS), exclBind);\n-            if (rv == SOCKET_ERROR) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            \/* close the original pair of sockets before continuing *\/\n-            closesocket (close_fd);\n-            closesocket (close_ofd);\n-            close_fd = close_ofd = -1;\n-\n-            \/* bind new port on second socket *\/\n-            len = sizeof(SOCKETADDRESS);\n-            if (getsockname(ofd, &oaddr.sa, &len) == -1) {\n-                CLOSE_SOCKETS_AND_RETURN;\n-            }\n-            bound_port = GET_PORT (&oaddr);\n-            SET_PORT (b->addr, bound_port);\n-            rv = NET_WinBind(fd, b->addr, sizeof(SOCKETADDRESS), exclBind);\n-\n-            if (rv != SOCKET_ERROR) {\n-                if (family == AF_INET) {\n-                    b->ipv4_fd = fd;\n-                    b->ipv6_fd = ofd;\n-                } else {\n-                    b->ipv4_fd = ofd;\n-                    b->ipv6_fd = fd;\n-                }\n-                return 0;\n-            }\n-        }\n-        CLOSE_SOCKETS_AND_RETURN;\n-    }\n-    return 0;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":0,"deletions":274,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,0 @@\n-void NET_ThrowCurrent(JNIEnv *env, char *msg);\n-\n@@ -62,10 +60,0 @@\n-\/*\n- * passed to NET_BindV6. Both ipv4_fd and ipv6_fd must be created and unbound\n- * sockets. On return they may refer to different sockets.\n- *\/\n-struct ipv6bind {\n-    SOCKETADDRESS      *addr;\n-    SOCKET              ipv4_fd;\n-    SOCKET              ipv6_fd;\n-};\n-\n@@ -121,4 +109,0 @@\n-JNIEXPORT int JNICALL NET_SocketClose(int fd);\n-\n-JNIEXPORT int JNICALL NET_Timeout(int fd, long timeout);\n-\n@@ -130,15 +114,0 @@\n-\/*\n- * differs from NET_Timeout() as follows:\n- *\n- * If timeout = -1, it blocks forever.\n- *\n- * returns 1 or 2 depending if only one or both sockets\n- * fire at same time.\n- *\n- * *fdret is (one of) the active fds. If both sockets\n- * fire at same time, *fd == fd always.\n- *\/\n-JNIEXPORT int JNICALL NET_Timeout2(int fd, int fd1, long timeout, int *fdret);\n-\n-JNIEXPORT int JNICALL NET_BindV6(struct ipv6bind *b, jboolean exclBind);\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.h","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-#include <io.h>\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-#include \"sun_nio_ch_FileChannelImpl.h\"\n-#include \"java_lang_Integer.h\"\n-\n-#include <Mswsock.h>\n-#pragma comment(lib, \"Mswsock.lib\")\n-\n-\/**************************************************************\n- * static method to retrieve the allocation granularity\n- *\/\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_allocationGranularity0(JNIEnv *env, jclass clazz)\n-{\n-    SYSTEM_INFO si;\n-    jint align;\n-    GetSystemInfo(&si);\n-    align = si.dwAllocationGranularity;\n-    return align;\n-}\n-\n-\n-\/**************************************************************\n- * Channel\n- *\/\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this, jobject fdo,\n-                                     jint prot, jlong off, jlong len, jboolean map_sync)\n-{\n-    void *mapAddress = 0;\n-    jint lowOffset = (jint)off;\n-    jint highOffset = (jint)(off >> 32);\n-    jlong maxSize = off + len;\n-    jint lowLen = (jint)(maxSize);\n-    jint highLen = (jint)(maxSize >> 32);\n-    HANDLE fileHandle = (HANDLE)(handleval(env, fdo));\n-    HANDLE mapping;\n-    DWORD mapAccess = FILE_MAP_READ;\n-    DWORD fileProtect = PAGE_READONLY;\n-    DWORD mapError;\n-    BOOL result;\n-\n-    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {\n-        fileProtect = PAGE_READONLY;\n-        mapAccess = FILE_MAP_READ;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {\n-        fileProtect = PAGE_READWRITE;\n-        mapAccess = FILE_MAP_WRITE;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {\n-        fileProtect = PAGE_WRITECOPY;\n-        mapAccess = FILE_MAP_COPY;\n-    }\n-\n-    if (map_sync) {\n-        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n-        return IOS_THROWN;\n-    }\n-\n-    mapping = CreateFileMapping(\n-        fileHandle,      \/* Handle of file *\/\n-        NULL,            \/* Not inheritable *\/\n-        fileProtect,     \/* Read and write *\/\n-        highLen,         \/* High word of max size *\/\n-        lowLen,          \/* Low word of max size *\/\n-        NULL);           \/* No name for object *\/\n-\n-    if (mapping == NULL) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    mapAddress = MapViewOfFile(\n-        mapping,             \/* Handle of file mapping object *\/\n-        mapAccess,           \/* Read and write access *\/\n-        highOffset,          \/* High word of offset *\/\n-        lowOffset,           \/* Low word of offset *\/\n-        (SIZE_T)len);        \/* Number of bytes to map *\/\n-    mapError = GetLastError();\n-\n-    result = CloseHandle(mapping);\n-    if (result == 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    if (mapAddress == NULL) {\n-        if (mapError == ERROR_NOT_ENOUGH_MEMORY)\n-            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n-        else\n-            JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    return ptr_to_jlong(mapAddress);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_unmap0(JNIEnv *env, jobject this,\n-                                 jlong address, jlong len)\n-{\n-    BOOL result;\n-    void *a = (void *) jlong_to_ptr(address);\n-\n-    result = UnmapViewOfFile(a);\n-    if (result == 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Unmap failed\");\n-        return IOS_THROWN;\n-    }\n-    return 0;\n-}\n-\n-\/\/ Integer.MAX_VALUE - 1 is the maximum transfer size for TransmitFile()\n-#define MAX_TRANSMIT_SIZE (java_lang_Integer_MAX_VALUE - 1)\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n-                                            jobject srcFD,\n-                                            jlong position, jlong count,\n-                                            jobject dstFD, jboolean append)\n-{\n-    const int PACKET_SIZE = 524288;\n-\n-    LARGE_INTEGER where;\n-    HANDLE src = (HANDLE)(handleval(env, srcFD));\n-    SOCKET dst = (SOCKET)(fdval(env, dstFD));\n-    DWORD chunkSize = (count > MAX_TRANSMIT_SIZE) ?\n-        MAX_TRANSMIT_SIZE : (DWORD)count;\n-    BOOL result;\n-\n-    where.QuadPart = position;\n-    result = SetFilePointerEx(src, where, &where, FILE_BEGIN);\n-    if (result == 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"SetFilePointerEx failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    result = TransmitFile(\n-        dst,\n-        src,\n-        chunkSize,\n-        PACKET_SIZE,\n-        NULL,\n-        NULL,\n-        TF_USE_KERNEL_APC\n-    );\n-    if (!result) {\n-        int error = WSAGetLastError();\n-        if (WSAEINVAL == error && count >= 0) {\n-            return IOS_UNSUPPORTED_CASE;\n-        }\n-        if (WSAENOTSOCK == error) {\n-            return IOS_UNSUPPORTED_CASE;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return chunkSize;\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                              jobject srcFDO, jobject dstFDO,\n-                                              jlong position, jlong count,\n-                                              jboolean append)\n-{\n-    return IOS_UNSUPPORTED;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jobject this)\n-{\n-    return MAX_TRANSMIT_SIZE;\n-}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"sun_nio_ch_FileDispatcherImpl.h\"\n@@ -35,1 +34,2 @@\n-#include \"jlong.h\"\n+#include \"java_lang_Integer.h\"\n+#include \"sun_nio_ch_FileDispatcherImpl.h\"\n@@ -37,0 +37,2 @@\n+#include <Mswsock.h>\n+#pragma comment(lib, \"Mswsock.lib\")\n@@ -485,0 +487,159 @@\n+\/**************************************************************\n+ * static method to retrieve the allocation granularity\n+ *\/\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_allocationGranularity0(JNIEnv *env, jclass klass)\n+{\n+    SYSTEM_INFO si;\n+    jint align;\n+    GetSystemInfo(&si);\n+    align = si.dwAllocationGranularity;\n+    return align;\n+}\n+\n+\n+\/**************************************************************\n+ * Channel\n+ *\/\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_map0(JNIEnv *env, jclass klass, jobject fdo,\n+                                        jint prot, jlong off, jlong len,\n+                                        jboolean map_sync)\n+{\n+    void *mapAddress = 0;\n+    jint lowOffset = (jint)off;\n+    jint highOffset = (jint)(off >> 32);\n+    jlong maxSize = off + len;\n+    jint lowLen = (jint)(maxSize);\n+    jint highLen = (jint)(maxSize >> 32);\n+    HANDLE fileHandle = (HANDLE)(handleval(env, fdo));\n+    HANDLE mapping;\n+    DWORD mapAccess = FILE_MAP_READ;\n+    DWORD fileProtect = PAGE_READONLY;\n+    DWORD mapError;\n+    BOOL result;\n+\n+    if (prot == sun_nio_ch_FileDispatcherImpl_MAP_RO) {\n+        fileProtect = PAGE_READONLY;\n+        mapAccess = FILE_MAP_READ;\n+    } else if (prot == sun_nio_ch_FileDispatcherImpl_MAP_RW) {\n+        fileProtect = PAGE_READWRITE;\n+        mapAccess = FILE_MAP_WRITE;\n+    } else if (prot == sun_nio_ch_FileDispatcherImpl_MAP_PV) {\n+        fileProtect = PAGE_WRITECOPY;\n+        mapAccess = FILE_MAP_COPY;\n+    }\n+\n+    if (map_sync) {\n+        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n+        return IOS_THROWN;\n+    }\n+\n+    mapping = CreateFileMapping(\n+        fileHandle,      \/* Handle of file *\/\n+        NULL,            \/* Not inheritable *\/\n+        fileProtect,     \/* Read and write *\/\n+        highLen,         \/* High word of max size *\/\n+        lowLen,          \/* Low word of max size *\/\n+        NULL);           \/* No name for object *\/\n+\n+    if (mapping == NULL) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    mapAddress = MapViewOfFile(\n+        mapping,             \/* Handle of file mapping object *\/\n+        mapAccess,           \/* Read and write access *\/\n+        highOffset,          \/* High word of offset *\/\n+        lowOffset,           \/* Low word of offset *\/\n+        (SIZE_T)len);        \/* Number of bytes to map *\/\n+    mapError = GetLastError();\n+\n+    result = CloseHandle(mapping);\n+    if (result == 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    if (mapAddress == NULL) {\n+        if (mapError == ERROR_NOT_ENOUGH_MEMORY)\n+            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n+        else\n+            JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    return ptr_to_jlong(mapAddress);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_unmap0(JNIEnv *env, jclass klass,\n+                                          jlong address, jlong len)\n+{\n+    BOOL result;\n+    void *a = (void *) jlong_to_ptr(address);\n+\n+    result = UnmapViewOfFile(a);\n+    if (result == 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Unmap failed\");\n+        return IOS_THROWN;\n+    }\n+    return 0;\n+}\n+\n+\/\/ Integer.MAX_VALUE - 1 is the maximum transfer size for TransmitFile()\n+#define MAX_TRANSMIT_SIZE (java_lang_Integer_MAX_VALUE - 1)\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_maxDirectTransferSize0(JNIEnv* env, jclass klass)\n+{\n+    return MAX_TRANSMIT_SIZE;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jclass klass,\n+                                               jobject srcFD,\n+                                            jlong position, jlong count,\n+                                            jobject dstFD, jboolean append)\n+{\n+    const int PACKET_SIZE = 524288;\n+\n+    LARGE_INTEGER where;\n+    HANDLE src = (HANDLE)(handleval(env, srcFD));\n+    SOCKET dst = (SOCKET)(fdval(env, dstFD));\n+    DWORD chunkSize = (count > MAX_TRANSMIT_SIZE) ?\n+        MAX_TRANSMIT_SIZE : (DWORD)count;\n+    BOOL result;\n+\n+    where.QuadPart = position;\n+    result = SetFilePointerEx(src, where, &where, FILE_BEGIN);\n+    if (result == 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"SetFilePointerEx failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    result = TransmitFile(\n+        dst,\n+        src,\n+        chunkSize,\n+        PACKET_SIZE,\n+        NULL,\n+        NULL,\n+        TF_USE_KERNEL_APC\n+    );\n+    if (!result) {\n+        int error = WSAGetLastError();\n+        if (WSAEINVAL == error && count >= 0) {\n+            return IOS_UNSUPPORTED_CASE;\n+        }\n+        if (WSAENOTSOCK == error) {\n+            return IOS_UNSUPPORTED_CASE;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return chunkSize;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":164,"deletions":3,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,5 +170,0 @@\n-            } catch (ThreadDeath td) {\n-                \/\/XXX: if there isn't native code on the stack, the VM just\n-                \/\/kills the thread right away. Do we expect to catch it\n-                \/\/nevertheless?\n-                break;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/LWToolkit.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,4 +205,0 @@\n-        catch (ThreadDeath death) {\n-            doDispatch = false;\n-            throw death;\n-        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/EventDispatchThread.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -938,1 +938,0 @@\n-         * @throws NullPointerException {@inheritDoc}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSpinner.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -421,0 +421,1 @@\n+     * Divider sizes {@code newSize < 0} are ignored.\n@@ -427,0 +428,3 @@\n+        if (newSize < 0) {\n+            return;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSplitPane.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -201,7 +201,0 @@\n-        }\n-        catch (ThreadDeath td) {\n-            \/\/ Mark all the timers we contain as not being queued.\n-            for (DelayedTimer delayedTimer : queue) {\n-                delayedTimer.getTimer().cancelEvent();\n-            }\n-            throw td;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/TimerQueue.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,1 @@\n+     * @throws NullPointerException if {@code Component} is {@code null}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/AbstractBorder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,1 +590,1 @@\n-     * @throws NullPointerException {@inheritDoc}\n+     * @throws NullPointerException if {@code Component} is {@code null}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/TitledBorder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,0 +222,1 @@\n+     * Divider sizes {@code newSize < 0} are ignored.\n@@ -226,0 +227,3 @@\n+        if (newSize < 0) {\n+            return;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2389,5 +2389,0 @@\n-        } catch (ThreadDeath e) {\n-            errorContext();\n-            error(\"terminated\");\n-            e.printStackTrace();\n-            throw e;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/parser\/Parser.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -730,3 +730,0 @@\n-            } catch (ThreadDeath td) {\n-                XBaseWindow.ungrabInput();\n-                return;\n@@ -1997,2 +1994,0 @@\n-                } catch (ThreadDeath td) {\n-                    throw td;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XToolkit.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1391,1 +1391,0 @@\n-    int extraBottomInsets = 0;\n@@ -1403,1 +1402,1 @@\n-        m_insets.bottom = outside.bottom - inside.bottom + extraBottomInsets;\n+        m_insets.bottom = outside.bottom - inside.bottom;\n@@ -1409,0 +1408,1 @@\n+\n@@ -1416,12 +1416,5 @@\n-            LONG style = GetStyle();\n-            if (style & WS_THICKFRAME) {\n-                m_insets.left = m_insets.right =\n-                    ::GetSystemMetrics(SM_CXSIZEFRAME) + extraPaddedBorderInsets;\n-                m_insets.top = m_insets.bottom =\n-                    ::GetSystemMetrics(SM_CYSIZEFRAME) + extraPaddedBorderInsets;\n-            } else {\n-                m_insets.left = m_insets.right =\n-                    ::GetSystemMetrics(SM_CXDLGFRAME) + extraPaddedBorderInsets;\n-                m_insets.top = m_insets.bottom =\n-                    ::GetSystemMetrics(SM_CYDLGFRAME) + extraPaddedBorderInsets;\n-            }\n+            \/\/ System metrics are same for resizable & non-resizable frame.\n+            m_insets.left = m_insets.right =\n+                ::GetSystemMetrics(SM_CXFRAME) + extraPaddedBorderInsets;\n+            m_insets.top = m_insets.bottom =\n+                ::GetSystemMetrics(SM_CYFRAME) + extraPaddedBorderInsets;\n@@ -1435,1 +1428,1 @@\n-                \/* Also, 5089312: Window insets should be 0. *\/\n+            \/* Also, 5089312: Window insets should be 0. *\/\n@@ -1448,1 +1441,0 @@\n-        m_insets.bottom += extraBottomInsets;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2669,2 +2669,0 @@\n-            } catch (ThreadDeath death) {\n-                throw death;\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/LogManager.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.net.ProtocolException;\n@@ -475,0 +476,2 @@\n+        \/\/ after 101 is handled we check for other 1xx responses\n+        cf = cf.thenCompose(this::ignore1xxResponse);\n@@ -479,0 +482,50 @@\n+    \/**\n+     * Checks whether the passed Response has a status code between 102 and 199 (both inclusive).\n+     * If so, then that {@code Response} is considered intermediate informational response and is\n+     * ignored by the client. This method then creates a new {@link CompletableFuture} which\n+     * completes when a subsequent response is sent by the server. Such newly constructed\n+     * {@link CompletableFuture} will not complete till a \"final\" response (one which doesn't have\n+     * a response code between 102 and 199 inclusive) is sent by the server. The returned\n+     * {@link CompletableFuture} is thus capable of handling multiple subsequent intermediate\n+     * informational responses from the server.\n+     * <p>\n+     * If the passed Response doesn't have a status code between 102 and 199 (both inclusive) then\n+     * this method immediately returns back a completed {@link CompletableFuture} with the passed\n+     * {@code Response}.\n+     * <\/p>\n+     *\n+     * @param rsp The response\n+     * @return A {@code CompletableFuture} with the final response from the server\n+     *\/\n+    private CompletableFuture<Response> ignore1xxResponse(final Response rsp) {\n+        final int statusCode = rsp.statusCode();\n+        \/\/ we ignore any response code which is 1xx.\n+        \/\/ For 100 (with the request configured to expect-continue) and 101, we handle it\n+        \/\/ specifically as defined in the RFC-9110, outside of this method.\n+        \/\/ As noted in RFC-9110, section 15.2.1, if response code is 100 and if the request wasn't\n+        \/\/ configured with expectContinue, then we ignore the 100 response and wait for the final\n+        \/\/ response (just like any other 1xx response).\n+        \/\/ Any other response code between 102 and 199 (both inclusive) aren't specified in the\n+        \/\/ \"HTTP semantics\" RFC-9110. The spec states that these 1xx response codes are informational\n+        \/\/ and interim and the client can choose to ignore them and continue to wait for the\n+        \/\/ final response (headers)\n+        if ((statusCode >= 102 && statusCode <= 199)\n+                || (statusCode == 100 && !request.expectContinue)) {\n+            Log.logTrace(\"Ignoring (1xx informational) response code {0}\", rsp.statusCode());\n+            if (debug.on()) {\n+                debug.log(\"Ignoring (1xx informational) response code \"\n+                        + rsp.statusCode());\n+            }\n+            assert exchImpl != null : \"Illegal state - current exchange isn't set\";\n+            \/\/ ignore this Response and wait again for the subsequent response headers\n+            final CompletableFuture<Response> cf = exchImpl.getResponseAsync(parentExecutor);\n+            \/\/ we recompose the CF again into the ignore1xxResponse check\/function because\n+            \/\/ the 1xx response is allowed to be sent multiple times for a request, before\n+            \/\/ a final response arrives\n+            return cf.thenCompose(this::ignore1xxResponse);\n+        } else {\n+            \/\/ return the already completed future\n+            return MinimalFuture.completedFuture(rsp);\n+        }\n+    }\n+\n@@ -509,1 +562,24 @@\n-        return cf;\n+        \/\/ websocket requests use \"Connection: Upgrade\" and \"Upgrade: websocket\" headers.\n+        \/\/ however, the \"upgrading\" flag we maintain in this class only tracks a h2 upgrade\n+        \/\/ that we internally triggered. So it will be false in the case of websocket upgrade, hence\n+        \/\/ this additional check. If it's a websocket request we allow 101 responses and we don't\n+        \/\/ require any additional checks when a response arrives.\n+        if (request.isWebSocket()) {\n+            return cf;\n+        }\n+        \/\/ not expecting an upgrade, but if the server sends a 101 response then we fail the\n+        \/\/ request and also let the ExchangeImpl deal with it as a protocol error\n+        return cf.thenCompose(r -> {\n+            if (r.statusCode == 101) {\n+                final ProtocolException protoEx = new ProtocolException(\"Unexpected 101 \" +\n+                        \"response, when not upgrading\");\n+                assert exchImpl != null : \"Illegal state - current exchange isn't set\";\n+                try {\n+                    exchImpl.onProtocolError(protoEx);\n+                } catch (Throwable ignore){\n+                    \/\/ ignored\n+                }\n+                return MinimalFuture.failedFuture(protoEx);\n+            }\n+            return MinimalFuture.completedFuture(r);\n+        });\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":77,"deletions":1,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -219,0 +219,10 @@\n+    \/**\n+     * Invoked whenever there is a (HTTP) protocol error when dealing with the response\n+     * from the server. The implementations of {@code ExchangeImpl} are then expected to\n+     * take necessary action that is expected by the corresponding specifications whenever\n+     * a protocol error happens. For example, in HTTP\/1.1, such protocol error would result\n+     * in the connection being closed.\n+     * @param cause The cause of the protocol violation\n+     *\/\n+    abstract void onProtocolError(IOException cause);\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -505,0 +505,9 @@\n+    @Override\n+    void onProtocolError(final IOException cause) {\n+        if (debug.on()) {\n+            debug.log(\"cancelling exchange due to protocol error: %s\", cause.getMessage());\n+        }\n+        Log.logError(\"cancelling exchange due to protocol error: {0}\\n\", cause);\n+        cancelImpl(cause);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-            initialStream.sendCancelStreamFrame();\n+            initialStream.sendResetStreamFrame(ResetFrame.CANCEL);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.net.ProtocolException;\n@@ -862,0 +863,2 @@\n+            } else if (throwable instanceof ProtocolException) {\n+                throw new ProtocolException(msg);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-            else sendCancelStreamFrame();\n+            else sendResetStreamFrame(ResetFrame.CANCEL);\n@@ -1241,0 +1241,10 @@\n+    @Override\n+    void onProtocolError(final IOException cause) {\n+        if (debug.on()) {\n+            debug.log(\"cancelling exchange on stream %d due to protocol error: %s\", streamid, cause.getMessage());\n+        }\n+        Log.logError(\"cancelling exchange on stream {0} due to protocol error: {1}\\n\", streamid, cause);\n+        \/\/ send a RESET frame and close the stream\n+        cancelImpl(cause, ResetFrame.PROTOCOL_ERROR);\n+    }\n+\n@@ -1252,0 +1262,4 @@\n+        cancelImpl(e, ResetFrame.CANCEL);\n+    }\n+\n+    private void cancelImpl(final Throwable e, final int resetFrameErrCode) {\n@@ -1283,2 +1297,2 @@\n-                e = Utils.getCompletionCause(e);\n-                if (e instanceof EOFException) {\n+                final Throwable cause = Utils.getCompletionCause(e);\n+                if (cause instanceof EOFException) {\n@@ -1290,1 +1304,1 @@\n-                    sendCancelStreamFrame();\n+                    sendResetStreamFrame(resetFrameErrCode);\n@@ -1298,1 +1312,1 @@\n-    void sendCancelStreamFrame() {\n+    void sendResetStreamFrame(final int resetFrameErrCode) {\n@@ -1300,2 +1314,2 @@\n-        if (streamid > 0 && markStream(ResetFrame.CANCEL) == 0) {\n-            connection.resetStream(streamid, ResetFrame.CANCEL);\n+        if (streamid > 0 && markStream(resetFrameErrCode) == 0) {\n+            connection.resetStream(streamid, resetFrameErrCode);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -185,2 +185,1 @@\n-        \"Unlike java.lang.Thread.suspend, \"\n-        \"suspends of both the virtual machine and individual threads are \"\n+        \"Suspends of both the virtual machine and individual threads are \"\n@@ -1838,4 +1837,3 @@\n-        \"Unlike java.lang.Thread.suspend(), suspends of both \"\n-        \"the virtual machine and individual threads are counted. Before \"\n-        \"a thread will run again, it must be resumed the same number \"\n-        \"of times it has been suspended. \"\n+        \"Suspends of both the virtual machine and individual threads are \"\n+        \"counted. Before a thread will run again, it must be resumed the \"\n+        \"same number of times it has been suspended. \"\n@@ -1843,3 +1841,2 @@\n-        \"Suspending single threads with command has the same \"\n-        \"dangers java.lang.Thread.suspend(). If the suspended \"\n-        \"thread holds a monitor needed by another running thread, \"\n+        \"Suspending single threads is inherently deadlock-prone. If the \"\n+        \"suspended thread holds a monitor needed by another running thread, \"\n@@ -1850,3 +1847,1 @@\n-        \"resumed through one of the JDI resume methods mentioned above; \"\n-        \"the application in the target VM cannot resume the suspended thread \"\n-        \"through {@link java.lang.Thread#resume}. \"\n+        \"resumed through one of the JDI resume methods mentioned above. \"\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -324,1 +324,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -326,4 +325,4 @@\n-         BufferedReader bufReader = new BufferedReader(x);\n-         try {\n-             int i;\n-             while( (i = bufReader.read()) != -1 ) {\n+        BufferedReader bufReader = new BufferedReader(x);\n+        try {\n+            int i;\n+            while ((i = bufReader.read()) != -1) {\n@@ -331,2 +330,0 @@\n-                StringBuffer strBuf = new StringBuffer();\n-                strBuf.append(ch);\n@@ -334,1 +331,0 @@\n-                String str = new String(strBuf);\n@@ -337,3 +333,3 @@\n-                writeString(str.concat(strLine));\n-             }\n-         } catch(IOException ioe) {\n+                writeString(ch + strLine);\n+            }\n+        } catch (IOException ioe) {\n@@ -341,1 +337,1 @@\n-         }\n+        }\n@@ -354,1 +350,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -356,4 +351,4 @@\n-         BufferedReader bufReader = new BufferedReader(new InputStreamReader(x));\n-         try {\n-               int i;\n-               while( (i=bufReader.read()) != -1 ) {\n+        BufferedReader bufReader = new BufferedReader(new InputStreamReader(x));\n+        try {\n+            int i;\n+            while ((i = bufReader.read()) != -1) {\n@@ -362,4 +357,0 @@\n-                StringBuffer strBuf = new StringBuffer();\n-                strBuf.append(ch);\n-\n-                String str = new String(strBuf);\n@@ -367,2 +358,1 @@\n-\n-                writeString(str.concat(strLine));\n+                writeString(ch + strLine);\n@@ -370,1 +360,1 @@\n-          }catch(IOException ioe) {\n+        } catch (IOException ioe) {\n@@ -384,1 +374,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -386,4 +375,4 @@\n-         BufferedReader bufReader = new BufferedReader(new InputStreamReader(x));\n-         try {\n-               int i;\n-             while( (i=bufReader.read()) != -1 ) {\n+        BufferedReader bufReader = new BufferedReader(new InputStreamReader(x));\n+        try {\n+            int i;\n+            while ((i = bufReader.read()) != -1) {\n@@ -392,4 +381,0 @@\n-                StringBuffer strBuf = new StringBuffer();\n-                strBuf.append(ch);\n-\n-                String str = new String(strBuf);\n@@ -398,3 +383,3 @@\n-                writeString(str.concat(strLine));\n-             }\n-        } catch(IOException ioe) {\n+                writeString(ch + strLine);\n+            }\n+        } catch (IOException ioe) {\n","filename":"src\/java.sql.rowset\/share\/classes\/javax\/sql\/rowset\/serial\/SQLOutputImpl.java","additions":21,"deletions":36,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1033,1 +1033,1 @@\n-             catch (VirtualMachineError | ThreadDeath vme) {\n+             catch (VirtualMachineError vme) {\n@@ -1049,1 +1049,1 @@\n-            catch (VirtualMachineError | ThreadDeath vme) {\n+            catch (VirtualMachineError vme) {\n@@ -1065,1 +1065,1 @@\n-            catch (VirtualMachineError | ThreadDeath vme) {\n+            catch (VirtualMachineError vme) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/serialize\/DOMSerializerImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,4 +264,0 @@\n-                        if (t instanceof ThreadDeath) {\n-                            ThreadDeath td = (ThreadDeath)t;\n-                            throw td;\n-                        }\n","filename":"src\/jdk.attach\/share\/classes\/com\/sun\/tools\/attach\/spi\/AttachProvider.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,3 +78,0 @@\n-            if (t instanceof ThreadDeath) {\n-                throw (ThreadDeath)t;\n-            }\n@@ -104,3 +101,1 @@\n-                if (t instanceof ThreadDeath) {\n-                    throw (ThreadDeath)t;\n-                }\n+                \/\/ ignore\n@@ -141,4 +136,0 @@\n-            if (t instanceof ThreadDeath) {\n-                ThreadDeath td = (ThreadDeath)t;\n-                throw td;\n-            }\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotAttachProvider.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,0 +221,8 @@\n+        \/**\n+         * Used for instances of {@link SpecTree}\n+         * representing an {@code @spec} tag.\n+         *\n+         * @since 20\n+         *\/\n+        SPEC(\"spec\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTree.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -303,0 +303,16 @@\n+    }\n+\n+    \/**\n+     * Visits a {@code SpecTree} node.\n+     *\n+     * @implSpec Visits the provided {@code SpecTree} node\n+     * by calling {@code visitOther(node, p)}.\n+     *\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\n+     * @since 20\n+     *\/\n+    default R visitSpec(SpecTree node, P p) {\n+        return visitOther(node, p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTreeVisitor.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.doctree;\n+\n+import java.util.List;\n+\n+\/**\n+ * A tree node for an {@code @spec} block tag.\n+ *\n+ * <pre>\n+ *    &#064;spec url title\n+ * <\/pre>\n+ *\n+ * @since 20\n+ *\/\n+public interface SpecTree extends BlockTagTree {\n+    \/**\n+     * {@return the URL}\n+     *\/\n+    TextTree getURL();\n+\n+    \/**\n+     * {@return the title}\n+     *\/\n+    List<? extends DocTree> getTitle();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/SpecTree.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -62,0 +62,1 @@\n+import com.sun.source.doctree.SpecTree;\n@@ -339,0 +340,9 @@\n+    \/**\n+     * Creates a new {@code SpecTree} object, to represent an {@code @spec} tag.\n+     * @param url    the url\n+     * @param title  the title\n+     * @return a {@code SpecTree} object\n+     * @since 20\n+     *\/\n+    SpecTree newSpecTree(TextTree url, List<? extends DocTree> title);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -518,0 +518,17 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p    {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 20\n+     *\/\n+    @Override\n+    public R visitSpec(SpecTree node, P p) {\n+        R r = scan(node.getURL(), p);\n+        r = scanAndReduce(node.getTitle(), p, r);\n+        return r;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeScanner.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -466,0 +466,17 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p    {@inheritDoc}\n+     *\n+     * @return  the result of {@code defaultAction}\n+     *\n+     * @since 20\n+     *\/\n+    @Override\n+    public R visitSpec(SpecTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleDocTreeVisitor.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-        \/** The number of scopes that share this scope's hash table.\n+        \/** true if this scope's hash table is shared with a nested scope.\n@@ -277,1 +277,1 @@\n-        private int shared;\n+        private boolean shared;\n@@ -342,0 +342,2 @@\n+            Assert.check(!shared);\n+\n@@ -343,1 +345,1 @@\n-            shared++;\n+            shared = true;\n@@ -354,1 +356,1 @@\n-            if (shared > 0) {\n+            if (shared) {\n@@ -386,1 +388,1 @@\n-            Assert.check(shared == 0);\n+            Assert.check(!shared);\n@@ -395,2 +397,2 @@\n-            Assert.check(next.shared > 0);\n-            next.shared--;\n+            Assert.check(next.shared);\n+            next.shared = false;\n@@ -406,1 +408,1 @@\n-            Assert.check(shared == 0);\n+            Assert.check(!shared);\n@@ -411,1 +413,1 @@\n-                    Assert.check(s == this || s.shared != 0);\n+                    Assert.check(s == this || s.shared);\n@@ -432,1 +434,1 @@\n-            Assert.check(shared == 0);\n+            Assert.check(!shared);\n@@ -452,1 +454,1 @@\n-            Assert.check(shared == 0);\n+            Assert.check(!shared);\n@@ -490,1 +492,1 @@\n-            Assert.check(shared == 0);\n+            Assert.check(!shared);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Scope.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1780,1 +1780,1 @@\n-                            Env<AttrContext> bodyEnv = bindingEnv(env, matchBindings.bindingsWhenTrue);\n+                            Env<AttrContext> bodyEnv = bindingEnv(switchEnv, matchBindings.bindingsWhenTrue);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1554,0 +1554,18 @@\n+            \/\/ @spec url label\n+            new TagParser(TagParser.Kind.BLOCK, DCTree.Kind.SPEC) {\n+                @Override\n+                public DCTree parse(int pos) throws ParseException {\n+                    skipWhitespace();\n+                    DCText url = inlineWord();\n+                    if (url == null || url.isBlank()) {\n+                        throw new ParseException(\"dc.no.url\");\n+                    }\n+                    skipWhitespace();\n+                    List<DCTree> title = blockContent();\n+                    if (title.isEmpty() || DCTree.isBlank(title)) {\n+                        throw new ParseException(\"dc.no.title\");\n+                    }\n+                    return m.at(pos).newSpecTree(url, title);\n+                }\n+            },\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3334,0 +3334,6 @@\n+compiler.err.dc.no.url=\\\n+    no URL\n+\n+compiler.err.dc.no.title=\\\n+    no title\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import com.sun.tools.javac.util.Position;\n@@ -228,0 +227,8 @@\n+    public boolean isBlank() {\n+        return false;\n+    }\n+\n+    public static boolean isBlank(List<? extends DCTree> list) {\n+        return list.stream().allMatch(DCTree::isBlank);\n+    }\n+\n@@ -1083,0 +1090,35 @@\n+    public static class DCSpec extends DCBlockTag implements SpecTree {\n+        public final DCText uri;\n+        public final List<DCTree> title;\n+\n+        DCSpec(DCText uri, List<DCTree> title) {\n+            this.uri = uri;\n+            this.title = title;\n+        }\n+\n+        @Override\n+        public String getTagName() {\n+            return \"spec\";\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.SPEC;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(DocTreeVisitor<R, D> v, D d) {\n+            return v.visitSpec(this, d);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public TextTree getURL() {\n+            return uri;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<? extends DocTree> getTitle() {\n+            return title;\n+        }\n+    }\n+\n@@ -1173,0 +1215,5 @@\n+        @Override\n+        public boolean isBlank() {\n+            return text.isBlank();\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -507,0 +507,14 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public Void visitSpec(SpecTree node, Void p) {\n+        try {\n+            printTagName(node);\n+            print(\" \");\n+            print(node.getURL());\n+            print(\" \");\n+            print(node.getTitle());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocPretty.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+import com.sun.tools.javac.tree.DCTree.DCSpec;\n@@ -92,1 +93,0 @@\n-import com.sun.tools.javac.util.DiagnosticSource;\n@@ -94,1 +94,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -127,1 +126,1 @@\n-    public int pos = Position.NOPOS;\n+    public int pos;\n@@ -241,1 +240,1 @@\n-        DCDocComment tree = new DCDocComment(c, fBody, pair.fst, pair.snd, cast(tags),\n+        return new DCDocComment(c, fBody, pair.fst, pair.snd, cast(tags),\n@@ -243,1 +242,0 @@\n-        return tree;\n@@ -424,0 +422,7 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DCSpec newSpecTree(TextTree url, List<? extends DocTree> title) {\n+        DCSpec tree = new DCSpec((DCText) url, cast(title));\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+    public final Content externalSpecifications;\n@@ -172,0 +173,1 @@\n+    public final Content specificationLabel;\n@@ -242,0 +244,1 @@\n+        externalSpecifications = getContent(\"doclet.External_Specifications\");\n@@ -316,0 +319,1 @@\n+        specificationLabel = getContent(\"doclet.Specification\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Contents.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.text.Collator;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.WeakHashMap;\n+import java.util.function.Predicate;\n+import javax.lang.model.element.Element;\n+import javax.tools.Diagnostic;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SpecTree;\n+import com.sun.source.util.DocTreePath;\n+import com.sun.source.util.TreePath;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.OverviewElement;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+\n+\/**\n+ * Generates the file with the summary of all the references to external specifications.\n+ *\/\n+public class ExternalSpecsWriter extends HtmlDocletWriter {\n+\n+    private final Navigation navBar;\n+\n+    \/**\n+     * Cached contents of {@code <title>...<\/title>} tags of the HTML pages.\n+     *\/\n+    final Map<Element, String> titles = new WeakHashMap<>();\n+\n+    \/**\n+     * Constructs ExternalSpecsWriter object.\n+     *\n+     * @param configuration The current configuration\n+     * @param filename Path to the file which is getting generated.\n+     *\/\n+    public ExternalSpecsWriter(HtmlConfiguration configuration, DocPath filename) {\n+        super(configuration, filename);\n+        this.navBar = new Navigation(null, configuration, PageMode.EXTERNAL_SPECS, path);\n+    }\n+\n+    public static void generate(HtmlConfiguration configuration) throws DocFileIOException {\n+        generate(configuration, DocPaths.EXTERNAL_SPECS);\n+    }\n+\n+    private static void generate(HtmlConfiguration configuration, DocPath fileName) throws DocFileIOException {\n+        boolean hasExternalSpecs = configuration.mainIndex != null\n+                && !configuration.mainIndex.getItems(DocTree.Kind.SPEC).isEmpty();\n+        if (!hasExternalSpecs) {\n+            return;\n+        }\n+        ExternalSpecsWriter w = new ExternalSpecsWriter(configuration, fileName);\n+        w.buildExternalSpecsPage();\n+        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.EXTERNAL_SPECS);\n+    }\n+\n+    \/**\n+     * Prints all the \"external specs\" to the file.\n+     *\/\n+    protected void buildExternalSpecsPage() throws DocFileIOException {\n+        checkUniqueItems();\n+\n+        String title = resources.getText(\"doclet.External_Specifications\");\n+        HtmlTree body = getBody(getWindowTitle(title));\n+        Content mainContent = new ContentBuilder();\n+        addExternalSpecs(mainContent);\n+        body.add(new BodyContents()\n+                .setHeader(getHeader(PageMode.EXTERNAL_SPECS))\n+                .addMainContent(HtmlTree.DIV(HtmlStyle.header,\n+                        HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING,\n+                                contents.getContent(\"doclet.External_Specifications\"))))\n+                .addMainContent(mainContent)\n+                .setFooter(getFooter()));\n+        printHtmlDocument(null, \"external specifications\", body);\n+\n+        if (configuration.mainIndex != null) {\n+            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS, title, path));\n+        }\n+    }\n+\n+    protected void checkUniqueItems() {\n+        Map<String, Map<String, List<IndexItem>>> itemsByURL = new HashMap<>();\n+        Map<String, Map<String, List<IndexItem>>> itemsByTitle = new HashMap<>();\n+        for (IndexItem ii : configuration.mainIndex.getItems(DocTree.Kind.SPEC)) {\n+            if (ii.getDocTree() instanceof SpecTree st) {\n+                String url = st.getURL().toString();\n+                String title = st.getTitle().toString();\n+                itemsByTitle\n+                        .computeIfAbsent(title, l -> new HashMap<>())\n+                        .computeIfAbsent(url, u -> new ArrayList<>())\n+                        .add(ii);\n+                itemsByURL\n+                        .computeIfAbsent(url, u -> new HashMap<>())\n+                        .computeIfAbsent(title, l -> new ArrayList<>())\n+                        .add(ii);\n+            }\n+        }\n+\n+        itemsByURL.forEach((url, title) -> {\n+            if (title.size() > 1) {\n+                messages.error(\"doclet.extSpec.spec.has.multiple.titles\", url,\n+                        title.values().stream().distinct().count());\n+                title.forEach((t, list) ->\n+                        list.forEach(ii ->\n+                                report(ii, \"doclet.extSpec.url.title\", url, t)));\n+            }\n+        });\n+\n+        itemsByTitle.forEach((title, urls) -> {\n+            if (urls.size() > 1) {\n+                messages.error(\"doclet.extSpec.title.for.multiple.specs\", title,\n+                        urls.values().stream().distinct().count());\n+                urls.forEach((u, list) ->\n+                        list.forEach(ii ->\n+                                report(ii, \"doclet.extSpec.title.url\", title, u)));\n+            }\n+        });\n+    }\n+\n+    private void report(IndexItem ii, String key, Object... args) {\n+        String message = messages.getResources().getText(key, args);\n+        Element e = ii.getElement();\n+        if (e == null) {\n+            configuration.reporter.print(Diagnostic.Kind.NOTE, message);\n+        } else {\n+            TreePath tp = utils.getTreePath(e);\n+            DocTreePath dtp = new DocTreePath(new DocTreePath(tp, utils.getDocCommentTree(e)), ii.getDocTree());\n+            configuration.reporter.print(Diagnostic.Kind.NOTE, dtp, message);\n+        }\n+    }\n+\n+    \/**\n+     * Adds all the references to external specifications to the content tree.\n+     *\n+     * @param content HtmlTree content to which the links will be added\n+     *\/\n+    protected void addExternalSpecs(Content content) {\n+        final int USE_DETAILS_THRESHHOLD = 20;\n+        Map<String, List<IndexItem>> searchIndexMap = groupExternalSpecs();\n+        Table table = new Table(HtmlStyle.summaryTable)\n+                .setCaption(contents.externalSpecifications)\n+                .setHeader(new TableHeader(contents.specificationLabel, contents.referencedIn))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n+        for (List<IndexItem> searchIndexItems : searchIndexMap.values()) {\n+            Content specName = createSpecLink(searchIndexItems.get(0));\n+            Content referencesList = HtmlTree.UL(HtmlStyle.refList, searchIndexItems,\n+                    item -> HtmlTree.LI(createLink(item)));\n+            Content references = searchIndexItems.size() < USE_DETAILS_THRESHHOLD\n+                    ? referencesList\n+                    : HtmlTree.DETAILS()\n+                            .add(HtmlTree.SUMMARY(contents.getContent(\"doclet.references\",\n+                                    String.valueOf(searchIndexItems.size()))))\n+                            .add(referencesList);\n+            table.addRow(specName, references);\n+        }\n+        content.add(table);\n+    }\n+\n+    private Map<String, List<IndexItem>> groupExternalSpecs() {\n+        return configuration.mainIndex.getItems(DocTree.Kind.SPEC).stream()\n+                .collect(groupingBy(IndexItem::getLabel, () -> new TreeMap<>(getTitleComparator()), toList()));\n+    }\n+\n+    Comparator<String> getTitleComparator() {\n+        Collator collator = Collator.getInstance();\n+        return new Comparator<>() {\n+            @Override\n+            public int compare(String s1, String s2) {\n+                int i1 = 0;\n+                int i2 = 0;\n+                while (i1 < s1.length() && i2 < s2.length()) {\n+                    int j1 = find(s1, i1, Character::isDigit);\n+                    int j2 = find(s2, i2, Character::isDigit);\n+                    int cmp = collator.compare(s1.substring(i1, j1), s2.substring(i2, j2));\n+                    if (cmp != 0) {\n+                        return cmp;\n+                    }\n+                    if (j1 == s1.length() || j2 == s2.length()) {\n+                        i1 = j1;\n+                        i2 = j2;\n+                        break;\n+                    }\n+                    int k1 = find(s1, j1, ch -> !Character.isDigit(ch));\n+                    int k2 = find(s2, j2, ch -> !Character.isDigit(ch));\n+                    cmp = Integer.compare(Integer.parseInt(s1.substring(j1, k1)), Integer.parseInt(s2.substring(j2, k2)));\n+                    if (cmp != 0) {\n+                        return cmp;\n+                    }\n+                    i1 = k1;\n+                    i2 = k2;\n+                }\n+                return i1 < s1.length() ? 1 : i2 < s2.length() ? -1 : 0;\n+            }\n+        };\n+    }\n+\n+    private static int find(String s, int start, Predicate<Character> p) {\n+        int i = start;\n+        while (i < s.length() && !p.test(s.charAt(i))) {\n+            i++;\n+        }\n+        return i;\n+    }\n+\n+    private Content createLink(IndexItem i) {\n+        assert i.getDocTree().getKind() == DocTree.Kind.SPEC : i;\n+        Element element = i.getElement();\n+        if (element instanceof OverviewElement) {\n+            return links.createLink(pathToRoot.resolve(i.getUrl()),\n+                    resources.getText(\"doclet.Overview\"));\n+        } else if (element instanceof DocletElement) {\n+            DocletElement e = (DocletElement) element;\n+            \/\/ Implementations of DocletElement do not override equals and\n+            \/\/ hashCode; putting instances of DocletElement in a map is not\n+            \/\/ incorrect, but might well be inefficient\n+            String t = titles.computeIfAbsent(element, utils::getHTMLTitle);\n+            if (t.isBlank()) {\n+                \/\/ The user should probably be notified (a warning?) that this\n+                \/\/ file does not have a title\n+                Path p = Path.of(e.getFileObject().toUri());\n+                t = p.getFileName().toString();\n+            }\n+            ContentBuilder b = new ContentBuilder();\n+            b.add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")));\n+            \/\/ non-program elements should be displayed using a normal font\n+            b.add(t);\n+            return links.createLink(pathToRoot.resolve(i.getUrl()), b);\n+        } else {\n+            \/\/ program elements should be displayed using a code font\n+            Content link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n+            return HtmlTree.CODE(link);\n+        }\n+    }\n+\n+    private Content createSpecLink(IndexItem i) {\n+        assert i.getDocTree().getKind() == DocTree.Kind.SPEC : i;\n+        SpecTree specTree = (SpecTree) i.getDocTree();\n+\n+        Content title = Text.of(i.getLabel());\n+\n+        URI specURI;\n+        try {\n+            specURI = new URI(specTree.getURL().getBody());\n+        } catch (URISyntaxException e) {\n+            \/\/ should not happen: items with bad URIs should not make it into the index\n+            return title;\n+        }\n+\n+        return HtmlTree.A(resolveExternalSpecURI(specURI), title);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ExternalSpecsWriter.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -393,0 +393,9 @@\n+        \/\/ External Specification\n+        if (configuration.conditionalPages.contains(HtmlConfiguration.ConditionalPage.EXTERNAL_SPECS)) {\n+            section = newHelpSection(contents.externalSpecifications, PageMode.EXTERNAL_SPECS, subTOC);\n+            Content extSpecsBody = getContent(\"doclet.help.externalSpecifications.body\",\n+                    links.createLink(DocPaths.EXTERNAL_SPECS, resources.getText(\"doclet.External_Specifications\")));\n+            section.add(HtmlTree.P(extSpecsBody));\n+            pageKindsSection.add(section);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HelpWriter.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-        CONSTANT_VALUES, DEPRECATED, PREVIEW, SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n+        CONSTANT_VALUES, DEPRECATED, EXTERNAL_SPECS, PREVIEW, SERIALIZED_FORM, SYSTEM_PROPERTIES, NEW\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,8 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n@@ -259,0 +266,1 @@\n+            ExternalSpecsWriter.generate(configuration);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.net.URI;\n@@ -2179,0 +2180,15 @@\n+\n+    public URI resolveExternalSpecURI(URI specURI) {\n+        if (!specURI.isAbsolute()) {\n+            URI baseURI = configuration.getOptions().specBaseURI();\n+            if (baseURI == null) {\n+                baseURI = URI.create(\"..\/specs\/\");\n+            }\n+            if (!baseURI.isAbsolute() && !pathToRoot.isEmpty()) {\n+                baseURI = URI.create(pathToRoot.getPath() + \"\/\").resolve(baseURI);\n+            }\n+            specURI = baseURI.resolve(specURI);\n+        }\n+        return specURI;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -88,0 +89,1 @@\n+        EXTERNAL_SPECS,\n@@ -319,0 +321,1 @@\n+            case EXTERNAL_SPECS:\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.net.URI;\n+import java.net.URISyntaxException;\n@@ -37,0 +39,1 @@\n+import java.util.stream.Collectors;\n@@ -57,0 +60,1 @@\n+import com.sun.source.doctree.SpecTree;\n@@ -60,0 +64,1 @@\n+import com.sun.source.doctree.TextTree;\n@@ -83,0 +88,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -403,0 +409,14 @@\n+    String textOf(List<? extends DocTree> trees) {\n+        return trees.stream()\n+                .filter(dt -> dt instanceof TextTree)\n+                .map(dt -> ((TextTree) dt).getBody().trim())\n+                .collect(Collectors.joining(\" \"));\n+    }\n+\n+    private void appendSeparatorIfNotEmpty(ContentBuilder body) {\n+        if (!body.isEmpty()) {\n+            body.add(\", \");\n+            body.add(Text.NL);\n+        }\n+    }\n+\n@@ -721,0 +741,48 @@\n+    @Override\n+    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n+        ContentBuilder body = new ContentBuilder();\n+        for (SpecTree st : specTags) {\n+            appendSeparatorIfNotEmpty(body);\n+            body.add(specTagToContent(holder, st));\n+        }\n+        if (body.isEmpty())\n+            return body;\n+\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.externalSpecifications),\n+                HtmlTree.DD(body));\n+    }\n+\n+    private Content specTagToContent(Element holder, SpecTree specTree) {\n+        String specTreeURL = specTree.getURL().getBody();\n+        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n+        Content label = htmlWriter.commentTagsToContent(holder, specTreeLabel, isFirstSentence);\n+        return getExternalSpecContent(holder, specTree, specTreeURL, textOf(specTreeLabel), label);\n+    }\n+\n+    Content getExternalSpecContent(Element holder, DocTree docTree, String url, String searchText, Content title) {\n+        URI specURI;\n+        try {\n+            \/\/ Use the canonical title of the spec if one is available\n+            specURI = new URI(url);\n+        } catch (URISyntaxException e) {\n+            CommentHelper ch = utils.getCommentHelper(holder);\n+            DocTreePath dtp = ch.getDocTreePath(docTree);\n+            htmlWriter.messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n+            specURI = null;\n+        }\n+\n+        Content titleWithAnchor = createAnchorAndSearchIndex(holder,\n+                searchText,\n+                title,\n+                resources.getText(\"doclet.External_Specification\"),\n+                docTree);\n+\n+        if (specURI == null) {\n+            return titleWithAnchor;\n+        } else {\n+            return HtmlTree.A(htmlWriter.resolveExternalSpecURI(specURI), titleWithAnchor);\n+        }\n+\n+    }\n+\n@@ -813,0 +881,4 @@\n+    public HtmlDocletWriter getHtmlWriter() {\n+        return htmlWriter;\n+    }\n+\n@@ -814,0 +886,5 @@\n+        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n+    }\n+\n+    @SuppressWarnings(\"preview\")\n+    private Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n@@ -816,1 +893,1 @@\n-            result = Text.of(tagText);\n+            result = tagContent;\n@@ -819,1 +896,1 @@\n-            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, Text.of(tagText));\n+            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":79,"deletions":2,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -746,0 +746,5 @@\n+    \/**\n+     * The class of the {@code body} element for the \"external specifications\" page.\n+     *\/\n+    externalSpecsPage,\n+\n@@ -1010,0 +1015,5 @@\n+    \/**\n+     * The class for the list of references to an external specification.\n+     *\/\n+    refList,\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -390,0 +390,9 @@\n+    \/**\n+     * Creates an HTML {@code DETAILS} element.\n+     *\n+     * @return the element\n+     *\/\n+    public static HtmlTree DETAILS() {\n+        return new HtmlTree(TagName.DETAILS);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlTree.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -163,0 +163,3 @@\n+doclet.External_Specification=External Specification\n+doclet.External_Specifications=External Specifications\n+doclet.Specification=Specification\n@@ -168,0 +171,2 @@\n+# 0: number of references (> 1)\n+doclet.references={0} references\n@@ -321,0 +326,3 @@\n+# 0: link to External Specifications page\n+doclet.help.externalSpecifications.body=\\\n+    The {0} page lists references to external specifications.\n@@ -406,0 +414,16 @@\n+# 0: URL; 1: an integer\n+doclet.extSpec.spec.has.multiple.titles=\\\n+    {1} different titles given in @spec tags for the external specification at {0}\n+\n+# 0: name; 1: an integer\n+doclet.extSpec.title.for.multiple.specs=\\\n+    The title \"{0}\" is used for {1} different external specifications in @spec tags\n+\n+# 0: name; 1: url\n+doclet.extSpec.title.url=\\\n+    title: \"{0}\", url: {1}\n+\n+# 0: url; 1: name\n+doclet.extSpec.url.title=\\\n+    url: {0}, title: \"{1}\"\n+\n@@ -666,0 +690,8 @@\n+doclet.usage.spec-base-url=\\\n+    <URL>\n+doclet.usage.spec-base-url.description=\\\n+    Specify a base URL for relative URLs in @spec tags\n+\n+doclet.Invalid_URL=\\\n+    invalid URL: {0}\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n@@ -298,0 +301,6 @@\n+    \/**\n+     * Argument for command-line option {@code --spec-base-url}.\n+     * The base URL for relative URLs in {@code @spec} tags.\n+     *\/\n+    private URI specBaseURI;\n+\n@@ -673,0 +682,20 @@\n+                new Option(resources, \"--spec-base-url\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        String arg = args.get(0);\n+                        try {\n+                            if (!arg.endsWith(\"\/\")) {\n+                                \/\/ to ensure that URI.resolve works as expected\n+                                arg += \"\/\";\n+                            }\n+                            specBaseURI = new URI(arg);\n+                            return true;\n+                        } catch (URISyntaxException e) {\n+                            config.reporter.print(ERROR,\n+                                    config.getDocResources().getText(\"doclet.Invalid_URL\",\n+                                            e.getMessage()));\n+                            return false;\n+                        }\n+                    }\n+                },\n+\n@@ -1053,0 +1082,8 @@\n+    \/**\n+     * Argument for command-line option {@code --spec-base-url}.\n+     * The base URL for relative URLs in {@code @spec} tags.\n+     *\/\n+    public URI specBaseURI() {\n+        return specBaseURI;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -368,0 +368,8 @@\n+ul.ref-list {\n+  margin-left:0;\n+  padding:0;\n+  margin:0;\n+}\n+ul.ref-list > li {\n+    list-style:none;\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/stylesheet.css","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SpecTree;\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @spec} tag.\n+ *\/\n+public class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n+\n+    public SpecTaglet() {\n+        super(DocTree.Kind.SPEC, false, EnumSet.allOf(Location.class));\n+    }\n+\n+    @Override\n+    public void inherit(Input input, DocFinder.Output output) {\n+        List<? extends SpecTree> tags = input.utils.getSpecTrees(input.element);\n+        if (!tags.isEmpty()) {\n+            CommentHelper ch =  input.utils.getCommentHelper(input.element);\n+            output.holder = input.element;\n+            output.holderTag = tags.get(0);\n+            output.inlineTags = input.isFirstSentence\n+                    ? ch.getFirstSentenceTrees(output.holderTag)\n+                    : ch.getTags(output.holderTag);\n+        }\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n+        Utils utils = writer.configuration().utils;\n+        List<? extends SpecTree> tags = utils.getSpecTrees(holder);\n+        Element e = holder;\n+        if (tags.isEmpty() && utils.isExecutableElement(holder)) {\n+            Input input = new Input(utils, holder, this);\n+            DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);\n+            if (inheritedDoc.holder != null) {\n+                tags = utils.getSpecTrees(inheritedDoc.holder);\n+                e = inheritedDoc.holder;\n+            }\n+        }\n+        return writer.specTagOutput(e, tags);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -624,0 +624,1 @@\n+        addStandardTaglet(new SpecTaglet());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.source.doctree.SpecTree;\n@@ -198,0 +199,10 @@\n+    \/**\n+     * Returns the output for one or more {@code @spec} tags.\n+     *\n+     * @param element  the element that owns the doc comment\n+     * @param specTags the array of @spec tags.\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content specTagOutput(Element element, List<? extends SpecTree> specTags);\n+\n@@ -201,1 +212,1 @@\n-     * @param element           The element that owns the doc comment\n+     * @param element           the element that owns the doc comment\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,14 +28,0 @@\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.AttributeTree;\n-import com.sun.source.doctree.AttributeTree.ValueKind;\n@@ -48,2 +34,0 @@\n-import com.sun.source.doctree.EndElementTree;\n-import com.sun.source.doctree.EntityTree;\n@@ -63,1 +47,1 @@\n-import com.sun.source.doctree.StartElementTree;\n+import com.sun.source.doctree.SpecTree;\n@@ -76,1 +60,12 @@\n-import static com.sun.source.doctree.DocTree.Kind.*;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import java.util.List;\n+\n+import static com.sun.source.doctree.DocTree.Kind.SEE;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n@@ -485,0 +480,5 @@\n+            @Override\n+            public List<? extends DocTree> visitSpec(SpecTree node, Void p) {\n+                return node.getTitle();\n+            }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+    \/** The name of the file for all references to external specifications. *\/\n+    public static final DocPath EXTERNAL_SPECS = DocPath.create(\"external-specs.html\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-            case INDEX, SYSTEM_PROPERTY -> { }\n+            case INDEX, SPEC, SYSTEM_PROPERTY -> { }\n@@ -340,1 +340,1 @@\n-            case INDEX, SYSTEM_PROPERTY -> Category.TAGS;\n+            case INDEX, SPEC, SYSTEM_PROPERTY -> Category.TAGS;\n@@ -565,1 +565,1 @@\n-                        .append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\",\")\n+                        .append(\"\\\"l\\\":\\\"\").append(escapeQuotes(label)).append(\"\\\",\")\n@@ -568,1 +568,1 @@\n-                    item.append(\"\\\"d\\\":\\\"\").append(description).append(\"\\\",\");\n+                    item.append(\"\\\"d\\\":\\\"\").append(escapeQuotes(description)).append(\"\\\",\");\n@@ -570,1 +570,1 @@\n-                item.append(\"\\\"u\\\":\\\"\").append(url).append(\"\\\"\")\n+                item.append(\"\\\"u\\\":\\\"\").append(escapeQuotes(url)).append(\"\\\"\")\n@@ -579,1 +579,5 @@\n-}\n+\n+    private String escapeQuotes(String s) {\n+        return s.replace(\"\\\"\", \"\\\\\\\"\");\n+    }\n+ }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/IndexItem.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+import com.sun.source.doctree.SpecTree;\n@@ -2405,0 +2406,4 @@\n+    public List<? extends SpecTree> getSpecTrees(Element element) {\n+        return getBlockTags(element, SPEC, SpecTree.class);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,2 +74,1 @@\n-     * Unlike {@link java.lang.Thread#suspend},\n-     * suspends of both the virtual machine and individual threads are\n+     * Suspends of both the virtual machine and individual threads are\n@@ -77,1 +76,1 @@\n-     * (through {@link #resume} or {@link ThreadReference#resume})\n+     * (through {@link #resume} or {@link VirtualMachine#resume})\n@@ -80,4 +79,3 @@\n-     * Suspending single threads with this method has the same dangers\n-     * as {@link java.lang.Thread#suspend()}. If the suspended thread\n-     * holds a monitor needed by another running thread, deadlock is\n-     * possible in the target VM (at least until the suspended thread\n+     * Suspending single threads with this method is inherently deadlock-prone.\n+     * If the suspended thread holds a monitor needed by another running thread,\n+     * deadlock is possible in the target VM (at least until the suspended thread\n@@ -87,4 +85,4 @@\n-     * resumed through one of the JDI resume methods mentioned above;\n-     * the application in the target VM cannot resume the suspended thread\n-     * through {@link java.lang.Thread#resume}.\n-     * @throws VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.\n+     * resumed through one of the JDI resume methods mentioned above.\n+     *\n+     * @throws VMCannotBeModifiedException if the VirtualMachine is read-only\n+     * @see VirtualMachine#canBeModified()\n@@ -104,1 +102,3 @@\n-     * @throws VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.\n+     *\n+     * @throws VMCannotBeModifiedException if the VirtualMachine is read-only\n+     * @see VirtualMachine#canBeModified()\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -280,2 +280,1 @@\n-     * Unlike {@link java.lang.Thread#suspend Thread.suspend()},\n-     * suspends of both the virtual machine and individual threads are\n+     * Suspends of both the virtual machine and individual threads are\n@@ -286,1 +285,2 @@\n-     * @throws VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.\n+     * @throws VMCannotBeModifiedException if the VirtualMachine is read-only\n+     * @see #canBeModified()\n@@ -295,3 +295,3 @@\n-     * @throws VMCannotBeModifiedException if the VirtualMachine is read-only - see {@link VirtualMachine#canBeModified()}.\n-     *\n-     * @see #suspend\n+     * @throws VMCannotBeModifiedException if the VirtualMachine is read-only\n+     * @see #suspend()\n+     * @see #canBeModified()\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/VirtualMachine.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,6 +102,1 @@\n-            } catch (ThreadDeath x) {\n-                throw x;\n-            } catch (Exception x) {\n-                System.err.println(x);\n-                continue;\n-            } catch (Error x) {\n+            } catch (Exception | Error x) {\n@@ -131,6 +126,1 @@\n-            } catch (ThreadDeath x) {\n-                throw x;\n-            } catch (Exception x) {\n-                System.err.println(x);\n-                continue;\n-            } catch (Error x) {\n+            } catch (Exception | Error x) {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VirtualMachineManagerImpl.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -337,3 +337,8 @@\n-                    deferring = isBreakpointSet(clazz, method, start) ||\n-                                threadControl_getInstructionStepMode(thread)\n-                                    == JVMTI_ENABLE;\n+                    if (isBreakpointSet(clazz, method, start)) {\n+                        deferring = JNI_TRUE;\n+                    } else {\n+                        StepRequest* step = threadControl_getStepRequest(thread);\n+                        if (step->pending && step->depth == JDWP_STEP_DEPTH(INTO)) {\n+                            deferring = JNI_TRUE;\n+                        }\n+                    }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.MirrorEvent;\n+\n+@Category({\"Java Development Kit\", \"Security\"})\n+@Label(\"Security Provider Instance Request\")\n+@Name(\"jdk.SecurityProviderService\")\n+@Description(\"Details of Provider.getInstance(String type, String algorithm) calls\")\n+@MirrorEvent(className = \"jdk.internal.event.SecurityProviderServiceEvent\")\n+public final class SecurityProviderServiceEvent extends AbstractJDKEvent {\n+    @Label(\"Type of Service\")\n+    public String type;\n+\n+    @Label(\"Algorithm Name\")\n+    public String algorithm;\n+\n+    @Label(\"Security Provider\")\n+    public String provider;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SecurityProviderServiceEvent.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Map;\n@@ -50,0 +49,1 @@\n+import jdk.jfr.events.SecurityProviderServiceEvent;\n@@ -75,0 +75,1 @@\n+        SecurityProviderServiceEvent.class,\n@@ -99,0 +100,1 @@\n+        jdk.internal.event.SecurityProviderServiceEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -717,0 +717,5 @@\n+    <event name=\"jdk.SecurityProviderService\">\n+       <setting name=\"enabled\">false<\/setting>\n+       <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -717,0 +717,5 @@\n+    <event name=\"jdk.SecurityProviderService\">\n+       <setting name=\"enabled\">false<\/setting>\n+       <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -268,3 +268,23 @@\n-        \/\/ If predefine app image is provided, then just sign it and return.\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) != null) {\n-            doSigning(params);\n+        \/\/ If predefined app image is provided, then just sign it and return.\n+        Path predefinedAppImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n+        if (predefinedAppImage != null) {\n+            \/\/ Mark app image as signed, before we signing it.\n+            AppImageFile appImageFile =\n+                AppImageFile.load(predefinedAppImage);\n+            if (!appImageFile.isSigned()) {\n+                appImageFile.copyAsSigned().save(predefinedAppImage);\n+            } else {\n+                appImageFile = null;\n+            }\n+\n+            try {\n+                doSigning(params);\n+            } catch (Exception ex) {\n+                \/\/ Restore original app image file if signing failed\n+                if (appImageFile != null) {\n+                    appImageFile.save(predefinedAppImage);\n+                }\n+\n+                throw ex;\n+            }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractAppImageBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n@@ -62,2 +64,1 @@\n-    private final String creatorVersion;\n-    private final String creatorPlatform;\n+    private final String appVersion;\n@@ -67,0 +68,2 @@\n+    private final String creatorVersion;\n+    private final String creatorPlatform;\n@@ -76,3 +79,4 @@\n-    private AppImageFile(Path appImageDir, String launcherName, String mainClass,\n-            List<LauncherInfo> launcherInfos, String creatorVersion,\n-            String creatorPlatform, String signedStr, String appStoreStr) {\n+    private AppImageFile(Path appImageDir, String appVersion, String launcherName,\n+            String mainClass, List<LauncherInfo> launcherInfos,\n+            String creatorVersion, String creatorPlatform, String signedStr,\n+            String appStoreStr) {\n@@ -80,3 +84,0 @@\n-        if (!Objects.equals(getVersion(), creatorVersion)) {\n-            isValid = false;\n-        }\n@@ -84,1 +85,1 @@\n-        if (!Objects.equals(getPlatform(), creatorPlatform)) {\n+        if (appVersion == null || appVersion.length() == 0) {\n@@ -102,0 +103,8 @@\n+        if (!Objects.equals(getVersion(), creatorVersion)) {\n+            isValid = false;\n+        }\n+\n+        if (!Objects.equals(getPlatform(), creatorPlatform)) {\n+            isValid = false;\n+        }\n+\n@@ -114,1 +123,2 @@\n-                \"error.invalid-app-image\"), appImageDir));\n+                \"error.invalid-app-image\"), appImageDir,\n+                AppImageFile.getPathInAppImage(appImageDir)));\n@@ -117,0 +127,1 @@\n+        this.appVersion = appVersion;\n@@ -135,0 +146,7 @@\n+    \/**\n+     * Returns application version. Never returns null or empty value.\n+     *\/\n+    String getAppVersion() {\n+        return appVersion;\n+    }\n+\n@@ -153,1 +171,1 @@\n-    boolean isAppStore() {\n+    public boolean isAppStore() {\n@@ -168,0 +186,10 @@\n+    \/**\n+     * Saves file with application image info in application image using values\n+     * from current instance.\n+     * @param appImageDir - path to application image\n+     * @throws IOException\n+     *\/\n+    void save(Path appImageDir) throws IOException {\n+        AppImageFile.save(appImageDir, null, this);\n+    }\n+\n@@ -171,0 +199,1 @@\n+     * @param params - parameters used to generate application image\n@@ -175,0 +204,43 @@\n+        AppImageFile.save(appImageDir, params, null);\n+    }\n+\n+    \/**\n+     * Saves file with application image info in application image using params\n+     * or appImage. Both params or appImage cannot be valid.\n+     * @param appImageDir - path to application image\n+     * @param params - parameters used to generate application image\n+     * @param appImage - instance of already existing application image file\n+     * @throws IOException\n+     * @throws IllegalArgumentException - If both params and appImage are null or\n+     *                                    If both params and appImage are not null\n+     *\/\n+    private static void save(Path appImageDir,\n+            Map<String, Object> params,\n+            AppImageFile appImage) throws IOException {\n+        if ((params == null && appImage == null) ||\n+            (params != null && appImage != null)) {\n+                throw new IllegalArgumentException();\n+        }\n+\n+        final String appVersionSave;\n+        final String mainLauncherSave;\n+        final String mainClassSave;\n+        final String signedSave;\n+        final String appStoreSave;\n+        final List<LauncherInfo> addLauncherInfoSave;\n+        if (params != null) {\n+            appVersionSave = VERSION.fetchFrom(params);\n+            mainLauncherSave = APP_NAME.fetchFrom(params);\n+            mainClassSave = MAIN_CLASS.fetchFrom(params);\n+            signedSave = SIGN_BUNDLE.fetchFrom(params).toString();\n+            appStoreSave = APP_STORE.fetchFrom(params).toString();\n+            addLauncherInfoSave = null;\n+        } else {\n+            appVersionSave = appImage.getAppVersion();\n+            mainLauncherSave = appImage.getLauncherName();\n+            mainClassSave = appImage.getMainClass();\n+            signedSave = String.valueOf(appImage.isSigned());\n+            appStoreSave = String.valueOf(appImage.isAppStore());\n+            addLauncherInfoSave = appImage.getAddLaunchers();\n+        }\n+\n@@ -181,1 +253,1 @@\n-            xml.writeCharacters(VERSION.fetchFrom(params));\n+            xml.writeCharacters(appVersionSave);\n@@ -185,1 +257,1 @@\n-            xml.writeCharacters(APP_NAME.fetchFrom(params));\n+            xml.writeCharacters(mainLauncherSave);\n@@ -189,1 +261,1 @@\n-            xml.writeCharacters(MAIN_CLASS.fetchFrom(params));\n+            xml.writeCharacters(mainClassSave);\n@@ -193,1 +265,1 @@\n-            xml.writeCharacters(SIGN_BUNDLE.fetchFrom(params).toString());\n+            xml.writeCharacters(signedSave);\n@@ -197,1 +269,1 @@\n-            xml.writeCharacters(APP_STORE.fetchFrom(params).toString());\n+            xml.writeCharacters(appStoreSave);\n@@ -200,11 +272,12 @@\n-            List<Map<String, ? super Object>> addLaunchers =\n-                ADD_LAUNCHERS.fetchFrom(params);\n-\n-            for (var launcherParams : addLaunchers) {\n-                var li = new LauncherInfo(launcherParams);\n-                xml.writeStartElement(\"add-launcher\");\n-                xml.writeAttribute(\"name\", li.getName());\n-                xml.writeAttribute(\"shortcut\", Boolean.toString(li.isShortcut()));\n-                xml.writeAttribute(\"menu\", Boolean.toString(li.isMenu()));\n-                xml.writeAttribute(\"service\", Boolean.toString(li.isService()));\n-                xml.writeEndElement();\n+            if (addLauncherInfoSave != null) {\n+                for (var li : addLauncherInfoSave) {\n+                    addLauncherInfo(xml, li);\n+                }\n+            } else {\n+                List<Map<String, ? super Object>> addLaunchers =\n+                    ADD_LAUNCHERS.fetchFrom(params);\n+\n+                for (var launcherParams : addLaunchers) {\n+                    var li = new LauncherInfo(launcherParams);\n+                    addLauncherInfo(xml, li);\n+                }\n@@ -215,0 +288,10 @@\n+    static void addLauncherInfo(XMLStreamWriter xml, LauncherInfo li)\n+            throws XMLStreamException {\n+        xml.writeStartElement(\"add-launcher\");\n+        xml.writeAttribute(\"name\", li.getName());\n+        xml.writeAttribute(\"shortcut\", Boolean.toString(li.isShortcut()));\n+        xml.writeAttribute(\"menu\", Boolean.toString(li.isMenu()));\n+        xml.writeAttribute(\"service\", Boolean.toString(li.isService()));\n+        xml.writeEndElement();\n+    }\n+\n@@ -227,0 +310,3 @@\n+            String appVersion = xpathQueryNullable(xPath,\n+                    \"\/jpackage-state\/app-version\/text()\", doc);\n+\n@@ -255,2 +341,3 @@\n-            return new AppImageFile(appImageDir, mainLauncher, mainClass,\n-                    launcherInfos, version, platform, signedStr, appStoreStr);\n+            return new AppImageFile(appImageDir, appVersion, mainLauncher,\n+                    mainClass, launcherInfos, version, platform, signedStr,\n+                    appStoreStr);\n@@ -269,4 +356,16 @@\n-    private static String getAttribute(Node item, String attr) {\n-        NamedNodeMap attrs = item.getAttributes();\n-        Node attrNode = attrs.getNamedItem(attr);\n-        return ((attrNode == null) ? null : attrNode.getNodeValue());\n+    \/**\n+     * Returns copy of AppImageFile, but with signed set to true if AppImageFile\n+     * is not marked as signed. If AppImageFile already signed it will return\n+     * instance to itself.\n+     *\/\n+    public AppImageFile copyAsSigned() {\n+        if (isSigned()) {\n+            return this;\n+        }\n+\n+        \/\/ Pass null for appImageDir, it is used only to show location of\n+        \/\/ .jpackage.xml in case of error. copyAsSigned() should not produce\n+        \/\/ invalid app image file.\n+        return new AppImageFile(null, getAppVersion(),\n+                getLauncherName(), getMainClass(), getAddLaunchers(),\n+                getVersion(), getPlatform(), \"true\", String.valueOf(isAppStore()));\n@@ -365,0 +464,6 @@\n+        private String getAttribute(Node item, String attr) {\n+            NamedNodeMap attrs = item.getAttributes();\n+            Node attrNode = attrs.getNamedItem(attr);\n+            return ((attrNode == null) ? null : attrNode.getNodeValue());\n+        }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":138,"deletions":33,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir ({0})\n-error.invalid-app-image=Error: app-image dir ({0}) generated by another jpackage version or malformed .jpackage.xml\n+error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir ({0})\n-error.invalid-app-image=Error: app-image dir ({0}) generated by another jpackage version or malformed .jpackage.xml\n+error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_de.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir ({0})\n-error.invalid-app-image=Error: app-image dir ({0}) generated by another jpackage version or malformed .jpackage.xml\n+error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir ({0})\n-error.invalid-app-image=Error: app-image dir ({0}) generated by another jpackage version or malformed .jpackage.xml\n+error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-    @SuppressWarnings(\"serial\")             \/\/ serialVersionUID intentionally omitted\n+    @SuppressWarnings({\"serial\", \"removal\"})       \/\/ serialVersionUID intentionally omitted\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/RemoteExecutionControl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.io.BufferedInputStream;\n@@ -927,3 +926,0 @@\n-        private final String[] enabledCipherSuites;\n-        private final String[] enabledProtocols;\n-        private final boolean needClientAuth;\n@@ -944,1 +940,1 @@\n-            this.context = ctx;\n+            super(ctx, enabledCipherSuites, enabledProtocols, sslNeedClientAuth);\n@@ -946,3 +942,1 @@\n-            this.enabledProtocols = enabledProtocols;\n-            this.enabledCipherSuites = enabledCipherSuites;\n-            this.needClientAuth = sslNeedClientAuth;\n+            this.context = ctx;\n@@ -958,1 +952,2 @@\n-                                               enabledCipherSuites, enabledProtocols, needClientAuth);\n+                            this.getEnabledCipherSuites(), this.getEnabledProtocols(),\n+                            this.getNeedClientAuth());\n@@ -961,1 +956,1 @@\n-                                               enabledCipherSuites, enabledProtocols, needClientAuth);\n+                            this.getEnabledCipherSuites(), this.getEnabledProtocols(), this.getNeedClientAuth());\n@@ -965,1 +960,1 @@\n-                                           enabledCipherSuites, enabledProtocols, needClientAuth);\n+                        this.getEnabledCipherSuites(), this.getEnabledProtocols(), this.getNeedClientAuth());\n","filename":"src\/jdk.management.agent\/share\/classes\/sun\/management\/jmxremote\/ConnectorBootstrap.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+# Valhalla\n+compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBuffering.java 8294624 generic-aarch64\n+\n@@ -93,0 +96,1 @@\n+runtime\/handshake\/HandshakeSuspendExitTest.java 8294313 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,2 +106,2 @@\n-  vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001\/TestDescription.java \\\n-  vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002\/TestDescription.java \\\n+  vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.java \\\n+  vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java \\\n@@ -1039,5 +1039,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005\/TestDescription.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8289422\n+ * @key randomness\n+ * @summary Auto-vectorization enhancement to support vector conditional move on AArch64\n+ * @requires os.arch==\"aarch64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestVectorConditionalMove\n+ *\/\n+\n+public class TestVectorConditionalMove {\n+    final private static int SIZE = 3000;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    private static float[] floata = new float[SIZE];\n+    private static float[] floatb = new float[SIZE];\n+    private static float[] floatc = new float[SIZE];\n+    private static double[] doublea = new double[SIZE];\n+    private static double[] doubleb = new double[SIZE];\n+    private static double[] doublec = new double[SIZE];\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-Xcomp\", \"-XX:-TieredCompilation\", \"-XX:+UseCMoveUnconditionally\",\n+                                   \"-XX:+UseVectorCmov\", \"-XX:CompileCommand=exclude,*.cmove*\");\n+    }\n+\n+    private float cmoveFloatGT(float a, float b) {\n+        return (a > b) ? a : b;\n+    }\n+\n+    private float cmoveFloatGTSwap(float a, float b) {\n+        return (b > a) ? a : b;\n+    }\n+\n+    private float cmoveFloatLT(float a, float b) {\n+        return (a < b) ? a : b;\n+    }\n+\n+    private float cmoveFloatLTSwap(float a, float b) {\n+        return (b < a) ? a : b;\n+    }\n+\n+    private float cmoveFloatEQ(float a, float b) {\n+        return (a == b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleLE(double a, double b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleLESwap(double a, double b) {\n+        return (b <= a) ? a : b;\n+    }\n+\n+    private double cmoveDoubleGE(double a, double b) {\n+        return (a >= b) ? a : b;\n+    }\n+\n+    private double cmoveDoubleGESwap(double a, double b) {\n+        return (b >= a) ? a : b;\n+    }\n+\n+    private double cmoveDoubleNE(double a, double b) {\n+        return (a != b) ? a : b;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFGT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] > b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFGTSwap(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] > a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFLT(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] < b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFLTSwap(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] < a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVF, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVFEQ(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] == b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDLE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] <= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDLESwap(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] <= a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDGE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] >= b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDGESwap(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (b[i] >= a[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.CMOVEVD, \">0\", IRNode.STORE_VECTOR, \">0\"})\n+    private static void testCMoveVDNE(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = (a[i] != b[i]) ? a[i] : b[i];\n+        }\n+    }\n+\n+    @Run(test = {\"testCMoveVFGT\", \"testCMoveVFLT\",\"testCMoveVDLE\", \"testCMoveVDGE\", \"testCMoveVFEQ\", \"testCMoveVDNE\",\n+                 \"testCMoveVFGTSwap\", \"testCMoveVFLTSwap\",\"testCMoveVDLESwap\", \"testCMoveVDGESwap\"})\n+    private void testCMove_runner() {\n+        for (int i = 0; i < SIZE; i++) {\n+            floata[i] = RANDOM.nextFloat();\n+            floatb[i] = RANDOM.nextFloat();\n+            doublea[i] = RANDOM.nextDouble();\n+            doubleb[i] = RANDOM.nextDouble();\n+        }\n+\n+        testCMoveVFGT(floata, floatb, floatc);\n+        testCMoveVDLE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatGT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleLE(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFLT(floata, floatb, floatc);\n+        testCMoveVDGE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatLT(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleGE(doublea[i], doubleb[i]));\n+        }\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            if (i % 3 == 0) {\n+                floatb[i] = floata[i];\n+                doubleb[i] = doublea[i];\n+            }\n+        }\n+\n+        testCMoveVFEQ(floata, floatb, floatc);\n+        testCMoveVDNE(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatEQ(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleNE(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFGTSwap(floata, floatb, floatc);\n+        testCMoveVDLESwap(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatGTSwap(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleLESwap(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveVFLTSwap(floata, floatb, floatc);\n+        testCMoveVDGESwap(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFloatLTSwap(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDoubleGESwap(doublea[i], doubleb[i]));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @bug 8292158\n+ * @summary AES-CTR cipher state corruption with AVX-512\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbatch\n+ * -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * compiler.codegen.aes.Test8292158\n+ *\/\n+\n+package compiler.codegen.aes;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.code.Compiler;\n+import jdk.test.lib.Utils;\n+import jtreg.SkippedException;\n+\n+public class Test8292158 {\n+    private static final String ALGO = \"AES\/CTR\/NoPadding\";\n+    private static final int LOOPS = 100000;\n+    private static final int LEN = 15;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Compiler.isIntrinsicAvailable(CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"com.sun.crypto.provider.CounterMode\", \"implCrypt\", byte[].class, int.class, int.class, byte[].class, int.class)) {\n+            throw new SkippedException(\"AES-CTR intrinsic is not available\");\n+        }\n+\n+        Random random = Utils.getRandomInstance();\n+\n+        byte[] keyBytes = new byte[32];\n+        random.nextBytes(keyBytes);\n+        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n+\n+        byte[] ivBytes = new byte[16];\n+        random.nextBytes(ivBytes);\n+        IvParameterSpec iv = new IvParameterSpec(ivBytes);\n+\n+        Cipher encryptCipher = Cipher.getInstance(ALGO);\n+        Cipher decryptCipher = Cipher.getInstance(ALGO);\n+\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, key, iv);\n+        decryptCipher.init(Cipher.DECRYPT_MODE, key, iv);\n+\n+        byte[] original = new byte[LEN];\n+        byte[] encrypted = new byte[LEN];\n+        byte[] decrypted = new byte[LEN];\n+\n+        for (int i = 0; i < LOOPS; i++) {\n+            random.nextBytes(original);\n+            encryptCipher.doFinal(original, 0, LEN, encrypted);\n+\n+            \/\/ Cipher must be used at least 3 times\n+            decryptCipher.update(encrypted, 0, 1, decrypted, 0);\n+            decryptCipher.update(encrypted, 1, 1, decrypted, 1);\n+            decryptCipher.doFinal(encrypted, 2, LEN - 2, decrypted, 2);\n+\n+            if (!Arrays.equals(original, decrypted)) {\n+                throw new Exception(\"array mismatch\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/Test8292158.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -145,0 +145,2 @@\n+    public static final String CMOVEVF = START + \"CMoveVF\" + MID + END;\n+    public static final String CMOVEVD = START + \"CMoveVD\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +27,1 @@\n- * @bug 8231988\n+ * @bug 8231988 8293996\n@@ -37,1 +38,1 @@\n-    public void test() {\n+    public void test_cmp_helper() {\n@@ -39,0 +40,1 @@\n+        \/\/ The empty loop that collapses\n@@ -40,0 +42,1 @@\n+        \/\/ If uses same Cmp node as the loop condition\n@@ -47,2 +50,2 @@\n-    public static void main(String[] args) {\n-        TestRemoveEmptyLoop _instance = new TestRemoveEmptyLoop();\n+    public void test_cmp() {\n+        \/\/ Loop is OSR compiled, and test_cmp_helper inlined\n@@ -50,1 +53,22 @@\n-            _instance.test();\n+            test_cmp_helper();\n+        }\n+    }\n+\n+    void test_collapse_helper() {\n+        int o = 11;\n+        int e = 43542;\n+        for (int i = 524; i < 19325; i += 1) {\n+            \/\/ The empty loop that is supposed to collapse\n+            for (int j = 0; j < 32767; j++) {\n+                o++;\n+            }\n+            for (int k = 0; k < o; k++) {\n+                e++;\n+            }\n+        }\n+    }\n+\n+    public void test_collapse() {\n+        \/\/ Loop is OSR compiled, and test_collapse_helper inlined\n+        for (int i = 0; i < 50000; i++) {\n+            test_collapse_helper();\n@@ -52,1 +76,0 @@\n-        System.out.println(\"Test passed.\");\n@@ -55,0 +78,6 @@\n+    public static void main(String[] args) {\n+        TestRemoveEmptyLoop _instance = new TestRemoveEmptyLoop();\n+        _instance.test_cmp();\n+        _instance.test_collapse();\n+        System.out.println(\"Test passed.\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRemoveEmptyLoop.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test\n+ * @requires vm.compiler2.enabled\n+ * @bug 8290910 8293216\n+ * @summary Test which needs to select the memory state of the last load in a load pack in SuperWord::co_locate_pack.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler\/loopopts\/superword\/TestPickLastMemoryState\n+ *                   -Xbatch -XX:MaxVectorSize=16 compiler.loopopts.superword.TestPickLastMemoryState\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler\/loopopts\/superword\/TestPickLastMemoryState\n+ *                   -Xbatch -XX:MaxVectorSize=32 compiler.loopopts.superword.TestPickLastMemoryState\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler\/loopopts\/superword\/TestPickLastMemoryState\n+ *                   -Xbatch compiler.loopopts.superword.TestPickLastMemoryState\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestPickLastMemoryState {\n+    static final int N = 400;\n+    static final int M = 32;\n+    static long lArrFld[] = new long[N];\n+    static long iMeth_check_sum;\n+    static float a[] = new float[M];\n+\n+    static void f() {\n+        int b[] = new int[M];\n+        for (int h = 1; h < 32; h++) {\n+            a[h] = b[h - 1]--;\n+            b[h]--;\n+        }\n+        boolean c[] = new boolean[M];\n+    }\n+\n+    static void test0() throws Exception {\n+        f();\n+        double s = checkSum(a);\n+        System.out.println(s);\n+        if (s < -31 || s > -29) {\n+            throw new Exception(\"expected s: -30, actual s: \" + s);\n+        }\n+    }\n+\n+    static void test1() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        \/\/ For the following loop, statement 1 can be vectorized but statement 2 can't. When\n+        \/\/ finding the memory state for the LoadI pack, we cannot pick the memory state from\n+        \/\/ the first load as the LoadI vector operation must load the memory after iArr writes\n+        \/\/ 'iArr[i1 + 1] - (i2++)' to 'iArr[i1 + 1]'. We must take the memory state of the last\n+        \/\/ load where we have assigned new values ('iArr[i1 + 1] - (i2++)') to the iArr array.\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++; \/\/ statement 1\n+            iArr[i1 + 1] -= (i2++); \/\/ statement 2\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test2() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++;\n+            iArr[i1 + 2] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test3() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1-2] += lArrFld[i1]++;\n+            iArr[i1] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test4() {\n+        int i1 , i2 = -222, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1-3] += lArrFld[i1]++;\n+            iArr[i1] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test5() {\n+        int i1 , i2 = -222, i3 = -100, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++;\n+            iArr[i1+2] -= (i3++);\n+            iArr[i1+16] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void test6() {\n+        int i1 , i2 = -222, i3 = -100, iArr[] = new int[N];\n+        init(iArr, 212);\n+        for (i1 = 6; i1 < 227; i1++) {\n+            iArr[i1] += lArrFld[i1]++;\n+            iArr[i1+1] -= (i3++);\n+            iArr[i1+32] -= (i2++);\n+        }\n+        iMeth_check_sum += checkSum(iArr);\n+    }\n+\n+    static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    static long checkSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += (a[j] \/ (j + 1) + a[j] % (j + 1));\n+        }\n+        return sum;\n+    }\n+\n+    static double checkSum(float[] a) {\n+        double sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += a[j];\n+        }\n+        return sum;\n+    }\n+\n+    static void reset() {\n+        for (int i = 0; i < N; i++) {\n+            lArrFld[i] = 0;\n+        }\n+        iMeth_check_sum = 0;\n+    }\n+\n+    public static void main(String[] strArr)  throws Exception {\n+        test0();\n+        test0();\n+        for (int i = 0; i < 5_000; i++) {\n+            reset();\n+            test1();\n+            if (iMeth_check_sum != 22154) {\n+                throw new RuntimeException(\"iMeth wrong result at test1: \" + iMeth_check_sum);\n+            }\n+            test2();\n+            if (iMeth_check_sum != 44246) {\n+                throw new RuntimeException(\"iMeth wrong result at test2: \" + iMeth_check_sum);\n+            }\n+            test3();\n+            if (iMeth_check_sum != 66171) {\n+                throw new RuntimeException(\"iMeth wrong result at test3: \" + iMeth_check_sum);\n+            }\n+            test4();\n+            if (iMeth_check_sum != 88309) {\n+                throw new RuntimeException(\"iMeth wrong result at test4: \" + iMeth_check_sum);\n+            }\n+            test5();\n+            if (iMeth_check_sum != 109251) {\n+                throw new RuntimeException(\"iMeth wrong result at test5: \" + iMeth_check_sum);\n+            }\n+            test6();\n+            if (iMeth_check_sum != 130073) {\n+                throw new RuntimeException(\"iMeth wrong result at test6: \" + iMeth_check_sum);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestPickLastMemoryState.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-    public static final int JNI_VERSION_19 = 0x00130000;\n+    public static final int JNI_VERSION_20 = 0x00140000;\n@@ -35,1 +35,1 @@\n-        if (res != JNI_VERSION_19) {\n+        if (res != JNI_VERSION_20) {\n","filename":"test\/hotspot\/jtreg\/native_sanity\/JniVersion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    System.out.println(\"memAlloc1:\"+memAlloc1);\n+    System.out.println(\"memAlloc2:\"+memAlloc2);\n+    System.out.println(\"memAlloc3:\"+memAlloc3);\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/ThreadedMallocTestType.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main ThreadCountLimit\n+ * @run main\/othervm -Xmx1g ThreadCountLimit\n@@ -39,1 +39,0 @@\n-    private final int index;\n@@ -42,2 +41,1 @@\n-    Worker(int index, CountDownLatch startSignal) {\n-      this.index = index;\n+    Worker(CountDownLatch startSignal) {\n@@ -49,4 +47,0 @@\n-      if ((index % 250) == 0) {\n-        System.out.println(\"INFO: thread \" + index + \" waiting to start\");\n-      }\n-\n@@ -56,13 +50,1 @@\n-        throw new Error(\"Unexpected: \" + e);\n-      }\n-\n-      setName(String.valueOf(index));\n-\n-      Thread.yield();\n-\n-      if (index != Integer.parseInt(getName())) {\n-        throw new Error(\"setName\/getName failed!\");\n-      }\n-\n-      if ((index % 250) == 0) {\n-        System.out.println(\"INFO: thread \" + getName() + \" working\");\n+        throw new Error(\"Unexpected\", e);\n@@ -77,0 +59,10 @@\n+    boolean reachedTimeLimit = false;\n+    boolean reachedNativeOOM = false;\n+    int countAtTimeLimit = -1;\n+    int countAtNativeOOM = -1;\n+\n+    \/\/ This is dangerous loop: it depletes system resources,\n+    \/\/ so doing additional things there that may end up allocating\n+    \/\/ Java\/native memory risks failing the VM prematurely.\n+    \/\/ Avoid doing unnecessary calls, printouts, etc.\n+\n@@ -81,1 +73,1 @@\n-        Worker w = new Worker(count, startSignal);\n+        Worker w = new Worker(startSignal);\n@@ -88,2 +80,2 @@\n-          \/\/ Windows path or a system with very large ulimit\n-          System.out.println(\"INFO: reached the time limit \" + TIME_LIMIT_MS + \" ms, with \" + count + \" threads created\");\n+          reachedTimeLimit = true;\n+          countAtTimeLimit = count;\n@@ -96,2 +88,2 @@\n-        long end = System.currentTimeMillis();\n-        System.out.println(\"INFO: reached this process thread count limit at \" + count + \" [\" + (end - start) + \" ms]\");\n+        reachedNativeOOM = true;\n+        countAtNativeOOM = count;\n@@ -110,1 +102,12 @@\n-      throw new Error(\"Unexpected: \" + e);\n+      throw new Error(\"Unexpected\", e);\n+    }\n+\n+    \/\/ Now that all threads have joined, we are away from dangerous\n+    \/\/ VM state and have enough memory to perform any other things.\n+    if (reachedTimeLimit) {\n+       \/\/ Windows path or a system with very large ulimit\n+       System.out.println(\"INFO: reached the time limit \" + TIME_LIMIT_MS +\n+                          \" ms, with \" + countAtTimeLimit + \" threads created\");\n+    } else if (reachedNativeOOM) {\n+       System.out.println(\"INFO: reached this process thread count limit with \" +\n+                           countAtNativeOOM + \" threads created\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/ThreadCountLimit.java","additions":31,"deletions":28,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -49,0 +51,20 @@\n+    static void suspendThread(Thread t) {\n+        try {\n+            JVMTIUtils.suspendThread(t);\n+        } catch (JVMTIUtils.JvmtiException e) {\n+            if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    static void resumeThread(Thread t) {\n+        try {\n+            JVMTIUtils.resumeThread(t);\n+        } catch (JVMTIUtils.JvmtiException e) {\n+            if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n@@ -94,1 +116,1 @@\n-                    workingThreads[i].suspend();\n+                    suspendThread(workingThreads[i]);\n@@ -99,1 +121,1 @@\n-                    workingThreads[i].resume();\n+                    resumeThread(workingThreads[i]);\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -39,0 +41,22 @@\n+    static void suspendThread(Thread t) {\n+        try {\n+            JVMTIUtils.suspendThread(t);\n+        } catch (JVMTIUtils.JvmtiException e) {\n+            if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_SUSPENDED\n+                && e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    static void resumeThread(Thread t) {\n+        try {\n+            JVMTIUtils.resumeThread(t);\n+        } catch (JVMTIUtils.JvmtiException e) {\n+            if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_SUSPENDED\n+                && e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n@@ -46,2 +70,2 @@\n-                    _suspend_threads[i].suspend();\n-                    _suspend_threads[i].resume();\n+                    suspendThread(_suspend_threads[i]);\n+                    resumeThread(_suspend_threads[i]);\n@@ -54,0 +78,1 @@\n+\n@@ -77,1 +102,1 @@\n-            thr.suspend();\n+            suspendThread(thr);\n@@ -80,1 +105,1 @@\n-            thr.resume();\n+            resumeThread(thr);\n@@ -91,1 +116,1 @@\n-                thr.resume();\n+                resumeThread(thr);\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeSuspendExitTest.java","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/testlibrary\n@@ -34,0 +34,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -44,4 +46,10 @@\n-            suspend_thread.suspend();\n-            wb.lockAndBlock(\/* suspender= *\/ true);\n-            suspend_thread.resume();\n-            Thread.sleep(1);\n+            try {\n+                JVMTIUtils.suspendThread(suspend_thread);\n+                wb.lockAndBlock(\/* suspender= *\/ true);\n+                JVMTIUtils.resumeThread(suspend_thread);\n+                Thread.sleep(1);\n+            } catch (JVMTIUtils.JvmtiException e) {\n+                if (e.getCode() != JVMTIUtils.JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+                    throw e;\n+                }\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/SuspendBlocked.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8290482\n+ * @summary Tests that DestroyJavaVM from an active thread fails.\n+ * @run main\/native TestActiveDestroy\n+ *\/\n+\n+public class TestActiveDestroy {\n+\n+    static native boolean tryDestroyJavaVM();\n+\n+    static {\n+        System.loadLibrary(\"activeDestroy\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (tryDestroyJavaVM()) {\n+            throw new Error(\"DestroyJavaVM succeeded when it should not!\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/activeDestroy\/TestActiveDestroy.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+\n+static const char* jni_error_code(int ret) {\n+  switch(ret) {\n+  case JNI_OK: return \"JNI_OK\";\n+  case JNI_ERR: return \"JNI_ERR\";\n+  case JNI_EDETACHED: return \"JNI_EDETACHED\";\n+  case JNI_EVERSION: return \"JNI_EVERSION\";\n+  case JNI_ENOMEM: return \"JNI_ENOMEM\";\n+  case JNI_EEXIST: return \"JNI_EEXIST\";\n+  case JNI_EINVAL: return \"JNI_EINVAL\";\n+  default: return \"Invalid JNI error code\";\n+  }\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_TestActiveDestroy_tryDestroyJavaVM(JNIEnv *env, jclass cls) {\n+  JavaVM* jvm;\n+  int res = (*env)->GetJavaVM(env, &jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"GetJavaVM failed: %s\\n\", jni_error_code(res));\n+    exit(1);\n+  }\n+  printf(\"Calling DestroyJavaVM from active thread\\n\");\n+  res = (*jvm)->DestroyJavaVM(jvm);\n+  printf(\"DestroyJavaVM returned: %s\\n\", jni_error_code(res));\n+  return res == JNI_OK;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/activeDestroy\/libactiveDestroy.c","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+ * @library \/testlibrary\n@@ -38,0 +39,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -66,1 +69,1 @@\n-        t.suspend();\n+        JVMTIUtils.suspendThread(t);\n@@ -68,1 +71,1 @@\n-        t.resume();\n+        JVMTIUtils.resumeThread(t);\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/terminatedThread\/TestTerminatedThread.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,0 +51,13 @@\n+    class EmptyDelegatingLoader extends ClassLoader {\n+        EmptyDelegatingLoader(String name, ClassLoader parent) {\n+            super(name, parent);\n+        }\n+    }\n+\n+    static void loadTestClassInLoaderAndCheck(String classname, ClassLoader loader) throws ClassNotFoundException {\n+        Class<?> c = Class.forName(classname, true, loader);\n+        if (c.getClassLoader() != loader) {\n+            Assert.fail(classname + \" defined by wrong classloader: \" + c.getClassLoader());\n+        }\n+    }\n+\n@@ -63,0 +76,1 @@\n+        \/\/ A) one unnamed, two named loaders\n@@ -64,5 +78,0 @@\n-        Class<?> c1 = Class.forName(\"TestClass2\", true, unnamed_cl);\n-        if (c1.getClassLoader() != unnamed_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c1.getClassLoader());\n-        }\n-\n@@ -70,5 +79,0 @@\n-        Class<?> c2 = Class.forName(\"TestClass2\", true, named_cl);\n-        if (c2.getClassLoader() != named_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c2.getClassLoader());\n-        }\n-\n@@ -76,4 +80,35 @@\n-        Class<?> c3 = Class.forName(\"TestClass2\", true, named_child_cl);\n-        if (c3.getClassLoader() != named_child_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c3.getClassLoader());\n-        }\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", unnamed_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_cl);\n+\n+        \/\/ B) A named CL with empty loaders as parents (JDK-8293156)\n+        EmptyDelegatingLoader emptyLoader1 = new EmptyDelegatingLoader(\"EmptyLoader1\", null);\n+        EmptyDelegatingLoader emptyLoader2 = new EmptyDelegatingLoader(\"EmptyLoader2\", emptyLoader1);\n+        ClassLoader named_child_2_cl = new TestClassLoader(\"Child2\", emptyLoader2);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_2_cl);\n+\n+        \/\/ C) Test output for several class loaders, same class, same name, empty parents,\n+        \/\/    and all these should be folded by default.\n+        EmptyDelegatingLoader emptyLoader3 = new EmptyDelegatingLoader(\"EmptyLoader3\", null);\n+        EmptyDelegatingLoader emptyLoader4 = new EmptyDelegatingLoader(\"EmptyLoader4\", emptyLoader3);\n+        ClassLoader named_child_3_cl = new TestClassLoader(\"ChildX\", emptyLoader4); \/\/ Same names\n+        ClassLoader named_child_4_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        ClassLoader named_child_5_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        ClassLoader named_child_6_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_3_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_4_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_5_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_6_cl);\n+\n+        \/\/ D) Test output for several *unnamed* class loaders, same class, same parents,\n+        \/\/    and all these should be folded by default too.\n+        EmptyDelegatingLoader emptyLoader5 = new EmptyDelegatingLoader(null, null);\n+        EmptyDelegatingLoader emptyLoader6 = new EmptyDelegatingLoader(null, emptyLoader5);\n+        ClassLoader named_child_7_cl = new TestClassLoader(null, emptyLoader6); \/\/ Same names\n+        ClassLoader named_child_8_cl = new TestClassLoader(null, emptyLoader6);\n+        ClassLoader named_child_9_cl = new TestClassLoader(null, emptyLoader6);\n+        ClassLoader named_child_10_cl = new TestClassLoader(null, emptyLoader6);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_7_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_8_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_9_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_10_cl);\n@@ -83,4 +118,19 @@\n-        output.shouldContain(\"<bootstrap>\");\n-        output.shouldMatch(\".*TestClassLoader\");\n-        output.shouldMatch(\"Kevin.*TestClassLoader\");\n-        output.shouldMatch(\"Bill.*TestClassLoader\");\n+        \/\/ (A)\n+        output.shouldContain(\"+-- <bootstrap>\");\n+        output.shouldContain(\"      +-- \\\"platform\\\", jdk.internal.loader.ClassLoaders$PlatformClassLoader\");\n+        output.shouldContain(\"      |     +-- \\\"app\\\", jdk.internal.loader.ClassLoaders$AppClassLoader\");\n+        output.shouldContain(\"      +-- \\\"Kevin\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        output.shouldContain(\"      +-- ClassLoaderHierarchyTest$TestClassLoader\");\n+        output.shouldContain(\"      |     +-- \\\"Bill\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        \/\/ (B)\n+        output.shouldContain(\"      +-- \\\"EmptyLoader1\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |     +-- \\\"EmptyLoader2\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |           +-- \\\"Child2\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        \/\/ (C)\n+        output.shouldContain(\"      +-- \\\"EmptyLoader3\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |     +-- \\\"EmptyLoader4\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |           +-- \\\"ChildX\\\", ClassLoaderHierarchyTest$TestClassLoader (+ 3 more)\");\n+        \/\/ (D)\n+        output.shouldContain(\"      +-- ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"            +-- ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"                  +-- ClassLoaderHierarchyTest$TestClassLoader (+ 3 more)\");\n@@ -92,3 +142,2 @@\n-        output.shouldMatch(\".*TestClassLoader\");\n-        output.shouldMatch(\"Kevin.*TestClassLoader\");\n-        output.shouldMatch(\"Bill.*TestClassLoader\");\n+        output.shouldContain(\"java.lang.Enum\");\n+        output.shouldContain(\"java.lang.NullPointerException\");\n@@ -96,0 +145,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ClassLoaderHierarchyTest.java","additions":71,"deletions":21,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- *     a thread and for various thread states calls Thread.suspend()\/resume()\n- *     methods or JVMDI functions SuspendThread\/ResumeThread. Then native method\n+ *     a thread and for various thread states calls\n+ *     JVMTI functions SuspendThread\/ResumeThread. Then native method\n@@ -123,9 +123,0 @@\n-            thr.suspend();\n-            System.out.println(\"thrstat02.meth after thr.suspend()\");\n-            checkStatus(STATUS_MONITOR, true);\n-            System.out.println(\"thrstat02.meth after checkStatus(STATUS_MONITOR,true)\");\n-\n-            thr.resume();\n-            System.out.println(\"thrstat02.meth after thr.resume()\");\n-            checkStatus(STATUS_MONITOR, false);\n-            System.out.println(\"thrstat02.meth after checkStatus(STATUS_MONITOR,false)\");\n@@ -136,4 +127,0 @@\n-        thr.suspend();\n-        checkStatus(STATUS_RUNNING, true);\n-        thr.resume();\n-        checkStatus(STATUS_RUNNING, false);\n@@ -143,4 +130,0 @@\n-            checkStatus(STATUS_WAIT, false);\n-            thr.suspend();\n-            checkStatus(STATUS_WAIT, true);\n-            thr.resume();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetThreadState\/thrstat02\/thrstat02.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,25 @@\n+    public static int JVMTI_ERROR_NONE = 0;\n+\n+    public static int JVMTI_ERROR_THREAD_NOT_SUSPENDED = 13;\n+    public static int JVMTI_ERROR_THREAD_SUSPENDED = 14;\n+    public static int JVMTI_ERROR_THREAD_NOT_ALIVE = 15;\n+\n+\n+    public static class JvmtiException extends RuntimeException {\n+\n+        private int code;\n+\n+        public JvmtiException(int code) {\n+            this.code = code;\n+        }\n+\n+        public int getCode() {\n+            return code;\n+        }\n+\n+        @Override\n+        public String getMessage(){\n+            return \"JVMTI ERROR: \" + code;\n+        }\n+    }\n+\n@@ -42,0 +67,17 @@\n+\n+    private static native int suspendThread0(Thread t);\n+    private static native int resumeThread0(Thread t);\n+\n+    public static void suspendThread(Thread t) {\n+        int err = suspendThread0(t);\n+        if (err != JVMTI_ERROR_NONE) {\n+            throw new JvmtiException(err);\n+        }\n+    }\n+    public static void resumeThread(Thread t) {\n+        int err = resumeThread0(t);\n+        if (err != JVMTI_ERROR_NONE) {\n+            throw new JvmtiException(err);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jvmti\/JVMTIUtils.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  caps.can_suspend = 1;\n@@ -55,1 +56,1 @@\n-    LOG(\"JVMTI_ERROR_THREAD_NOT_ALIVE happened\");\n+    LOG(\"JVMTI_ERROR_THREAD_NOT_ALIVE happened\\n\");\n@@ -61,0 +62,10 @@\n+JNIEXPORT jint JNICALL\n+Java_jvmti_JVMTIUtils_suspendThread0(JNIEnv *jni, jclass cls, jthread thread) {\n+  return jvmti->SuspendThread(thread);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jvmti_JVMTIUtils_resumeThread0(JNIEnv *jni, jclass cls, jthread thread) {\n+  return jvmti->ResumeThread(thread);\n+}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jvmti\/libJvmtiUtils.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,0 @@\n-    static final int MAX_CASE = 2;\n-\n@@ -172,1 +170,0 @@\n-        for (int i = 0; i < MAX_CASE; i++) {\n@@ -174,7 +171,7 @@\n-            debuggee.sendSignal(\"newcheck\");\n-            try {\n-                debuggee.receiveExpectedSignal(\"checkready\");\n-            } catch (Failure e) {\n-                debuggee.quit();\n-                throw e;\n-            }\n+        debuggee.sendSignal(\"newcheck\");\n+        try {\n+            debuggee.receiveExpectedSignal(\"checkready\");\n+        } catch (Failure e) {\n+            debuggee.quit();\n+            throw e;\n+        }\n@@ -182,1 +179,1 @@\n-            log1(\"BEGIN OF CASE #\" + i);\n+        log1(\"BEGIN OF CASE #0\");\n@@ -184,5 +181,1 @@\n-            \/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ variable part\n-            switch (i) {\n-            case 0:\n-                executeCase(i, \"Thread02\");\n-                break;\n+        executeCase(0, \"Thread02\");\n@@ -190,5 +183,0 @@\n-            case 1:\n-                executeCase(i, \"Thread12\");\n-                break;\n-            }\n-        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/interrupt\/interrupt001.java","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/interrupt\/interrupt001\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+\n@@ -104,20 +105,3 @@\n-                switch (i) {\n-                case 0:\n-                    synchronized (interrupt001aThread.lockingObject) {\n-                        thread2 = threadStart(\"Thread02\");\n-                        thread3 = threadStart(\"Thread03\");\n-\n-                        pipe.println(\"checkready\");\n-                        if (checkInterruptStatus() == FAILED) {\n-                            exitCode = FAILED;\n-                            break label0;\n-                        }\n-                    }\n-                    log1(\"mainThread is out of: synchronized (lockingObject)\");\n-\n-                    if (waitThreadJoin(thread2) == FAILED) {\n-                        exitCode = FAILED;\n-                    }\n-                    if (waitThreadJoin(thread3) == FAILED) {\n-                        exitCode = FAILED;\n-                    }\n+                synchronized (interrupt001aThread.lockingObject) {\n+                    thread2 = threadStart(\"Thread02\");\n+                    thread3 = threadStart(\"Thread03\");\n@@ -125,3 +109,2 @@\n-                    instruction = pipe.readln();\n-                    if (!instruction.equals(\"continue\")) {\n-                        logErr(\"Unexpected instruction #1: \" + instruction);\n+                    pipe.println(\"checkready\");\n+                    if (checkInterruptStatus() == FAILED) {\n@@ -131,24 +114,2 @@\n-                    pipe.println(\"docontinue\");\n-                    break;\n-\n-                case 1:\n-                    synchronized (interrupt001aThread.lockingObject) {\n-                        thread2 = threadStart(\"Thread12\");\n-                        thread3 = threadStart(\"Thread13\");\n-\n-                        log1(\"suspending Thread2\");\n-                        thread2.suspend();\n-\n-                        log1(\"suspending Thread3\");\n-                        thread3.suspend();\n-\n-                        log1(\"interrupting the Thread3\");\n-                        thread3.interrupt();\n-\n-                        pipe.println(\"checkready\");\n-                        if (checkInterruptStatus() == FAILED) {\n-                            exitCode = FAILED;\n-                            break label0;\n-                        }\n-                    }\n-                    log1(\"mainThread is out of: synchronized (lockingObject)\");\n+                }\n+                log1(\"mainThread is out of: synchronized (lockingObject)\");\n@@ -156,10 +117,6 @@\n-                    log1(\"resuming Thread2\");\n-                    thread2.resume();\n-                    if (waitThreadJoin(thread2) == FAILED) {\n-                        exitCode = FAILED;\n-                    }\n-                    log1(\"resuming Thread3\");\n-                    thread3.resume();\n-                    if (waitThreadJoin(thread3) == FAILED) {\n-                        exitCode = FAILED;\n-                    }\n+                if (waitThreadJoin(thread2) == FAILED) {\n+                    exitCode = FAILED;\n+                }\n+                if (waitThreadJoin(thread3) == FAILED) {\n+                    exitCode = FAILED;\n+                }\n@@ -167,8 +124,8 @@\n-                    instruction = pipe.readln();\n-                    if (!instruction.equals(\"continue\")) {\n-                        logErr(\"Unexpected instruction #2: \" + instruction);\n-                        exitCode = FAILED;\n-                        break label0;\n-                    }\n-                    pipe.println(\"docontinue\");\n-                    break;\n+                instruction = pipe.readln();\n+                if (!instruction.equals(\"continue\")) {\n+                    logErr(\"Unexpected instruction #1: \" + instruction);\n+                    exitCode = FAILED;\n+                    break label0;\n+                }\n+                pipe.println(\"docontinue\");\n+                break;\n@@ -177,1 +134,0 @@\n-                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/interrupt\/interrupt001a.java","additions":23,"deletions":67,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import java.io.PrintStream;\n-\n-public class thrstat001 {\n-\n-    public static final int STATUS_RUNNING = 0;\n-    public static final int STATUS_MONITOR = 1;\n-    public static final int STATUS_WAIT    = 2;\n-\n-    native static void checkStatus(int statInd);\n-    native static int getRes();\n-\n-    public static void main(String[] args) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + 95\/*STATUS_TEMP*\/);\n-    }\n-\n-    public static int run(String argv[], PrintStream ref) {\n-        thrstat001 t = new thrstat001();\n-        t.meth();\n-        return getRes();\n-    }\n-\n-    \/\/ barriers for testing thread status values\n-    public static Lock startingMonitor = new Lock();\n-    public static Object blockingMonitor = new Object();\n-    public static Lock endingMonitor = new Lock();\n-\n-    void meth() {\n-        thrstat001a thr = new thrstat001a(\"thr1\");\n-\n-        synchronized (blockingMonitor) {\n-            synchronized (startingMonitor) {\n-                startingMonitor.val = 0;\n-                thr.start();\n-                while (startingMonitor.val == 0) {\n-                    try {\n-                        startingMonitor.wait();\n-                    } catch (InterruptedException e) {\n-                        throw new Error(\"Unexpected: \" + e);\n-                    }\n-                }\n-            }\n-            Thread.yield();\n-            checkStatus(STATUS_MONITOR);\n-        }\n-\n-        synchronized (endingMonitor) {\n-            checkStatus(STATUS_WAIT);\n-            endingMonitor.val++;\n-            endingMonitor.notify();\n-        }\n-\n-        try {\n-            thr.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-   }\n-\n-    static class Lock {\n-        public int val = 0;\n-    }\n-}\n-\n-class thrstat001a extends Thread {\n-\n-    public thrstat001a(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-        synchronized (thrstat001.endingMonitor) {\n-            thrstat001.checkStatus(thrstat001.STATUS_RUNNING);\n-            synchronized (thrstat001.startingMonitor) {\n-                thrstat001.startingMonitor.val++;\n-                thrstat001.startingMonitor.notifyAll();\n-            }\n-\n-            synchronized (thrstat001.blockingMonitor) {\n-            }\n-\n-            thrstat001.endingMonitor.val = 0;\n-            while (thrstat001.endingMonitor.val == 0) {\n-                try {\n-                    thrstat001.endingMonitor.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat001.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_logic, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetThreadState.  Java program\n- *     launchs thread and 3 times calls a native method checkStatus. This\n- *     method calls GetThreadState and checks if the returned value is\n- *     correct.\n- *     The test exercises JVMTI function GetThreadState.  Java program\n- *     launches a thread and 3 times calls a native method checkStatus.\n- *     This method calls GetThreadState and checks if the returned value is:\n- *       - JVMTI_THREAD_STATE_RUNNABLE\n- *               if thread is runnable\n- *       - JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\n- *               if thread is waiting to enter sync. block\n- *       - JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n- *               if thread is waiting by object.wait()\n- *     The test also enables JVMPI_EVENT_METHOD_ENTRY and JVMPI_EVENT_METHOD_EXIT\n- *     events and checks if GetThreadState returns JVMPI_THREAD_RUNNABLE for\n- *     their threads.\n- *     Failing criteria for the test are:\n- *       - value returned by GetThreadState does not match expected value;\n- *       - failures of used JVMTI functions.\n- * COMMENTS\n- *     Converted the test to use GetThreadState instead of GetThreadStatus.\n- *     The test was updated to be more precise in its thread state transitions.\n- *     Fixed according to 4387521 bug.\n- *     To fix bug 4463667,\n- *         1) two code fragments with \"Thread.sleep(500);\" are replaced\n- *            with following ones:\n- *                 Object obj = new Object();\n- *                 *\n- *                 *\n- *                 synchronized (obj) {\n- *                     obj.wait(500);\n- *                 }\n- *         2) extra waiting time\n- *                 synchronized (obj) {\n- *                     obj.wait(500);\n- *                 }\n- *            is added to get waiting time certainly after \"contendCount\"\n- *            is set to 1.\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *     Fixed according to 4925857 bug:\n- *       - rearranged synchronization of tested thread\n- *       - enhanced descripton\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat001 nsk.jvmti.GetThreadState.thrstat001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/TestDescription.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/libthrstat001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED  0\n-#define STATUS_FAILED  2\n-#define WAIT_START 100\n-#define WAIT_TIME (2*60*1000)\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID access_lock;\n-static jrawMonitorID wait_lock;\n-static jint result = PASSED;\n-static jthread thr_ptr = NULL;\n-\n-static jint state[] = {\n-    JVMTI_THREAD_STATE_RUNNABLE,\n-    JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,\n-    JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n-};\n-\n-static void\n-lock(const char* func_name, jrawMonitorID lock) {\n-    jvmtiError err = jvmti->RawMonitorEnter(lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"%s: unexpected error in RawMonitorEnter: %s (%d)\\n\",\n-               func_name, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-static void\n-unlock(const char* func_name, jrawMonitorID lock) {\n-    jvmtiError err = jvmti->RawMonitorExit(lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"%s: unexpected error in RawMonitorExit: %s (%d)\\n\",\n-               func_name, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-static void\n-wait(const char* func_name, jrawMonitorID lock, jint millis) {\n-    jvmtiError err = jvmti->RawMonitorWait(lock, (jlong)millis);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"%s: unexpected error in RawMonitorWait: %s (%d)\\n\",\n-               func_name, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-static void\n-set_notification_mode(const char* event_name,\n-                      jvmtiEventMode mode,\n-                      jvmtiEvent event_type,\n-                      jthread event_thread) {\n-    const char* action = (mode == JVMTI_ENABLE) ? \"enable\" : \"disable\";\n-    jvmtiError err = jvmti->SetEventNotificationMode(mode, event_type, event_thread);\n-\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to %s %s event: %s (%d)\\n\",\n-               action, event_name, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-void JNICALL VMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr) {\n-    set_notification_mode(\"JVMTI_EVENT_THREAD_START\", JVMTI_ENABLE,\n-                          JVMTI_EVENT_THREAD_START, NULL);\n-}\n-\n-void JNICALL\n-ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiThreadInfo thrInfo;\n-\n-    lock(\"ThreadStart\", access_lock);\n-\n-    err = jvmti_env->GetThreadInfo(thread, &thrInfo);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo#TS) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (thrInfo.name != NULL && strcmp(thrInfo.name, \"thr1\") == 0) {\n-        thr_ptr = env->NewGlobalRef(thread);\n-        printf(\">>> ThreadStart: \\\"%s\\\", 0x%p\\n\", thrInfo.name, thr_ptr);\n-        set_notification_mode(\"JVMTI_EVENT_THREAD_START\", JVMTI_DISABLE,\n-                              JVMTI_EVENT_THREAD_START, NULL);\n-    }\n-\n-    unlock(\"ThreadStart\", access_lock);\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    printf(\"Agent_Initialize started\\n\");\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_access_lock\", &access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor)#access_lock unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor#wait_lock) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.VMInit = &VMInit;\n-    callbacks.ThreadStart = &ThreadStart;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    set_notification_mode(\"JVMTI_EVENT_VM_INIT\", JVMTI_ENABLE,\n-                          JVMTI_EVENT_VM_INIT, NULL);\n-\n-    printf(\"Agent_Initialize finished\\n\\n\");\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat001_checkStatus(JNIEnv *env,\n-        jclass cls, jint statInd) {\n-    jvmtiError err;\n-    jint thrState;\n-    jint millis;\n-\n-    printf(\"native method checkStatus started\\n\");\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (thr_ptr == NULL) {\n-        printf(\"Missing thread \\\"thr1\\\" start event\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    \/* wait until thread gets an expected state *\/\n-    for (millis = WAIT_START; millis < WAIT_TIME; millis <<= 1) {\n-        err = jvmti->GetThreadState(thr_ptr, &thrState);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetThreadState#%d) unexpected error: %s (%d)\\n\",\n-                statInd, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        if ((thrState & state[statInd]) != 0) {\n-            break;\n-        }\n-        lock(\"checkStatus\", wait_lock);\n-        wait(\"checkStatus\", wait_lock, millis);\n-        unlock(\"checkStatus\", wait_lock);\n-    }\n-\n-    printf(\">>> thread \\\"thr1\\\" (0x%p) state: %s (%d)\\n\",\n-            thr_ptr, TranslateState(thrState), thrState);\n-\n-    if ((thrState & state[statInd]) == 0) {\n-        printf(\"Wrong thread \\\"thr1\\\" (0x%p) state:\\n\", thr_ptr);\n-        printf(\"    expected: %s (%d)\\n\",\n-            TranslateState(state[statInd]), state[statInd]);\n-        printf(\"      actual: %s (%d)\\n\",\n-            TranslateState(thrState), thrState);\n-        result = STATUS_FAILED;\n-    }\n-    printf(\"native method checkStatus finished\\n\\n\");\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat001_getRes(JNIEnv *env, jclass cls) {\n-    printf(\"native method getRes: result: %d\\n\\n\", result);\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat001\/thrstat001.cpp","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -1,194 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import nsk.share.Wicket;\n-import java.io.PrintStream;\n-\n-public class thrstat002 {\n-\n-    public static final int STATUS_RUNNING = 0;\n-    public static final int STATUS_MONITOR = 1;\n-    public static final int STATUS_WAIT    = 2;\n-\n-    native static void init(int waitTime);\n-    native static void checkStatus(int statInd, boolean susp);\n-    native static int getRes();\n-\n-    public static void main(String[] args) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + 95\/*STATUS_TEMP*\/);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int waitTime = 2;\n-        if (args.length > 0) {\n-            try {\n-                int i  = Integer.parseInt(args[0]);\n-                waitTime = i;\n-            } catch (NumberFormatException ex) {\n-                out.println(\"# Wrong argument \\\"\" + args[0]\n-                    + \"\\\", the default value is used\");\n-            }\n-        }\n-        out.println(\"# Waiting time = \" + waitTime + \" mins\");\n-        init(waitTime);\n-        new thrstat002().meth();\n-        return getRes();\n-    }\n-\n-    public static Wicket startingBarrier;\n-    public static Wicket runningBarrier;\n-    public static Object blockingMonitor = new Object();\n-    public static Lock endingMonitor = new Lock();\n-\n-    static volatile boolean targetAboutToLock = false;\n-\n-    void meth() {\n-        thrstat002a thr = new thrstat002a(\"thr1\");\n-        startingBarrier = new Wicket();\n-        runningBarrier = new Wicket();\n-\n-        synchronized (blockingMonitor) {\n-            thr.start();\n-            System.out.println(\"thrstat002.meth after thr.start()\");\n-\n-            startingBarrier.waitFor();\n-            System.out.println(\"thrstat002.meth after thr.startingBarrier.waitFor()\");\n-\n-            waitForThreadBlocked(thr);\n-\n-            checkStatus(STATUS_MONITOR, false);\n-            System.out.println(\"thrstat002.meth after checkStatus(STATUS_MONITOR,false)\");\n-\n-            thr.suspend();\n-            System.out.println(\"thrstat002.meth after thr.suspend()\");\n-            checkStatus(STATUS_MONITOR, true);\n-            System.out.println(\"thrstat002.meth after checkStatus(STATUS_MONITOR,true)\");\n-\n-            thr.resume();\n-            System.out.println(\"thrstat002.meth after thr.resume()\");\n-            checkStatus(STATUS_MONITOR, false);\n-            System.out.println(\"thrstat002.meth after checkStatus(STATUS_MONITOR,false)\");\n-        }\n-\n-        runningBarrier.waitFor();\n-        checkStatus(STATUS_RUNNING, false);\n-        thr.suspend();\n-        checkStatus(STATUS_RUNNING, true);\n-        thr.resume();\n-        checkStatus(STATUS_RUNNING, false);\n-        thr.letItGo();\n-\n-        synchronized (endingMonitor) {\n-            checkStatus(STATUS_WAIT, false);\n-            thr.suspend();\n-            checkStatus(STATUS_WAIT, true);\n-            thr.resume();\n-            checkStatus(STATUS_WAIT, false);\n-            endingMonitor.val++;\n-            endingMonitor.notifyAll();\n-        }\n-\n-        try {\n-            thr.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-    }\n-\n-    private static void waitForThreadBlocked(Thread t) {\n-        \/\/ Ensure that the thread is blocked on the right monitor\n-        while (!targetAboutToLock || t.getState() != Thread.State.BLOCKED) {\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException ex) {\n-                System.out.println(\"thrstat002.waitForThreadBlocked was interrupted: \" + ex.getMessage());\n-            }\n-        }\n-    }\n-\n-    static class Lock {\n-        public int val = 0;\n-    }\n-}\n-\n-class thrstat002a extends Thread {\n-    private volatile boolean flag = true;\n-\n-    public thrstat002a(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-        synchronized (thrstat002.endingMonitor) {\n-            System.out.println(\"thrstat002a.run before startingBarrier.unlock\");\n-            thrstat002.startingBarrier.unlock();\n-\n-            System.out.println(\"thrstat002a.run after  startingBarrier.unlock\");\n-\n-            System.out.println(\"thrstat002a.run before blockingMonitor lock\");\n-\n-            thrstat002.targetAboutToLock = true;\n-\n-            synchronized (thrstat002.blockingMonitor) {\n-               System.out.println(\"thrstat002a.run blockingMonitor locked\");\n-            }\n-            System.out.println(\"thrstat002a.run after blockingMonitor lock\");\n-\n-            System.out.println(\"thrstat002a.run before runningBarrier unlock\");\n-            thrstat002.runningBarrier.unlock();\n-\n-            \/\/ Don't do println's from this point until we have exited the loop,\n-            \/\/ else we can suspend in the println in an unexpected state.\n-            int i = 0;\n-            int n = 1000;\n-            while (flag) {\n-                if (n <= 0) {\n-                    n = 1000;\n-                }\n-                if (i > n) {\n-                    i = 0;\n-                    n--;\n-                }\n-                i++;\n-            }\n-\n-            thrstat002.endingMonitor.val = 0;\n-            while (thrstat002.endingMonitor.val == 0) {\n-                try {\n-                    thrstat002.endingMonitor.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-            System.out.println(\"thrstat002a.run before endingMonitor unlock\");\n-       }\n-    }\n-\n-    public void letItGo() {\n-        flag = false;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002.java","additions":0,"deletions":194,"binary":false,"changes":194,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat002.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_logic, noras, quarantine]\n- * VM Testbase comments: 6260469\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMDI function GetThreadState.  Java program launches\n- *     a thread and for various thread states calls Thread.suspend()\/resume()\n- *     methods or JVMDI functions SuspendThread\/ResumeThread. Then native method\n- *     checkStatus is invoked. This method calls GetThreadState and checks if\n- *     the returned values are correct and JVMTI_THREAD_STATE_SUSPENDED bit\n- *     is set (or clear after resume).\n- *     The thread statuses are:\n- *       - JVMTI_THREAD_STATE_RUNNABLE\n- *               if thread is runnable\n- *       - JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\n- *               if thread is waiting to enter sync. block\n- *       - JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n- *               if thread is waiting by object.wait()\n- *     Failing criteria for the test are:\n- *       - values returned by GetThreadState are not the same as expected;\n- *       - failure of used JVMTI functions.\n- * COMMENTS\n- *     Converted the test to use GetThreadState instead of GetThreadStatus.\n- *     Fixed according to 4387521 and 4427103 bugs.\n- *     Fixed according to 4463667 bug.\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *     Fixed according to 4925857 bug:\n- *       - rearranged synchronization of tested thread\n- *       - enhanced descripton\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat002 nsk.jvmti.GetThreadState.thrstat002 5\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/TestDescription.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/libthrstat002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,470 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED  0\n-#define STATUS_FAILED  2\n-#define WAIT_START 100\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID access_lock, wait_lock;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jthread thr_ptr = NULL;\n-static jint wait_time = 0;\n-static jint state[] = {\n-    JVMTI_THREAD_STATE_RUNNABLE,\n-    JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,\n-    JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n-};\n-\n-\n-#if 1 \/\/ support for debug tracing\n-\n-#define LOG(...) \\\n-  { \\\n-    printf(__VA_ARGS__); \\\n-    fflush(stdout); \\\n-  }\n-\n-#define MAX_FRAME_COUNT_PRINT_STACK_TRACE 200\n-\n-static void\n-check_jvmti_status(JNIEnv* jni, jvmtiError err, const char* msg) {\n-  if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"check_jvmti_status: JVMTI function returned error: %s (%d)\\n\", TranslateError(err), err);\n-    jni->FatalError(msg);\n-  }\n-}\n-\n-static void\n-deallocate(jvmtiEnv *jvmti, JNIEnv* jni, void* ptr) {\n-  jvmtiError err;\n-\n-  err = jvmti->Deallocate((unsigned char*)ptr);\n-  check_jvmti_status(jni, err, \"deallocate: error in JVMTI Deallocate call\");\n-}\n-\n-static char*\n-get_method_class_name(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method) {\n-  jclass klass = NULL;\n-  char*  cname = NULL;\n-  char*  result = NULL;\n-  jvmtiError err;\n-\n-  err = jvmti->GetMethodDeclaringClass(method, &klass);\n-  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI GetMethodDeclaringClass\");\n-\n-  err = jvmti->GetClassSignature(klass, &cname, NULL);\n-  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI GetClassSignature\");\n-\n-  size_t len = strlen(cname) - 2; \/\/ get rid of leading 'L' and trailing ';'\n-\n-  err = jvmti->Allocate((jlong)(len + 1), (unsigned char**)&result);\n-  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI Allocate\");\n-\n-  strncpy(result, cname + 1, len); \/\/ skip leading 'L'\n-  result[len] = '\\0';\n-  deallocate(jvmti, jni, (void*)cname);\n-  return result;\n-}\n-\n-static void\n-print_method(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method, jint depth) {\n-  char*  cname = NULL;\n-  char*  mname = NULL;\n-  char*  msign = NULL;\n-  jvmtiError err;\n-\n-  cname = get_method_class_name(jvmti, jni, method);\n-\n-  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n-  check_jvmti_status(jni, err, \"print_method: error in JVMTI GetMethodName\");\n-\n-  LOG(\"%2d: %s: %s%s\\n\", depth, cname, mname, msign);\n-  fflush(0);\n-  deallocate(jvmti, jni, (void*)cname);\n-  deallocate(jvmti, jni, (void*)mname);\n-  deallocate(jvmti, jni, (void*)msign);\n-}\n-\n-static char*\n-get_thread_name(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n-  jvmtiThreadInfo thr_info;\n-  jvmtiError err;\n-\n-  memset(&thr_info, 0, sizeof(thr_info));\n-  err = jvmti->GetThreadInfo(thread, &thr_info);\n-  check_jvmti_status(jni, err, \"get_thread_name: error in JVMTI GetThreadInfo call\");\n-\n-  return thr_info.name == NULL ? (char*)\"<Unnamed thread>\" : thr_info.name;\n-}\n-\n-static void\n-print_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n-  jvmtiFrameInfo frames[MAX_FRAME_COUNT_PRINT_STACK_TRACE];\n-  char* tname = get_thread_name(jvmti, jni, thread);\n-  jint count = 0;\n-  jvmtiError err;\n-\n-  err = jvmti->GetStackTrace(thread, 0, MAX_FRAME_COUNT_PRINT_STACK_TRACE, frames, &count);\n-  check_jvmti_status(jni, err, \"print_stack_trace: error in JVMTI GetStackTrace\");\n-\n-  LOG(\"JVMTI Stack Trace for thread %s: frame count: %d\\n\", tname, count);\n-  for (int depth = 0; depth < count; depth++) {\n-    print_method(jvmti, jni, frames[depth].method, depth);\n-  }\n-  deallocate(jvmti, jni, (void*)tname);\n-  LOG(\"\\n\");\n-}\n-#endif \/\/ support for debug tracing\n-\n-void printStateFlags(jint flags) {\n-    if (flags & JVMTI_THREAD_STATE_SUSPENDED)\n-        printf(\" JVMTI_THREAD_STATE_SUSPENDED\");\n-    if (flags & JVMTI_THREAD_STATE_INTERRUPTED)\n-        printf(\" JVMTI_THREAD_STATE_INTERRUPTED\");\n-    if (flags & JVMTI_THREAD_STATE_IN_NATIVE)\n-        printf(\" JVMTI_THREAD_STATE_IN_NATIVE\");\n-    printf(\" (0x%0x)\\n\", flags);\n-}\n-\n-void JNICALL VMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr) {\n-    jvmtiError err;\n-\n-    err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_THREAD_START, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable THREAD_START event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-void JNICALL\n-ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiThreadInfo thrInfo;\n-    jvmtiError err;\n-\n-    err = jvmti_env->RawMonitorEnter(access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti_env->GetThreadInfo(thread, &thrInfo);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (thrInfo.name != NULL && strcmp(thrInfo.name, \"thr1\") == 0) {\n-        thr_ptr = env->NewGlobalRef(thread);\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> ThreadStart: \\\"%s\\\", 0x%p\\n\", thrInfo.name, thr_ptr);\n-        }\n-    }\n-\n-    err = jvmti_env->RawMonitorExit(access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        printf(\"Warning: suspend\/resume is not implemented\\n\");\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_access_lock\", &access_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.VMInit = &VMInit;\n-    callbacks.ThreadStart = &ThreadStart;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_VM_INIT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable VM_INIT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat002_init(JNIEnv *env, jclass cls,\n-        jint waitTime) {\n-    wait_time = waitTime * 60000;\n-}\n-\n-void wait_for(jint millis) {\n-    jvmtiError err;\n-\n-    err = jvmti->RawMonitorEnter(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter#check) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorWait(wait_lock, (jlong)millis);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorWait#check) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorExit(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorExit#check) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat002_checkStatus(JNIEnv *env, jclass cls,\n-        jint statInd, jboolean suspended) {\n-    jint thrState;\n-    jint suspState = -1;\n-    jint right_stat = (suspended ? JVMTI_THREAD_STATE_SUSPENDED : 0);\n-    jvmtiError right_ans = (suspended ? JVMTI_ERROR_THREAD_SUSPENDED : JVMTI_ERROR_NONE);\n-    const char *suspStr = (suspended ? \", suspended\" : \"\");\n-    jvmtiError err;\n-    jint millis;\n-    jboolean timeout_is_reached;\n-    unsigned int waited_millis;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (thr_ptr == NULL) {\n-        printf(\"Missing thread \\\"thr1\\\" start event\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        return;\n-    }\n-\n-    printf(\"START checkStatus for \\\"thr1\\\" (0x%p%s), check state: %s\\n\",\n-           thr_ptr, suspStr, TranslateState(state[statInd]));\n-\n-    timeout_is_reached = JNI_TRUE;\n-    for (millis = WAIT_START, waited_millis=0; millis < wait_time; millis <<= 1) {\n-        err = jvmti->GetThreadState(thr_ptr, &thrState);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetThreadState#%d) unexpected error: %s (%d)\\n\",\n-                statInd, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            timeout_is_reached = JNI_FALSE;\n-            break;\n-        }\n-        suspState = thrState & JVMTI_THREAD_STATE_SUSPENDED;\n-        if (suspended || (thrState & JVMTI_THREAD_STATE_RUNNABLE) == 0 ||\n-            (state[statInd] == JVMTI_THREAD_STATE_RUNNABLE)) {\n-            timeout_is_reached = JNI_FALSE;\n-            break;\n-        }\n-\n-        waited_millis += millis;\n-        wait_for(millis);\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> thread \\\"thr1\\\" (0x%p) state: %s (%d)\\n\",\n-            thr_ptr, TranslateState(thrState), thrState);\n-        printf(\">>>\\tflags:\");\n-        printStateFlags(suspState);\n-    }\n-\n-    if (timeout_is_reached == JNI_TRUE) {\n-        printf(\"Error: timeout (%d secs) has been reached\\n\", waited_millis\/1000);\n-    }\n-    if ((thrState & state[statInd]) == 0) {\n-        printf(\"Wrong thread \\\"thr1\\\" (0x%p%s) state:\\n\", thr_ptr, suspStr);\n-        printf(\"    expected: %s (%d)\\n\",\n-            TranslateState(state[statInd]), state[statInd]);\n-        printf(\"      actual: %s (%d)\\n\",\n-            TranslateState(thrState), thrState);\n-        result = STATUS_FAILED;\n-    }\n-    if (suspState != right_stat) {\n-        printf(\"Wrong thread \\\"thr1\\\" (0x%p%s) state flags:\\n\",\n-               thr_ptr, suspStr);\n-        printf(\"    expected:\");\n-        printStateFlags(right_stat);\n-        printf(\"    actual:\");\n-        printStateFlags(suspState);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SuspendThread(thr_ptr);\n-    if (err != right_ans) {\n-        printf(\"Wrong result of SuspendThread() for \\\"thr1\\\" (0x%p%s):\\n\",\n-               thr_ptr, suspStr);\n-        printf(\"    expected: %s (%d), actual: %s (%d)\\n\",\n-            TranslateError(right_ans), right_ans, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (!suspended) {\n-        \/\/ wait till thread is not suspended\n-        timeout_is_reached = JNI_TRUE;\n-        for (millis = WAIT_START, waited_millis=0; millis < wait_time; millis <<= 1) {\n-            waited_millis += millis;\n-            wait_for(millis);\n-            err = jvmti->GetThreadState(thr_ptr, &thrState);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(GetThreadState#%d,after) unexpected error: %s (%d)\\n\",\n-                    statInd, TranslateError(err), err);\n-                timeout_is_reached = JNI_FALSE;\n-                result = STATUS_FAILED;\n-                break;\n-            }\n-            suspState = thrState & JVMTI_THREAD_STATE_SUSPENDED;\n-            if (suspState) {\n-                timeout_is_reached = JNI_FALSE;\n-                break;\n-            }\n-        }\n-\n-        if (timeout_is_reached == JNI_TRUE) {\n-            printf(\"Error: timeout (%d secs) has been reached\\n\", waited_millis\/1000);\n-        }\n-        if ((thrState & state[statInd]) == 0) {\n-            printf(\"Wrong thread \\\"thr1\\\" (0x%p) state after SuspendThread:\\n\",\n-                thr_ptr);\n-            printf(\"    expected: %s (%d)\\n\",\n-                TranslateState(state[statInd]), state[statInd]);\n-            printf(\"      actual: %s (%d)\\n\",\n-                TranslateState(thrState), thrState);\n-#ifdef DBG\n-            print_stack_trace(jvmti, env, thr_ptr);\n-#endif\n-            result = STATUS_FAILED;\n-        }\n-        if (suspState != JVMTI_THREAD_STATE_SUSPENDED) {\n-            printf(\"Wrong thread \\\"thr1\\\" (0x%p) state flags\", thr_ptr);\n-            printf(\" after SuspendThread:\\n\");\n-            printf(\"    expected:\");\n-            printStateFlags(JVMTI_THREAD_STATE_SUSPENDED);\n-            printf(\"    actual:\");\n-            printStateFlags(suspState);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->ResumeThread(thr_ptr);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(ResumeThread#%d) unexpected error: %s (%d)\\n\",\n-                statInd, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-    fflush(0);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat002_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat002\/thrstat002.cpp","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import java.io.PrintStream;\n-\n-public class thrstat003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    static final int NOT_STARTED = 0;\n-    static final int SLEEPING = 1;\n-    static final int ZOMBIE = 2;\n-\n-    native static void init(int waitTime);\n-    native static int check(Thread thread, int status);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    static int contendCount = 0;\n-    public static Object lock = new Object();\n-    public static int waitTime = 2;\n-\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            try {\n-                int i  = Integer.parseInt(args[0]);\n-                waitTime = i;\n-            } catch (NumberFormatException ex) {\n-                out.println(\"# Wrong argument \\\"\" + args[0]\n-                    + \"\\\", the default value is used\");\n-            }\n-        }\n-        out.println(\"# Waiting time = \" + waitTime + \" mins\");\n-\n-        init(waitTime);\n-\n-        TestThread t = new TestThread();\n-\n-        check(t, NOT_STARTED);\n-\n-        synchronized (lock) {\n-            t.start();\n-            try {\n-                lock.wait();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-\n-        }\n-\n-        check(t, SLEEPING);\n-\n-        t.interrupt();\n-        try {\n-            t.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-\n-        return check(t, ZOMBIE);\n-    }\n-\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            synchronized (lock) {\n-                lock.notify();\n-            }\n-            try {\n-                sleep(waitTime*60000);\n-            } catch (InterruptedException e) {\n-                \/\/ OK, it's expected\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetThreadState.\n- *     The test checks if the function returns:\n- *       - NEW              if thread has not run yet\n- *       - STATE_SLEEPING   if Thread.sleep() has been called\n- *       - STATE_TERMINATED if thread has exited\n- * COMMENTS\n- *     Converted the test to use GetThreadState instead of GetThreadStatus.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat003 nsk.jvmti.GetThreadState.thrstat003 5\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003\/TestDescription.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003\/libthrstat003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-#define WAIT_START 100\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jint wait_time = 0;\n-static jint state[] = {\n-    0,                               \/*  JVMTI_THREAD_STATUS_NOT_STARTED, *\/\n-    JVMTI_THREAD_STATE_SLEEPING,\n-    JVMTI_THREAD_STATE_TERMINATED    \/*  JVMTI_THREAD_STATUS_ZOMBIE *\/\n-};\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat003_init(JNIEnv *env, jclass cls,\n-        jint waitTime) {\n-    wait_time = waitTime * 60000;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat003_check(JNIEnv *env, jclass cls,\n-        jthread thr, jint statInd) {\n-    jvmtiError err;\n-    jrawMonitorID wait_lock;\n-    jint thrState;\n-    jint i;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor#%d) unexpected error: %s (%d)\\n\",\n-               statInd, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    for (i = WAIT_START; i < wait_time; i <<= 1) {\n-        err = jvmti->GetThreadState(thr, &thrState);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetThreadState#%d) unexpected error: %s (%d)\\n\",\n-                statInd, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> thread state: %s (%d)\\n\",\n-                TranslateState(thrState), thrState);\n-        }\n-\n-        if ((thrState & JVMTI_THREAD_STATE_RUNNABLE) == 0) {\n-            break;\n-        }\n-\n-        err = jvmti->RawMonitorEnter(wait_lock);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorWait(wait_lock, (jlong)i);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorWait) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        err = jvmti->RawMonitorExit(wait_lock);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    err = jvmti->DestroyRawMonitor(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(DestroyRawMonitor#%d) unexpected error: %s (%d)\\n\",\n-               statInd, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    \/* We expect that thread is NOT_STARTED if statInd == 0 *\/\n-    if (statInd == 0 && thrState != state[statInd]) {\n-        result = STATUS_FAILED;\n-    } else if (statInd != 0 && (thrState & state[statInd]) == 0) {\n-        result = STATUS_FAILED;\n-    }\n-    if (result == STATUS_FAILED) {\n-        printf(\"Wrong state: %s (%d)\\n\", TranslateState(thrState), thrState);\n-        printf(\"   expected: %s (%d)\\n\",\n-            TranslateState(state[statInd]), state[statInd]);\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat003\/thrstat003.cpp","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import java.io.PrintStream;\n-\n-public class thrstat004 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    native static int check(Thread thr);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check(Thread.currentThread());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat004.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function\n- *       GetThreadState(thread, threadStatusPtr)\n- *     The test checks if the function returns:\n- *       - JVMTI_ERROR_NULL_POINTER if threadStatusPtr is null\n- *       - JVMTI_ERROR_NULL_POINTER if suspendStatusPtr is null\n- *       - JVMTI_ERROR_INVALID_THREAD if thread is not a thread object\n- * COMMENTS\n- *     Converted the test to use GetThreadState instead of GetThreadStatus.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat004 nsk.jvmti.GetThreadState.thrstat004\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat004.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004\/libthrstat004.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat004(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat004_check(JNIEnv *env, jclass cls, jthread thr) {\n-    jvmtiError err;\n-    jint thrState;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (threadStatePtr) null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetThreadState(thr, NULL);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"(threadStatePtr) error expected: JVMTI_ERROR_NULL_POINTER,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> invalid thread check ...\\n\");\n-    }\n-    err = jvmti->GetThreadState(cls, &thrState);\n-    if (err != JVMTI_ERROR_INVALID_THREAD) {\n-        printf(\"Error expected: JVMTI_ERROR_INVALID_THREAD,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat004\/thrstat004.cpp","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,338 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package nsk.jvmti.GetThreadState;\n-\n-import java.io.PrintStream;\n-import java.util.concurrent.*;\n-import java.util.concurrent.locks.*;\n-\n-public class thrstat005 {\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    public static final int TS_NEW        = 0;\n-    public static final int TS_TERMINATED = 1;\n-\n-    public static final int TS_RUN_RUNNING           = 2;\n-    public static final int TS_RUN_BLOCKED           = 3;\n-    public static final int TS_RUN_WAIT_TIMED        = 4;\n-    public static final int TS_RUN_WAIT_INDEF        = 5;\n-    public static final int TS_RUN_WAIT_PARKED_TIMED = 6;\n-    public static final int TS_RUN_WAIT_PARKED_INDEF = 7;\n-    public static final int TS_RUN_WAIT_SLEEP        = 8; \/* assumes _TIMED *\/\n-\n-    public static final int WAIT_TIME = 250;\n-\n-    public PrintStream _out;\n-    public Thread      _thrMain;\n-    public TestThread  _thrDummy;\n-    public int         _passCnt, _failCnt;\n-\n-    \/**\n-     * Set waiting time for checkThreadState\n-     *\/\n-    native static void setWaitTime(int sec);\n-\n-    \/**\n-     * Check that thread state (TS_xxx) is what we expect\n-     * (for TS_xxx -> JVMTI_THREAD_STATE_xxx mapping see table in thrstat005.c)\n-     *\/\n-    native static boolean checkThreadState(Thread t, int stateIdx);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return new thrstat005(out).run();\n-    }\n-\n-    thrstat005(PrintStream out) {\n-        _out = out;\n-        _thrMain = Thread.currentThread();\n-        setWaitTime(WAIT_TIME * 23 \/ 11);\n-    }\n-\n-    public int run() {\n-        _failCnt = 0;\n-        _passCnt = 0;\n-\n-        testAndPrint(\"New\", TS_NEW);\n-        testAndPrint(\"Running\", TS_RUN_RUNNING);\n-        testAndPrint(\"Blocked on monitor\", TS_RUN_BLOCKED);\n-        testAndPrint(\"Waiting with timeout\", TS_RUN_WAIT_TIMED);\n-        testAndPrint(\"Waiting forever\", TS_RUN_WAIT_INDEF);\n-        testAndPrint(\"Parking forever\", TS_RUN_WAIT_PARKED_TIMED);\n-        testAndPrint(\"Parking with timeout\", TS_RUN_WAIT_PARKED_INDEF);\n-        testAndPrint(\"Sleeping\", TS_RUN_WAIT_SLEEP);\n-        testAndPrint(\"Terminating\", TS_TERMINATED);\n-\n-        log(\">>> PASS\/FAIL: \" + _passCnt + \"\/\" + _failCnt);\n-\n-        return _failCnt > 0 ? 2 : 0;\n-    }\n-\n-    public void testAndPrint(String name, int state) {\n-        boolean fPassed;\n-\n-        try {\n-            log(\">>> Testing state: \" + name);\n-            fPassed = test(state);\n-        } catch ( BrokenBarrierException e ) {\n-            log(\"Main: broken barrier exception\");\n-            fPassed = false;\n-        } catch ( InterruptedException e ) {\n-            log(\"Main: interrupted exception\");\n-            fPassed = false;\n-        }\n-\n-        log(\">>> \" + (fPassed ? \"PASSED\" : \"FAILED\") + \" testing state: \" + name);\n-        if ( fPassed )\n-            _passCnt++;\n-        else\n-            _failCnt++;\n-    }\n-\n-    public boolean test(int state) throws BrokenBarrierException, InterruptedException {\n-        boolean fRes;\n-\n-        switch ( state ) {\n-            case TS_NEW:\n-                log(\"Main: Creating new thread\");\n-                _thrDummy = new TestThread();\n-                fRes = checkThreadState(_thrDummy, state);\n-                _thrDummy.start();\n-                return fRes;\n-\n-            case TS_RUN_RUNNING:\n-                log(\"Main: Running thread\");\n-                _thrDummy._fRun = true;\n-                fRes = sendStateAndCheckIt(state);\n-                _thrDummy._fRun = false;\n-                return fRes;\n-\n-            case TS_RUN_BLOCKED:\n-                log(\"Main: Blocking thread\");\n-                synchronized ( _thrDummy._mon ) {\n-                    return sendStateAndCheckIt(state);\n-                }\n-\n-            case TS_RUN_WAIT_TIMED:\n-            case TS_RUN_WAIT_INDEF:\n-                log(\"Main: Thread will wait\");\n-                _thrDummy._fRun = true;\n-                fRes = sendStateAndCheckIt(state);\n-\n-                _thrDummy._fRun = false;\n-                do {\n-                    log(\"Main: Notifying the thread\");\n-                    synchronized ( _thrDummy._mon ) {\n-                        _thrDummy._mon.notify();\n-                    }\n-\n-                    if ( ! _thrDummy._fInTest ) {\n-                        break;\n-                    }\n-\n-                    Thread.sleep(WAIT_TIME \/ 4);\n-                } while ( true );\n-\n-                return fRes;\n-\n-            case TS_RUN_WAIT_PARKED_TIMED:\n-            case TS_RUN_WAIT_PARKED_INDEF:\n-                log(\"Main: Thread will park\");\n-                _thrDummy._fRun = true;\n-                fRes = sendStateAndCheckIt(state);\n-\n-                _thrDummy._fRun = false;\n-                do {\n-                    log(\"Main: Unparking the thread\");\n-                    LockSupport.unpark(_thrDummy);\n-\n-                    if ( ! _thrDummy._fInTest ) {\n-                        break;\n-                    }\n-\n-                    Thread.sleep(WAIT_TIME);\n-                } while ( true );\n-\n-                return fRes;\n-\n-            case TS_RUN_WAIT_SLEEP:\n-                log(\"Main: Thread will sleep\");\n-                _thrDummy._fRun = true;\n-                fRes = sendStateAndCheckIt(state);\n-                _thrDummy._fRun = false;\n-                return fRes;\n-\n-            case TS_TERMINATED:\n-                log(\"Main: Terminating thread\");\n-                _thrDummy.sendTestState(state);\n-\n-                log(\"Main: Waiting for join\");\n-                _thrDummy.join();\n-                return checkThreadState(_thrDummy, state);\n-        }\n-\n-        return false;\n-    }\n-\n-    public boolean sendStateAndCheckIt(int state) throws BrokenBarrierException, InterruptedException {\n-        _thrDummy.sendTestState(state);\n-        while ( ! _thrDummy._fInTest ) {\n-            log(\"Main: Waiting for the thread to start the test\");\n-            Thread.sleep(WAIT_TIME * 29 \/ 7); \/\/ Wait time should not be a multiple of WAIT_TIME\n-        }\n-        return checkThreadState(_thrDummy, state);\n-    }\n-\n-    synchronized void log(String s) {\n-        _out.println(s);\n-        _out.flush();\n-    }\n-\n-    class TestThread extends Thread {\n-\n-        SynchronousQueue<Integer> _taskQueue = new SynchronousQueue<Integer>();\n-\n-        public volatile boolean _fRun = true;\n-        public volatile boolean _fInTest = false;\n-        public Object _mon = new Object();\n-\n-        public void sendTestState(int state) throws BrokenBarrierException, InterruptedException {\n-            _taskQueue.put(state);\n-        }\n-\n-        public int recvTestState() {\n-            int state = TS_NEW;\n-            try {\n-                state = _taskQueue.take();\n-            } catch ( InterruptedException e ) {\n-                log(\"Thread: interrupted exception \" + e);\n-            }\n-            return state;\n-        }\n-\n-        public void run() {\n-            log(\"Thread: started\");\n-\n-            while ( true ) {\n-                int state = recvTestState();\n-                switch ( state ) {\n-                    case TS_NEW:\n-                        log(\"Thread: ERROR IN TEST: TS_NEW\");\n-                        break;\n-\n-                    case TS_RUN_RUNNING:\n-                        int i = 0;\n-                        log(\"Thread: Running...\");\n-                        _fInTest = true;\n-                        while ( _fRun ) i++;\n-                        log(\"Thread: Running: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_BLOCKED:\n-                        log(\"Thread: Blocking...\");\n-                        _fInTest = true;\n-                        synchronized ( _mon ) {}\n-                        log(\"Thread: Blocking: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_WAIT_TIMED:\n-                        log(\"Thread: Waiting with timeout...\");\n-                        while ( _fRun ) {\n-                            synchronized ( _mon ) {\n-                                _fInTest = true;\n-                                try {\n-                                    _mon.wait(WAIT_TIME);\n-                                } catch ( InterruptedException e ) {\n-                                    log(\"Thread: Interrupted exception\");\n-                                }\n-                            }\n-                        }\n-                        log(\"Thread: Waiting: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_WAIT_INDEF:\n-                        log(\"Thread: Waiting indefinitely...\");\n-                        _fInTest = true;\n-                        synchronized ( _mon ) {\n-                            try {\n-                                _mon.wait();\n-                            } catch ( InterruptedException e ) {\n-                                log(\"Thread: Interrupted exception\");\n-                            }\n-                            log(\"Thread: Waiting: done\");\n-                            _fInTest = false;\n-                        }\n-                        break;\n-\n-                    case TS_RUN_WAIT_SLEEP:\n-                        log(\"Thread: Sleeping...\");\n-                        while ( _fRun ) {\n-                            try {\n-                                _fInTest = true;\n-                                Thread.sleep(WAIT_TIME);\n-                            } catch ( InterruptedException e ) {\n-                                log(\"Thread: Interrupted exception\");\n-                            }\n-                        }\n-                        log(\"Thread: Sleeping: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_WAIT_PARKED_TIMED:\n-                        log(\"Thread: Parking indefinitely...\");\n-                        _fInTest = true;\n-                        while ( _fRun ) {\n-                            LockSupport.park();\n-                        }\n-                        log(\"Thread: Parking: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_RUN_WAIT_PARKED_INDEF:\n-                        log(\"Thread: Parking with timeout...\");\n-                        _fInTest = true;\n-                        while ( _fRun ) {\n-                            LockSupport.parkUntil(System.currentTimeMillis() + WAIT_TIME);\n-                        }\n-                        log(\"Thread: Parking: done\");\n-                        _fInTest = false;\n-                        break;\n-\n-                    case TS_TERMINATED:\n-                        log(\"Thread: terminating\");\n-                        return;\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005.java","additions":0,"deletions":338,"binary":false,"changes":338,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadState\/thrstat005.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test verifies that the new hierarchical flags returned by GetThreadState()\n- *     are properly set in various thread states as requested in bug #5041847.\n- *     Flags being tested are:\n- *     JVMTI_THREAD_STATE_ALIVE\n- *     JVMTI_THREAD_STATE_TERMINATED\n- *     JVMTI_THREAD_STATE_RUNNABLE\n- *     JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\n- *     JVMTI_THREAD_STATE_WAITING\n- *     JVMTI_THREAD_STATE_WAITING_INDEFINITELY\n- *     JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT\n- *     JVMTI_THREAD_STATE_SLEEPING\n- *     JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n- *     JVMTI_THREAD_STATE_PARKED\n- *     The state is checked in the following test cases:\n- *     - A new thread is created\n- *     - Thread is running (doing some computations)\n- *     - Thread is blocked on a monitor (synchronized (...) { ... })\n- *     - Thread is waiting in wait(timeout)\n- *     - Thread is waiting in wait() w\/o a timeout\n- *     - Thread is parked using LockSupport.park()\n- *     - Thread is parked using LockSupport.parkUntil()\n- *     - Thread is in Thread.sleep()\n- *     - Thread has terminated\n- *     For more information see bugs #5041847, #4980307 and J2SE 5.0+ JVMTI spec.\n- * COMMENTS\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:thrstat005 nsk.jvmti.GetThreadState.thrstat005\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005\/TestDescription.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrstat005.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005\/libthrstat005.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-\n-#ifndef STANDALONE\n-#include \"JVMTITools.h\"\n-#endif\n-\n-extern \"C\" {\n-\n-\n-#define THREAD_STATE_MASK ~(JVMTI_THREAD_STATE_SUSPENDED \\\n-                            | JVMTI_THREAD_STATE_INTERRUPTED \\\n-                            | JVMTI_THREAD_STATE_IN_NATIVE \\\n-                            | JVMTI_THREAD_STATE_VENDOR_1 \\\n-                            | JVMTI_THREAD_STATE_VENDOR_2 \\\n-                            | JVMTI_THREAD_STATE_VENDOR_3)\n-\n-static int g_ThreadState[] = {\n-    0,                                                 \/* TS_NEW *\/\n-    JVMTI_THREAD_STATE_TERMINATED,                     \/* TS_TERMINATED *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_RUNNABLE,                 \/* TS_RUN_RUNNING *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER, \/* TS_RUN_BLOCKED *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,     \/* TS_RUN_WAIT_TIMED *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_INDEFINITELY,     \/* TS_RUN_WAIT_INDEF *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_PARKED\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_INDEFINITELY,     \/* TS_RUN_WAIT_PARKED_INDEF *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_PARKED\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,     \/* TS_RUN_WAIT_PARKED_TIMED *\/\n-    JVMTI_THREAD_STATE_ALIVE\n-        | JVMTI_THREAD_STATE_SLEEPING\n-        | JVMTI_THREAD_STATE_WAITING\n-        | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,     \/* TS_RUN_WAIT_SLEEPING *\/\n-};\n-\n-static jvmtiEnv * g_ppJvmtiEnv = NULL;\n-static int g_waitTime = 1000;\n-jrawMonitorID g_waitMon; \/* Monitor is used just for sleeping *\/\n-\n-void reportError(const char * szErr, jvmtiError res) {\n-#ifndef STANDALONE\n-    printf(\"%s (%d: %s)\\n\", szErr, res, TranslateError(res));\n-#else\n-    printf(\"%s (%d)\\n\", szErr, res);\n-#endif\n-    fflush(stdout);\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrstat005(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrstat005(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrstat005(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError error;\n-    jint res;\n-\n-    res = jvm->GetEnv((void **) &g_ppJvmtiEnv, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || !g_ppJvmtiEnv) {\n-        printf(\"Agent_OnLoad: Error: GetEnv returned error or NULL\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    error = g_ppJvmtiEnv->CreateRawMonitor(\"beast\", &g_waitMon);\n-    if (error != JVMTI_ERROR_NONE) {\n-        reportError(\"Agent_OnLoad: error creating raw monitor\", error);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat005_setWaitTime(JNIEnv * pEnv, jclass klass, jint waitTime) {\n-    g_waitTime = waitTime;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_nsk_jvmti_GetThreadState_thrstat005_checkThreadState(JNIEnv * pEnv, jclass klass, jthread thread, jint stateIdx) {\n-\n-    jint thrState;\n-    jint maskedThrState;\n-    int waitTime = 10;\n-\n-    \/* Repeat querying status until waitTime < g_waitTime *\/\n-    do {\n-        jvmtiError res = g_ppJvmtiEnv->GetThreadState(thread, &thrState);\n-        if (res != JVMTI_ERROR_NONE) {\n-            reportError(\"GetThreadState: unexpected error\", res);\n-            return JNI_FALSE;\n-        }\n-\n-        maskedThrState = thrState & THREAD_STATE_MASK;\n-        printf(\"GetThreadState = %x. Masked: %x. Must be: %x\\n\", thrState, maskedThrState, g_ThreadState[stateIdx]);\n-        fflush(stdout);\n-\n-        if (maskedThrState == g_ThreadState[stateIdx])\n-            return JNI_TRUE;\n-\n-        printf(\"checkThreadState: wait %d ms\\n\", waitTime);\n-        fflush(stdout);\n-        res = g_ppJvmtiEnv->RawMonitorEnter(g_waitMon);\n-        if (res != JVMTI_ERROR_NONE) {\n-            reportError(\"GetThreadState: unexpected error from RawMontiorEnter\", res);\n-            return JNI_FALSE;\n-        }\n-        res = g_ppJvmtiEnv->RawMonitorWait(g_waitMon, waitTime);\n-        if (res != JVMTI_ERROR_NONE) {\n-            reportError(\"GetThreadState: unexpected error from RawMontiorWait\", res);\n-            return JNI_FALSE;\n-        }\n-        res = g_ppJvmtiEnv->RawMonitorExit(g_waitMon);\n-        if (res != JVMTI_ERROR_NONE) {\n-            reportError(\"GetThreadState: unexpected error from RawMonitorExit\", res);\n-            return JNI_FALSE;\n-        }\n-\n-        waitTime <<= 1;\n-\n-    } while (waitTime < g_waitTime);\n-\n-    return JNI_FALSE;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadState\/thrstat005\/thrstat005.cpp","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,28 @@\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.\n+ * VM Testbase keywords: [quick, monitoring]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test checks that\n+ *         ThreadInfo.isSuspended()\n+ *     returns correct values for a thread in different states.\n+ *     The test starts an instance of MyThread and checks that isSuspended()\n+ *     returns false for it. Then it suspends the thread and expects the method\n+ *     to return true. After that the MyThread is resumed and isSuspended() must\n+ *     return false.\n+ *     Testing of the method does not depend on the way to access metrics, so\n+ *     only one (direct access) is implemented in the test.\n+ * COMMENT\n+ *     Fixed the bug\n+ *     4989235 TEST: The spec is updated accoring to 4982289, 4985742\n+ *     Updated according to:\n+ *     5024531 Fix MBeans design flaw that restricts to use JMX CompositeData\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *          \/testlibrary\n+ * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended001\n+ *\/\n+\n@@ -30,0 +58,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -56,1 +86,1 @@\n-        thread.suspend();\n+        JVMTIUtils.suspendThread(thread);\n@@ -66,1 +96,1 @@\n-        thread.resume();\n+        JVMTIUtils.resumeThread(thread);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that\n- *         ThreadInfo.isSuspended()\n- *     returns correct values for a thread in different states.\n- *     The test starts an instance of MyThread and checks that isSuspended()\n- *     returns false for it. Then it suspends the thread and expects the method\n- *     to return true. After that the MyThread is resumed and isSuspended() must\n- *     return false.\n- *     Testing of the method does not depend on the way to access metrics, so\n- *     only one (direct access) is implemented in the test.\n- * COMMENT\n- *     Fixed the bug\n- *     4989235 TEST: The spec is updated accoring to 4982289, 4985742\n- *     Updated according to:\n- *     5024531 Fix MBeans design flaw that restricts to use JMX CompositeData\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001\/TestDescription.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,19 @@\n+\/*\n+ * @test\n+ *\n+ * @bug 8167108 8266130\n+ * @summary converted from VM Testbase nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.\n+ * VM Testbase keywords: [quick, monitoring]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     Same test as issuspended001 with additional calls to\n+ *     ThreadInfo.isSuspended() as the worker thread is exiting.\n+ * COMMENT\n+ *     Derived from nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *          \/testlibrary\n+ * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n+ *\/\n+\n@@ -30,0 +49,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -81,1 +102,1 @@\n-            thread.suspend();\n+            JVMTIUtils.suspendThread(thread);\n@@ -92,1 +113,1 @@\n-            thread.resume();\n+            JVMTIUtils.resumeThread(thread);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @bug 8167108 8266130\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Same test as issuspended001 with additional calls to\n- *     ThreadInfo.isSuspended() as the worker thread is exiting.\n- * COMMENT\n- *     Derived from nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002\/TestDescription.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -527,1 +527,0 @@\n-sun\/management\/jmxremote\/bootstrap\/RmiBootstrapTest.java#id1    8293657 linux-x64\n@@ -673,1 +672,1 @@\n-sanity\/client\/SwingSet\/src\/ToolTipDemoTest.java 8225012 windows-all,macosx-all\n+sanity\/client\/SwingSet\/src\/ToolTipDemoTest.java 8293001 linux-all\n@@ -723,1 +722,1 @@\n-sun\/tools\/jstatd\/TestJstatdRmiPort.java                         8226420,8251259 windows-all\n+sun\/tools\/jstatd\/TestJstatdRmiPort.java                         8226420,8251259,8293577 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -218,4 +218,9 @@\n-                \/\/ For now, we expect these two test cases to fail due to 8292217,\n-                \/\/ so don't fail the overall test run as a result of these failures.\n-                \/\/ testFailed = true;\n-                System.out.println(\"TESTCASE #\" + testcase + \" FAILED (ignoring): too many events in EventSet: \" + set.size());\n+                \/\/ For now, we expect the 2nd test cases to fail due to 8292217,\n+                \/\/ so don't fail the overall test run as a result of this failure.\n+                \/\/ There is a workaround in place that allows the 1st test case to pass.\n+                if (testcase == 1) {\n+                    testFailed = true;\n+                }\n+                System.out.println(\"TESTCASE #\" + testcase + \" FAILED\" +\n+                                   (testcase == 2 ? \"(ignoring)\" : \"\") +\n+                                   \": too many events in EventSet: \" + set.size());\n","filename":"test\/jdk\/com\/sun\/jdi\/CLETest.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,2 +42,3 @@\n- * @summary Tests whether insets are calculated correctly on Windows\n- * for AWT Frame by checking the actual and expected\/preferred frame sizes.\n+ * @summary Tests whether correct native frame insets are obtained\n+ * for Resizable & Non-Resizable AWT Frame by checking the actual\n+ * and expected\/preferred frame sizes.\n@@ -46,1 +47,0 @@\n-\n@@ -48,1 +48,0 @@\n-\n@@ -51,0 +50,1 @@\n+    private static StringBuffer errorLog = new StringBuffer();\n@@ -53,3 +53,5 @@\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(300);\n+        robot = new Robot();\n+        robot.setAutoDelay(300);\n+\n+        \/\/ Resizable frame\n+        createAWTFrame(true);\n@@ -57,0 +59,14 @@\n+        robot.waitForIdle();\n+        robot.delay(500);\n+\n+        \/\/ Non-Resizable frame\n+        createAWTFrame(false);\n+\n+        if (!errorLog.isEmpty()) {\n+            throw new RuntimeException(\"Test failed due to the following\" +\n+                    \" one or more errors: \\n\" + errorLog);\n+        }\n+    }\n+\n+    private static void createAWTFrame(boolean isResizable) {\n+        try {\n@@ -70,0 +86,1 @@\n+            frame.setResizable(isResizable);\n@@ -73,1 +90,0 @@\n-            robot.delay(500);\n@@ -75,0 +91,1 @@\n+            robot.delay(500);\n@@ -80,5 +97,6 @@\n-                System.out.println(\"Expected frame size: \"+ expectedFrameSize);\n-                System.out.println(\"Actual frame size: \"+ actualFrameSize);\n-                saveScreenCapture();\n-                throw new RuntimeException(\"Expected and Actual frame size\" +\n-                        \" are different. frame.pack() does not work!!\");\n+                String frameType = isResizable ? \"ResizableFrame\" : \"NonResizableFrame\";\n+                System.out.println(\"Expected frame size: \" + expectedFrameSize);\n+                System.out.println(\"Actual frame size: \" + actualFrameSize);\n+                saveScreenCapture(frameType + \".png\");\n+                errorLog.append(frameType + \": Expected and Actual frame size\" +\n+                        \" are different. frame.pack() does not work!! \\n\");\n@@ -87,1 +105,3 @@\n-            frame.dispose();\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n@@ -92,1 +112,1 @@\n-    private static void saveScreenCapture() {\n+    private static void saveScreenCapture(String filename) {\n@@ -95,1 +115,1 @@\n-            ImageIO.write(image,\"png\", new File(\"Frame.png\"));\n+            ImageIO.write(image,\"png\", new File(filename));\n","filename":"test\/jdk\/java\/awt\/Frame\/AwtFramePackTest.java","additions":36,"deletions":16,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            + \"Perform the VO action \\\"Show menu\\\" (VO+m)\\n\\n\"\n+            + \"Perform the VO action \\\"Show menu\\\" (VO+Shift+m)\\n\\n\"\n","filename":"test\/jdk\/java\/awt\/a11y\/AccessibleActionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires (os.arch != \"x86\" & os.arch != \"i386\") | vm.opt.UseSSE == \"null\" | vm.opt.UseSSE > 0\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+\n+\/*\n+ * @test\n+ * @summary Verify Signal mask is cleared by ProcessBuilder start\n+ * @bug 8234262\n+ * @requires (os.family == \"linux\" | os.family == \"mac\")\n+ * @run main\/othervm UnblockSignals\n+ * @run main\/othervm -Xrs UnblockSignals\n+ *\/\n+public class UnblockSignals {\n+    public static void main(String[] args)  throws IOException, InterruptedException {\n+        \/\/ Check that SIGQUIT is not masked, in previous releases it was masked\n+        final ProcessBuilder pb = new ProcessBuilder(\"sleep\", \"30\").inheritIO();\n+        Process p = pb.start();\n+        System.out.printf(\"Child %d, %s%n\", p.pid(), pb.command());\n+        ProcessBuilder killpb = new ProcessBuilder(\"kill\", \"-s\", \"QUIT\", Long.toString(p.pid()));\n+        Process killp = killpb.start();\n+        System.out.printf(\"Child %d, %s%n\", killp.pid(), killpb.command());\n+        int killst = killp.waitFor();\n+        if (killst != 0) {\n+            throw new RuntimeException(\"Kill process failed, exit status: \" + killst);\n+        }\n+        int sleepStatus = p.waitFor();\n+        if (sleepStatus == 0) {\n+            throw new RuntimeException(\"Child not killed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/UnblockSignals.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8205132\n- * @summary Test Thread.countStackFrames()\n- * @run testng CountStackFrames\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-public class CountStackFrames {\n-\n-    \/\/ current thread\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testCurrentThread() {\n-        Thread.currentThread().countStackFrames();\n-    }\n-\n-    \/\/ unstarted thread\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testUnstartedThread() {\n-        Thread thread = new Thread(() -> { });\n-        thread.countStackFrames();\n-    }\n-\n-    \/\/ terminated thread\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testTerminatedThread() throws Exception {\n-        Thread thread = new Thread(() -> { });\n-        thread.start();\n-        thread.join();\n-        thread.countStackFrames();\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/CountStackFrames.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug  8289610 8249627 8205132\n+ * @summary Test that Thread stop\/suspend\/resume\/countStackFrames throw UOE\n+ * @run junit DegradedMethodsThrowUOE\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class DegradedMethodsThrowUOE {\n+\n+    \/**\n+     * Returns a stream of operations on a Thread that should throw UOE.\n+     *\/\n+    static Stream<Consumer<Thread>> ops() {\n+        return Stream.<Consumer<Thread>>of(\n+                Thread::stop,\n+                Thread::suspend,\n+                Thread::resume,\n+                Thread::countStackFrames\n+        );\n+    }\n+\n+    \/**\n+     * Test degraded method on current thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"ops\")\n+    void testCurrentThread(Consumer<Thread> op) {\n+        var thread = Thread.currentThread();\n+        assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n+    }\n+\n+    \/**\n+     * Test degraded method on an unstarted thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"ops\")\n+    void testUnstartedThread(Consumer<Thread> op) {\n+        Thread thread = new Thread(() -> { });\n+        assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n+        assertTrue(thread.getState() == Thread.State.NEW);\n+    }\n+\n+    \/**\n+     * Test degraded method on a thread spinning in a loop.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"ops\")\n+    void testRunnableThread(Consumer<Thread> op) throws Exception {\n+        AtomicBoolean done = new AtomicBoolean();\n+        Thread thread = new Thread(() -> {\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        thread.start();\n+        try {\n+            assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n+\n+            \/\/ thread should not terminate\n+            boolean terminated = thread.join(Duration.ofMillis(500));\n+            assertFalse(terminated);\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test degraded method on a thread that is parked.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"ops\")\n+    void testWaitingThread(Consumer<Thread> op) throws Exception {\n+        Thread thread = new Thread(LockSupport::park);\n+        thread.start();\n+        try {\n+            \/\/ wait for thread to park\n+            while ((thread.getState() != Thread.State.WAITING)) {\n+                Thread.sleep(10);\n+            }\n+            assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n+            assertTrue(thread.getState() == Thread.State.WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test degraded method on a terminated thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"ops\")\n+    void testTerminatedThread(Consumer<Thread> op) throws Exception {\n+        Thread thread = new Thread(() -> { });\n+        thread.start();\n+        thread.join();\n+        assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n+        assertTrue(thread.getState() == Thread.State.TERMINATED);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/DegradedMethodsThrowUOE.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,495 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ProtocolException;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8292044\n+ * @summary Tests behaviour of HttpClient when server responds with 102 or 103 status codes\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          jdk.httpserver\n+ * @library \/test\/lib http2\/server\n+ * @build Http2TestServer HttpServerAdapters jdk.test.lib.net.SimpleSSLContext\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n+ * *                   -Djdk.httpclient.HttpClient.log=headers,requests,responses,errors Response1xxTest\n+ *\/\n+public class Response1xxTest implements HttpServerAdapters {\n+    private static final String EXPECTED_RSP_BODY = \"Hello World\";\n+\n+    private ServerSocket serverSocket;\n+    private Http11Server server;\n+    private String http1RequestURIBase;\n+\n+\n+    private HttpTestServer http2Server; \/\/ h2c\n+    private String http2RequestURIBase;\n+\n+\n+    private SSLContext sslContext;\n+    private HttpTestServer https2Server;  \/\/ h2\n+    private String https2RequestURIBase;\n+\n+    private final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+        server = new Http11Server(serverSocket);\n+        new Thread(server).start();\n+        http1RequestURIBase = URIBuilder.newBuilder().scheme(\"http\").loopback()\n+                .port(serverSocket.getLocalPort()).build().toString();\n+\n+        http2Server = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/102\");\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/103\");\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/100\");\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/101\");\n+        http2Server.addHandler(new OKHandler(), \"\/http2\/200\");\n+        http2Server.addHandler(new OnlyInformationalHandler(), \"\/http2\/only-informational\");\n+        http2RequestURIBase = URIBuilder.newBuilder().scheme(\"http\").loopback()\n+                .port(http2Server.getAddress().getPort())\n+                .path(\"\/http2\").build().toString();\n+\n+        http2Server.start();\n+        System.out.println(\"Started HTTP2 server at \" + http2Server.getAddress());\n+\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null) {\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+        }\n+        https2Server = HttpTestServer.of(new Http2TestServer(\"localhost\",\n+                true, sslContext));\n+        https2Server.addHandler(new Http2Handler(), \"\/http2\/101\");\n+        https2RequestURIBase = URIBuilder.newBuilder().scheme(\"https\").loopback()\n+                .port(https2Server.getAddress().getPort())\n+                .path(\"\/http2\").build().toString();\n+        https2Server.start();\n+        System.out.println(\"Started (https) HTTP2 server at \" + https2Server.getAddress());\n+\n+    }\n+\n+    @AfterClass\n+    public void teardown() throws Throwable {\n+        try {\n+            assertNoOutstandingClientOps();\n+        } finally {\n+            if (server != null) {\n+                server.stop = true;\n+                System.out.println(\"(HTTP 1.1) Server stop requested\");\n+            }\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+                System.out.println(\"Closed (HTTP 1.1) server socket\");\n+            }\n+            if (http2Server != null) {\n+                http2Server.stop();\n+                System.out.println(\"Stopped HTTP2 server\");\n+            }\n+            if (https2Server != null) {\n+                https2Server.stop();\n+                System.out.println(\"Stopped (https) HTTP2 server\");\n+            }\n+        }\n+    }\n+\n+    private static final class Http11Server implements Runnable {\n+        private static final int CONTENT_LENGTH = EXPECTED_RSP_BODY.getBytes(StandardCharsets.UTF_8).length;\n+\n+        private static final String HTTP_1_1_RSP_200 = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Content-Length: \" + CONTENT_LENGTH + \"\\r\\n\\r\\n\" +\n+                EXPECTED_RSP_BODY;\n+\n+        private static final String REQ_LINE_FOO = \"GET \/test\/foo HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_BAR = \"GET \/test\/bar HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_HELLO = \"GET \/test\/hello HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_BYE = \"GET \/test\/bye HTTP\/1.1\\r\\n\";\n+\n+\n+        private final ServerSocket serverSocket;\n+        private volatile boolean stop;\n+\n+        private Http11Server(final ServerSocket serverSocket) {\n+            this.serverSocket = serverSocket;\n+        }\n+\n+        @Override\n+        public void run() {\n+            System.out.println(\"Server running at \" + serverSocket);\n+            while (!stop) {\n+                Socket socket = null;\n+                try {\n+                    \/\/ accept a connection\n+                    socket = serverSocket.accept();\n+                    System.out.println(\"Accepted connection from client \" + socket);\n+                    \/\/ read request\n+                    final String requestLine;\n+                    try {\n+                        requestLine = readRequestLine(socket);\n+                    } catch (Throwable t) {\n+                        \/\/ ignore connections from potential rogue client\n+                        System.err.println(\"Ignoring connection\/request from client \" + socket\n+                                + \" due to exception:\");\n+                        t.printStackTrace();\n+                        \/\/ close the socket\n+                        safeClose(socket);\n+                        continue;\n+                    }\n+                    System.out.println(\"Received following request line from client \" + socket\n+                            + \" :\\n\" + requestLine);\n+                    final int informationalResponseCode;\n+                    if (requestLine.startsWith(REQ_LINE_FOO)) {\n+                        \/\/ we will send intermediate\/informational 102 response\n+                        informationalResponseCode = 102;\n+                    } else if (requestLine.startsWith(REQ_LINE_BAR)) {\n+                        \/\/ we will send intermediate\/informational 103 response\n+                        informationalResponseCode = 103;\n+                    } else if (requestLine.startsWith(REQ_LINE_HELLO)) {\n+                        \/\/ we will send intermediate\/informational 100 response\n+                        informationalResponseCode = 100;\n+                    } else if (requestLine.startsWith(REQ_LINE_BYE)) {\n+                        \/\/ we will send intermediate\/informational 101 response\n+                        informationalResponseCode = 101;\n+                    } else {\n+                        \/\/ unexpected client. ignore and close the client\n+                        System.err.println(\"Ignoring unexpected request from client \" + socket);\n+                        safeClose(socket);\n+                        continue;\n+                    }\n+                    try (final OutputStream os = socket.getOutputStream()) {\n+                        \/\/ send informational response headers a few times (spec allows them to\n+                        \/\/ be sent multiple times)\n+                        for (int i = 0; i < 3; i++) {\n+                            \/\/ send 1xx response header\n+                            if (informationalResponseCode == 101) {\n+                                os.write((\"HTTP\/1.1 \" + informationalResponseCode + \"\\r\\n\" +\n+                                        \"Connection: upgrade\\r\\n\" +\n+                                        \"Upgrade: websocket\\r\\n\\r\\n\")\n+                                        .getBytes(StandardCharsets.UTF_8));\n+                            } else {\n+                                os.write((\"HTTP\/1.1 \" + informationalResponseCode + \"\\r\\n\\r\\n\")\n+                                        .getBytes(StandardCharsets.UTF_8));\n+                            }\n+                            os.flush();\n+                            System.out.println(\"Sent response code \" + informationalResponseCode\n+                                    + \" to client \" + socket);\n+                        }\n+                        \/\/ now send a final response\n+                        System.out.println(\"Now sending 200 response code to client \" + socket);\n+                        os.write(HTTP_1_1_RSP_200.getBytes(StandardCharsets.UTF_8));\n+                        os.flush();\n+                        System.out.println(\"Sent 200 response code to client \" + socket);\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ close the client connection\n+                    safeClose(socket);\n+                    \/\/ continue accepting any other client connections until we are asked to stop\n+                    System.err.println(\"Ignoring exception in server:\");\n+                    t.printStackTrace();\n+                }\n+            }\n+        }\n+\n+        static String readRequestLine(final Socket sock) throws IOException {\n+            final InputStream is = sock.getInputStream();\n+            final StringBuilder sb = new StringBuilder(\"\");\n+            byte[] buf = new byte[1024];\n+            while (!sb.toString().endsWith(\"\\r\\n\\r\\n\")) {\n+                final int numRead = is.read(buf);\n+                if (numRead == -1) {\n+                    return sb.toString();\n+                }\n+                final String part = new String(buf, 0, numRead, StandardCharsets.ISO_8859_1);\n+                sb.append(part);\n+            }\n+            return sb.toString();\n+        }\n+\n+        private static void safeClose(final Socket socket) {\n+            try {\n+                socket.close();\n+            } catch (Throwable t) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    private static class Http2Handler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            final URI requestURI = exchange.getRequestURI();\n+            final int informationResponseCode;\n+            if (requestURI.getPath().endsWith(\"\/102\")) {\n+                informationResponseCode = 102;\n+            } else if (requestURI.getPath().endsWith(\"\/103\")) {\n+                informationResponseCode = 103;\n+            } else if (requestURI.getPath().endsWith(\"\/100\")) {\n+                informationResponseCode = 100;\n+            } else if (requestURI.getPath().endsWith(\"\/101\")) {\n+                informationResponseCode = 101;\n+            } else {\n+                \/\/ unexpected request\n+                System.err.println(\"Unexpected request \" + requestURI + \" from client \"\n+                        + exchange.getRemoteAddress());\n+                exchange.sendResponseHeaders(400, -1);\n+                return;\n+            }\n+            \/\/ send informational response headers a few times (spec allows them to\n+            \/\/ be sent multiple times)\n+            for (int i = 0; i < 3; i++) {\n+                exchange.sendResponseHeaders(informationResponseCode, -1);\n+                System.out.println(\"Sent \" + informationResponseCode + \" response code from H2 server\");\n+            }\n+            \/\/ now send 200 response\n+            try {\n+                final byte[] body = EXPECTED_RSP_BODY.getBytes(StandardCharsets.UTF_8);\n+                exchange.sendResponseHeaders(200, body.length);\n+                System.out.println(\"Sent 200 response from H2 server\");\n+                try (OutputStream os = exchange.getResponseBody()) {\n+                    os.write(body);\n+                }\n+                System.out.println(\"Sent response body from H2 server\");\n+            } catch (Throwable e) {\n+                System.err.println(\"Failed to send response from HTTP2 handler:\");\n+                e.printStackTrace();\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static class OnlyInformationalHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            \/\/ we only send informational response and then return\n+            for (int i = 0; i < 5; i++) {\n+                exchange.sendResponseHeaders(102, -1);\n+                System.out.println(\"Sent 102 response code from H2 server\");\n+                \/\/ wait for a while before sending again\n+                try {\n+                    Thread.sleep(2000);\n+                } catch (InterruptedException e) {\n+                    \/\/ just return\n+                    System.err.println(\"Handler thread interrupted\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class OKHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            exchange.sendResponseHeaders(200, -1);\n+        }\n+    }\n+\n+    \/**\n+     * Tests that when a HTTP\/1.1 server sends intermediate 1xx response codes and then the final\n+     * response, the client (internally) will ignore those intermediate informational response codes\n+     * and only return the final response to the application\n+     *\/\n+    @Test\n+    public void test1xxForHTTP11() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_1_1)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI[] requestURIs = new URI[]{\n+                new URI(http1RequestURIBase + \"\/test\/foo\"),\n+                new URI(http1RequestURIBase + \"\/test\/bar\"),\n+                new URI(http1RequestURIBase + \"\/test\/hello\")};\n+        for (final URI requestURI : requestURIs) {\n+            final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+            System.out.println(\"Issuing request to \" + requestURI);\n+            final HttpResponse<String> response = client.send(request,\n+                    HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+            Assert.assertEquals(response.version(), HttpClient.Version.HTTP_1_1,\n+                    \"Unexpected HTTP version in response\");\n+            Assert.assertEquals(response.statusCode(), 200, \"Unexpected response code\");\n+            Assert.assertEquals(response.body(), EXPECTED_RSP_BODY, \"Unexpected response body\");\n+        }\n+    }\n+\n+    \/**\n+     * Tests that when a HTTP2 server sends intermediate 1xx response codes and then the final\n+     * response, the client (internally) will ignore those intermediate informational response codes\n+     * and only return the final response to the application\n+     *\/\n+    @Test\n+    public void test1xxForHTTP2() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI[] requestURIs = new URI[]{\n+                new URI(http2RequestURIBase + \"\/102\"),\n+                new URI(http2RequestURIBase + \"\/103\"),\n+                new URI(http2RequestURIBase + \"\/100\")};\n+        for (final URI requestURI : requestURIs) {\n+            final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+            System.out.println(\"Issuing request to \" + requestURI);\n+            final HttpResponse<String> response = client.send(request,\n+                    HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+            Assert.assertEquals(response.version(), HttpClient.Version.HTTP_2,\n+                    \"Unexpected HTTP version in response\");\n+            Assert.assertEquals(response.statusCode(), 200, \"Unexpected response code\");\n+            Assert.assertEquals(response.body(), EXPECTED_RSP_BODY, \"Unexpected response body\");\n+        }\n+    }\n+\n+\n+    \/**\n+     * Tests that when a request is issued with a specific request timeout and the server\n+     * responds with intermediate 1xx response code but doesn't respond with a final response within\n+     * the timeout duration, then the application fails with a request timeout\n+     *\/\n+    @Test\n+    public void test1xxRequestTimeout() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI requestURI = new URI(http2RequestURIBase + \"\/only-informational\");\n+        final Duration requestTimeout = Duration.ofSeconds(2);\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).timeout(requestTimeout)\n+                .build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to timeout\n+        Assert.assertThrows(HttpTimeoutException.class, () -> {\n+            client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+        });\n+    }\n+\n+    \/**\n+     * Tests that when the HTTP\/1.1 server sends a 101 response when the request hasn't asked\n+     * for an \"Upgrade\" then the request fails.\n+     *\/\n+    @Test\n+    public void testHTTP11Unexpected101() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_1_1)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI requestURI = new URI(http1RequestURIBase + \"\/test\/bye\");\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to fail because the server sent an unexpected 101\n+        Assert.assertThrows(ProtocolException.class,\n+                () -> client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8)));\n+    }\n+\n+\n+    \/**\n+     * Tests that when the HTTP2 server (over HTTPS) sends a 101 response when the request\n+     * hasn't asked for an \"Upgrade\" then the request fails.\n+     *\/\n+    @Test\n+    public void testSecureHTTP2Unexpected101() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .sslContext(sslContext)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        final URI requestURI = new URI(https2RequestURIBase + \"\/101\");\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to fail because the server sent an unexpected 101\n+        Assert.assertThrows(ProtocolException.class,\n+                () -> client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8)));\n+    }\n+\n+    \/**\n+     * Tests that when the HTTP2 server (over plain HTTP) sends a 101 response when the request\n+     * hasn't asked for an \"Upgrade\" then the request fails.\n+     *\/\n+    @Test\n+    public void testPlainHTTP2Unexpected101() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        TRACKER.track(client);\n+        \/\/ when using HTTP2 version against a \"http:\/\/\" (non-secure) URI\n+        \/\/ the HTTP client (implementation) internally initiates a HTTP\/1.1 connection\n+        \/\/ and then does an \"Upgrade:\" to \"h2c\". This it does when there isn't already a\n+        \/\/ H2 connection against the target\/destination server. So here we initiate a dummy request\n+        \/\/ using the client instance against the same target server and just expect it to return\n+        \/\/ back successfully. Once that connection is established (and internally pooled), the client\n+        \/\/ will then reuse that connection and won't issue an \"Upgrade:\" and thus we can then\n+        \/\/ start our testing\n+        warmupH2Client(client);\n+        \/\/ start the actual testing\n+        final URI requestURI = new URI(http2RequestURIBase + \"\/101\");\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to fail because the server sent an unexpected 101\n+        Assert.assertThrows(ProtocolException.class,\n+                () -> client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8)));\n+    }\n+\n+    \/\/ sends a request and expects a 200 response back\n+    private void warmupH2Client(final HttpClient client) throws Exception {\n+        final URI requestURI = new URI(http2RequestURIBase + \"\/200\");\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+        System.out.println(\"Issuing (warmup) request to \" + requestURI);\n+        final HttpResponse<Void> response = client.send(request, HttpResponse.BodyHandlers.discarding());\n+        Assert.assertEquals(response.statusCode(), 200, \"Unexpected response code\");\n+    }\n+\n+    \/\/ verifies that the HttpClient being tracked has no outstanding operations\n+    private void assertNoOutstandingClientOps() throws AssertionError {\n+        System.gc();\n+        final AssertionError refCheckFailure = TRACKER.check(1000);\n+        if (refCheckFailure != null) {\n+            throw refCheckFailure;\n+        }\n+        \/\/ successful test completion\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/Response1xxTest.java","additions":495,"deletions":0,"binary":false,"changes":495,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static org.testng.Assert.*;\n+import org.testng.SkipException;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8032220 8293792\n+ * @summary Test java.nio.file.Files.createDirectories method\n+ * @library ..\n+ * @run testng CreateDirectories\n+ *\/\n+public class CreateDirectories {\n+\n+    \/**\n+     * Test Files.createDirectories symbolic file with an existing directory.\n+     *\/\n+    @Test\n+    public void testSymlinkDir() throws Exception {\n+        \/\/ create a temp dir as the \"root\" in which we will run our tests.\n+        final Path top = TestUtil.createTemporaryDirectory();\n+        if (!TestUtil.supportsLinks(top)) {\n+            System.out.println(\"Skipping tests since symbolic links isn't \" +\n+                    \"supported under directory \"+ top);\n+            throw new SkipException(\"Symbolic links not supported\");\n+        }\n+        System.out.println(\"Running tests under directory \" + top.toAbsolutePath());\n+        final Path fooDir = Files.createDirectory(top.resolve(\"foo\"));\n+        assertTrue(Files.isDirectory(fooDir),\n+                fooDir + \" was expected to be a directory but wasn't\");\n+\n+        \/\/ now create a symlink to the \"foo\" dir\n+        final Path symlink = Files.createSymbolicLink(top.resolve(\"symlinkToFoo\"),\n+                fooDir.toAbsolutePath());\n+        assertTrue(Files.isSymbolicLink(symlink),\n+                symlink + \" was expected to be a symlink but wasn't\");\n+        assertTrue(Files.isDirectory(symlink),\n+                symlink + \" was expected to be a directory but wasn't\");\n+\n+        \/\/ now create a directory under the symlink (which effectively creates a directory under\n+        \/\/ \"foo\")\n+        final Path barDir = Files.createDirectory(symlink.resolve(\"bar\"));\n+        assertTrue(Files.isDirectory(barDir),\n+                barDir + \" was expected to be a directory but wasn't\");\n+        \/\/ ultimately, we now have this directory structure:\n+        \/\/ <root-dir>\n+        \/\/   |--- foo\n+        \/\/   |     |--- bar\n+        \/\/   |\n+        \/\/   |--- symlinkToFoo -> (links to) <absolute-path-to-root-dir>\/foo\n+\n+\n+        \/\/ now call Files.createDirectories on each of these existing directory\/symlink paths\n+        \/\/ and expect each one to succeed\n+        Files.createDirectories(fooDir); \/\/ .\/<root-dir>\/foo\n+        Files.createDirectories(symlink); \/\/ .\/<root-dir>\/symlinkToFoo\n+        Files.createDirectories(barDir); \/\/ .\/<root-dir>\/symlinkToFoo\/bar\n+    }\n+\n+    \/**\n+     * Tests Files.createDirectories\n+     *\/\n+    @Test\n+    public void testCreateDirectories() throws IOException {\n+        final Path tmpdir = TestUtil.createTemporaryDirectory();\n+        \/\/ a no-op\n+        Files.createDirectories(tmpdir);\n+\n+        \/\/ create one directory\n+        Path subdir = tmpdir.resolve(\"a\");\n+        Files.createDirectories(subdir);\n+        assertTrue(Files.isDirectory(subdir), subdir + \" was expected to be a directory,\" +\n+                \" but wasn't\");\n+\n+        \/\/ create parents\n+        subdir = subdir.resolve(\"b\/c\/d\");\n+        Files.createDirectories(subdir);\n+        assertTrue(Files.isDirectory(subdir), subdir + \" was expected to be a directory,\" +\n+                \" but wasn't\");\n+\n+        \/\/ existing file is not a directory\n+        Path file = Files.createFile(tmpdir.resolve(\"x\"));\n+        try {\n+            Files.createDirectories(file);\n+            throw new RuntimeException(\"failure expected\");\n+        } catch (FileAlreadyExistsException x) { }\n+        try {\n+            Files.createDirectories(file.resolve(\"y\"));\n+            throw new RuntimeException(\"failure expected\");\n+        } catch (IOException x) { }\n+\n+        \/\/ the root directory always exists\n+        Path root = Path.of(\"\/\");\n+        Files.createDirectories(root);\n+        Files.createDirectories(root.toAbsolutePath());\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CreateDirectories.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -25,2 +25,2 @@\n- * @bug 4313887 6838333 8005566 8032220 8215467 8255576 8286160\n- * @summary Unit test for miscellenous methods in java.nio.file.Files\n+ * @bug 4313887 6838333 8005566 8215467 8255576 8286160\n+ * @summary Unit test for miscellaneous methods in java.nio.file.Files\n@@ -54,1 +54,0 @@\n-            testCreateDirectories(dir);\n@@ -64,33 +63,0 @@\n-    \/**\n-     * Tests createDirectories\n-     *\/\n-    static void testCreateDirectories(Path tmpdir) throws IOException {\n-        \/\/ a no-op\n-        createDirectories(tmpdir);\n-\n-        \/\/ create one directory\n-        Path subdir = tmpdir.resolve(\"a\");\n-        createDirectories(subdir);\n-        assertTrue(exists(subdir));\n-\n-        \/\/ create parents\n-        subdir = subdir.resolve(\"b\/c\/d\");\n-        createDirectories(subdir);\n-        assertTrue(exists(subdir));\n-\n-        \/\/ existing file is not a directory\n-        Path file = createFile(tmpdir.resolve(\"x\"));\n-        try {\n-            createDirectories(file);\n-            throw new RuntimeException(\"failure expected\");\n-        } catch (FileAlreadyExistsException x) { }\n-        try {\n-            createDirectories(file.resolve(\"y\"));\n-            throw new RuntimeException(\"failure expected\");\n-        } catch (IOException x) { }\n-\n-        \/\/ the root directory always exists\n-        Path root = Path.of(\"\/\");\n-        Files.createDirectories(root);\n-        Files.createDirectories(root.toAbsolutePath());\n-    }\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Misc.java","additions":2,"deletions":36,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @key headful\n+ * @bug 4797982\n+ * @summary Verifies if negative size of JSplitPane divider can be set.\n+ * @run main JSplitPaneTestNegDivSize\n+ *\/\n+import java.awt.BorderLayout;\n+import java.awt.Dimension;\n+import javax.swing.JFrame;\n+import javax.swing.JSplitPane;\n+import javax.swing.JTextArea;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.basic.BasicSplitPaneUI;\n+\n+public class JSplitPaneTestNegDivSize {\n+\n+    private static volatile int divSize;\n+    private static volatile int basicDivSize;\n+    private static JFrame frame;\n+    private static JSplitPane sp;\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            frame = new JFrame();\n+            sp = new JSplitPane(JSplitPane.VERTICAL_SPLIT, true,\n+                    new JTextArea(\"I am top text area!\"),\n+                    new JTextArea(\"I am bottom text area!\"));\n+            frame.getContentPane().add(sp, BorderLayout.CENTER);\n+            sp.setDividerSize(-50);\n+            divSize = sp.getDividerSize();\n+            ((BasicSplitPaneUI)sp.getUI()).getDivider().setDividerSize(-50);\n+            basicDivSize = ((BasicSplitPaneUI)sp.getUI()).getDivider().\n+                                              getDividerSize();\n+            frame.setSize(new Dimension(400,200));\n+            frame.setVisible(true);\n+        });\n+        try {\n+            Thread.sleep(1000);\n+        } catch(Exception e){}\n+        SwingUtilities.invokeAndWait(()->frame.dispose());\n+        System.out.println(divSize);\n+        System.out.println(basicDivSize);\n+        System.out.println((Integer)UIManager.get(\"SplitPane.dividerSize\"));\n+        if (divSize < 0 || basicDivSize < 0) {\n+            throw new RuntimeException(\"Negative divider size\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JSplitPane\/JSplitPaneTestNegDivSize.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -175,0 +175,1 @@\n+        insertSetting(doc, EventNames.SecurityProviderService, \"threshold\", \"0 ns\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestDefaultConfigurations.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.security;\n+\n+import java.security.*;\n+import java.security.cert.CertPathBuilder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.*;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.EventNames;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+\/*\n+ * @test\n+ * @bug 8254711\n+ * @summary Add JFR events for security crypto algorithms\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.events\n+ * @run main\/othervm jdk.jfr.event.security.TestSecurityProviderServiceEvent\n+ *\/\n+public class TestSecurityProviderServiceEvent {\n+\n+    public static void main(String[] args) throws Exception {\n+        testAlg(cipherFunc, \"AES\", \"SunJCE\",\n+                \"SunEC\", \"Cipher\", 1, Collections.emptyList());\n+        testAlg(signatureFunc, \"SHA256withRSA\", \"SunRsaSign\",\n+                \"SunEC\", \"Signature\", 2, List.of(\"MessageDigest\"));\n+        testAlg(messageDigestFunc, \"SHA-512\", \"SUN\",\n+                \"SunEC\", \"MessageDigest\", 1, Collections.emptyList());\n+        testAlg(keystoreFunc, \"PKCS12\", \"SUN\",\n+                \"SunEC\", \"KeyStore\", 1, Collections.emptyList());\n+        testAlg(certPathBuilderFunc, \"PKIX\", \"SUN\",\n+                \"SunEC\", \"CertPathBuilder\", 2, List.of(\"CertificateFactory\"));\n+    }\n+\n+    private static void testAlg(BiFunction<String, String, Provider> bif, String alg,\n+                String workingProv, String brokenProv, String algType,\n+                                int expected, List<String> other) throws Exception {\n+        \/\/ bootstrap security Provider services\n+        Provider p =  bif.apply(alg, workingProv);\n+\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EventNames.SecurityProviderService);\n+            recording.start();\n+            p = bif.apply(alg, workingProv);\n+            bif.apply(alg, brokenProv);\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            Asserts.assertEquals(events.size(), expected, \"Incorrect number of events\");\n+            assertEvent(events, algType, alg, p.getName(), other);\n+        }\n+    }\n+\n+    private static BiFunction<String, String, Provider> cipherFunc = (s1, p1 ) -> {\n+        Cipher c;\n+        try {\n+            c = Cipher.getInstance(s1, p1);\n+            return c.getProvider();\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException | NoSuchProviderException e) {\n+            \/\/ expected\n+        }\n+        return null;\n+    };\n+\n+    private static BiFunction<String, String, Provider> signatureFunc = (s1, p1 ) -> {\n+        Signature s;\n+        try {\n+            s = Signature.getInstance(s1, p1);\n+            return s.getProvider();\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n+            \/\/ expected\n+        }\n+        return null;\n+    };\n+\n+    private static BiFunction<String, String, Provider> messageDigestFunc = (s1, p1 ) -> {\n+        MessageDigest md;\n+        try {\n+            md = MessageDigest.getInstance(s1, p1);\n+            return md.getProvider();\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n+            \/\/ expected\n+        }\n+        return null;\n+    };\n+\n+    private static BiFunction<String, String, Provider> keystoreFunc = (s1, p1 ) -> {\n+        KeyStore ks;\n+        try {\n+            ks = KeyStore.getInstance(s1, p1);\n+            return ks.getProvider();\n+        } catch (NoSuchProviderException | KeyStoreException e) {\n+            \/\/ expected\n+        }\n+        return null;\n+    };\n+\n+    private static BiFunction<String, String, Provider> certPathBuilderFunc = (s1, p1 ) -> {\n+        CertPathBuilder cps;\n+        try {\n+            cps = CertPathBuilder.getInstance(s1, p1);\n+            return cps.getProvider();\n+        } catch (NoSuchProviderException | NoSuchAlgorithmException e) {\n+            \/\/ expected\n+        }\n+        return null;\n+    };\n+\n+    private static void assertEvent(List<RecordedEvent> events, String type,\n+            String alg, String workingProv, List<String> other) {\n+        boolean secondaryEventOK = other.isEmpty() ? true : false;\n+        for (RecordedEvent e : events) {\n+            if (other.contains(e.getValue(\"type\"))) {\n+                \/\/ secondary operation in service stack while constructing this request\n+                secondaryEventOK = true;\n+                continue;\n+            }\n+            Events.assertField(e, \"provider\").equal(workingProv);\n+            Events.assertField(e, \"type\").equal(type);\n+            Events.assertField(e, \"algorithm\").equal(alg);\n+        }\n+        if (!secondaryEventOK) {\n+            throw new RuntimeException(\"Secondary events missing\");\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestSecurityProviderServiceEvent.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import org.netbeans.jemmy.JemmyProperties;\n@@ -82,0 +83,4 @@\n+\n+        JemmyProperties.setCurrentDispatchingModel(JemmyProperties.ROBOT_MODEL_MASK |\n+                JemmyProperties.SMOOTH_ROBOT_MODEL_MASK);\n+\n@@ -88,0 +93,4 @@\n+        \/\/activate window\n+        frameOperator.clickMouse();\n+        frameOperator.moveMouse(-1, -1);\n+\n@@ -119,1 +128,0 @@\n-\n@@ -126,3 +134,2 @@\n-\n-        \/\/ Dismissing the tooltip by mouse click\n-        toolTipHostComp.clickMouse();\n+        \/\/ Dismissing the tooltip by moving the mouse out\n+        toolTipHostComp.moveMouse(-1, -1);\n@@ -130,1 +137,0 @@\n-\n","filename":"test\/jdk\/sanity\/client\/SwingSet\/src\/ToolTipDemoTest.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-com.sun.management.jmxremote.ssl.enabled.cipher.suites=TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\n+com.sun.management.jmxremote.ssl.enabled.cipher.suites=TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA\n@@ -5,1 +5,1 @@\n-javax.rmi.ssl.client.enabledCipherSuites=TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\n+javax.rmi.ssl.client.enabledCipherSuites=TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/management_ssltest07_ok.properties.in","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -398,0 +398,3 @@\n+     *\n+     * Special case for masOS. If this is sign app image command, returns value\n+     * of \"--app-image\".\n@@ -402,0 +405,3 @@\n+            if (TKit.isOSX() && hasArgument(\"--app-image\")) {\n+                return Path.of(getArgumentValue(\"--app-image\", () -> null));\n+            }\n@@ -821,1 +827,4 @@\n-        final Path lookupPath = AppImageFile.getPathInAppImage(Path.of(\"\"));\n+        Path appImageDir = Path.of(\"\");\n+        if (isImagePackageType() && hasArgument(\"--app-image\")) {\n+            appImageDir = Path.of(getArgumentValue(\"--app-image\", () -> null));\n+        }\n@@ -823,0 +832,1 @@\n+        final Path lookupPath = AppImageFile.getPathInAppImage(appImageDir);\n@@ -827,0 +837,18 @@\n+\n+            \/\/ If file exist validated important values based on arguments\n+            \/\/ Exclude validation when we generating packages from predefined\n+            \/\/ app images, since we do not know if image is signed or not.\n+            if (isImagePackageType() || !hasArgument(\"--app-image\")) {\n+                final Path rootDir = isImagePackageType() ? outputBundle() :\n+                        pathToUnpackedPackageFile(appInstallationDirectory());\n+\n+                boolean expectedValue = hasArgument(\"--mac-sign\");\n+                boolean actualValue = AppImageFile.load(rootDir).isSigned();\n+                TKit.assertTrue(expectedValue == actualValue,\n+                    \"Unexptected value in app image file for <signed>\");\n+\n+                expectedValue = hasArgument(\"--mac-app-store\");\n+                actualValue = AppImageFile.load(rootDir).isAppStore();\n+                TKit.assertTrue(expectedValue == actualValue,\n+                    \"Unexptected value in app image file for <app-store>\");\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        params.put(Arguments.CLIOptions.VERSION.getId(), \"\");\n+        params.put(Arguments.CLIOptions.VERSION.getId(), \"1.0\");\n@@ -107,0 +107,1 @@\n+                    \"<app-version>1.0<\/app-version>\",\n@@ -115,0 +116,1 @@\n+                    \"<app-version>1.0<\/app-version>\",\n@@ -124,0 +126,1 @@\n+                    \"<app-version>1.0<\/app-version>\",\n@@ -169,0 +172,15 @@\n+    @Test\n+    public void testCopyAsSigned() throws IOException {\n+        Map<String, Object> params = new LinkedHashMap<>();\n+        params.put(\"name\", \"Foo\");\n+        params.put(\"main-class\", \"main.Class\");\n+        params.put(\"description\", \"Duck App Description\");\n+        params.put(\"mac-sign\", Boolean.FALSE);\n+\n+        AppImageFile aif = create(params);\n+        Assert.assertFalse(aif.isSigned());\n+\n+        aif = aif.copyAsSigned();\n+        Assert.assertTrue(aif.isSigned());\n+    }\n+\n@@ -218,1 +236,4 @@\n-        Assert.assertTrue(ex.getMessage().contains(\"malformed .jpackage.xml\"));\n+        Assert.assertTrue(ex.getMessage()\n+                .contains(\"generated by another jpackage version or malformed\"));\n+        Assert.assertTrue(ex.getMessage()\n+                .endsWith(\".jpackage.xml\\\"\"));\n","filename":"test\/jdk\/tools\/jpackage\/junit\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-        verifySignature(appImageCmd, signAppImage);\n+        SigningBase.verifyAppImageSignature(appImageCmd, signAppImage, \"testAL\");\n@@ -100,1 +100,1 @@\n-        cmd.execute();\n+        cmd.executeAndAssertImageCreated();\n@@ -103,15 +103,1 @@\n-        verifySignature(appImageCmd, true);\n-    }\n-\n-    private void verifySignature(JPackageCommand appImageCmd, boolean isSigned) throws Exception {\n-        Path launcherPath = appImageCmd.appLauncherPath();\n-        SigningBase.verifyCodesign(launcherPath, isSigned);\n-\n-        Path testALPath = launcherPath.getParent().resolve(\"testAL\");\n-        SigningBase.verifyCodesign(testALPath, isSigned);\n-\n-        Path appImage = appImageCmd.outputBundle();\n-        SigningBase.verifyCodesign(appImage, isSigned);\n-        if (isSigned) {\n-            SigningBase.verifySpctl(appImage, \"exec\");\n-        }\n+        SigningBase.verifyAppImageSignature(appImageCmd, true, \"testAL\");\n@@ -120,1 +106,0 @@\n-\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTwoStepsTest.java","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.ApplicationLayout;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+\n+\/**\n+ * Tests generation of dmg and pkg from signed predefined app image which was\n+ * signed using two step process (generate app image and then signed using\n+ * --app-image and --mac-sign). Test will generate pkg and verifies its\n+ * signature. It verifies that dmg is not signed, but app image inside dmg\n+ * is signed. This test requires that the machine is configured with test\n+ * certificate for \"Developer ID Installer: jpackage.openjdk.java.net\" in\n+ * jpackagerTest keychain with always allowed access to this keychain for user\n+ * which runs test.\n+ * note:\n+ * \"jpackage.openjdk.java.net\" can be over-ridden by systerm property\n+ * \"jpackage.mac.signing.key.user.name\", and\n+ * \"jpackagerTest\" can be over-ridden by system property\n+ * \"jpackage.mac.signing.keychain\"\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type pkg,dmg --app-image\n+ * @library ..\/helpers\n+ * @library \/test\/lib\n+ * @library base\n+ * @key jpackagePlatformPackage\n+ * @build SigningBase\n+ * @build SigningCheck\n+ * @build jtreg.SkippedException\n+ * @build jdk.jpackage.test.*\n+ * @build SigningPackageFromTwoStepAppImageTest\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningPackageFromTwoStepAppImageTest\n+ *\/\n+public class SigningPackageFromTwoStepAppImageTest {\n+\n+    private static void verifyPKG(JPackageCommand cmd) {\n+        if (!cmd.hasArgument(\"--mac-sign\")) {\n+            return; \/\/ Nothing to check if not signed\n+        }\n+\n+        Path outputBundle = cmd.outputBundle();\n+        SigningBase.verifyPkgutil(outputBundle);\n+        SigningBase.verifySpctl(outputBundle, \"install\");\n+    }\n+\n+    private static void verifyDMG(JPackageCommand cmd) {\n+        \/\/ DMG always unsigned, so we will check it\n+        Path outputBundle = cmd.outputBundle();\n+        SigningBase.verifyCodesign(outputBundle, false);\n+    }\n+\n+    private static void verifyAppImageInDMG(JPackageCommand cmd) {\n+        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n+            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n+            \/\/ we only need to verify app.\n+            if (dmgImage.endsWith(cmd.name() + \".app\")) {\n+                Path launcherPath = ApplicationLayout.platformAppImage()\n+                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());\n+                SigningBase.verifyCodesign(launcherPath, true);\n+                SigningBase.verifyCodesign(dmgImage, true);\n+                SigningBase.verifySpctl(dmgImage, \"exec\");\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public static void test(boolean signAppImage) throws Exception {\n+        SigningCheck.checkCertificates();\n+\n+        Path appimageOutput = TKit.createTempDirectory(\"appimage\");\n+\n+        \/\/ Generate app image. Signed or unsigned based on test\n+        \/\/ parameter. We should able to sign predfined app images\n+        \/\/ which are signed or unsigned.\n+        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--dest\", appimageOutput);\n+        if (signAppImage) {\n+            appImageCmd.addArguments(\"--mac-sign\", \"--mac-signing-key-user-name\",\n+                    SigningBase.DEV_NAME, \"--mac-signing-keychain\",\n+                    SigningBase.KEYCHAIN);\n+        }\n+\n+        \/\/ Generate app image\n+        appImageCmd.executeAndAssertHelloAppImageCreated();\n+\n+        \/\/ Double check if it is signed or unsigned based on signAppImage\n+        SigningBase.verifyAppImageSignature(appImageCmd, signAppImage);\n+\n+        \/\/ Sign app image\n+        JPackageCommand appImageSignedCmd = new JPackageCommand();\n+        appImageSignedCmd.setPackageType(PackageType.IMAGE)\n+            .addArguments(\"--app-image\", appImageCmd.outputBundle().toAbsolutePath())\n+            .addArguments(\"--mac-sign\")\n+            .addArguments(\"--mac-signing-key-user-name\", SigningBase.DEV_NAME)\n+            .addArguments(\"--mac-signing-keychain\", SigningBase.KEYCHAIN);\n+        appImageSignedCmd.executeAndAssertImageCreated();\n+\n+        \/\/ Should be signed app image\n+        SigningBase.verifyAppImageSignature(appImageCmd, true);\n+\n+        new PackageTest()\n+                .forTypes(PackageType.MAC)\n+                .addInitializer(cmd -> {\n+                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n+                    cmd.removeArgumentWithValue(\"--input\");\n+                    if (signAppImage) {\n+                        cmd.addArguments(\"--mac-sign\",\n+                                \"--mac-signing-key-user-name\",\n+                                SigningBase.DEV_NAME,\n+                                \"--mac-signing-keychain\",\n+                                SigningBase.KEYCHAIN);\n+                    }\n+                })\n+                .forTypes(PackageType.MAC_PKG)\n+                .addBundleVerifier(\n+                    SigningPackageFromTwoStepAppImageTest::verifyPKG)\n+                .forTypes(PackageType.MAC_DMG)\n+                .addBundleVerifier(\n+                    SigningPackageFromTwoStepAppImageTest::verifyDMG)\n+                .addBundleVerifier(\n+                    SigningPackageFromTwoStepAppImageTest::verifyAppImageInDMG)\n+                .run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.jpackage.test.JPackageCommand;\n@@ -150,0 +151,18 @@\n+    public static void verifyAppImageSignature(JPackageCommand appImageCmd,\n+            boolean isSigned, String... launchers) throws Exception {\n+        Path launcherPath = appImageCmd.appLauncherPath();\n+        SigningBase.verifyCodesign(launcherPath, isSigned);\n+\n+        final List<String> launchersList = List.of(launchers);\n+        launchersList.forEach(launcher -> {\n+            Path testALPath = launcherPath.getParent().resolve(launcher);\n+            SigningBase.verifyCodesign(testALPath, isSigned);\n+        });\n+\n+        Path appImage = appImageCmd.outputBundle();\n+        SigningBase.verifyCodesign(appImage, isSigned);\n+        if (isSigned) {\n+            SigningBase.verifySpctl(appImage, \"exec\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.util.HexFormat;\n+import java.nio.charset.StandardCharsets;\n@@ -69,7 +71,7 @@\n-        execTest(\"\\\"\" + unicodeStr + \"a\" + unicodeStr + \"\\\"\", hexValue + \"61\" + hexValue);\n-        execTest(\"\\\\\" + unicodeStr + \"a\" + unicodeStr + \"\\\\\", hexValue + \"61\" + hexValue);\n-        execTest(\" \" + unicodeStr + \"a\" + unicodeStr + \" \", hexValue + \"61\"+ hexValue);\n-        execTest(\"'\" + unicodeStr + \"a\" + unicodeStr + \"'\", hexValue + \"61\"+ hexValue);\n-        execTest(\"\\t\" + unicodeStr + \"a\" + unicodeStr + \"\\t\", hexValue + \"61\"+ hexValue);\n-        execTest(\"*\" + unicodeStr + \"a\" + unicodeStr + \"*\", hexValue + \"61\"+ hexValue);\n-        execTest(\"?\" + unicodeStr + \"a\" + unicodeStr + \"?\", hexValue + \"61\"+ hexValue);\n+        execTest(\"\\\"\" + unicodeStr + \"a\" + unicodeStr + \"\\\"\", hexValue + \"0061\" + hexValue);\n+        execTest(\"\\\\\" + unicodeStr + \"a\" + unicodeStr + \"\\\\\", hexValue + \"0061\" + hexValue);\n+        execTest(\" \" + unicodeStr + \"a\" + unicodeStr + \" \", hexValue + \"0061\"+ hexValue);\n+        execTest(\"'\" + unicodeStr + \"a\" + unicodeStr + \"'\", hexValue + \"0061\"+ hexValue);\n+        execTest(\"\\t\" + unicodeStr + \"a\" + unicodeStr + \"\\t\", hexValue + \"0061\"+ hexValue);\n+        execTest(\"*\" + unicodeStr + \"a\" + unicodeStr + \"*\", hexValue + \"0061\"+ hexValue);\n+        execTest(\"?\" + unicodeStr + \"a\" + unicodeStr + \"?\", hexValue + \"0061\"+ hexValue);\n@@ -77,7 +79,7 @@\n-        execTest(\"\\\"\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\\"\", hexValue + \"b1\" + hexValue);\n-        execTest(\"\\\\\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\\\\", hexValue + \"b1\" + hexValue);\n-        execTest(\" \" + unicodeStr + \"\\u00b1\" + unicodeStr + \" \", hexValue + \"b1\"+ hexValue);\n-        execTest(\"'\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"'\", hexValue + \"b1\"+ hexValue);\n-        execTest(\"\\t\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\t\", hexValue + \"b1\"+ hexValue);\n-        execTest(\"*\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"*\", hexValue + \"b1\"+ hexValue);\n-        execTest(\"?\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"?\", hexValue + \"b1\"+ hexValue);\n+        execTest(\"\\\"\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\\"\", hexValue + \"00b1\" + hexValue);\n+        execTest(\"\\\\\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\\\\", hexValue + \"00b1\" + hexValue);\n+        execTest(\" \" + unicodeStr + \"\\u00b1\" + unicodeStr + \" \", hexValue + \"00b1\"+ hexValue);\n+        execTest(\"'\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"'\", hexValue + \"00b1\"+ hexValue);\n+        execTest(\"\\t\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"\\t\", hexValue + \"00b1\"+ hexValue);\n+        execTest(\"*\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"*\", hexValue + \"00b1\"+ hexValue);\n+        execTest(\"?\" + unicodeStr + \"\\u00b1\" + unicodeStr + \"?\", hexValue + \"00b1\"+ hexValue);\n@@ -100,6 +102,15 @@\n-        String cmd = \"-Dtest.src=\" + TEST_SOURCES_DIR.getAbsolutePath() +\n-                \" -Dtest.classes=\" + TEST_CLASSES_DIR.getAbsolutePath() +\n-                \" -cp \" + TEST_CLASSES_DIR.getAbsolutePath() +\n-                \" I18NArgTest \" + unicodeStr + \" \" + hexValue;\n-        env.put(\"JDK_JAVA_OPTIONS\", cmd);\n-        tr = doExec(env, javaCmd);\n+        String sysPropName = \"foo.bar\";\n+        \/\/ When pass \"-Dfoo.bar=<unicodestr>\" via the JDK_JAVA_OPTIONS environment variable,\n+        \/\/ we expect that system property value to be passed along to the main method with the\n+        \/\/ correct encoding\n+        \/\/ If <unicodestr> contains space or tab, it should be enclosed with double quotes.\n+        if (unicodeStr.contains(\" \") || unicodeStr.contains(\"\\t\")) {\n+            unicodeStr = \"\\\"\" + unicodeStr + \"\\\"\";\n+        }\n+        String jdkJavaOpts = \"-D\" + sysPropName + \"=\" + unicodeStr;\n+        env.put(\"JDK_JAVA_OPTIONS\", jdkJavaOpts);\n+        tr = doExec(env,javaCmd,\n+                \"-Dtest.src=\" + TEST_SOURCES_DIR.getAbsolutePath(),\n+                \"-Dtest.classes=\" + TEST_CLASSES_DIR.getAbsolutePath(),\n+                \"-cp\", TEST_CLASSES_DIR.getAbsolutePath(),\n+                \"I18NArgTest\", unicodeStr, hexValue, sysPropName);\n@@ -116,4 +127,1 @@\n-        String hexValue = \"\";\n-        for (int i = 0; i < input.length(); i++) {\n-            hexValue = hexValue.concat(Integer.toHexString((int)input.charAt(i)));\n-        }\n+        var hexValue = HexFormat.of().formatHex(input.getBytes(StandardCharsets.UTF_16));\n@@ -128,0 +136,15 @@\n+        if (args.length == 3) {\n+            \/\/ verify the value of the system property matches the expected value\n+            String sysPropName = args[2];\n+            String sysPropVal = System.getProperty(sysPropName);\n+            if (sysPropVal == null) {\n+                throw new RuntimeException(\"Missing system property \" + sysPropName);\n+            }\n+            var sysPropHexVal = HexFormat.of().formatHex(sysPropVal.getBytes(StandardCharsets.UTF_16));\n+            System.out.println(\"System property \" + sysPropName + \" computed hex value: \"\n+                    + sysPropHexVal);\n+            if (!sysPropHexVal.contains(expected)) {\n+                throw new RuntimeException(\"Unexpected value in system property, expected \"\n+                        + expected + \", but got \" + sysPropHexVal);\n+            }\n+        }\n","filename":"test\/jdk\/tools\/launcher\/I18NArgTest.java","additions":48,"deletions":25,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      8254721\n+ * @bug      8254721 6251738\n@@ -76,0 +76,11 @@\n+    @Test\n+    public void testExternalSpecs(Path base) throws IOException {\n+        test(base, \"\"\"\n+                package p;\n+                \/** @spec http:\/\/example.com label. *\/\n+                public class C {  }\n+                \"\"\",\n+                \"external-specs.html\",\n+                b -> checkOutput(\"index-all.html\", b, \"External&nbsp;Specifications\"));\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testConditionalPages\/TestConditionalPages.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,1 @@\n+        \"external-specs-page\",\n@@ -218,0 +219,1 @@\n+            \"ExternalSpecsWriter\",\n@@ -346,0 +348,4 @@\n+            case \"ExternalSpecsWriter\":\n+                check(generator, content, content.startsWith(\"external specifications\"));\n+                break;\n+\n@@ -399,1 +405,10 @@\n-                    \"\/** Class pA.CA. *\/ package pA; public class CA { @Deprecated public static final int ZERO = 0; }\",\n+                    \"\"\"\n+                        \/** Class pA.CA. *\/\n+                        package pA; public class CA {\n+                            \/**\n+                             * First sentence.\n+                             * @spec http:\/\/example.com example reference\n+                             *\/\n+                            @Deprecated public static final int ZERO = 0;\n+                        }\n+                        \"\"\",\n@@ -414,1 +429,11 @@\n-                        .classes(\"\/** Class mA\/pA.CA. *\/ package pA; public class CA { @Deprecated public static int ZERO = 0; }\")\n+                        .classes(\"\"\"\n+                            \/** Class mA\/pA.CA. *\/\n+                            package pA;\n+                            public class CA {\n+                                \/**\n+                                 * First sentence.\n+                                 * @spec http:\/\/example.com example reference\n+                                 *\/\n+                                @Deprecated public static int ZERO = 0;\n+                            }\n+                        \"\"\")\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMetadata\/TestMetadata.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,432 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6251738 8226279\n+ * @summary JDK-8226279 javadoc should support a new at-spec tag\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestSpecTag\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestSpecTag extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        TestSpecTag tester = new TestSpecTag();\n+        tester.runTests(m -> new Object[] { Path.of(m.getName()) });\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    enum LinkKind { ABSOLUTE, RELATIVE }\n+\n+    @Test\n+    public void testBadSpecBaseURI(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"package p; public class C { }\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--spec-base-url\", \"http:\/\/[\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.CMDERR);\n+        checkOutput(Output.OUT, true,\n+                \"error: invalid URL: Expected closing bracket for IPv6 address at index 8: http:\/\/[\");\n+    }\n+\n+    @Test\n+    public void testBadSpecURI(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"package p; \/** @spec http:\/\/[ label *\/ public class C { }\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.ERROR);\n+\n+        checkOutput(Output.OUT, true,\n+                \"testBadSpecURI\/src\/p\/C.java:1:\".replace('\/', File.separatorChar)\n+                    + \" error: invalid URL: Expected closing bracket for IPv6 address at index 8: http:\/\/[\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>External Specifications<\/dt>\n+                    <dd><span id=\"label\" class=\"search-tag-result\">label<\/span><\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+\n+        checkOutput(\"external-specs.html\", true,\n+                \"\"\"\n+                    <div class=\"col-first even-row-color\">label<\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <ul class=\"ref-list\">\n+                    <li><code><a href=\"p\/C.html#label\">class p.C<\/a><\/code><\/li>\n+                    <\/ul>\n+                    <\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testNavigation(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"package p; \/** @spec http:\/\/example.com label *\/ public class C { }\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"external-specs.html\", true,\n+                \"\"\"\n+                    <!-- ========= START OF TOP NAVBAR ======= -->\n+                    <div class=\"top-nav\" id=\"navbar-top\"><button id=\"navbar-toggle-button\" aria-controls=\"navbar-top\" aria-expanded=\"false\" aria-label=\"Toggle navigation links\"><span class=\"nav-bar-toggle-icon\">&nbsp;<\/span><span class=\"nav-bar-toggle-icon\">&nbsp;<\/span><span class=\"nav-bar-toggle-icon\">&nbsp;<\/span><\/button>\n+                    <div class=\"skip-nav\"><a href=\"#skip-navbar-top\" title=\"Skip navigation links\">Skip navigation links<\/a><\/div>\n+                    <ul id=\"navbar-top-firstrow\" class=\"nav-list\" title=\"Navigation\">\n+                    <li><a href=\"p\/package-summary.html\">Package<\/a><\/li>\n+                    <li>Class<\/li>\n+                    <li><a href=\"p\/package-tree.html\">Tree<\/a><\/li>\n+                    <li><a href=\"index-all.html\">Index<\/a><\/li>\n+                    <li><a href=\"help-doc.html#external-specs\">Help<\/a><\/li>\n+                    <\/ul>\n+                    <\/div>\n+                    <div class=\"sub-nav\">\n+                    <div id=\"navbar-sub-list\"><\/div>\n+                    <div class=\"nav-list-search\"><a href=\"search.html\">SEARCH<\/a>\n+                    <input type=\"text\" id=\"search-input\" disabled placeholder=\"Search\">\n+                    <input type=\"reset\" id=\"reset-button\" disabled value=\"reset\">\n+                    <\/div>\n+                    <\/div>\n+                    <!-- ========= END OF TOP NAVBAR ========= -->\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testEncodedURI(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        \/\/ The default encoding for OpenJDK source files is ASCII.\n+        \/\/ The following writes a file using UTF-8 containing a non-ASCII character (section)\n+        \/\/ and a Unicode escape for another character (plus or minus)\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * @spec http:\/\/example.com\/a+b         space: plus\n+                 * @spec http:\/\/example.com\/a%20b       space: percent\n+                 * @spec http:\/\/example.com\/a\\u00A7b    other: section; U+00A7, UTF-8 c2 a7\n+                 * @spec http:\/\/example.com\/a\\\\u00B1b   unicode: plus or minus; U+00B1, UTF-8 c2 b1\n+                 *\/\n+                public class C { }\n+                \"\"\");\n+\n+        \/\/ Ensure the source file is read using UTF-8\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"-encoding\", \"UTF-8\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>External Specifications<\/dt>\n+                    <dd><a href=\"http:\/\/example.com\/a+b\"><span id=\"space:plus\" class=\"search-tag-result\">space: plus<\/span><\/a>,\\s\n+                    <a href=\"http:\/\/example.com\/a%20b\"><span id=\"space:percent\" class=\"search-tag-result\">space: percent<\/span><\/a>,\\s\n+                    <a href=\"http:\/\/example.com\/a%C2%A7b\"><span id=\"other:section;U+00A7,UTF-8c2a7\" class=\"search-tag-result\">other: section; U+00A7, UTF-8 c2 a7<\/span><\/a>,\\s\n+                    <a href=\"http:\/\/example.com\/a%C2%B1b\"><span id=\"unicode:plusorminus;U+00B1,UTF-8c2b1\" class=\"search-tag-result\">unicode: plus or minus; U+00B1, UTF-8 c2 b1<\/span><\/a><\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+\n+        checkOutput(\"external-specs.html\", true,\n+                \"\"\"\n+                    <div class=\"table-header col-first\">Specification<\/div>\n+                    <div class=\"table-header col-last\">Referenced In<\/div>\n+                    <div class=\"col-first even-row-color\"><a href=\"http:\/\/example.com\/a%C2%A7b\">other: section; U+00A7, UTF-8 c2 a7<\/a><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <ul class=\"ref-list\">\n+                    <li><code><a href=\"p\/C.html#other:section;U+00A7,UTF-8c2a7\">class p.C<\/a><\/code><\/li>\n+                    <\/ul>\n+                    <\/div>\n+                    <div class=\"col-first odd-row-color\"><a href=\"http:\/\/example.com\/a%20b\">space: percent<\/a><\/div>\n+                    <div class=\"col-last odd-row-color\">\n+                    <ul class=\"ref-list\">\n+                    <li><code><a href=\"p\/C.html#space:percent\">class p.C<\/a><\/code><\/li>\n+                    <\/ul>\n+                    <\/div>\n+                    <div class=\"col-first even-row-color\"><a href=\"http:\/\/example.com\/a+b\">space: plus<\/a><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <ul class=\"ref-list\">\n+                    <li><code><a href=\"p\/C.html#space:plus\">class p.C<\/a><\/code><\/li>\n+                    <\/ul>\n+                    <\/div>\n+                    <div class=\"col-first odd-row-color\"><a href=\"http:\/\/example.com\/a%C2%B1b\">unicode: plus or minus; U+00B1, UTF-8 c2 b1<\/a><\/div>\n+                    <div class=\"col-last odd-row-color\">\n+                    <ul class=\"ref-list\">\n+                    <li><code><a href=\"p\/C.html#unicode:plusorminus;U+00B1,UTF-8c2b1\">class p.C<\/a><\/code><\/li>\n+                    <\/ul>\n+                    <\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testDuplicateRefs(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * @spec http:\/\/example.com\/ example\n+                 *\/\n+                public class C {\n+                    \/**\n+                     * @spec http:\/\/example.com\/ example\n+                     *\/\n+                     public void m() { }\n+                    \/**\n+                     * @spec http:\/\/example.com\/ example\n+                     *\/\n+                     public int f;\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOrder(\"p\/C.html\",\n+                \"<h1 title=\\\"Class C\\\" class=\\\"title\\\">Class C<\/h1>\",\n+                \"\"\"\n+                    <dt>External Specifications<\/dt>\n+                    <dd><a href=\"http:\/\/example.com\/\"><span id=\"example\" class=\"search-tag-result\">example<\/span><\/a><\/dd>\n+                    \"\"\",\n+                \"<section class=\\\"field-details\\\" id=\\\"field-detail\\\">\",\n+                \"\"\"\n+                    <dt>External Specifications<\/dt>\n+                    <dd><a href=\"http:\/\/example.com\/\"><span id=\"example-1\" class=\"search-tag-result\">example<\/span><\/a><\/dd>\n+                    \"\"\",\n+                \"<section class=\\\"detail\\\" id=\\\"m()\\\">\",\n+                \"\"\"\n+                    <dt>External Specifications<\/dt>\n+                    <dd><a href=\"http:\/\/example.com\/\"><span id=\"example-2\" class=\"search-tag-result\">example<\/span><\/a><\/dd>\n+                    \"\"\");\n+\n+        checkOutput(\"external-specs.html\", true,\n+                \"\"\"\n+                    <div class=\"col-first even-row-color\"><a href=\"http:\/\/example.com\/\">example<\/a><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <ul class=\"ref-list\">\n+                    <li><code><a href=\"p\/C.html#example\">class p.C<\/a><\/code><\/li>\n+                    <li><code><a href=\"p\/C.html#example-1\">p.C.f<\/a><\/code><\/li>\n+                    <li><code><a href=\"p\/C.html#example-2\">p.C.m()<\/a><\/code><\/li>\n+                    <\/ul>\n+                    <\/div>\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testMultiple(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * First sentence.\n+                 * @spec http:\/\/example.com\/1 example-1\n+                 * @spec http:\/\/example.com\/2 example-2\n+                 *\/\n+                public class C { }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dt>External Specifications<\/dt>\n+                    <dd><a href=\"http:\/\/example.com\/1\"><span id=\"example-1\" class=\"search-tag-result\">example-1<\/span><\/a>,\\s\n+                    <a href=\"http:\/\/example.com\/2\"><span id=\"example-2\" class=\"search-tag-result\">example-2<\/span><\/a><\/dd>\n+                    \"\"\");\n+\n+        checkOutput(\"external-specs.html\", true,\n+                \"\"\"\n+                    <div class=\"col-first even-row-color\"><a href=\"http:\/\/example.com\/1\">example-1<\/a><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <ul class=\"ref-list\">\n+                    <li><code><a href=\"p\/C.html#example-1\">class p.C<\/a><\/code><\/li>\n+                    <\/ul>\n+                    <\/div>\n+                    <div class=\"col-first odd-row-color\"><a href=\"http:\/\/example.com\/2\">example-2<\/a><\/div>\n+                    <div class=\"col-last odd-row-color\">\n+                    <ul class=\"ref-list\">\n+                    <li><code><a href=\"p\/C.html#example-2\">class p.C<\/a><\/code><\/li>\n+                    <\/ul>\n+                    <\/div>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testMultipleTitlesForURL(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/** Class C. *\/\n+                public class C {\n+                    private C() { }\n+\n+                    \/**\n+                     * Method m1.\n+                     * @spec http:\/\/example.com\/index.html first\n+                     *\/\n+                     public void m1() { }\n+\n+                    \/**\n+                     * Method m2.\n+                     * @spec http:\/\/example.com\/index.html second\n+                     *\/\n+                     public void m2() { }\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.ERROR);\n+\n+        checkOutput(Output.OUT, true,\n+                \"\"\"\n+                    error: 2 different titles given in @spec tags for the external specification at http:\/\/example.com\/index.html\n+                    #FILE#:8: Note: url: http:\/\/example.com\/index.html, title: \"first\"\n+                         * @spec http:\/\/example.com\/index.html first\n+                           ^\n+                    #FILE#:14: Note: url: http:\/\/example.com\/index.html, title: \"second\"\n+                         * @spec http:\/\/example.com\/index.html second\n+                           ^\n+                    \"\"\"\n+                    .replace(\"#FILE#\", src.resolve(\"p\").resolve(\"C.java\").toString()));\n+    }\n+\n+    @Test\n+    public void testMultipleURLsForTitle(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/** Class C. *\/\n+                public class C {\n+                    private C() { }\n+\n+                    \/**\n+                     * Method m1.\n+                     * @spec http:\/\/example.com\/index1.html Example Title\n+                     *\/\n+                     public void m1() { }\n+\n+                    \/**\n+                     * Method m2.\n+                     * @spec http:\/\/example.com\/index2.html Example Title\n+                     *\/\n+                     public void m2() { }\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.ERROR);\n+\n+        checkOutput(Output.OUT, true,\n+                \"\"\"\n+                    error: The title \"Example Title\" is used for 2 different external specifications in @spec tags\n+                    #FILE#:8: Note: title: \"Example Title\", url: http:\/\/example.com\/index1.html\n+                         * @spec http:\/\/example.com\/index1.html Example Title\n+                           ^\n+                    #FILE#:14: Note: title: \"Example Title\", url: http:\/\/example.com\/index2.html\n+                         * @spec http:\/\/example.com\/index2.html Example Title\n+                           ^\n+                    \"\"\"\n+                    .replace(\"#FILE#\", src.resolve(\"p\").resolve(\"C.java\").toString()));\n+    }\n+\n+    @Test\n+    public void testCombo(Path base) throws IOException {\n+        for (LinkKind lk : LinkKind.values()) {\n+            test(base, lk);\n+        }\n+    }\n+\n+    void test(Path base, LinkKind lk) throws IOException {\n+        Path dir = Files.createDirectories(base.resolve(lk.toString()));\n+        Path src = genSource(dir, lk);\n+\n+        javadoc(\"-d\", dir.resolve(\"out\").toString(),\n+                \"--spec-base-url\", \"http:\/\/example.com\/\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>External Specifications<\/dt>\n+                    <dd><a href=\"http:\/\/example.com\/#LK#\"><span id=\"#LK#reference\" \\\n+                    class=\"search-tag-result\">#LK# reference<\/span><\/a><\/dd>\n+                    <\/dl>\"\"\"\n+                .replaceAll(\"#LK#\", lk.toString().toLowerCase()));\n+\n+        checkOutput(\"external-specs.html\", true,\n+                \"\"\"\n+                        <div class=\"col-first even-row-color\"><a href=\"http:\/\/example.com\/#LK#\">#LK# reference<\/a><\/div>\n+                        <div class=\"col-last even-row-color\">\n+                        <ul class=\"ref-list\">\n+                        <li><code><a href=\"p\/C.html##LK#reference\">class p.C<\/a><\/code><\/li>\n+                        <\/ul>\n+                        <\/div>\"\"\"\n+                        .replaceAll(\"#LK#\", lk.toString().toLowerCase()));\n+    }\n+\n+    Path genSource(Path base, LinkKind lk) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        String template = \"\"\"\n+                \/**\n+                 * First sentence.\n+                 * @spec #SPEC#\n+                 *\/\n+                \"\"\";\n+\n+        String spec = switch (lk) {\n+            case ABSOLUTE -> \"http:\/\/example.com\/absolute absolute reference\";\n+            case RELATIVE -> \"relative                    relative reference\";\n+        };\n+        String comment = template.replace(\"#SPEC#\", spec);\n+        tb.writeJavaFiles(src,\n+                \"package p;\\n\" + comment + \"public class C { }\");\n+\n+        return src;\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSpecTag\/TestSpecTag.java","additions":432,"deletions":0,"binary":false,"changes":432,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      8202947\n+ * @bug      8202947 8294471\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTaglets\/TestTaglets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+               @spec: block overview module package type constructor method field ...... ........\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTaglets\/TestTaglets.out","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    List<String> MISSING_IN_MAN_PAGE = List.of();\n+    List<String> MISSING_IN_MAN_PAGE = List.of(\"--spec-base-url\");\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckManPageOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.dc.no.title\n+\/\/ key: compiler.note.note\n+\/\/ key: compiler.note.proc.messager\n+\/\/ run: backdoor\n+\/\/ options: -processor DocCommentProcessor -proc:only\n+\n+\/** @spec http:\/\/example.com *\/\n+class NoTitle { }\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NoTitle.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.dc.no.url\n+\/\/ key: compiler.note.note\n+\/\/ key: compiler.note.proc.messager\n+\/\/ run: backdoor\n+\/\/ options: -processor DocCommentProcessor -proc:only\n+\n+\/** @spec *\/\n+class NoURL { }\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NoURL.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -602,0 +602,12 @@\n+            @Override\n+            public Void visitSpec(SpecTree node, Void p) {\n+                header(node);\n+                indent(+1);\n+                print(\"url\", node.getURL());\n+                print(\"title\", node.getTitle());\n+                indent(-1);\n+                indent();\n+                out.println(\"]\");\n+                return null;\n+            }\n+\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6251738 8226279\n+ * @summary javadoc should support a new at-spec tag\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build DocCommentTester\n+ * @run main DocCommentTester SpecTest.java\n+ *\/\n+\n+class SpecTest {\n+\n+    \/**\n+     * abc.\n+     * @spec http:\/\/example.com title\n+     *\/\n+    void block() {}\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 1\n+    Text[TEXT, pos:1, abc.]\n+  body: empty\n+  block tags: 1\n+    Spec[SPEC, pos:7\n+      url:\n+        Text[TEXT, pos:13, http:\/\/example.com]\n+      title: 1\n+        Text[TEXT, pos:32, title]\n+    ]\n+]\n+*\/\n+\n+    \/**\n+     * abc.\n+     * @spec\n+     *\/\n+    void bad_no_url() {}\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 1\n+    Text[TEXT, pos:1, abc.]\n+  body: empty\n+  block tags: 1\n+    Erroneous[ERRONEOUS, pos:7, prefPos:11\n+      code: compiler.err.dc.no.url\n+      body: @spec\n+    ]\n+]\n+*\/\n+\n+    \/**\n+     * abc.\n+     * @spec http:\/\/example.com\n+     *\/\n+    void bad_no_label() {}\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 1\n+    Text[TEXT, pos:1, abc.]\n+  body: empty\n+  block tags: 1\n+    Erroneous[ERRONEOUS, pos:7, prefPos:30\n+      code: compiler.err.dc.no.title\n+      body: @spec_http:\/\/example.com\n+    ]\n+]\n+*\/\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/SpecTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -1145,0 +1145,6 @@\n+        public Void visitSpec(SpecTree node, Void p) {\n+            printDocTree(\"url\", node.getURL());\n+            printList(\"title\", node.getTitle());\n+            return visitBlockTag(node, null);\n+        }\n+\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8292756\n+ * @summary Verify the Scope can be safely and correctly resized to accommodate pattern binding variables\n+ *          when the Scope for a guard is constructed.\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @build combo.ComboTestHelper\n+ * @compile ScopeResizeTest.java\n+ * @run main ScopeResizeTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask;\n+import combo.ComboTestHelper;\n+import java.util.stream.Stream;\n+import toolbox.ToolBox;\n+\n+public class ScopeResizeTest extends ComboInstance<ScopeResizeTest> {\n+    protected ToolBox tb;\n+\n+    ScopeResizeTest() {\n+        super();\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        int variantsSize = 17;\n+        PredefinedVariables[] variants = Stream.iterate(0, i -> i + 1)\n+                                               .limit(variantsSize)\n+                                               .map(s -> new PredefinedVariables(s))\n+                                               .toArray(s -> new PredefinedVariables[s]);\n+        new ComboTestHelper<ScopeResizeTest>()\n+                .withDimension(\"PREDEFINED_VARIABLES\", (x, predefinedVariables) -> x.predefinedVariables = predefinedVariables, variants)\n+                .run(ScopeResizeTest::new);\n+    }\n+\n+    private PredefinedVariables predefinedVariables;\n+\n+    private static final String MAIN_TEMPLATE =\n+            \"\"\"\n+            public class Test {\n+                public static void test(Object o) {\n+                    #{PREDEFINED_VARIABLES}\n+                    switch (o) {\n+                        case String s when s.isEmpty() -> {}\n+                        default -> {}\n+                    }\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    protected void doWork() throws Throwable {\n+        ComboTask task = newCompilationTask()\n+                .withSourceFromTemplate(MAIN_TEMPLATE, pname -> switch (pname) {\n+                        case \"PREDEFINED_VARIABLES\" -> predefinedVariables;\n+                        default -> throw new UnsupportedOperationException(pname);\n+                    });\n+\n+        task.analyze(result -> {});\n+    }\n+\n+    public record PredefinedVariables(int size) implements ComboParameter {\n+        @Override\n+        public String expand(String optParameter) {\n+            StringBuilder variables = new StringBuilder();\n+            for (int i = 0; i < size(); i++) {\n+                variables.append(\"int i\" + i + \";\\n\");\n+            }\n+            return variables.toString();\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ScopeResizeTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -196,0 +196,1 @@\n+    public final static String SecurityProviderService = PREFIX + \"SecurityProviderService\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -369,0 +369,16 @@\n+    @Benchmark\n+    @Fork(jvmArgsPrepend = {\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\"})\n+    public void cmoveD() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = resD[i] < doubles[i] ? resD[i] : doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsPrepend = {\"-XX:+UseCMoveUnconditionally\", \"-XX:+UseVectorCmov\"})\n+    public void cmoveF() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = resF[i] < floats[i] ? resF[i] : floats[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}