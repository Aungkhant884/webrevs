{"files":[{"patch":"@@ -72,2 +72,0 @@\n-    -tag spec:X \\\n-    -tag specdefault:X \\\n@@ -89,0 +87,1 @@\n+    -tag spec \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1145,1 +1145,1 @@\n-            revision: \"1.34+1.0\"\n+            revision: \"1.35+1.0\"\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,1 +198,0 @@\n-JVM_ResumeThread\n@@ -209,2 +208,0 @@\n-JVM_StopThread\n-JVM_SuspendThread\n@@ -231,0 +228,1 @@\n+JVM_VirtualThreadHideFrames\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2573,1 +2573,1 @@\n-#ifdef ASSERT0\n+#ifdef ASSERT\n@@ -2575,2 +2575,1 @@\n-    __ ldr(rscratch1, Address(rthread,\n-                              JavaThread::last_Java_fp_offset()));\n+    __ ldr(rscratch1, Address(rthread, JavaThread::last_Java_fp_offset()));\n@@ -2848,1 +2847,1 @@\n-    __ stop(\"SharedRuntime::generate_deopt_blob: last_Java_fp not cleared\");\n+    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  __ cmpl(disarmed_addr, 0);\n+  __ cmpl_imm32(disarmed_addr, 0);\n@@ -333,1 +333,1 @@\n-  __ cmpl(disarmed_addr, 0);\n+  __ cmpl_imm32(disarmed_addr, 0);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3278,0 +3278,16 @@\n+void MacroAssembler::testl(Address dst, int32_t imm32) {\n+  if (imm32 >= 0 && is8bit(imm32)) {\n+    testb(dst, imm32);\n+  } else {\n+    Assembler::testl(dst, imm32);\n+  }\n+}\n+\n+void MacroAssembler::testl(Register dst, int32_t imm32) {\n+  if (imm32 >= 0 && is8bit(imm32) && dst->has_byte_register()) {\n+    testb(dst, imm32);\n+  } else {\n+    Assembler::testl(dst, imm32);\n+  }\n+}\n+\n@@ -3279,1 +3295,1 @@\n-  assert(reachable(src), \"Address should be reachable\");\n+  assert(always_reachable(src), \"Address should be reachable\");\n@@ -3283,0 +3299,20 @@\n+#ifdef _LP64\n+\n+void MacroAssembler::testq(Address dst, int32_t imm32) {\n+  if (imm32 >= 0) {\n+    testl(dst, imm32);\n+  } else {\n+    Assembler::testq(dst, imm32);\n+  }\n+}\n+\n+void MacroAssembler::testq(Register dst, int32_t imm32) {\n+  if (imm32 >= 0) {\n+    testl(dst, imm32);\n+  } else {\n+    Assembler::testq(dst, imm32);\n+  }\n+}\n+\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -894,0 +894,2 @@\n+  void testl(Address dst, int32_t imm32);\n+  void testl(Register dst, int32_t imm32);\n@@ -895,0 +897,3 @@\n+  using Assembler::testq;\n+  void testq(Address dst, int32_t imm32);\n+  void testq(Register dst, int32_t imm32);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2500,1 +2500,1 @@\n-    __ stop(\"SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\");\n+    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3118,1 +3118,1 @@\n-    __ stop(\"SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\");\n+    __ stop(\"SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -833,1 +833,1 @@\n-    ClassLoaderExt::process_jar_manifest(current, entry, check_for_duplicates);\n+    ClassLoaderExt::process_jar_manifest(current, entry);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1722,1 +1722,0 @@\n-int java_lang_Thread_FieldHolder::_stillborn_offset;\n@@ -1730,1 +1729,0 @@\n-  macro(_stillborn_offset,     k, \"stillborn\",                bool_signature,        false); \\\n@@ -1763,8 +1761,0 @@\n-bool java_lang_Thread_FieldHolder::is_stillborn(oop holder) {\n-  return holder->bool_field(_stillborn_offset) != 0;\n-}\n-\n-void java_lang_Thread_FieldHolder::set_stillborn(oop holder) {\n-  holder->bool_field_put(_stillborn_offset, true);\n-}\n-\n@@ -1934,15 +1924,0 @@\n-bool java_lang_Thread::is_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::is_stillborn(holder);\n-}\n-\n-\n-\/\/ We never have reason to turn the stillborn bit off\n-void java_lang_Thread::set_stillborn(oop java_thread) {\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != NULL, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_stillborn(holder);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -395,3 +395,0 @@\n-  \/\/ Stillborn\n-  static bool is_stillborn(oop java_thread);\n-  static void set_stillborn(oop java_thread);\n@@ -450,1 +447,0 @@\n-  static int _stillborn_offset;\n@@ -466,3 +462,0 @@\n-  static bool is_stillborn(oop holder);\n-  static void set_stillborn(oop holder);\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  do_klass(ThreadDeath_klass,                           java_lang_ThreadDeath                                 ) \\\n@@ -201,1 +200,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  template(java_lang_ThreadDeath,                     \"java\/lang\/ThreadDeath\")                    \\\n@@ -399,1 +398,0 @@\n-  template(stillborn_name,                            \"stillborn\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,2 @@\n+\n+  _deferred_obj_array = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapWord*>(10, mtGC);\n@@ -169,0 +171,9 @@\n+void ParCompactionManager::drain_deferred_objects() {\n+  while (!_deferred_obj_array->is_empty()) {\n+    HeapWord* addr = _deferred_obj_array->pop();\n+    assert(addr != NULL, \"expected a deferred object\");\n+    PSParallelCompact::update_deferred_object(this, addr);\n+  }\n+  _deferred_obj_array->clear_and_deallocate();\n+}\n+\n@@ -199,0 +210,4 @@\n+void ParCompactionManager::push_deferred_object(HeapWord* addr) {\n+  _deferred_obj_array->push(addr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2431,0 +2431,4 @@\n+\n+    \/\/ At this point all regions have been compacted, so it's now safe\n+    \/\/ to update the deferred objects that cross region boundaries.\n+    cm->drain_deferred_objects();\n@@ -2460,1 +2464,1 @@\n-    \/\/ Verify that all regions have been processed before the deferred updates.\n+    \/\/ Verify that all regions have been processed.\n@@ -2467,9 +2471,0 @@\n-  {\n-    GCTraceTime(Trace, gc, phases) tm(\"Deferred Updates\", &_gc_timer);\n-    \/\/ Update the deferred objects, if any.\n-    ParCompactionManager* cm = ParCompactionManager::get_vmthread_cm();\n-    for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n-      update_deferred_objects(cm, SpaceId(id));\n-    }\n-  }\n-\n@@ -2602,4 +2597,2 @@\n-void PSParallelCompact::update_deferred_objects(ParCompactionManager* cm,\n-                                                SpaceId id) {\n-  assert(id < last_space_id, \"bad space id\");\n-\n+void PSParallelCompact::update_deferred_object(ParCompactionManager* cm, HeapWord *addr) {\n+#ifdef ASSERT\n@@ -2607,2 +2600,4 @@\n-  const SpaceInfo* const space_info = _space_info + id;\n-  ObjectStartArray* const start_array = space_info->start_array();\n+  size_t region_idx = sd.addr_to_region_idx(addr);\n+  assert(sd.region(region_idx)->completed(), \"first region must be completed before deferred updates\");\n+  assert(sd.region(region_idx + 1)->completed(), \"second region must be completed before deferred updates\");\n+#endif\n@@ -2610,17 +2605,4 @@\n-  const MutableSpace* const space = space_info->space();\n-  assert(space_info->dense_prefix() >= space->bottom(), \"dense_prefix not set\");\n-  HeapWord* const beg_addr = space_info->dense_prefix();\n-  HeapWord* const end_addr = sd.region_align_up(space_info->new_top());\n-\n-  const RegionData* const beg_region = sd.addr_to_region_ptr(beg_addr);\n-  const RegionData* const end_region = sd.addr_to_region_ptr(end_addr);\n-  const RegionData* cur_region;\n-  for (cur_region = beg_region; cur_region < end_region; ++cur_region) {\n-    HeapWord* const addr = cur_region->deferred_obj_addr();\n-    if (addr != NULL) {\n-      if (start_array != NULL) {\n-        start_array->allocate_block(addr);\n-      }\n-      cm->update_contents(cast_to_oop(addr));\n-      assert(oopDesc::is_oop_or_null(cast_to_oop(addr)), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n-    }\n+  const SpaceInfo* const space_info = _space_info + space_id(addr);\n+  ObjectStartArray* const start_array = space_info->start_array();\n+  if (start_array != NULL) {\n+    start_array->allocate_block(addr);\n@@ -2628,0 +2610,3 @@\n+\n+  cm->update_contents(cast_to_oop(addr));\n+  assert(oopDesc::is_oop(cast_to_oop(addr)), \"Expected an oop at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n@@ -2874,1 +2859,0 @@\n-      region_ptr->set_deferred_obj_addr(NULL);\n@@ -2919,1 +2903,1 @@\n-      region_ptr->set_deferred_obj_addr(closure.destination());\n+      cm->push_deferred_object(closure.destination());\n@@ -2931,1 +2915,0 @@\n-      region_ptr->set_deferred_obj_addr(NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":19,"deletions":36,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -136,0 +136,4 @@\n+  private:\n+    template <typename T>\n+    static void oop_store_common(T* addr, oop value);\n+\n@@ -177,1 +181,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-inline void ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_store_not_in_heap(T* addr, oop value) {\n+inline void ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_store_common(T* addr, oop value) {\n@@ -253,0 +253,6 @@\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline void ShenandoahBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_store_not_in_heap(T* addr, oop value) {\n+  oop_store_common(addr, value);\n+}\n+\n@@ -258,2 +264,1 @@\n-  shenandoah_assert_not_in_cset_except    (addr, value, value == NULL || ShenandoahHeap::heap()->cancelled_gc() || !ShenandoahHeap::heap()->is_concurrent_mark_in_progress());\n-  oop_store_not_in_heap(addr, value);\n+  oop_store_common(addr, value);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -272,3 +272,0 @@\n-JNIEXPORT void JNICALL\n-JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);\n-\n@@ -278,6 +275,0 @@\n-JNIEXPORT void JNICALL\n-JVM_SuspendThread(JNIEnv *env, jobject thread);\n-\n-JNIEXPORT void JNICALL\n-JVM_ResumeThread(JNIEnv *env, jobject thread);\n-\n@@ -1165,0 +1156,3 @@\n+JNIEXPORT void JNICALL\n+JVM_VirtualThreadHideFrames(JNIEnv* env, jobject vthread, jboolean hide);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1042,5 +1042,1 @@\n-  if (!exception->is_a(vmClasses::ThreadDeath_klass())) {\n-    exception = get_preinitialized_exception(\n-                       vmClasses::IllegalMonitorStateException_klass(),\n-                       CATCH);\n-  }\n+  exception = get_preinitialized_exception(vmClasses::IllegalMonitorStateException_klass(), CATCH);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,7 +80,2 @@\n-      add->set_req(1, in11);\n-      add->set_req(2, in12);\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (igvn) {\n-        igvn->_worklist.push(in1);\n-        igvn->_worklist.push(in2);\n-      }\n+      add->set_req_X(1, in11, phase);\n+      add->set_req_X(2, in12, phase);\n@@ -635,6 +630,1 @@\n-      set_req(Offset, add->in(2));\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (add->outcnt() == 0 && igvn) {\n-        \/\/ add disconnected.\n-        igvn->_worklist.push((Node*)add);\n-      }\n+      set_req_X(Offset, add->in(2), phase); \/\/ puts add on igvn worklist if needed\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1665,1 +1665,1 @@\n-    igvn->C->root()->rm_prec(nb);\n+    igvn->delete_precedence_of(igvn->C->root(), nb);\n@@ -1835,1 +1835,1 @@\n-        phase->C->root()->add_req(halt);\n+        igvn->add_input_to(phase->C->root(), halt);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -577,1 +577,3 @@\n-    root()->dump(9999);\n+    tty->print_cr(\"AFTER: %s\", phase_name);\n+    \/\/ Print out all nodes in ascending order of index.\n+    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\");\n@@ -652,1 +654,1 @@\n-                  _print_inlining_stream(NULL),\n+                  _print_inlining_stream(new stringStream()),\n@@ -933,1 +935,1 @@\n-    _print_inlining_stream(NULL),\n+    _print_inlining_stream(new stringStream()),\n@@ -3466,0 +3468,1 @@\n+    cfg.verify_dominator_tree();\n@@ -4918,7 +4921,0 @@\n-void Compile::print_inlining_stream_free() {\n-  if (_print_inlining_stream != NULL) {\n-    _print_inlining_stream->~stringStream();\n-    _print_inlining_stream = NULL;\n-  }\n-}\n-\n@@ -4936,2 +4932,1 @@\n-    print_inlining_stream_free();\n-    _print_inlining_stream = new stringStream();\n+    print_inlining_reset();\n@@ -4944,3 +4939,1 @@\n-    print_inlining_stream_free();\n-    \/\/ Re allocate buffer when we change ResourceMark\n-    _print_inlining_stream = new stringStream();\n+    print_inlining_reset();\n@@ -5036,1 +5029,1 @@\n-    print_inlining_stream_free();\n+    print_inlining_reset();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -472,1 +472,0 @@\n-  void print_inlining_stream_free();\n@@ -486,1 +485,1 @@\n-  outputStream* print_inlining_stream() const {\n+  stringStream* print_inlining_stream() {\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1008,1 +1008,0 @@\n-          igvn->_worklist.push(in(1));\n@@ -1058,1 +1057,0 @@\n-    igvn->_worklist.push(in(1));\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2400,3 +2400,1 @@\n-    case Op_CMoveP:\n-    case Op_CMoveVF:\n-    case Op_CMoveVD:  {\n+    case Op_CMoveP: {\n@@ -2414,0 +2412,14 @@\n+    case Op_CMoveVF:\n+    case Op_CMoveVD: {\n+      \/\/ Restructure into a binary tree for Matching:\n+      \/\/ CMoveVF (Binary bool mask) (Binary src1 src2)\n+      Node* in_cc = n->in(1);\n+      assert(in_cc->is_Con(), \"The condition input of cmove vector node must be a constant.\");\n+      Node* bol = new BoolNode(in_cc, (BoolTest::mask)in_cc->get_int());\n+      Node* pair1 = new BinaryNode(bol, in_cc);\n+      n->set_req(1, pair1);\n+      Node* pair2 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair2);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -400,4 +400,1 @@\n-    set_req(MemNode::Memory, mem);\n-    if (can_reshape && old_mem->outcnt() == 0 && igvn != NULL) {\n-      igvn->_worklist.push(old_mem);\n-    }\n+    set_req_X(MemNode::Memory, mem, phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,7 +76,2 @@\n-      set_req(1, in1->in(2));\n-      set_req(2, in2->in(2));\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (igvn) {\n-        igvn->_worklist.push(in1);\n-        igvn->_worklist.push(in2);\n-      }\n+      set_req_X(1, in1->in(2), phase);\n+      set_req_X(2, in2->in(2), phase);\n@@ -100,7 +95,2 @@\n-      set_req(1, in11);\n-      set_req(2, in12);\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (igvn) {\n-        igvn->_worklist.push(in1);\n-        igvn->_worklist.push(in2);\n-      }\n+      set_req_X(1, in11, phase);\n+      set_req_X(2, in12, phase);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -578,0 +578,1 @@\n+  Compile::current()->record_modified_node(n);\n@@ -790,0 +791,1 @@\n+  Compile::current()->record_modified_node(this);\n@@ -828,0 +830,1 @@\n+  Compile::current()->record_modified_node(this);\n@@ -874,0 +877,1 @@\n+  Compile::current()->record_modified_node(this);\n@@ -1051,0 +1055,1 @@\n+  Compile::current()->record_modified_node(this);\n@@ -1062,0 +1067,1 @@\n+  Compile::current()->record_modified_node(this);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -568,0 +568,1 @@\n+    Compile::current()->record_modified_node(this);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -536,0 +536,6 @@\n+  \/\/ Add \"in\" as input (req) of \"n\"\n+  void add_input_to(Node* n, Node* in) {\n+    rehash_node_delayed(n);\n+    n->add_req(in);\n+  }\n+\n@@ -542,0 +548,6 @@\n+  \/\/ Delete precedence edge i of \"n\"\n+  void delete_precedence_of(Node* n, int i) {\n+    rehash_node_delayed(n);\n+    n->rm_prec(i);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  flags(ALL,                          \"All\") \\\n@@ -173,0 +174,2 @@\n+      } else if (PHASE_ALL == cpt) {\n+        mask = ~(UINT64_C(0));\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-static jint CurrentVersion = JNI_VERSION_19;\n+static jint CurrentVersion = JNI_VERSION_20;\n@@ -591,2 +591,20 @@\n-    if (ex->is_a(vmClasses::ThreadDeath_klass())) {\n-      \/\/ Don't print anything if we are being killed.\n+    jio_fprintf(defaultStream::error_stream(), \"Exception \");\n+    if (thread != NULL && thread->threadObj() != NULL) {\n+      ResourceMark rm(THREAD);\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"in thread \\\"%s\\\" \", thread->name());\n+    }\n+    if (ex->is_a(vmClasses::Throwable_klass())) {\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_virtual(&result,\n+                              ex,\n+                              vmClasses::Throwable_klass(),\n+                              vmSymbols::printStackTrace_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      \/\/ If an exception is thrown in the call it gets thrown away. Not much\n+      \/\/ we can do with it. The native code that calls this, does not check\n+      \/\/ for the exception - hence, it might still be in the thread when DestroyVM gets\n+      \/\/ called, potentially causing a few asserts to trigger - since no pending exception\n+      \/\/ is expected.\n+      CLEAR_PENDING_EXCEPTION;\n@@ -594,26 +612,4 @@\n-      jio_fprintf(defaultStream::error_stream(), \"Exception \");\n-      if (thread != NULL && thread->threadObj() != NULL) {\n-        ResourceMark rm(THREAD);\n-        jio_fprintf(defaultStream::error_stream(),\n-        \"in thread \\\"%s\\\" \", thread->name());\n-      }\n-      if (ex->is_a(vmClasses::Throwable_klass())) {\n-        JavaValue result(T_VOID);\n-        JavaCalls::call_virtual(&result,\n-                                ex,\n-                                vmClasses::Throwable_klass(),\n-                                vmSymbols::printStackTrace_name(),\n-                                vmSymbols::void_method_signature(),\n-                                THREAD);\n-        \/\/ If an exception is thrown in the call it gets thrown away. Not much\n-        \/\/ we can do with it. The native code that calls this, does not check\n-        \/\/ for the exception - hence, it might still be in the thread when DestroyVM gets\n-        \/\/ called, potentially causing a few asserts to trigger - since no pending exception\n-        \/\/ is expected.\n-        CLEAR_PENDING_EXCEPTION;\n-      } else {\n-        ResourceMark rm(THREAD);\n-        jio_fprintf(defaultStream::error_stream(),\n-        \". Uncaught exception of type %s.\",\n-        ex->klass()->external_name());\n-      }\n+      ResourceMark rm(THREAD);\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \". Uncaught exception of type %s.\",\n+                  ex->klass()->external_name());\n@@ -3881,1 +3877,0 @@\n-  \/\/ Since this is not a JVM_ENTRY we have to set the thread state manually before entering.\n@@ -3884,0 +3879,8 @@\n+  \/\/ Make sure we are actually in a newly attached thread, with no\n+  \/\/ existing Java frame.\n+  if (thread->has_last_Java_frame()) {\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Since this is not a JVM_ENTRY we have to set the thread state manually before entering.\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2997,3 +2997,0 @@\n-      \/\/ We could also check the stillborn flag to see if this thread was already stopped, but\n-      \/\/ for historical reasons we let the thread detect that itself when it starts running\n-\n@@ -3052,39 +3049,0 @@\n-\/\/ JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints\n-\/\/ before the quasi-asynchronous exception is delivered.  This is a little obtrusive,\n-\/\/ but is thought to be reliable and simple. In the case, where the receiver is the\n-\/\/ same thread as the sender, no VM_Operation is needed.\n-JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))\n-  ThreadsListHandle tlh(thread);\n-  oop java_throwable = JNIHandles::resolve(throwable);\n-  if (java_throwable == NULL) {\n-    THROW(vmSymbols::java_lang_NullPointerException());\n-  }\n-  oop java_thread = NULL;\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, &java_thread);\n-  Events::log_exception(thread,\n-                        \"JVM_StopThread thread JavaThread \" INTPTR_FORMAT \" as oop \" INTPTR_FORMAT \" [exception \" INTPTR_FORMAT \"]\",\n-                        p2i(receiver), p2i(java_thread), p2i(throwable));\n-\n-  if (is_alive) {\n-    \/\/ jthread refers to a live JavaThread.\n-    if (thread == receiver) {\n-      \/\/ Exception is getting thrown at self so no VM_Operation needed.\n-      THROW_OOP(java_throwable);\n-    } else {\n-      \/\/ Use a VM_Operation to throw the exception.\n-      JavaThread::send_async_exception(receiver, java_throwable);\n-    }\n-  } else {\n-    \/\/ Either:\n-    \/\/ - target thread has not been started before being stopped, or\n-    \/\/ - target thread already terminated\n-    \/\/ We could read the threadStatus to determine which case it is\n-    \/\/ but that is overkill as it doesn't matter. We must set the\n-    \/\/ stillborn flag for the first case, and if the thread has already\n-    \/\/ exited setting this flag has no effect.\n-    java_lang_Thread::set_stillborn(java_thread);\n-  }\n-JVM_END\n-\n-\n@@ -3097,23 +3055,0 @@\n-JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))\n-  ThreadsListHandle tlh(thread);\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, NULL);\n-  if (is_alive) {\n-    \/\/ jthread refers to a live JavaThread, but java_suspend() will\n-    \/\/ detect a thread that has started to exit and will ignore it.\n-    receiver->java_suspend();\n-  }\n-JVM_END\n-\n-\n-JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))\n-  ThreadsListHandle tlh(thread);\n-  JavaThread* receiver = NULL;\n-  bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &receiver, NULL);\n-  if (is_alive) {\n-    \/\/ jthread refers to a live JavaThread.\n-    receiver->java_resume();\n-  }\n-JVM_END\n-\n-\n@@ -3164,1 +3099,1 @@\n-      \/\/ An asynchronous exception (e.g., ThreadDeathException) could have been thrown on\n+      \/\/ An asynchronous exception could have been thrown on\n@@ -4022,0 +3957,2 @@\n+  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n+  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n@@ -4046,0 +3983,1 @@\n+  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -4094,1 +4032,1 @@\n-\n+  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -4117,0 +4055,1 @@\n+  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -4123,0 +4062,14 @@\n+JVM_ENTRY(void, JVM_VirtualThreadHideFrames(JNIEnv* env, jobject vthread, jboolean hide))\n+#if INCLUDE_JVMTI\n+  if (!DoJVMTIVirtualThreadTransitions) {\n+    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n+    return;\n+  }\n+  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n+  assert(thread->is_in_tmp_VTMS_transition() != (bool)hide, \"sanity check\");\n+  thread->toggle_is_in_tmp_VTMS_transition();\n+#else\n+  fatal(\"Should only be called with JVMTI enabled\");\n+#endif\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":20,"deletions":67,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -896,1 +896,1 @@\n-    assert(!_thread->is_in_VTMS_transition(), \"CFLH events are not allowed in VTMS transition\");\n+    assert(!_thread->is_in_any_VTMS_transition(), \"CFLH events are not allowed in any VTMS transition\");\n@@ -1053,0 +1053,3 @@\n+  if (JavaThread::current()->is_in_tmp_VTMS_transition()) {\n+    return false; \/\/ skip CFLH events in tmp VTMS transition\n+  }\n@@ -1187,2 +1190,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1343,1 +1346,4 @@\n-  assert(!thread->is_in_VTMS_transition(), \"class load events are not allowed in VTMS transition\");\n+  if (thread->is_in_tmp_VTMS_transition()) {\n+    return; \/\/ skip ClassLoad events in tmp VTMS transition\n+  }\n+  assert(!thread->is_in_any_VTMS_transition(), \"class load events are not allowed in any VTMS transition\");\n@@ -1378,1 +1384,4 @@\n-  assert(!thread->is_in_VTMS_transition(), \"class prepare events are not allowed in VTMS transition\");\n+  if (thread->is_in_tmp_VTMS_transition()) {\n+    return; \/\/ skip ClassPrepare events in tmp VTMS transition\n+  }\n+  assert(!thread->is_in_any_VTMS_transition(), \"class prepare events are not allowed in any VTMS transition\");\n@@ -1697,2 +1706,2 @@\n-  if (javaThread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (javaThread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1721,2 +1730,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1764,2 +1773,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1848,2 +1857,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1924,2 +1933,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1961,2 +1970,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2083,2 +2092,2 @@\n-      if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n-        return; \/\/ no events should be posted if thread is in a VTMS transition\n+      if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n+        return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2129,2 +2138,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2165,2 +2174,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2215,2 +2224,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2246,2 +2255,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2321,2 +2330,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2360,2 +2369,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2434,1 +2443,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"compiled method load events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"compiled method load events are not allowed in any VTMS transition\");\n@@ -2457,1 +2466,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"compiled method load events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"compiled method load events are not allowed in any VTMS transition\");\n@@ -2482,1 +2491,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n@@ -2530,1 +2539,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n@@ -2554,1 +2563,1 @@\n-  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n+  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n@@ -2684,2 +2693,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2717,2 +2726,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2751,2 +2760,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2785,2 +2794,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2817,2 +2826,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -2851,2 +2860,2 @@\n-  if (thread->is_in_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in a VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":57,"deletions":48,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -425,0 +425,1 @@\n+  _is_in_tmp_VTMS_transition(false),\n@@ -691,5 +692,3 @@\n-  \/\/ Execute thread entry point unless this thread has a pending exception\n-  \/\/ or has been stopped before starting.\n-  \/\/ Note: Due to JVM_StopThread we can have pending exceptions already!\n-  if (!this->has_pending_exception() &&\n-      !java_lang_Thread::is_stillborn(this->threadObj())) {\n+  \/\/ Execute thread entry point unless this thread has a pending exception.\n+  \/\/ Note: Due to JVMTI StopThread we can have pending exceptions already!\n+  if (!this->has_pending_exception()) {\n@@ -723,2 +722,0 @@\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n-  thread->clear_pending_exception();\n@@ -731,1 +728,1 @@\n-  \/\/ Ignore pending exception (ThreadDeath), since we are exiting anyway\n+  \/\/ Ignore pending exception, since we are exiting anyway\n@@ -1071,22 +1068,17 @@\n-  \/\/ Only overwrite an already pending exception if it is not a ThreadDeath.\n-  if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n-\n-    \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n-    set_pending_exception(java_throwable, __FILE__, __LINE__);\n-\n-    \/\/ Clear any extent-local bindings on ThreadDeath\n-    set_extentLocalCache(NULL);\n-    oop threadOop = threadObj();\n-    assert(threadOop != NULL, \"must be\");\n-    java_lang_Thread::clear_extentLocalBindings(threadOop);\n-\n-    LogTarget(Info, exceptions) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n-      if (has_last_Java_frame()) {\n-        frame f = last_frame();\n-        ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n-      }\n-      ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n+  \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n+  set_pending_exception(java_throwable, __FILE__, __LINE__);\n+\n+  \/\/ Clear any extent-local bindings\n+  set_extentLocalCache(NULL);\n+  oop threadOop = threadObj();\n+  assert(threadOop != NULL, \"must be\");\n+  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+\n+  LogTarget(Info, exceptions) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n+    if (has_last_Java_frame()) {\n+      frame f = last_frame();\n+      ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n@@ -1094,0 +1086,1 @@\n+    ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n@@ -1105,10 +1098,0 @@\n-  \/\/ Don't install a new pending async exception if there is already\n-  \/\/ a pending ThreadDeath one. Just interrupt thread from potential\n-  \/\/ wait()\/sleep()\/park() and return.\n-  if (has_async_exception_condition(true \/* ThreadDeath_only *\/)) {\n-    java_lang_Thread::set_interrupted(threadObj(), true);\n-    this->interrupt();\n-    delete aeh;\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":23,"deletions":40,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  bool has_async_exception_condition(bool ThreadDeath_only = false);\n+  bool has_async_exception_condition();\n@@ -314,0 +314,1 @@\n+  bool                  _is_in_tmp_VTMS_transition;      \/\/ thread is in temporary virtual thread mount state transition\n@@ -647,0 +648,3 @@\n+  bool is_in_tmp_VTMS_transition() const         { return _is_in_tmp_VTMS_transition; }\n+  bool is_in_any_VTMS_transition() const         { return _is_in_VTMS_transition || _is_in_tmp_VTMS_transition; }\n+\n@@ -648,0 +652,2 @@\n+  void toggle_is_in_tmp_VTMS_transition()        { _is_in_tmp_VTMS_transition = !_is_in_tmp_VTMS_transition; };\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError and j.l.ThreadDeath.\n+\/\/ CAUTION: These macros clears all exceptions except probable async exceptions j.l.InternalError.\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+        ptypes.add(null); \/\/placeholder for return type\n@@ -159,1 +160,1 @@\n-        ptypes.add(0, descriptor.substring(cur, cur + rLen));\n+        ptypes.set(0, descriptor.substring(cur, cur + rLen));\n@@ -208,8 +209,20 @@\n-                    \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n-                    index++;\n-                    int indexOfSemi = descriptor.indexOf(';', index);\n-                    if (indexOfSemi != -1) {\n-                        String unqualifiedName = descriptor.substring(index, indexOfSemi);\n-                        boolean legal = verifyUnqualifiedClassName(unqualifiedName);\n-                        if (!legal) {\n-                            return 0;\n+                    \/\/ state variable for detection of illegal states, such as:\n+                    \/\/ empty unqualified name, '\/\/', leading '\/', or trailing '\/'\n+                    boolean legal = false;\n+                    while (++index < end) {\n+                        switch (descriptor.charAt(index)) {\n+                            case ';' -> {\n+                                \/\/ illegal state on parser exit indicates empty unqualified name or trailing '\/'\n+                                return legal ? index - start + 1 : 0;\n+                            }\n+                            case '.', '[' -> {\n+                                \/\/ do not permit '.' or '['\n+                                return 0;\n+                            }\n+                            case '\/' -> {\n+                                \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n+                                if (!legal) return 0;\n+                                legal = false;\n+                            }\n+                            default ->\n+                                legal = true;\n@@ -217,1 +230,0 @@\n-                        return index - start + unqualifiedName.length() + 1;\n@@ -237,0 +249,21 @@\n+    static boolean verifyUnqualifiedClassName(String name) {\n+        for (int index = 0; index < name.length(); index++) {\n+            char ch = name.charAt(index);\n+            if (ch < 128) {\n+                if (ch == '.' || ch == ';' || ch == '[' ) {\n+                    return false;   \/\/ do not permit '.', ';', or '['\n+                }\n+                if (ch == '\/') {\n+                    \/\/ check for '\/\/' or leading or trailing '\/' which are not legal\n+                    \/\/ unqualified name must not be empty\n+                    if (index == 0 || index + 1 >= name.length() || name.charAt(index + 1) == '\/') {\n+                        return false;\n+                    }\n+                }\n+            } else {\n+                index ++;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -293,20 +326,0 @@\n-    static boolean verifyUnqualifiedClassName(String name) {\n-        for (int index = 0; index < name.length(); index++) {\n-            char ch = name.charAt(index);\n-            if (ch < 128) {\n-                if (ch == '.' || ch == ';' || ch == '[' ) {\n-                    return false;   \/\/ do not permit '.', ';', or '['\n-                }\n-                if (ch == '\/') {\n-                    \/\/ check for '\/\/' or leading or trailing '\/' which are not legal\n-                    \/\/ unqualified name must not be empty\n-                    if (index == 0 || index + 1 >= name.length() || name.charAt(index + 1) == '\/') {\n-                        return false;\n-                    }\n-                }\n-            } else {\n-                index ++;\n-            }\n-        }\n-        return true;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":43,"deletions":30,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1780,1 +1780,1 @@\n-                            Env<AttrContext> bodyEnv = bindingEnv(env, matchBindings.bindingsWhenTrue);\n+                            Env<AttrContext> bodyEnv = bindingEnv(switchEnv, matchBindings.bindingsWhenTrue);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3334,0 +3334,6 @@\n+compiler.err.dc.no.url=\\\n+    no URL\n+\n+compiler.err.dc.no.title=\\\n+    no title\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+runtime\/handshake\/HandshakeSuspendExitTest.java 8294313 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}