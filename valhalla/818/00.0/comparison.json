{"files":[{"patch":"@@ -623,1 +623,1 @@\n-SPECS_TOP := $(if $(filter true, $(IS_DRAFT)), <header class=\"draft-header\">$(DRAFT_TEXT)<\/header>)\n+SPECS_TOP := $(if $(filter true, $(IS_DRAFT)), <header class=\"draft-header\" role=\"banner\">$(DRAFT_TEXT)<\/header>)\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -947,1 +947,1 @@\n-                testedProfileTest, testedProfile + \".jdk_symbols\",\n+                testedProfileTest,\n@@ -961,0 +961,3 @@\n+    if (!testedProfile.endsWith(\"-jcov\")) {\n+        testOnlyProfilesPrebuilt[\"run-test-prebuilt\"][\"dependencies\"].push(testedProfile + \".jdk_symbols\");\n+    }\n@@ -990,1 +993,1 @@\n-                input.get(\"lldb\", \"install_path\") + \"\/Xcode.app\/Contents\/Developer\/usr\/bin\",\n+                input.get(\"lldb\", \"install_path\") + \"\/Xcode\/Contents\/Developer\/usr\/bin\",\n@@ -1035,1 +1038,1 @@\n-        macosx: \"Xcode12.4+1.0\",\n+        macosx: \"Xcode12.4+1.1\",\n@@ -1126,1 +1129,1 @@\n-            revision: (input.build_cpu == \"x64\" ? \"Xcode11.3.1-MacOSX10.15+1.1\" : devkit_platform_revisions[devkit_platform])\n+            revision: (input.build_cpu == \"x64\" ? \"Xcode11.3.1-MacOSX10.15+1.2\" : devkit_platform_revisions[devkit_platform])\n@@ -1154,1 +1157,1 @@\n-            revision: \"3.0-13-jdk-asm+1.0\",\n+            revision: \"3.0-14-jdk-asm+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -878,1 +878,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c\n@@ -1520,0 +1520,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativeStack += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1745,1 +1745,1 @@\n-    st->print(\"ldr  rscratch2, [rthread, #thread_disarmed_offset]\\n\\t\");\n+    st->print(\"ldr  rscratch2, [rthread, #thread_disarmed_guard_value_offset]\\n\\t\");\n@@ -1843,1 +1843,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n@@ -7598,1 +7600,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -7612,1 +7614,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -8013,0 +8015,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -8025,0 +8028,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -9709,0 +9713,84 @@\n+\/\/ Manifest a CmpU result in an integer register.\n+\/\/ (src1 < src2) ? -1 : ((src1 > src2) ? 1 : 0)\n+instruct cmpU3_reg_reg(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"cmpw $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpU3(reg)\"\n+  %}\n+  ins_encode %{\n+    __ cmpw($src1$$Register, $src2$$Register);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpU3_reg_imm(iRegINoSp dst, iRegI src1, immIAddSub src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"subsw zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpU3(imm)\"\n+  %}\n+  ins_encode %{\n+    __ subsw(zr, $src1$$Register, (int32_t)$src2$$constant);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Manifest a CmpUL result in an integer register.\n+\/\/ (src1 < src2) ? -1 : ((src1 > src2) ? 1 : 0)\n+instruct cmpUL3_reg_reg(iRegINoSp dst, iRegL src1, iRegL src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"cmp $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpUL3(reg)\"\n+  %}\n+  ins_encode %{\n+    __ cmp($src1$$Register, $src2$$Register);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpUL3_reg_imm(iRegINoSp dst, iRegL src1, immLAddSub src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"subs zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpUL3(imm)\"\n+  %}\n+  ins_encode %{\n+    __ subs(zr, $src1$$Register, (int32_t)$src2$$constant);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -9716,1 +9804,1 @@\n-  ins_cost(INSN_COST * 6);\n+  ins_cost(INSN_COST * 3);\n@@ -9718,3 +9806,3 @@\n-      \"cmp $src1, $src2\"\n-      \"csetw $dst, ne\"\n-      \"cnegw $dst, lt\"\n+      \"cmp $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lt\\t# CmpL3(reg)\"\n@@ -9722,1 +9810,0 @@\n-  \/\/ format %{ \"CmpL3 $dst, $src1, $src2\" %}\n@@ -9737,1 +9824,1 @@\n-  ins_cost(INSN_COST * 6);\n+  ins_cost(INSN_COST * 3);\n@@ -9739,3 +9826,3 @@\n-      \"cmp $src1, $src2\"\n-      \"csetw $dst, ne\"\n-      \"cnegw $dst, lt\"\n+      \"subs zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lt\\t# CmpL3(imm)\"\n@@ -9744,6 +9831,1 @@\n-    int32_t con = (int32_t)$src2$$constant;\n-     if (con < 0) {\n-      __ adds(zr, $src1$$Register, -con);\n-    } else {\n-      __ subs(zr, $src1$$Register, con);\n-    }\n+    __ subs(zr, $src1$$Register, (int32_t)$src2$$constant);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":102,"deletions":20,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,1 +216,1 @@\n-  zero_words(t1, t2);\n+  address tpc = zero_words(t1, t2);\n@@ -219,0 +219,3 @@\n+  if (tpc == nullptr) {\n+    Compilation::current()->bailout(\"no space for trampoline stub\");\n+  }\n@@ -245,0 +248,3 @@\n+       if (Compilation::current()->bailed_out()) {\n+         return;\n+       }\n@@ -248,1 +254,5 @@\n-       zero_words(t1, con_size_in_bytes \/ BytesPerWord);\n+       address tpc = zero_words(t1, con_size_in_bytes \/ BytesPerWord);\n+       if (tpc == nullptr) {\n+         Compilation::current()->bailout(\"no space for trampoline stub\");\n+         return;\n+       }\n@@ -285,0 +295,3 @@\n+  if (Compilation::current()->bailed_out()) {\n+    return;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,3 @@\n-      C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-      slow_path = &stub->slow_path();\n+      C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+      Compile::current()->output()->add_stub(stub);\n+      slow_path = &stub->entry();\n@@ -70,11 +71,0 @@\n-void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n-  bind(stub->slow_path());\n-  movptr(rscratch1, (uintptr_t) StubRoutines::aarch64::method_entry_barrier());\n-  blr(rscratch1);\n-  b(stub->continuation());\n-\n-  bind(stub->guard());\n-  relocate(entry_guard_Relocation::spec());\n-  emit_int32(0);   \/\/ nmethod guard value\n-}\n-\n@@ -338,1 +328,6 @@\n-    trampoline_call(stub);\n+    address call = trampoline_call(stub);\n+    if (call == nullptr) {\n+      DEBUG_ONLY(reset_labels(LINEARSEARCH, LINEAR_MEDIUM, DONE, NOMATCH, MATCH));\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n@@ -897,1 +892,6 @@\n-    trampoline_call(stub);\n+    address call = trampoline_call(stub);\n+    if (call == nullptr) {\n+      DEBUG_ONLY(reset_labels(DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT, SHORT_LOOP_START));\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-    ::new (reg_map) RegisterMap((JavaThread*)thread,\n+    ::new (reg_map) RegisterMap(reinterpret_cast<JavaThread*>(thread),\n@@ -746,1 +746,1 @@\n-    *reg_map = RegisterMap((JavaThread*)thread,\n+    *reg_map = RegisterMap(reinterpret_cast<JavaThread*>(thread),\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-    Address thread_disarmed_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+    Address thread_disarmed_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n@@ -271,1 +271,1 @@\n-    Address thread_disarmed_and_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+    Address thread_disarmed_and_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n@@ -279,1 +279,1 @@\n-    Address thread_disarmed_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+    Address thread_disarmed_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -196,20 +196,1 @@\n-  \/\/ The patching epoch is incremented before the nmethod is disarmed. Disarming\n-  \/\/ is performed with a release store. In the nmethod entry barrier, the values\n-  \/\/ are read in the opposite order, such that the load of the nmethod guard\n-  \/\/ acquires the patching epoch. This way, the guard is guaranteed to block\n-  \/\/ entries to the nmethod, until it has safely published the requirement for\n-  \/\/ further fencing by mutators, before they are allowed to enter.\n-  BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs_asm->increment_patching_epoch();\n-\n-  \/\/ Disarms the nmethod guard emitted by BarrierSetAssembler::nmethod_entry_barrier.\n-  \/\/ Symmetric \"LDR; DMB ISHLD\" is in the nmethod barrier.\n-  set_value(nm, disarmed_value());\n-}\n-\n-void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n-  if (!supports_entry_barrier(nm)) {\n-    return;\n-  }\n-\n-  if (arm_value == disarmed_value()) {\n+  if (value == disarmed_guard_value()) {\n@@ -226,1 +207,1 @@\n-  set_value(nm, arm_value);\n+  set_value(nm, value);\n@@ -229,1 +210,1 @@\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -231,1 +212,1 @@\n-    return false;\n+    return disarmed_guard_value();\n@@ -235,1 +216,1 @@\n-  return barrier->get_value(nm) != disarmed_value();\n+  return barrier->get_value(nm);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1148,3 +1148,0 @@\n-private:\n-  void compare_eq(Register rn, Register rm, enum operand_size size);\n-\n@@ -1165,0 +1162,3 @@\n+private:\n+  void compare_eq(Register rn, Register rm, enum operand_size size);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1396,0 +1396,3 @@\n+    if (tr_call == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n@@ -1403,1 +1406,4 @@\n-    CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+    address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+    if (stub == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n@@ -1420,0 +1426,3 @@\n+  if (tr_call == nullptr) {\n+    fatal(\"CodeCache is full at gen_continuation_enter\");\n+  }\n@@ -1461,1 +1470,4 @@\n-  CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+  if (stub == nullptr) {\n+    fatal(\"CodeCache is full at gen_continuation_enter\");\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2390,1 +2390,4 @@\n-      __ zero_words(bz_base, cnt_words);\n+      address tpc = __ zero_words(bz_base, cnt_words);\n+      if (tpc == nullptr) {\n+        fatal(\"CodeCache is full at generate_fill\");\n+      }\n@@ -3275,1 +3278,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);\n+    __ addw(rscratch4, rscratch4, rscratch1);\n@@ -3286,1 +3289,2 @@\n-    __ eorw(rscratch2, r2, r3);\n+    __ andw(rscratch3, r2, r4);\n+    __ bicw(rscratch4, r3, r4);\n@@ -3288,2 +3292,1 @@\n-    __ andw(rscratch3, rscratch2, r4);\n-    __ eorw(rscratch3, rscratch3, r3);\n+    __ orrw(rscratch3, rscratch3, rscratch4);\n@@ -3292,1 +3295,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);\n+    __ addw(rscratch4, rscratch4, rscratch1);\n@@ -3308,1 +3311,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);\n+    __ addw(rscratch4, rscratch4, rscratch1);\n@@ -3324,1 +3327,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);\n+    __ addw(rscratch4, rscratch4, rscratch1);\n@@ -5360,1 +5363,1 @@\n-      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()) + 4);\n+      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -846,2 +846,4 @@\n-    } else {\n-    __ mov(rscratch1, sp);\n+  } else {\n+    \/\/ Make sure there is room for the exception oop pushed in case method throws\n+    \/\/ an exception (see TemplateInterpreterGenerator::generate_throw_exception())\n+    __ sub(rscratch1, sp, 2 * wordSize);\n@@ -849,0 +851,1 @@\n+    __ mov(sp, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-define_pd_global(bool,  VMContinuations, true);\n+define_pd_global(bool,  VMContinuations, AIX_ONLY(false) NOT_AIX(true));\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-define_pd_global(bool, TwoOperandLIRForm,              true );\n","filename":"src\/hotspot\/cpu\/x86\/c1_globals_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -167,3 +167,3 @@\n-      C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-      slow_path = &stub->slow_path();\n-      continuation = &stub->continuation();\n+      C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+      Compile::current()->output()->add_stub(stub);\n+      slow_path = &stub->entry();                                                                                                                                                                                                                                                                                                                                                              continuation = &stub->continuation();\n@@ -179,10 +179,0 @@\n-void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n-  bind(stub->slow_path());\n-  call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));\n-  jmp(stub->continuation(), false \/* maybe_short *\/);\n-}\n-\n-int C2_MacroAssembler::entry_barrier_stub_size() {\n-  return 10;\n-}\n-\n@@ -2447,52 +2437,26 @@\n-void C2_MacroAssembler::vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n-                                   XMMRegister vtmp1, XMMRegister vtmp2, KRegister mask) {\n-  switch(vlen) {\n-    case 4:\n-      assert(vtmp1 != xnoreg, \"required.\");\n-      \/\/ Broadcast lower 32 bits to 128 bits before ptest\n-      pshufd(vtmp1, src1, 0x0);\n-      if (bt == BoolTest::overflow) {\n-        assert(vtmp2 != xnoreg, \"required.\");\n-        pshufd(vtmp2, src2, 0x0);\n-      } else {\n-        assert(vtmp2 == xnoreg, \"required.\");\n-        vtmp2 = src2;\n-      }\n-      ptest(vtmp1, vtmp2);\n-     break;\n-    case 8:\n-      assert(vtmp1 != xnoreg, \"required.\");\n-      \/\/ Broadcast lower 64 bits to 128 bits before ptest\n-      pshufd(vtmp1, src1, 0x4);\n-      if (bt == BoolTest::overflow) {\n-        assert(vtmp2 != xnoreg, \"required.\");\n-        pshufd(vtmp2, src2, 0x4);\n-      } else {\n-        assert(vtmp2 == xnoreg, \"required.\");\n-        vtmp2 = src2;\n-      }\n-      ptest(vtmp1, vtmp2);\n-     break;\n-    case 16:\n-      assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-      ptest(src1, src2);\n-      break;\n-    case 32:\n-      assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-      vptest(src1, src2, Assembler::AVX_256bit);\n-      break;\n-    case 64:\n-      {\n-        assert((vtmp1 == xnoreg) && (vtmp2 == xnoreg), \"required.\");\n-        evpcmpeqb(mask, src1, src2, Assembler::AVX_512bit);\n-        if (bt == BoolTest::ne) {\n-          ktestql(mask, mask);\n-        } else {\n-          assert(bt == BoolTest::overflow, \"required\");\n-          kortestql(mask, mask);\n-        }\n-      }\n-      break;\n-    default:\n-      assert(false,\"Should not reach here.\");\n-      break;\n+void C2_MacroAssembler::vectortest(BasicType bt, XMMRegister src1, XMMRegister src2, XMMRegister vtmp, int vlen_in_bytes) {\n+  assert(vlen_in_bytes <= 32, \"\");\n+  int esize = type2aelembytes(bt);\n+  if (vlen_in_bytes == 32) {\n+    assert(vtmp == xnoreg, \"required.\");\n+    if (esize >= 4) {\n+      vtestps(src1, src2, AVX_256bit);\n+    } else {\n+      vptest(src1, src2, AVX_256bit);\n+    }\n+    return;\n+  }\n+  if (vlen_in_bytes < 16) {\n+    \/\/ Duplicate the lower part to fill the whole register,\n+    \/\/ Don't need to do so for src2\n+    assert(vtmp != xnoreg, \"required\");\n+    int shuffle_imm = (vlen_in_bytes == 4) ? 0x00 : 0x04;\n+    pshufd(vtmp, src1, shuffle_imm);\n+  } else {\n+    assert(vtmp == xnoreg, \"required\");\n+    vtmp = src1;\n+  }\n+  if (esize >= 4 && VM_Version::supports_avx()) {\n+    vtestps(vtmp, src2, AVX_128bit);\n+  } else {\n+    ptest(vtmp, src2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":29,"deletions":65,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -142,2 +142,1 @@\n-  void vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n-                  XMMRegister vtmp1 = xnoreg, XMMRegister vtmp2 = xnoreg, KRegister mask = knoreg);\n+  void vectortest(BasicType bt, XMMRegister src1, XMMRegister src2, XMMRegister vtmp, int vlen_in_bytes);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-  Address disarmed_addr(thread, in_bytes(bs_nm->thread_disarmed_offset()));\n+  Address disarmed_addr(thread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()));\n@@ -330,1 +330,1 @@\n-  __ movptr(tmp, (intptr_t)bs_nm->disarmed_value_address());\n+  __ movptr(tmp, (intptr_t)bs_nm->disarmed_guard_value_address());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  jint get_immedate() const { return int_at(imm_offset); }\n+  jint get_immediate() const { return int_at(imm_offset); }\n@@ -204,1 +204,1 @@\n-void BarrierSetNMethod::disarm(nmethod* nm) {\n+void BarrierSetNMethod::set_guard_value(nmethod* nm, int value) {\n@@ -209,1 +209,1 @@\n-  set_immediate(nm, disarmed_value());\n+  set_immediate(nm, value);\n@@ -212,1 +212,1 @@\n-void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n+int BarrierSetNMethod::guard_value(nmethod* nm) {\n@@ -214,9 +214,1 @@\n-    return;\n-  }\n-\n-  set_immediate(nm, arm_value);\n-}\n-\n-bool BarrierSetNMethod::is_armed(nmethod* nm) {\n-  if (!supports_entry_barrier(nm)) {\n-    return false;\n+    return disarmed_guard_value();\n@@ -226,1 +218,1 @@\n-  return (disarmed_value() != cmp->get_immedate());\n+  return cmp->get_immediate();\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -9004,5 +9004,7 @@\n-  BIND(L_wordByWord);\n-  jcc(Assembler::greaterEqual, L_byteByByteProlog);\n-    crc32(in_out, Address(in1, 0), 4);\n-    addq(in1, 4);\n-    jmp(L_wordByWord);\n+  jccb(Assembler::greaterEqual, L_byteByByteProlog);\n+  align(16);\n+  BIND(L_wordByWord);\n+    crc32(in_out, Address(in1, 0), 8);\n+    addq(in1, 8);\n+    cmpq(in1, tmp1);\n+    jcc(Assembler::less, L_wordByWord);\n@@ -9015,1 +9017,0 @@\n-  BIND(L_byteByByte);\n@@ -9018,0 +9019,1 @@\n+  BIND(L_byteByByte);\n@@ -9021,1 +9023,2 @@\n-    jmp(L_byteByByte);\n+    cmpl(tmp2, in2);\n+    jcc(Assembler::lessEqual, L_byteByByte);\n@@ -9789,20 +9792,0 @@\n-void MacroAssembler::anytrue(Register dst, uint masklen, KRegister src1, KRegister src2) {\n-   masklen = masklen < 8 ? 8 : masklen;\n-   ktest(masklen, src1, src2);\n-   setb(Assembler::notZero, dst);\n-   movzbl(dst, dst);\n-}\n-\n-void MacroAssembler::alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch) {\n-  if (masklen < 8) {\n-    knotbl(kscratch, src2);\n-    kortestbl(src1, kscratch);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  } else {\n-    ktest(masklen, src1, src2);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1831,3 +1831,0 @@\n-  void alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch);\n-  void anytrue(Register dst, uint masklen, KRegister src, KRegister kscratch);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3740,1 +3740,1 @@\n-  if (UsePolyIntrinsics) {\n+  if (UsePoly1305Intrinsics) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1354,2 +1354,2 @@\n-    if (FLAG_IS_DEFAULT(UsePolyIntrinsics)) {\n-      FLAG_SET_DEFAULT(UsePolyIntrinsics, true);\n+    if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n+      FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n@@ -1359,1 +1359,1 @@\n-  if (UsePolyIntrinsics) {\n+  if (UsePoly1305Intrinsics) {\n@@ -1361,1 +1361,1 @@\n-    FLAG_SET_DEFAULT(UsePolyIntrinsics, false);\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, false);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1853,2 +1853,0 @@\n-      } else if (size_in_bits == 512 && (VM_Version::supports_avx512bw() == false)) {\n-        return false; \/\/ Implementation limitation\n@@ -8087,8 +8085,5 @@\n-instruct vptest_alltrue_lt16(rRegI dst, legVec src1, legVec src2, legVec vtmp1, legVec vtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP vtmp1, TEMP vtmp2, KILL cr);\n-  format %{ \"vptest_alltrue_lt16 $dst,$src1, $src2\\t! using $vtmp1, $vtmp2 and $cr as TEMP\" %}\n+instruct vptest_lt16(rFlagsRegU cr, legVec src1, legVec src2, legVec vtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) < 16);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP vtmp);\n+  format %{ \"vptest_lt16  $src1, $src2\\t! using $vtmp as TEMP\" %}\n@@ -8096,0 +8091,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -8097,3 +8093,1 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);\n-    __ setb(Assembler::carrySet, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ vectortest(bt, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister, vlen);\n@@ -8104,8 +8098,4 @@\n-instruct vptest_alltrue_ge16(rRegI dst, legVec src1, legVec src2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) <  64 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(KILL cr);\n-  format %{ \"vptest_alltrue_ge16  $dst,$src1, $src2\\t! using $cr as TEMP\" %}\n+instruct vptest_ge16(rFlagsRegU cr, legVec src1, legVec src2) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) >= 16);\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"vptest_ge16  $src1, $src2\\n\\t\" %}\n@@ -8113,0 +8103,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src1);\n@@ -8114,21 +8105,1 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n-    __ setb(Assembler::carrySet, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vptest_alltrue_lt8_evex(rRegI dst, kReg src1, kReg src2, kReg kscratch, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow &&\n-            n->in(1)->bottom_type()->isa_vectmask() &&\n-            Matcher::vector_length(n->in(1)) < 8);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr, TEMP kscratch);\n-  format %{ \"vptest_alltrue_lt8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint masklen = Matcher::vector_length(this, $src1);\n-    __ alltrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister, $kscratch$$KRegister);\n+    __ vectortest(bt, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, vlen);\n@@ -8139,9 +8110,7 @@\n-\n-instruct vptest_alltrue_ge8_evex(rRegI dst, kReg src1, kReg src2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow &&\n-            n->in(1)->bottom_type()->isa_vectmask() &&\n-            Matcher::vector_length(n->in(1)) >= 8);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vptest_alltrue_ge8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n+instruct ktest_alltrue_le8(rFlagsRegU cr, kReg src1, kReg src2, rRegI tmp) %{\n+  predicate((Matcher::vector_length(n->in(1)) < 8 ||\n+             (Matcher::vector_length(n->in(1)) == 8 && !VM_Version::supports_avx512dq())) &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"ktest_alltrue_le8  $src1, $src2\\t! using $tmp as TEMP\" %}\n@@ -8149,22 +8118,3 @@\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    __ alltrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vptest_anytrue_lt16(rRegI dst, legVec src1, legVec src2, legVec vtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(TEMP vtmp, KILL cr);\n-  format %{ \"vptest_anytrue_lt16 $dst,$src1,$src2\\t! using $vtmp, $cr as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ kmovwl($tmp$$Register, $src1$$KRegister);\n+    __ andl($tmp$$Register, (1 << masklen) - 1);\n+    __ cmpl($tmp$$Register, (1 << masklen) - 1);\n@@ -8176,4 +8126,3 @@\n-instruct vptest_anytrue_ge16(rRegI dst, legVec src1, legVec src2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)) < 64  &&\n+instruct ktest_anytrue_le8(rFlagsRegU cr, kReg src1, kReg src2, rRegI tmp) %{\n+  predicate((Matcher::vector_length(n->in(1)) < 8 ||\n+             (Matcher::vector_length(n->in(1)) == 8 && !VM_Version::supports_avx512dq())) &&\n@@ -8181,50 +8130,3 @@\n-  match(Set dst (VectorTest src1 src2 ));\n-  effect(KILL cr);\n-  format %{ \"vptest_anytrue_ge16 $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vptest_anytrue_evex(rRegI dst, kReg src1, kReg src2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n-  match(Set dst (VectorTest src1 src2));\n-  effect(KILL cr);\n-  format %{ \"vptest_anytrue_lt8_evex $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n-  ins_encode %{\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    uint  masklen = Matcher::vector_length(this, $src1);\n-    __ anytrue($dst$$Register, masklen, $src1$$KRegister, $src2$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct cmpvptest_anytrue_lt16(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero, legVec vtmp) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 4 &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) < 16 &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  effect(TEMP vtmp);\n-  format %{ \"cmpvptest_anytrue_lt16 $src1,$src2\\t! using $vtmp as TEMP\" %}\n-  ins_encode %{\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, $vtmp$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct cmpvptest_anytrue_ge16(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero) %{\n-  predicate(!VM_Version::supports_avx512bwdq() &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) >= 16 &&\n-            Matcher::vector_length_in_bytes(n->in(1)->in(1)) <  64 &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  format %{ \"cmpvptest_anytrue_ge16 $src1,$src2\\t!\" %}\n+  match(Set cr (VectorTest src1 src2));\n+  effect(TEMP tmp);\n+  format %{ \"ktest_anytrue_le8  $src1, $src2\\t! using $tmp as TEMP\" %}\n@@ -8232,2 +8134,3 @@\n-    int vlen = Matcher::vector_length_in_bytes(this, $src1);\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n+    uint masklen = Matcher::vector_length(this, $src1);\n+    __ kmovwl($tmp$$Register, $src1$$KRegister);\n+    __ andl($tmp$$Register, (1 << masklen) - 1);\n@@ -8238,5 +8141,5 @@\n-instruct cmpvptest_anytrue_evex(rFlagsReg cr, kReg src1, kReg src2, immI_0 zero) %{\n-  predicate(VM_Version::supports_avx512bwdq() &&\n-            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n-  match(Set cr (CmpI (VectorTest src1 src2) zero));\n-  format %{ \"cmpvptest_anytrue_evex $src1,$src2\\t!\" %}\n+instruct ktest_ge8(rFlagsRegU cr, kReg src1, kReg src2) %{\n+  predicate(Matcher::vector_length(n->in(1)) >= 16 ||\n+            (Matcher::vector_length(n->in(1)) == 8 && VM_Version::supports_avx512dq()));\n+  match(Set cr (VectorTest src1 src2));\n+  format %{ \"ktest_ge8  $src1, $src2\\n\\t\" %}\n@@ -8245,5 +8148,1 @@\n-    const MachNode* mask1 = static_cast<const MachNode*>(this->in(this->operand_index($src1)));\n-    const MachNode* mask2 = static_cast<const MachNode*>(this->in(this->operand_index($src2)));\n-    assert(0 == Type::cmp(mask1->bottom_type(), mask2->bottom_type()), \"\");\n-    masklen = masklen < 8 ? 8 : masklen;\n-    __ ktest(masklen, $src1$$KRegister, $src2$$KRegister);\n+    __ kortest(masklen, $src1$$KRegister, $src1$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":38,"deletions":139,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -708,1 +708,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -897,1 +897,1 @@\n-    st->print(\"cmpl    [r15_thread + #disarmed_offset], #disarmed_value\\t\");\n+    st->print(\"cmpl    [r15_thread + #disarmed_guard_value_offset], #disarmed_guard_value\\t\");\n@@ -992,1 +992,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n@@ -6102,0 +6104,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -6114,1 +6117,1 @@\n-  predicate(UseCompressedOops && (CompressedOops::base() == NULL));\n+  predicate(UseCompressedOops && (CompressedOops::base() == NULL) && n->as_Store()->barrier_data() == 0);\n@@ -6128,0 +6131,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#define remaining_buflen(buffer, position) (sizeof(buffer) - ((position) - (buffer)))\n+\n@@ -1537,1 +1539,1 @@\n-      sprintf(s,\"\/*%s*\/(\",(char*)i._key);\n+      snprintf_checked(s, remaining_buflen(buf, s), \"\/*%s*\/(\",(char*)i._key);\n@@ -3476,1 +3478,1 @@\n-  sprintf(subtree,\"_%s_%s_%s\", _opType, lstr, rstr);\n+  snprintf_checked(subtree, len, \"_%s_%s_%s\", _opType, lstr, rstr);\n@@ -3923,2 +3925,3 @@\n-  char* buf = (char*) AdlAllocateHeap(strlen(instr_ident) + 4);\n-  sprintf(buf, \"%s_%d\", instr_ident, match_rules_cnt++);\n+  const size_t buf_size = strlen(instr_ident) + 4;\n+  char* buf = (char*) AdlAllocateHeap(buf_size);\n+  snprintf_checked(buf, buf_size, \"%s_%d\", instr_ident, match_rules_cnt++);\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  sprintf(fname,\"%s%s\",base,suffix);\n+  snprintf_checked(fname,len,\"%s%s\",base,suffix);\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  if (TwoOperandLIRForm) {\n+  if (two_operand_lir_form) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-  if (TwoOperandLIRForm && left_op != result_op) {\n+  if (two_operand_lir_form && left_op != result_op) {\n@@ -570,1 +570,1 @@\n-  if (TwoOperandLIRForm && value != result_op\n+  if (two_operand_lir_form && value != result_op\n@@ -592,1 +592,1 @@\n-  if (TwoOperandLIRForm && left_op != result_op) {\n+  if (two_operand_lir_form && left_op != result_op) {\n@@ -4109,1 +4109,1 @@\n-  if (TwoOperandLIRForm) {\n+  if (two_operand_lir_form) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-  sprintf(message, \"Index %d out of bounds for length %d\", index, a->length());\n+  os::snprintf_checked(message, sizeof(message), \"Index %d out of bounds for length %d\", index, a->length());\n@@ -826,1 +826,1 @@\n-  sprintf(message, \"%d\", index);\n+  os::snprintf_checked(message, sizeof(message), \"%d\", index);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,3 +206,0 @@\n-  develop_pd(bool, TwoOperandLIRForm,                                       \\\n-          \"true if LIR requires src1 and dst to match in binary LIR ops\")   \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-    sprintf(&header_version[JVM_IDENT_MAX-9], \"%08x\", hash);\n+    os::snprintf_checked(&header_version[JVM_IDENT_MAX-9], 9, \"%08x\", hash);\n@@ -950,4 +950,6 @@\n-\n-      while (pos > 0 && rp_array->at(0)[--pos] != *os::file_separator());\n-      \/\/ return the file separator char position\n-      return pos + 1;\n+      while (pos > 0) {\n+        if (rp_array->at(0)[--pos] == *os::file_separator()) {\n+          return pos + 1;\n+        }\n+      }\n+      return 0;\n@@ -1092,2 +1094,6 @@\n-      mismatch = check_paths(j, shared_app_paths_len, rp_array,\n-                             dumptime_prefix_len, runtime_prefix_len);\n+      if (dumptime_prefix_len != 0 || runtime_prefix_len != 0) {\n+        log_info(class, path)(\"LCP length for app classpath (dumptime: %u, runtime: %u)\",\n+                              dumptime_prefix_len, runtime_prefix_len);\n+        mismatch = check_paths(j, shared_app_paths_len, rp_array,\n+                               dumptime_prefix_len, runtime_prefix_len);\n+      }\n@@ -2134,0 +2140,14 @@\n+\/\/ Get the total size in bytes of a read only region\n+size_t FileMapInfo::readonly_total() {\n+  size_t total = 0;\n+  if (current_info() != nullptr) {\n+    FileMapRegion* r = FileMapInfo::current_info()->region_at(MetaspaceShared::ro);\n+    if (r->read_only()) total += r->used();\n+  }\n+  if (dynamic_info() != nullptr) {\n+    FileMapRegion* r = FileMapInfo::dynamic_info()->region_at(MetaspaceShared::ro);\n+    if (r->read_only()) total += r->used();\n+  }\n+  return total;\n+}\n+\n@@ -2507,0 +2527,7 @@\n+narrowOop FileMapInfo::encoded_heap_region_dumptime_address(FileMapRegion* r) {\n+  assert(UseSharedSpaces, \"runtime only\");\n+  assert(UseCompressedOops, \"sanity\");\n+  r->assert_is_heap_region();\n+  return CompressedOops::narrow_oop_cast(r->mapping_offset() >> narrow_oop_shift());\n+}\n+\n@@ -2514,16 +2541,1 @@\n-    if (UseCompressedOops) {\n-      \/\/ These are the encoded values for the bottom of this region at dump-time vs run-time:\n-      narrowOop dt_encoded_bottom = CompressedOops::narrow_oop_cast(r->mapping_offset() >> narrow_oop_shift());\n-      narrowOop rt_encoded_bottom = CompressedOops::encode_not_null(cast_to_oop(regions[i].start()));\n-      log_info(cds)(\"patching heap embedded pointers for %s: narrowOop 0x%8x -> 0x%8x\",\n-                    region_name(region_idx), (uint)dt_encoded_bottom, (uint)rt_encoded_bottom);\n-      \/\/ TODO JDK-8269736: if we have the same narrow_oop_shift between dumptime and runtime,\n-      \/\/ Each embedded pointer P can be updated by:\n-      \/\/     P += (rt_encoded_bottom - dt_encoded_bottom)\n-      \/\/\n-      \/\/ TODO:\n-      \/\/ if (dt_encoded_bottom == rt_encoded_bottom && narrow_oop_shift() == CompressedOops::shift()) {\n-      \/\/   \/\/nothing to do\n-      \/\/   return;\n-      \/\/ }\n-    }\n+\n@@ -2531,1 +2543,1 @@\n-      regions[i],\n+      this, r, regions[i],\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -497,0 +497,1 @@\n+  static size_t readonly_total();\n@@ -629,0 +630,1 @@\n+  narrowOop encoded_heap_region_dumptime_address(FileMapRegion* r);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-#include \"classfile\/classLoaderDataShared.hpp\"\n-#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/modules.hpp\"\n@@ -87,0 +86,5 @@\n+size_t HeapShared::_alloc_count[HeapShared::ALLOC_STAT_SLOTS];\n+size_t HeapShared::_alloc_size[HeapShared::ALLOC_STAT_SLOTS];\n+size_t HeapShared::_total_obj_count;\n+size_t HeapShared::_total_obj_size;\n+\n@@ -304,0 +308,1 @@\n+    count_allocation(len);\n@@ -553,1 +558,1 @@\n-    ClassLoaderDataShared::init_archived_oops();\n+    Modules::verify_archived_modules();\n@@ -591,0 +596,1 @@\n+  count_allocation(roots()->size());\n@@ -836,0 +842,3 @@\n+  if (log_is_enabled(Info, cds, heap)) {\n+    print_stats();\n+  }\n@@ -1184,19 +1193,0 @@\n-void HeapShared::check_module_oop(oop orig_module_obj) {\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(java_lang_Module::is_instance(orig_module_obj), \"must be\");\n-  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n-  if (orig_module_ent == NULL) {\n-    \/\/ These special Module objects are created in Java code. They are not\n-    \/\/ defined via Modules::define_module(), so they don't have a ModuleEntry:\n-    \/\/     java.lang.Module::ALL_UNNAMED_MODULE\n-    \/\/     java.lang.Module::EVERYONE_MODULE\n-    \/\/     jdk.internal.loader.ClassLoaders$BootClassLoader::unnamedModule\n-    assert(java_lang_Module::name(orig_module_obj) == NULL, \"must be unnamed\");\n-    log_info(cds, heap)(\"Module oop with No ModuleEntry* @[\" PTR_FORMAT \"]\", p2i(orig_module_obj));\n-  } else {\n-    ClassLoaderData* loader_data = orig_module_ent->loader_data();\n-    assert(loader_data->is_builtin_class_loader_data(), \"must be\");\n-  }\n-}\n-\n-\n@@ -1271,1 +1261,3 @@\n-      check_module_oop(orig_obj);\n+      if (Modules::check_module_oop(orig_obj)) {\n+        Modules::update_oops_in_archived_module(orig_obj, append_root(archived_obj));\n+      }\n@@ -1273,1 +1265,0 @@\n-      java_lang_Module::set_loader(archived_obj, NULL);\n@@ -1863,0 +1854,45 @@\n+void HeapShared::count_allocation(size_t size) {\n+  _total_obj_count ++;\n+  _total_obj_size += size;\n+  for (int i = 0; i < ALLOC_STAT_SLOTS; i++) {\n+    if (size <= (size_t(1) << i)) {\n+      _alloc_count[i] ++;\n+      _alloc_size[i] += size;\n+      return;\n+    }\n+  }\n+}\n+\n+static double avg_size(size_t size, size_t count) {\n+  double avg = 0;\n+  if (count > 0) {\n+    avg = double(size * HeapWordSize) \/ double(count);\n+  }\n+  return avg;\n+}\n+\n+void HeapShared::print_stats() {\n+  size_t huge_count = _total_obj_count;\n+  size_t huge_size = _total_obj_size;\n+\n+  for (int i = 0; i < ALLOC_STAT_SLOTS; i++) {\n+    size_t byte_size_limit = (size_t(1) << i) * HeapWordSize;\n+    size_t count = _alloc_count[i];\n+    size_t size = _alloc_size[i];\n+    log_info(cds, heap)(SIZE_FORMAT_W(8) \" objects are <= \" SIZE_FORMAT_W(-6)\n+                        \" bytes (total \" SIZE_FORMAT_W(8) \" bytes, avg %8.1f bytes)\",\n+                        count, byte_size_limit, size * HeapWordSize, avg_size(size, count));\n+    huge_count -= count;\n+    huge_size -= size;\n+  }\n+\n+  log_info(cds, heap)(SIZE_FORMAT_W(8) \" huge  objects               (total \"  SIZE_FORMAT_W(8) \" bytes\"\n+                      \", avg %8.1f bytes)\",\n+                      huge_count, huge_size * HeapWordSize,\n+                      avg_size(huge_size, huge_count));\n+  log_info(cds, heap)(SIZE_FORMAT_W(8) \" total objects               (total \"  SIZE_FORMAT_W(8) \" bytes\"\n+                      \", avg %8.1f bytes)\",\n+                      _total_obj_count, _total_obj_size * HeapWordSize,\n+                      avg_size(_total_obj_size, _total_obj_count));\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":60,"deletions":24,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"ci\/ciUtilities.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -137,0 +137,1 @@\n+\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -722,1 +722,1 @@\n-  oop obj = cpool->resolved_references()->obj_at(obj_index);\n+  oop obj = cpool->resolved_reference_at(obj_index);\n@@ -1260,1 +1260,1 @@\n-uint ciEnv::compile_id() {\n+int ciEnv::compile_id() {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-  uint compile_id();  \/\/ task()->compile_id()\n+  int compile_id();  \/\/ task()->compile_id()\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+  _transitive_interfaces = NULL;\n@@ -846,0 +847,26 @@\n+GrowableArray<ciInstanceKlass*>* ciInstanceKlass::transitive_interfaces() const{\n+  if (_transitive_interfaces == NULL) {\n+    const_cast<ciInstanceKlass*>(this)->compute_transitive_interfaces();\n+  }\n+  return _transitive_interfaces;\n+}\n+\n+void ciInstanceKlass::compute_transitive_interfaces() {\n+  GUARDED_VM_ENTRY(\n+          InstanceKlass* ik = get_instanceKlass();\n+          Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n+          int orig_length = interfaces->length();\n+          Arena* arena = CURRENT_ENV->arena();\n+          int transitive_interfaces_len = orig_length + (is_interface() ? 1 : 0);\n+          GrowableArray<ciInstanceKlass*>* transitive_interfaces = new(arena)GrowableArray<ciInstanceKlass*>(arena, transitive_interfaces_len,\n+                                                                                                             0, NULL);\n+          for (int i = 0; i < orig_length; i++) {\n+            transitive_interfaces->append(CURRENT_ENV->get_instance_klass(interfaces->at(i)));\n+          }\n+          if (is_interface()) {\n+            transitive_interfaces->append(this);\n+          }\n+          _transitive_interfaces = transitive_interfaces;\n+  );\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  GrowableArray<ciInstanceKlass*>* _transitive_interfaces;\n@@ -83,0 +84,1 @@\n+  void compute_transitive_interfaces();\n@@ -300,0 +302,1 @@\n+  GrowableArray<ciInstanceKlass*>* transitive_interfaces() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+        obj->as_instance_klass()->transitive_interfaces();\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2350,3 +2350,1 @@\n-\/\/ The promoted_flags parameter is used to pass relevant access_flags\n-\/\/ from the method back up to the containing klass. These flag values\n-\/\/ are added to klass's access_flags.\n+\/\/ The has_localvariable_table parameter is used to pass up the value to InstanceKlass.\n@@ -2359,1 +2357,1 @@\n-                                      AccessFlags* const promoted_flags,\n+                                      bool* const has_localvariable_table,\n@@ -2363,1 +2361,1 @@\n-  assert(promoted_flags != NULL, \"invariant\");\n+  assert(has_localvariable_table != NULL, \"invariant\");\n@@ -2966,1 +2964,1 @@\n-    promoted_flags->set_has_localvariable_table();\n+    *has_localvariable_table = true;\n@@ -3022,3 +3020,0 @@\n-\/\/ The promoted_flags parameter is used to pass relevant access_flags\n-\/\/ from the methods back up to the containing klass. These flag values\n-\/\/ are added to klass's access_flags.\n@@ -3030,1 +3025,1 @@\n-                                    AccessFlags* promoted_flags,\n+                                    bool* const has_localvariable_table,\n@@ -3035,1 +3030,1 @@\n-  assert(promoted_flags != NULL, \"invariant\");\n+  assert(has_localvariable_table != NULL, \"invariant\");\n@@ -3057,1 +3052,1 @@\n-                                    promoted_flags,\n+                                    has_localvariable_table,\n@@ -5711,0 +5706,4 @@\n+  if (_has_localvariable_table) {\n+    ik->set_has_localvariable_table(true);\n+  }\n+\n@@ -6007,0 +6006,1 @@\n+  _has_localvariable_table(false),\n@@ -6351,1 +6351,0 @@\n-  AccessFlags promoted_flags;\n@@ -6355,1 +6354,1 @@\n-                &promoted_flags,\n+                &_has_localvariable_table,\n@@ -6363,3 +6362,0 @@\n-  \/\/ promote flags from parse_methods() to the klass' flags\n-  _access_flags.add_promoted_flags(promoted_flags.as_int());\n-\n@@ -6452,1 +6448,4 @@\n-    _super_klass = (const InstanceKlass*)\n+    if (loader.is_null() && super_class_name == vmSymbols::java_lang_Object()) {\n+      _super_klass = vmClasses::Object_klass();\n+    } else {\n+      _super_klass = (const InstanceKlass*)\n@@ -6459,0 +6458,1 @@\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+  bool _has_localvariable_table;\n@@ -290,1 +291,1 @@\n-                       AccessFlags* const promoted_flags,\n+                       bool* const has_localvariable_table,\n@@ -297,1 +298,1 @@\n-                     AccessFlags* const promoted_flags,\n+                     bool* const has_localvariable_table,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -69,0 +69,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -70,1 +71,0 @@\n-#include \"oops\/objArrayKlass.hpp\"\n@@ -73,1 +73,1 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n+#include \"oops\/verifyOopClosure.hpp\"\n@@ -1031,0 +1031,17 @@\n+class VerifyHandleOops : public OopClosure {\n+  VerifyOopClosure vc;\n+ public:\n+  virtual void do_oop(oop* p) {\n+    if (p != nullptr && *p != nullptr) {\n+      oop o = *p;\n+      if (!java_lang_Class::is_instance(o)) {\n+        \/\/ is_instance will assert for an invalid oop.\n+        \/\/ Walk the resolved_references array and other assorted oops in the\n+        \/\/ CLD::_handles field.  The mirror oops are followed by other heap roots.\n+        o->oop_iterate(&vc);\n+      }\n+    }\n+  }\n+  virtual void do_oop(narrowOop* o) { ShouldNotReachHere(); }\n+};\n+\n@@ -1054,0 +1071,13 @@\n+\n+  if (_deallocate_list != nullptr) {\n+    for (int i = _deallocate_list->length() - 1; i >= 0; i--) {\n+      Metadata* m = _deallocate_list->at(i);\n+      if (m->is_klass()) {\n+        ((Klass*)m)->verify();\n+      }\n+    }\n+  }\n+\n+  \/\/ Check the oops in the handles area\n+  VerifyHandleOops vho;\n+  oops_do(&vho, _claim_none, false);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1794,1 +1794,1 @@\n-  return (JavaThread*)java_thread->address_field(_eetop_offset);\n+  return reinterpret_cast<JavaThread*>(java_thread->address_field(_eetop_offset));\n@@ -2572,1 +2572,2 @@\n-  char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);\n+  const size_t buf_size = buf_len + 64;\n+  char* buf = NEW_RESOURCE_ARRAY(char, buf_size);\n@@ -2575,1 +2576,1 @@\n-  sprintf(buf, \"\\tat %s.%s(\", klass_name, method_name);\n+  size_t buf_off = os::snprintf_checked(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n@@ -2580,1 +2581,1 @@\n-      sprintf(buf + (int)strlen(buf), \"%s@%s\/\", module_name, module_version);\n+      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n@@ -2582,1 +2583,1 @@\n-      sprintf(buf + (int)strlen(buf), \"%s\/\", module_name);\n+      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n@@ -2597,1 +2598,1 @@\n-        sprintf(buf + (int)strlen(buf), \"%s:%d)\", source_file_name, line_number);\n+        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n@@ -2600,1 +2601,1 @@\n-        sprintf(buf + (int)strlen(buf), \"%s)\", source_file_name);\n+        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n@@ -2603,1 +2604,1 @@\n-        sprintf(buf + (int)strlen(buf), \"Unknown Source)\");\n+        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n@@ -2607,1 +2608,1 @@\n-        sprintf(buf + (int)strlen(buf), \"(nmethod \" INTPTR_FORMAT \")\", (intptr_t)nm);\n+        os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"(nmethod \" INTPTR_FORMAT \")\", (intptr_t)nm);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -968,0 +968,1 @@\n+  static inline void clear_referent_raw(oop ref);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -155,0 +155,4 @@\n+  HeapAccess<ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE>::oop_store_at(ref, _referent_offset, nullptr);\n+}\n+\n+void java_lang_ref_Reference::clear_referent_raw(oop ref) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,3 +112,5 @@\n-    Symbol::maybe_decrement_refcount(_supername);\n-    _supername = supername;\n-    Symbol::maybe_increment_refcount(_supername);\n+    if (supername != _supername) {\n+      Symbol::maybe_decrement_refcount(_supername);\n+      _supername = supername;\n+      Symbol::maybe_increment_refcount(_supername);\n+    }\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -186,0 +186,5 @@\n+\/\/ Helper function\n+inline ClassLoaderData* class_loader_data(Handle class_loader) {\n+  return ClassLoaderData::class_loader_data(class_loader());\n+}\n+\n@@ -1124,1 +1129,1 @@\n-      pkg_entry = ClassLoaderData::class_loader_data(class_loader())->packages()->lookup_only(pkg_name);\n+      pkg_entry = class_loader_data(class_loader)->packages()->lookup_only(pkg_name);\n@@ -1240,1 +1245,1 @@\n-  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), \"mismatched class loader data\");\n+  assert(shared_nest_host->class_loader_data() == class_loader_data(class_loader), \"mismatched class loader data\");\n@@ -1306,1 +1311,1 @@\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n+  ClassLoaderData* loader_data = class_loader_data(class_loader);\n@@ -1343,1 +1348,0 @@\n-    ClassLoaderData *loader_data = class_loader_data(class_loader);\n@@ -1348,1 +1352,1 @@\n-      pkg_entry = loader_data->packages()->lookup_only(pkg_name);\n+      pkg_entry = class_loader_data(class_loader)->packages()->lookup_only(pkg_name);\n@@ -1489,1 +1493,1 @@\n-    loaded_class->class_loader() != class_loader()) {\n+      loaded_class->class_loader() != class_loader()) {\n@@ -1491,1 +1495,2 @@\n-    check_constraints(loaded_class, class_loader, false, CHECK_NULL);\n+    ClassLoaderData* loader_data = class_loader_data(class_loader);\n+    check_constraints(loaded_class, loader_data, false, CHECK_NULL);\n@@ -1498,1 +1503,0 @@\n-    ClassLoaderData* loader_data = class_loader_data(class_loader);\n@@ -1504,1 +1508,1 @@\n-      update_dictionary(THREAD, loaded_class, class_loader);\n+      update_dictionary(THREAD, loaded_class, loader_data);\n@@ -1548,3 +1552,1 @@\n-  Symbol*  name_h = k->name();\n-  Dictionary* dictionary = loader_data->dictionary();\n-  check_constraints(k, class_loader, true, CHECK);\n+  check_constraints(k, loader_data, true, CHECK);\n@@ -1574,1 +1576,1 @@\n-    update_dictionary(THREAD, k, class_loader);\n+    update_dictionary(THREAD, k, loader_data);\n@@ -1607,1 +1609,1 @@\n-  Symbol*  name_h = k->name(); \/\/ passed in class_name may be null\n+  Symbol* name_h = k->name();\n@@ -1804,1 +1806,1 @@\n-                                         Handle class_loader,\n+                                         ClassLoaderData* loader_data,\n@@ -1812,2 +1814,1 @@\n-    Symbol *name = k->name();\n-    ClassLoaderData *loader_data = class_loader_data(class_loader);\n+    Symbol* name = k->name();\n@@ -1834,1 +1835,1 @@\n-      if (LoaderConstraintTable::check_or_update(k, class_loader, name) == false) {\n+      if (LoaderConstraintTable::check_or_update(k, loader_data, name) == false) {\n@@ -1839,2 +1840,2 @@\n-        Klass *existing_klass = LoaderConstraintTable::find_constrained_klass(name, class_loader);\n-        if (existing_klass != NULL && existing_klass->class_loader() != class_loader()) {\n+        Klass *existing_klass = LoaderConstraintTable::find_constrained_klass(name, loader_data);\n+        if (existing_klass != NULL && existing_klass->class_loader_data() != loader_data) {\n@@ -1863,1 +1864,1 @@\n-                                         Handle class_loader) {\n+                                         ClassLoaderData* loader_data) {\n@@ -1866,2 +1867,1 @@\n-  Symbol*  name  = k->name();\n-  ClassLoaderData *loader_data = class_loader_data(class_loader);\n+  Symbol* name  = k->name();\n@@ -1869,2 +1869,1 @@\n-  {\n-    MutexLocker mu1(SystemDictionary_lock);\n+  MutexLocker mu1(SystemDictionary_lock);\n@@ -1872,7 +1871,5 @@\n-    \/\/ Make a new dictionary entry.\n-    Dictionary* dictionary = loader_data->dictionary();\n-    InstanceKlass* sd_check = dictionary->find_class(current, name);\n-    if (sd_check == NULL) {\n-      dictionary->add_klass(current, name, k);\n-    }\n-    SystemDictionary_lock->notify_all();\n+  \/\/ Make a new dictionary entry.\n+  Dictionary* dictionary = loader_data->dictionary();\n+  InstanceKlass* sd_check = dictionary->find_class(current, name);\n+  if (sd_check == NULL) {\n+    dictionary->add_klass(current, name, k);\n@@ -1880,0 +1877,1 @@\n+  SystemDictionary_lock->notify_all();\n@@ -1910,1 +1908,1 @@\n-      klass = LoaderConstraintTable::find_constrained_klass(ss.as_symbol(), class_loader);\n+      klass = LoaderConstraintTable::find_constrained_klass(ss.as_symbol(), class_loader_data(class_loader));\n@@ -1923,1 +1921,1 @@\n-    klass = LoaderConstraintTable::find_constrained_klass(class_name, class_loader);\n+    klass = LoaderConstraintTable::find_constrained_klass(class_name, class_loader_data(class_loader));\n@@ -1963,2 +1961,2 @@\n-    bool result = LoaderConstraintTable::add_entry(constraint_name, klass1, class_loader1,\n-                                                   klass2, class_loader2);\n+    bool result = LoaderConstraintTable::add_entry(constraint_name, klass1, loader_data1,\n+                                                   klass2, loader_data2);\n@@ -2526,4 +2524,0 @@\n-ClassLoaderData* SystemDictionary::class_loader_data(Handle class_loader) {\n-  return ClassLoaderData::class_loader_data(class_loader());\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":34,"deletions":40,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -211,4 +211,0 @@\n-  \/\/ Returns the class loader data to be used when looking up\/updating the\n-  \/\/ system dictionary.\n-  static ClassLoaderData *class_loader_data(Handle class_loader);\n-\n@@ -391,1 +387,1 @@\n-  static void check_constraints(InstanceKlass* k, Handle loader,\n+  static void check_constraints(InstanceKlass* k, ClassLoaderData* loader,\n@@ -393,1 +389,1 @@\n-  static void update_dictionary(JavaThread* current, InstanceKlass* k, Handle loader);\n+  static void update_dictionary(JavaThread* current, InstanceKlass* k, ClassLoaderData* loader_data);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-    if (!UsePolyIntrinsics) return true;\n+    if (!UsePoly1305Intrinsics) return true;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1474,1 +1474,1 @@\n-  return NativeAccess<AS_NO_KEEPALIVE>::oop_load(oop_addr_at(index));\n+  return NMethodAccess<AS_NO_KEEPALIVE>::oop_load(oop_addr_at(index));\n@@ -1481,1 +1481,1 @@\n-  return NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(oop_addr_at(index));\n+  return NMethodAccess<ON_PHANTOM_OOP_REF>::oop_load(oop_addr_at(index));\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -935,1 +935,1 @@\n-    sprintf(name_buffer, \"%s CompilerThread%d\", _compilers[1]->name(), i);\n+    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", _compilers[1]->name(), i);\n@@ -957,1 +957,1 @@\n-    sprintf(name_buffer, \"C1 CompilerThread%d\", i);\n+    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"C1 CompilerThread%d\", i);\n@@ -1021,1 +1021,1 @@\n-        sprintf(name_buffer, \"%s CompilerThread%d\", _compilers[1]->name(), i);\n+        os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", _compilers[1]->name(), i);\n@@ -1569,1 +1569,1 @@\n-uint CompileBroker::assign_compile_id_unlocked(Thread* thread, const methodHandle& method, int osr_bci) {\n+int CompileBroker::assign_compile_id_unlocked(Thread* thread, const methodHandle& method, int osr_bci) {\n@@ -2112,1 +2112,1 @@\n-  uint compile_id = task->compile_id();\n+  int compile_id = task->compile_id();\n@@ -2435,1 +2435,1 @@\n-  uint compile_id = task->compile_id();\n+  int compile_id = task->compile_id();\n@@ -2603,1 +2603,1 @@\n-      sprintf(tier_name, \"Tier%d\", tier);\n+      os::snprintf_checked(tier_name, sizeof(tier_name), \"Tier%d\", tier);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1010,1 +1010,1 @@\n-                    && (if_ctrl->in(0)->is_MultiBranch() && if_ctrl->in(0)->Opcode() == Op_NeverBranch)) {\n+                    && if_ctrl->in(0)->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    return NOT_ARM32(new BarrierSetNMethod()) ARM32_ONLY(nullptr);\n+    return new BarrierSetNMethod();\n@@ -121,1 +121,1 @@\n-    thread->set_nmethod_disarm_value(bs_nm->disarmed_value());\n+    thread->set_nmethod_disarmed_guard_value(bs_nm->disarmed_guard_value());\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,0 +271,1 @@\n+  virtual void eliminate_gc_barrier_data(Node* node) const { }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1031,1 +1031,1 @@\n-                      && (if_ctrl->in(0)->is_MultiBranch() && if_ctrl->in(0)->Opcode() == Op_NeverBranch)) {\n+                      && if_ctrl->in(0)->is_NeverBranch()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-      } else if (c->Opcode() == Op_CProj && next->Opcode() == Op_NeverBranch) {\n+      } else if (c->Opcode() == Op_CProj && next->is_NeverBranch()) {\n@@ -2002,1 +2002,1 @@\n-    if (in != NULL && in->Opcode() == Op_Halt && in->in(0)->is_Proj() && in->in(0)->in(0)->Opcode() == Op_NeverBranch) {\n+    if (in != NULL && in->Opcode() == Op_Halt && in->in(0)->is_Proj() && in->in(0)->in(0)->is_NeverBranch()) {\n@@ -2033,1 +2033,1 @@\n-              assert(r->in(j)->Opcode() != Op_NeverBranch, \"\");\n+              assert(!r->in(j)->is_NeverBranch(), \"\");\n@@ -2039,1 +2039,1 @@\n-            assert(in->is_CallStaticJava() || in->Opcode() == Op_NeverBranch || in->Opcode() == Op_Catch || proj->is_IfProj(), \"\");\n+            assert(in->is_CallStaticJava() || in->is_NeverBranch() || in->Opcode() == Op_Catch || proj->is_IfProj(), \"\");\n@@ -2046,1 +2046,1 @@\n-            } else if (in->Opcode() == Op_NeverBranch) {\n+            } else if (in->is_NeverBranch()) {\n@@ -2517,1 +2517,1 @@\n-                     !(u->Opcode() == Op_CProj && u->in(0)->Opcode() == Op_NeverBranch && u->as_Proj()->_con == 1)) {\n+                     !(u->Opcode() == Op_CProj && u->in(0)->is_NeverBranch() && u->as_Proj()->_con == 1)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-int* ZBarrierSetNMethod::disarmed_value_address() const {\n+int* ZBarrierSetNMethod::disarmed_guard_value_address() const {\n@@ -75,1 +75,1 @@\n-ByteSize ZBarrierSetNMethod::thread_disarmed_offset() const {\n+ByteSize ZBarrierSetNMethod::thread_disarmed_guard_value_offset() const {\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-      oop coop = m->constants()->resolved_references()->obj_at(rindex);\n+      oop coop = m->constants()->resolved_reference_at(rindex);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -817,1 +817,1 @@\n-            (resolved_klass == NULL ? \"<NULL>\" : resolved_klass->internal_name()),\n+            resolved_klass->internal_name(),\n@@ -975,4 +975,0 @@\n-  if (resolved_klass == NULL) {\n-    ResourceMark rm(THREAD);\n-    THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field->as_C_string());\n-  }\n@@ -999,1 +995,5 @@\n-    THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field->as_C_string());\n+    stringStream ss;\n+    ss.print(\"Class %s does not have member field '\", resolved_klass->external_name());\n+    sig->print_as_field_external_type(&ss);\n+    ss.print(\" %s'\", field->as_C_string());\n+    THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), ss.as_string());\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,4 +157,10 @@\n-    _name(name),\n-    _signature(signature), _resolved_klass(resolved_klass), _current_klass(current_klass), _current_method(methodHandle()),\n-    _check_access(check_access == AccessCheck::required),\n-    _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required), _tag(tag) {}\n+      _name(name),\n+      _signature(signature),\n+      _resolved_klass(resolved_klass),\n+      _current_klass(current_klass),\n+      _current_method(methodHandle()),\n+      _check_access(check_access == AccessCheck::required),\n+      _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required),\n+      _tag(tag) {\n+    assert(_resolved_klass != nullptr, \"must always have a resolved_klass\");\n+  }\n@@ -166,5 +172,3 @@\n-    _name(name),\n-    _signature(signature), _resolved_klass(resolved_klass), _current_klass(current_method->method_holder()), _current_method(current_method),\n-    _check_access(check_access == AccessCheck::required),\n-    _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required), _tag(tag) {}\n-\n+    LinkInfo(resolved_klass, name, signature, current_method->method_holder(), check_access, check_loader_constraints, tag) {\n+    _current_method = current_method;\n+  }\n@@ -172,1 +176,1 @@\n-  \/\/ Case where we just find the method and don't check access against the current class\n+  \/\/ Case where we just find the method and don't check access against the current class, used by JavaCalls\n@@ -174,3 +178,2 @@\n-    _name(name),\n-    _signature(signature), _resolved_klass(resolved_klass), _current_klass(NULL), _current_method(methodHandle()),\n-    _check_access(false), _check_loader_constraints(false), _tag(JVM_CONSTANT_Invalid) {}\n+    LinkInfo(resolved_klass, name, signature, nullptr, AccessCheck::skip, LoaderConstraintCheck::skip,\n+             JVM_CONSTANT_Invalid) {}\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-\/\/ atomicity decorators as well as compressed oops)\n+\/\/ atomicity decorators as well as compressed oops).\n@@ -296,1 +296,1 @@\n-\/\/ may resolve an accessor on a GC barrier set\n+\/\/ may resolve an accessor on a GC barrier set.\n@@ -301,1 +301,1 @@\n-\/\/ may resolve an accessor on a GC barrier set\n+\/\/ may resolve an accessor on a GC barrier set.\n@@ -305,0 +305,5 @@\n+\/\/ Helper for performing accesses in nmethods. These accesses\n+\/\/ may resolve an accessor on a GC barrier set.\n+template <DecoratorSet decorators = DECORATORS_NONE>\n+class NMethodAccess: public Access<IN_NMETHOD | decorators> {};\n+\n@@ -382,0 +387,1 @@\n+    (location_decorators ^ IN_NMETHOD) == 0 ||\n","filename":"src\/hotspot\/share\/oops\/access.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"metaprogramming\/decay.hpp\"\n@@ -34,2 +33,0 @@\n-#include \"metaprogramming\/isFloatingPoint.hpp\"\n-#include \"metaprogramming\/isIntegral.hpp\"\n@@ -38,1 +35,0 @@\n-#include \"metaprogramming\/isVolatile.hpp\"\n@@ -45,0 +41,1 @@\n+#include <type_traits>\n@@ -446,1 +443,1 @@\n-    typedef typename OopOrNarrowOopInternal<typename Decay<T>::type>::type type;\n+    typedef typename OopOrNarrowOopInternal<std::decay_t<T>>::type type;\n@@ -1144,2 +1141,2 @@\n-                   (IsPointer<T>::value || IsIntegral<T>::value) ||\n-                    IsFloatingPoint<T>::value)); \/\/ not allowed primitive type\n+                   (IsPointer<T>::value || std::is_integral<T>::value) ||\n+                    std::is_floating_point<T>::value)); \/\/ not allowed primitive type\n@@ -1151,2 +1148,2 @@\n-    typedef typename Decay<P>::type DecayedP;\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedP = std::decay_t<P>;\n+    using DecayedT = std::decay_t<T>;\n@@ -1157,1 +1154,1 @@\n-      (IsVolatile<P>::value && !HasDecorator<decorators, MO_DECORATOR_MASK>::value) ?\n+      (std::is_volatile<P>::value && !HasDecorator<decorators, MO_DECORATOR_MASK>::value) ?\n@@ -1165,1 +1162,1 @@\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedT = std::decay_t<T>;\n@@ -1176,1 +1173,1 @@\n-    typedef typename Decay<P>::type DecayedP;\n+    using DecayedP = std::decay_t<P>;\n@@ -1179,1 +1176,1 @@\n-                                 typename Decay<T>::type>::type DecayedT;\n+                                 std::decay_t<T>>::type DecayedT;\n@@ -1183,1 +1180,1 @@\n-      (IsVolatile<P>::value && !HasDecorator<decorators, MO_DECORATOR_MASK>::value) ?\n+      (std::is_volatile<P>::value && !HasDecorator<decorators, MO_DECORATOR_MASK>::value) ?\n@@ -1193,1 +1190,1 @@\n-                                 typename Decay<T>::type>::type DecayedT;\n+                                 std::decay_t<T>>::type DecayedT;\n@@ -1205,2 +1202,2 @@\n-    typedef typename Decay<P>::type DecayedP;\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedP = std::decay_t<P>;\n+    using DecayedT = std::decay_t<T>;\n@@ -1220,1 +1217,1 @@\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedT = std::decay_t<T>;\n@@ -1238,2 +1235,2 @@\n-    typedef typename Decay<P>::type DecayedP;\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedP = std::decay_t<P>;\n+    using DecayedT = std::decay_t<T>;\n@@ -1250,1 +1247,1 @@\n-    typedef typename Decay<T>::type DecayedT;\n+    using DecayedT = std::decay_t<T>;\n@@ -1264,3 +1261,3 @@\n-                   (IsSame<T, void>::value || IsIntegral<T>::value) ||\n-                    IsFloatingPoint<T>::value)); \/\/ arraycopy allows type erased void elements\n-    typedef typename Decay<T>::type DecayedT;\n+                   (IsSame<T, void>::value || std::is_integral<T>::value) ||\n+                    std::is_floating_point<T>::value)); \/\/ arraycopy allows type erased void elements\n+    using DecayedT = std::decay_t<T>;\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+\/\/ * IN_NMETHOD: The access is performed inside of an nmethod.\n@@ -177,1 +178,2 @@\n-const DecoratorSet IN_DECORATOR_MASK  = IN_HEAP | IN_NATIVE;\n+const DecoratorSet IN_NMETHOD         = UCONST64(1) << 20;\n+const DecoratorSet IN_DECORATOR_MASK  = IN_HEAP | IN_NATIVE | IN_NMETHOD;\n@@ -185,3 +187,3 @@\n-const DecoratorSet IS_ARRAY              = UCONST64(1) << 20;\n-const DecoratorSet IS_DEST_UNINITIALIZED = UCONST64(1) << 21;\n-const DecoratorSet IS_NOT_NULL           = UCONST64(1) << 22;\n+const DecoratorSet IS_ARRAY              = UCONST64(1) << 21;\n+const DecoratorSet IS_DEST_UNINITIALIZED = UCONST64(1) << 22;\n+const DecoratorSet IS_NOT_NULL           = UCONST64(1) << 23;\n@@ -201,6 +203,6 @@\n-const DecoratorSet ARRAYCOPY_CHECKCAST            = UCONST64(1) << 23;\n-const DecoratorSet ARRAYCOPY_NOTNULL              = UCONST64(1) << 24;\n-const DecoratorSet ARRAYCOPY_DISJOINT             = UCONST64(1) << 25;\n-const DecoratorSet ARRAYCOPY_ARRAYOF              = UCONST64(1) << 26;\n-const DecoratorSet ARRAYCOPY_ATOMIC               = UCONST64(1) << 27;\n-const DecoratorSet ARRAYCOPY_ALIGNED              = UCONST64(1) << 28;\n+const DecoratorSet ARRAYCOPY_CHECKCAST            = UCONST64(1) << 24;\n+const DecoratorSet ARRAYCOPY_NOTNULL              = UCONST64(1) << 25;\n+const DecoratorSet ARRAYCOPY_DISJOINT             = UCONST64(1) << 26;\n+const DecoratorSet ARRAYCOPY_ARRAYOF              = UCONST64(1) << 27;\n+const DecoratorSet ARRAYCOPY_ATOMIC               = UCONST64(1) << 28;\n+const DecoratorSet ARRAYCOPY_ALIGNED              = UCONST64(1) << 29;\n@@ -215,2 +217,2 @@\n-const DecoratorSet ACCESS_READ                    = UCONST64(1) << 29;\n-const DecoratorSet ACCESS_WRITE                   = UCONST64(1) << 30;\n+const DecoratorSet ACCESS_READ                    = UCONST64(1) << 30;\n+const DecoratorSet ACCESS_WRITE                   = UCONST64(1) << 31;\n@@ -219,1 +221,1 @@\n-const DecoratorSet DECORATOR_LAST = UCONST64(1) << 30;\n+const DecoratorSet DECORATOR_LAST = UCONST64(1) << 31;\n","filename":"src\/hotspot\/share\/oops\/accessDecorators.hpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-  return (objArrayOop)_cache->resolved_references();\n+  return _cache->resolved_references();\n@@ -171,1 +171,1 @@\n-    return (objArrayOop)_cache->resolved_references();\n+    return _cache->resolved_references();\n@@ -175,0 +175,12 @@\n+oop ConstantPool::resolved_reference_at(int index) const {\n+  oop result = resolved_references()->obj_at(index);\n+  assert(oopDesc::is_oop_or_null(result), \"Must be oop\");\n+  return result;\n+}\n+\n+\/\/ Use a CAS for multithreaded access\n+oop ConstantPool::set_resolved_reference_at(int index, oop new_result) {\n+  assert(oopDesc::is_oop_or_null(new_result), \"Must be oop\");\n+  return resolved_references()->replace_if_null(index, new_result);\n+}\n+\n@@ -455,1 +467,2 @@\n-  resolved_references()->obj_at_put(obj_index, str);\n+  oop result = set_resolved_reference_at(obj_index, str);\n+  assert(result == nullptr || result == str, \"Only set once or to the same string.\");\n@@ -983,1 +996,1 @@\n-    result_oop = this_cp->resolved_references()->obj_at(cache_index);\n+    result_oop = this_cp->resolved_reference_at(cache_index);\n@@ -1208,3 +1221,2 @@\n-    oop old_result = this_cp->resolved_references()\n-      ->atomic_compare_exchange_oop(cache_index, new_result, NULL);\n-    if (old_result == NULL) {\n+    oop old_result = this_cp->set_resolved_reference_at(cache_index, new_result);\n+    if (old_result == nullptr) {\n@@ -1271,1 +1283,1 @@\n-  oop str = this_cp->resolved_references()->obj_at(obj_index);\n+  oop str = this_cp->resolved_reference_at(obj_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,0 +239,3 @@\n+  oop resolved_reference_at(int obj_index) const;\n+  oop set_resolved_reference_at(int index, oop new_value);\n+\n@@ -486,1 +489,1 @@\n-    return resolved_references()->obj_at(obj_index);\n+    return resolved_reference_at(obj_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -441,4 +441,2 @@\n-    objArrayOop resolved_references = cpool->resolved_references();\n-    assert(appendix_index >= 0 && appendix_index < resolved_references->length(), \"oob\");\n-    assert(resolved_references->obj_at(appendix_index) == NULL, \"init just once\");\n-    resolved_references->obj_at_put(appendix_index, appendix());\n+    oop old_oop = cpool->set_resolved_reference_at(appendix_index, appendix());\n+    assert(old_oop == nullptr, \"init just once\");\n@@ -540,2 +538,1 @@\n-  objArrayOop resolved_references = cpool->resolved_references();\n-  return resolved_references->obj_at(ref_index);\n+  return cpool->resolved_reference_at(ref_index);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -460,1 +460,1 @@\n-  inline oop resolved_references();\n+  inline objArrayOop resolved_references();\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/devirtualizer.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -647,4 +647,4 @@\n-  \/\/ Can't release the constant pool here because the constant pool can be\n-  \/\/ deallocated separately from the InstanceKlass for default methods and\n-  \/\/ redefine classes.\n-  release_C_heap_structures(\/* release_constant_pool *\/ false);\n+  \/\/ Can't release the constant pool or MethodData C heap data here because the constant\n+  \/\/ pool can be deallocated separately from the InstanceKlass for default methods and\n+  \/\/ redefine classes.  MethodData can also be released separately.\n+  release_C_heap_structures(\/* release_sub_metadata *\/ false);\n@@ -2352,9 +2352,2 @@\n-      \/\/ cache can grow so we have to be more careful\n-      if (Threads::number_of_threads() == 0 ||\n-          SafepointSynchronize::is_at_safepoint()) {\n-        \/\/ we're single threaded or at a safepoint - no locking needed\n-        get_jmethod_id_length_value(jmeths, idnum, &length, &id);\n-      } else {\n-        MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n-        get_jmethod_id_length_value(jmeths, idnum, &length, &id);\n-      }\n+      MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n+      get_jmethod_id_length_value(jmeths, idnum, &length, &id);\n@@ -2370,2 +2363,2 @@\n-    \/\/ This function can be called by the VMThread so we have to do all\n-    \/\/ things that might block on a safepoint before grabbing the lock.\n+    \/\/ This function can be called by the VMThread or GC worker threads so we\n+    \/\/ have to do all things that might block on a safepoint before grabbing the lock.\n@@ -2390,18 +2383,1 @@\n-    jmethodID new_id = NULL;\n-    if (method_h->is_old() && !method_h->is_obsolete()) {\n-      \/\/ The method passed in is old (but not obsolete), we need to use the current version\n-      Method* current_method = method_with_idnum((int)idnum);\n-      assert(current_method != NULL, \"old and but not obsolete, so should exist\");\n-      new_id = Method::make_jmethod_id(class_loader_data(), current_method);\n-    } else {\n-      \/\/ It is the current version of the method or an obsolete method,\n-      \/\/ use the version passed in\n-      new_id = Method::make_jmethod_id(class_loader_data(), method_h());\n-    }\n-\n-    if (Threads::number_of_threads() == 0 ||\n-        SafepointSynchronize::is_at_safepoint()) {\n-      \/\/ we're single threaded or at a safepoint - no locking needed\n-      id = get_jmethod_id_fetch_or_update(idnum, new_id, new_jmeths,\n-                                          &to_dealloc_id, &to_dealloc_jmeths);\n-    } else {\n+    {\n@@ -2409,0 +2385,12 @@\n+      jmethodID new_id = NULL;\n+      if (method_h->is_old() && !method_h->is_obsolete()) {\n+        \/\/ The method passed in is old (but not obsolete), we need to use the current version\n+        Method* current_method = method_with_idnum((int)idnum);\n+        assert(current_method != NULL, \"old and but not obsolete, so should exist\");\n+        new_id = Method::make_jmethod_id(class_loader_data(), current_method);\n+      } else {\n+        \/\/ It is the current version of the method or an obsolete method,\n+        \/\/ use the version passed in\n+        new_id = Method::make_jmethod_id(class_loader_data(), method_h());\n+      }\n+\n@@ -2458,3 +2446,1 @@\n-  assert(Threads::number_of_threads() == 0 ||\n-         SafepointSynchronize::is_at_safepoint() ||\n-         JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n+  assert(JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n@@ -2887,2 +2873,2 @@\n-\/\/ Called also by InstanceKlass::deallocate_contents, with false for release_constant_pool.\n-void InstanceKlass::release_C_heap_structures(bool release_constant_pool) {\n+\/\/ Called also by InstanceKlass::deallocate_contents, with false for release_sub_metadata.\n+void InstanceKlass::release_C_heap_structures(bool release_sub_metadata) {\n@@ -2893,1 +2879,3 @@\n-  methods_do(method_release_C_heap_structures);\n+  if (release_sub_metadata) {\n+    methods_do(method_release_C_heap_structures);\n+  }\n@@ -2933,1 +2921,1 @@\n-  if (release_constant_pool) {\n+  if (release_sub_metadata) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":28,"deletions":40,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -364,0 +364,3 @@\n+  bool has_localvariable_table() const     { return _misc_status.has_localvariable_table(); }\n+  void set_has_localvariable_table(bool b) { _misc_status.set_has_localvariable_table(b); }\n+\n@@ -1091,1 +1094,1 @@\n-  virtual void release_C_heap_structures(bool release_constant_pool = true);\n+  virtual void release_C_heap_structures(bool release_sub_metadata = true);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,6 +49,7 @@\n-    flag(has_inline_type_fields             , 1 << 14) \/* has inline fields and related embedded section is not empty *\/ \\\n-    flag(is_empty_inline_type               , 1 << 15) \/* empty inline type (*) *\/ \\\n-    flag(is_naturally_atomic                , 1 << 16) \/* loaded\/stored in one instruction *\/ \\\n-    flag(is_declared_atomic                 , 1 << 17) \/* Listed -XX:ForceNonTearable=clist option *\/ \\\n-    flag(carries_value_modifier             , 1 << 18) \/* the class or one of its super types has the ACC_VALUE modifier *\/ \\\n-    flag(carries_identity_modifier          , 1 << 19) \/* the class or one of its super types has the ACC_IDENTITY modifier *\/\n+    flag(has_localvariable_table            , 1 << 14) \/* has localvariable information *\/ \\\n+    flag(has_inline_type_fields             , 1 << 15) \/* has inline fields and related embedded section is not empty *\/ \\\n+    flag(is_empty_inline_type               , 1 << 16) \/* empty inline type (*) *\/ \\\n+    flag(is_naturally_atomic                , 1 << 17) \/* loaded\/stored in one instruction *\/ \\\n+    flag(is_declared_atomic                 , 1 << 18) \/* Listed -XX:ForceNonTearable=clist option *\/ \\\n+    flag(carries_value_modifier             , 1 << 19) \/* the class or one of its super types has the ACC_VALUE modifier *\/ \\\n+    flag(carries_identity_modifier          , 1 << 20) \/* the class or one of its super types has the ACC_IDENTITY modifier *\/\n@@ -86,1 +87,1 @@\n-    assert(!name(), \"set once\");    \\\n+    assert_is_safe(name());         \\\n@@ -105,0 +106,2 @@\n+\n+  void assert_is_safe(bool set) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/oops\/instanceKlassMiscStatus.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -144,4 +144,3 @@\n-#if INCLUDE_JVMCI\n-    FailedSpeculation::free_failed_speculations(method_data()->get_failed_speculations_address());\n-#endif\n-    \/\/ Destroy MethodData\n+    method_data()->release_C_heap_structures();\n+\n+    \/\/ Destroy MethodData embedded lock\n@@ -2232,12 +2231,7 @@\n-void Method::ensure_jmethod_ids(ClassLoaderData* loader_data, int capacity) {\n-  ClassLoaderData* cld = loader_data;\n-  if (!SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n-    \/\/ Also have to add the method to the list safely, which the lock\n-    \/\/ protects as well.\n-    MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n-    if (cld->jmethod_ids() == NULL) {\n-      cld->set_jmethod_ids(new JNIMethodBlock(capacity));\n-    } else {\n-      cld->jmethod_ids()->ensure_methods(capacity);\n-    }\n+void Method::ensure_jmethod_ids(ClassLoaderData* cld, int capacity) {\n+  \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n+  \/\/ Also have to add the method to the list safely, which the lock\n+  \/\/ protects as well.\n+  MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n+  if (cld->jmethod_ids() == NULL) {\n+    cld->set_jmethod_ids(new JNIMethodBlock(capacity));\n@@ -2245,6 +2239,1 @@\n-    \/\/ At safepoint, we are single threaded and can set this.\n-    if (cld->jmethod_ids() == NULL) {\n-      cld->set_jmethod_ids(new JNIMethodBlock(capacity));\n-    } else {\n-      cld->jmethod_ids()->ensure_methods(capacity);\n-    }\n+    cld->jmethod_ids()->ensure_methods(capacity);\n@@ -2255,20 +2244,7 @@\n-jmethodID Method::make_jmethod_id(ClassLoaderData* loader_data, Method* m) {\n-  ClassLoaderData* cld = loader_data;\n-\n-  if (!SafepointSynchronize::is_at_safepoint()) {\n-    \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n-    \/\/ Also have to add the method to the list safely, which the lock\n-    \/\/ protects as well.\n-    MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n-    if (cld->jmethod_ids() == NULL) {\n-      cld->set_jmethod_ids(new JNIMethodBlock());\n-    }\n-    \/\/ jmethodID is a pointer to Method*\n-    return (jmethodID)cld->jmethod_ids()->add_method(m);\n-  } else {\n-    \/\/ At safepoint, we are single threaded and can set this.\n-    if (cld->jmethod_ids() == NULL) {\n-      cld->set_jmethod_ids(new JNIMethodBlock());\n-    }\n-    \/\/ jmethodID is a pointer to Method*\n-    return (jmethodID)cld->jmethod_ids()->add_method(m);\n+jmethodID Method::make_jmethod_id(ClassLoaderData* cld, Method* m) {\n+  \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n+  \/\/ Also have to add the method to the list safely, which the lock\n+  \/\/ protects as well.\n+  assert(JmethodIdCreation_lock->owned_by_self(), \"sanity check\");\n+  if (cld->jmethod_ids() == NULL) {\n+    cld->set_jmethod_ids(new JNIMethodBlock());\n@@ -2276,0 +2252,2 @@\n+  \/\/ jmethodID is a pointer to Method*\n+  return (jmethodID)cld->jmethod_ids()->add_method(m);\n@@ -2285,2 +2263,1 @@\n-void Method::destroy_jmethod_id(ClassLoaderData* loader_data, jmethodID m) {\n-  ClassLoaderData* cld = loader_data;\n+void Method::destroy_jmethod_id(ClassLoaderData* cld, jmethodID m) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":21,"deletions":44,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -799,2 +799,2 @@\n-  static jmethodID make_jmethod_id(ClassLoaderData* loader_data, Method* mh);\n-  static void destroy_jmethod_id(ClassLoaderData* loader_data, jmethodID mid);\n+  static jmethodID make_jmethod_id(ClassLoaderData* cld, Method* mh);\n+  static void destroy_jmethod_id(ClassLoaderData* cld, jmethodID mid);\n@@ -805,1 +805,1 @@\n-  static void ensure_jmethod_ids(ClassLoaderData* loader_data, int capacity);\n+  static void ensure_jmethod_ids(ClassLoaderData* cld, int capacity);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1642,1 +1642,1 @@\n-  return profile_arguments_flag() > no_type_profile && profile_arguments_flag() <= type_profile_all;\n+  return profile_arguments_flag() > no_type_profile && profile_arguments_flag() <= type_profile_all && TypeProfileArgsLimit > 0;\n@@ -1868,0 +1868,10 @@\n+\n+void MethodData::deallocate_contents(ClassLoaderData* loader_data) {\n+  release_C_heap_structures();\n+}\n+\n+void MethodData::release_C_heap_structures() {\n+#if INCLUDE_JVMCI\n+  FailedSpeculation::free_failed_speculations(get_failed_speculations_address());\n+#endif\n+}\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2613,2 +2613,3 @@\n-  \/\/ Deallocation support - no metaspace pointer fields to deallocate\n-  void deallocate_contents(ClassLoaderData* loader_data) {}\n+  \/\/ Deallocation support\n+  void deallocate_contents(ClassLoaderData* loader_data);\n+  void release_C_heap_structures();\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,0 +372,19 @@\n+void Symbol::print_as_field_external_type(outputStream *os) {\n+  SignatureStream ss(this, false);\n+  assert(!ss.is_done(), \"must have at least one element in field ref\");\n+  assert(!ss.at_return_type(), \"field ref cannot be a return type\");\n+  assert(!Signature::is_method(this), \"field ref cannot be a method\");\n+\n+  if (ss.is_array()) {\n+    print_array(os, ss);\n+  } else if (ss.is_reference()) {\n+    print_class(os, ss);\n+  } else {\n+    os->print(\"%s\", type2name(ss.type()));\n+  }\n+#ifdef ASSERT\n+  ss.next();\n+  assert(ss.is_done(), \"must have at most one element in field ref\");\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,0 +290,1 @@\n+  void print_as_field_external_type(outputStream *os);\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -326,0 +326,3 @@\n+    Node* hook = new Node(1);\n+    hook->init_req(0, dest_offset);\n+\n@@ -327,0 +330,3 @@\n+\n+    hook->destruct(phase);\n+\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  _caller_jvms(caller_jvms),\n+  _caller_jvms(NULL),\n@@ -60,1 +60,1 @@\n-  if (_caller_jvms != NULL) {\n+  if (caller_jvms != NULL) {\n@@ -65,0 +65,1 @@\n+    assert(_caller_jvms->same_calls_as(caller_jvms), \"consistent JVMS\");\n@@ -66,1 +67,0 @@\n-  assert(_caller_jvms->same_calls_as(caller_jvms), \"consistent JVMS\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -398,18 +398,1 @@\n-  Node* dom = dominating_cast(phase, phase);\n-  if (dom != NULL) {\n-    return dom;\n-  }\n-  if (_dependency != RegularDependency) {\n-    return this;\n-  }\n-  const Type* t = phase->type(in(1));\n-  if (EnableVectorReboxing && in(1)->Opcode() == Op_VectorBox) {\n-    if (t->higher_equal_speculative(phase->type(this))) {\n-      return in(1);\n-    }\n-  } else if (t == phase->type(this)) {\n-    \/\/ Toned down to rescue meeting at a Phi 3 different oops all implementing\n-    \/\/ the same interface.\n-    return in(1);\n-  }\n-  return this;\n+  return ConstraintCastNode::Identity(phase);\n@@ -426,2 +409,6 @@\n-  const TypePtr *in_type   = inn->isa_ptr();\n-  const TypePtr *my_type   = _type->isa_ptr();\n+  if (inn->isa_oopptr() && _type->isa_oopptr()) {\n+    return ConstraintCastNode::Value(phase);\n+  }\n+\n+  const TypePtr *in_type = inn->isa_ptr();\n+  const TypePtr *my_type = _type->isa_ptr();\n@@ -442,12 +429,2 @@\n-    } else if (in_ptr == TypePtr::Constant) {\n-      if (my_type->isa_rawptr()) {\n-        result = my_type;\n-      } else {\n-        const TypeOopPtr *jptr = my_type->isa_oopptr();\n-        assert(jptr, \"\");\n-        result = !in_type->higher_equal(_type)\n-          ? my_type->cast_to_ptr_type(TypePtr::NotNull)\n-          : in_type;\n-      }\n-    } else {\n-      result =  my_type->cast_to_ptr_type( my_type->join_ptr(in_ptr) );\n+    } else if (in_ptr != TypePtr::Constant) {\n+      result =  my_type->cast_to_ptr_type(my_type->join_ptr(in_ptr));\n@@ -457,55 +434,1 @@\n-  \/\/ This is the code from TypePtr::xmeet() that prevents us from\n-  \/\/ having 2 ways to represent the same type. We have to replicate it\n-  \/\/ here because we don't go through meet\/join.\n-  if (result->remove_speculative() == result->speculative()) {\n-    result = result->remove_speculative();\n-  }\n-\n-  \/\/ Same as above: because we don't go through meet\/join, remove the\n-  \/\/ speculative type if we know we won't use it.\n-  return result->cleanup_speculative();\n-\n-  \/\/ JOIN NOT DONE HERE BECAUSE OF INTERFACE ISSUES.\n-  \/\/ FIX THIS (DO THE JOIN) WHEN UNION TYPES APPEAR!\n-\n-  \/\/\n-  \/\/ Remove this code after overnight run indicates no performance\n-  \/\/ loss from not performing JOIN at CheckCastPPNode\n-  \/\/\n-  \/\/ const TypeInstPtr *in_oop = in->isa_instptr();\n-  \/\/ const TypeInstPtr *my_oop = _type->isa_instptr();\n-  \/\/ \/\/ If either input is an 'interface', return destination type\n-  \/\/ assert (in_oop == NULL || in_oop->klass() != NULL, \"\");\n-  \/\/ assert (my_oop == NULL || my_oop->klass() != NULL, \"\");\n-  \/\/ if( (in_oop && in_oop->klass()->is_interface())\n-  \/\/   ||(my_oop && my_oop->klass()->is_interface()) ) {\n-  \/\/   TypePtr::PTR  in_ptr = in->isa_ptr() ? in->is_ptr()->_ptr : TypePtr::BotPTR;\n-  \/\/   \/\/ Preserve cast away nullness for interfaces\n-  \/\/   if( in_ptr == TypePtr::NotNull && my_oop && my_oop->_ptr == TypePtr::BotPTR ) {\n-  \/\/     return my_oop->cast_to_ptr_type(TypePtr::NotNull);\n-  \/\/   }\n-  \/\/   return _type;\n-  \/\/ }\n-  \/\/\n-  \/\/ \/\/ Neither the input nor the destination type is an interface,\n-  \/\/\n-  \/\/ \/\/ history: JOIN used to cause weird corner case bugs\n-  \/\/ \/\/          return (in == TypeOopPtr::NULL_PTR) ? in : _type;\n-  \/\/ \/\/ JOIN picks up NotNull in common instance-of\/check-cast idioms, both oops.\n-  \/\/ \/\/ JOIN does not preserve NotNull in other cases, e.g. RawPtr vs InstPtr\n-  \/\/ const Type *join = in->join(_type);\n-  \/\/ \/\/ Check if join preserved NotNull'ness for pointers\n-  \/\/ if( join->isa_ptr() && _type->isa_ptr() ) {\n-  \/\/   TypePtr::PTR join_ptr = join->is_ptr()->_ptr;\n-  \/\/   TypePtr::PTR type_ptr = _type->is_ptr()->_ptr;\n-  \/\/   \/\/ If there isn't any NotNull'ness to preserve\n-  \/\/   \/\/ OR if join preserved NotNull'ness then return it\n-  \/\/   if( type_ptr == TypePtr::BotPTR  || type_ptr == TypePtr::Null ||\n-  \/\/       join_ptr == TypePtr::NotNull || join_ptr == TypePtr::Constant ) {\n-  \/\/     return join;\n-  \/\/   }\n-  \/\/   \/\/ ELSE return same old type as before\n-  \/\/   return _type;\n-  \/\/ }\n-  \/\/ \/\/ Not joining two pointers\n-  \/\/ return join;\n+  return result;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":10,"deletions":87,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -398,0 +398,41 @@\n+#ifdef ASSERT\n+\/\/ Is this region in an infinite subgraph?\n+\/\/ (no path to root except through false NeverBranch exit)\n+bool RegionNode::is_in_infinite_subgraph() {\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(this);\n+  return RegionNode::are_all_nodes_in_infinite_subgraph(worklist);\n+}\n+\n+\/\/ Are all nodes in worklist in infinite subgraph?\n+\/\/ (no path to root except through false NeverBranch exit)\n+\/\/ worklist is directly used for the traversal\n+bool RegionNode::are_all_nodes_in_infinite_subgraph(Unique_Node_List& worklist) {\n+  \/\/ BFS traversal down the CFG, except through NeverBranch exits\n+  for (uint i = 0; i < worklist.size(); ++i) {\n+    Node* n = worklist.at(i);\n+    assert(n->is_CFG(), \"only traverse CFG\");\n+    if (n->is_Root()) {\n+      \/\/ Found root -> there was an exit!\n+      return false;\n+    } else if (n->is_NeverBranch()) {\n+      \/\/ Only follow the loop-internal projection, not the NeverBranch exit\n+      ProjNode* proj = n->as_NeverBranch()->proj_out_or_null(0);\n+      assert(proj != nullptr, \"must find loop-internal projection of NeverBranch\");\n+      worklist.push(proj);\n+    } else {\n+      \/\/ Traverse all CFG outputs\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node* use = n->fast_out(i);\n+        if (use->is_CFG()) {\n+          worklist.push(use);\n+        }\n+      }\n+    }\n+  }\n+  \/\/ No exit found for any loop -> all are infinite\n+  return true;\n+}\n+#endif \/\/ASSERT\n+\n@@ -993,8 +1034,0 @@\n-  const TypePtr *t = adr_type();\n-  assert(type() == Type::MEMORY &&\n-         (t == TypePtr::BOTTOM || t == TypeRawPtr::BOTTOM ||\n-          t->isa_oopptr() && !t->is_oopptr()->is_known_instance() &&\n-          t->is_oopptr()->cast_to_exactness(true)\n-           ->is_oopptr()->cast_to_ptr_type(t_oop->ptr())\n-           ->is_oopptr()->cast_to_instance_id(t_oop->instance_id()) == t_oop),\n-         \"bottom or raw memory required\");\n@@ -1200,16 +1233,0 @@\n-  \/\/ Until we have harmony between classes and interfaces in the type\n-  \/\/ lattice, we must tread carefully around phis which implicitly\n-  \/\/ convert the one to the other.\n-  const TypePtr* ttp = _type->make_ptr();\n-  const TypeInstPtr* ttip = (ttp != NULL) ? ttp->isa_instptr() : NULL;\n-  const TypeInstKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n-  bool is_intf = false;\n-  if (ttip != NULL) {\n-    if (ttip->is_interface())\n-      is_intf = true;\n-  }\n-  if (ttkp != NULL) {\n-    if (ttkp->is_interface())\n-      is_intf = true;\n-  }\n-\n@@ -1222,14 +1239,0 @@\n-      \/\/ We assume that each input of an interface-valued Phi is a true\n-      \/\/ subtype of that interface.  This might not be true of the meet\n-      \/\/ of all the input types.  The lattice is not distributive in\n-      \/\/ such cases.  Ward off asserts in type.cpp by refusing to do\n-      \/\/ meets between interfaces and proper classes.\n-      const TypePtr* tip = ti->make_ptr();\n-      const TypeInstPtr* tiip = (tip != NULL) ? tip->isa_instptr() : NULL;\n-      if (tiip) {\n-        bool ti_is_intf = false;\n-        if (tiip->is_interface())\n-          ti_is_intf = true;\n-        if (is_intf != ti_is_intf)\n-          { t = _type; break; }\n-      }\n@@ -1259,25 +1262,3 @@\n-\n-    \/\/ Check for evil case of 't' being a class and '_type' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!t->empty() && ttip && ttip->is_interface()) {\n-      assert(ft == _type, \"\"); \/\/ Uplift to interface\n-    } else if (!t->empty() && ttkp && ttkp->is_interface()) {\n-      assert(ft == _type, \"\"); \/\/ Uplift to interface\n-    } else {\n-      \/\/ We also have to handle 'evil cases' of interface- vs. class-arrays\n-      Type::get_arrays_base_elements(jt, _type, NULL, &ttip);\n-      if (!t->empty() && ttip != NULL && ttip->is_interface()) {\n-          assert(ft == _type, \"\");   \/\/ Uplift to array of interface\n-      } else {\n-        \/\/ Otherwise it's something stupid like non-overlapping int ranges\n-        \/\/ found on dying counted loops.\n-        assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n-      }\n-    }\n+    \/\/ Otherwise it's something stupid like non-overlapping int ranges\n+    \/\/ found on dying counted loops.\n+    assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n@@ -1288,25 +1269,0 @@\n-    \/\/ If we have an interface-typed Phi and we narrow to a class type, the join\n-    \/\/ should report back the class.  However, if we have a J\/L\/Object\n-    \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-    \/\/ join report an interface back out.  This isn't possible but happens\n-    \/\/ because the type system doesn't interact well with interfaces.\n-    const TypePtr *jtp = jt->make_ptr();\n-    const TypeInstPtr *jtip = (jtp != NULL) ? jtp->isa_instptr() : NULL;\n-    const TypeInstKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n-    if (jtip && ttip) {\n-      if (jtip->is_interface() &&\n-          !ttip->is_interface()) {\n-        assert(ft == ttip->cast_to_ptr_type(jtip->ptr()) ||\n-               ft->isa_narrowoop() && ft->make_ptr() == ttip->cast_to_ptr_type(jtip->ptr()), \"\");\n-        jt = ft;\n-      }\n-    }\n-    if (jtkp && ttkp) {\n-      if (jtkp->is_interface() &&\n-          !jtkp->klass_is_exact() && \/\/ Keep exact interface klass (6894807)\n-          ttkp->is_loaded() && !ttkp->is_interface()) {\n-        assert(ft == ttkp->cast_to_ptr_type(jtkp->ptr()) ||\n-               ft->isa_narrowklass() && ft->make_ptr() == ttkp->cast_to_ptr_type(jtkp->ptr()), \"\");\n-        jt = ft;\n-      }\n-    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":44,"deletions":88,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+#ifdef ASSERT\n+  bool is_in_infinite_subgraph();\n+  static bool are_all_nodes_in_infinite_subgraph(Unique_Node_List& worklist);\n+#endif \/\/ASSERT\n@@ -598,1 +602,4 @@\n-  NeverBranchNode( Node *ctrl ) : MultiBranchNode(1) { init_req(0,ctrl); }\n+  NeverBranchNode(Node* ctrl) : MultiBranchNode(1) {\n+    init_req(0, ctrl);\n+    init_class_id(Class_NeverBranch);\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1487,1 +1487,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, Type::Offset(offset), canonical_holder->flatten_array(), to->instance_id());\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, Type::Offset(offset), to->instance_id());\n@@ -1516,1 +1516,0 @@\n-\n@@ -4887,2 +4886,2 @@\n-Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk) {\n-  if (StressReflectiveCode) {\n+Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk, bool skip) {\n+  if (skip) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-class Int_Array;\n@@ -81,1 +80,0 @@\n-class Scope;\n@@ -86,1 +84,0 @@\n-class TypeData;\n@@ -169,1 +166,0 @@\n-  static const char* debug_option_name;\n@@ -1204,1 +1200,1 @@\n-  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk);\n+  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk, bool skip = StressReflectiveCode);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint));\n+    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint, Type::trust_interfaces));\n@@ -906,1 +906,1 @@\n-\/\/ no subklasses.  We do a Deutsch-Shiffman style type-check on the incoming\n+\/\/ no subklasses.  We do a Deutsch-Schiffman style type-check on the incoming\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1034,3 +1034,0 @@\n-  BasicType rtype = T_ILLEGAL;\n-  int       rsize = 0;\n-\n@@ -1039,3 +1036,0 @@\n-    rtype = Bytecodes::result_type(code); \/\/ checkcast=P, athrow=V\n-    if (rtype < T_CONFLICT)\n-      rsize = type2size[rtype];\n@@ -1044,0 +1038,6 @@\n+  auto rsize = [&]() {\n+    assert(code != Bytecodes::_illegal, \"code is illegal!\");\n+    BasicType rtype = Bytecodes::result_type(code); \/\/ checkcast=P, athrow=V\n+    return (rtype < T_CONFLICT) ? type2size[rtype] : 0;\n+  };\n+\n@@ -1104,2 +1104,2 @@\n-      assert(rsize == 1, \"\");\n-      depth = rsize - inputs;\n+      assert(rsize() == 1, \"\");\n+      depth = 1 - inputs;\n@@ -1114,1 +1114,1 @@\n-    depth = rsize - inputs;\n+    depth = rsize() - inputs;\n@@ -1123,2 +1123,2 @@\n-    assert(rsize == -depth, \"\");\n-    inputs = rsize;\n+    assert(rsize() == -depth, \"\");\n+    inputs = -depth;\n@@ -1135,1 +1135,1 @@\n-    inputs = rsize - depth;\n+    inputs = rsize() - depth;\n@@ -1607,1 +1607,2 @@\n-                                bool unsafe) {\n+                                bool unsafe,\n+                                int barrier_data) {\n@@ -1622,0 +1623,1 @@\n+  st->as_Store()->set_barrier_data(barrier_data);\n@@ -2296,1 +2298,1 @@\n-    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls);\n+    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls, Type::trust_interfaces);\n@@ -2762,1 +2764,1 @@\n-  gvn.transform(cmp);\n+  cmp = gvn.transform(cmp);\n@@ -2984,1 +2986,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces);\n@@ -3024,1 +3026,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces)->try_improve();\n@@ -3166,1 +3168,1 @@\n-        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls)) == Compile::SSC_always_true) {\n+        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls, Type::trust_interfaces)) == Compile::SSC_always_true) {\n@@ -3351,2 +3353,2 @@\n-  const TypeKlassPtr* tk = _gvn.type(superklass)->is_klassptr();\n-  const TypeOopPtr* toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr()->try_improve();\n+  const TypeOopPtr *toop = tk->cast_to_exactness(false)->as_instance_type();\n@@ -3369,1 +3371,1 @@\n-      kptr = TypeInstKlassPtr::make(TypePtr::NotNull, vk, Type::Offset(0), vk->flatten_array());\n+      kptr = TypeInstKlassPtr::make(TypePtr::NotNull, vk, Type::Offset(0));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -580,1 +580,2 @@\n-                        bool unsafe = false) {\n+                        bool unsafe = false,\n+                        int barrier_data = 0) {\n@@ -586,1 +587,2 @@\n-                           unaligned, mismatched, unsafe);\n+                           unaligned, mismatched, unsafe,\n+                           barrier_data);\n@@ -596,1 +598,2 @@\n-                        bool unsafe = false);\n+                        bool unsafe = false,\n+                        int barrier_data = 0);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1144,0 +1144,3 @@\n+  if (tinit == Type::TOP) {\n+    return Type::TOP;\n+  }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3903,1 +3903,1 @@\n-      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass()), tp->as_klass_type());\n+      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass(), Type::trust_interfaces), tp->as_klass_type());\n@@ -7390,1 +7390,1 @@\n-  assert(UsePolyIntrinsics, \"need Poly intrinsics support\");\n+  assert(UsePoly1305Intrinsics, \"need Poly intrinsics support\");\n@@ -7622,1 +7622,1 @@\n-  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n+  const TypeOopPtr* xtype = aklass->cast_to_exactness(false)->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -153,1 +153,5 @@\n-  if (phase->type(in(1))->is_inlinetypeptr()) {\n+  const Type* in1_t = phase->type(in(1));\n+  if (in1_t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (in1_t->is_inlinetypeptr()) {\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -362,0 +362,2 @@\n+\n+  static bool is_zero_trip_guard_if(const IfNode* iff);\n@@ -802,0 +804,13 @@\n+\n+  void collect_loop_core_nodes(PhaseIdealLoop* phase, Unique_Node_List& wq) const;\n+\n+  bool empty_loop_with_data_nodes(PhaseIdealLoop* phase) const;\n+\n+  void enqueue_data_nodes(PhaseIdealLoop* phase, Unique_Node_List& empty_loop_nodes, Unique_Node_List& wq) const;\n+\n+  bool process_safepoint(PhaseIdealLoop* phase, Unique_Node_List& empty_loop_nodes, Unique_Node_List& wq,\n+                         Node* sfpt) const;\n+\n+  bool empty_loop_candidate(PhaseIdealLoop* phase) const;\n+\n+  bool empty_loop_with_extra_nodes_candidate(PhaseIdealLoop* phase) const;\n@@ -1573,0 +1588,3 @@\n+  bool cannot_split_division(const Node* n, const Node* region) const;\n+  static bool is_divisor_counted_loop_phi(const Node* divisor, const Node* loop);\n+  bool loop_phi_backedge_type_contains_zero(const Node* phi_divisor, const Type* zero) const;\n@@ -1737,0 +1755,8 @@\n+\n+  bool clone_cmp_down(Node* n, const Node* blk1, const Node* blk2);\n+\n+  void clone_loadklass_nodes_at_cmp_index(const Node* n, Node* cmp, int i);\n+\n+  bool clone_cmp_loadklass_down(Node* n, const Node* blk1, const Node* blk2);\n+\n+  bool at_relevant_ctrl(Node* n, const Node* blk1, const Node* blk2);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,13 +71,2 @@\n-  \/\/ Bail out if 'n' is a Div or Mod node whose zero check was removed earlier (i.e. control is NULL) and its divisor is an induction variable\n-  \/\/ phi p of a trip-counted (integer) loop whose inputs could be zero (include zero in their type range). p could have a more precise type\n-  \/\/ range that does not necessarily include all values of its inputs. Since each of these inputs will be a divisor of the newly cloned nodes\n-  \/\/ of 'n', we need to bail out of one of these divisors could be zero (zero in its type range).\n-  if ((n->Opcode() == Op_DivI || n->Opcode() == Op_ModI) && n->in(0) == NULL\n-      && region->is_CountedLoop() && n->in(2) == region->as_CountedLoop()->phi()) {\n-    Node* phi = region->as_CountedLoop()->phi();\n-    for (uint i = 1; i < phi->req(); i++) {\n-      if (_igvn.type(phi->in(i))->filter_speculative(TypeInt::ZERO) != Type::TOP) {\n-        \/\/ Zero could be a possible value but we already removed the zero check. Bail out to avoid a possible division by zero at a later point.\n-        return NULL;\n-      }\n-    }\n+  if (cannot_split_division(n, region)) {\n+    return NULL;\n@@ -235,0 +224,36 @@\n+\/\/ Return true if 'n' is a Div or Mod node (without zero check If node which was removed earlier) with a loop phi divisor\n+\/\/ of a trip-counted (integer or long) loop with a backedge input that could be zero (include zero in its type range). In\n+\/\/ this case, we cannot split the division to the backedge as it could freely float above the loop exit check resulting in\n+\/\/ a division by zero. This situation is possible because the type of an increment node of an iv phi (trip-counter) could\n+\/\/ include zero while the iv phi does not (see PhiNode::Value() for trip-counted loops where we improve types of iv phis).\n+\/\/ We also need to check other loop phis as they could have been created in the same split-if pass when applying\n+\/\/ PhaseIdealLoop::split_thru_phi() to split nodes through an iv phi.\n+bool PhaseIdealLoop::cannot_split_division(const Node* n, const Node* region) const {\n+  const Type* zero;\n+  switch (n->Opcode()) {\n+    case Op_DivI:\n+    case Op_ModI:\n+      zero = TypeInt::ZERO;\n+      break;\n+    case Op_DivL:\n+    case Op_ModL:\n+      zero = TypeLong::ZERO;\n+      break;\n+    default:\n+      return false;\n+  }\n+\n+  assert(n->in(0) == NULL, \"divisions with zero check should already have bailed out earlier in split-if\");\n+  Node* divisor = n->in(2);\n+  return is_divisor_counted_loop_phi(divisor, region) &&\n+         loop_phi_backedge_type_contains_zero(divisor, zero);\n+}\n+\n+bool PhaseIdealLoop::is_divisor_counted_loop_phi(const Node* divisor, const Node* loop) {\n+  return loop->is_BaseCountedLoop() && divisor->is_Phi() && divisor->in(0) == loop;\n+}\n+\n+bool PhaseIdealLoop::loop_phi_backedge_type_contains_zero(const Node* phi_divisor, const Type* zero) const {\n+    return _igvn.type(phi_divisor->in(LoopNode::LoopBackControl))->filter_speculative(zero) != Type::TOP;\n+}\n+\n@@ -802,2 +827,2 @@\n-      if (u->Opcode() == Op_NeverBranch) {\n-        u = ((NeverBranchNode*)u)->proj_out(0);\n+      if (u->is_NeverBranch()) {\n+        u = u->as_NeverBranch()->proj_out(0);\n@@ -986,1 +1011,1 @@\n-            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->Opcode() == Op_NeverBranch, \"must not be moved into inner loop\");\n+            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch(), \"must not be moved into inner loop\");\n@@ -1246,1 +1271,1 @@\n-        (dom->Opcode() == Op_NeverBranch && loop->is_member(get_loop(dom->in(0))))) {\n+        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n@@ -1903,1 +1928,1 @@\n-    if (u->Opcode() == Op_Opaque1) {\n+    if (u->is_Opaque1()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/subnode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,5 +221,20 @@\n-    if (t == TypePtr::BOTTOM || t == TypeRawPtr::BOTTOM ||\n-        (t->isa_oopptr() && !t->is_oopptr()->is_known_instance() &&\n-         t->is_oopptr()->cast_to_exactness(true)\n-           ->is_oopptr()->cast_to_ptr_type(t_oop->ptr())\n-            ->is_oopptr()->cast_to_instance_id(t_oop->instance_id()) == t_oop)) {\n+    bool do_split = false;\n+    \/\/ In the following cases, Load memory input can be further optimized based on\n+    \/\/ its precise address type\n+    if (t == TypePtr::BOTTOM || t == TypeRawPtr::BOTTOM ) {\n+      do_split = true;\n+    } else if (t->isa_oopptr() && !t->is_oopptr()->is_known_instance()) {\n+      const TypeOopPtr* mem_t =\n+        t->is_oopptr()->cast_to_exactness(true)\n+        ->is_oopptr()->cast_to_ptr_type(t_oop->ptr())\n+        ->is_oopptr()->cast_to_instance_id(t_oop->instance_id());\n+      if (t_oop->is_aryptr()) {\n+        mem_t = mem_t->is_aryptr()\n+                     ->cast_to_stable(t_oop->is_aryptr()->is_stable())\n+                     ->cast_to_size(t_oop->is_aryptr()->size())\n+                     ->with_offset(t_oop->is_aryptr()->offset())\n+                     ->is_aryptr();\n+      }\n+      do_split = mem_t == t_oop;\n+    }\n+    if (do_split) {\n@@ -2081,1 +2096,1 @@\n-  if (tkls != NULL && !StressReflectiveCode) {\n+  if (tkls != NULL) {\n@@ -2101,1 +2116,1 @@\n-        return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n+        return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -2132,1 +2147,1 @@\n-          return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n+          return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -2402,1 +2417,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t, null_free));\n+          return TypeKlassPtr::make(ciArrayKlass::make(t, null_free), Type::trust_interfaces);\n@@ -2409,1 +2424,1 @@\n-        return TypeKlassPtr::make(t->as_klass());\n+        return TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n@@ -2447,1 +2462,1 @@\n-      return sup ? TypeKlassPtr::make(sup) : TypePtr::NULL_PTR;\n+      return sup ? TypeKlassPtr::make(sup, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -4103,0 +4118,1 @@\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n@@ -4106,0 +4122,1 @@\n+  bs->eliminate_gc_barrier_data(new_st);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -743,1 +743,0 @@\n-  dump();\n@@ -2401,11 +2400,0 @@\n-\/\/ log10 rounded down\n-uint log10(const uint i) {\n-  uint v = 10;\n-  uint e = 0;\n-  while(v <= i) {\n-    v *= 10;\n-    e++;\n-  }\n-  return e;\n-}\n-\n@@ -2421,1 +2409,1 @@\n-    uint max_width = log10(C->unique()) + 2;\n+    uint max_width = static_cast<uint>(log10(static_cast<double>(C->unique()))) + 2;\n@@ -2423,1 +2411,1 @@\n-    uint width = log10(_idx) + 1 + (is_new ? 0 : 1);\n+    uint width = static_cast<uint>(log10(static_cast<double>(_idx))) + 1 + (is_new ? 0 : 1);\n@@ -2563,4 +2551,1 @@\n-    ciKlass*           klass = toop ? toop->instance_klass() : (tkls ? tkls->instance_klass() : NULL );\n-    if (klass && klass->is_loaded() && ((toop && toop->is_interface()) || (tkls && tkls->is_interface()))) {\n-      st->print(\"  Interface:\");\n-    } else if (toop) {\n+    if (toop) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -775,1 +775,1 @@\n-    _max_classes  = ClassMask_Move\n+    _max_classes  = ClassMask_LShift\n@@ -938,0 +938,1 @@\n+  DEFINE_CLASS_QUERY(NeverBranch)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,106 +222,0 @@\n-volatile int C2SafepointPollStubTable::_stub_size = 0;\n-\n-Label& C2SafepointPollStubTable::add_safepoint(uintptr_t safepoint_offset) {\n-  C2SafepointPollStub* entry = new (Compile::current()->comp_arena()) C2SafepointPollStub(safepoint_offset);\n-  _safepoints.append(entry);\n-  return entry->_stub_label;\n-}\n-\n-void C2SafepointPollStubTable::emit(CodeBuffer& cb) {\n-  MacroAssembler masm(&cb);\n-  for (int i = _safepoints.length() - 1; i >= 0; i--) {\n-    \/\/ Make sure there is enough space in the code buffer\n-    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n-      ciEnv::current()->record_failure(\"CodeCache is full\");\n-      return;\n-    }\n-\n-    C2SafepointPollStub* entry = _safepoints.at(i);\n-    emit_stub(masm, entry);\n-  }\n-}\n-\n-int C2SafepointPollStubTable::stub_size_lazy() const {\n-  int size = Atomic::load(&_stub_size);\n-\n-  if (size != 0) {\n-    return size;\n-  }\n-\n-  Compile* const C = Compile::current();\n-  BufferBlob* const blob = C->output()->scratch_buffer_blob();\n-  CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());\n-  MacroAssembler masm(&cb);\n-  C2SafepointPollStub* entry = _safepoints.at(0);\n-  emit_stub(masm, entry);\n-  size += cb.insts_size();\n-\n-  Atomic::store(&_stub_size, size);\n-\n-  return size;\n-}\n-\n-int C2SafepointPollStubTable::estimate_stub_size() const {\n-  if (_safepoints.length() == 0) {\n-    return 0;\n-  }\n-\n-  int result = stub_size_lazy() * _safepoints.length();\n-\n-#ifdef ASSERT\n-  Compile* const C = Compile::current();\n-  BufferBlob* const blob = C->output()->scratch_buffer_blob();\n-  int size = 0;\n-\n-  for (int i = _safepoints.length() - 1; i >= 0; i--) {\n-    CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());\n-    MacroAssembler masm(&cb);\n-    C2SafepointPollStub* entry = _safepoints.at(i);\n-    emit_stub(masm, entry);\n-    size += cb.insts_size();\n-  }\n-  assert(size == result, \"stubs should not have variable size\");\n-#endif\n-\n-  return result;\n-}\n-\n-\/\/ Nmethod entry barrier stubs\n-C2EntryBarrierStub* C2EntryBarrierStubTable::add_entry_barrier() {\n-  C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n-  _stubs.append(stub);\n-  return stub;\n-}\n-\n-void C2EntryBarrierStubTable::emit(CodeBuffer& cb) {\n-  if (_stubs.is_empty()) {\n-    \/\/ No stub - nothing to do\n-    return;\n-  }\n-\n-  C2_MacroAssembler masm(&cb);\n-  for (C2EntryBarrierStub* stub : _stubs) {\n-    \/\/ Make sure there is enough space in the code buffer\n-    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n-      ciEnv::current()->record_failure(\"CodeCache is full\");\n-      return;\n-    }\n-\n-    intptr_t before = masm.offset();\n-    masm.emit_entry_barrier_stub(stub);\n-    intptr_t after = masm.offset();\n-    int actual_size = (int)(after - before);\n-    int expected_size = masm.entry_barrier_stub_size();\n-    assert(actual_size == expected_size, \"Estimated size is wrong, expected %d, was %d\", expected_size, actual_size);\n-  }\n-}\n-\n-int C2EntryBarrierStubTable::estimate_stub_size() const {\n-  if (BarrierSet::barrier_set()->barrier_set_nmethod() == NULL) {\n-    \/\/ No nmethod entry barrier?\n-    return 0;\n-  }\n-\n-  return C2_MacroAssembler::entry_barrier_stub_size();\n-}\n-\n@@ -334,2 +228,1 @@\n-    _safepoint_poll_table(),\n-    _entry_barrier_table(),\n+    _stub_list(),\n@@ -1421,2 +1314,0 @@\n-  stub_req += safepoint_poll_table()->estimate_stub_size();\n-  stub_req += entry_barrier_table()->estimate_stub_size();\n@@ -1930,6 +1821,2 @@\n-  \/\/ Fill in stubs for calling the runtime from safepoint polls.\n-  safepoint_poll_table()->emit(*cb);\n-  if (C->failing())  return;\n-\n-  \/\/ Fill in stubs for calling the runtime from nmethod entries.\n-  entry_barrier_table()->emit(*cb);\n+  \/\/ Fill in stubs.\n+  _stub_list.emit(*cb);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":116,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1274,1 +1274,1 @@\n-    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder, Type::trust_interfaces);\n@@ -1287,1 +1287,1 @@\n-      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder, Type::trust_interfaces));\n@@ -2286,1 +2286,1 @@\n-  Node* holder = makecon(TypeKlassPtr::make(method()->holder()));\n+  Node* holder = makecon(TypeKlassPtr::make(method()->holder(), Type::trust_interfaces));\n@@ -2372,20 +2372,0 @@\n-    } else if (tr && tr->isa_instptr() && tr->is_loaded() && tr->is_interface()) {\n-      \/\/ If returning oops to an interface-return, there is a silent free\n-      \/\/ cast from oop to interface allowed by the Verifier. Make it explicit here.\n-      const TypeInstPtr* tp = value->bottom_type()->isa_instptr();\n-      if (tp && tp->is_loaded() && !tp->is_interface()) {\n-        \/\/ sharpen the type eagerly; this eases certain assert checking\n-        if (tp->higher_equal(TypeInstPtr::NOTNULL)) {\n-          tr = tr->join_speculative(TypeInstPtr::NOTNULL)->is_instptr();\n-        }\n-        value = _gvn.transform(new CheckCastPPNode(0, value, tr));\n-      }\n-    } else {\n-      \/\/ Handle returns of oop-arrays to an arrays-of-interface return\n-      const TypeInstPtr* phi_tip;\n-      const TypeInstPtr* val_tip;\n-      Type::get_arrays_base_elements(return_type, value->bottom_type(), &phi_tip, &val_tip);\n-      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->is_interface() &&\n-          val_tip != NULL && val_tip->is_loaded() && !val_tip->is_interface()) {\n-        value = _gvn.transform(new CheckCastPPNode(0, value, return_type));\n-      }\n@@ -2393,0 +2373,3 @@\n+    \/\/ ...else\n+    \/\/ If returning oops to an interface-return, there is a silent free\n+    \/\/ cast from oop to interface allowed by the Verifier. Make it explicit here.\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass);\n+  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n@@ -348,1 +348,1 @@\n-  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass)), length, nargs);\n+  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)), length, nargs);\n@@ -445,1 +445,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass)),\n+                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n@@ -467,1 +467,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass)),\n+                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n@@ -474,1 +474,1 @@\n-  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass);\n+  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass, Type::trust_interfaces);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)), NULL, null_free);\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), NULL, null_free);\n@@ -137,1 +137,1 @@\n-  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass)), true);\n+  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), true);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1251,0 +1251,5 @@\n+  \/\/ Allow Bool -> Cmp idealisation in late inlining intrinsics that return a bool\n+  if (n->is_Cmp()) {\n+    add_users_to_worklist(n);\n+  }\n+\n@@ -1722,0 +1727,7 @@\n+    if (use->Opcode() == Op_OpaqueZeroTripGuard) {\n+      assert(use->outcnt() <= 1, \"OpaqueZeroTripGuard can't be shared\");\n+      if (use->outcnt() == 1) {\n+        Node* cmp = use->unique_out();\n+        _worklist.push(cmp);\n+      }\n+    }\n@@ -1821,0 +1833,1 @@\n+  DEBUG_ONLY(Unique_Node_List worklist_verify;)\n@@ -1829,0 +1842,1 @@\n+    DEBUG_ONLY(worklist_verify.push(n);)\n@@ -1842,0 +1856,45 @@\n+  DEBUG_ONLY(verify_analyze(worklist_verify);)\n+}\n+\n+#ifdef ASSERT\n+\/\/ For every node n on verify list, check if type(n) == n->Value()\n+\/\/ We have a list of exceptions, see comments in code.\n+void PhaseCCP::verify_analyze(Unique_Node_List& worklist_verify) {\n+  bool failure = false;\n+  while (worklist_verify.size()) {\n+    Node* n = worklist_verify.pop();\n+    const Type* told = type(n);\n+    const Type* tnew = n->Value(this);\n+    if (told != tnew) {\n+      \/\/ Check special cases that are ok\n+      if (told->isa_integer(tnew->basic_type()) != nullptr) { \/\/ both either int or long\n+        const TypeInteger* t0 = told->is_integer(tnew->basic_type());\n+        const TypeInteger* t1 = tnew->is_integer(tnew->basic_type());\n+        if (t0->lo_as_long() == t1->lo_as_long() &&\n+            t0->hi_as_long() == t1->hi_as_long()) {\n+          continue; \/\/ ignore integer widen\n+        }\n+      }\n+      if (n->is_Load()) {\n+        \/\/ MemNode::can_see_stored_value looks up through many memory nodes,\n+        \/\/ which means we would need to notify modifications from far up in\n+        \/\/ the inputs all the way down to the LoadNode. We don't do that.\n+        continue;\n+      }\n+      tty->cr();\n+      tty->print_cr(\"Missed optimization (PhaseCCP):\");\n+      n->dump_bfs(1, 0, \"\");\n+      tty->print_cr(\"Current type:\");\n+      told->dump_on(tty);\n+      tty->cr();\n+      tty->print_cr(\"Optimized type:\");\n+      tnew->dump_on(tty);\n+      tty->cr();\n+      failure = true;\n+    }\n+  }\n+  \/\/ If we get this assert, check why the reported nodes were not processed again in CCP.\n+  \/\/ We should either make sure that these nodes are properly added back to the CCP worklist\n+  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type or add an exception\n+  \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+  assert(!failure, \"Missed optimization opportunity in PhaseCCP\");\n@@ -1843,0 +1902,1 @@\n+#endif\n@@ -1893,0 +1953,1 @@\n+  push_opaque_zero_trip_guard(worklist, use);\n@@ -2025,0 +2086,6 @@\n+void PhaseCCP::push_opaque_zero_trip_guard(Unique_Node_List& worklist, const Node* use) const {\n+  if (use->Opcode() == Op_OpaqueZeroTripGuard) {\n+    push_if_not_bottom_type(worklist, use->unique_out());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -602,0 +602,1 @@\n+  void push_opaque_zero_trip_guard(Unique_Node_List& worklist, const Node* use) const;\n@@ -609,0 +610,4 @@\n+#ifdef ASSERT\n+  \/\/ For every node n on verify list, check if type(n) == n->Value()\n+  void verify_analyze(Unique_Node_List& worklist_verify);\n+#endif\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+#include \"opto\/addnode.hpp\"\n+#include \"opto\/node.hpp\"\n@@ -73,1 +75,1 @@\n-  if( get_ctrl(n) != blk1 && get_ctrl(n) != blk2 )\n+  if (!at_relevant_ctrl(n, blk1, blk2))\n@@ -87,0 +89,4 @@\n+  if (clone_cmp_loadklass_down(n, blk1, blk2)) {\n+    return true;\n+  }\n+\n@@ -89,0 +95,217 @@\n+  if (clone_cmp_down(n, blk1, blk2)) {\n+    return true;\n+  }\n+\n+  if (subgraph_has_opaque(n)) {\n+    Unique_Node_List wq;\n+    wq.push(n);\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* m = wq.at(i);\n+      if (m->is_If()) {\n+        assert(skeleton_predicate_has_opaque(m->as_If()), \"opaque node not reachable from if?\");\n+        Node* bol = clone_skeleton_predicate_bool(m, NULL, NULL, m->in(0));\n+        _igvn.replace_input_of(m, 1, bol);\n+      } else {\n+        assert(!m->is_CFG(), \"not CFG expected\");\n+        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n+          Node* u = m->fast_out(j);\n+          wq.push(u);\n+        }\n+      }\n+    }\n+  }\n+\n+  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n+    \/\/ If this Opaque1 is part of the zero trip guard for a loop:\n+    \/\/ 1- it can't be shared\n+    \/\/ 2- the zero trip guard can't be the if that's being split\n+    \/\/ As a consequence, this node could be assigned control anywhere between its current control and the zero trip guard.\n+    \/\/ Move it down to get it out of the way of split if and avoid breaking the zero trip guard shape.\n+    Node* cmp = n->unique_out();\n+    assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n+    Node* bol = cmp->unique_out();\n+    assert(bol->Opcode() == Op_Bool, \"bad zero trip guard shape\");\n+    Node* iff = bol->unique_out();\n+    assert(iff->Opcode() == Op_If, \"bad zero trip guard shape\");\n+    set_ctrl(n, iff->in(0));\n+    set_ctrl(cmp, iff->in(0));\n+    set_ctrl(bol, iff->in(0));\n+    return true;\n+  }\n+\n+  \/\/ See if splitting-up a Store.  Any anti-dep loads must go up as\n+  \/\/ well.  An anti-dep load might be in the wrong block, because in\n+  \/\/ this particular layout\/schedule we ignored anti-deps and allow\n+  \/\/ memory to be alive twice.  This only works if we do the same\n+  \/\/ operations on anti-dep loads as we do their killing stores.\n+  if( n->is_Store() && n->in(MemNode::Memory)->in(0) == n->in(0) ) {\n+    \/\/ Get store's memory slice\n+    int alias_idx = C->get_alias_index(_igvn.type(n->in(MemNode::Address))->is_ptr());\n+\n+    \/\/ Get memory-phi anti-dep loads will be using\n+    Node *memphi = n->in(MemNode::Memory);\n+    assert( memphi->is_Phi(), \"\" );\n+    \/\/ Hoist any anti-dep load to the splitting block;\n+    \/\/ it will then \"split-up\".\n+    for (DUIterator_Fast imax,i = memphi->fast_outs(imax); i < imax; i++) {\n+      Node *load = memphi->fast_out(i);\n+      if( load->is_Load() && alias_idx == C->get_alias_index(_igvn.type(load->in(MemNode::Address))->is_ptr()) )\n+        set_ctrl(load,blk1);\n+    }\n+  }\n+\n+  \/\/ Found some other Node; must clone it up\n+#ifndef PRODUCT\n+  if( PrintOpto && VerifyLoopOptimizations ) {\n+    tty->print(\"Cloning up: \");\n+    n->dump();\n+  }\n+#endif\n+\n+  \/\/ ConvI2L may have type information on it which becomes invalid if\n+  \/\/ it moves up in the graph so change any clones so widen the type\n+  \/\/ to TypeLong::INT when pushing it up.\n+  const Type* rtype = NULL;\n+  if (n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::INT) {\n+    rtype = TypeLong::INT;\n+  }\n+\n+  \/\/ Now actually split-up this guy.  One copy per control path merging.\n+  Node *phi = PhiNode::make_blank(blk1, n);\n+  for( uint j = 1; j < blk1->req(); j++ ) {\n+    Node *x = n->clone();\n+    \/\/ Widen the type of the ConvI2L when pushing up.\n+    if (rtype != NULL) x->as_Type()->set_type(rtype);\n+    if( n->in(0) && n->in(0) == blk1 )\n+      x->set_req( 0, blk1->in(j) );\n+    for( uint i = 1; i < n->req(); i++ ) {\n+      Node *m = n->in(i);\n+      if( get_ctrl(m) == blk1 ) {\n+        assert( m->in(0) == blk1, \"\" );\n+        x->set_req( i, m->in(j) );\n+      }\n+    }\n+    register_new_node( x, blk1->in(j) );\n+    phi->init_req( j, x );\n+  }\n+  \/\/ Announce phi to optimizer\n+  register_new_node(phi, blk1);\n+\n+  \/\/ Remove cloned-up value from optimizer; use phi instead\n+  _igvn.replace_node( n, phi );\n+\n+  \/\/ (There used to be a self-recursive call to split_up() here,\n+  \/\/ but it is not needed.  All necessary forward walking is done\n+  \/\/ by do_split_if() below.)\n+\n+  return true;\n+}\n+\n+\/\/ Look for a (If .. (Bool(CmpP (LoadKlass .. (AddP obj ..)) ..))) and clone all of it down.\n+\/\/ There's likely a CheckCastPP on one of the branches of the If, with obj as input.\n+\/\/ If the (LoadKlass .. (AddP obj ..)) is not cloned down, then split if transforms this to: (If .. (Bool(CmpP phi1 ..)))\n+\/\/ and the CheckCastPP to (CheckCastPP phi2). It's possible then that phi2 is transformed to a CheckCastPP\n+\/\/ (through PhiNode::Ideal) and that that CheckCastPP is replaced by another narrower CheckCastPP at the same control\n+\/\/ (through ConstraintCastNode::Identity). That could cause the CheckCastPP at the If to become top while (CmpP phi1)\n+\/\/ wouldn't constant fold because it's using a different data path. Cloning the whole subgraph down guarantees both the\n+\/\/ AddP and CheckCastPP have the same obj input after split if.\n+bool PhaseIdealLoop::clone_cmp_loadklass_down(Node* n, const Node* blk1, const Node* blk2) {\n+  if (n->Opcode() == Op_AddP && at_relevant_ctrl(n, blk1, blk2)) {\n+    Node_List cmp_nodes;\n+    uint old = C->unique();\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* u1 = n->fast_out(i);\n+      if (u1->Opcode() == Op_LoadNKlass && at_relevant_ctrl(u1, blk1, blk2)) {\n+        for (DUIterator_Fast jmax, j = u1->fast_outs(jmax); j < jmax; j++) {\n+          Node* u2 = u1->fast_out(j);\n+          if (u2->Opcode() == Op_DecodeNKlass && at_relevant_ctrl(u2, blk1, blk2)) {\n+            for (DUIterator k = u2->outs(); u2->has_out(k); k++) {\n+              Node* u3 = u2->out(k);\n+              if (at_relevant_ctrl(u3, blk1, blk2) && clone_cmp_down(u3, blk1, blk2)) {\n+                --k;\n+              }\n+            }\n+            for (DUIterator_Fast kmax, k = u2->fast_outs(kmax); k < kmax; k++) {\n+              Node* u3 = u2->fast_out(k);\n+              if (u3->_idx >= old) {\n+                cmp_nodes.push(u3);\n+              }\n+            }\n+          }\n+        }\n+      } else if (u1->Opcode() == Op_LoadKlass && at_relevant_ctrl(u1, blk1, blk2)) {\n+        for (DUIterator j = u1->outs(); u1->has_out(j); j++) {\n+          Node* u2 = u1->out(j);\n+          if (at_relevant_ctrl(u2, blk1, blk2) && clone_cmp_down(u2, blk1, blk2)) {\n+            --j;\n+          }\n+        }\n+        for (DUIterator_Fast kmax, k = u1->fast_outs(kmax); k < kmax; k++) {\n+          Node* u2 = u1->fast_out(k);\n+          if (u2->_idx >= old) {\n+            cmp_nodes.push(u2);\n+          }\n+        }\n+      }\n+    }\n+\n+    for (uint i = 0; i < cmp_nodes.size(); ++i) {\n+      Node* cmp = cmp_nodes.at(i);\n+      clone_loadklass_nodes_at_cmp_index(n, cmp, 1);\n+      clone_loadklass_nodes_at_cmp_index(n, cmp, 2);\n+    }\n+    if (n->outcnt() == 0) {\n+      assert(n->is_dead(), \"\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool PhaseIdealLoop::at_relevant_ctrl(Node* n, const Node* blk1, const Node* blk2) {\n+  return ctrl_or_self(n) == blk1 || ctrl_or_self(n) == blk2;\n+}\n+\n+void PhaseIdealLoop::clone_loadklass_nodes_at_cmp_index(const Node* n, Node* cmp, int i) {\n+  Node* decode = cmp->in(i);\n+  if (decode->Opcode() == Op_DecodeNKlass) {\n+    Node* loadklass = decode->in(1);\n+    if (loadklass->Opcode() == Op_LoadNKlass) {\n+      Node* addp = loadklass->in(MemNode::Address);\n+      if (addp == n) {\n+        Node* ctrl = get_ctrl(cmp);\n+        Node* decode_clone = decode->clone();\n+        Node* loadklass_clone = loadklass->clone();\n+        Node* addp_clone = addp->clone();\n+        register_new_node(decode_clone, ctrl);\n+        register_new_node(loadklass_clone, ctrl);\n+        register_new_node(addp_clone, ctrl);\n+        _igvn.replace_input_of(cmp, i, decode_clone);\n+        _igvn.replace_input_of(decode_clone, 1, loadklass_clone);\n+        _igvn.replace_input_of(loadklass_clone, MemNode::Address, addp_clone);\n+        if (decode->outcnt() == 0) {\n+          _igvn.remove_dead_node(decode);\n+        }\n+      }\n+    }\n+  } else {\n+    Node* loadklass = cmp->in(i);\n+    if (loadklass->Opcode() == Op_LoadKlass) {\n+      Node* addp = loadklass->in(MemNode::Address);\n+      if (addp == n) {\n+        Node* ctrl = get_ctrl(cmp);\n+        Node* loadklass_clone = loadklass->clone();\n+        Node* addp_clone = addp->clone();\n+        register_new_node(loadklass_clone, ctrl);\n+        register_new_node(addp_clone, ctrl);\n+        _igvn.replace_input_of(cmp, i, loadklass_clone);\n+        _igvn.replace_input_of(loadklass_clone, MemNode::Address, addp_clone);\n+        if (loadklass->outcnt() == 0) {\n+          _igvn.remove_dead_node(loadklass);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+bool PhaseIdealLoop::clone_cmp_down(Node* n, const Node* blk1, const Node* blk2) {\n@@ -98,1 +321,1 @@\n-    if( !(n->outcnt() == 1 && n->unique_out()->is_Bool() &&\n+    if (!(n->outcnt() == 1 && n->unique_out()->is_Bool() &&\n@@ -100,7 +323,5 @@\n-          (get_ctrl(bol) == blk1 ||\n-           get_ctrl(bol) == blk2) &&\n-          bol->outcnt() == 1 &&\n-          bol->unique_out()->is_CMove() &&\n-          (cmov = bol->unique_out()->as_CMove()) &&\n-          (get_ctrl(cmov) == blk1 ||\n-           get_ctrl(cmov) == blk2) ) ) {\n+          (at_relevant_ctrl(bol, blk1, blk2) &&\n+           bol->outcnt() == 1 &&\n+           bol->unique_out()->is_CMove() &&\n+           (cmov = bol->unique_out()->as_CMove()) &&\n+           at_relevant_ctrl(cmov, blk1, blk2)))) {\n@@ -141,1 +362,1 @@\n-          if (get_ctrl(bol) == blk1 || get_ctrl(bol) == blk2) {\n+          if (at_relevant_ctrl(bol, blk1, blk2)) {\n@@ -201,1 +422,1 @@\n-      _igvn.remove_dead_node( n );\n+      _igvn.remove_dead_node(n);\n@@ -206,103 +427,1 @@\n-  if (subgraph_has_opaque(n)) {\n-    Unique_Node_List wq;\n-    wq.push(n);\n-    for (uint i = 0; i < wq.size(); i++) {\n-      Node* m = wq.at(i);\n-      if (m->is_If()) {\n-        assert(skeleton_predicate_has_opaque(m->as_If()), \"opaque node not reachable from if?\");\n-        Node* bol = clone_skeleton_predicate_bool(m, NULL, NULL, m->in(0));\n-        _igvn.replace_input_of(m, 1, bol);\n-      } else {\n-        assert(!m->is_CFG(), \"not CFG expected\");\n-        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n-          Node* u = m->fast_out(j);\n-          wq.push(u);\n-        }\n-      }\n-    }\n-  }\n-\n-  if (n->Opcode() == Op_OpaqueZeroTripGuard) {\n-    \/\/ If this Opaque1 is part of the zero trip guard for a loop:\n-    \/\/ 1- it can't be shared\n-    \/\/ 2- the zero trip guard can't be the if that's being split\n-    \/\/ As a consequence, this node could be assigned control anywhere between its current control and the zero trip guard.\n-    \/\/ Move it down to get it out of the way of split if and avoid breaking the zero trip guard shape.\n-    Node* cmp = n->unique_out();\n-    assert(cmp->Opcode() == Op_CmpI, \"bad zero trip guard shape\");\n-    Node* bol = cmp->unique_out();\n-    assert(bol->Opcode() == Op_Bool, \"bad zero trip guard shape\");\n-    Node* iff = bol->unique_out();\n-    assert(iff->Opcode() == Op_If, \"bad zero trip guard shape\");\n-    set_ctrl(n, iff->in(0));\n-    set_ctrl(cmp, iff->in(0));\n-    set_ctrl(bol, iff->in(0));\n-    return true;\n-  }\n-\n-  \/\/ See if splitting-up a Store.  Any anti-dep loads must go up as\n-  \/\/ well.  An anti-dep load might be in the wrong block, because in\n-  \/\/ this particular layout\/schedule we ignored anti-deps and allow\n-  \/\/ memory to be alive twice.  This only works if we do the same\n-  \/\/ operations on anti-dep loads as we do their killing stores.\n-  if( n->is_Store() && n->in(MemNode::Memory)->in(0) == n->in(0) ) {\n-    \/\/ Get store's memory slice\n-    int alias_idx = C->get_alias_index(_igvn.type(n->in(MemNode::Address))->is_ptr());\n-\n-    \/\/ Get memory-phi anti-dep loads will be using\n-    Node *memphi = n->in(MemNode::Memory);\n-    assert( memphi->is_Phi(), \"\" );\n-    \/\/ Hoist any anti-dep load to the splitting block;\n-    \/\/ it will then \"split-up\".\n-    for (DUIterator_Fast imax,i = memphi->fast_outs(imax); i < imax; i++) {\n-      Node *load = memphi->fast_out(i);\n-      if( load->is_Load() && alias_idx == C->get_alias_index(_igvn.type(load->in(MemNode::Address))->is_ptr()) )\n-        set_ctrl(load,blk1);\n-    }\n-  }\n-\n-  \/\/ Found some other Node; must clone it up\n-#ifndef PRODUCT\n-  if( PrintOpto && VerifyLoopOptimizations ) {\n-    tty->print(\"Cloning up: \");\n-    n->dump();\n-  }\n-#endif\n-\n-  \/\/ ConvI2L may have type information on it which becomes invalid if\n-  \/\/ it moves up in the graph so change any clones so widen the type\n-  \/\/ to TypeLong::INT when pushing it up.\n-  const Type* rtype = NULL;\n-  if (n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::INT) {\n-    rtype = TypeLong::INT;\n-  }\n-\n-  \/\/ Now actually split-up this guy.  One copy per control path merging.\n-  Node *phi = PhiNode::make_blank(blk1, n);\n-  for( uint j = 1; j < blk1->req(); j++ ) {\n-    Node *x = n->clone();\n-    \/\/ Widen the type of the ConvI2L when pushing up.\n-    if (rtype != NULL) x->as_Type()->set_type(rtype);\n-    if( n->in(0) && n->in(0) == blk1 )\n-      x->set_req( 0, blk1->in(j) );\n-    for( uint i = 1; i < n->req(); i++ ) {\n-      Node *m = n->in(i);\n-      if( get_ctrl(m) == blk1 ) {\n-        assert( m->in(0) == blk1, \"\" );\n-        x->set_req( i, m->in(j) );\n-      }\n-    }\n-    register_new_node( x, blk1->in(j) );\n-    phi->init_req( j, x );\n-  }\n-  \/\/ Announce phi to optimizer\n-  register_new_node(phi, blk1);\n-\n-  \/\/ Remove cloned-up value from optimizer; use phi instead\n-  _igvn.replace_node( n, phi );\n-\n-  \/\/ (There used to be a self-recursive call to split_up() here,\n-  \/\/ but it is not needed.  All necessary forward walking is done\n-  \/\/ by do_split_if() below.)\n-\n-  return true;\n+  return false;\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":234,"deletions":115,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -665,0 +666,41 @@\n+const Type* CmpINode::Value(PhaseGVN* phase) const {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  \/\/ If this test is the zero trip guard for a main or post loop, check whether, with the opaque node removed, the test\n+  \/\/ would constant fold so the loop is never entered. If so return the type of the test without the opaque node removed:\n+  \/\/ make the loop unreachable.\n+  \/\/ The reason for this is that the iv phi captures the bounds of the loop and if the loop becomes unreachable, it can\n+  \/\/ become top. In that case, the loop must be removed.\n+  \/\/ This is safe because:\n+  \/\/ - as optimizations proceed, the range of iterations executed by the main loop narrows. If no iterations remain, then\n+  \/\/ we're done with optimizations for that loop.\n+  \/\/ - the post loop is initially not reachable but as long as there's a main loop, the zero trip guard for the post\n+  \/\/ loop takes a phi that merges the pre and main loop's iv and can't constant fold the zero trip guard. Once, the main\n+  \/\/ loop is removed, there's no need to preserve the zero trip guard for the post loop anymore.\n+  if (in1 != NULL && in2 != NULL) {\n+    uint input = 0;\n+    Node* cmp = NULL;\n+    BoolTest::mask test;\n+    if (in1->Opcode() == Op_OpaqueZeroTripGuard && phase->type(in1) != Type::TOP) {\n+      cmp = new CmpINode(in1->in(1), in2);\n+      test = ((OpaqueZeroTripGuardNode*)in1)->_loop_entered_mask;\n+    }\n+    if (in2->Opcode() == Op_OpaqueZeroTripGuard && phase->type(in2) != Type::TOP) {\n+      assert(cmp == NULL, \"A cmp with 2 OpaqueZeroTripGuard inputs\");\n+      cmp = new CmpINode(in1, in2->in(1));\n+      test = ((OpaqueZeroTripGuardNode*)in2)->_loop_entered_mask;\n+    }\n+    if (cmp != NULL) {\n+      const Type* cmp_t = cmp->Value(phase);\n+      const Type* t = BoolTest(test).cc2logical(cmp_t);\n+      cmp->destruct(phase);\n+      if (t == TypeInt::ZERO) {\n+        return cmp_t;\n+      }\n+    }\n+  }\n+\n+  return SubNode::Value(phase);\n+}\n+\n+\n@@ -1089,1 +1131,1 @@\n-  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass()));\n+  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(), Type::trust_interfaces));\n@@ -1530,1 +1572,4 @@\n-  if( cop == Op_FastLock || cop == Op_FastUnlock || cmp->is_SubTypeCheck()) return NULL;\n+  if( cop == Op_FastLock || cop == Op_FastUnlock ||\n+      cmp->is_SubTypeCheck() || cop == Op_VectorTest ) {\n+    return NULL;\n+  }\n@@ -1562,0 +1607,15 @@\n+  \/\/ Change \"bool eq\/ne (cmp (cmove (bool tst (cmp2)) 1 0) 0)\" into \"bool tst\/~tst (cmp2)\"\n+  if (cop == Op_CmpI &&\n+      (_test._test == BoolTest::eq || _test._test == BoolTest::ne) &&\n+      cmp1_op == Op_CMoveI && cmp2->find_int_con(1) == 0) {\n+    \/\/ 0 should be on the true branch\n+    if (cmp1->in(CMoveNode::Condition)->is_Bool() &&\n+        cmp1->in(CMoveNode::IfTrue)->find_int_con(1) == 0 &&\n+        cmp1->in(CMoveNode::IfFalse)->find_int_con(0) != 0) {\n+      BoolNode* target = cmp1->in(CMoveNode::Condition)->as_Bool();\n+      return new BoolNode(target->in(1),\n+                          (_test._test == BoolTest::eq) ? target->_test._test :\n+                                                          target->_test.negate());\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":62,"deletions":2,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  \/\/ FIXME: shouldn't this be encoded in helper methods of the type system (maybe_java_subtype_of() etc.?)\n@@ -70,1 +71,1 @@\n-    switch (Compile::current()->static_subtype_check(superk, subk)) {\n+    switch (Compile::current()->static_subtype_check(superk, subk, false)) {\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -173,0 +173,2 @@\n+const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = NULL;\n+const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = NULL;\n@@ -187,1 +189,1 @@\n-const Type* Type::get_const_type(ciType* type) {\n+const Type* Type::get_const_type(ciType* type, InterfaceHandling interface_handling) {\n@@ -193,1 +195,1 @@\n-    return TypeOopPtr::make_from_klass(type->as_klass());\n+    return TypeOopPtr::make_from_klass(type->as_klass(), interface_handling);\n@@ -629,0 +631,6 @@\n+  GrowableArray<ciInstanceKlass*> array_interfaces;\n+  array_interfaces.push(current->env()->Cloneable_klass());\n+  array_interfaces.push(current->env()->Serializable_klass());\n+  TypeAryPtr::_array_interfaces = new TypePtr::InterfaceSet(&array_interfaces);\n+  TypeAryKlassPtr::_array_interfaces = TypeAryPtr::_array_interfaces;\n+\n@@ -666,2 +674,2 @@\n-  TypeInstKlassPtr::OBJECT = TypeInstKlassPtr::make(TypePtr::NotNull, current->env()->Object_klass(), Offset(0), false);\n-  TypeInstKlassPtr::OBJECT_OR_NULL = TypeInstKlassPtr::make(TypePtr::BotPTR, current->env()->Object_klass(), Offset(0), false);\n+  TypeInstKlassPtr::OBJECT = TypeInstKlassPtr::make(TypePtr::NotNull, current->env()->Object_klass(), Offset(0));\n+  TypeInstKlassPtr::OBJECT_OR_NULL = TypeInstKlassPtr::make(TypePtr::BotPTR, current->env()->Object_klass(), Offset(0));\n@@ -845,45 +853,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool Type::interface_vs_oop_helper(const Type *t) const {\n-  bool result = false;\n-\n-  const TypePtr* this_ptr = this->make_ptr(); \/\/ In case it is narrow_oop\n-  const TypePtr*    t_ptr =    t->make_ptr();\n-  if( this_ptr == NULL || t_ptr == NULL )\n-    return result;\n-\n-  const TypeInstPtr* this_inst = this_ptr->isa_instptr();\n-  const TypeInstPtr*    t_inst =    t_ptr->isa_instptr();\n-  if( this_inst && this_inst->is_loaded() && t_inst && t_inst->is_loaded() ) {\n-    bool this_interface = this_inst->is_interface();\n-    bool    t_interface =    t_inst->is_interface();\n-    result = this_interface ^ t_interface;\n-  }\n-\n-  return result;\n-}\n-\n-bool Type::interface_vs_oop(const Type *t) const {\n-  if (interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  \/\/ Now check the speculative parts as well\n-  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n-  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n-  if (this_spec != NULL && t_spec != NULL) {\n-    if (this_spec->interface_vs_oop_helper(t_spec)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-#endif\n-\n@@ -909,1 +872,1 @@\n-  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n+  if (t2t != t->_dual || t2this != this->_dual) {\n@@ -2104,1 +2067,1 @@\n-const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {\n+const TypeTuple *TypeTuple::make_range(ciSignature* sig, InterfaceHandling interface_handling, bool ret_vt_fields) {\n@@ -2133,1 +2096,1 @@\n-    field_array[TypeFunc::Parms] = get_const_type(return_type);\n+    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n@@ -2157,1 +2120,1 @@\n-const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {\n+const TypeTuple *TypeTuple::make_domain(ciMethod* method, InterfaceHandling interface_handling, bool vt_fields_as_args) {\n@@ -2175,1 +2138,1 @@\n-      field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n+      field_array[pos++] = get_const_type(recv, interface_handling)->join_speculative(TypePtr::NOTNULL);\n@@ -2197,1 +2160,1 @@\n-      field_array[pos++] = get_const_type(type);\n+      field_array[pos++] = get_const_type(type, interface_handling);\n@@ -2447,15 +2410,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAry::interface_vs_oop(const Type *t) const {\n-  const TypeAry* t_ary = t->is_ary();\n-  if (t_ary) {\n-    const TypePtr* this_ptr = _elem->make_ptr(); \/\/ In case we have narrow_oops\n-    const TypePtr*    t_ptr = t_ary->_elem->make_ptr();\n-    if(this_ptr != NULL && t_ptr != NULL) {\n-      return this_ptr->interface_vs_oop(t_ptr);\n-    }\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -2503,3 +2451,1 @@\n-  ciKlass* tklass = toop->klass();\n-  if (tklass == NULL)       return false;  \/\/ unloaded class\n-  if (!tklass->is_loaded()) return false;  \/\/ unloaded class\n+  if (!toop->is_loaded())   return false;  \/\/ unloaded class\n@@ -2512,1 +2458,1 @@\n-    if (tklass->as_instance_klass()->is_final()) {\n+    if (tinst->instance_klass()->is_final()) {\n@@ -2537,1 +2483,5 @@\n-  return (TypeInlineType*)(new TypeInlineType(vk, larval))->hashcons();\n+  TypePtr::InterfaceSet interfaces;\n+  if (vk != NULL) {\n+    interfaces = TypePtr::InterfaceSet(vk->transitive_interfaces());\n+  }\n+  return (TypeInlineType*)(new TypeInlineType(vk, interfaces, larval))->hashcons();\n@@ -3127,1 +3077,1 @@\n-      return speculative->klass();\n+      return speculative->exact_klass();\n@@ -3420,0 +3370,229 @@\n+TypePtr::InterfaceSet::InterfaceSet()\n+        : _list(Compile::current()->type_arena(), 0, 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+}\n+\n+TypePtr::InterfaceSet::InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces)\n+        : _list(Compile::current()->type_arena(), interfaces->length(), 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    add(interfaces->at(i));\n+  }\n+}\n+\n+\n+int TypePtr::InterfaceSet::compare(ciKlass* const& k1, ciKlass* const& k2) {\n+  if ((intptr_t)k1 < (intptr_t)k2) {\n+    return -1;\n+  } else if ((intptr_t)k1 > (intptr_t)k2) {\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+void TypePtr::InterfaceSet::add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.insert_sorted<compare>(interface);\n+  verify();\n+}\n+\n+void TypePtr::InterfaceSet::raw_add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.push(interface);\n+}\n+\n+bool TypePtr::InterfaceSet::eq(const InterfaceSet& other) const {\n+  if (_list.length() != other._list.length()) {\n+    return false;\n+  }\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i);\n+    ciKlass* k2 = other._list.at(i);\n+    if (!k1->equals(k2)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+int TypePtr::InterfaceSet::hash() const {\n+  if (_hash_computed) {\n+    return _hash;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_hash();\n+  assert(_hash_computed, \"should be computed now\");\n+  return _hash;\n+}\n+\n+void TypePtr::InterfaceSet::compute_hash() {\n+  int hash = 0;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k = _list.at(i);\n+    hash += (jint)k->hash();\n+  }\n+  _hash_computed = 1;\n+  _hash = hash;\n+}\n+\n+static int compare_interfaces(ciKlass** k1, ciKlass** k2) {\n+  return (int)((*k1)->ident() - (*k2)->ident());\n+}\n+\n+void TypePtr::InterfaceSet::dump(outputStream *st) const {\n+  if (_list.length() == 0) {\n+    return;\n+  }\n+  ResourceMark rm;\n+  st->print(\" (\");\n+  GrowableArray<ciKlass*> interfaces;\n+  interfaces.appendAll(&_list);\n+  \/\/ Sort the interfaces so they are listed in the same order from one run to the other of the same compilation\n+  interfaces.sort(compare_interfaces);\n+  for (int i = 0; i < interfaces.length(); i++) {\n+    if (i > 0) {\n+      st->print(\",\");\n+    }\n+    ciKlass* k = interfaces.at(i);\n+    k->print_name_on(st);\n+  }\n+  st->print(\")\");\n+}\n+\n+void TypePtr::InterfaceSet::verify() const {\n+#ifdef DEBUG\n+  for (int i = 1; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i-1);\n+    ciKlass* k2 = _list.at(i);\n+    assert(compare(k2, k1) > 0, \"should be ordered\");\n+    assert(k1 != k2, \"no duplicate\");\n+  }\n+#endif\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::union_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      result.raw_add(other._list.at(j));\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) || other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::intersection_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(!other._list.contains(_list.at(i)) || result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(!_list.contains(other._list.at(i)) || result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) && other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+\/\/ Is there a single ciKlass* that can represent the interface set?\n+ciKlass* TypePtr::InterfaceSet::exact_klass() const {\n+  if (_exact_klass_computed) {\n+    return _exact_klass;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_exact_klass();\n+  assert(_exact_klass_computed, \"should be computed now\");\n+  return _exact_klass;\n+}\n+\n+void TypePtr::InterfaceSet::compute_exact_klass() {\n+  if (_list.length() == 0) {\n+    _exact_klass_computed = 1;\n+    _exact_klass = NULL;\n+    return;\n+  }\n+  ciKlass* res = NULL;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (eq(interfaces(interface, false, true, false, trust_interfaces))) {\n+      assert(res == NULL, \"\");\n+      res = _list.at(i);\n+    }\n+  }\n+  _exact_klass_computed = 1;\n+  _exact_klass = res;\n+}\n+\n+bool TypePtr::InterfaceSet::is_loaded() const {\n+  if (_is_loaded_computed) {\n+    return _is_loaded;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_is_loaded();\n+  assert(_is_loaded_computed, \"should be computed now\");\n+  return _is_loaded;\n+}\n+\n+void TypePtr::InterfaceSet::compute_is_loaded() {\n+  _is_loaded_computed = 1;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (!interface->is_loaded()) {\n+      _is_loaded = false;\n+      return;\n+    }\n+  }\n+  _is_loaded = true;\n+}\n+\n@@ -3421,1 +3600,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, Offset offset, Offset field_offset,\n@@ -3425,0 +3604,1 @@\n+    _interfaces(interfaces),\n@@ -3452,1 +3632,1 @@\n-        _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(bt);\n+        _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(bt);\n@@ -3482,1 +3662,1 @@\n-                _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+                _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3495,1 +3675,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3518,1 +3698,1 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))->hashcons();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, InterfaceSet(), xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))->hashcons();\n@@ -3630,1 +3810,1 @@\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -3635,1 +3815,1 @@\n-const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {\n+const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling) {\n@@ -3662,1 +3842,2 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0));\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, NULL, Offset(0));\n@@ -3665,1 +3846,1 @@\n-    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ false, try_for_exact);\n+    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ false, try_for_exact, interface_handling);\n@@ -3674,1 +3855,1 @@\n-      exact_etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ true, \/* try_for_exact= *\/ true);\n+      exact_etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ true, \/* try_for_exact= *\/ true, interface_handling);\n@@ -3685,1 +3866,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, NULL, xk, Offset(0));\n@@ -3724,1 +3905,1 @@\n-    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass());\n+    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass(), trust_interfaces);\n@@ -3799,21 +3980,0 @@\n-    \/\/ Check for evil case of 'this' being a class and 'kills' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!empty()) {\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to interface\n-      }\n-      \/\/ Also check for evil cases of 'this' being a class array\n-      \/\/ and 'kills' expecting an array of interfaces.\n-      Type::get_arrays_base_elements(ft, kills, NULL, &ktip);\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to array of interface\n-      }\n-    }\n-\n@@ -3823,12 +3983,0 @@\n-  \/\/ If we have an interface-typed Phi or cast and we narrow to a class type,\n-  \/\/ the join should report back the class.  However, if we have a J\/L\/Object\n-  \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-  \/\/ join report an interface back out.  This isn't possible but happens\n-  \/\/ because the type system doesn't interact well with interfaces.\n-  if (ftip != NULL && ktip != NULL &&\n-      ftip->is_loaded() &&  ftip->klass()->is_interface() &&\n-      ktip->is_loaded() && !ktip->klass()->is_interface()) {\n-    assert(!ftip->klass_is_exact(), \"interface could not be exact\");\n-    return ktip->cast_to_ptr_type(ftip->ptr());\n-  }\n-\n@@ -3888,1 +4036,1 @@\n-const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeOopPtr::add_offset(intptr_t offset) const {\n@@ -3955,0 +4103,12 @@\n+\n+TypePtr::InterfaceSet TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -3979,0 +4139,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -3980,1 +4141,12 @@\n-  return _klass;\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    if (_interfaces.eq(interfaces)) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -3984,1 +4156,1 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, Offset off,\n@@ -3986,1 +4158,1 @@\n-  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),\n+  : TypeOopPtr(InstPtr, ptr, k, interfaces, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),\n@@ -3988,5 +4160,6 @@\n-   assert(k != NULL &&\n-          (k->is_loaded() || o == NULL),\n-          \"cannot have constants with non-loaded klass\");\n-   assert(!klass()->flatten_array() || flatten_array, \"Should be flat in array\");\n-   assert(!flatten_array || can_be_inline_type(), \"Only inline types can be flat in array\");\n+  assert(k == NULL || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n+  assert(k != NULL &&\n+         (k->is_loaded() || o == NULL),\n+         \"cannot have constants with non-loaded klass\");\n+  assert(!klass()->flatten_array() || flatten_array, \"Should be flat in array\");\n+  assert(!flatten_array || can_be_inline_type(), \"Only inline types can be flat in array\");\n@@ -3998,0 +4171,1 @@\n+                                     const InterfaceSet& interfaces,\n@@ -4019,0 +4193,1 @@\n+    assert(!ik->is_interface(), \"no interface here\");\n@@ -4027,1 +4202,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o, offset, flatten_array, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o, offset, flatten_array, instance_id, speculative, inline_depth))->hashcons();\n@@ -4032,0 +4207,33 @@\n+TypePtr::InterfaceSet TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n+  if (k->is_instance_klass()) {\n+    if (k->is_loaded()) {\n+      if (k->is_interface() && interface_handling == ignore_interfaces) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+        InterfaceSet interfaces;\n+        return interfaces;\n+      }\n+      GrowableArray<ciInstanceKlass *> *k_interfaces = k->as_instance_klass()->transitive_interfaces();\n+      InterfaceSet interfaces(k_interfaces);\n+      if (k->is_interface()) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+      } else {\n+        assert(klass, \"no instance klass expected\");\n+      }\n+      return interfaces;\n+    }\n+    InterfaceSet interfaces;\n+    return interfaces;\n+  }\n+  assert(array, \"no array expected\");\n+  assert(k->is_array_klass(), \"Not an array?\");\n+  ciType* e = k->as_array_klass()->base_element_type();\n+  if (e->is_loaded() && e->is_instance_klass() && e->as_instance_klass()->is_interface()) {\n+    if (interface_handling == ignore_interfaces) {\n+      k = ciObjArrayKlass::make(ciEnv::current()->Object_klass(), k->as_array_klass()->dimension());\n+    }\n+  }\n+  return *TypeAryPtr::_array_interfaces;\n+}\n+\n@@ -4060,1 +4268,1 @@\n-  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n@@ -4070,2 +4278,2 @@\n-  if( ik->is_interface() )              return this;  \/\/ cannot set xk\n-  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n+  assert(!ik->is_interface(), \"no interface here\");\n+  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n@@ -4077,1 +4285,1 @@\n-  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flatten_array, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, _klass_is_exact, const_oop(), _offset, _flatten_array, instance_id, _speculative, _inline_depth);\n@@ -4083,35 +4291,31 @@\n-const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {\n-    Offset off = meet_offset(tinst->offset());\n-    PTR ptr = meet_ptr(tinst->ptr());\n-    int instance_id = meet_instance_id(tinst->instance_id());\n-    const TypePtr* speculative = xmeet_speculative(tinst);\n-    int depth = meet_inline_depth(tinst->inline_depth());\n-\n-    const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n-    const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n-    if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n-      \/\/\n-      \/\/ Meet unloaded class with java\/lang\/Object\n-      \/\/\n-      \/\/ Meet\n-      \/\/          |                     Unloaded Class\n-      \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n-      \/\/  ===================================================================\n-      \/\/   TOP    | ..........................Unloaded......................|\n-      \/\/  AnyNull |  U-AN    |................Unloaded......................|\n-      \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n-      \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n-      \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n-      \/\/\n-      assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n-      \/\/\n-      if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n-      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, false, instance_id, speculative, depth); }\n-      else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n-      else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n-        if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n-        else                                      { return TypeInstPtr::NOTNULL; }\n-      }\n-      else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n-\n-      return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const InterfaceSet& interfaces) const {\n+  Offset off = meet_offset(tinst->offset());\n+  PTR ptr = meet_ptr(tinst->ptr());\n+  int instance_id = meet_instance_id(tinst->instance_id());\n+  const TypePtr* speculative = xmeet_speculative(tinst);\n+  int depth = meet_inline_depth(tinst->inline_depth());\n+\n+  const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n+  const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n+  if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n+    \/\/\n+    \/\/ Meet unloaded class with java\/lang\/Object\n+    \/\/\n+    \/\/ Meet\n+    \/\/          |                     Unloaded Class\n+    \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n+    \/\/  ===================================================================\n+    \/\/   TOP    | ..........................Unloaded......................|\n+    \/\/  AnyNull |  U-AN    |................Unloaded......................|\n+    \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n+    \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n+    \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n+    \/\/\n+    assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n+    \/\/\n+    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded; }\n+    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, false, instance_id, speculative, depth); }\n+    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM; }\n+    else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n+      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM;  }\n+      else                                       { return TypeInstPtr::NOTNULL; }\n@@ -4119,0 +4323,1 @@\n+    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded; }\n@@ -4120,6 +4325,9 @@\n-    \/\/ Both are unloaded, not the same class, not Object\n-    \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n-    if( ptr != TypePtr::BotPTR ) {\n-      return TypeInstPtr::NOTNULL;\n-    }\n-    return TypeInstPtr::BOTTOM;\n+    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+  }\n+\n+  \/\/ Both are unloaded, not the same class, not Object\n+  \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n+  if (ptr != TypePtr::BotPTR) {\n+    return TypeInstPtr::NOTNULL;\n+  }\n+  return TypeInstPtr::BOTTOM;\n@@ -4178,1 +4386,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -4206,1 +4414,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -4240,0 +4448,2 @@\n+    InterfaceSet interfaces = meet_interfaces(tinst);\n+\n@@ -4242,4 +4452,0 @@\n-    bool tinst_xk = tinst->klass_is_exact();\n-    bool this_xk  = this->klass_is_exact();\n-    bool tinst_flatten_array = tinst->flatten_array();\n-    bool this_flatten_array  = this->flatten_array();\n@@ -4251,3 +4457,2 @@\n-    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr,\n-                                   this_flatten_array, tinst_flatten_array,\n-                                   res_klass, res_xk, res_flatten_array);\n+    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk, res_flatten_array);\n+\n@@ -4256,1 +4461,1 @@\n-      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst, interfaces);\n@@ -4293,1 +4498,1 @@\n-      res = make(ptr, res_klass, res_xk, o, off, res_flatten_array, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, interfaces, res_xk, o, off, res_flatten_array, instance_id, speculative, depth);\n@@ -4302,0 +4507,1 @@\n+    InterfaceSet interfaces = tv->interfaces();\n@@ -4303,1 +4509,1 @@\n-      if (tv->inline_klass()->is_subtype_of(_klass)) {\n+      if (tv->inline_klass()->is_subtype_of(_klass) && interfaces.contains(_interfaces)) {\n@@ -4313,2 +4519,2 @@\n-      if (tv->inline_klass()->is_subtype_of(_klass)) {\n-        return make(ptr, _klass, false, NULL, Offset(0), _flatten_array, InstanceBot, _speculative);\n+      if (tv->inline_klass()->is_subtype_of(_klass) && interfaces.contains(_interfaces)) {\n+        return make(ptr, _klass, _interfaces, false, NULL, Offset(0), _flatten_array, InstanceBot, _speculative);\n@@ -4325,4 +4531,6 @@\n-TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n-                                          PTR this_ptr, PTR tinst_ptr, bool this_flatten_array, bool tinst_flatten_array,\n-                                          ciKlass*&res_klass, bool &res_xk, bool& res_flatten_array) {\n-\n+template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n+                                                            ciKlass*& res_klass, bool& res_xk, bool& res_flatten_array) {\n+  ciKlass* this_klass = this_type->klass();\n+  ciKlass* other_klass = other_type->klass();\n+  bool this_flatten_array = this_type->flatten_array();\n+  bool other_flatten_array = other_type->flatten_array();\n@@ -4330,2 +4538,7 @@\n-  bool tinst_flatten_array_orig = tinst_flatten_array;\n-\n+  bool other_flatten_array_orig = other_flatten_array;\n+  bool this_xk = this_type->klass_is_exact();\n+  bool other_xk = other_type->klass_is_exact();\n+  PTR this_ptr = this_type->ptr();\n+  PTR other_ptr = other_type->ptr();\n+  InterfaceSet this_interfaces = this_type->interfaces();\n+  InterfaceSet other_interfaces = other_type->interfaces();\n@@ -4336,1 +4549,1 @@\n-  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk && this_flatten_array == tinst_flatten_array) {\n+  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk && this_flatten_array == other_flatten_array) {\n@@ -4344,1 +4557,1 @@\n-  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n+  if (!other_klass->is_loaded() || !this_klass->is_loaded()) {\n@@ -4348,46 +4561,0 @@\n-  \/\/ Handle mixing oops and interfaces first.\n-  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n-                                      tinst_klass == ciEnv::current()->Object_klass())) {\n-    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n-    tinst_klass = this_klass;\n-    this_klass = tmp;\n-    bool tmp2 = tinst_xk;\n-    tinst_xk = this_xk;\n-    this_xk = tmp2;\n-    tmp2 = tinst_flatten_array;\n-    tinst_flatten_array = this_flatten_array;\n-    this_flatten_array = tmp2;\n-  }\n-  if (tinst_klass->is_interface() &&\n-      !(this_klass->is_interface() ||\n-        \/\/ Treat java\/lang\/Object as an honorary interface,\n-        \/\/ because we need a bottom for the interface hierarchy.\n-        this_klass == ciEnv::current()->Object_klass())) {\n-    \/\/ Oop meets interface!\n-\n-    \/\/ See if the oop subtypes (implements) interface.\n-    if (this_klass->is_subtype_of(tinst_klass)) {\n-      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n-      \/\/ on whether we are both above the centerline or either is\n-      \/\/ below the centerline.  If we are on the centerline\n-      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n-      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n-      \/\/ If we are keeping this_klass, keep its exactness too.\n-      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n-      res_flatten_array = below_centerline(ptr) ? tinst_flatten_array    : this_flatten_array;\n-      return SUBTYPE;\n-    } else {                  \/\/ Does not implement, fall to Object\n-      \/\/ Oop does not implement interface, so mixing falls to Object\n-      \/\/ just like the verifier does (if both are above the\n-      \/\/ centerline fall to interface)\n-      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n-      res_xk = above_centerline(ptr) ? tinst_xk : false;\n-      res_flatten_array = above_centerline(ptr) ? tinst_flatten_array : false;\n-      \/\/ Watch out for Constant vs. AnyNull interface.\n-      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n-      return NOT_SUBTYPE;\n-    }\n-  }\n-\n-  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n-\n@@ -4419,1 +4586,1 @@\n-  ciKlass *subtype = NULL;\n+  const T* subtype = NULL;\n@@ -4422,6 +4589,7 @@\n-  if (tinst_klass->equals(this_klass)) {\n-    subtype = this_klass;\n-    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n-    flat_array = below_centerline(ptr) ? (this_flatten_array && tinst_flatten_array) : (this_flatten_array || tinst_flatten_array);\n-  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass) && (!tinst_flatten_array || this_flatten_array)) {\n-    subtype = this_klass;     \/\/ Pick subtyping class\n+  InterfaceSet subtype_interfaces;\n+  if (this_type->is_same_java_type_as(other_type)) {\n+    subtype = this_type;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && other_xk) : (this_xk || other_xk);\n+    flat_array = below_centerline(ptr) ? (this_flatten_array && other_flatten_array) : (this_flatten_array || other_flatten_array);\n+  } else if (!other_xk && this_type->is_meet_subtype_of(other_type) && (!other_flatten_array || this_flatten_array)) {\n+    subtype = this_type;     \/\/ Pick subtyping class\n@@ -4430,4 +4598,4 @@\n-  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass) && (!this_flatten_array || tinst_flatten_array)) {\n-    subtype = tinst_klass;    \/\/ Pick subtyping class\n-    subtype_exact = tinst_xk;\n-    flat_array = tinst_flatten_array;\n+  } else if (!this_xk && other_type->is_meet_subtype_of(this_type) && (!this_flatten_array || other_flatten_array)) {\n+    subtype = other_type;    \/\/ Pick subtyping class\n+    subtype_exact = other_xk;\n+    flat_array = other_flatten_array;\n@@ -4438,11 +4606,11 @@\n-      this_klass = tinst_klass = subtype;\n-      this_xk = tinst_xk = subtype_exact;\n-      this_flatten_array = tinst_flatten_array = flat_array;\n-    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n-      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n-      this_xk = tinst_xk;\n-      this_flatten_array = tinst_flatten_array;\n-    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n-      tinst_klass = this_klass; \/\/ this is down; keep down man\n-      tinst_xk = this_xk;\n-      tinst_flatten_array = this_flatten_array;\n+      this_type = other_type = subtype;\n+      this_xk = other_xk = subtype_exact;\n+      this_flatten_array = other_flatten_array = flat_array;\n+    } else if (above_centerline(this_ptr) && !above_centerline(other_ptr)) {\n+      this_type = other_type; \/\/ tinst is down; keep down man\n+      this_xk = other_xk;\n+      this_flatten_array = other_flatten_array;\n+    } else if (above_centerline(other_ptr) && !above_centerline(this_ptr)) {\n+      other_type = this_type; \/\/ this is down; keep down man\n+      other_xk = this_xk;\n+      other_flatten_array = this_flatten_array;\n@@ -4456,1 +4624,1 @@\n-  if (tinst_klass->equals(this_klass)) {\n+  if (this_type->is_same_java_type_as(other_type)) {\n@@ -4460,1 +4628,1 @@\n-    res_klass = this_klass;\n+    res_klass = this_type->klass();\n@@ -4472,0 +4640,2 @@\n+  interfaces = this_interfaces.intersection_with(other_interfaces);\n+\n@@ -4473,1 +4643,1 @@\n-  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n+  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n@@ -4477,1 +4647,1 @@\n-  res_flatten_array = this_flatten_array_orig && tinst_flatten_array_orig;\n+  res_flatten_array = this_flatten_array_orig && other_flatten_array_orig;\n@@ -4482,1 +4652,0 @@\n-\n@@ -4498,1 +4667,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flatten_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), flatten_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4508,0 +4677,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -4514,1 +4684,1 @@\n-  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), (jint)flatten_array());\n+  int hash = java_add(java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash()), (jint)flatten_array());\n@@ -4519,20 +4689,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-\n-  if (!other_exact) {\n-    return false;\n-  }\n-\n-  if (other->klass()->equals(ciEnv::current()->Object_klass())) {\n-    return true;\n-  }\n-\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n-\n-  return _klass->is_subtype_of(other->klass());\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4541,8 +4692,3 @@\n-bool TypeInstPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-  return _klass->equals(other->_klass);\n+\n+bool TypeInstPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n@@ -4552,27 +4698,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n-\n-  if (other->isa_aryptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n-  }\n-\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n-  }\n-\n-  assert(other->isa_instptr(), \"unsupported\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n-    return false;\n-  }\n-\n-  if (this_exact) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-\n-  return true;\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4588,0 +4708,1 @@\n+  _interfaces.dump(st);\n@@ -4638,1 +4759,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flatten_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset), flatten_array(),\n@@ -4643,1 +4764,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), Offset(offset), flatten_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), Offset(offset), flatten_array(),\n@@ -4652,1 +4773,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flatten_array(),\n@@ -4656,1 +4777,1 @@\n-const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeInstPtr::with_inline_depth(int depth) const {\n@@ -4660,1 +4781,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flatten_array(), _instance_id, _speculative, depth);\n@@ -4663,1 +4784,1 @@\n-const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeInstPtr::with_instance_id(int instance_id) const {\n@@ -4665,1 +4786,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flatten_array(), instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flatten_array(), instance_id, _speculative, _inline_depth);\n@@ -4669,1 +4790,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);\n@@ -4675,5 +4796,71 @@\n-  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n-    Compile* C = Compile::current();\n-    Dependencies* deps = C->dependencies();\n-    deps->assert_leaf_type(ik);\n-    xk = true;\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final()) {\n+    ciKlass* k = ik;\n+    TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    assert(k == ik, \"\");\n+    if (interfaces.eq(_interfaces)) {\n+      Compile *C = Compile::current();\n+      Dependencies* deps = C->dependencies();\n+      deps->assert_leaf_type(ik);\n+      xk = true;\n+    }\n+  }\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, Offset(0), flatten_array());\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (!this_one->is_instance_type(other)) {\n+    return false;\n+  }\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  return this_one->klass()->is_subtype_of(other->klass()) &&\n+         (!this_xk || this_one->_interfaces.contains(other->_interfaces));\n+}\n+\n+\n+bool TypeInstPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+template <class T1, class T2>  bool TypePtr::is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces.contains(other->_interfaces);\n+  }\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (this_top_or_bottom) {\n+    return false;\n+  }\n+\n+  const T1* other_ary = this_one->is_array_type(other);\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk) &&\n+      (this_one->is_null_free() == other_ary->is_null_free() || (this_one->is_null_free() && !other_ary->is_null_free()));\n+  }\n+\n+  if (this_one->elem()->isa_inlinetype()) {\n+    ciInstanceKlass* inline_klass = this_one->elem()->is_inlinetype()->inline_klass();\n+    if (other_ary->elem()->isa_inlinetype()) {\n+      return inline_klass == other_ary->elem()->is_inlinetype()->inline_klass();\n+    } else {\n+      auto other_inst = this_one->is_instance_type(this_one->is_reference_type(other_elem));\n+      if (other_inst != nullptr) {\n+        const InterfaceSet interfaces = this_one->elem()->is_inlinetype()->interfaces();\n+        return inline_klass->is_subtype_of(other_inst->instance_klass()) && interfaces.contains(other_inst->interfaces());\n+      } else {\n+        return false;\n+      }\n+    }\n@@ -4681,1 +4868,18 @@\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), Offset(0), flatten_array());\n+\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n+  }\n+\n+  return false;\n+}\n+\n+bool TypeAryPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeInstKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeAryKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n@@ -4705,0 +4909,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4717,0 +4925,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4750,1 +4962,1 @@\n-  if (!is_java_primitive(etype) && !is_reference_type(etype)) {\n+  if (!is_java_primitive(etype) && !::is_reference_type(etype)) {\n@@ -4819,1 +5031,6 @@\n-  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  const TypeAryPtr* res = make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset,\n+                               _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  if (res->speculative() == res->remove_speculative()) {\n+    return res->remove_speculative();\n+  }\n+  return res;\n@@ -4909,22 +5126,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n-    return false;\n-  }\n-  if (other->isa_instptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n-  }\n-  if (klass() == NULL) {\n-    return false;\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact, other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4933,13 +5129,2 @@\n-bool TypeAryPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!other->isa_aryptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return false;\n-  }\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_same_java_type_as(other_ary->elem()->make_oopptr());\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->equals(other->_klass);\n-  }\n-  return false;\n+bool TypeAryPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n@@ -4949,25 +5134,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return true;\n-  }\n-  if (other->isa_instptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->maybe_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact,\n-                                                               other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -5070,6 +5231,2 @@\n-    const Type* res_elem = NULL;\n-    if (meet_aryptr(ptr, _ary->_elem, tap->_ary->_elem, this->klass(), tap->klass(),\n-                    this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(),\n-                    this->is_not_flat(), tap->is_not_flat(),\n-                    this->is_not_null_free(), tap->is_not_null_free(),\n-                    res_elem, res_klass, res_xk, res_not_flat, res_not_null_free) == NOT_SUBTYPE) {\n+    const Type* elem = tary->_elem;\n+    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk, res_not_flat, res_not_null_free) == NOT_SUBTYPE) {\n@@ -5077,1 +5234,1 @@\n-    } else if (klass() != NULL && tap->klass() != NULL && klass()->is_flat_array_klass() != tap->klass()->is_flat_array_klass()) {\n+    } else if ((this->elem()->isa_inlinetype() != NULL) != (tap->elem()->isa_inlinetype() != NULL)) {\n@@ -5105,1 +5262,1 @@\n-    return make(ptr, o, TypeAry::make(res_elem, tary->_size, tary->_stable, res_not_flat, res_not_null_free), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n+    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable, res_not_flat, res_not_null_free), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n@@ -5116,0 +5273,4 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n+\n@@ -5122,2 +5283,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact() && !tp->flatten_array()) {\n-        return make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact() && !tp->flatten_array()) {\n+        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);\n@@ -5128,1 +5289,2 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);\n+        interfaces = this_interfaces.intersection_with(tp_interfaces);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, false, instance_id, speculative, depth);\n@@ -5140,1 +5302,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact() && !tp->flatten_array()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact() && !tp->flatten_array()) {\n@@ -5154,1 +5316,2 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, false, instance_id, speculative, depth);\n@@ -5176,7 +5339,15 @@\n-TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type* this_elem, const Type* tap_elem,\n-                                         ciKlass* this_klass, ciKlass* tap_klass,\n-                                         bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr,\n-                                         bool this_not_flat, bool tap_not_flat,\n-                                         bool this_not_null_free, bool tap_not_null_free,\n-                                         const Type*& res_elem, ciKlass*& res_klass,\n-                                         bool& res_xk, bool& res_not_flat, bool& res_not_null_free) {\n+template<class T> TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary, const T* other_ary,\n+                                                           ciKlass*& res_klass, bool& res_xk, bool& res_not_flat, bool& res_not_null_free) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_ary->base_element_type(dummy) == Type::TOP || this_ary->base_element_type(dummy) == Type::BOTTOM);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  ciKlass* this_klass = this_ary->klass();\n+  ciKlass* other_klass = other_ary->klass();\n+  bool this_xk = this_ary->klass_is_exact();\n+  bool other_xk = other_ary->klass_is_exact();\n+  PTR this_ptr = this_ary->ptr();\n+  PTR other_ptr = other_ary->ptr();\n+  bool this_not_flat = this_ary->is_not_flat();\n+  bool other_not_flat = other_ary->is_not_flat();\n+  bool this_not_null_free = this_ary->is_not_null_free();\n+  bool other_not_null_free = other_ary->is_not_null_free();\n@@ -5185,3 +5356,2 @@\n-  res_elem = this_elem->meet(tap_elem);\n-  res_not_flat = this_not_flat && tap_not_flat;\n-  res_not_null_free = this_not_null_free && tap_not_null_free;\n+  res_not_flat = this_not_flat && other_not_flat;\n+  res_not_null_free = this_not_null_free && other_not_null_free;\n@@ -5189,1 +5359,1 @@\n-  if (res_elem->isa_int()) {\n+  if (elem->isa_int()) {\n@@ -5192,3 +5362,3 @@\n-    if (this_klass == NULL) {\n-      res_klass = tap_klass;\n-    } else if (tap_klass == NULL || tap_klass == this_klass) {\n+      if (this_top_or_bottom) {\n+        res_klass = other_klass;\n+      } else if (other_top_or_bottom || other_klass == this_klass) {\n@@ -5200,1 +5370,1 @@\n-      res_elem = Type::BOTTOM;\n+      elem = Type::BOTTOM;\n@@ -5203,1 +5373,1 @@\n-  } else \/\/ Non integral arrays.\n+  } else {\/\/ Non integral arrays.\n@@ -5206,1 +5376,1 @@\n-    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n+    if ((above_centerline(ptr) || ptr == Constant) && !this_ary->is_same_java_type_as(other_ary) &&\n@@ -5208,1 +5378,1 @@\n-        tap_klass != NULL  && this_klass != NULL   &&\n+        !this_top_or_bottom && !other_top_or_bottom &&\n@@ -5210,1 +5380,1 @@\n-        ((tap_xk && this_xk) ||\n+        ((other_xk && this_xk) ||\n@@ -5212,1 +5382,1 @@\n-         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n+         (other_xk && !other_ary->is_meet_subtype_of(this_ary)) ||\n@@ -5214,4 +5384,4 @@\n-         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n-      if (above_centerline(ptr) || (res_elem->make_ptr() && above_centerline(res_elem->make_ptr()->_ptr)) ||\n-          res_elem->isa_inlinetype()) {\n-        res_elem = Type::BOTTOM;\n+         (this_xk && !this_ary->is_meet_subtype_of(other_ary)))) {\n+      if (above_centerline(ptr) || (elem->make_ptr() && above_centerline(elem->make_ptr()->_ptr)) ||\n+          elem->isa_inlinetype()) {\n+        elem = Type::BOTTOM;\n@@ -5223,0 +5393,1 @@\n+  }\n@@ -5225,1 +5396,1 @@\n-  switch (tap_ptr) {\n+  switch (other_ptr) {\n@@ -5231,2 +5402,2 @@\n-        if (this_elem->isa_inlinetype()) {\n-          res_elem = this_elem;\n+        if (this_ary->elem()->isa_inlinetype()) {\n+          elem = this_ary->elem();\n@@ -5235,1 +5406,1 @@\n-        res_xk = (tap_xk || this_xk);\n+        res_xk = (other_xk || this_xk);\n@@ -5245,1 +5416,1 @@\n-        res_xk = this_xk && (this_klass == tap_klass);\n+        res_xk = this_xk && (this_ary->is_same_java_type_as(other_ary) || (this_top_or_bottom && other_top_or_bottom));\n@@ -5253,3 +5424,3 @@\n-        res_xk = tap_xk;\n-        if (tap_elem->isa_inlinetype()) {\n-          res_elem = tap_elem;\n+        res_xk = other_xk;\n+        if (other_ary->elem()->isa_inlinetype()) {\n+          elem = other_ary->elem();\n@@ -5258,2 +5429,2 @@\n-        res_xk = (tap_xk && this_xk) &&\n-          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n+        res_xk = (other_xk && this_xk) &&\n+                 (this_ary->is_same_java_type_as(other_ary) || (this_top_or_bottom && other_top_or_bottom)); \/\/ Only precise for identical arrays\n@@ -5287,11 +5458,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAryPtr::interface_vs_oop(const Type *t) const {\n-  const TypeAryPtr* t_aryptr = t->isa_aryptr();\n-  if (t_aryptr) {\n-    return _ary->interface_vs_oop(t_aryptr->_ary);\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -5302,0 +5462,2 @@\n+  _interfaces.dump(st);\n+\n@@ -5355,0 +5517,4 @@\n+  \/\/ FIXME: Does this belong here? Or in the meet code itself?\n+  if (is_flat() && is_not_flat()) {\n+    return true;\n+  }\n@@ -5359,1 +5525,1 @@\n-const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryPtr::add_offset(intptr_t offset) const {\n@@ -5385,1 +5551,2 @@\n-  if (spec_aryptr != NULL && (spec_aryptr->is_not_flat() || spec_aryptr->is_not_null_free())) {\n+  if (spec_aryptr != NULL && !above_centerline(spec_aryptr->ptr()) &&\n+      (spec_aryptr->is_not_flat() || spec_aryptr->is_not_null_free())) {\n@@ -5391,1 +5558,1 @@\n-const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeAryPtr::with_inline_depth(int depth) const {\n@@ -5446,1 +5613,1 @@\n-const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeAryPtr::with_instance_id(int instance_id) const {\n@@ -5634,1 +5801,1 @@\n-const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {\n+const TypePtr* TypeMetadataPtr::add_offset( intptr_t offset ) const {\n@@ -5813,1 +5980,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(ciKlass* klass) {\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n@@ -5815,1 +5982,1 @@\n-    return TypeInstKlassPtr::make(klass);\n+    return TypeInstKlassPtr::make(klass, interface_handling);\n@@ -5817,1 +5984,1 @@\n-  return TypeAryKlassPtr::make(klass);\n+  return TypeAryKlassPtr::make(klass, interface_handling);\n@@ -5820,1 +5987,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, InterfaceHandling interface_handling) {\n@@ -5822,1 +5989,2 @@\n-    return TypeInstKlassPtr::make(ptr, klass, offset);\n+    const InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n@@ -5824,1 +5992,1 @@\n-  return TypeAryKlassPtr::make(ptr, klass, offset);\n+  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n@@ -5827,3 +5995,4 @@\n-\/\/------------------------------TypeKlassPtr-----------------------------------\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, Offset offset)\n-  : TypePtr(t, ptr, offset), _klass(klass) {\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, Offset offset)\n+  : TypePtr(t, ptr, offset), _klass(klass), _interfaces(interfaces) {\n+  assert(klass == NULL || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n+         klass->is_type_array_klass() || klass->is_flat_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"no interface here\");\n@@ -5832,0 +6001,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5833,1 +6003,12 @@\n-  return _klass;\n+  assert(_klass->is_instance_klass() && !_klass->is_interface(), \"No interface\");\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    if (_interfaces.eq(TypePtr::interfaces(k, true, false, true, ignore_interfaces))) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -5841,0 +6022,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -5847,1 +6029,1 @@\n-  return TypePtr::hash();\n+  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n@@ -5868,3 +6050,0 @@\n-    if (!empty() && ktkp != NULL && ktkp->is_loaded() && ktkp->klass()->is_interface())\n-      return kills;             \/\/ Uplift to interface\n-\n@@ -5874,9 +6053,0 @@\n-  \/\/ Interface klass type could be exact in opposite to interface type,\n-  \/\/ return it here instead of incorrect Constant ptr J\/L\/Object (6894807).\n-  if (ftkp != NULL && ktkp != NULL &&\n-      ftkp->is_loaded() &&  ftkp->klass()->is_interface() &&\n-      !ftkp->klass_is_exact() && \/\/ Keep exact interface klass\n-      ktkp->is_loaded() && !ktkp->klass()->is_interface()) {\n-    return ktkp->cast_to_ptr_type(ftkp->ptr());\n-  }\n-\n@@ -5886,0 +6056,11 @@\n+TypePtr::InterfaceSet TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -5911,1 +6092,1 @@\n-void TypeInstKlassPtr::dump2(Dict & d, uint depth, outputStream *st) const {\n+void TypeKlassPtr::dump2(Dict & d, uint depth, outputStream *st) const {\n@@ -5923,0 +6104,1 @@\n+      _interfaces.dump(st);\n@@ -5935,1 +6117,1 @@\n-    if (_flatten_array) st->print(\":flatten array\");\n+    if (isa_instklassptr() && is_instklassptr()->flatten_array()) st->print(\":flatten array\");\n@@ -5961,1 +6143,1 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, Offset offset, bool flatten_array) {\n@@ -5965,1 +6147,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset, flatten_array))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset, flatten_array))->hashcons();\n@@ -5973,1 +6155,1 @@\n-  return make(_ptr, klass(), xadd_offset(offset), flatten_array());\n+  return make(_ptr, klass(), _interfaces, xadd_offset(offset), flatten_array());\n@@ -5977,1 +6159,1 @@\n-  return make(_ptr, klass(), Offset(offset), flatten_array());\n+  return make(_ptr, klass(), _interfaces, Offset(offset), flatten_array());\n@@ -5984,1 +6166,1 @@\n-  return make(ptr, _klass, _offset, flatten_array());\n+  return make(ptr, _klass, _interfaces, _offset, flatten_array());\n@@ -6000,1 +6182,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _offset, flatten_array());\n+  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset, flatten_array());\n@@ -6015,0 +6197,1 @@\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n@@ -6023,3 +6206,8 @@\n-        deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-        k = ik = sub;\n-        xk = sub->is_final();\n+        ciKlass* sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          xk = sub->is_final();\n+        }\n@@ -6029,1 +6217,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, Offset(0), flatten_array() && !klass()->is_inlinetype());\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, NULL, Offset(0), flatten_array() && !klass()->is_inlinetype());\n@@ -6070,1 +6258,1 @@\n-      return make(ptr, klass(), offset, flatten_array());\n+      return make(ptr, klass(), _interfaces, offset, flatten_array());\n@@ -6105,6 +6293,1 @@\n-    ciKlass* tkls_klass = tkls->klass();\n-    ciKlass* this_klass  = klass();\n-    bool tkls_xk = tkls->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n-    bool tkls_flatten_array = tkls->flatten_array();\n-    bool this_flatten_array  = this->flatten_array();\n+    InterfaceSet interfaces = meet_interfaces(tkls);\n@@ -6115,2 +6298,1 @@\n-    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr,\n-                        this_flatten_array, tkls_flatten_array, res_klass, res_xk, res_flatten_array)) {\n+    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk, res_flatten_array)) {\n@@ -6124,2 +6306,2 @@\n-        const Type* res1 = make(ptr, res_klass, off, res_flatten_array);\n-        return res1;\n+        const Type* res = make(ptr, res_klass, interfaces, off, res_flatten_array);\n+        return res;\n@@ -6135,0 +6317,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -6142,1 +6327,1 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -6147,1 +6332,2 @@\n-        return make(ptr, ciEnv::current()->Object_klass(), offset, false);\n+        interfaces = _interfaces.intersection_with(tp->_interfaces);\n+        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, false);\n@@ -6159,1 +6345,1 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass())) {\n+        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -6161,2 +6347,1 @@\n-          return TypeAryKlassPtr::make(ptr,\n-                                       tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_null_free());\n+          return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_null_free());\n@@ -6169,1 +6354,2 @@\n-      return make(ptr, ciEnv::current()->Object_klass(), offset, false);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, false);\n@@ -6175,0 +6361,1 @@\n+    InterfaceSet interfaces = tv->interfaces();\n@@ -6176,1 +6363,1 @@\n-      if (tv->inline_klass()->is_subtype_of(_klass)) {\n+      if (tv->inline_klass()->is_subtype_of(_klass) && interfaces.contains(_interfaces)) {\n@@ -6186,2 +6373,2 @@\n-      if (tv->inline_klass()->is_subtype_of(_klass)) {\n-        return make(ptr, _klass, Offset(0), _flatten_array);\n+      if (tv->inline_klass()->is_subtype_of(_klass) && interfaces.contains(_interfaces)) {\n+        return make(ptr, _klass, _interfaces, Offset(0), _flatten_array);\n@@ -6201,1 +6388,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset(), flatten_array());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset(), flatten_array());\n@@ -6204,2 +6391,3 @@\n-bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -6208,1 +6396,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -6216,1 +6404,1 @@\n-  if (other->_klass->equals(ciEnv::current()->Object_klass())) {\n+  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces.empty()) {\n@@ -6220,3 +6408,2 @@\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n+  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+}\n@@ -6224,1 +6411,2 @@\n-  return _klass->is_subtype_of(other->_klass);\n+bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -6227,2 +6415,3 @@\n-bool TypeInstKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -6231,1 +6420,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -6234,1 +6423,1 @@\n-  return _klass->equals(other->_klass);\n+  return this_one->_klass->equals(other->_klass) && this_one->_interfaces.eq(other->_interfaces);\n@@ -6237,4 +6426,3 @@\n-bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n+bool TypeInstKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n+}\n@@ -6242,2 +6430,4 @@\n-  if (other->isa_aryklassptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n+    return true;\n@@ -6246,2 +6436,2 @@\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n+  if (this_one->is_array_type(other)) {\n+    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces.contains(this_one->_interfaces);\n@@ -6250,1 +6440,1 @@\n-  assert(other->isa_instklassptr(), \"unsupported\");\n+  assert(this_one->is_instance_type(other), \"unsupported\");\n@@ -6253,1 +6443,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -6256,1 +6446,1 @@\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n@@ -6261,1 +6451,1 @@\n-    return _klass->is_subtype_of(other->_klass);\n+    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n@@ -6267,1 +6457,52 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n+bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+}\n+\n+const TypeKlassPtr* TypeInstKlassPtr::try_improve() const {\n+  if (!UseUniqueSubclasses) {\n+    return this;\n+  }\n+  ciKlass* k = klass();\n+  Compile* C = Compile::current();\n+  Dependencies* deps = C->dependencies();\n+  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n+  if (k->is_loaded()) {\n+    ciInstanceKlass* ik = k->as_instance_klass();\n+    bool klass_is_exact = ik->is_final();\n+    if (!klass_is_exact &&\n+        deps != NULL) {\n+      ciInstanceKlass* sub = ik->unique_concrete_subklass();\n+      if (sub != NULL) {\n+        ciKlass *sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          klass_is_exact = sub->is_final();\n+          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n+        }\n+      }\n+    }\n+  }\n+  return this;\n+}\n+\n+bool TypeInstKlassPtr::can_be_inline_array() const {\n+  return _klass->equals(ciEnv::current()->Object_klass()) && TypeAryKlassPtr::_array_interfaces->contains(_interfaces);\n+}\n+\n+bool TypeAryKlassPtr::can_be_inline_array() const {\n+  return _elem->isa_inlinetype() || (_elem->isa_instklassptr() && _elem->is_instklassptr()->_klass->can_be_inline_klass());\n+}\n+\n+bool TypeInstPtr::can_be_inline_array() const {\n+  return _klass->equals(ciEnv::current()->Object_klass()) && TypeAryPtr::_array_interfaces->contains(_interfaces);\n+}\n+\n+bool TypeAryPtr::can_be_inline_array() const {\n+  return elem()->isa_inlinetype() || (elem()->make_ptr() && elem()->make_ptr()->isa_instptr() && elem()->make_ptr()->is_instptr()->_klass->can_be_inline_klass());\n+}\n+\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n@@ -6271,2 +6512,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n-  if (klass->is_obj_array_klass()) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool null_free) {\n+  if (k->is_obj_array_klass()) {\n@@ -6274,3 +6515,2 @@\n-    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n-    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n-\n+    ciKlass* eklass = k->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n@@ -6279,1 +6519,1 @@\n-      etype = TypeInstKlassPtr::make(NotNull, etype->is_instklassptr()->klass(), Offset(etype->is_instklassptr()->offset()), etype->is_instklassptr()->flatten_array());\n+      etype = TypeInstKlassPtr::make(NotNull, etype->is_instklassptr()->klass(), Offset(etype->is_instklassptr()->offset()));\n@@ -6281,5 +6521,2 @@\n-\n-    const TypeAryKlassPtr* res = TypeAryKlassPtr::make(ptr, etype, NULL, offset, not_flat, not_null_free, null_free);\n-    assert(res->klass() == klass, \"\");\n-    return res;\n-  } else if (klass->is_type_array_klass()) {\n+    return TypeAryKlassPtr::make(ptr, etype, NULL, offset, not_flat, not_null_free, null_free);\n+  } else if (k->is_type_array_klass()) {\n@@ -6287,4 +6524,4 @@\n-    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, klass, offset, not_flat, not_null_free, null_free);\n-  } else if (klass->is_flat_array_klass()) {\n-    ciKlass* eklass = klass->as_flat_array_klass()->element_klass();\n+    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, null_free);\n+  } else if (k->is_flat_array_klass()) {\n+    ciKlass* eklass = k->as_flat_array_klass()->element_klass();\n@@ -6292,1 +6529,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, klass, offset, not_flat, not_null_free, null_free);\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, null_free);\n@@ -6299,1 +6536,1 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling) {\n@@ -6307,1 +6544,1 @@\n-  return TypeAryKlassPtr::make(ptr, k, offset, not_flat, not_null_free, null_free);\n+  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, null_free);\n@@ -6310,2 +6547,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n-  return TypeAryKlassPtr::make(Constant, klass, Offset(0));\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n+  return TypeAryKlassPtr::make(Constant, klass, Offset(0), interface_handling);\n@@ -6337,0 +6574,1 @@\n+  const TypeInstPtr *tinst;\n@@ -6344,4 +6582,4 @@\n-  if (el->isa_instptr()) {\n-    \/\/ Compute object array klass from element klass\n-    bool null_free = el->is_inlinetypeptr() && el->isa_instptr()->ptr() != TypePtr::TopPTR && !el->isa_instptr()->maybe_null();\n-    k_ary = ciArrayKlass::make(el->is_oopptr()->klass(), null_free);\n+  if ((tinst = el->isa_instptr()) != NULL) {\n+    \/\/ Leave k_ary at NULL.\n+  } else if ((tary = el->isa_aryptr()) != NULL) {\n+    \/\/ Leave k_ary at NULL.\n@@ -6353,6 +6591,0 @@\n-  } else if ((tary = el->isa_aryptr()) != NULL) {\n-    \/\/ Compute array klass from element klass\n-    ciKlass* k_elem = tary->klass();\n-    \/\/ If element type is something like bottom[], k_elem will be null.\n-    if (k_elem != NULL)\n-      k_ary = ciObjArrayKlass::make(k_elem);\n@@ -6416,5 +6648,0 @@\n-    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n-        offset() != 0 && offset() != arrayOopDesc::length_offset_in_bytes() &&\n-        offset() != arrayOopDesc::klass_offset_in_bytes()) {\n-      ((TypeAryPtr*)this)->_is_ptr_to_narrowoop = true;\n-    }\n@@ -6425,0 +6652,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -6450,1 +6678,1 @@\n-const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryKlassPtr::add_offset(intptr_t offset) const {\n@@ -6471,1 +6699,1 @@\n-  if (tk->klass()->is_inlinetype() && !is_null_free()) {\n+  if (tk->isa_instklassptr() && tk->klass()->is_inlinetype() && !is_null_free()) {\n@@ -6481,0 +6709,3 @@\n+  if (klass_is_exact == this->klass_is_exact()) {\n+    return this;\n+  }\n@@ -6488,2 +6719,2 @@\n-  if (k != NULL && k->is_obj_array_klass()) {\n-    if (klass_is_exact) {\n+  if (_elem->isa_klassptr()) {\n+    if (klass_is_exact || _elem->isa_aryklassptr()) {\n@@ -6494,0 +6725,1 @@\n+      assert(_elem->isa_instklassptr(), \"\");\n@@ -6495,1 +6727,1 @@\n-      const TypeOopPtr* exact_etype = TypeOopPtr::make_from_klass_unique(k->as_array_klass()->element_klass());\n+      const TypeOopPtr* exact_etype = TypeOopPtr::make_from_klass_unique(_elem->is_instklassptr()->instance_klass());\n@@ -6509,1 +6741,0 @@\n-  assert(k != NULL, \"klass should not be NULL\");\n@@ -6569,1 +6800,1 @@\n-      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), _null_free);\n+      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), is_null_free());\n@@ -6603,1 +6834,1 @@\n-    const Type* res_elem = NULL;\n+    const Type* elem = _elem->meet(tap->_elem);\n@@ -6609,5 +6840,2 @@\n-    MeetResult res = meet_aryptr(ptr, _elem, tap->_elem, this->klass(), tap->klass(),\n-                                 this->klass_is_exact(), tap->klass_is_exact(),\n-                                 this->ptr(), tap->ptr(), this->is_not_flat(), tap->is_not_flat(),\n-                                 this->is_not_null_free(), tap->is_not_null_free(),\n-                                 res_elem, res_klass, res_xk, res_not_flat, res_not_null_free);\n+    MeetResult res = meet_aryptr(ptr, elem, this, tap,\n+                                 res_klass, res_xk, res_not_flat, res_not_null_free);\n@@ -6625,1 +6853,1 @@\n-    return make(ptr, res_elem, res_klass, off, res_not_flat, res_not_null_free, null_free);\n+    return make(ptr, elem, res_klass, off, res_not_flat, res_not_null_free, null_free);\n@@ -6631,0 +6859,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -6638,2 +6869,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n-        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), _null_free);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n+        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_null_free());\n@@ -6643,1 +6874,2 @@\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset, false);\n+        interfaces = this_interfaces.intersection_with(tp->_interfaces);\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, false);\n@@ -6655,1 +6887,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6657,1 +6889,1 @@\n-          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), _null_free);\n+          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_null_free());\n@@ -6664,1 +6896,2 @@\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset, false);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset, false);\n@@ -6685,2 +6918,4 @@\n-bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6690,1 +6925,4 @@\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6693,2 +6931,3 @@\n-  if (other->isa_instklassptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces) && other_exact;\n@@ -6696,1 +6935,5 @@\n-  if (klass() == NULL) {\n+\n+  assert(this_one->is_array_type(other), \"\");\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n@@ -6699,4 +6942,5 @@\n-  assert(other->isa_aryklassptr(), \"\");\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    if (other->is_null_free() && !is_null_free()) {\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (this_elem != NULL && other_elem != NULL) {\n+    if (other->is_null_free() && !this_one->is_null_free()) {\n@@ -6705,1 +6949,15 @@\n-    return _elem->is_klassptr()->is_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+    return this_one->is_reference_type(this_elem)->is_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n+  }\n+  if (this_one->elem()->isa_inlinetype()) {\n+    ciInstanceKlass* inline_klass = this_one->elem()->is_inlinetype()->inline_klass();\n+    if (other_ary->elem()->isa_inlinetype()) {\n+      return inline_klass == other_ary->elem()->is_inlinetype()->inline_klass();\n+    } else {\n+      auto other_inst = this_one->is_instance_type(this_one->is_reference_type(other_elem));\n+      if (other_inst != nullptr) {\n+        const InterfaceSet interfaces = this_one->elem()->is_inlinetype()->interfaces();\n+        return inline_klass->is_subtype_of(other_inst->instance_klass()) && interfaces.contains(other_inst->interfaces());\n+      } else {\n+        return false;\n+      }\n+    }\n@@ -6707,2 +6965,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (this_elem == NULL && other_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6713,3 +6971,12 @@\n-bool TypeAryKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!other->isa_aryklassptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_array_type(other) ||\n+      !this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6718,3 +6985,20 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_same_java_type_as(other_ary->_elem->is_klassptr());\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (other_top_or_bottom) {\n+    return false;\n+  }\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem)) &&\n+            this_one->is_null_free() == other_ary->is_null_free();\n+  }\n+  if (this_one->elem()->isa_inlinetype()) {\n+    ciInstanceKlass* inline_klass = this_one->elem()->is_inlinetype()->inline_klass();\n+    if (other_ary->elem()->isa_inlinetype()) {\n+      return inline_klass == other_ary->elem()->is_inlinetype()->inline_klass();\n+    } else {\n+      return false;\n+    }\n@@ -6722,2 +7006,3 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->equals(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    assert(this_one->_klass != NULL && other->_klass != NULL, \"\");\n+    return this_one->_klass->equals(other->_klass);\n@@ -6728,2 +7013,7 @@\n-bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n+bool TypeAryKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n+}\n+\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6732,1 +7022,3 @@\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6735,2 +7027,2 @@\n-  if (other->isa_instklassptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  if (this_one->is_instance_type(other)) {\n+    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces);\n@@ -6738,1 +7030,1 @@\n-  assert(other->isa_aryklassptr(), \"\");\n+  assert(this_one->is_array_type(other), \"\");\n@@ -6740,0 +7032,5 @@\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n+    return true;\n+  }\n@@ -6741,1 +7038,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -6744,3 +7041,4 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->maybe_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->maybe_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6748,2 +7046,16 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (this_one->elem()->isa_inlinetype()) {\n+    ciInstanceKlass* inline_klass = this_one->elem()->is_inlinetype()->inline_klass();\n+    if (other_ary->elem()->isa_inlinetype()) {\n+      return inline_klass == other_ary->elem()->is_inlinetype()->inline_klass();\n+    } else {\n+      auto other_inst = this_one->is_instance_type(this_one->is_reference_type(other_elem));\n+      if (other_inst != nullptr) {\n+        const InterfaceSet interfaces = this_one->elem()->is_inlinetype()->interfaces();\n+        return inline_klass->is_subtype_of(other_inst->instance_klass()) && interfaces.contains(other_inst->interfaces());\n+      } else {\n+        return false;\n+      }\n+    }\n+  }\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6754,0 +7066,4 @@\n+bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n@@ -6760,1 +7076,1 @@\n-\/\/------------------------------get_con----------------------------------------\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -6779,20 +7095,10 @@\n-  const Type* el = elem();\n-  if (el->isa_instklassptr()) {\n-    \/\/ Compute object array klass from element klass\n-    bool null_free = el->is_instklassptr()->klass()->is_inlinetype() && el->isa_instklassptr()->ptr() != TypePtr::TopPTR && (_null_free != 0);\n-    k = ciArrayKlass::make(el->is_klassptr()->klass(), null_free);\n-    ((TypeAryKlassPtr*)this)->_klass = k;\n-  } else if (el->isa_inlinetype()) {\n-    \/\/ If element type is TypeInlineType::BOTTOM, inline_klass() will be null.\n-    if (el->inline_klass() != NULL) {\n-      k = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n-      ((TypeAryKlassPtr*)this)->_klass = k;\n-    }\n-  } else if (el->isa_aryklassptr() != NULL) {\n-    \/\/ Compute array klass from element klass\n-    ciKlass* k_elem = el->is_aryklassptr()->klass();\n-    \/\/ If element type is something like bottom[], k_elem will be null.\n-    if (k_elem != NULL) {\n-      k = ciObjArrayKlass::make(k_elem);\n-      ((TypeAryKlassPtr*)this)->_klass = k;\n-    }\n+\n+\/\/  if (el->isa_inlinetype()) {\n+\/\/    \/\/ If element type is TypeInlineType::BOTTOM, inline_klass() will be null.\n+\/\/    if (el->inline_klass() != NULL) {\n+\/\/      k = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n+\/\/      ((TypeAryKlassPtr*)this)->_klass = k;\n+\/\/    }\n+\/\/  }\n+  if (elem()->isa_klassptr()) {\n+    \/\/ leave NULL\n@@ -6803,0 +7109,1 @@\n+    ((TypeAryKlassPtr*)this)->_klass = k;\n@@ -6822,0 +7129,1 @@\n+      _interfaces.dump(st);\n@@ -6891,2 +7199,2 @@\n-  const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);\n-  const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;\n+  const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, ignore_interfaces, false);\n+  const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, ignore_interfaces, true) : domain_sig;\n@@ -6895,2 +7203,2 @@\n-  const TypeTuple* range_sig = TypeTuple::make_range(sig, false);\n-  const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;\n+  const TypeTuple* range_sig = TypeTuple::make_range(sig, ignore_interfaces, false);\n+  const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, ignore_interfaces, true) : range_sig;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":969,"deletions":661,"binary":false,"changes":1630,"status":"modified"},{"patch":"@@ -199,4 +199,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop_helper(const Type *t) const;\n-#endif\n@@ -291,1 +287,0 @@\n-  \/\/ Currently, it also works around limitations involving interface types.\n@@ -301,5 +296,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n-\n@@ -440,0 +430,4 @@\n+  enum InterfaceHandling {\n+      trust_interfaces,\n+      ignore_interfaces\n+  };\n@@ -441,1 +435,1 @@\n-  static const Type* get_const_type(ciType* type);\n+  static const Type* get_const_type(ciType* type, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -760,2 +754,2 @@\n-  static const TypeTuple *make_range(ciSignature* sig, bool ret_vt_fields = false);\n-  static const TypeTuple *make_domain(ciMethod* method, bool vt_fields_as_args = false);\n+  static const TypeTuple *make_range(ciSignature* sig, InterfaceHandling interface_handling = ignore_interfaces, bool ret_vt_fields = false);\n+  static const TypeTuple *make_domain(ciMethod* method, InterfaceHandling interface_handling, bool vt_fields_as_args = false);\n@@ -818,5 +812,0 @@\n-\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n@@ -828,39 +817,0 @@\n-\/\/ TODO 8293800 Remove\n-\/\/------------------------------TypeValue---------------------------------------\n-\/\/ Class of Inline Type Types\n-class TypeInlineType : public Type {\n-private:\n-  ciInlineKlass* _vk;\n-  bool _larval;\n-\n-protected:\n-  TypeInlineType(ciInlineKlass* vk, bool larval)\n-    : Type(InlineType),\n-      _vk(vk), _larval(larval) {\n-  }\n-\n-public:\n-  static const TypeInlineType* make(ciInlineKlass* vk, bool larval = false);\n-  virtual ciInlineKlass* inline_klass() const { return _vk; }\n-  bool larval() const { return _larval; }\n-\n-  virtual bool eq(const Type* t) const;\n-  virtual int  hash() const;             \/\/ Type specific hashing\n-  virtual bool singleton(void) const;    \/\/ TRUE if type is a singleton\n-  virtual bool empty(void) const;        \/\/ TRUE if type is vacuous\n-\n-  virtual const Type* xmeet(const Type* t) const;\n-  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n-\n-  virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }\n-  virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }\n-\n-  virtual bool maybe_null() const { return false; }\n-\n-  static const TypeInlineType* BOTTOM;\n-\n-#ifndef PRODUCT\n-  virtual void dump2(Dict &d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n-#endif\n-};\n-\n@@ -967,0 +917,47 @@\n+  friend class Type;\n+  friend class TypeInlineType;\n+protected:\n+  class InterfaceSet {\n+  private:\n+    GrowableArray<ciKlass*> _list;\n+    void raw_add(ciKlass* interface);\n+    void add(ciKlass* interface);\n+    void verify() const;\n+    int _hash_computed:1;\n+    int _exact_klass_computed:1;\n+    int _is_loaded_computed:1;\n+    int _hash;\n+    ciKlass* _exact_klass;\n+    bool _is_loaded;\n+    void compute_hash();\n+    void compute_exact_klass();\n+  public:\n+    InterfaceSet();\n+    InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces);\n+    bool eq(const InterfaceSet& other) const;\n+    int hash() const;\n+    void dump(outputStream *st) const;\n+    InterfaceSet union_with(const InterfaceSet& other) const;\n+    InterfaceSet intersection_with(const InterfaceSet& other) const;\n+    bool contains(const InterfaceSet& other) const {\n+      return intersection_with(other).eq(other);\n+    }\n+    bool empty() const { return _list.length() == 0; }\n+\n+    inline void* operator new(size_t x) throw() {\n+      Compile* compile = Compile::current();\n+      return compile->type_arena()->AmallocWords(x);\n+    }\n+    inline void operator delete( void* ptr ) {\n+      ShouldNotReachHere();\n+    }\n+    ciKlass* exact_klass() const;\n+    bool is_loaded() const;\n+\n+    static int compare(ciKlass* const &, ciKlass* const & k2);\n+\n+    void compute_is_loaded();\n+  };\n+\n+  static InterfaceSet interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling);\n+\n@@ -1025,10 +1022,14 @@\n-  static MeetResult\n-  meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk, PTR this_ptr,\n-               PTR tinst_ptr, bool this_flatten_array, bool tinst_flatten_array, ciKlass*&res_klass, bool &res_xk,\n-               bool& res_flatten_array);\n-\n-  static MeetResult meet_aryptr(PTR &ptr, const Type* this_elem, const Type* tap_elem, ciKlass* this_klass, ciKlass* tap_klass,\n-                                bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, bool this_not_flat, bool tap_not_flat,\n-                                bool this_not_null_free, bool tap_not_null_free, const Type*& res_elem, ciKlass*&res_klass,\n-                                bool &res_xk, bool &res_not_flat, bool &res_not_null_free);\n-\n+  template<class T> static TypePtr::MeetResult meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n+                                                            ciKlass*& res_klass, bool& res_xk, bool& res_flatten_array);\n+\n+  template<class T> static MeetResult meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary, const T* other_ary,\n+                                                  ciKlass*& res_klass, bool& res_xk, bool &res_not_flat, bool &res_not_null_free);\n+\n+  template <class T1, class T2> static bool is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other);\n+  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other);\n+  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n+  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n@@ -1152,1 +1153,1 @@\n-  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,\n+  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces,bool xk, ciObject* o, Offset offset, Offset field_offset,\n@@ -1168,0 +1169,3 @@\n+\n+  const InterfaceSet _interfaces;\n+\n@@ -1179,1 +1183,1 @@\n-  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);\n+  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling);\n@@ -1184,0 +1188,2 @@\n+  InterfaceSet meet_interfaces(const TypeOopPtr* other) const;\n+\n@@ -1195,1 +1201,9 @@\n-  virtual bool is_same_java_type_as(const TypeOopPtr* other) const { ShouldNotReachHere(); return false; }\n+\n+  bool is_same_java_type_as(const TypePtr* other) const {\n+    return is_same_java_type_as_helper(other->is_oopptr());\n+  }\n+\n+  virtual bool is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n@@ -1206,2 +1220,2 @@\n-  static const TypeOopPtr* make_from_klass(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, false);\n+  static const TypeOopPtr* make_from_klass(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    return make_from_klass_common(klass, true, false, interface_handling);\n@@ -1211,2 +1225,2 @@\n-  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, true);\n+  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass, InterfaceHandling interface_handling= ignore_interfaces) {\n+    return make_from_klass_common(klass, true, true, interface_handling);\n@@ -1216,2 +1230,2 @@\n-  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {\n-    return make_from_klass_common(klass, false, false);\n+  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    return make_from_klass_common(klass, false, false, interface_handling);\n@@ -1236,2 +1250,2 @@\n-  virtual bool  is_loaded() const { return klass()->is_loaded(); }\n-  bool klass_is_exact()    const { return _klass_is_exact; }\n+  virtual bool  is_loaded() const { return klass()->is_loaded() && _interfaces.is_loaded(); }\n+  virtual bool klass_is_exact()    const { return _klass_is_exact; }\n@@ -1249,1 +1263,1 @@\n-  bool can_be_inline_array() const { return (_klass == NULL || _klass->can_be_inline_array_klass()); }\n+  virtual bool can_be_inline_array() const { ShouldNotReachHere(); return false; }\n@@ -1282,0 +1296,24 @@\n+private:\n+  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n+    return is_meet_subtype_of_helper(other->is_oopptr(), klass_is_exact(), other->is_oopptr()->klass_is_exact());\n+  }\n+\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n+  virtual const InterfaceSet interfaces() const {\n+    return _interfaces;\n+  };\n+\n+  const TypeOopPtr* is_reference_type(const Type* other) const {\n+    return other->isa_oopptr();\n+  }\n+\n+  const TypeAryPtr* is_array_type(const TypeOopPtr* other) const {\n+    return other->isa_aryptr();\n+  }\n+\n+  const TypeInstPtr* is_instance_type(const TypeOopPtr* other) const {\n+    return other->isa_instptr();\n+  }\n@@ -1288,1 +1326,1 @@\n-  TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,\n+  TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, Offset offset,\n@@ -1301,3 +1339,1 @@\n-    if (klass()->is_loaded() && klass()->is_interface()) {\n-      return Compile::current()->env()->Object_klass();\n-    }\n+    assert(!(klass()->is_loaded() && klass()->is_interface()), \"\");\n@@ -1307,1 +1343,1 @@\n-  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n@@ -1313,1 +1349,3 @@\n-    return make(TypePtr::Constant, o->klass(), true, o, Offset(0));\n+    ciKlass* k = o->klass();\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(TypePtr::Constant, k, interfaces, true, o, Offset(0));\n@@ -1316,2 +1354,4 @@\n-  static const TypeInstPtr* make(ciObject* o, Offset offset) {\n-    return make(TypePtr::Constant, o->klass(), true, o, offset);\n+  static const TypeInstPtr *make(ciObject* o, Offset offset) {\n+    ciKlass* k = o->klass();\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(TypePtr::Constant, k, interfaces, true, o, offset);\n@@ -1321,2 +1361,3 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {\n-    return make(ptr, klass, false, NULL, Offset(0));\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return make(ptr, klass, interfaces, false, NULL, Offset(0));\n@@ -1327,1 +1368,2 @@\n-    return make(ptr, klass, true, NULL, Offset(0));\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n+    return make(ptr, klass, interfaces, true, NULL, Offset(0));\n@@ -1332,1 +1374,2 @@\n-    return make(ptr, klass, false, NULL, offset);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n+    return make(ptr, klass, interfaces, false, NULL, offset);\n@@ -1336,1 +1379,1 @@\n-  static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,\n+  static const TypeInstPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, Offset offset,\n@@ -1342,0 +1385,5 @@\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, int instance_id = InstanceBot) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(ptr, k, interfaces, xk, o, offset, false, instance_id);\n+  }\n+\n@@ -1370,1 +1418,1 @@\n-  virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;\n+  virtual const TypeInstPtr *xmeet_unloaded(const TypeInstPtr *t, const InterfaceSet& interfaces) const;\n@@ -1375,1 +1423,1 @@\n-  bool is_interface() const { return is_loaded() && klass()->is_interface(); }\n+  virtual bool can_be_inline_array() const;\n@@ -1386,0 +1434,8 @@\n+\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n+\n+  virtual bool is_meet_same_type_as(const TypePtr* other) const {\n+    return _klass->equals(other->is_instptr()->_klass) && _interfaces.eq(other->is_instptr()->_interfaces);\n+  }\n+\n@@ -1391,0 +1447,4 @@\n+  friend class Type;\n+  friend class TypePtr;\n+  friend class TypeInstPtr;\n+\n@@ -1394,1 +1454,1 @@\n-    : TypeOopPtr(AryPtr, ptr, k, xk, o, offset, field_offset, instance_id, speculative, inline_depth),\n+    : TypeOopPtr(AryPtr, ptr, k, *_array_interfaces, xk, o, offset, field_offset, instance_id, speculative, inline_depth),\n@@ -1399,14 +1459,7 @@\n-#ifdef ASSERT\n-    if (k != NULL) {\n-      \/\/ Verify that specified klass and TypeAryPtr::klass() follow the same rules.\n-      ciKlass* ck = compute_klass(true);\n-      if (k != ck) {\n-        this->dump(); tty->cr();\n-        tty->print(\" k: \");\n-        k->print(); tty->cr();\n-        tty->print(\"ck: \");\n-        if (ck != NULL) ck->print();\n-        else tty->print(\"<NULL>\");\n-        tty->cr();\n-        assert(false, \"unexpected TypeAryPtr::_klass\");\n-      }\n+    int dummy;\n+    bool top_or_bottom = (base_element_type(dummy) == Type::TOP || base_element_type(dummy) == Type::BOTTOM);\n+\n+    if (UseCompressedOops && (elem()->make_oopptr() != NULL && !top_or_bottom) &&\n+        _offset.get() != 0 && _offset.get() != arrayOopDesc::length_offset_in_bytes() &&\n+        _offset.get() != arrayOopDesc::klass_offset_in_bytes()) {\n+      _is_ptr_to_narrowoop = true;\n@@ -1414,1 +1467,1 @@\n-#endif\n+\n@@ -1429,0 +1482,3 @@\n+  \/\/ A pointer to delay allocation to Type::Initialize_shared()\n+\n+  static const InterfaceSet* _array_interfaces;\n@@ -1430,0 +1486,1 @@\n+  \/\/ Only guaranteed non null for array of basic types\n@@ -1434,1 +1491,1 @@\n-  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n@@ -1452,1 +1509,1 @@\n-  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr() && !_ary->_elem->make_ptr()->maybe_null()); }\n+  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr() && (_ary->_elem->make_ptr()->ptr() == NotNull || _ary->_elem->make_ptr()->ptr() == AnyNull)); }\n@@ -1518,0 +1575,2 @@\n+  virtual bool can_be_inline_array() const;\n+\n@@ -1537,4 +1596,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n@@ -1544,0 +1599,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n@@ -1591,0 +1648,1 @@\n+  friend class TypePtr;\n@@ -1592,1 +1650,1 @@\n-  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, Offset offset);\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, Offset offset);\n@@ -1604,1 +1662,2 @@\n-\n+  const InterfaceSet _interfaces;\n+  InterfaceSet meet_interfaces(const TypeKlassPtr* other) const;\n@@ -1614,0 +1673,4 @@\n+  bool is_same_java_type_as(const TypePtr* other) const {\n+    return is_same_java_type_as_helper(other->is_klassptr());\n+  }\n+\n@@ -1617,1 +1680,1 @@\n-  virtual bool is_same_java_type_as(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n+  virtual bool is_same_java_type_as_helper(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n@@ -1623,0 +1686,1 @@\n+  virtual bool klass_is_exact()    const { return _ptr == Constant; }\n@@ -1624,4 +1688,2 @@\n-  bool klass_is_exact()    const { return _ptr == Constant; }\n-\n-  static const TypeKlassPtr* make(ciKlass* klass);\n-  static const TypeKlassPtr* make(PTR ptr, ciKlass* klass, Offset offset);\n+  static const TypeKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, Offset offset, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -1646,1 +1708,30 @@\n-  bool can_be_inline_array() const { return (_klass == NULL || _klass->can_be_inline_array_klass()); }\n+  virtual bool can_be_inline_array() const { ShouldNotReachHere(); return false; }\n+  virtual const TypeKlassPtr* try_improve() const { return this; }\n+\n+#ifndef PRODUCT\n+  virtual void dump2( Dict &d, uint depth, outputStream *st ) const; \/\/ Specialized per-Type dumping\n+#endif\n+private:\n+  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n+    return is_meet_subtype_of_helper(other->is_klassptr(), klass_is_exact(), other->is_klassptr()->klass_is_exact());\n+  }\n+\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n+  virtual const InterfaceSet interfaces() const {\n+    return _interfaces;\n+  };\n+\n+  const TypeKlassPtr* is_reference_type(const Type* other) const {\n+    return other->isa_klassptr();\n+  }\n+\n+  const TypeAryKlassPtr* is_array_type(const TypeKlassPtr* other) const {\n+    return other->isa_aryklassptr();\n+  }\n+\n+  const TypeInstKlassPtr* is_instance_type(const TypeKlassPtr* other) const {\n+    return other->isa_instklassptr();\n+  }\n@@ -1652,2 +1743,3 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flatten_array)\n-    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset), _flatten_array(flatten_array) {\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, Offset offset, bool flatten_array)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, interfaces, offset), _flatten_array(flatten_array) {\n+    assert(klass->is_instance_klass() && (!klass->is_loaded() || !klass->is_interface()), \"\");\n@@ -1663,3 +1755,1 @@\n-    if (klass()->is_interface()) {\n-      return Compile::current()->env()->Object_klass();\n-    }\n+    assert(!klass()->is_interface(), \"\");\n@@ -1669,1 +1759,1 @@\n-  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n@@ -1675,2 +1765,9 @@\n-  static const TypeInstKlassPtr *make(ciKlass* k) {\n-    return make(TypePtr::Constant, k, Offset(0), false);\n+  static const TypeInstKlassPtr *make(ciKlass* k, InterfaceHandling interface_handling) {\n+    InterfaceSet interfaces = TypePtr::interfaces(k, true, true, false, interface_handling);\n+    return make(TypePtr::Constant, k, interfaces, Offset(0));\n+  }\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, Offset offset, bool flatten_array = false);\n+\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, Offset offset) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(ptr, k, interfaces, offset);\n@@ -1678,1 +1775,0 @@\n-  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, Offset offset, bool flatten_array = false);\n@@ -1694,1 +1790,1 @@\n-  bool is_interface() const { return klass()->is_interface(); }\n+  virtual const TypeKlassPtr* try_improve() const;\n@@ -1699,0 +1795,2 @@\n+  virtual bool can_be_inline_array() const;\n+\n@@ -1702,4 +1800,2 @@\n-\n-#ifndef PRODUCT\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const; \/\/ Specialized per-Type dumping\n-#endif\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n@@ -1711,0 +1807,3 @@\n+  friend class Type;\n+  friend class TypePtr;\n+\n@@ -1716,0 +1815,1 @@\n+  static const InterfaceSet* _array_interfaces;\n@@ -1717,1 +1817,2 @@\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _null_free(null_free) {\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, *_array_interfaces, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _null_free(null_free) {\n+    assert(klass == NULL || klass->is_type_array_klass() || klass->is_flat_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"\");\n@@ -1721,0 +1822,1 @@\n+  \/\/ Only guaranteed non null for array of basic types\n@@ -1738,1 +1840,1 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool null_free);\n@@ -1740,1 +1842,1 @@\n-  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n@@ -1747,2 +1849,2 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset);\n-  static const TypeAryKlassPtr* make(ciKlass* klass);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling);\n+  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n@@ -1776,0 +1878,1 @@\n+  virtual bool can_be_inline_array() const;\n@@ -1780,0 +1883,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n@@ -1966,0 +2071,42 @@\n+\/\/ TODO 8293800 Remove\n+\/\/------------------------------TypeValue---------------------------------------\n+\/\/ Class of Inline Type Types\n+class TypeInlineType : public Type {\n+private:\n+  ciInlineKlass* _vk;\n+  TypePtr::InterfaceSet _interfaces;\n+  bool _larval;\n+\n+protected:\n+  TypeInlineType(ciInlineKlass* vk, TypePtr::InterfaceSet interfaces, bool larval)\n+          : Type(InlineType),\n+            _vk(vk), _interfaces(interfaces), _larval(larval) {\n+  }\n+\n+public:\n+  static const TypeInlineType* make(ciInlineKlass* vk, bool larval = false);\n+  virtual ciInlineKlass* inline_klass() const { return _vk; }\n+  TypePtr::InterfaceSet interfaces() const { return _interfaces; }\n+  bool larval() const { return _larval; }\n+\n+  virtual bool eq(const Type* t) const;\n+  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual bool singleton(void) const;    \/\/ TRUE if type is a singleton\n+  virtual bool empty(void) const;        \/\/ TRUE if type is vacuous\n+\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n+\n+  virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }\n+  virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }\n+\n+  virtual bool maybe_null() const { return false; }\n+\n+  static const TypeInlineType* BOTTOM;\n+\n+#ifndef PRODUCT\n+  virtual void dump2(Dict &d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n+#endif\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":290,"deletions":143,"binary":false,"changes":433,"status":"modified"},{"patch":"@@ -641,1 +641,1 @@\n-  thread->print_stack();\n+  thread->print_jni_stack();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  thr->print_stack();\n+  thr->print_jni_stack();\n@@ -196,1 +196,1 @@\n-      thr->print_stack();\n+      thr->print_jni_stack();\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -586,1 +586,1 @@\n-    JvmtiEventController::set_user_enabled(this, (JavaThread*) NULL, (oop) NULL, event_type, enabled);\n+    JvmtiEventController::set_user_enabled(this, NULL, (oop) NULL, event_type, enabled);\n@@ -3527,1 +3527,1 @@\n-  if (!ik->access_flags().has_localvariable_table()) {\n+  if (!ik->has_localvariable_table()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false, self),\n+  : VM_BaseGetOrSetLocal(NULL, depth, index, type, _DEFAULT_VALUE, false, self),\n@@ -760,1 +760,1 @@\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true, self),\n+  : VM_BaseGetOrSetLocal(NULL, depth, index, type, value, true, self),\n@@ -823,1 +823,1 @@\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false, self)\n+  : VM_BaseGetOrSetLocal(NULL, depth, index, type, _DEFAULT_VALUE, false, self)\n@@ -832,1 +832,1 @@\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true, self)\n+  : VM_BaseGetOrSetLocal(NULL, depth, index, type, value, true, self)\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4412,10 +4412,3 @@\n-  if (scratch_class->access_flags().has_localvariable_table() !=\n-      the_class->access_flags().has_localvariable_table()) {\n-\n-    AccessFlags flags = the_class->access_flags();\n-    if (scratch_class->access_flags().has_localvariable_table()) {\n-      flags.set_has_localvariable_table();\n-    } else {\n-      flags.clear_has_localvariable_table();\n-    }\n-    the_class->set_access_flags(flags);\n+  if (scratch_class->has_localvariable_table() !=\n+      the_class->has_localvariable_table()) {\n+    the_class->set_has_localvariable_table(scratch_class->has_localvariable_table());\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -213,1 +213,3 @@\n-  if (h_name == NULL) return false;\n+  if (h_name == NULL) {\n+    return 0;\n+  }\n@@ -226,1 +228,3 @@\n-  if (h_name == NULL) return false;\n+  if (h_name == NULL) {\n+    return 0;\n+  }\n@@ -503,1 +507,1 @@\n-WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))\n+WB_ENTRY(jint, WB_G1CompletedConcurrentMarkCycles(JNIEnv* env, jobject o))\n@@ -506,5 +510,2 @@\n-    if (!g1h->concurrent_mark()->cm_thread()->in_progress()) {\n-      g1h->collect(GCCause::_wb_conc_mark);\n-      return true;\n-    }\n-    return false;\n+    G1ConcurrentMark* cm = g1h->concurrent_mark();\n+    return cm->completed_mark_cycles();\n@@ -512,1 +513,1 @@\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_G1StartMarkCycle: G1 GC is not enabled\");\n+  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_G1CompletedConcurrentMarkCycles: G1 GC is not enabled\");\n@@ -2626,0 +2627,1 @@\n+  {CC\"g1CompletedConcurrentMarkCycles\", CC\"()I\",      (void*)&WB_G1CompletedConcurrentMarkCycles},\n@@ -2632,1 +2634,0 @@\n-  {CC\"g1StartConcMarkCycle\",       CC\"()Z\",           (void*)&WB_G1StartMarkCycle  },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -551,7 +551,0 @@\n-  { \"ExtendedDTraceProbes\",         JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"UseContainerCpuShares\",        JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"PreferContainerQuotaForCPUCount\", JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"AliasLevel\",                   JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"UseCodeAging\",                 JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"PrintSharedDictionary\",          JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2680,1 +2680,1 @@\n-  sprintf(buf, \"reason%d\", reason);\n+  os::snprintf_checked(buf, sizeof(buf), \"reason%d\", reason);\n@@ -2690,1 +2690,1 @@\n-  sprintf(buf, \"action%d\", action);\n+  os::snprintf_checked(buf, sizeof(buf), \"action%d\", action);\n@@ -2813,1 +2813,1 @@\n-            sprintf(name, \"%s\/%s\/%s\",\n+            os::snprintf_checked(name, sizeof(name), \"%s\/%s\/%s\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,3 @@\n-    assert(field_holder() == ik, \"must be already initialized to this class\");\n+    \/\/ If the class is a scratch class, the constant pool points to the original class,\n+    \/\/ but that's ok because of constant pool merging.\n+    assert(field_holder() == ik || ik->is_scratch_class(), \"must be already initialized to this class\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1609,1 +1609,1 @@\n-  \/\/ if (error) { tty->cr(); print_on((JavaThread*)nullptr, tty); }\n+  \/\/ if (error) { tty->cr(); print_on(static_cast<JavaThread*>(nullptr), tty); }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  product(bool, UsePolyIntrinsics, false, DIAGNOSTIC,                       \\\n+  product(bool, UsePoly1305Intrinsics, false, DIAGNOSTIC,                   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -1677,0 +1678,19 @@\n+\/\/ Print current stack trace for checked JNI warnings and JNI fatal errors.\n+\/\/ This is the external format, selecting the platform or vthread\n+\/\/ as applicable, and allowing for a native-only stack.\n+void JavaThread::print_jni_stack() {\n+  assert(this == JavaThread::current(), \"Can't print stack of other threads\");\n+  if (!has_last_Java_frame()) {\n+    ResourceMark rm(this);\n+    char* buf = NEW_RESOURCE_ARRAY_RETURN_NULL(char, O_BUFLEN);\n+    if (buf == nullptr) {\n+      tty->print_cr(\"Unable to print native stack - out of memory\");\n+      return;\n+    }\n+    frame f = os::current_frame();\n+    VMError::print_native_stack(tty, f, this, true \/*print_source_info *\/,\n+                                -1 \/* max stack *\/, buf, O_BUFLEN);\n+  } else {\n+    print_active_stack_on(tty);\n+  }\n+}\n@@ -1710,0 +1730,50 @@\n+void JavaThread::print_vthread_stack_on(outputStream* st) {\n+  assert(is_vthread_mounted(), \"Caller should have checked this\");\n+  assert(has_last_Java_frame(), \"must be\");\n+\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  RegisterMap reg_map(this,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::include);\n+  ContinuationEntry* cont_entry = last_continuation();\n+  vframe* start_vf = last_java_vframe(&reg_map);\n+  int count = 0;\n+  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+    \/\/ Watch for end of vthread stack\n+    if (Continuation::is_continuation_enterSpecial(f->fr())) {\n+      assert(cont_entry == Continuation::get_continuation_entry_for_entry_frame(this, f->fr()), \"\");\n+      if (cont_entry->is_virtual_thread()) {\n+        break;\n+      }\n+      cont_entry = cont_entry->parent();\n+    }\n+    if (f->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(f);\n+      java_lang_Throwable::print_stack_element(st, jvf->method(), jvf->bci());\n+\n+      \/\/ Print out lock information\n+      if (JavaMonitorsInStackTrace) {\n+        jvf->print_lock_info_on(st, count);\n+      }\n+    } else {\n+      \/\/ Ignore non-Java frames\n+    }\n+\n+    \/\/ Bail-out case for too deep stacks if MaxJavaStackTraceDepth > 0\n+    count++;\n+    if (MaxJavaStackTraceDepth > 0 && MaxJavaStackTraceDepth == count) return;\n+  }\n+}\n+\n+void JavaThread::print_active_stack_on(outputStream* st) {\n+  if (is_vthread_mounted()) {\n+    print_vthread_stack_on(st);\n+  } else {\n+    print_stack_on(st);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -830,1 +830,1 @@\n-    JavaThread* current = (JavaThread*)((intptr_t)env - in_bytes(jni_environment_offset()));\n+    JavaThread* current = reinterpret_cast<JavaThread*>(((intptr_t)env - in_bytes(jni_environment_offset())));\n@@ -946,0 +946,1 @@\n+  \/\/ These variants print carrier\/platform thread information only.\n@@ -948,0 +949,8 @@\n+  \/\/ This prints the currently mounted virtual thread.\n+  void print_vthread_stack_on(outputStream* st);\n+  \/\/ This prints the active stack: either carrier\/platform or virtual.\n+  void print_active_stack_on(outputStream* st);\n+  \/\/ Print current stack trace for checked JNI warnings and JNI fatal errors.\n+  \/\/ This is the external format from above, but selecting the platform\n+  \/\/ or vthread as applicable.\n+  void print_jni_stack();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -391,1 +391,1 @@\n-    JavaThread* const owner = (JavaThread*) m->owner_raw();\n+    JavaThread* const owner = static_cast<JavaThread*>(m->owner_raw());\n@@ -448,1 +448,1 @@\n-    current->print_stack_on(&ss);\n+    current->print_active_stack_on(&ss);\n@@ -463,1 +463,1 @@\n-      current->print_stack_on(&info_stream);\n+      current->print_active_stack_on(&info_stream);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1071,1 +1071,1 @@\n-  nonstatic_field(CompileTask,                 _compile_id,                                   uint)                                  \\\n+  nonstatic_field(CompileTask,                 _compile_id,                                   int)                                   \\\n@@ -1883,1 +1883,1 @@\n-  declare_c2_type(VectorTestNode, Node)                                   \\\n+  declare_c2_type(VectorTestNode, CmpNode)                                \\\n@@ -2106,1 +2106,0 @@\n-  declare_constant(JVM_ACC_PROMOTED_FLAGS)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  \/\/ Klass* and Method* flags\n+  \/\/ Method* flags\n@@ -78,2 +78,0 @@\n-  JVM_ACC_PROMOTED_FLAGS          = 0x00400000,     \/\/ flags promoted from methods to the holding klass\n-\n@@ -161,1 +159,1 @@\n-  \/\/ Klass* and Method* flags\n+  \/\/ Method* flags\n@@ -189,1 +187,0 @@\n-  void add_promoted_flags(jint flags)   { _flags |= (flags & JVM_ACC_PROMOTED_FLAGS); }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include <type_traits>\n@@ -133,0 +134,1 @@\n+#define SSIZE_PLUS_FORMAT        \"%+\"         PRIdPTR\n@@ -1311,0 +1313,4 @@\n+\/\/ Converts any type T to a reference type.\n+template<typename T>\n+std::add_rvalue_reference_t<T> declval() noexcept;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n- * ObjectOutputStream:\n+ * {@link ObjectOutputStream}:\n@@ -121,10 +121,10 @@\n- * <pre>\n- *      FileInputStream fis = new FileInputStream(\"t.tmp\");\n- *      ObjectInputStream ois = new ObjectInputStream(fis);\n- *\n- *      int i = ois.readInt();\n- *      String today = (String) ois.readObject();\n- *      Date date = (Date) ois.readObject();\n- *\n- *      ois.close();\n- * <\/pre>\n+ * {@snippet lang=\"java\" :\n+ *     try (FileInputStream fis = new FileInputStream(\"t.tmp\");\n+ *          ObjectInputStream ois = new ObjectInputStream(fis)) {\n+ *         String label = (String) ois.readObject();\n+ *         LocalDateTime dateTime = (LocalDateTime) ois.readObject();\n+ *         \/\/ Use label and dateTime\n+ *     } catch (Exception ex) {\n+ *         \/\/ handle exception\n+ *     }\n+ * }\n@@ -145,8 +145,8 @@\n- * <pre>\n- * private void writeObject(java.io.ObjectOutputStream stream)\n- *     throws IOException;\n- * private void readObject(java.io.ObjectInputStream stream)\n- *     throws IOException, ClassNotFoundException;\n- * private void readObjectNoData()\n- *     throws ObjectStreamException;\n- * <\/pre>\n+ * {@snippet lang=\"java\":\n+ *     private void writeObject(java.io.ObjectOutputStream stream)\n+ *         throws IOException;\n+ *     private void readObject(java.io.ObjectInputStream stream)\n+ *         throws IOException, ClassNotFoundException;\n+ *     private void readObjectNoData()\n+ *         throws ObjectStreamException;\n+ * }\n@@ -781,1 +781,1 @@\n-     * <pre>\n+     * {@snippet lang=\"java\":\n@@ -783,1 +783,1 @@\n-     * <\/pre>\n+     * }\n@@ -843,1 +843,1 @@\n-     * <pre>\n+     * {@snippet lang=\"java\":\n@@ -845,1 +845,1 @@\n-     * <\/pre>\n+     * }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -69,12 +69,10 @@\n- * ObjectInputStream:\n- * <br>\n- * <pre>\n- *      FileOutputStream fos = new FileOutputStream(\"t.tmp\");\n- *      ObjectOutputStream oos = new ObjectOutputStream(fos);\n- *\n- *      oos.writeInt(12345);\n- *      oos.writeObject(\"Today\");\n- *      oos.writeObject(new Date());\n- *\n- *      oos.close();\n- * <\/pre>\n+ * {@link ObjectInputStream}:\n+ * {@snippet lang=\"java\":\n+ *      try (FileOutputStream fos = new FileOutputStream(\"t.tmp\");\n+ *           ObjectOutputStream oos = new ObjectOutputStream(fos)) {\n+ *          oos.writeObject(\"Today\");\n+ *          oos.writeObject(LocalDateTime.now());\n+ *      } catch (Exception ex) {\n+ *          \/\/ handle exception\n+ *      }\n+ * }\n@@ -86,9 +84,8 @@\n- * <br>\n- * <pre>\n- * private void readObject(java.io.ObjectInputStream stream)\n- *     throws IOException, ClassNotFoundException;\n- * private void writeObject(java.io.ObjectOutputStream stream)\n- *     throws IOException\n- * private void readObjectNoData()\n- *     throws ObjectStreamException;\n- * <\/pre>\n+ * {@snippet lang=\"java\":\n+ *     private void readObject(java.io.ObjectInputStream stream)\n+ *         throws IOException, ClassNotFoundException;\n+ *     private void writeObject(java.io.ObjectOutputStream stream)\n+ *         throws IOException;\n+ *     private void readObjectNoData()\n+ *         throws ObjectStreamException;\n+ * }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-        LambdaForm lform = new LambdaForm(ARG_LIMIT, names, result, kind);\n+        LambdaForm lform = LambdaForm.create(ARG_LIMIT, names, result, kind);\n@@ -849,1 +849,1 @@\n-            form = new LambdaForm(ARG_LIMIT, names, RESULT);\n+            form = LambdaForm.create(ARG_LIMIT, names, RESULT);\n@@ -851,1 +851,1 @@\n-            form = new LambdaForm(ARG_LIMIT, names, RESULT, kind);\n+            form = LambdaForm.create(ARG_LIMIT, names, RESULT, kind);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -337,11 +337,2 @@\n-    LambdaForm(int arity, Name[] names, int result) {\n-        this(arity, names, result, \/*forceInline=*\/true, \/*customized=*\/null, Kind.GENERIC);\n-    }\n-    LambdaForm(int arity, Name[] names, int result, Kind kind) {\n-        this(arity, names, result, \/*forceInline=*\/true, \/*customized=*\/null, kind);\n-    }\n-    LambdaForm(int arity, Name[] names, int result, boolean forceInline, MethodHandle customized) {\n-        this(arity, names, result, forceInline, customized, Kind.GENERIC);\n-    }\n-    LambdaForm(int arity, Name[] names, int result, boolean forceInline, MethodHandle customized, Kind kind) {\n-        assert(namesOK(arity, names));\n+    \/\/ private version that doesn't do checks or defensive copies\n+    private LambdaForm(int arity, int result, boolean forceInline, MethodHandle customized, Name[] names, Kind kind) {\n@@ -349,2 +340,1 @@\n-        this.result = fixResult(result, names);\n-        this.names = names.clone();\n+        this.result = result;\n@@ -353,0 +343,1 @@\n+        this.names = names;\n@@ -354,5 +345,15 @@\n-        int maxOutArity = normalize();\n-        if (maxOutArity > MethodType.MAX_MH_INVOKER_ARITY) {\n-            \/\/ Cannot use LF interpreter on very high arity expressions.\n-            assert(maxOutArity <= MethodType.MAX_JVM_ARITY);\n-            compileToBytecode();\n+        this.vmentry = null;\n+        this.isCompiled = false;\n+    }\n+\n+    \/\/ root factory pre\/post processing and calls simple cosntructor\n+    private static LambdaForm create(int arity, Name[] names, int result, boolean forceInline, MethodHandle customized, Kind kind) {\n+        names = names.clone();\n+        assert(namesOK(arity, names));\n+        result = fixResult(result, names);\n+\n+        boolean canInterpret = normalizeNames(arity, names);\n+        LambdaForm form = new LambdaForm(arity, result, forceInline, customized, names, kind);\n+        assert(form.nameRefsAreLegal());\n+        if (!canInterpret) {\n+            form.compileToBytecode();\n@@ -360,0 +361,1 @@\n+        return form;\n@@ -361,2 +363,15 @@\n-    LambdaForm(int arity, Name[] names) {\n-        this(arity, names, LAST_RESULT, \/*forceInline=*\/true, \/*customized=*\/null, Kind.GENERIC);\n+\n+    \/\/ derived factories with defaults\n+    private static final int DEFAULT_RESULT = LAST_RESULT;\n+    private static final boolean DEFAULT_FORCE_INLINE = true;\n+    private static final MethodHandle DEFAULT_CUSTOMIZED = null;\n+    private static final Kind DEFAULT_KIND = Kind.GENERIC;\n+\n+    static LambdaForm create(int arity, Name[] names, int result) {\n+        return create(arity, names, result, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, DEFAULT_KIND);\n+    }\n+    static LambdaForm create(int arity, Name[] names, int result, Kind kind) {\n+        return create(arity, names, result, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, kind);\n+    }\n+    static LambdaForm create(int arity, Name[] names) {\n+        return create(arity, names, DEFAULT_RESULT, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, DEFAULT_KIND);\n@@ -364,2 +379,2 @@\n-    LambdaForm(int arity, Name[] names, Kind kind) {\n-        this(arity, names, LAST_RESULT, \/*forceInline=*\/true, \/*customized=*\/null, kind);\n+    static LambdaForm create(int arity, Name[] names, Kind kind) {\n+        return create(arity, names, DEFAULT_RESULT, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, kind);\n@@ -367,2 +382,2 @@\n-    LambdaForm(int arity, Name[] names, boolean forceInline, Kind kind) {\n-        this(arity, names, LAST_RESULT, forceInline, \/*customized=*\/null, kind);\n+    static LambdaForm create(int arity, Name[] names, boolean forceInline, Kind kind) {\n+        return create(arity, names, DEFAULT_RESULT, forceInline, DEFAULT_CUSTOMIZED, kind);\n@@ -371,1 +386,1 @@\n-    private LambdaForm(MethodType mt) {\n+    private static LambdaForm createBlankForType(MethodType mt) {\n@@ -375,11 +390,10 @@\n-        this.arity = mt.parameterCount();\n-        this.result = (mt.returnType() == void.class || mt.returnType() == Void.class) ? -1 : arity;\n-        this.names = buildEmptyNames(arity, mt, result == -1);\n-        this.forceInline = true;\n-        this.customized = null;\n-        this.kind = Kind.ZERO;\n-        assert(nameRefsAreLegal());\n-        assert(isEmpty());\n-        String sig = null;\n-        assert(isValidSignature(sig = basicTypeSignature()));\n-        assert(sig.equals(basicTypeSignature())) : sig + \" != \" + basicTypeSignature();\n+        int arity = mt.parameterCount();\n+        int result = (mt.returnType() == void.class || mt.returnType() == Void.class) ? VOID_RESULT : arity;\n+        Name[] names = buildEmptyNames(arity, mt, result == VOID_RESULT);\n+        boolean canInterpret = normalizeNames(arity, names);\n+        LambdaForm form = new LambdaForm(arity, result, DEFAULT_FORCE_INLINE, DEFAULT_CUSTOMIZED, names, Kind.ZERO);\n+        assert(form.nameRefsAreLegal() && form.isEmpty() && isValidSignature(form.basicTypeSignature()));\n+        if (!canInterpret) {\n+            form.compileToBytecode();\n+        }\n+        return form;\n@@ -394,0 +408,1 @@\n+        assert(namesOK(arity, names));\n@@ -464,1 +479,1 @@\n-        LambdaForm customForm = new LambdaForm(arity, names, result, forceInline, mh, kind);\n+        LambdaForm customForm = LambdaForm.create(arity, names, result, forceInline, mh, kind);\n@@ -488,1 +503,1 @@\n-     *  @return maximum argument list length among the names (since we have to pass over them anyway)\n+     *  @return true if we can interpret\n@@ -490,1 +505,1 @@\n-    private int normalize() {\n+    private static boolean normalizeNames(int arity, Name[] names) {\n@@ -515,1 +530,0 @@\n-        assert(nameRefsAreLegal());\n@@ -530,2 +544,8 @@\n-        assert(nameRefsAreLegal());\n-        return maxOutArity;\n+\n+        \/\/ return true if we can interpret\n+        if (maxOutArity > MethodType.MAX_MH_INVOKER_ARITY) {\n+            \/\/ Cannot use LF interpreter on very high arity expressions.\n+            assert(maxOutArity <= MethodType.MAX_JVM_ARITY);\n+            return false;\n+        }\n+        return true;\n@@ -811,1 +831,1 @@\n-            prep = new LambdaForm(mtype);\n+            prep = LambdaForm.createBlankForType(mtype);\n@@ -1755,1 +1775,1 @@\n-                idForm = new LambdaForm(1, idNames, VOID_RESULT, Kind.IDENTITY);\n+                idForm = LambdaForm.create(1, idNames, VOID_RESULT, Kind.IDENTITY);\n@@ -1763,1 +1783,1 @@\n-                idForm = new LambdaForm(2, idNames, 1, Kind.IDENTITY);\n+                idForm = LambdaForm.create(2, idNames, 1, Kind.IDENTITY);\n@@ -1770,1 +1790,1 @@\n-                zeForm = new LambdaForm(1, zeNames, 1, Kind.ZERO);\n+                zeForm = LambdaForm.create(1, zeNames, 1, Kind.ZERO);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":66,"deletions":46,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Collections;\n@@ -1150,1 +1149,1 @@\n-        form = new LambdaForm(arity2, names2, result2);\n+        form = LambdaForm.create(arity2, names2, result2);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7971,1 +7971,1 @@\n-     * Finally, in all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n+     * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n@@ -7973,0 +7973,3 @@\n+     * <p>\n+     * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n+     * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2096,2 +2096,2 @@\n-        throw new WrongMethodTypeException(\"expected \" + accessModeType(ad.type) + \" but found \"\n-                + ad.symbolicMethodTypeExact);\n+        throw new WrongMethodTypeException(\"handle's method type \" + accessModeType(ad.type)\n+                + \" but found \" + ad.symbolicMethodTypeExact);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-            Env<AttrContext> packageEnv = isPkgInfo ? topEnv.dup(pd) : null;\n+            Env<AttrContext> packageEnv = null;\n@@ -367,0 +367,2 @@\n+                packageEnv = topEnv.dup(pd != null ? pd : tree);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2043,4 +2043,4 @@\n-                    if (inits.isMember(sym.adr) || !uninits.isMember(sym.adr)) {\n-                        \/\/assignment targeting an effectively final variable makes the\n-                        \/\/variable lose its status of effectively final if the variable\n-                        \/\/is definitely assigned or _not_ definitively unassigned\n+                    if (!uninits.isMember(sym.adr)) {\n+                        \/\/assignment targeting an effectively final variable\n+                        \/\/makes the variable lose its status of effectively final\n+                        \/\/if the variable is _not_ definitively unassigned\n@@ -2048,0 +2048,2 @@\n+                    } else {\n+                        uninit(sym);\n@@ -2049,1 +2051,0 @@\n-                    uninit(sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4232,11 +4232,27 @@\n-            return diags.create(dkind, log.currentSource(), pos,\n-                      \"cant.apply.symbol\",\n-                      compactMethodDiags ?\n-                              d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null,\n-                      kindName(ws),\n-                      names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n-                      methodArguments(ws.type.getParameterTypes()),\n-                      methodArguments(argtypes),\n-                      kindName(ws.owner),\n-                      ws.owner.type,\n-                      c.snd);\n+\n+            \/\/ If the problem is due to type arguments, then the method parameters aren't relevant,\n+            \/\/ so use the error message that omits them to avoid confusion.\n+            switch (c.snd.getCode()) {\n+                case \"compiler.misc.wrong.number.type.args\":\n+                case \"compiler.misc.explicit.param.do.not.conform.to.bounds\":\n+                    return diags.create(dkind, log.currentSource(), pos,\n+                              \"cant.apply.symbol.noargs\",\n+                              compactMethodDiags ?\n+                                      d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null,\n+                              kindName(ws),\n+                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              ws.owner.type,\n+                              c.snd);\n+                default:\n+                    return diags.create(dkind, log.currentSource(), pos,\n+                              \"cant.apply.symbol\",\n+                              compactMethodDiags ?\n+                                      d -> MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd) : null,\n+                              kindName(ws),\n+                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              methodArguments(ws.type.getParameterTypes()),\n+                              methodArguments(argtypes),\n+                              kindName(ws.owner),\n+                              ws.owner.type,\n+                              c.snd);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2246,1 +2246,2 @@\n-        long flags = adjustFieldFlags(nextChar());\n+        char rawFlags = nextChar();\n+        long flags = adjustFieldFlags(rawFlags);\n@@ -2251,0 +2252,3 @@\n+        if (Integer.bitCount(rawFlags & (PUBLIC | PRIVATE | PROTECTED)) > 1 ||\n+            Integer.bitCount(rawFlags & (FINAL | VOLATILE)) > 1)\n+            throw badClassFile(\"illegal.flag.combo\", Flags.toString((long)rawFlags), \"field\", v);\n@@ -2257,1 +2261,2 @@\n-        long flags = adjustMethodFlags(nextChar());\n+        char rawFlags = nextChar();\n+        long flags = adjustMethodFlags(rawFlags);\n@@ -2313,0 +2318,2 @@\n+        if (Integer.bitCount(rawFlags & (PUBLIC | PRIVATE | PROTECTED)) > 1)\n+            throw badClassFile(\"illegal.flag.combo\", Flags.toString((long)rawFlags), \"method\", m);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.nio.file.FileSystemNotFoundException;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.ReadOnlyFileSystemException;\n@@ -611,0 +614,9 @@\n+        return parse(filename, content, false);\n+    }\n+\n+    \/** Parse contents of input stream.\n+     *  @param filename     The name of the file from which input stream comes.\n+     *  @param content      The characters to be parsed.\n+     *  @param silent       true if TaskListeners should not be notified\n+     *\/\n+    private JCCompilationUnit parse(JavaFileObject filename, CharSequence content, boolean silent) {\n@@ -617,1 +629,1 @@\n-            if (!taskListener.isEmpty()) {\n+            if (!taskListener.isEmpty() && !silent) {\n@@ -633,1 +645,1 @@\n-        if (content != null && !taskListener.isEmpty()) {\n+        if (content != null && !taskListener.isEmpty() && !silent) {\n@@ -1676,1 +1688,5 @@\n-            } catch (IOException ex) {\n+            } catch (IOException\n+                    | UncheckedIOException\n+                    | FileSystemNotFoundException\n+                    | InvalidPathException\n+                    | ReadOnlyFileSystemException ex) {\n@@ -1803,1 +1819,1 @@\n-            JCTree.JCCompilationUnit t = parse(fo, fo.getCharContent(false));\n+            JCTree.JCCompilationUnit t = parse(fo, fo.getCharContent(false), true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -387,2 +387,1 @@\n-        java.util.List<Processor> pl = Collections.emptyList();\n-        return pl.iterator();\n+        return Collections.emptyIterator();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -236,0 +236,5 @@\n+# 0: symbol kind, 1: name, 2: symbol kind, 3: type, 4: message segment\n+compiler.err.cant.apply.symbol.noargs=\\\n+    {0} {1} in {2} {3} cannot be applied to given types;\\n\\\n+    reason: {4}\n+\n@@ -2514,0 +2519,3 @@\n+compiler.misc.illegal.flag.combo=\\\n+    class file contains illegal flag combination {0} for {1} {2}\n+\n@@ -3349,1 +3357,1 @@\n-    no tag name after '@'\n+    no tag name after ''@''\n@@ -3616,1 +3624,1 @@\n-    {0} {1} in module {2} is not indirectly exported using 'requires transitive'\n+    {0} {1} in module {2} is not indirectly exported using ''requires transitive''\n@@ -3678,1 +3686,1 @@\n-    (as it is not listed in its 'permits' clause)\n+    (as it is not listed in its ''permits'' clause)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1736,1 +1736,1 @@\n-                     (gdata->jvm, (void **)&jvmti, JVMTI_VERSION_1);\n+                     (gdata->jvm, (void **)&jvmti, JVMTI_VERSION);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java 8301665 generic-all\n@@ -84,1 +85,0 @@\n-gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293,8298073 macosx-x64,macosx-aarch64\n@@ -103,0 +103,1 @@\n+runtime\/StackGuardPages\/TestStackGuardPages.java 8293452 linux-all\n@@ -185,0 +186,1 @@\n+vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java 8288911 macosx-x64\n@@ -200,0 +202,4 @@\n+vmTestbase\/nsk\/stress\/strace\/strace002.java 8288912 macosx-x64,windows-x64\n+vmTestbase\/nsk\/stress\/strace\/strace003.java 8297824 macosx-x64,windows-x64\n+vmTestbase\/nsk\/stress\/strace\/strace004.java 8297824 macosx-x64,windows-x64\n+vmTestbase\/nsk\/monitoring\/ThreadMXBean\/ThreadInfo\/Multi\/Multi005\/TestDescription.java 8076494 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1117,0 +1117,5 @@\n+    public static final String VECTOR_TEST = PREFIX + \"VECTOR_TEST\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_TEST, \"VectorTest\");\n+    }\n+\n@@ -1202,0 +1207,10 @@\n+    public static final String XOR3_NEON = PREFIX + \"XOR3_NEON\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(XOR3_NEON, \"veor3_neon\");\n+    }\n+\n+    public static final String XOR3_SVE = PREFIX + \"XOR3_SVE\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(XOR3_SVE, \"veor3_sve\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+                    \"UseRVV\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-        Asserts.assertEQ(nsfe.getMessage(), \"x\");\n+        Asserts.assertEQ(nsfe.getMessage(), \"Class compiler.valhalla.inlinetypes.PointN does not have member field 'int x'\");\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+    jdk\/internal\/util \\\n@@ -635,3 +636,0 @@\n-    sun\/security\/provider\/PolicyParser\/ExtDirs.java \\\n-    sun\/security\/provider\/PolicyParser\/ExtDirsChange.java \\\n-    sun\/security\/provider\/PolicyParser\/ExtDirsDefaultPolicy.java \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+tools\/javac\/Diagnostics\/8043251\/T8043251.java                                   8301662    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.regex.*;\n@@ -50,0 +51,2 @@\n+     * -checkformats\n+     *      validate MessageFormat patterns in resource bundles\n@@ -74,0 +77,1 @@\n+        boolean checkFormats = false;\n@@ -79,0 +83,1 @@\n+                checkFormats = true;\n@@ -84,0 +89,1 @@\n+                System.err.println(\"  -checkformats      validate MessageFormat patterns in resource bundles\");\n@@ -92,0 +98,2 @@\n+                else if (arg.equalsIgnoreCase(\"-checkformats\"))\n+                    checkFormats = true;\n@@ -109,0 +117,3 @@\n+        if (checkFormats)\n+            checkFormats(getMessageFormatBundles());\n+\n@@ -315,0 +326,103 @@\n+    void checkFormats(List<ResourceBundle> messageFormatBundles) {\n+        for (ResourceBundle bundle : messageFormatBundles) {\n+            for (String key : bundle.keySet()) {\n+                final String pattern = bundle.getString(key);\n+                try {\n+                    validateMessageFormatPattern(pattern);\n+                } catch (IllegalArgumentException e) {\n+                    error(\"Invalid MessageFormat pattern for resource \\\"\"\n+                        + key + \"\\\": \" + e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Do some basic validation of a {@link java.text.MessageFormat} format string.\n+     *\n+     * <p>\n+     * This checks for balanced braces and unnecessary quoting.\n+     * Code cut, pasted, &amp; simplified from {@link java.text.MessageFormat#applyPattern}.\n+     *\n+     * @throws IllegalArgumentException if {@code pattern} is invalid\n+     * @throws IllegalArgumentException if {@code pattern} is null\n+     *\/\n+    public static void validateMessageFormatPattern(String pattern) {\n+\n+        \/\/ Check for null\n+        if (pattern == null)\n+            throw new IllegalArgumentException(\"null pattern\");\n+\n+        \/\/ Replicate the quirky lexical analysis of MessageFormat's parsing algorithm\n+        final int SEG_RAW = 0;\n+        final int SEG_INDEX = 1;\n+        final int SEG_TYPE = 2;\n+        final int SEG_MODIFIER = 3;\n+        int part = SEG_RAW;\n+        int braceStack = 0;\n+        int quotedStartPos = -1;\n+        for (int i = 0; i < pattern.length(); i++) {\n+            final char ch = pattern.charAt(i);\n+            if (part == SEG_RAW) {\n+                if (ch == '\\'') {\n+                    if (i + 1 < pattern.length() && pattern.charAt(i + 1) == '\\'')\n+                        i++;\n+                    else if (quotedStartPos == -1)\n+                        quotedStartPos = i;\n+                    else {\n+                        validateMessageFormatQuoted(pattern.substring(quotedStartPos + 1, i));\n+                        quotedStartPos = -1;\n+                    }\n+                } else if (ch == '{' && quotedStartPos == -1)\n+                    part = SEG_INDEX;\n+                continue;\n+            }\n+            if (quotedStartPos != -1) {\n+                if (ch == '\\'') {\n+                    validateMessageFormatQuoted(pattern.substring(quotedStartPos + 1, i));\n+                    quotedStartPos = -1;\n+                }\n+                continue;\n+            }\n+            switch (ch) {\n+            case ',':\n+                if (part < SEG_MODIFIER)\n+                    part++;\n+                break;\n+            case '{':\n+                braceStack++;\n+                break;\n+            case '}':\n+                if (braceStack == 0)\n+                    part = SEG_RAW;\n+                else\n+                    braceStack--;\n+                break;\n+            case '\\'':\n+                quotedStartPos = i;\n+                break;\n+            default:\n+                break;\n+            }\n+        }\n+        if (part != SEG_RAW)\n+            throw new IllegalArgumentException(\"unmatched braces\");\n+        if (quotedStartPos != -1)\n+            throw new IllegalArgumentException(\"unmatched quote starting at offset \" + quotedStartPos);\n+    }\n+\n+    \/**\n+     * Validate the content of a quoted substring in a {@link java.text.MessageFormat} pattern.\n+     *\n+     * <p>\n+     * We expect this content to contain at least one special character. Otherwise,\n+     * it was probably meant to be something in single quotes but somebody forgot\n+     * to escape the single quotes by doulbing them; and even if intentional,\n+     * it's still bogus because the single quotes are just going to get discarded\n+     * and so they were unnecessary in the first place.\n+     *\/\n+    static void validateMessageFormatQuoted(String quoted) {\n+        if (quoted.matches(\"[^'{},]+\"))\n+            throw new IllegalArgumentException(\"unescaped single quotes around \\\"\" + quoted + \"\\\"\");\n+    }\n+\n@@ -408,0 +522,14 @@\n+    \/**\n+     * Get resource bundles containing MessageFormat strings.\n+     *\/\n+    List<ResourceBundle> getMessageFormatBundles() {\n+        Module jdk_compiler = ModuleLayer.boot().findModule(\"jdk.compiler\").get();\n+        List<ResourceBundle> results = new ArrayList<>();\n+        for (String name : new String[]{\"compiler\", \"launcher\"}) {\n+            ResourceBundle b =\n+                    ResourceBundle.getBundle(\"com.sun.tools.javac.resources.\" + name, jdk_compiler);\n+            results.add(b);\n+        }\n+        return results;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+compiler.misc.illegal.flag.combo                        # ClassReader\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+\n@@ -183,0 +184,44 @@\n+  public native int g1CompletedConcurrentMarkCycles();\n+\n+  \/\/ Perform a complete concurrent GC cycle, using concurrent GC breakpoints.\n+  \/\/ Completes any in-progress cycle before performing the requested cycle.\n+  \/\/ Returns true if the cycle completed successfully.  If the cycle was not\n+  \/\/ successful (e.g. it was aborted), then throws RuntimeException if\n+  \/\/ errorIfFail is true, returning false otherwise.\n+  public boolean g1RunConcurrentGC(boolean errorIfFail) {\n+    try {\n+      \/\/ Take control, waiting until any in-progress cycle completes.\n+      concurrentGCAcquireControl();\n+      int count = g1CompletedConcurrentMarkCycles();\n+      concurrentGCRunTo(AFTER_MARKING_STARTED, false);\n+      concurrentGCRunToIdle();\n+      if (count < g1CompletedConcurrentMarkCycles()) {\n+        return true;\n+      } else if (errorIfFail) {\n+        throw new RuntimeException(\"Concurrent GC aborted\");\n+      } else {\n+        return false;\n+      }\n+    } finally {\n+      concurrentGCReleaseControl();\n+    }\n+  }\n+\n+  public void g1RunConcurrentGC() {\n+    g1RunConcurrentGC(true);\n+  }\n+\n+  \/\/ Start a concurrent GC cycle, using concurrent GC breakpoints.\n+  \/\/ The concurrent GC will continue in parallel with the caller.\n+  \/\/ Completes any in-progress cycle before starting the requested cycle.\n+  public void g1StartConcurrentGC() {\n+    try {\n+      \/\/ Take control, waiting until any in-progress cycle completes.\n+      concurrentGCAcquireControl();\n+      concurrentGCRunTo(AFTER_MARKING_STARTED, false);\n+    } finally {\n+      \/\/ Release control, permitting the cycle to complete.\n+      concurrentGCReleaseControl();\n+    }\n+  }\n+\n@@ -557,4 +602,0 @@\n-  \/\/ Method tries to start concurrent mark cycle.\n-  \/\/ It returns false if CM Thread is always in concurrent cycle.\n-  public native boolean g1StartConcMarkCycle();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"}]}