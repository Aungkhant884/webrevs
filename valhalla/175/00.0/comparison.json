{"files":[{"patch":"@@ -663,0 +663,1 @@\n+fd60c3146a024037cdd9be34c645bb793995a7cc jdk-15+35\n@@ -664,0 +665,1 @@\n+b01985b4f88f554f97901e53e1ba314681dd9c19 jdk-16+10\n","filename":".hgtags","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3143,0 +3143,166 @@\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - byte[]  source+offset\n+  \/\/   c_rarg1   - int[]   SHA.state\n+  \/\/   c_rarg2   - int     offset\n+  \/\/   c_rarg3   - int     limit\n+  \/\/\n+  address generate_sha512_implCompress(bool multi_block, const char *name) {\n+    static const uint64_t round_consts[80] = {\n+      0x428A2F98D728AE22L, 0x7137449123EF65CDL, 0xB5C0FBCFEC4D3B2FL,\n+      0xE9B5DBA58189DBBCL, 0x3956C25BF348B538L, 0x59F111F1B605D019L,\n+      0x923F82A4AF194F9BL, 0xAB1C5ED5DA6D8118L, 0xD807AA98A3030242L,\n+      0x12835B0145706FBEL, 0x243185BE4EE4B28CL, 0x550C7DC3D5FFB4E2L,\n+      0x72BE5D74F27B896FL, 0x80DEB1FE3B1696B1L, 0x9BDC06A725C71235L,\n+      0xC19BF174CF692694L, 0xE49B69C19EF14AD2L, 0xEFBE4786384F25E3L,\n+      0x0FC19DC68B8CD5B5L, 0x240CA1CC77AC9C65L, 0x2DE92C6F592B0275L,\n+      0x4A7484AA6EA6E483L, 0x5CB0A9DCBD41FBD4L, 0x76F988DA831153B5L,\n+      0x983E5152EE66DFABL, 0xA831C66D2DB43210L, 0xB00327C898FB213FL,\n+      0xBF597FC7BEEF0EE4L, 0xC6E00BF33DA88FC2L, 0xD5A79147930AA725L,\n+      0x06CA6351E003826FL, 0x142929670A0E6E70L, 0x27B70A8546D22FFCL,\n+      0x2E1B21385C26C926L, 0x4D2C6DFC5AC42AEDL, 0x53380D139D95B3DFL,\n+      0x650A73548BAF63DEL, 0x766A0ABB3C77B2A8L, 0x81C2C92E47EDAEE6L,\n+      0x92722C851482353BL, 0xA2BFE8A14CF10364L, 0xA81A664BBC423001L,\n+      0xC24B8B70D0F89791L, 0xC76C51A30654BE30L, 0xD192E819D6EF5218L,\n+      0xD69906245565A910L, 0xF40E35855771202AL, 0x106AA07032BBD1B8L,\n+      0x19A4C116B8D2D0C8L, 0x1E376C085141AB53L, 0x2748774CDF8EEB99L,\n+      0x34B0BCB5E19B48A8L, 0x391C0CB3C5C95A63L, 0x4ED8AA4AE3418ACBL,\n+      0x5B9CCA4F7763E373L, 0x682E6FF3D6B2B8A3L, 0x748F82EE5DEFB2FCL,\n+      0x78A5636F43172F60L, 0x84C87814A1F0AB72L, 0x8CC702081A6439ECL,\n+      0x90BEFFFA23631E28L, 0xA4506CEBDE82BDE9L, 0xBEF9A3F7B2C67915L,\n+      0xC67178F2E372532BL, 0xCA273ECEEA26619CL, 0xD186B8C721C0C207L,\n+      0xEADA7DD6CDE0EB1EL, 0xF57D4F7FEE6ED178L, 0x06F067AA72176FBAL,\n+      0x0A637DC5A2C898A6L, 0x113F9804BEF90DAEL, 0x1B710B35131C471BL,\n+      0x28DB77F523047D84L, 0x32CAAB7B40C72493L, 0x3C9EBE0A15C9BEBCL,\n+      0x431D67C49C100D4CL, 0x4CC5D4BECB3E42B6L, 0x597F299CFC657E2AL,\n+      0x5FCB6FAB3AD6FAECL, 0x6C44198C4A475817L\n+    };\n+\n+    \/\/ Double rounds for sha512.\n+    #define sha512_dround(dr, i0, i1, i2, i3, i4, rc0, rc1, in0, in1, in2, in3, in4) \\\n+      if (dr < 36)                                                                   \\\n+        __ ld1(v##rc1, __ T2D, __ post(rscratch2, 16));                              \\\n+      __ addv(v5, __ T2D, v##rc0, v##in0);                                           \\\n+      __ ext(v6, __ T16B, v##i2, v##i3, 8);                                          \\\n+      __ ext(v5, __ T16B, v5, v5, 8);                                                \\\n+      __ ext(v7, __ T16B, v##i1, v##i2, 8);                                          \\\n+      __ addv(v##i3, __ T2D, v##i3, v5);                                             \\\n+      if (dr < 32) {                                                                 \\\n+        __ ext(v5, __ T16B, v##in3, v##in4, 8);                                      \\\n+        __ sha512su0(v##in0, __ T2D, v##in1);                                        \\\n+      }                                                                              \\\n+      __ sha512h(v##i3, __ T2D, v6, v7);                                             \\\n+      if (dr < 32)                                                                   \\\n+        __ sha512su1(v##in0, __ T2D, v##in2, v5);                                    \\\n+      __ addv(v##i4, __ T2D, v##i1, v##i3);                                          \\\n+      __ sha512h2(v##i3, __ T2D, v##i1, v##i0);                                      \\\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", name);\n+    address start = __ pc();\n+\n+    Register buf   = c_rarg0;\n+    Register state = c_rarg1;\n+    Register ofs   = c_rarg2;\n+    Register limit = c_rarg3;\n+\n+    __ stpd(v8, v9, __ pre(sp, -64));\n+    __ stpd(v10, v11, Address(sp, 16));\n+    __ stpd(v12, v13, Address(sp, 32));\n+    __ stpd(v14, v15, Address(sp, 48));\n+\n+    Label sha512_loop;\n+\n+    \/\/ load state\n+    __ ld1(v8, v9, v10, v11, __ T2D, state);\n+\n+    \/\/ load first 4 round constants\n+    __ lea(rscratch1, ExternalAddress((address)round_consts));\n+    __ ld1(v20, v21, v22, v23, __ T2D, __ post(rscratch1, 64));\n+\n+    __ BIND(sha512_loop);\n+    \/\/ load 128B of data into v12..v19\n+    __ ld1(v12, v13, v14, v15, __ T2D, __ post(buf, 64));\n+    __ ld1(v16, v17, v18, v19, __ T2D, __ post(buf, 64));\n+    __ rev64(v12, __ T16B, v12);\n+    __ rev64(v13, __ T16B, v13);\n+    __ rev64(v14, __ T16B, v14);\n+    __ rev64(v15, __ T16B, v15);\n+    __ rev64(v16, __ T16B, v16);\n+    __ rev64(v17, __ T16B, v17);\n+    __ rev64(v18, __ T16B, v18);\n+    __ rev64(v19, __ T16B, v19);\n+\n+    __ mov(rscratch2, rscratch1);\n+\n+    __ mov(v0, __ T16B, v8);\n+    __ mov(v1, __ T16B, v9);\n+    __ mov(v2, __ T16B, v10);\n+    __ mov(v3, __ T16B, v11);\n+\n+    sha512_dround( 0, 0, 1, 2, 3, 4, 20, 24, 12, 13, 19, 16, 17);\n+    sha512_dround( 1, 3, 0, 4, 2, 1, 21, 25, 13, 14, 12, 17, 18);\n+    sha512_dround( 2, 2, 3, 1, 4, 0, 22, 26, 14, 15, 13, 18, 19);\n+    sha512_dround( 3, 4, 2, 0, 1, 3, 23, 27, 15, 16, 14, 19, 12);\n+    sha512_dround( 4, 1, 4, 3, 0, 2, 24, 28, 16, 17, 15, 12, 13);\n+    sha512_dround( 5, 0, 1, 2, 3, 4, 25, 29, 17, 18, 16, 13, 14);\n+    sha512_dround( 6, 3, 0, 4, 2, 1, 26, 30, 18, 19, 17, 14, 15);\n+    sha512_dround( 7, 2, 3, 1, 4, 0, 27, 31, 19, 12, 18, 15, 16);\n+    sha512_dround( 8, 4, 2, 0, 1, 3, 28, 24, 12, 13, 19, 16, 17);\n+    sha512_dround( 9, 1, 4, 3, 0, 2, 29, 25, 13, 14, 12, 17, 18);\n+    sha512_dround(10, 0, 1, 2, 3, 4, 30, 26, 14, 15, 13, 18, 19);\n+    sha512_dround(11, 3, 0, 4, 2, 1, 31, 27, 15, 16, 14, 19, 12);\n+    sha512_dround(12, 2, 3, 1, 4, 0, 24, 28, 16, 17, 15, 12, 13);\n+    sha512_dround(13, 4, 2, 0, 1, 3, 25, 29, 17, 18, 16, 13, 14);\n+    sha512_dround(14, 1, 4, 3, 0, 2, 26, 30, 18, 19, 17, 14, 15);\n+    sha512_dround(15, 0, 1, 2, 3, 4, 27, 31, 19, 12, 18, 15, 16);\n+    sha512_dround(16, 3, 0, 4, 2, 1, 28, 24, 12, 13, 19, 16, 17);\n+    sha512_dround(17, 2, 3, 1, 4, 0, 29, 25, 13, 14, 12, 17, 18);\n+    sha512_dround(18, 4, 2, 0, 1, 3, 30, 26, 14, 15, 13, 18, 19);\n+    sha512_dround(19, 1, 4, 3, 0, 2, 31, 27, 15, 16, 14, 19, 12);\n+    sha512_dround(20, 0, 1, 2, 3, 4, 24, 28, 16, 17, 15, 12, 13);\n+    sha512_dround(21, 3, 0, 4, 2, 1, 25, 29, 17, 18, 16, 13, 14);\n+    sha512_dround(22, 2, 3, 1, 4, 0, 26, 30, 18, 19, 17, 14, 15);\n+    sha512_dround(23, 4, 2, 0, 1, 3, 27, 31, 19, 12, 18, 15, 16);\n+    sha512_dround(24, 1, 4, 3, 0, 2, 28, 24, 12, 13, 19, 16, 17);\n+    sha512_dround(25, 0, 1, 2, 3, 4, 29, 25, 13, 14, 12, 17, 18);\n+    sha512_dround(26, 3, 0, 4, 2, 1, 30, 26, 14, 15, 13, 18, 19);\n+    sha512_dround(27, 2, 3, 1, 4, 0, 31, 27, 15, 16, 14, 19, 12);\n+    sha512_dround(28, 4, 2, 0, 1, 3, 24, 28, 16, 17, 15, 12, 13);\n+    sha512_dround(29, 1, 4, 3, 0, 2, 25, 29, 17, 18, 16, 13, 14);\n+    sha512_dround(30, 0, 1, 2, 3, 4, 26, 30, 18, 19, 17, 14, 15);\n+    sha512_dround(31, 3, 0, 4, 2, 1, 27, 31, 19, 12, 18, 15, 16);\n+    sha512_dround(32, 2, 3, 1, 4, 0, 28, 24, 12,  0,  0,  0,  0);\n+    sha512_dround(33, 4, 2, 0, 1, 3, 29, 25, 13,  0,  0,  0,  0);\n+    sha512_dround(34, 1, 4, 3, 0, 2, 30, 26, 14,  0,  0,  0,  0);\n+    sha512_dround(35, 0, 1, 2, 3, 4, 31, 27, 15,  0,  0,  0,  0);\n+    sha512_dround(36, 3, 0, 4, 2, 1, 24,  0, 16,  0,  0,  0,  0);\n+    sha512_dround(37, 2, 3, 1, 4, 0, 25,  0, 17,  0,  0,  0,  0);\n+    sha512_dround(38, 4, 2, 0, 1, 3, 26,  0, 18,  0,  0,  0,  0);\n+    sha512_dround(39, 1, 4, 3, 0, 2, 27,  0, 19,  0,  0,  0,  0);\n+\n+    __ addv(v8, __ T2D, v8, v0);\n+    __ addv(v9, __ T2D, v9, v1);\n+    __ addv(v10, __ T2D, v10, v2);\n+    __ addv(v11, __ T2D, v11, v3);\n+\n+    if (multi_block) {\n+      __ add(ofs, ofs, 128);\n+      __ cmp(ofs, limit);\n+      __ br(Assembler::LE, sha512_loop);\n+      __ mov(c_rarg0, ofs); \/\/ return ofs\n+    }\n+\n+    __ st1(v8, v9, v10, v11, __ T2D, state);\n+\n+    __ ldpd(v14, v15, Address(sp, 48));\n+    __ ldpd(v12, v13, Address(sp, 32));\n+    __ ldpd(v10, v11, Address(sp, 16));\n+    __ ldpd(v8, v9, __ post(sp, 64));\n+\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -6053,0 +6219,4 @@\n+    if (UseSHA512Intrinsics) {\n+      StubRoutines::_sha512_implCompress   = generate_sha512_implCompress(false, \"sha512_implCompress\");\n+      StubRoutines::_sha512_implCompressMB = generate_sha512_implCompress(true,  \"sha512_implCompressMB\");\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -877,0 +877,51 @@\n+void C2_MacroAssembler::vprotate_imm(int opcode, BasicType etype, XMMRegister dst, XMMRegister src,\n+                                     int shift, int vector_len) {\n+  if (opcode == Op_RotateLeftV) {\n+    if (etype == T_INT) {\n+      evprold(dst, src, shift, vector_len);\n+    } else {\n+      assert(etype == T_LONG, \"expected type T_LONG\");\n+      evprolq(dst, src, shift, vector_len);\n+    }\n+  } else {\n+    assert(opcode == Op_RotateRightV, \"opcode should be Op_RotateRightV\");\n+    if (etype == T_INT) {\n+      evprord(dst, src, shift, vector_len);\n+    } else {\n+      assert(etype == T_LONG, \"expected type T_LONG\");\n+      evprorq(dst, src, shift, vector_len);\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::vprotate_var(int opcode, BasicType etype, XMMRegister dst, XMMRegister src,\n+                                     XMMRegister shift, int vector_len) {\n+  if (opcode == Op_RotateLeftV) {\n+    if (etype == T_INT) {\n+      evprolvd(dst, src, shift, vector_len);\n+    } else {\n+      assert(etype == T_LONG, \"expected type T_LONG\");\n+      evprolvq(dst, src, shift, vector_len);\n+    }\n+  } else {\n+    assert(opcode == Op_RotateRightV, \"opcode should be Op_RotateRightV\");\n+    if (etype == T_INT) {\n+      evprorvd(dst, src, shift, vector_len);\n+    } else {\n+      assert(etype == T_LONG, \"expected type T_LONG\");\n+      evprorvq(dst, src, shift, vector_len);\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::vshiftd_imm(int opcode, XMMRegister dst, int shift) {\n+  if (opcode == Op_RShiftVI) {\n+    psrad(dst, shift);\n+  } else if (opcode == Op_LShiftVI) {\n+    pslld(dst, shift);\n+  } else {\n+    assert((opcode == Op_URShiftVI),\"opcode should be Op_URShiftVI\");\n+    psrld(dst, shift);\n+  }\n+}\n+\n@@ -888,0 +939,11 @@\n+void C2_MacroAssembler::vshiftd_imm(int opcode, XMMRegister dst, XMMRegister nds, int shift, int vector_len) {\n+  if (opcode == Op_RShiftVI) {\n+    vpsrad(dst, nds, shift, vector_len);\n+  } else if (opcode == Op_LShiftVI) {\n+    vpslld(dst, nds, shift, vector_len);\n+  } else {\n+    assert((opcode == Op_URShiftVI),\"opcode should be Op_URShiftVI\");\n+    vpsrld(dst, nds, shift, vector_len);\n+  }\n+}\n+\n@@ -932,0 +994,11 @@\n+void C2_MacroAssembler::vshiftq_imm(int opcode, XMMRegister dst, int shift) {\n+  if (opcode == Op_RShiftVL) {\n+    psrlq(dst, shift);  \/\/ using srl to implement sra on pre-avs512 systems\n+  } else if (opcode == Op_LShiftVL) {\n+    psllq(dst, shift);\n+  } else {\n+    assert((opcode == Op_URShiftVL),\"opcode should be Op_URShiftVL\");\n+    psrlq(dst, shift);\n+  }\n+}\n+\n@@ -943,0 +1016,11 @@\n+void C2_MacroAssembler::vshiftq_imm(int opcode, XMMRegister dst, XMMRegister nds, int shift, int vector_len) {\n+  if (opcode == Op_RShiftVL) {\n+    evpsraq(dst, nds, shift, vector_len);\n+  } else if (opcode == Op_LShiftVL) {\n+    vpsllq(dst, nds, shift, vector_len);\n+  } else {\n+    assert((opcode == Op_URShiftVL),\"opcode should be Op_URShiftVL\");\n+    vpsrlq(dst, nds, shift, vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -3334,13 +3334,0 @@\n-operand no_rcx_RegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_no_rcx_reg));\n-  match(RegI);\n-  match(rax_RegI);\n-  match(rbx_RegI);\n-  match(rdx_RegI);\n-  match(rdi_RegI);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3556,10 +3543,0 @@\n-operand no_rcx_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_no_rcx_reg));\n-  match(RegL);\n-  match(rRegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -9020,20 +8997,2 @@\n-\/\/ ROL expand\n-instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{\n-  effect(KILL cr, USE_DEF dst);\n-\n-  format %{ \"roll    $dst\" %}\n-  opcode(0xD1, 0x0); \/* Opcode  D1 \/0 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{\n-  effect(USE_DEF dst, USE shift, KILL cr);\n-\n-  format %{ \"roll    $dst, $shift\" %}\n-  opcode(0xC1, 0x0); \/* Opcode C1 \/0 ib *\/\n-  ins_encode( reg_opc_imm(dst, shift) );\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)\n+\/\/ Rotate left by constant.\n+instruct rolI_imm(rRegI dst, immI8 shift, rFlagsReg cr)\n@@ -9041,2 +9000,3 @@\n-  effect(USE_DEF dst, USE shift, KILL cr);\n-\n+  predicate(n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft dst shift));\n+  effect(KILL cr);\n@@ -9044,34 +9004,2 @@\n-  opcode(0xD3, 0x0); \/* Opcode D3 \/0 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\/\/ end of ROL expand\n-\n-\/\/ Rotate Left by one\n-instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)\n-%{\n-  match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));\n-\n-  expand %{\n-    rolI_rReg_imm1(dst, cr);\n-  %}\n-%}\n-\n-\/\/ Rotate Left by 8-bit immediate\n-instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)\n-%{\n-  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x1f));\n-  match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));\n-\n-  expand %{\n-    rolI_rReg_imm8(dst, lshift, cr);\n-  %}\n-%}\n-\n-\/\/ Rotate Left by variable\n-instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)\n-%{\n-  match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));\n-\n-  expand %{\n-    rolI_rReg_CL(dst, shift, cr);\n+  ins_encode %{\n+    __ roll($dst$$Register, $shift$$constant);\n@@ -9079,0 +9007,1 @@\n+  ins_pipe(ialu_reg);\n@@ -9082,1 +9011,1 @@\n-instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)\n+instruct rolI_rReg_Var(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n@@ -9084,4 +9013,6 @@\n-  match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));\n-\n-  expand %{\n-    rolI_rReg_CL(dst, shift, cr);\n+  predicate(n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft dst shift));\n+  effect(KILL cr);\n+  format %{ \"roll    $dst, $shift\" %}\n+  ins_encode %{\n+    __ roll($dst$$Register);\n@@ -9089,30 +9020,0 @@\n-%}\n-\n-\/\/ ROR expand\n-instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, KILL cr);\n-\n-  format %{ \"rorl    $dst\" %}\n-  opcode(0xD1, 0x1); \/* D1 \/1 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, USE shift, KILL cr);\n-\n-  format %{ \"rorl    $dst, $shift\" %}\n-  opcode(0xC1, 0x1); \/* C1 \/1 ib *\/\n-  ins_encode(reg_opc_imm(dst, shift));\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, USE shift, KILL cr);\n-\n-  format %{ \"rorl    $dst, $shift\" %}\n-  opcode(0xD3, 0x1); \/* D3 \/1 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n@@ -9121,13 +9022,2 @@\n-\/\/ end of ROR expand\n-\n-\/\/ Rotate Right by one\n-instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)\n-%{\n-  match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));\n-\n-  expand %{\n-    rorI_rReg_imm1(dst, cr);\n-  %}\n-%}\n-\/\/ Rotate Right by 8-bit immediate\n-instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)\n+\/\/ Rotate Right by constant.\n+instruct rorI_immI8_legacy(rRegI dst, immI8 shift, rFlagsReg cr)\n@@ -9136,5 +9026,6 @@\n-  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x1f));\n-  match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));\n-\n-  expand %{\n-    rorI_rReg_imm8(dst, rshift, cr);\n+  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight dst shift));\n+  effect(KILL cr);\n+  format %{ \"rorl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorl($dst$$Register, $shift$$constant);\n@@ -9142,0 +9033,1 @@\n+  ins_pipe(ialu_reg);\n@@ -9144,2 +9036,2 @@\n-\/\/ Rotate Right by variable\n-instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)\n+\/\/ Rotate Right by constant.\n+instruct rorI_immI8(rRegI dst, immI8 shift)\n@@ -9147,4 +9039,5 @@\n-  match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));\n-\n-  expand %{\n-    rorI_rReg_CL(dst, shift, cr);\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight dst shift));\n+  format %{ \"rorxd     $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorxd($dst$$Register, $dst$$Register, $shift$$constant);\n@@ -9152,0 +9045,1 @@\n+  ins_pipe(ialu_reg_reg);\n@@ -9155,1 +9049,1 @@\n-instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)\n+instruct rorI_rReg_Var(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n@@ -9157,4 +9051,6 @@\n-  match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));\n-\n-  expand %{\n-    rorI_rReg_CL(dst, shift, cr);\n+  predicate(n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight dst shift));\n+  effect(KILL cr);\n+  format %{ \"rorl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorl($dst$$Register);\n@@ -9162,29 +9058,0 @@\n-%}\n-\n-\/\/ for long rotate\n-\/\/ ROL expand\n-instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{\n-  effect(USE_DEF dst, KILL cr);\n-\n-  format %{ \"rolq    $dst\" %}\n-  opcode(0xD1, 0x0); \/* Opcode  D1 \/0 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{\n-  effect(USE_DEF dst, USE shift, KILL cr);\n-\n-  format %{ \"rolq    $dst, $shift\" %}\n-  opcode(0xC1, 0x0); \/* Opcode C1 \/0 ib *\/\n-  ins_encode( reg_opc_imm_wide(dst, shift) );\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, USE shift, KILL cr);\n-\n-  format %{ \"rolq    $dst, $shift\" %}\n-  opcode(0xD3, 0x0); \/* Opcode D3 \/0 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n@@ -9193,23 +9060,2 @@\n-\/\/ end of ROL expand\n-\n-\/\/ Rotate Left by one\n-instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)\n-%{\n-  match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));\n-\n-  expand %{\n-    rolL_rReg_imm1(dst, cr);\n-  %}\n-%}\n-\n-\/\/ Rotate Left by 8-bit immediate\n-instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)\n-%{\n-  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x3f));\n-  match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));\n-  expand %{\n-    rolL_rReg_imm8(dst, lshift, cr);\n-  %}\n-%}\n-\/\/ Rotate Left by variable\n-instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)\n+\/\/ Rotate Left by constant.\n+instruct rolL_immI8(rRegL dst, immI8 shift, rFlagsReg cr)\n@@ -9219,4 +9065,6 @@\n-  match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));\n-\n-  expand %{\n-    rolL_rReg_CL(dst, shift, cr);\n+  predicate(n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft dst shift));\n+  effect(KILL cr);\n+  format %{ \"rolq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rolq($dst$$Register, $shift$$constant);\n@@ -9224,0 +9072,1 @@\n+  ins_pipe(ialu_reg);\n@@ -9227,1 +9076,1 @@\n-instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)\n+instruct rolL_rReg_Var(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n@@ -9229,4 +9078,6 @@\n-  match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));\n-\n-  expand %{\n-    rolL_rReg_CL(dst, shift, cr);\n+  predicate(n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft dst shift));\n+  effect(KILL cr);\n+  format %{ \"rolq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rolq($dst$$Register);\n@@ -9234,0 +9085,1 @@\n+  ins_pipe(ialu_reg_reg);\n@@ -9236,11 +9088,2 @@\n-\/\/ ROR expand\n-instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, KILL cr);\n-\n-  format %{ \"rorq    $dst\" %}\n-  opcode(0xD1, 0x1); \/* D1 \/1 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n-  ins_pipe(ialu_reg);\n-%}\n-instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)\n+\/\/ Rotate Right by constant.\n+instruct rorL_immI8_legacy(rRegL dst, immI8 shift, rFlagsReg cr)\n@@ -9249,2 +9092,3 @@\n-  effect(USE_DEF dst, USE shift, KILL cr);\n-\n+  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight dst shift));\n+  effect(KILL cr);\n@@ -9252,2 +9096,3 @@\n-  opcode(0xC1, 0x1); \/* C1 \/1 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, shift));\n+  ins_encode %{\n+    __ rorq($dst$$Register, $shift$$constant);\n+  %}\n@@ -9257,12 +9102,2 @@\n-instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  effect(USE_DEF dst, USE shift, KILL cr);\n-\n-  format %{ \"rorq    $dst, $shift\" %}\n-  opcode(0xD3, 0x1); \/* D3 \/1 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\/\/ end of ROR expand\n-\/\/ Rotate Right by one\n-instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)\n+\/\/ Rotate Right by constant\n+instruct rorL_immI8(rRegL dst, immI8 shift)\n@@ -9271,15 +9106,5 @@\n-  match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));\n-\n-  expand %{\n-    rorL_rReg_imm1(dst, cr);\n-  %}\n-%}\n-\n-\/\/ Rotate Right by 8-bit immediate\n-instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)\n-%{\n-  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x3f));\n-  match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));\n-\n-  expand %{\n-    rorL_rReg_imm8(dst, rshift, cr);\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight dst shift));\n+  format %{ \"rorxq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorxq($dst$$Register, $dst$$Register, $shift$$constant);\n@@ -9287,0 +9112,1 @@\n+  ins_pipe(ialu_reg_reg);\n@@ -9290,1 +9116,1 @@\n-instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)\n+instruct rorL_rReg_Var(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n@@ -9292,4 +9118,6 @@\n-  match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));\n-\n-  expand %{\n-    rorL_rReg_CL(dst, shift, cr);\n+  predicate(n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight dst shift));\n+  effect(KILL cr);\n+  format %{ \"rorq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorq($dst$$Register);\n@@ -9297,0 +9125,1 @@\n+  ins_pipe(ialu_reg_reg);\n@@ -9299,9 +9128,0 @@\n-\/\/ Rotate Right by variable\n-instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)\n-%{\n-  match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));\n-\n-  expand %{\n-    rorL_rReg_CL(dst, shift, cr);\n-  %}\n-%}\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":80,"deletions":260,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -777,0 +777,2 @@\n+       !strcmp(_matrule->_rChild->_opType,\"RotateLeft\")   ||\n+       !strcmp(_matrule->_rChild->_opType,\"RotateRight\")   ||\n@@ -4169,1 +4171,1 @@\n-    \"RoundDoubleModeV\",\"LoadVector\",\"StoreVector\",\n+    \"RoundDoubleModeV\",\"RotateLeftV\" , \"RotateRightV\", \"LoadVector\",\"StoreVector\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1333,0 +1333,1 @@\n+  LIR_Opr temp = new_register(T_ADDRESS);\n@@ -1334,1 +1335,4 @@\n-  __ move_wide(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::threadObj_offset()), T_OBJECT), reg);\n+  __ move(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::threadObj_offset()), T_ADDRESS), temp);\n+  \/\/ threadObj = ((OopHandle)_threadObj)->resolve();\n+  access_load(IN_NATIVE, T_OBJECT,\n+              LIR_OprFact::address(new LIR_Address(temp, T_OBJECT)), reg);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4545,0 +4545,12 @@\n+\/\/ Check if there is an intersection with any of the split children of 'interval'\n+bool Interval::intersects_any_children_of(Interval* interval) const {\n+  if (interval->_split_children != NULL) {\n+    for (int i = 0; i < interval->_split_children->length(); i++) {\n+      if (intersects(interval->_split_children->at(i))) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -5725,0 +5737,7 @@\n+  assert(!cur->intersects(register_hint), \"cur should not intersect register_hint\");\n+\n+  if (cur->intersects_any_children_of(register_hint)) {\n+    \/\/ Bail out if cur intersects any split children of register_hint, which have the same spill slot as their parent. An overlap of two intervals with\n+    \/\/ the same spill slot could result in a situation where both intervals are spilled at the same time to the same stack location which is not correct.\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -790,1 +790,1 @@\n-  LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::needs_access_check, tag);\n+  LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::AccessCheck::required, tag);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -829,1 +829,1 @@\n-                      check_access ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);\n+                      check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3262,1 +3262,1 @@\n-    accessor_method = holder->find_instance_method(name, full_sig, Klass::find_private);\n+    accessor_method = holder->find_instance_method(name, full_sig, Klass::PrivateLookupMode::find);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2166,1 +2166,1 @@\n-    Method* m = target_instance->uncached_lookup_method(field_name, field_sig, Klass::find_overpass);\n+    Method* m = target_instance->uncached_lookup_method(field_name, field_sig, Klass::OverpassLookupMode::find);\n@@ -2779,1 +2779,1 @@\n-        Klass::find_overpass);\n+        Klass::OverpassLookupMode::find);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -847,1 +847,0 @@\n-jlong               PSParallelCompact::_time_of_last_gc = 0;\n@@ -1074,2 +1073,2 @@\n-  \/\/ Update time of last GC\n-  reset_millis_since_last_gc();\n+  \/\/ Signal that we have completed a visit to all live objects.\n+  Universe::heap()->record_whole_heap_examined_timestamp();\n@@ -2012,4 +2011,0 @@\n-    case ParallelRootType::universe:\n-      Universe::oops_do(&mark_and_push_closure);\n-      break;\n-\n@@ -2229,1 +2224,0 @@\n-  Universe::oops_do(&oop_closure);\n@@ -3201,19 +3195,0 @@\n-jlong PSParallelCompact::millis_since_last_gc() {\n-  \/\/ We need a monotonically non-decreasing time in ms but\n-  \/\/ os::javaTimeMillis() does not guarantee monotonicity.\n-  jlong now = os::javaTimeNanos() \/ NANOSECS_PER_MILLISEC;\n-  jlong ret_val = now - _time_of_last_gc;\n-  \/\/ XXX See note in genCollectedHeap::millis_since_last_gc().\n-  if (ret_val < 0) {\n-    NOT_PRODUCT(log_warning(gc)(\"time warp: \" JLONG_FORMAT, ret_val);)\n-    return 0;\n-  }\n-  return ret_val;\n-}\n-\n-void PSParallelCompact::reset_millis_since_last_gc() {\n-  \/\/ We need a monotonically non-decreasing time in ms but\n-  \/\/ os::javaTimeMillis() does not guarantee monotonicity.\n-  _time_of_last_gc = os::javaTimeNanos() \/ NANOSECS_PER_MILLISEC;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,1 @@\n+  bool immutable = (decorators & C2_IMMUTABLE_MEMORY) != 0;\n@@ -160,3 +161,6 @@\n-    if (in_native) {\n-      load = kit->make_load(control, adr, val_type, access.type(), mo, dep,\n-                            requires_atomic_access, unaligned,\n+    if (immutable) {\n+      assert(!requires_atomic_access, \"can't ensure atomicity\");\n+      Compile* C = Compile::current();\n+      Node* mem = kit->immutable_memory();\n+      load = LoadNode::make(kit->gvn(), control, mem, adr,\n+                            adr_type, val_type, access.type(), mo, dep, unaligned,\n@@ -164,0 +168,1 @@\n+      load = kit->gvn().transform(load);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+\/\/ Loads from immutable memory\n+const DecoratorSet C2_IMMUTABLE_MEMORY       = DECORATOR_LAST << 11;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,0 +115,6 @@\n+  \/\/ Last time the whole heap has been examined in support of RMI\n+  \/\/ MaxObjectInspectionAge.\n+  \/\/ This timestamp must be monotonically non-decreasing to avoid\n+  \/\/ time-warp warnings.\n+  jlong _last_whole_heap_examined_time_ns;\n+\n@@ -408,4 +414,0 @@\n-  \/\/ Returns the longest time (in ms) that has elapsed since the last\n-  \/\/ time that any part of the heap was examined by a garbage collection.\n-  virtual jlong millis_since_last_gc() = 0;\n-\n@@ -415,1 +417,7 @@\n-  \/\/ Generate any dumps preceding or following a full gc\n+  \/\/ Returns the longest time (in ms) that has elapsed since the last\n+  \/\/ time that the whole heap has been examined by a garbage collection.\n+  jlong millis_since_last_whole_heap_examined();\n+  \/\/ GC should call this when the next whole heap analysis has completed to\n+  \/\/ satisfy above requirement.\n+  void record_whole_heap_examined_timestamp();\n+\n@@ -417,0 +425,1 @@\n+  \/\/ Generate any dumps preceding or following a full gc\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  assert(obj != NULL, \"checked by caller\");\n@@ -119,0 +120,1 @@\n+  assert(value != NULL, \"checked by caller\");\n@@ -128,0 +130,1 @@\n+  assert(value != NULL, \"checked by caller\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-  Method* result = klass->uncached_lookup_method(name, signature, Klass::skip_overpass);\n+  Method* result = klass->uncached_lookup_method(name, signature, Klass::OverpassLookupMode::skip);\n@@ -380,1 +380,1 @@\n-  Method* result = klass->uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);\n+  Method* result = klass->uncached_lookup_method(name, signature, Klass::OverpassLookupMode::find, private_mode);\n@@ -384,1 +384,1 @@\n-    result = super_klass->uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);\n+    result = super_klass->uncached_lookup_method(name, signature, Klass::OverpassLookupMode::find, private_mode);\n@@ -413,2 +413,4 @@\n-                                                 name, signature, Klass::find_overpass,\n-                                                 Klass::find_static, Klass::find_private);\n+                                                 name, signature,\n+                                                 Klass::OverpassLookupMode::find,\n+                                                 Klass::StaticLookupMode::find,\n+                                                 Klass::PrivateLookupMode::find);\n@@ -433,1 +435,1 @@\n-  return ik->lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);\n+  return ik->lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::DefaultsLookupMode::skip);\n@@ -1104,1 +1106,1 @@\n-                      link_info.check_access() ? LinkInfo::needs_access_check : LinkInfo::skip_access_check);\n+                      link_info.check_access() ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip);\n@@ -1255,1 +1257,1 @@\n-                                                     Klass::find_private, CHECK);\n+                                                     Klass::PrivateLookupMode::find, CHECK);\n@@ -1497,1 +1499,1 @@\n-                                                       Klass::skip_private, CHECK);\n+                                                       Klass::PrivateLookupMode::skip, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -147,4 +147,1 @@\n-  enum AccessCheck {\n-    needs_access_check,\n-    skip_access_check\n-  };\n+  enum class AccessCheck { required, skip };\n@@ -157,1 +154,1 @@\n-           AccessCheck check_access = needs_access_check,\n+           AccessCheck check_access = AccessCheck::required,\n@@ -161,1 +158,1 @@\n-    _check_access(check_access == needs_access_check), _tag(tag) {}\n+    _check_access(check_access == AccessCheck::required), _tag(tag) {}\n@@ -164,1 +161,1 @@\n-           AccessCheck check_access = needs_access_check,\n+           AccessCheck check_access = AccessCheck::required,\n@@ -168,1 +165,1 @@\n-    _check_access(check_access == needs_access_check), _tag(tag) {}\n+    _check_access(check_access == AccessCheck::required), _tag(tag) {}\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-  nonstatic_field(JavaThread,                  _threadObj,                                    oop)                                   \\\n+  nonstatic_field(JavaThread,                  _threadObj,                                    OopHandle)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,5 +229,0 @@\n-void Universe::oops_do(OopClosure* f) {\n-\n-  ThreadsSMRSupport::exiting_threads_oops_do(f);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -344,6 +344,0 @@\n-  \/\/ Iteration\n-\n-  \/\/ Apply \"f\" to the addresses of all the direct heap pointers maintained\n-  \/\/ as static fields of \"Universe\".\n-  static void oops_do(OopClosure* f);\n-\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  return super()->uncached_lookup_method(name, signature, Klass::skip_overpass, private_mode);\n+  return super()->uncached_lookup_method(name, signature, OverpassLookupMode::skip, private_mode);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-                                 PrivateLookupMode private_mode = find_private) const;\n+                                 PrivateLookupMode private_mode = PrivateLookupMode::find) const;\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1910,1 +1910,4 @@\n-  return find_method_impl(name, signature, find_overpass, find_static, find_private);\n+  return find_method_impl(name, signature,\n+                          OverpassLookupMode::find,\n+                          StaticLookupMode::find,\n+                          PrivateLookupMode::find);\n@@ -1935,2 +1938,2 @@\n-                                                 find_overpass,\n-                                                 skip_static,\n+                                                 OverpassLookupMode::find,\n+                                                 StaticLookupMode::skip,\n@@ -1994,3 +1997,3 @@\n-                                         find_overpass,\n-                                         find_static,\n-                                         find_private);\n+                                         OverpassLookupMode::find,\n+                                         StaticLookupMode::find,\n+                                         PrivateLookupMode::find);\n@@ -2039,3 +2042,3 @@\n-  const bool skipping_overpass = (overpass_mode == skip_overpass);\n-  const bool skipping_static = (static_mode == skip_static);\n-  const bool skipping_private = (private_mode == skip_private);\n+  const bool skipping_overpass = (overpass_mode == OverpassLookupMode::skip);\n+  const bool skipping_static = (static_mode == StaticLookupMode::skip);\n+  const bool skipping_private = (private_mode == PrivateLookupMode::skip);\n@@ -2117,1 +2120,1 @@\n-                                                                        find_static,\n+                                                                        StaticLookupMode::find,\n@@ -2126,1 +2129,1 @@\n-    overpass_local_mode = skip_overpass;   \/\/ Always ignore overpass methods in superclasses\n+    overpass_local_mode = OverpassLookupMode::skip;   \/\/ Always ignore overpass methods in superclasses\n@@ -2156,1 +2159,1 @@\n-    m = lookup_method_in_all_interfaces(name, signature, find_defaults);\n+    m = lookup_method_in_all_interfaces(name, signature, DefaultsLookupMode::find);\n@@ -2174,1 +2177,1 @@\n-        ((defaults_mode != skip_defaults) || !m->is_default_method())) {\n+        ((defaults_mode != DefaultsLookupMode::skip) || !m->is_default_method())) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -769,1 +769,1 @@\n-                                 PrivateLookupMode private_mode = find_private) const;\n+                                 PrivateLookupMode private_mode = PrivateLookupMode::find) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,4 +200,4 @@\n-  enum DefaultsLookupMode { find_defaults, skip_defaults };\n-  enum OverpassLookupMode { find_overpass, skip_overpass };\n-  enum StaticLookupMode   { find_static,   skip_static };\n-  enum PrivateLookupMode  { find_private,  skip_private };\n+  enum class DefaultsLookupMode { find, skip };\n+  enum class OverpassLookupMode { find, skip };\n+  enum class StaticLookupMode   { find, skip };\n+  enum class PrivateLookupMode  { find, skip };\n@@ -505,1 +505,1 @@\n-                                         PrivateLookupMode = find_private) const;\n+                                         PrivateLookupMode = PrivateLookupMode::find) const;\n@@ -508,1 +508,1 @@\n-    return uncached_lookup_method(name, signature, find_overpass);\n+    return uncached_lookup_method(name, signature, OverpassLookupMode::find);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -695,1 +695,1 @@\n-    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::find_defaults) != NULL) {\n+    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != NULL) {\n@@ -800,1 +800,3 @@\n-              Klass::find_overpass, Klass::skip_static, Klass::skip_private) != NULL)\n+                                       Klass::OverpassLookupMode::find,\n+                                       Klass::StaticLookupMode::skip,\n+                                       Klass::PrivateLookupMode::skip) != NULL)\n@@ -820,1 +822,3 @@\n-       Klass::find_overpass, Klass::skip_static, Klass::skip_private);\n+                                                                          Klass::OverpassLookupMode::find,\n+                                                                          Klass::StaticLookupMode::skip,\n+                                                                          Klass::PrivateLookupMode::skip);\n@@ -864,1 +868,1 @@\n-        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::find_defaults) == NULL) {\n+        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == NULL) {\n@@ -1217,1 +1221,1 @@\n-                                                               Klass::skip_private, CHECK);\n+                                                               Klass::PrivateLookupMode::skip, CHECK);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -758,0 +758,40 @@\n+Node *OrINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  int lopcode = in(1)->Opcode();\n+  int ropcode = in(2)->Opcode();\n+  if (Matcher::match_rule_supported(Op_RotateLeft) &&\n+      lopcode == Op_LShiftI && ropcode == Op_URShiftI && in(1)->in(1) == in(2)->in(1)) {\n+     Node *lshift = in(1)->in(2);\n+     Node *rshift = in(2)->in(2);\n+     \/\/ val << norm_con_shift | val >> (32 - norm_con_shift) => rotate_left val , norm_con_shift\n+     if (lshift->is_Con() && rshift->is_Con() &&\n+         ((lshift->get_int() & 0x1F) == (32 - (rshift->get_int() & 0x1F)))) {\n+       return  new RotateLeftNode(in(1)->in(1),\n+                 phase->intcon(lshift->get_int() & 0x1F), TypeInt::INT);\n+     }\n+     \/\/ val << var_shift | val >> (0\/32 - var_shift) => rotate_left val , var_shift\n+     if (rshift->Opcode() == Op_SubI && rshift->in(2) == lshift &&\n+         rshift->in(1)->is_Con() &&\n+         (rshift->in(1)->get_int() == 0 || rshift->in(1)->get_int() == 32)) {\n+       return  new RotateLeftNode(in(1)->in(1), lshift, TypeInt::INT);\n+     }\n+  }\n+  if (Matcher::match_rule_supported(Op_RotateRight) &&\n+      lopcode == Op_URShiftI && ropcode == Op_LShiftI && in(1)->in(1) == in(2)->in(1)) {\n+     Node *rshift = in(1)->in(2);\n+     Node *lshift = in(2)->in(2);\n+     \/\/ val >> norm_con_shift | val << (32 - norm_con_shift) => rotate_right val , norm_con_shift\n+     if (rshift->is_Con() && lshift->is_Con() &&\n+         ((rshift->get_int() & 0x1F) == (32 - (lshift->get_int() & 0x1F)))) {\n+       return  new RotateRightNode(in(1)->in(1),\n+                 phase->intcon(rshift->get_int() & 0x1F), TypeInt::INT);\n+     }\n+     \/\/ val >> var_shift | val << (0\/32 - var_shift) => rotate_right val , var_shift\n+     if (lshift->Opcode() == Op_SubI && lshift->in(2) == rshift &&\n+         lshift->in(1)->is_Con() &&\n+         (lshift->in(1)->get_int() == 0 || lshift->in(1)->get_int() == 32)) {\n+       return  new RotateRightNode(in(1)->in(1), rshift, TypeInt::INT);\n+     }\n+  }\n+  return NULL;\n+}\n+\n@@ -799,0 +839,40 @@\n+Node *OrLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  int lopcode = in(1)->Opcode();\n+  int ropcode = in(2)->Opcode();\n+  if (Matcher::match_rule_supported(Op_RotateLeft) &&\n+      lopcode == Op_LShiftL && ropcode == Op_URShiftL && in(1)->in(1) == in(2)->in(1)) {\n+     Node *lshift = in(1)->in(2);\n+     Node *rshift = in(2)->in(2);\n+     \/\/ val << norm_con_shift | val >> (64 - norm_con_shift) => rotate_left val , norm_con_shift\n+     if (lshift->is_Con() && rshift->is_Con() &&\n+         ((lshift->get_int() & 0x3F) == (64 - (rshift->get_int() & 0x3F)))) {\n+       return  new RotateLeftNode(in(1)->in(1),\n+                 phase->intcon(lshift->get_int() & 0x3F), TypeLong::LONG);\n+     }\n+     \/\/ val << var_shift | val >> (0\/64 - var_shift) => rotate_left val , var_shift\n+     if (rshift->Opcode() == Op_SubI && rshift->in(2) == lshift &&\n+         rshift->in(1)->is_Con() &&\n+         (rshift->in(1)->get_int() == 0 || rshift->in(1)->get_int() == 64)) {\n+       return  new RotateLeftNode(in(1)->in(1), lshift, TypeLong::LONG);\n+     }\n+  }\n+  if (Matcher::match_rule_supported(Op_RotateRight) &&\n+      lopcode == Op_URShiftL && ropcode == Op_LShiftL && in(1)->in(1) == in(2)->in(1)) {\n+     Node *rshift = in(1)->in(2);\n+     Node *lshift = in(2)->in(2);\n+     \/\/ val >> norm_con_shift | val << (64 - norm_con_shift) => rotate_right val , norm_con_shift\n+     if (rshift->is_Con() && lshift->is_Con() &&\n+         ((rshift->get_int() & 0x3F) == (64 - (lshift->get_int() & 0x3F)))) {\n+       return  new RotateRightNode(in(1)->in(1),\n+                 phase->intcon(rshift->get_int() & 0x3F), TypeLong::LONG);\n+     }\n+     \/\/ val >> var_shift | val << (0\/64 - var_shift) => rotate_right val , var_shift\n+     if (lshift->Opcode() == Op_SubI && lshift->in(2) == rshift &&\n+         lshift->in(1)->is_Con() &&\n+         (lshift->in(1)->get_int() == 0 || lshift->in(1)->get_int() == 64)) {\n+       return  new RotateRightNode(in(1)->in(1), rshift, TypeLong::LONG);\n+     }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                       float site_invoke_ratio, int max_inline_level) :\n+                       int max_inline_level) :\n@@ -51,1 +51,0 @@\n-  _site_invoke_ratio(site_invoke_ratio),\n@@ -649,12 +648,0 @@\n-\/\/------------------------------compute_callee_frequency-----------------------\n-float InlineTree::compute_callee_frequency( int caller_bci ) const {\n-  int count  = method()->interpreter_call_site_count(caller_bci);\n-  int invcnt = method()->interpreter_invocation_count();\n-  float freq = (float)count\/(float)invcnt;\n-  \/\/ Call-site count \/ interpreter invocation count, scaled recursively.\n-  \/\/ Always between 0.0 and 1.0.  Represents the percentage of the method's\n-  \/\/ total execution time used at this call site.\n-\n-  return freq;\n-}\n-\n@@ -663,1 +650,0 @@\n-  float recur_frequency = _site_invoke_ratio * compute_callee_frequency(caller_bci);\n@@ -688,1 +674,1 @@\n-  InlineTree* ilt = new (C->comp_arena()) InlineTree(C, this, callee_method, caller_jvms, caller_bci, recur_frequency, _max_inline_level + max_inline_level_adjust);\n+  InlineTree* ilt = new (C->comp_arena()) InlineTree(C, this, callee_method, caller_jvms, caller_bci, _max_inline_level + max_inline_level_adjust);\n@@ -714,1 +700,1 @@\n-  InlineTree* ilt = new InlineTree(C, NULL, C->method(), NULL, -1, 1.0F, MaxInlineLevel);\n+  InlineTree* ilt = new InlineTree(C, NULL, C->method(), NULL, -1, MaxInlineLevel);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1893,1 +1893,1 @@\n-void PhaseChaitin::dump(const Node *n) const {\n+void PhaseChaitin::dump(const Node* n) const {\n@@ -1971,1 +1971,1 @@\n-void PhaseChaitin::dump(const Block *b) const {\n+void PhaseChaitin::dump(const Block* b) const {\n@@ -2067,1 +2067,1 @@\n-static char *print_reg( OptoReg::Name reg, const PhaseChaitin *pc, char *buf ) {\n+static char *print_reg(OptoReg::Name reg, const PhaseChaitin* pc, char* buf) {\n@@ -2080,1 +2080,1 @@\n-char *PhaseChaitin::dump_register( const Node *n, char *buf  ) const {\n+char *PhaseChaitin::dump_register(const Node* n, char* buf) const {\n@@ -2234,1 +2234,1 @@\n-void PhaseChaitin::dump_bb( uint pre_order ) const {\n+void PhaseChaitin::dump_bb(uint pre_order) const {\n@@ -2244,1 +2244,1 @@\n-void PhaseChaitin::dump_lrg( uint lidx, bool defs_only ) const {\n+void PhaseChaitin::dump_lrg(uint lidx, bool defs_only) const {\n@@ -2302,0 +2302,96 @@\n+#ifdef ASSERT\n+\/\/ Verify that base pointers and derived pointers are still sane.\n+void PhaseChaitin::verify_base_ptrs(ResourceArea* a) const {\n+  Unique_Node_List worklist(a);\n+  for (uint i = 0; i < _cfg.number_of_blocks(); i++) {\n+    Block* block = _cfg.get_block(i);\n+    for (uint j = block->end_idx() + 1; j > 1; j--) {\n+      Node* n = block->get_node(j-1);\n+      if (n->is_Phi()) {\n+        break;\n+      }\n+      \/\/ Found a safepoint?\n+      if (n->is_MachSafePoint()) {\n+        MachSafePointNode* sfpt = n->as_MachSafePoint();\n+        JVMState* jvms = sfpt->jvms();\n+        if (jvms != NULL) {\n+          \/\/ Now scan for a live derived pointer\n+          if (jvms->oopoff() < sfpt->req()) {\n+            \/\/ Check each derived\/base pair\n+            for (uint idx = jvms->oopoff(); idx < sfpt->req(); idx++) {\n+              Node* check = sfpt->in(idx);\n+              bool is_derived = ((idx - jvms->oopoff()) & 1) == 0;\n+              \/\/ search upwards through spills and spill phis for AddP\n+              worklist.clear();\n+              worklist.push(check);\n+              uint k = 0;\n+              while (k < worklist.size()) {\n+                check = worklist.at(k);\n+                assert(check, \"Bad base or derived pointer\");\n+                \/\/ See PhaseChaitin::find_base_for_derived() for all cases.\n+                int isc = check->is_Copy();\n+                if (isc) {\n+                  worklist.push(check->in(isc));\n+                } else if (check->is_Phi()) {\n+                  for (uint m = 1; m < check->req(); m++) {\n+                    worklist.push(check->in(m));\n+                  }\n+                } else if (check->is_Con()) {\n+                  if (is_derived) {\n+                    \/\/ Derived is NULL+offset\n+                    assert(!is_derived || check->bottom_type()->is_ptr()->ptr() == TypePtr::Null, \"Bad derived pointer\");\n+                  } else {\n+                    assert(check->bottom_type()->is_ptr()->offset() == 0, \"Bad base pointer\");\n+                    \/\/ Base either ConP(NULL) or loadConP\n+                    if (check->is_Mach()) {\n+                      assert(check->as_Mach()->ideal_Opcode() == Op_ConP, \"Bad base pointer\");\n+                    } else {\n+                      assert(check->Opcode() == Op_ConP &&\n+                             check->bottom_type()->is_ptr()->ptr() == TypePtr::Null, \"Bad base pointer\");\n+                    }\n+                  }\n+                } else if (check->bottom_type()->is_ptr()->offset() == 0) {\n+                  if (check->is_Proj() || (check->is_Mach() &&\n+                     (check->as_Mach()->ideal_Opcode() == Op_CreateEx ||\n+                      check->as_Mach()->ideal_Opcode() == Op_ThreadLocal ||\n+                      check->as_Mach()->ideal_Opcode() == Op_CMoveP ||\n+                      check->as_Mach()->ideal_Opcode() == Op_CheckCastPP ||\n+#ifdef _LP64\n+                      (UseCompressedOops && check->as_Mach()->ideal_Opcode() == Op_CastPP) ||\n+                      (UseCompressedOops && check->as_Mach()->ideal_Opcode() == Op_DecodeN) ||\n+                      (UseCompressedClassPointers && check->as_Mach()->ideal_Opcode() == Op_DecodeNKlass) ||\n+#endif \/\/ _LP64\n+                      check->as_Mach()->ideal_Opcode() == Op_LoadP ||\n+                      check->as_Mach()->ideal_Opcode() == Op_LoadKlass))) {\n+                    \/\/ Valid nodes\n+                  } else {\n+                    check->dump();\n+                    assert(false, \"Bad base or derived pointer\");\n+                  }\n+                } else {\n+                  assert(is_derived, \"Bad base pointer\");\n+                  assert(check->is_Mach() && check->as_Mach()->ideal_Opcode() == Op_AddP, \"Bad derived pointer\");\n+                }\n+                k++;\n+                assert(k < 100000, \"Derived pointer checking in infinite loop\");\n+              } \/\/ End while\n+            }\n+          } \/\/ End of check for derived pointers\n+        } \/\/ End of Kcheck for debug info\n+      } \/\/ End of if found a safepoint\n+    } \/\/ End of forall instructions in block\n+  } \/\/ End of forall blocks\n+}\n+\n+\/\/ Verify that graphs and base pointers are still sane.\n+void PhaseChaitin::verify(ResourceArea* a, bool verify_ifg) const {\n+  if (VerifyRegisterAllocator) {\n+    _cfg.verify();\n+    verify_base_ptrs(a);\n+    if (verify_ifg) {\n+      _ifg->verify(this);\n+    }\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":102,"deletions":6,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -273,0 +273,4 @@\n+macro(RotateLeft)\n+macro(RotateLeftV)\n+macro(RotateRight)\n+macro(RotateRightV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1674,1 +1674,1 @@\n-  C2AccessValuePtr addr(adr, NULL);\n+  C2AccessValuePtr addr(adr, adr->bottom_type()->is_ptr());\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1131,2 +1131,3 @@\n-  Node* threadObj = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(), thread_type, T_OBJECT, MemNode::unordered));\n-  return threadObj;\n+  Node* thread_obj_handle = LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(), TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  thread_obj_handle = _gvn.transform(thread_obj_handle);\n+  return access_load(thread_obj_handle, thread_type, T_OBJECT, IN_NATIVE | C2_IMMUTABLE_MEMORY);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -642,0 +642,2 @@\n+  \/\/ Reassociate invariant binary expressions.\n+  Node* reassociate(Node* n1, PhaseIdealLoop *phase);\n@@ -643,1 +645,1 @@\n-  Node* reassociate_add_sub(Node* n1, PhaseIdealLoop *phase);\n+  Node* reassociate_add_sub(Node* n1, int inv1_idx, int inv2_idx, PhaseIdealLoop *phase);\n@@ -645,2 +647,4 @@\n-  \/\/ are combined with an Add or Sub. Helper for reassociate_invariants.\n-  int is_invariant_addition(Node* n, PhaseIdealLoop *phase);\n+  \/\/ are combined with an associative binary. Helper for reassociate_invariants.\n+  int find_invariant(Node* n, PhaseIdealLoop *phase);\n+  \/\/ Return TRUE if \"n\" is associative.\n+  bool is_associative(Node* n, Node* base=NULL);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -817,1 +817,3 @@\n-           in_bytes(JavaThread::osthread_offset())));\n+           in_bytes(JavaThread::osthread_offset()) ||\n+           adr->in(AddPNode::Offset)->find_intptr_t_con(-1) ==\n+           in_bytes(JavaThread::threadObj_offset())));\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1455,0 +1455,96 @@\n+\n+\/\/------------------------------Rotate Operations ------------------------------\n+\n+const Type* RotateLeftNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  if (t1->isa_int()) {\n+    const TypeInt* r1 = t1->is_int();\n+    const TypeInt* r2 = t2->is_int();\n+\n+    \/\/ Left input is ZERO ==> the result is ZERO.\n+    if (r1 == TypeInt::ZERO) {\n+      return TypeInt::ZERO;\n+    }\n+    \/\/ Shift by zero does nothing\n+    if (r2 == TypeInt::ZERO) {\n+      return r1;\n+    }\n+\n+    if (r1->is_con() && r2->is_con()) {\n+      int shift = r2->get_con() & (BitsPerJavaInteger - 1); \/\/ semantics of Java shifts\n+      return TypeInt::make((r1->get_con() << shift) | (r1->get_con() >> (32 - shift)));\n+    }\n+    return TypeInt::INT;\n+  } else {\n+    assert(t1->isa_long(), \"Type must be a long\");\n+    const TypeLong* r1 = t1->is_long();\n+    const TypeInt*  r2 = t2->is_int();\n+\n+    \/\/ Left input is ZERO ==> the result is ZERO.\n+    if (r1 == TypeLong::ZERO) {\n+      return TypeLong::ZERO;\n+    }\n+    \/\/ Shift by zero does nothing\n+    if (r2 == TypeInt::ZERO) {\n+      return r1;\n+    }\n+\n+    if (r1->is_con() && r2->is_con()) {\n+      int shift = r2->get_con() & (BitsPerJavaLong - 1); \/\/ semantics of Java shifts\n+      return TypeLong::make((r1->get_con() << shift) | (r1->get_con() >> (64 - shift)));\n+    }\n+    return TypeLong::LONG;\n+  }\n+}\n+\n+const Type* RotateRightNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  if (t1->isa_int()) {\n+    const TypeInt* r1 = t1->is_int();\n+    const TypeInt* r2 = t2->is_int();\n+\n+    \/\/ Left input is ZERO ==> the result is ZERO.\n+    if (r1 == TypeInt::ZERO) {\n+      return TypeInt::ZERO;\n+    }\n+    \/\/ Shift by zero does nothing\n+    if (r2 == TypeInt::ZERO) {\n+      return r1;\n+    }\n+    if (r1->is_con() && r2->is_con()) {\n+      int shift = r2->get_con() & (BitsPerJavaInteger - 1); \/\/ semantics of Java shifts\n+      return TypeInt::make((r1->get_con() >> shift) | (r1->get_con() << (32 - shift)));\n+    }\n+    return TypeInt::INT;\n+\n+  } else {\n+    assert(t1->isa_long(), \"Type must be a long\");\n+    const TypeLong* r1 = t1->is_long();\n+    const TypeInt*  r2 = t2->is_int();\n+    \/\/ Left input is ZERO ==> the result is ZERO.\n+    if (r1 == TypeLong::ZERO) {\n+      return TypeLong::ZERO;\n+    }\n+    \/\/ Shift by zero does nothing\n+    if (r2 == TypeInt::ZERO) {\n+      return r1;\n+    }\n+    if (r1->is_con() && r2->is_con()) {\n+      int shift = r2->get_con() & (BitsPerJavaLong - 1); \/\/ semantics of Java shifts\n+      return TypeLong::make((r1->get_con() >> shift) | (r1->get_con() << (64 - shift)));\n+    }\n+    return TypeLong::LONG;\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -51,5 +51,0 @@\n-  \/\/ Call-site count \/ interpreter invocation count, scaled recursively.\n-  \/\/ Always between 0.0 and 1.0.  Represents the percentage of the method's\n-  \/\/ total execution time used at this call site.\n-  const float _site_invoke_ratio;\n-  float compute_callee_frequency( int caller_bci ) const;\n@@ -70,1 +65,0 @@\n-             float site_invoke_ratio,\n@@ -128,1 +122,0 @@\n-  float       site_invoke_ratio() const { return _site_invoke_ratio; };\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-  return Universe::heap()->millis_since_last_gc();\n+  return Universe::heap()->millis_since_last_whole_heap_examined();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  _class_holder = OopHandle(Universe::vm_global(), class_holder_oop);\n+  _class_holder = OopHandle(JvmtiExport::jvmti_oop_storage(), class_holder_oop);\n@@ -208,1 +208,1 @@\n-    _class_holder.release(Universe::vm_global());\n+    _class_holder.release(JvmtiExport::jvmti_oop_storage());\n@@ -215,1 +215,1 @@\n-  _class_holder = OopHandle(Universe::vm_global(), bp._class_holder.resolve());\n+  _class_holder = OopHandle(JvmtiExport::jvmti_oop_storage(), bp._class_holder.resolve());\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -751,2 +751,2 @@\n-                                              LinkInfo::needs_access_check :\n-                                              LinkInfo::skip_access_check;\n+                                              LinkInfo::AccessCheck::required :\n+                                              LinkInfo::AccessCheck::skip;\n@@ -828,1 +828,1 @@\n-        LinkInfo link_info(defc, name, type, caller, LinkInfo::skip_access_check);\n+        LinkInfo link_info(defc, name, type, caller, LinkInfo::AccessCheck::skip);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -109,0 +110,1 @@\n+  JvmtiExport::initialize_oop_storage();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1051,9 +1051,0 @@\n-  \/\/ hashCode() is a heap mutator ...\n-  \/\/ Relaxing assertion for bug 6320749.\n-  assert(Universe::verify_in_progress() || DumpSharedSpaces ||\n-         !SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(Universe::verify_in_progress() || DumpSharedSpaces ||\n-         self->is_Java_thread() , \"invariant\");\n-  assert(Universe::verify_in_progress() || DumpSharedSpaces ||\n-         ((JavaThread *)self)->thread_state() != _thread_blocked, \"invariant\");\n-\n@@ -1838,5 +1829,0 @@\n-  \/\/ Inflate mutates the heap ...\n-  \/\/ Relaxing assertion for bug 6320749.\n-  assert(Universe::verify_in_progress() ||\n-         !SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n@@ -1059,2 +1061,2 @@\n-\/\/ Creates the initial Thread\n-static oop create_initial_thread(Handle thread_group, JavaThread* thread,\n+\/\/ Creates the initial Thread, and sets it to running.\n+static void create_initial_thread(Handle thread_group, JavaThread* thread,\n@@ -1064,1 +1066,1 @@\n-  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK_NULL);\n+  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK);\n@@ -1073,1 +1075,1 @@\n-  Handle string = java_lang_String::create_from_str(\"main\", CHECK_NULL);\n+  Handle string = java_lang_String::create_from_str(\"main\", CHECK);\n@@ -1082,2 +1084,6 @@\n-                          CHECK_NULL);\n-  return thread_oop();\n+                          CHECK);\n+\n+  \/\/ Set thread status to running since main thread has\n+  \/\/ been started and running.\n+  java_lang_Thread::set_thread_status(thread_oop(),\n+                                      java_lang_Thread::RUNNABLE);\n@@ -1191,0 +1197,17 @@\n+\/\/ Initialized by VMThread at vm_global_init\n+static OopStorage* _thread_oop_storage = NULL;\n+\n+oop  JavaThread::threadObj() const    {\n+  return _threadObj.resolve();\n+}\n+\n+void JavaThread::set_threadObj(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _threadObj = OopHandle(_thread_oop_storage, p);\n+}\n+\n+OopStorage* JavaThread::thread_oop_storage() {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  return _thread_oop_storage;\n+}\n+\n@@ -1657,1 +1680,0 @@\n-  set_threadObj(NULL);\n@@ -1763,1 +1785,1 @@\n-  if (threadObj() == NULL) {\n+  if (_threadObj.peek() == NULL) {\n@@ -1876,0 +1898,3 @@\n+  \/\/ Ask ServiceThread to release the threadObj OopHandle\n+  ServiceThread::add_oop_handle_release(_threadObj);\n+\n@@ -1976,1 +2001,1 @@\n-  assert(this->threadObj() != NULL, \"just checking\");\n+  assert(_threadObj.peek() != NULL, \"just checking\");\n@@ -3023,1 +3048,0 @@\n-  f->do_oop((oop*) &_threadObj);\n@@ -3725,7 +3749,1 @@\n-  oop thread_object = create_initial_thread(thread_group, main_thread, CHECK);\n-  main_thread->set_threadObj(thread_object);\n-\n-  \/\/ Set thread status to running since main thread has\n-  \/\/ been started and running.\n-  java_lang_Thread::set_thread_status(thread_object,\n-                                      java_lang_Thread::RUNNABLE);\n+  create_initial_thread(thread_group, main_thread, CHECK);\n@@ -3894,0 +3912,3 @@\n+  \/\/ Initialize OopStorage for threadObj\n+  _thread_oop_storage = OopStorageSet::create_strong(\"Thread OopStorage\");\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+class OopStorage;\n+\n@@ -1022,1 +1024,1 @@\n-  oop            _threadObj;                     \/\/ The Java level thread object\n+  OopHandle      _threadObj;                     \/\/ The Java level thread object\n@@ -1283,2 +1285,2 @@\n-  oop threadObj() const                          { return _threadObj; }\n-  void set_threadObj(oop p)                      { _threadObj = p; }\n+  oop threadObj() const;\n+  void set_threadObj(oop p);\n@@ -2122,0 +2124,1 @@\n+  static OopStorage* thread_oop_storage();\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -743,1 +743,1 @@\n-  nonstatic_field(JavaThread,                  _threadObj,                                    oop)                                   \\\n+  nonstatic_field(JavaThread,                  _threadObj,                                    OopHandle)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1862,2 +1862,3 @@\n-  Universe::oops_do(&jni_dumper);  \/\/ technically not jni roots, but global roots\n-                                   \/\/ for things like preallocated throwable backtraces\n+  \/\/ technically not jni roots, but global roots\n+  \/\/ for things like preallocated throwable backtraces\n+  Universe::vm_global()->oops_do(&jni_dumper);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    case 1: return \"\";\n","filename":"src\/hotspot\/share\/services\/nmtCommon.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -348,0 +348,1 @@\n+ -runtime\/cds\/appcds\/javaldr\/LockDuringDump.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n-            this.executable = LevelTransitionTest.Helper.getMethod(TrivialMethods.class, name);\n-            this.callable = LevelTransitionTest.Helper.getCallable(new TrivialMethods(), name);\n+            this.executable = MethodHelper.getMethod(TrivialMethods.class, name);\n+            this.callable = MethodHelper.getCallable(new TrivialMethods(), name);\n","filename":"test\/hotspot\/jtreg\/compiler\/tiered\/ConstantGettersTransitionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -387,0 +387,5 @@\n+        if (WB.getBooleanVMFlag(\"VerifyOops\")) {\n+            \/\/ Should be enabled when JDK-8209961 is fixed\n+            return \"false\";\n+        }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}