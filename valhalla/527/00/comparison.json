{"files":[{"patch":"@@ -388,8 +388,0 @@\n-  \/\/ The runtime call returns the new array in r0 which is also j_rarg7\n-  \/\/ so we must avoid clobbering that. Temporarily save r0 in a\n-  \/\/ non-argument register and pass the buffered array in r20 instead.\n-  \/\/ This is safe because the runtime stub saves all registers.\n-  Register val_array = r20;\n-  Register tmp1 = r21;\n-  mov(tmp1, j_rarg7);\n-\n@@ -405,2 +397,3 @@\n-  mov(val_array, r0);\n-  mov(j_rarg7, tmp1);\n+  \/\/ The runtime call returns the new array in r20 instead of the usual r0\n+  \/\/ because r0 is also j_rarg7 which may be holding a live argument here.\n+  Register val_array = r20;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -895,1 +895,6 @@\n-        int call_offset = __ call_RT(r0, noreg, entry, method);\n+        \/\/ This is called from a C1 method's scalarized entry point\n+        \/\/ where r0-r7 may be holding live argument values so we can't\n+        \/\/ return the result in r0 as the other stubs do. LR is used as\n+        \/\/ a temporay below to avoid the result being clobbered by\n+        \/\/ restore_live_registers.\n+        int call_offset = __ call_RT(lr, noreg, entry, method);\n@@ -898,2 +903,3 @@\n-        restore_live_registers_except_r0(sasm);\n-        __ verify_oop(r0);  \/\/ r0: an array of buffered value objects\n+        restore_live_registers(sasm);\n+        __ mov(r20, lr);\n+        __ verify_oop(r20);  \/\/ r20: an array of buffered value objects\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"}]}