[{"commit":{"message":"8272307: [lworld] [AArch64] TestCallingConventionC1 test63 and test64 get incorrect result\n\nThese two were hidden by the earlier IR test failures.  The errors look\nlike:\n\n  Caused by: java.lang.RuntimeException: assertEquals: expected -1163019586 to equal 777\n  at jdk.test.lib.Asserts.fail(Asserts.java:594)\n  at jdk.test.lib.Asserts.assertEquals(Asserts.java:205)\n  at jdk.test.lib.Asserts.assertEquals(Asserts.java:189)\n  at jdk.test.lib.Asserts.assertEQ(Asserts.java:166)\n  at compiler.valhalla.inlinetypes.TestCallingConventionC1.test64_verifier(TestCallingConventionC1.java:1518)\n  ... 9 more\n\nIn the C1 scalarised entry point we call a runtime stub to allocate\nobjects for buffering the incoming inline types.  The runtime stub\nreturns its result in r0 which is also j_rarg7 and might be holding a\nlive argument value.  To work around this we temporarily move j_rarg7\ninto r21 which is known to be free at this point and then move it back\nafter the call.  However if a GC occurs during the runtime call and an\nobject held in j_rarg7 is moved, r21 will still be pointing at the old\nfrom-space copy after the call returns because it's not recorded in the\noop map.  Fix that by having the stub return the object array in r20 and\nleave r0-r7 untouched."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp"}],"sha":"ff5a938bd716430da51f1a77ba7427ceea0b37b1"}]