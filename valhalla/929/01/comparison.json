{"files":[{"patch":"@@ -113,1 +113,1 @@\n-    -XDenableValueTypes \\\n+    -XDenableValueTypes -XDenablePrimitiveClasses \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-  JAVA_WARNINGS_ARE_ERRORS ?= -Werror\n+  JAVA_WARNINGS_ARE_ERRORS ?=\n@@ -276,1 +276,1 @@\n-  $1_FLAGS += -g -Xlint:all $$($1_TARGET_RELEASE) $$(PARANOIA_FLAGS) $$(JAVA_WARNINGS_ARE_ERRORS)\n+  $1_FLAGS += -g -XDenablePrimitiveClasses -Xlint:all $$($1_TARGET_RELEASE) $$(PARANOIA_FLAGS) $$(JAVA_WARNINGS_ARE_ERRORS)\n","filename":"make\/common\/JavaCompilation.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1186,0 +1186,8 @@\n+    \/\/ Skip scalarization for vector value objects (concrete vectors and payloads).\n+    load_klass(rdi, rax, rscratch1);\n+    movptr(rscratch1, rax);\n+    super_call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::skip_value_scalarization), rdi);\n+    testptr(rax, rax);\n+    movptr(rax, rscratch1);\n+    jcc(Assembler::notZero, skip);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1773,0 +1774,13 @@\n+bool ciEnv::is_multifield_scalarized(BasicType bt, int vec_length) {\n+#if COMPILER2\n+  CompilerThread* ct = CompilerThread::current();\n+  if (ct && ct->compiler()->is_c2()) {\n+    return InlineTypeNode::is_multifield_scalarized(bt, vec_length);\n+  } else {\n+    return true;\n+  }\n+#else\n+  return true;\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -523,0 +523,1 @@\n+  static bool is_multifield_scalarized(BasicType type, int vec_len);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+  _is_multifield = false;\n+  _is_multifield_base = false;\n@@ -196,1 +198,1 @@\n-ciField::ciField(fieldDescriptor *fd) :\n+ciField::ciField(fieldDescriptor *fd, bool bundled) :\n@@ -207,0 +209,2 @@\n+  initialize_from(fd);\n+\n@@ -212,1 +216,2 @@\n-    _type = ciType::make(field_type);\n+    int bundle_size = bundled ? fd->secondary_fields_count(fd->index()) : 1;\n+    _type = ciType::make(field_type, bundle_size);\n@@ -215,2 +220,0 @@\n-  initialize_from(fd);\n-\n@@ -245,0 +248,2 @@\n+  _is_multifield_base = field->_is_multifield_base;\n+  _is_multifield = field->_is_multifield;\n@@ -298,0 +303,4 @@\n+  _is_multifield_base = fd->is_multifield_base() &&\n+     !ciEnv::is_multifield_scalarized(fd->field_type(), fd->secondary_fields_count(fd->index()));\n+  _is_multifield = fd->is_multifield();\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -43,0 +44,1 @@\n+  friend class ciMultiField;\n@@ -55,0 +57,2 @@\n+  bool             _is_multifield;\n+  bool             _is_multifield_base;\n@@ -63,1 +67,1 @@\n-  ciField(fieldDescriptor* fd);\n+  ciField(fieldDescriptor* fd, bool bundled = false);\n@@ -108,0 +112,4 @@\n+  bool is_multifield() { return _is_multifield; }\n+  bool is_multifield_base() { return _is_multifield_base; }\n+  int secondary_fields_count() { return type()->bundle_size(); }\n+\n@@ -192,0 +200,33 @@\n+class ciMultiField : public ciField {\n+private:\n+  CI_PACKAGE_ACCESS\n+  friend class ciInstanceKlass;\n+\n+  GrowableArray<ciField*>* _secondary_fields;\n+\n+  ciMultiField(ciInstanceKlass* klass, int index, Bytecodes::Code bc) : ciField(klass, index, bc) {}\n+  ciMultiField(fieldDescriptor* fd, bool bundled) : ciField(fd, bundled) {\n+    _is_multifield_base = true;\n+  }\n+  ciMultiField(ciField* field, ciInstanceKlass* holder, int offset, bool is_final) :\n+       ciField(field, holder, offset, is_final) {}\n+public:\n+  void set_secondary_fields(GrowableArray<ciField*>* fields) {\n+    Arena* arena = CURRENT_ENV->arena();\n+    _secondary_fields = new (arena) GrowableArray<ciField*>(arena, fields->length(), 0, nullptr);\n+    for (int i = 0; i < fields->length(); i++) {\n+      ciField* field = fields->at(i);\n+      _secondary_fields->append(new (arena) ciField(field, field->holder(), field->offset_in_bytes(), field->is_final()));\n+    }\n+  }\n+\n+  void add_secondary_fields(GrowableArray<ciField*>* fields) { _secondary_fields = fields; }\n+\n+  GrowableArray<ciField*>* secondary_fields() { return _secondary_fields; }\n+\n+  ciField* secondary_field_at(int i) {\n+    assert(_secondary_fields->length() > i, \"\");\n+    return _secondary_fields->at(i);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciEnv.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciField.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -527,1 +527,4 @@\n-GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool is_flat) {\n+\n+\/\/ Generic routine to handle synthetic field population for both static\n+\/\/ and non-static base multifields.\n+ciField* ciInstanceKlass::populate_synthetic_multifields(ciField* field) {\n@@ -529,0 +532,5 @@\n+  if (!field->is_multifield_base()) {\n+    return field;\n+  }\n+  int sec_fields_count = 0;\n+  ciMultiField* mfield = static_cast<ciMultiField*>(field);\n@@ -530,0 +538,29 @@\n+  InstanceKlass* k = get_instanceKlass();\n+\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.offset() == field->offset_in_bytes()) {\n+      assert(mfield == field, \"Duplicate multifield for a given offset\");\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.is_multifield_base(), \"\");\n+      mfield = new (arena) ciMultiField(&fd, true);\n+\n+      sec_fields_count = fd.secondary_fields_count(fd.index()) - 1;\n+      mfield->add_secondary_fields(new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, nullptr));\n+      if (sec_fields_count == 0) {\n+        break;\n+      }\n+    } else if (sec_fields_count && fs.is_multifield()) {\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      mfield->secondary_fields()->append(new (arena) ciField(&fd));\n+      sec_fields_count--;\n+      if (sec_fields_count == 0) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  return mfield;\n+}\n+\n+GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool is_flat) {\n+  ASSERT_IN_VM;\n@@ -531,0 +568,1 @@\n+  Arena* arena = CURRENT_ENV->arena();\n@@ -550,0 +588,1 @@\n+  int sec_fields_count = 0;\n@@ -552,0 +591,10 @@\n+    if (fs.is_multifield() && sec_fields_count) {\n+      assert(fields->last()->is_multifield_base(), \"\");\n+      sec_fields_count--;\n+      flen--;\n+      ciMultiField* multifield_base = static_cast<ciMultiField*>(fields->last());\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      multifield_base->secondary_fields()->append(new (arena) ciField(&fd));\n+      continue;\n+    }\n+    assert(!sec_fields_count, \"\");\n@@ -568,1 +617,12 @@\n-        ciField* field = new (arena) ciField(flat_field, this, offset, is_final);\n+        ciField* field = nullptr;\n+        ciType* ftype = flat_field->type();\n+        assert(ftype, \"\");\n+        BasicType bt = ftype->basic_type();\n+        int sec_fields_count = ftype->bundle_size();\n+        bool scalarize_multifield = ciEnv::is_multifield_scalarized(bt, sec_fields_count);\n+        if (flat_field->is_multifield_base() && !scalarize_multifield) {\n+          field = new (arena) ciMultiField(flat_field, this, offset, is_final);\n+          static_cast<ciMultiField*>(field)->set_secondary_fields(static_cast<ciMultiField*>(flat_field)->secondary_fields());\n+        } else {\n+          field = new (arena) ciField(flat_field, this, offset, is_final);\n+        }\n@@ -572,1 +632,13 @@\n-      ciField* field = new (arena) ciField(&fd);\n+      ciField* field = nullptr;\n+      BasicType bt = fd.field_type();\n+      sec_fields_count = fd.secondary_fields_count(fd.index());\n+      bool scalarize_multifield = ciEnv::is_multifield_scalarized(bt, sec_fields_count);\n+      if (fs.is_multifield_base() && !scalarize_multifield) {\n+        field = new (arena) ciMultiField(&fd, true);\n+        GrowableArray<ciField*>* sec_fields = new (arena) GrowableArray<ciField*>(arena, sec_fields_count, 0, nullptr);\n+        static_cast<ciMultiField*>(field)->add_secondary_fields(sec_fields);\n+        sec_fields_count--;\n+      } else {\n+        field = new (arena) ciField(&fd);\n+        sec_fields_count = 0;\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":75,"deletions":3,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  friend class ciMultiField;\n@@ -213,0 +214,1 @@\n+  ciField* populate_synthetic_multifields(ciField* field);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,0 +324,3 @@\n+  if (f && f->is_multifield_base()) {\n+    GUARDED_VM_ENTRY(f = _holder->populate_synthetic_multifields(f);)\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-ciType::ciType(BasicType basic_type) : ciMetadata() {\n+ciType::ciType(BasicType basic_type, int bundle_size) : ciMetadata() {\n@@ -45,0 +45,1 @@\n+  _bundle_size = bundle_size;\n@@ -49,0 +50,1 @@\n+  _bundle_size = 1;\n@@ -109,7 +111,11 @@\n-ciType* ciType::make(BasicType t) {\n-  \/\/ short, etc.\n-  \/\/ Note: Bare T_ADDRESS means a raw pointer type, not a return_address.\n-  assert((uint)t < T_CONFLICT+1, \"range check\");\n-  if (t == T_OBJECT)  return ciEnv::_Object_klass;  \/\/ java\/lang\/Object\n-  assert(_basic_types[t] != nullptr, \"domain check\");\n-  return _basic_types[t];\n+ciType* ciType::make(BasicType t, int bundle_size) {\n+  if (bundle_size == 1) {\n+    \/\/ short, etc.\n+    \/\/ Note: Bare T_ADDRESS means a raw pointer type, not a return_address.\n+    assert((uint)t < T_CONFLICT+1, \"range check\");\n+    if (t == T_OBJECT)  return ciEnv::_Object_klass;  \/\/ java\/lang\/Object\n+    assert(_basic_types[t] != NULL, \"domain check\");\n+    return _basic_types[t];\n+  } else {\n+    return new (CURRENT_ENV->arena()) ciType(t, bundle_size);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  int _bundle_size;\n@@ -43,1 +44,1 @@\n-  ciType(BasicType t);     \/\/ for primitive and unloaded types\n+  ciType(BasicType t, int bundle_size = 1);     \/\/ for primitive and unloaded types\n@@ -66,1 +67,3 @@\n-  int size() const                          { return type2size[basic_type()]; }\n+  int size() const                          { return _bundle_size * type2size[basic_type()]; }\n+  int elem_word_count() const               { return type2size[basic_type()]; }\n+  int bundle_size() const                   { return _bundle_size; }\n@@ -68,2 +71,2 @@\n-  bool is_one_word() const                  { return size() == 1; }\n-  bool is_two_word() const                  { return size() == 2; }\n+  bool is_one_word() const                  { return type2size[basic_type()] == 1; }\n+  bool is_two_word() const                  { return type2size[basic_type()] == 2; }\n@@ -84,1 +87,1 @@\n-  static ciType* make(BasicType t);\n+  static ciType* make(BasicType t, int bundle_size = 1);\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -991,0 +991,1 @@\n+    _jdk_internal_vm_annotation_MultiField,\n@@ -997,0 +998,1 @@\n+  jbyte _multifield_arg;\n@@ -1023,0 +1025,3 @@\n+  void set_multifield_arg(jbyte arg) { _multifield_arg = arg; }\n+  jbyte multifield_arg() const { return _multifield_arg; }\n+\n@@ -1024,0 +1029,1 @@\n+  bool is_multifield_base() const { return has_annotation(_jdk_internal_vm_annotation_MultiField); }\n@@ -1163,0 +1169,3 @@\n+    b_tag_val = 'B',\n+    b_con_off = 7,\n+    b_size = 9,\n@@ -1209,0 +1218,9 @@\n+    } else if (AnnotationCollector::_jdk_internal_vm_annotation_MultiField == id) {\n+      \/\/ TODO: change those assertion into a conditional statement to process the value\n+      assert(count == 1, \"MultiField annotation must have at least one argument\");  \/\/ Is it true?\n+      assert(member == vmSymbols::value_name(), \"Must be\");\n+      assert(b_tag_val == *(abase + tag_off), \"Must be a byte value\");\n+      int arg_index = Bytes::get_Java_u2((address)abase + b_con_off);\n+      int multifield_arg = cp->int_at(arg_index);\n+      assert(((jbyte)multifield_arg) == multifield_arg, \"Must be\");\n+      coll->set_multifield_arg(multifield_arg);\n@@ -1511,1 +1529,7 @@\n-  ResourceMark rm(THREAD);\n+  \/\/ ResourceMark rm(THREAD);\n+  GrowableArray<MultiFieldInfo>* temp_multifield_info = new GrowableArray<MultiFieldInfo>(0); \/\/ could be allocated lazily\n+  GrowableArray<AnnotationArray*>* fields_annotations = nullptr;\n+  GrowableArray<AnnotationArray*>* fields_type_annotations = nullptr;\n+\n+  int field_index = -1;\n+  int inj_multifields = 0;\n@@ -1513,0 +1537,1 @@\n+    field_index++;\n@@ -1558,4 +1583,2 @@\n-        if (_fields_annotations == nullptr) {\n-          _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n-                                             _loader_data, length, nullptr,\n-                                             CHECK);\n+        if (fields_annotations == nullptr) {\n+          fields_annotations = new GrowableArray<AnnotationArray*>(length);\n@@ -1563,1 +1586,2 @@\n-        _fields_annotations->at_put(n, parsed_annotations.field_annotations());\n+\n+        fields_annotations->at_put_grow(field_index, parsed_annotations.field_annotations(), nullptr);\n@@ -1567,6 +1591,2 @@\n-        if (_fields_type_annotations == nullptr) {\n-          _fields_type_annotations =\n-            MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n-                                                         length,\n-                                                         nullptr,\n-                                                         CHECK);\n+        if (fields_type_annotations == nullptr) {\n+          fields_type_annotations = new GrowableArray<AnnotationArray*>(length);\n@@ -1574,1 +1594,1 @@\n-        _fields_type_annotations->at_put(n, parsed_annotations.field_type_annotations());\n+        fields_type_annotations->at_put_grow(field_index, parsed_annotations.field_type_annotations(), nullptr);\n@@ -1598,1 +1618,1 @@\n-    fi.set_index(n);\n+    fi.set_index(field_index);\n@@ -1606,1 +1626,43 @@\n-    _temp_field_info->append(fi);\n+\n+    int base_idx = _temp_field_info->append(fi);\n+    assert(base_idx == field_index, \"Must be\");\n+    FieldInfo* const field = _temp_field_info->adr_at(field_index);\n+\n+    if (parsed_annotations.is_multifield_base() && is_java_primitive(cp->basic_type_for_signature_at(signature_index))) {\n+      field->field_flags_addr()->update_multifield_base(true);\n+      char* base_name = cp->symbol_at(name_index)->as_C_string();\n+      for (int i = 1; i < parsed_annotations.multifield_arg(); i++) {\n+        field_index++;\n+        stringStream st;\n+        st.print(\"%s\", base_name);\n+        st.print(\"#\");\n+        st.print(\"%d\", i);\n+        Symbol* inj_name = SymbolTable::new_symbol(st.as_string());\n+        MultiFieldInfo mfi(inj_name, base_idx, i);\n+        int mfi_idx = temp_multifield_info->append(mfi);\n+\n+        const BasicType type = cp->basic_type_for_signature_at(signature_index);\n+        \/\/ Update FieldAllocationCount for this kind of field\n+        fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n+\n+        FieldInfo::FieldFlags fflags(0);\n+        \/\/ fflags.update_injected(true);\n+        AccessFlags aflags;\n+        aflags.set_flags(flags);\n+        FieldInfo fi(aflags, (u2)(mfi_idx), (u2)signature_index, 0, fflags);\n+        fi.set_index(field_index);\n+\n+        int inj_idx = _temp_field_info->append(fi);\n+        assert(inj_idx == field_index, \"Must be\");\n+        FieldInfo* const field = _temp_field_info->adr_at(inj_idx);\n+\n+        field->field_flags_addr()->update_multifield(true);\n+        if (fields_annotations != nullptr && fields_annotations->at(base_idx) != nullptr) {\n+          fields_annotations->at_put_grow(field_index, fields_annotations->at(base_idx));\n+        }\n+        if (fields_type_annotations != nullptr && fields_type_annotations->at(base_idx) != nullptr) {\n+          fields_type_annotations->at_put_grow(field_index, fields_type_annotations->at(base_idx));\n+        }\n+        inj_multifields++;\n+      }\n+    }\n@@ -1608,1 +1670,1 @@\n-  assert(_temp_field_info->length() == length, \"Must be\");\n+  assert(_temp_field_info->length() == (length + inj_multifields), \"Must be\");\n@@ -1610,1 +1672,2 @@\n-  int index = length;\n+  *java_fields_count_ptr = *java_fields_count_ptr + inj_multifields;\n+  int index = length + inj_multifields;\n@@ -1638,2 +1701,5 @@\n-      fi.set_index(index);\n-      _temp_field_info->append(fi);\n+      fi.set_index(field_index);\n+\n+      field_index++;\n+      int inj_idx = _temp_field_info->append(fi);\n+      assert(inj_idx == field_index, \"Must be\");\n@@ -1658,2 +1724,5 @@\n-      fi.set_index(index);\n-      _temp_field_info->append(fi);\n+    fi.set_index(index);\n+\n+    field_index++;\n+    int inj_idx = _temp_field_info->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1679,1 +1748,4 @@\n-    _temp_field_info->append(fi);\n+\n+    field_index++;\n+    int inj_idx = _temp_field_info->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1692,0 +1764,29 @@\n+  if (temp_multifield_info->length() > 0) {\n+    _multifield_info = MetadataFactory::new_array<MultiFieldInfo>(_loader_data,\n+                                                                  temp_multifield_info->length(),\n+                                                                  CHECK);\n+    for (int i = 0; i < temp_multifield_info->length(); i++) {\n+      _multifield_info->at_put(i, temp_multifield_info->at(i));\n+    }\n+  }\n+\n+  if (fields_annotations != nullptr) {\n+    _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n+                                                                       _temp_field_info->length(),\n+                                                                       nullptr,\n+                                                                       CHECK);\n+    for (int i = 0; i < fields_annotations->length(); i++) {\n+      _fields_annotations->at_put(i, fields_annotations->at(i));\n+    }\n+  }\n+\n+  if (fields_type_annotations != nullptr) {\n+     _fields_type_annotations = MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n+                                                                             _temp_field_info->length(),\n+                                                                             nullptr,\n+                                                                             CHECK);\n+    for (int i = 0; i < fields_type_annotations->length(); i++) {\n+      _fields_type_annotations->at_put(i, fields_type_annotations->at(i));\n+    }\n+  }\n+\n@@ -1698,1 +1799,1 @@\n-      NameSigHash name_and_sig(_temp_field_info->adr_at(i)->name(_cp),\n+      NameSigHash name_and_sig(_temp_field_info->adr_at(i)->name(_multifield_info, _cp),\n@@ -2064,0 +2165,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_MultiField_signature): {\n+      if (_location != _in_field) break;  \/\/ only allow for fields\n+      if (!privileged)            break;  \/\/ honor privileges\n+      return _jdk_internal_vm_annotation_MultiField;\n+    }\n@@ -3230,0 +3336,1 @@\n+    const Symbol* outer_class_name = nullptr;\n@@ -3231,1 +3338,1 @@\n-      const Symbol* const outer_class_name = cp->klass_name_at(outer_class_info_index);\n+      outer_class_name = cp->klass_name_at(outer_class_info_index);\n@@ -3275,1 +3382,1 @@\n-    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n+    verify_legal_class_modifiers(flags, name, outer_class_name, false, CHECK_0);\n@@ -4118,0 +4225,1 @@\n+  this_klass->set_multifield_info(_multifield_info);\n@@ -4704,0 +4812,14 @@\n+\/\/ utility function to skip over internal jdk primitive classes used to override the need for passing\n+\/\/ an explict JVM flag EnablePrimitiveClasses.\n+bool ClassFileParser::is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const {\n+  if (outer_class &&\n+      inner_class &&\n+      (vmSymbols::jdk_internal_vm_vector_VectorSupport() == outer_class ||\n+       vmSymbols::jdk_internal_vm_vector_VectorPayloadMF() == outer_class)) {\n+    if (strstr(inner_class, \"VectorPayloadMF\")) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -4706,1 +4828,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, const Symbol* outer_class, bool is_Object, TRAPS) const {\n@@ -4734,1 +4856,1 @@\n-  if (is_primitive_class && !EnablePrimitiveClasses) {\n+  if (is_primitive_class && !is_jdk_internal_class(outer_class, name) && !EnablePrimitiveClasses) {\n@@ -5629,0 +5751,1 @@\n+  assert(nullptr == _multifield_info, \"invariant\");\n@@ -5910,0 +6033,1 @@\n+  _multifield_info(nullptr),\n@@ -5997,0 +6121,1 @@\n+  _multifield_info = nullptr;\n@@ -6015,0 +6140,4 @@\n+  if (_multifield_info != nullptr) {\n+    MetadataFactory::free_array<MultiFieldInfo>(_loader_data, _multifield_info);\n+  }\n+\n@@ -6160,2 +6289,0 @@\n-  verify_legal_class_modifiers(flags, nullptr, is_java_lang_Object, CHECK);\n-\n@@ -6261,0 +6388,3 @@\n+  const Symbol* super_klass_name = _super_class_index ? cp->klass_name_at(_super_class_index) : nullptr;\n+  verify_legal_class_modifiers(flags, _class_name->as_C_string(), super_klass_name, is_java_lang_Object, CHECK);\n+\n@@ -6356,0 +6486,12 @@\n+bool ClassFileParser::is_jdk_internal_class(const Klass* cls) {\n+  while(cls) {\n+    const Symbol* cls_name = cls->name();\n+    if(cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayload() ||\n+       cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayloadMF()) {\n+      return true;\n+    }\n+    cls = cls->super();\n+   }\n+   return false;\n+}\n+\n@@ -6503,1 +6645,1 @@\n-  if (EnablePrimitiveClasses) {\n+  if (EnablePrimitiveClasses || is_jdk_internal_class(_super_klass)) {\n@@ -6534,1 +6676,1 @@\n-      _field_info, _inline_type_field_klasses);\n+      _field_info, _inline_type_field_klasses, _multifield_info);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":173,"deletions":31,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -504,1 +505,1 @@\n-  void verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const;\n+  void verify_legal_class_modifiers(jint flags, const char* name, const Symbol* out_class, bool is_Object, TRAPS) const;\n@@ -524,0 +525,3 @@\n+  bool is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const;\n+  bool is_jdk_internal_class(const Klass* cls);\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  _is_reference(false) {\n+  _is_reference(false),\n+  _multifield_index(-1) {\n@@ -56,1 +57,1 @@\n-LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :\n+LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index) :\n@@ -65,2 +66,3 @@\n- _is_reference(is_reference) {\n-  assert(kind == REGULAR || kind == FLAT || kind == INHERITED,\n+ _is_reference(is_reference),\n+ _multifield_index(multifield_index) {\n+  assert(kind == REGULAR || kind == FLAT || kind == INHERITED || kind == MULTIFIELD,\n@@ -85,0 +87,1 @@\n+  _multifields(nullptr),\n@@ -90,1 +93,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false, -1);\n@@ -100,1 +103,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true, -1);\n@@ -109,1 +112,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, vk->get_exact_size_in_bytes(), vk->get_alignment(), false, -1);\n@@ -118,0 +121,24 @@\n+void FieldGroup::add_multifield(ConstantPool* cp, FieldInfo* field, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk) {\n+  assert(field->is_multifield() || field->is_multifield_base(), \"Must be\");\n+  u2 base = field->multifield_base(multifield_info);\n+  BasicType type = Signature::basic_type(field->signature(cp));\n+  MultiFieldGroup* mfg = NULL;\n+  if (_multifields != NULL) {\n+    for (int i = 0; i < _multifields->length(); i++) {\n+      if (base == _multifields->at(i)->multifield_base()) {\n+        mfg = _multifields->at(i);\n+        break;\n+      }\n+    }\n+  } else {\n+    _multifields = new GrowableArray<MultiFieldGroup*>(INITIAL_LIST_SIZE);\n+  }\n+  if (mfg == NULL) {\n+    mfg = new MultiFieldGroup(base, field->signature(cp));\n+    mfg->add_field(cp, field, vk, multifield_info);\n+    _multifields->append(mfg);\n+  } else {\n+    mfg->add_field(cp, field, vk, multifield_info);\n+  }\n+}\n+\n@@ -125,0 +152,16 @@\n+  if (_multifields != NULL) {\n+    for (int i = 0; i < _multifields->length(); i++) {\n+      int size = _multifields->at(i)->fields()->at(0)->size();\n+      int alignment =  _multifields->at(i)->fields()->at(0)->alignment();\n+      int multialignment = size\/alignment;\n+      if (size % multialignment != 0) multialignment+= alignment;\n+      \/\/ Problem: at this point, multialignment can be a weird number, for instance not a power of two\n+      int multisize = multialignment * alignment * _multifields->at(i)->fields()->length();  \/\/ should be stored\n+      \/\/ True alignment should be adjusted to increase chances to be on a single cache line\n+      int multifield_group_alignment = MIN2(round_up_power_of_2(multisize), HeapWordSize);\n+      _multifields->at(i)->set_group_size(multisize);\n+      _multifields->at(i)->set_group_alignment(multifield_group_alignment);\n+      _multifields->at(i)->fields()->sort(MultiFieldGroup::compare_multifield_index);\n+    }\n+    _multifields->sort(MultiFieldGroup::compare_multifield_groups_inverted);\n+  }\n@@ -141,1 +184,28 @@\n-FieldLayout::FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp) :\n+MultiFieldGroup::MultiFieldGroup(u2 base, Symbol* signature) :  _multifield_base(base), _signature(signature), _fields(NULL) { }\n+\n+void MultiFieldGroup::add_field(ConstantPool* cp, FieldInfo* field, InlineKlass* vk, Array<MultiFieldInfo>* multifield_info) {\n+  assert(field->is_multifield() || field->is_multifield_base(), \"Must be\");\n+  assert(field->multifield_base(multifield_info) == multifield_base(), \"multifield base mismatch\");\n+  if (_fields == NULL) {\n+    _fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  } else {\n+    guarantee(field->signature(cp) == signature(), \"multifield signature mismatch\");\n+  }\n+  BasicType type = Signature::basic_type(field->signature(cp));\n+  LayoutRawBlock* block = NULL;\n+  if (type == T_PRIMITIVE_OBJECT) {\n+    block = new LayoutRawBlock(field->index(), LayoutRawBlock::MULTIFIELD, vk->get_exact_size_in_bytes(),\n+                               vk->get_alignment(), false, field->multifield_index(multifield_info));\n+  } else {\n+    int size = type2aelembytes(type);\n+    block = new LayoutRawBlock(field->index(), LayoutRawBlock::MULTIFIELD, size, size, false, field->multifield_index(multifield_info));\n+  }\n+  int cursor = 0;\n+  for (; cursor < _fields->length(); cursor++) {\n+    assert(_fields->at(cursor)->multifield_index() != field->multifield_index(multifield_info), \"multifield index duplicate found\");\n+    if (_fields->at(cursor)->multifield_index() > field->multifield_index(multifield_info)) break;\n+  }\n+  _fields->insert_before(cursor, block);\n+}\n+\n+FieldLayout::FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp, Array<MultiFieldInfo>* multifields) :\n@@ -144,0 +214,1 @@\n+  _multifield_info(multifields),\n@@ -187,0 +258,1 @@\n+         && block->kind() != LayoutRawBlock::MULTIFIELD\n@@ -316,0 +388,31 @@\n+void FieldLayout::add_multifield(MultiFieldGroup* multifield_group, LayoutRawBlock* start) {\n+  if (start == NULL) {\n+    start = _start;\n+  }\n+  LayoutRawBlock* candidate = NULL;\n+  if (start == last_block()) {\n+    candidate = last_block();\n+  } else {\n+    candidate = last_block()->prev_block();\n+    while (candidate->kind() != LayoutRawBlock::EMPTY || !candidate->fit(multifield_group->group_size(), multifield_group->group_alignment())) {\n+      if (candidate == start) {\n+        candidate = last_block();\n+        break;\n+      }\n+      candidate = candidate->prev_block();\n+    }\n+    assert(candidate != NULL, \"Candidate must not be null\");\n+    assert(candidate->kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n+  }\n+  if ((candidate->offset() % multifield_group->group_alignment()) != 0) {\n+    int adjustment = multifield_group->group_alignment() - (candidate->offset() % multifield_group->group_alignment());\n+    LayoutRawBlock* adj = new LayoutRawBlock(LayoutRawBlock::EMPTY, adjustment);\n+    insert(candidate, adj);\n+  }\n+  assert(candidate->fit(multifield_group->group_size(), multifield_group->group_alignment()), \"Candidate must be able to store the whole contiguous block\");\n+  for (int i = 0; i < multifield_group->fields()->length(); i++) {\n+    LayoutRawBlock* b = multifield_group->fields()->at(i);\n+    insert_field_block(candidate, b);\n+  }\n+}\n+\n@@ -335,1 +438,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n@@ -344,1 +447,1 @@\n-                                   vk->get_alignment(), false);\n+                                   vk->get_alignment(), false, -1);\n@@ -349,1 +452,1 @@\n-        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false, -1);\n@@ -473,1 +576,1 @@\n-                         fi->name(_cp)->as_C_string(),\n+                         fi->name(_multifield_info, _cp)->as_C_string(),\n@@ -484,1 +587,1 @@\n-                         fi->name(_cp)->as_C_string(),\n+                         fi->name(_multifield_info, _cp)->as_C_string(),\n@@ -504,1 +607,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n@@ -516,0 +619,1 @@\n+          }\n@@ -518,0 +622,1 @@\n+        break;\n@@ -519,14 +624,22 @@\n-      break;\n-    }\n-    case LayoutRawBlock::EMPTY:\n-      output->print_cr(\" @%d %d\/1 %s\",\n-                       b->offset(),\n-                       b->size(),\n-                       \"EMPTY\");\n-      break;\n-    case LayoutRawBlock::PADDING:\n-      output->print_cr(\" @%d %d\/1 %s\",\n-                       b->offset(),\n-                       b->size(),\n-                       \"PADDING\");\n-      break;\n+      case LayoutRawBlock::EMPTY:\n+        output->print_cr(\" @%d %d\/1 %s\",\n+                         b->offset(),\n+                         b->size(),\n+                         \"EMPTY\");\n+        break;\n+      case LayoutRawBlock::PADDING:\n+        output->print_cr(\" @%d %d\/1 %s\",\n+                         b->offset(),\n+                         b->size(),\n+                         \"PADDING\");\n+        break;\n+      case LayoutRawBlock::MULTIFIELD:\n+        FieldInfo* fi = _field_info->adr_at(b->field_index());\n+        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                         b->offset(),\n+                         fi->name(_multifield_info, _cp)->as_C_string(),\n+                         fi->signature(_cp)->as_C_string(),\n+                         b->size(),\n+                         b->alignment(),\n+                         \"MULTIFIELD\");\n+        break;\n@@ -540,1 +653,2 @@\n-                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses) :\n+                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses,\n+                                       Array<MultiFieldInfo>* multifields) :\n@@ -547,0 +661,1 @@\n+  _multifield_info(multifields),\n@@ -578,1 +693,1 @@\n-  _layout = new FieldLayout(_field_info, _constant_pool);\n+  _layout = new FieldLayout(_field_info, _constant_pool, _multifield_info);\n@@ -584,1 +699,1 @@\n-  _static_layout = new FieldLayout(_field_info, _constant_pool);\n+  _static_layout = new FieldLayout(_field_info, _constant_pool, _multifield_info);\n@@ -620,22 +735,21 @@\n-    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n-    switch(type) {\n-    case T_BYTE:\n-    case T_CHAR:\n-    case T_DOUBLE:\n-    case T_FLOAT:\n-    case T_INT:\n-    case T_LONG:\n-    case T_SHORT:\n-    case T_BOOLEAN:\n-      group->add_primitive_field(idx, type);\n-      break;\n-    case T_OBJECT:\n-    case T_ARRAY:\n-    case T_PRIMITIVE_OBJECT:  \/\/ T_PRIMITIVE_OBJECT is going to me removed, inline types are detected below\n-      if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n-        if (group != _static_fields) _nonstatic_oopmap_count++;\n-        group->add_oop_field(idx);\n-      } else {\n-        _has_inline_type_fields = true;\n-        if (group == _static_fields) {\n-          \/\/ static fields are never flat\n+    bool has_multifield_annotation = false;\n+    if (fieldinfo.is_multifield() || fieldinfo.is_multifield_base()) {\n+      group->add_multifield(_constant_pool, &fieldinfo, _multifield_info);\n+    } else {\n+      BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n+      switch(type) {\n+      case T_BYTE:\n+      case T_CHAR:\n+      case T_DOUBLE:\n+      case T_FLOAT:\n+      case T_INT:\n+      case T_LONG:\n+      case T_SHORT:\n+      case T_BOOLEAN:\n+        group->add_primitive_field(idx, type);\n+        break;\n+      case T_OBJECT:\n+      case T_ARRAY:\n+      case T_PRIMITIVE_OBJECT:  \/\/ T_PRIMITIVE_OBJECT is going to me removed, inline types are detected below\n+        if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+          if (group != _static_fields) _nonstatic_oopmap_count++;\n@@ -644,27 +758,3 @@\n-          _has_flattening_information = true;\n-          \/\/ Flattening decision to be taken here\n-          \/\/ This code assumes all verification already have been performed\n-          \/\/ (field's type has been loaded and it is an inline klass)\n-          JavaThread* THREAD = JavaThread::current();\n-          Klass* klass =  _inline_type_field_klasses->at(idx);\n-          assert(klass != nullptr, \"Sanity check\");\n-          InlineKlass* vk = InlineKlass::cast(klass);\n-          bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                    (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-          bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-          bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n-          if (vk->is_naturally_atomic()) {\n-            too_atomic_to_flatten = false;\n-            \/\/too_volatile_to_flatten = false; \/\/FIXME\n-            \/\/ Currently, volatile fields are never flat, this could change in the future\n-          }\n-          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n-            group->add_flat_field(idx, vk);\n-            _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-            _field_info->adr_at(idx)->field_flags_addr()->update_flat(true);\n-            if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-              _has_nonatomic_values = true;\n-              _atomic_field_count--;  \/\/ every other field is atomic but this one\n-            }\n-          } else {\n-            _nonstatic_oopmap_count++;\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never flat\n@@ -672,0 +762,30 @@\n+          } else {\n+            _has_flattening_information = true;\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verification already have been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            JavaThread* THREAD = JavaThread::current();\n+            Klass* klass =  _inline_type_field_klasses->at(idx);\n+            assert(klass != nullptr, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ Currently, volatile fields are never flat, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n+              group->add_flat_field(idx, vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              _field_info->adr_at(idx)->field_flags_addr()->update_flat(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              group->add_oop_field(idx);\n+            }\n@@ -673,0 +793,3 @@\n+          break;\n+        default:\n+          fatal(\"Something wrong?\");\n@@ -675,3 +798,0 @@\n-      break;\n-    default:\n-      fatal(\"Something wrong?\");\n@@ -714,20 +834,15 @@\n-    assert(group != nullptr, \"invariant\");\n-    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n-    switch(type) {\n-    case T_BYTE:\n-    case T_CHAR:\n-    case T_DOUBLE:\n-    case T_FLOAT:\n-    case T_INT:\n-    case T_LONG:\n-    case T_SHORT:\n-    case T_BOOLEAN:\n-      if (group != _static_fields) {\n-        field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n-      }\n-      group->add_primitive_field(fieldinfo.index(), type);\n-      break;\n-    case T_OBJECT:\n-    case T_ARRAY:\n-    case T_PRIMITIVE_OBJECT: \/\/ T_PRIMITIVE_OBJECT is going to be removed, online types are detected below\n-      if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+    bool has_multifield_annotation = false;\n+    if (fieldinfo.is_multifield() || fieldinfo.is_multifield_base()) {\n+      group->add_multifield(_constant_pool, &fieldinfo, _multifield_info);\n+    } else {\n+      assert(group != nullptr, \"invariant\");\n+      BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n+      switch(type) {\n+      case T_BYTE:\n+      case T_CHAR:\n+      case T_DOUBLE:\n+      case T_FLOAT:\n+      case T_INT:\n+      case T_LONG:\n+      case T_SHORT:\n+      case T_BOOLEAN:\n@@ -735,2 +850,1 @@\n-          _nonstatic_oopmap_count++;\n-          field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+          field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n@@ -738,5 +852,10 @@\n-        group->add_oop_field(fieldinfo.index());\n-      } else {\n-        _has_inline_type_fields = true;\n-        if (group == _static_fields) {\n-          \/\/ static fields are never flat\n+        group->add_primitive_field(fieldinfo.index(), type);\n+        break;\n+      case T_OBJECT:\n+      case T_ARRAY:\n+      case T_PRIMITIVE_OBJECT: \/\/ T_PRIMITIVE_OBJECT is going to be removed, online types are detected below\n+        if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+          if (group != _static_fields) {\n+            _nonstatic_oopmap_count++;\n+            field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+          }\n@@ -745,28 +864,3 @@\n-          \/\/ Flattening decision to be taken here\n-          \/\/ This code assumes all verifications have already been performed\n-          \/\/ (field's type has been loaded and it is an inline klass)\n-          JavaThread* THREAD = JavaThread::current();\n-          Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n-          assert(klass != nullptr, \"Sanity check\");\n-          InlineKlass* vk = InlineKlass::cast(klass);\n-          bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                    (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-          bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-          bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n-          if (vk->is_naturally_atomic()) {\n-            too_atomic_to_flatten = false;\n-            \/\/too_volatile_to_flatten = false; \/\/FIXME\n-            \/\/ Currently, volatile fields are never flat, this could change in the future\n-          }\n-          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n-            group->add_flat_field(fieldinfo.index(), vk);\n-            _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-            field_alignment = vk->get_alignment();\n-            _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_flat(true);\n-            if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-              _has_nonatomic_values = true;\n-              _atomic_field_count--;  \/\/ every other field is atomic but this one\n-            }\n-          } else {\n-            _nonstatic_oopmap_count++;\n-            field_alignment = type2aelembytes(T_OBJECT);\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never flat\n@@ -774,0 +868,31 @@\n+          } else {\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verifications have already been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            JavaThread* THREAD = JavaThread::current();\n+            Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n+            assert(klass != nullptr, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ Currently, volatile fields are never flat, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n+              group->add_flat_field(fieldinfo.index(), vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              field_alignment = vk->get_alignment();\n+              _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_flat(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              field_alignment = type2aelembytes(T_OBJECT);\n+              group->add_oop_field(fieldinfo.index());\n+            }\n@@ -776,0 +901,12 @@\n+        break;\n+      default:\n+        fatal(\"Unexpected BasicType\");\n+      }\n+      if (!fieldinfo.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n+    }\n+  }\n+  _root_group->sort_by_size();\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      if (_root_group->multifields()->at(i)->group_alignment() > alignment) {\n+        alignment = _root_group->multifields()->at(i)->group_alignment();\n@@ -777,3 +914,0 @@\n-      break;\n-    default:\n-      fatal(\"Unexpected BasicType\");\n@@ -781,1 +915,0 @@\n-    if (!fieldinfo.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n@@ -818,0 +951,5 @@\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      _layout->add_multifield(_root_group->multifields()->at(i));\n+    }\n+  }\n@@ -827,1 +965,6 @@\n-      _layout->add(cg->big_primitive_fields());\n+      if (cg->multifields() != NULL) {\n+        for (int i = 0; i < cg->multifields()->length(); i++) {\n+          _layout->add_multifield(cg->multifields()->at(i), start);\n+        }\n+      }\n+      _layout->add(cg->big_primitive_fields(), start);\n@@ -839,0 +982,5 @@\n+  if (_static_fields->multifields() != NULL) {\n+    for (int i = 0; i < _static_fields->multifields()->length(); i++) {\n+      _layout->add_multifield(_static_fields->multifields()->at(i));\n+    }\n+  }\n@@ -872,0 +1020,5 @@\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      _layout->add_multifield(_root_group->multifields()->at(i));\n+    }\n+  }\n@@ -885,1 +1038,0 @@\n-  _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":296,"deletions":144,"binary":false,"changes":440,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-    INHERITED         \/\/ field(s) inherited from super classes\n+    INHERITED,         \/\/ field(s) inherited from super classes\n+    MULTIFIELD        \/\/ fields part of a multi-field\n@@ -74,0 +75,1 @@\n+  jbyte _multifield_index;\n@@ -77,1 +79,1 @@\n-  LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference = false);\n+  LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index);\n@@ -96,0 +98,1 @@\n+  jbyte multifield_index() const { return _multifield_index; }\n@@ -123,1 +126,34 @@\n-\/\/ A Field group represents a set of fields that have to be allocated together,\n+class MultiFieldGroup : public ResourceObj {\n+ private:\n+  u2 _multifield_base;\n+  Symbol* _signature;\n+  int _group_size;\n+  int _group_alignment;\n+  GrowableArray<LayoutRawBlock*>* _fields;\n+  \/\/ total size and alignment?\n+\n+  static const int INITIAL_LIST_SIZE = 16;\n+ public:\n+  MultiFieldGroup(u2 base, Symbol* signature);\n+\n+  u2 multifield_base() const { return _multifield_base; }\n+  Symbol* signature() const { return _signature; }\n+  int group_size() const { return _group_size; }\n+  void set_group_size(int size) { _group_size = size; }\n+  int group_alignment() const { return _group_alignment; }\n+  void set_group_alignment(int alignment) { _group_alignment = alignment; }\n+  GrowableArray<LayoutRawBlock*>* fields() const { return _fields; }\n+  void add_field(ConstantPool* cp, FieldInfo* field, InlineKlass* vk, Array<MultiFieldInfo>* multifield_info);\n+  static int compare_multifield_index(LayoutRawBlock** x, LayoutRawBlock** y) {\n+    return (*x)->multifield_index() - (*y)->multifield_index();\n+  }\n+  static int compare_multifield_groups_inverted(MultiFieldGroup** x, MultiFieldGroup** y) {\n+    int diff = (*y)->group_size() - (*x)->group_size();\n+    if (diff == 0) {\n+      diff = (*y)->group_alignment() - (*x)->group_alignment();\n+    }\n+    return diff;\n+  }\n+};\n+\n+\/\/ A FieldGroup represents a set of fields that have to be allocated together,\n@@ -136,0 +172,1 @@\n+  GrowableArray<MultiFieldGroup*>* _multifields;\n@@ -148,0 +185,1 @@\n+  GrowableArray<MultiFieldGroup*>* multifields() const { return _multifields; }\n@@ -154,0 +192,1 @@\n+  void add_multifield(ConstantPool* cp, FieldInfo* field, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk = NULL);\n@@ -181,0 +220,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -186,1 +226,1 @@\n-  FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp);\n+  FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp, Array<MultiFieldInfo>* multifields);\n@@ -208,0 +248,1 @@\n+  void add_multifield(MultiFieldGroup* multifield, LayoutRawBlock* start = nullptr);\n@@ -248,0 +289,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -266,0 +308,1 @@\n+  MultiFieldGroup* get_or_create_multifield_group(int base);\n@@ -270,1 +313,1 @@\n-                     Array<InlineKlass*>* inline_type_field_klasses);\n+                     Array<InlineKlass*>* inline_type_field_klasses, Array<MultiFieldInfo>* multifields);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -4961,20 +4961,0 @@\n-int vector_VectorPayload::_payload_offset;\n-\n-#define VECTORPAYLOAD_FIELDS_DO(macro) \\\n-  macro(_payload_offset, k, \"payload\", object_signature, false)\n-\n-void vector_VectorPayload::compute_offsets() {\n-  InstanceKlass* k = vmClasses::vector_VectorPayload_klass();\n-  VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void vector_VectorPayload::serialize_offsets(SerializeClosure* f) {\n-  VECTORPAYLOAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-void vector_VectorPayload::set_payload(oop o, oop val) {\n-  o->obj_field_put(_payload_offset, val);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1739,2 +1739,0 @@\n- private:\n-  static int _payload_offset;\n@@ -1742,5 +1740,0 @@\n-  static void set_payload(oop o, oop val);\n-\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n@@ -1748,0 +1741,2 @@\n+  static void compute_offsets() { }\n+  static void serialize_offsets(SerializeClosure* f) { }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -193,0 +193,38 @@\n+  \/* support multi-field based vectors *\/                                                                       \\\n+  do_klass(vector_VectorPayloadMF_klass,                jdk_internal_vm_vector_VectorPayloadMF                ) \\\n+  do_klass(vector_VectorPayloadMF8Z_klass,              jdk_internal_vm_vector_VectorPayloadMF8Z              ) \\\n+  do_klass(vector_VectorPayloadMF16Z_klass,             jdk_internal_vm_vector_VectorPayloadMF16Z             ) \\\n+  do_klass(vector_VectorPayloadMF32Z_klass,             jdk_internal_vm_vector_VectorPayloadMF32Z             ) \\\n+  do_klass(vector_VectorPayloadMF64Z_klass,             jdk_internal_vm_vector_VectorPayloadMF64Z             ) \\\n+  do_klass(vector_VectorPayloadMF128Z_klass,            jdk_internal_vm_vector_VectorPayloadMF128Z            ) \\\n+  do_klass(vector_VectorPayloadMF256Z_klass,            jdk_internal_vm_vector_VectorPayloadMF256Z            ) \\\n+  do_klass(vector_VectorPayloadMF512Z_klass,            jdk_internal_vm_vector_VectorPayloadMF512Z            ) \\\n+  do_klass(vector_VectorPayloadMF8B_klass,              jdk_internal_vm_vector_VectorPayloadMF8B              ) \\\n+  do_klass(vector_VectorPayloadMF16B_klass,             jdk_internal_vm_vector_VectorPayloadMF16B             ) \\\n+  do_klass(vector_VectorPayloadMF32B_klass,             jdk_internal_vm_vector_VectorPayloadMF32B             ) \\\n+  do_klass(vector_VectorPayloadMF64B_klass,             jdk_internal_vm_vector_VectorPayloadMF64B             ) \\\n+  do_klass(vector_VectorPayloadMF128B_klass,            jdk_internal_vm_vector_VectorPayloadMF128B            ) \\\n+  do_klass(vector_VectorPayloadMF256B_klass,            jdk_internal_vm_vector_VectorPayloadMF256B            ) \\\n+  do_klass(vector_VectorPayloadMF512B_klass,            jdk_internal_vm_vector_VectorPayloadMF512B            ) \\\n+  do_klass(vector_VectorPayloadMF64S_klass,             jdk_internal_vm_vector_VectorPayloadMF64S             ) \\\n+  do_klass(vector_VectorPayloadMF128S_klass,            jdk_internal_vm_vector_VectorPayloadMF128S            ) \\\n+  do_klass(vector_VectorPayloadMF256S_klass,            jdk_internal_vm_vector_VectorPayloadMF256S            ) \\\n+  do_klass(vector_VectorPayloadMF512S_klass,            jdk_internal_vm_vector_VectorPayloadMF512S            ) \\\n+  do_klass(vector_VectorPayloadMF64I_klass,             jdk_internal_vm_vector_VectorPayloadMF64I             ) \\\n+  do_klass(vector_VectorPayloadMF128I_klass,            jdk_internal_vm_vector_VectorPayloadMF128I            ) \\\n+  do_klass(vector_VectorPayloadMF256I_klass,            jdk_internal_vm_vector_VectorPayloadMF256I            ) \\\n+  do_klass(vector_VectorPayloadMF512I_klass,            jdk_internal_vm_vector_VectorPayloadMF512I            ) \\\n+  do_klass(vector_VectorPayloadMF64L_klass,             jdk_internal_vm_vector_VectorPayloadMF64L             ) \\\n+  do_klass(vector_VectorPayloadMF128L_klass,            jdk_internal_vm_vector_VectorPayloadMF128L            ) \\\n+  do_klass(vector_VectorPayloadMF256L_klass,            jdk_internal_vm_vector_VectorPayloadMF256L            ) \\\n+  do_klass(vector_VectorPayloadMF512L_klass,            jdk_internal_vm_vector_VectorPayloadMF512L            ) \\\n+  do_klass(vector_VectorPayloadMF64F_klass,             jdk_internal_vm_vector_VectorPayloadMF64F             ) \\\n+  do_klass(vector_VectorPayloadMF128F_klass,            jdk_internal_vm_vector_VectorPayloadMF128F            ) \\\n+  do_klass(vector_VectorPayloadMF256F_klass,            jdk_internal_vm_vector_VectorPayloadMF256F            ) \\\n+  do_klass(vector_VectorPayloadMF512F_klass,            jdk_internal_vm_vector_VectorPayloadMF512F            ) \\\n+  do_klass(vector_VectorPayloadMF64D_klass,             jdk_internal_vm_vector_VectorPayloadMF64D             ) \\\n+  do_klass(vector_VectorPayloadMF128D_klass,            jdk_internal_vm_vector_VectorPayloadMF128D            ) \\\n+  do_klass(vector_VectorPayloadMF256D_klass,            jdk_internal_vm_vector_VectorPayloadMF256D            ) \\\n+  do_klass(vector_VectorPayloadMF512D_klass,            jdk_internal_vm_vector_VectorPayloadMF512D            ) \\\n+                                                                                                                \\\n+                                                                                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-\/\/ Mapping function names to values. New entries should be added below.\n@@ -55,0 +54,1 @@\n+\/\/ Mapping function names to values. New entries should be added below.\n@@ -94,8 +94,44 @@\n-  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")               \\\n-  template(jdk_internal_vm_vector_VectorPayload,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\") \\\n-  template(jdk_internal_vm_vector_Vector,             \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")        \\\n-  template(jdk_internal_vm_vector_VectorMask,         \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")    \\\n-  template(jdk_internal_vm_vector_VectorShuffle,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\") \\\n-  template(payload_name,                              \"payload\")                                            \\\n-  template(ETYPE_name,                                \"ETYPE\")                                              \\\n-  template(VLENGTH_name,                              \"VLENGTH\")                                            \\\n+  template(jdk_internal_vm_vector_VectorSupport,       \"jdk\/internal\/vm\/vector\/VectorSupport\")                     \\\n+  template(jdk_internal_vm_vector_VectorPayload,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\")       \\\n+  template(jdk_internal_vm_vector_Vector,              \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")              \\\n+  template(jdk_internal_vm_vector_VectorMask,          \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")          \\\n+  template(jdk_internal_vm_vector_VectorShuffle,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\")       \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF,     \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF\")     \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF8Z,   \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8Z\")   \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF16Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF32Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF8B,   \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8B\")   \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF16B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF32B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64S,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64S\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64I,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64I\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64L,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64L\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64F,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64F\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64D,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64D\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512D\") \\\n+  template(payload_name,                               \"payload\")                                                  \\\n+  template(mfield_name,                                \"mfield\")                                                   \\\n+  template(ETYPE_name,                                 \"ETYPE\")                                                    \\\n+  template(VLENGTH_name,                               \"VLENGTH\")                                                  \\\n@@ -269,0 +305,1 @@\n+  template(jdk_internal_vm_annotation_MultiField_signature,                  \"Ljdk\/internal\/vm\/annotation\/MultiField;\") \\\n@@ -271,0 +308,36 @@\n+  \/* VectorAPI support *\/                                                                         \\\n+  template(vector_VectorPayloadMF8Z_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8Z;\")   \\\n+  template(vector_VectorPayloadMF16Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16Z;\")  \\\n+  template(vector_VectorPayloadMF32Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32Z;\")  \\\n+  template(vector_VectorPayloadMF64Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64Z;\")  \\\n+  template(vector_VectorPayloadMF128Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128Z;\") \\\n+  template(vector_VectorPayloadMF256Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256Z;\") \\\n+  template(vector_VectorPayloadMF512Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512Z;\") \\\n+  template(vector_VectorPayloadMF8B_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8B;\")   \\\n+  template(vector_VectorPayloadMF16B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16B;\")  \\\n+  template(vector_VectorPayloadMF32B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32B;\")  \\\n+  template(vector_VectorPayloadMF64B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64B;\")  \\\n+  template(vector_VectorPayloadMF128B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128B;\") \\\n+  template(vector_VectorPayloadMF256B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256B;\") \\\n+  template(vector_VectorPayloadMF512B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512B;\") \\\n+  template(vector_VectorPayloadMF64S_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64S;\")  \\\n+  template(vector_VectorPayloadMF128S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128S;\") \\\n+  template(vector_VectorPayloadMF256S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256S;\") \\\n+  template(vector_VectorPayloadMF512S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512S;\") \\\n+  template(vector_VectorPayloadMF64I_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64I;\")  \\\n+  template(vector_VectorPayloadMF128I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128I;\") \\\n+  template(vector_VectorPayloadMF256I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256I;\") \\\n+  template(vector_VectorPayloadMF512I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512I;\") \\\n+  template(vector_VectorPayloadMF64L_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64L;\")  \\\n+  template(vector_VectorPayloadMF128L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128L;\") \\\n+  template(vector_VectorPayloadMF256L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256L;\") \\\n+  template(vector_VectorPayloadMF512L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512L;\") \\\n+  template(vector_VectorPayloadMF64F_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64F;\")  \\\n+  template(vector_VectorPayloadMF128F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128F;\") \\\n+  template(vector_VectorPayloadMF256F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256F;\") \\\n+  template(vector_VectorPayloadMF512F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512F;\") \\\n+  template(vector_VectorPayloadMF64D_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64D;\")  \\\n+  template(vector_VectorPayloadMF128D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128D;\") \\\n+  template(vector_VectorPayloadMF256D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256D;\") \\\n+  template(vector_VectorPayloadMF512D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512D;\") \\\n+                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":82,"deletions":9,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+  _is_larval = read_from(stream);\n@@ -195,0 +196,4 @@\n+    if (_is_larval == nullptr) {\n+      _is_larval = new MarkerValue();\n+    }\n+    _is_larval->write_on(stream);\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  ScopeValue*                _is_larval;\n@@ -142,1 +143,1 @@\n-  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = nullptr)\n+  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = nullptr, ScopeValue* is_larval = nullptr)\n@@ -144,0 +145,1 @@\n+     , _is_larval(is_larval)\n@@ -155,0 +157,1 @@\n+     , _is_larval(nullptr)\n@@ -167,0 +170,1 @@\n+  virtual ScopeValue*         is_larval() const           { return _is_larval; }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -374,1 +374,3 @@\n-  f(RecordComponent)\n+  f(RecordComponent) \\\n+  f(MultiFieldInfo) \\\n+  f(InlineKlassFixedBlock)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  class   MultiFieldInfo;    \/\/ no C++ vtable\n@@ -46,0 +47,1 @@\n+  class   InlineKlassFixedBlock; \/\/ no C++ vtable\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-  jint int_at(int which) {\n+  jint int_at(int which) const {\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-                name_index(), name(cp)->as_utf8(),\n+                name_index(), name(nullptr, cp)->as_utf8(),\n@@ -97,1 +97,5 @@\n-    assert(fi_ref->name_index() == fi.name_index(), \"Must be\");\n+    if (fi_ref->is_multifield()) {\n+      assert(fi_ref->secondary_index() == fi.secondary_index(), \"Must be\");\n+    } else {\n+      assert(fi_ref->name_index() == fi.name_index(), \"Must be\");\n+    }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class MultiFieldInfo;\n+\n@@ -57,0 +59,1 @@\n+  friend class FieldStreamBase;\n@@ -82,0 +85,2 @@\n+      _ff_multifield,        \/\/ carry a multifield annotation.\n+      _ff_multifield_base,   \/\/ is a base field of multifield bundle.\n@@ -118,0 +123,2 @@\n+    bool is_multifield() const      { return test_flag(_ff_multifield); }\n+    bool is_multifield_base() const { return test_flag(_ff_multifield_base); }\n@@ -126,0 +133,2 @@\n+    void update_multifield(bool z)       { update_flag(_ff_multifield, z); }\n+    void update_multifield_base(bool z)  { update_flag(_ff_multifield_base, z); }\n@@ -172,1 +181,1 @@\n-  u2 name_index() const                      { return _name_index; }\n+  u2 name_index() const                      { assert(!_field_flags.is_multifield(), \"wrong call\"); return _name_index; }\n@@ -186,0 +195,1 @@\n+  u2 secondary_index() const                 { assert(_field_flags.is_multifield(), \"wrong call\"); return _name_index; }\n@@ -191,0 +201,8 @@\n+  bool is_multifield() const {\n+    return _field_flags.is_multifield();\n+  }\n+\n+  bool is_multifield_base() const {\n+    return _field_flags.is_multifield_base();\n+  }\n+\n@@ -205,1 +223,1 @@\n-  inline Symbol* name(ConstantPool* cp) const;\n+  inline Symbol* name(Array<MultiFieldInfo>* multifield_info, ConstantPool* cp) const;\n@@ -211,0 +229,6 @@\n+  Symbol* get_multifield_name(Array<MultiFieldInfo>* multifield_info) const;\n+\n+  inline u2 multifield_base(Array<MultiFieldInfo>* multifield_info) const;\n+\n+  inline jbyte multifield_index(Array<MultiFieldInfo>* multifield_info) const;\n+\n@@ -215,0 +239,16 @@\n+class MultiFieldInfo : public MetaspaceObj {\n+ private:\n+  Symbol* _name;\n+  u2 _base_index;\n+  jbyte _multifield_index;\n+ public:\n+  MultiFieldInfo() : _name(nullptr), _base_index(0), _multifield_index(-1) {}\n+  MultiFieldInfo(Symbol* name, u2 base, jbyte index) : _name(name), _base_index(base), _multifield_index(index) {}\n+  Symbol* name() const { return _name; }\n+  u2 base_index() const { return _base_index; }\n+  jbyte multifield_index() const { return _multifield_index; }\n+  FieldInfo base_field_info(InstanceKlass* ik);\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  MetaspaceObj::Type type() const { return MultiFieldInfoType; }\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -35,1 +35,4 @@\n-inline Symbol* FieldInfo::name(ConstantPool* cp) const {\n+inline Symbol* FieldInfo::name(Array<MultiFieldInfo>* multifield_info, ConstantPool* cp) const {\n+  if (multifield_info && is_multifield()) {\n+    return get_multifield_name(multifield_info);\n+  }\n@@ -69,0 +72,15 @@\n+inline Symbol* FieldInfo::get_multifield_name(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield(), \"Sanity check\");\n+  return multifield_info->at(secondary_index()).name();\n+}\n+\n+inline u2 FieldInfo::multifield_base(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield() || is_multifield_base(), \"Must be\");\n+  return is_multifield() ? multifield_info->at(secondary_index()).base_index() : index();\n+}\n+\n+inline jbyte FieldInfo::multifield_index(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield() || is_multifield_base(), \"Sanity check\");\n+  return is_multifield() ? multifield_info->at(secondary_index()).multifield_index() : (jbyte)-1;\n+}\n+\n@@ -72,1 +90,1 @@\n-  _consumer->accept_uint(fi.name_index());\n+  _consumer->accept_uint(!fi.is_multifield() ? fi.name_index() : fi.secondary_index());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -57,1 +58,1 @@\n-  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants, int start, int limit);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info, int start, int limit);\n@@ -59,1 +60,1 @@\n-  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n+  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info);\n@@ -94,1 +95,5 @@\n-    return field()->name(_constants());\n+    return field()->name(_multifield_info, _constants());\n+  }\n+\n+  int name_index() const {\n+    return field()->name_index();\n@@ -135,0 +140,18 @@\n+  bool is_multifield() const {\n+    return field()->is_multifield();\n+  }\n+\n+  bool is_multifield_base() const {\n+    return field()->is_multifield_base();\n+  }\n+\n+  u2 multifield_base() const {\n+    assert(field()->is_multifield() || field()->is_multifield_base(), \"Must be\");\n+    return field()->is_multifield() ? _multifield_info->at(field()->secondary_index()).base_index() : index();\n+  }\n+\n+  jbyte multifield_index() const {\n+    assert(field()->is_multifield() || field()->is_multifield_base(), \"Must be\");\n+    return field()->is_multifield() ? _multifield_info->at(field()->secondary_index()).multifield_index() : (jbyte)0;\n+  }\n+\n@@ -150,1 +173,1 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), k->multifield_info(), 0, k->java_fields_count()) {}\n@@ -177,1 +200,0 @@\n-\n@@ -181,1 +203,1 @@\n-  InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k->fieldinfo_stream(), k->constants(), k->java_fields_count(), 0) {}\n+  InternalFieldStream(InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), k->multifield_info(), k->java_fields_count(), 0) {}\n@@ -187,2 +209,2 @@\n-  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n-  AllFieldStream(const InstanceKlass* k):      FieldStreamBase(k->fieldinfo_stream(), k->constants()) {}\n+  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info): FieldStreamBase(fieldinfo, constants, multifield_info) {}\n+  AllFieldStream(const InstanceKlass* k):      FieldStreamBase(k->fieldinfo_stream(), k->constants(), k->multifield_info()) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-FieldStreamBase::FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants, int start, int limit) :\n+FieldStreamBase::FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info, int start, int limit) :\n@@ -36,1 +36,3 @@\n-         _constants(constantPoolHandle(Thread::current(), constants)), _index(start) {\n+         _constants(constantPoolHandle(Thread::current(), constants)),\n+         _multifield_info(multifield_info),\n+         _index(start) {\n@@ -46,1 +48,1 @@\n-FieldStreamBase::FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n+FieldStreamBase::FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info) :\n@@ -50,0 +52,1 @@\n+        _multifield_info(multifield_info),\n@@ -59,0 +62,1 @@\n+         _multifield_info(klass->multifield_info()),\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -244,0 +245,1 @@\n+    if (fs.is_multifield()) continue;\n@@ -338,1 +340,2 @@\n-  return InlineTypePassFieldsAsArgs;\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) &&\n+         InlineTypePassFieldsAsArgs;\n@@ -343,1 +346,3 @@\n-  return InlineTypeReturnedAsFields && (init || return_regs() != nullptr);\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) &&\n+         InlineTypeReturnedAsFields &&\n+         (init || return_regs() != nullptr);\n@@ -508,0 +513,1 @@\n+#if INCLUDE_CDS\n@@ -546,0 +552,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,3 @@\n+\/\/ CDS support\n+\n+#if INCLUDE_CDS\n@@ -140,0 +143,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -170,0 +170,8 @@\n+FieldInfo MultiFieldInfo::base_field_info(InstanceKlass* ik) {\n+  return ik->field(_base_index);\n+}\n+\n+void MultiFieldInfo::metaspace_pointers_do(MetaspaceClosure* it) {\n+  it->push(&_name);\n+}\n+\n@@ -548,0 +556,1 @@\n+  _multifield_info(nullptr),\n@@ -757,0 +766,4 @@\n+  if (_multifield_info != NULL && !_multifield_info->is_shared()) {\n+    MetadataFactory::free_array<MultiFieldInfo>(loader_data, _multifield_info);\n+  }\n+\n@@ -2756,0 +2769,3 @@\n+  if(_multifield_info != NULL) {\n+    it->push(&_multifield_info);\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -141,13 +141,12 @@\n-class InlineKlassFixedBlock {\n-  Array<SigEntry>** _extended_sig;\n-  Array<VMRegPair>** _return_regs;\n-  address* _pack_handler;\n-  address* _pack_handler_jobject;\n-  address* _unpack_handler;\n-  int* _default_value_offset;\n-  ArrayKlass** _null_free_inline_array_klasses;\n-  int _alignment;\n-  int _first_field_offset;\n-  int _exact_size_in_bytes;\n-\n-  friend class InlineKlass;\n+class InlineKlassFixedBlock : public MetaspaceObj {\n+   Array<SigEntry>** _extended_sig;\n+   Array<VMRegPair>** _return_regs;\n+   address* _pack_handler;\n+   address* _pack_handler_jobject;\n+   address* _unpack_handler;\n+   int* _default_value_offset;\n+   ArrayKlass** _null_free_inline_array_klasses;\n+   int _alignment;\n+   int _first_field_offset;\n+   int _exact_size_in_bytes;\n+   friend class InlineKlass;\n@@ -231,0 +230,3 @@\n+  \/\/ Array containing meta-data generated for multifields\n+  Array<MultiFieldInfo>* _multifield_info;\n+\n@@ -303,1 +305,1 @@\n-  const InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n+  InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n@@ -440,0 +442,1 @@\n+  friend class MultiFieldInfo;\n@@ -462,0 +465,11 @@\n+  Array<MultiFieldInfo>* multifield_info() const { return _multifield_info; }\n+\n+  MultiFieldInfo multifield_info(int i) const {\n+    guarantee(_multifield_info != NULL, \"Just checking\");\n+    return _multifield_info->at(i);\n+  }\n+  void set_multifield_info(Array<MultiFieldInfo>* array) {\n+    assert(_multifield_info == NULL, \"Must be initialized only once\");\n+    _multifield_info = array;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-inline Symbol* InstanceKlass::field_name(int index) const { return field(index).name(constants()); }\n+inline Symbol* InstanceKlass::field_name(int index) const { return field(index).name(multifield_info(), constants()); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1272,1 +1272,4 @@\n-  if (InlineTypeReturnedAsFields && returns_inline_type(THREAD) && !has_scalarized_return()) {\n+  if (InlineTypeReturnedAsFields &&\n+      returns_inline_type(THREAD) &&\n+      !has_scalarized_return() &&\n+      returns_inline_type(THREAD)->can_be_returned_as_fields()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -797,1 +797,3 @@\n-    if (vt != nullptr) {\n+    \/\/ Upfront buffering for VectorBox may cause problems in sweeping allocation\n+    \/\/ graph pallets if boxes are removed during unbox-box optimization.\n+    if (vt != nullptr && !result->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-            format_helper(regalloc, st, init_node, \":\", -1, nullptr);\n+            format_helper(regalloc, st, init_node, \":\", -2, nullptr);\n@@ -512,0 +512,5 @@\n+\n+          Node* larval_node = mcall->in(first_ind++);\n+          assert(larval_node != NULL && larval_node->is_Con(), \"is_larval node not found\");\n+          st->print(\" [is_larval\");\n+          format_helper(regalloc, st, larval_node, \":\", -1, NULL);\n@@ -513,1 +518,1 @@\n-        Node* fld_node = mcall->in(first_ind);\n+\n@@ -515,13 +520,6 @@\n-        if (iklass != nullptr) {\n-          st->print(\" [\");\n-          cifield = iklass->nonstatic_field_at(0);\n-          cifield->print_name_on(st);\n-          format_helper(regalloc, st, fld_node, \":\", 0, &scobjs);\n-        } else {\n-          format_helper(regalloc, st, fld_node, \"[\", 0, &scobjs);\n-        }\n-        for (uint j = 1; j < nf; j++) {\n-          fld_node = mcall->in(first_ind+j);\n-          if (iklass != nullptr) {\n-            st->print(\", [\");\n-            cifield = iklass->nonstatic_field_at(j);\n+        uint sec_fields_count = 0;\n+        for (uint j = 0; j < nf; j++) {\n+          Node* fld_node = mcall->in(first_ind + j);\n+          if (iklass != NULL) {\n+            st->print(\" [\");\n+            cifield = iklass->nonstatic_field_at(j - sec_fields_count);\n@@ -530,0 +528,15 @@\n+            sec_fields_count = 0;\n+            if (cifield->is_multifield_base() && !fld_node->bottom_type()->isa_vect()) {\n+              sec_fields_count = cifield->secondary_fields_count() - 1;\n+              for (uint f = 0; f < sec_fields_count; f++) {\n+                st->print(\" [\");\n+                fld_node = mcall->in(first_ind + j + f + 1);\n+                ciField* sec_field = static_cast<ciMultiField*>(cifield)->secondary_field_at(f);\n+                sec_field->print_name_on(st);\n+                format_helper(regalloc, st, fld_node, \":\", j + f + 1, &scobjs);\n+                if (f < sec_fields_count - 1) {\n+                  st->print(\",\");\n+                }\n+              }\n+              j += sec_fields_count;\n+            }\n@@ -531,1 +544,5 @@\n-            format_helper(regalloc, st, fld_node, \", [\", j, &scobjs);\n+            format_helper(regalloc, st, fld_node, \" [\", j, &scobjs);\n+          }\n+\n+          if (j < nf - 1) {\n+            st->print(\",\");\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  if (vt != nullptr && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n+  if (vt != nullptr && !vt->is_VectorBox() && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2634,0 +2634,14 @@\n+        \/\/ FIXME: Skipping pushing VectorBox across Phi\n+        \/\/ since they are special type of InlineTypeNode\n+        \/\/ carrying VBA as oop fields.\n+        \/\/ We have a seperate handling for pushing VectorBoxes\n+        \/\/ across PhiNodes in merge_through_phi.\n+        \/\/ In long run we should eliminate VectorBox which is\n+        \/\/ just a light weight wrapper of InlineTypeNode.\n+        \/\/ Only reason to keep VectorBox was to defer buffering\n+        \/\/ to a later stage and associate VBA which carry\n+        \/\/ JVM state to reinitialize GraphKit before buffering.\n+        if (n->is_VectorBox()) {\n+          can_optimize = false;\n+          break;\n+        }\n@@ -2665,1 +2679,1 @@\n-    progress = merge_through_phi(this, phase->is_IterGVN());\n+    progress = merge_through_phi(this, phase);\n@@ -2699,1 +2713,1 @@\n-      } else if (def->Opcode() == Op_VectorBox) { \/\/ leaf\n+      } else if (def->is_InlineType()) { \/\/ leaf\n@@ -2716,1 +2730,2 @@\n-Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {\n+Node* PhiNode::merge_through_phi(Node* root_phi, PhaseGVN *phase) {\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -2762,3 +2777,7 @@\n-  Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);\n-  Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);\n-  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n+  const Type*        ptype = cached_vbox->field_value(0)->bottom_type();\n+\n+  Node* new_payload_phi = clone_through_phi(root_phi, ptype, InlineTypeNode::get_Values_idx(), igvn);\n+  Node* new_vector_phi = clone_through_phi(new_payload_phi, vtype, InlineTypeNode::get_Values_idx(), igvn);\n+  Node* new_vbox_phi = clone_through_phi(root_phi, btype, InlineTypeNode::get_Oop_idx(), igvn);\n+\n+  return VectorBoxNode::make_box_node(*igvn, phase->C, new_vbox_phi, new_vector_phi, btype, vtype);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  static Node* merge_through_phi(Node* root_phi, PhaseIterGVN* igvn);\n+  static Node* merge_through_phi(Node* root_phi, PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2758,10 +2758,0 @@\n-  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n-  if (EnableVectorSupport && has_vbox_nodes()) {\n-    TracePhase tp(\"\", &timers[_t_vector]);\n-    PhaseVector pv(igvn);\n-    pv.optimize_vector_boxes();\n-\n-    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n-  }\n-  assert(!has_vbox_nodes(), \"sanity\");\n-\n@@ -2779,0 +2769,13 @@\n+  \/\/ Process inline type nodes now that all inlining is over\n+  process_inline_types(igvn);\n+\n+  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n+  if (EnableVectorSupport && has_vbox_nodes()) {\n+    TracePhase tp(\"\", &timers[_t_vector]);\n+    PhaseVector pv(igvn);\n+    pv.optimize_vector_boxes();\n+\n+    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n+  }\n+  assert(!has_vbox_nodes(), \"sanity\");\n+\n@@ -2783,3 +2786,0 @@\n-  \/\/ Process inline type nodes now that all inlining is over\n-  process_inline_types(igvn);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-      int      size  = field->type()->size();\n+      int size = InlineTypeNode::stack_size_for_field(field);\n@@ -1135,1 +1135,1 @@\n-    int      size  = field->type()->size();\n+    int size = InlineTypeNode::stack_size_for_field(field);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -930,1 +930,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,26 @@\n+#include \"opto\/vectornode.hpp\"\n+\n+int  InlineTypeNode::stack_size_for_field(ciField* field) {\n+  return field->is_multifield_base()\n+             ? field->type()->elem_word_count()\n+             : field->type()->size();\n+}\n+\n+bool InlineTypeNode::is_multifield_scalarized(BasicType bt, int vec_len) {\n+  if (!is_java_primitive(bt) ||\n+      !Matcher::match_rule_supported_vector(Op_LoadVector, vec_len, bt)  ||\n+      !Matcher::match_rule_supported_vector(Op_StoreVector, vec_len, bt) ||\n+      !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool InlineTypeNode::is_multifield_scalarized(ciField* field) {\n+  if (!field->is_multifield_base()) {\n+    return true;\n+  }\n+  int field_count = field->secondary_fields_count();\n+  BasicType bt = field->type()->basic_type();\n+  return is_multifield_scalarized(bt, field_count);\n+}\n@@ -82,0 +108,4 @@\n+      if (vt->is_multifield_base(i) &&\n+          Matcher::vector_size_supported(type->basic_type(), vt->secondary_fields_count(i))) {\n+        t = TypeVect::make(t, vt->secondary_fields_count(i));\n+      }\n@@ -115,0 +145,1 @@\n+  assert(this->Opcode() == other->Opcode(), \"\");\n@@ -244,0 +275,15 @@\n+int InlineTypeNode::secondary_fields_count(uint index) const {\n+  assert(is_multifield_base(index), \"non-multifield field at index\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->secondary_fields_count();\n+}\n+\n+bool InlineTypeNode::is_multifield(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield();\n+}\n+\n+bool InlineTypeNode::is_multifield_base(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield_base();\n+}\n+\n@@ -258,0 +304,8 @@\n+static bool is_vector_payload(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n+}\n+\n+static bool is_vector_payload_mf(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayloadMF_klass());\n+}\n+\n@@ -261,0 +315,5 @@\n+  if (is_vector_payload_mf(vk)) {\n+     assert(field_count() == nfields, \"\");\n+  } else if (is_vector_payload(vk)) {\n+     assert(field_value(0)->as_InlineType()->field_count() == nfields, \"\");\n+  }\n@@ -276,0 +335,4 @@\n+\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(get_oop());\n+  sfpt->add_req(igvn->intcon(alloc && alloc->_larval ? 1 : 0));\n+\n@@ -425,1 +488,1 @@\n-      if (base->is_Con() && !is_array && !mismatched) {\n+      if (base->is_Con() && !is_array && !mismatched && !is_multifield_base(i)) {\n@@ -442,0 +505,1 @@\n+        BasicType bt = type2field[ft->basic_type()];\n@@ -444,1 +508,0 @@\n-        BasicType bt = type2field[ft->basic_type()];\n@@ -447,1 +510,7 @@\n-        value = kit->access_load_at(base, adr, adr_type, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+        ciField* field = inline_klass()->get_field_by_offset(field_offset(i), false);\n+        bool load_bundle = !InlineTypeNode::is_multifield_scalarized(field);\n+        if (load_bundle) {\n+          value = kit->gvn().transform(LoadVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, ft->bundle_size(), bt));\n+        } else {\n+          value = kit->access_load_at(base, adr, adr_type, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+        }\n@@ -478,0 +547,1 @@\n+  int field_idx = 0;\n@@ -486,1 +556,3 @@\n-      \/\/ Store field value to memory\n+      int vec_len = ft->bundle_size();\n+      BasicType bt = type2field[ft->basic_type()];\n+      const Type* val_type = Type::get_const_type(ft);\n@@ -489,1 +561,0 @@\n-      BasicType bt = type2field[ft->basic_type()];\n@@ -491,3 +562,8 @@\n-      const Type* val_type = Type::get_const_type(ft);\n-      bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n-      kit->access_store_at(base, adr, adr_type, value, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+      if (value->bottom_type()->isa_vect()) {\n+        assert(value->bottom_type()->is_vect()->length() == (uint)vec_len, \"\");\n+        Node* store = kit->gvn().transform(StoreVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, value, vec_len));\n+        kit->set_memory(store, adr_type);\n+      } else {\n+        bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n+        kit->access_store_at(base, adr, adr_type, value, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+      }\n@@ -694,1 +770,1 @@\n-  if (oop->isa_InlineType() && !phase->type(oop)->maybe_null()) {\n+  if (oop->isa_InlineType() && !oop->isa_VectorBox() && !phase->type(oop)->maybe_null()) {\n@@ -755,0 +831,13 @@\n+Node* InlineTypeNode::default_value(PhaseGVN& gvn, ciType* field_type, ciInlineKlass* klass, int index) {\n+  BasicType bt = field_type->basic_type();\n+  int vec_len = field_type->bundle_size();\n+  Node* value = gvn.zerocon(field_type->basic_type());\n+  bool is_multifield_base = klass->declared_nonstatic_field_at(index)->is_multifield_base();\n+  if (is_multifield_base &&\n+      is_java_primitive(bt) &&\n+      Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+      value = gvn.transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field_type), false));\n+  }\n+  return value;\n+}\n+\n@@ -769,1 +858,1 @@\n-    Node* value = gvn.zerocon(ft->basic_type());\n+    Node* value = default_value(gvn, ft, vk, i);\n@@ -806,1 +895,2 @@\n-    if (!gvn->type(value)->is_zero_type()) {\n+    if (!gvn->type(value)->is_zero_type() &&\n+        !VectorNode::is_all_zeros_vector(value)) {\n@@ -1120,1 +1210,20 @@\n-      if (multi->is_Start()) {\n+      ciInlineKlass* ik = inline_klass();\n+      ciField* field = ik->declared_nonstatic_field_at(i);\n+      if (!InlineTypeNode::is_multifield_scalarized(field)) {\n+        Node* not_null_oop =  NULL;\n+        if (multi->is_Call()) {\n+          if (in) {\n+            not_null_oop = multi->as_Call()->in(base_input);\n+          } else {\n+            not_null_oop =  multi->as_Call()->proj_out(TypeFunc::Parms);\n+          }\n+          assert(not_null_oop->bottom_type()->isa_instptr(), \"\");\n+          load(kit, not_null_oop, not_null_oop, ik, visited, \/* holder_offset *\/ 0);\n+          parm = field_value(i);\n+        } else if (multi->is_Start()) {\n+          assert(in, \"return from start?\");\n+          parm = default_value(gvn, type, ik, i);\n+        } else {\n+          assert(false, \"unhandled case\");\n+        }\n+      } else if (multi->is_Start()) {\n@@ -1148,1 +1257,1 @@\n-      base_input += type->size();\n+      base_input += (type->size() \/ type->bundle_size());\n@@ -1216,1 +1325,1 @@\n-    Node* value = gvn.zerocon(ft->basic_type());\n+    Node* value = default_value(gvn, ft, vk, i);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":123,"deletions":14,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/matcher.hpp\"\n@@ -53,3 +54,0 @@\n-  \/\/ Get the klass defining the field layout of the inline type\n-  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n-\n@@ -72,0 +70,3 @@\n+public:\n+  \/\/ Get the klass defining the field layout of the inline type\n+  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n@@ -93,0 +94,5 @@\n+  static bool is_multifield_scalarized(ciField* field);\n+  static bool is_multifield_scalarized(BasicType bt, int vec_len);\n+\n+  static int stack_size_for_field(ciField* field);\n+\n@@ -96,0 +102,2 @@\n+  static Node* default_value(PhaseGVN& gvn, ciType* field_type, ciInlineKlass* klass, int index);\n+\n@@ -110,0 +118,4 @@\n+  \/\/ Get indices for inputs.\n+  static int   get_Oop_idx()    { return InlineTypeNode::Oop; }\n+  static int   get_Values_idx() { return InlineTypeNode::Values; }\n+\n@@ -111,2 +123,4 @@\n-  uint          field_count() const { return req() - Values; }\n-  Node*         field_value(uint index) const;\n+  virtual uint  field_count() const { return req() - Values; }\n+  virtual Node* field_value(uint index) const;\n+  uint          field_index(int offset) const;\n+\n@@ -114,2 +128,3 @@\n-  void      set_field_value(uint index, Node* value);\n-  void      set_field_value_by_offset(int offset, Node* value);\n+  void          set_field_value(uint index, Node* value);\n+\n+  void          set_field_value_by_offset(int offset, Node* value);\n@@ -117,1 +132,3 @@\n-  uint          field_index(int offset) const;\n+  bool          is_multifield(uint index) const;\n+  bool          is_multifield_base(uint index) const;\n+  int           secondary_fields_count(uint index) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2312,1 +2312,1 @@\n- }\n+  }\n@@ -2352,0 +2352,8 @@\n+      \/\/ FIXME: Larval bit check is needed to preserve the semantics of value\n+      \/\/ objects which can be mutated only if its _larval bit is set. Since\n+      \/\/ the oop is not always an AllocateNode, we have to find an utility way\n+      \/\/ to check the larval state for all kind of oops.\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n+      if (alloc != nullptr) {\n+        assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+      }\n@@ -2360,0 +2368,5 @@\n+        \/\/ Skip over direct field access for VectorPayloadMF* class instances since\n+        \/\/ multifield is loaded into vector, alternatively we can create a lane\n+        \/\/ extraction logic. Given that unsafe put operations over vector payloads are part\n+        \/\/ of fallback implementation, for the time being suboptimality should not be major\n+        \/\/ concern.\n@@ -2361,1 +2374,1 @@\n-        if (field != nullptr) {\n+        if (field != nullptr && !VectorSupport::is_vector_payload_mf(vk->get_InlineKlass())) {\n@@ -2649,1 +2662,1 @@\n-  if (!vt->is_allocated(&_gvn)) {\n+  if (!vt->is_allocated(&_gvn) || VectorSupport::is_vector_payload_mf(vt->inline_klass()->get_InlineKlass())) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -112,1 +112,3 @@\n-      if (C->inlining_incrementally() && res->is_InlineType()) {\n+      \/\/ VectorBoxes should be treated as special InlineTypeNodes, we will defer its buffering\n+      \/\/ to a later stage to give opportunity for consumption by subsequent expanders.\n+      if (C->inlining_incrementally() && res->is_InlineType() && !res->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1246,1 +1246,6 @@\n-  if (base != nullptr && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n+  if (base != nullptr && base->is_InlineType() &&\n+      \/\/ Multifields are loaded into vectors and lane level loads needs\n+      \/\/ an explicit extraction operation.\n+      (bottom_type()->isa_vect() ||\n+       !VectorSupport::is_vector_payload_mf(base->as_InlineType()->inline_klass()->get_InlineKlass())) &&\n+      offset > oopDesc::klass_offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+class VectorBoxNode;\n@@ -733,2 +734,1 @@\n-      DEFINE_CLASS_ID(InlineType, Type, 8)\n-        DEFINE_CLASS_ID(Reduction, Vector, 9)\n+        DEFINE_CLASS_ID(Reduction, Vector, 7)\n@@ -736,1 +736,3 @@\n-      DEFINE_CLASS_ID(Con, Type, 10)\n+      DEFINE_CLASS_ID(InlineType, Type, 8)\n+        DEFINE_CLASS_ID(VectorBox, InlineType, 0)\n+      DEFINE_CLASS_ID(Con, Type, 9)\n@@ -738,1 +740,1 @@\n-      DEFINE_CLASS_ID(SafePointScalarMerge, Type, 9)\n+      DEFINE_CLASS_ID(SafePointScalarMerge, Type, 10)\n@@ -978,0 +980,1 @@\n+  DEFINE_CLASS_QUERY(VectorBox)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -807,0 +807,1 @@\n+      ScopeValue* is_larval = nullptr;\n@@ -819,0 +820,6 @@\n+\n+        Node* larval_node = sfpt->in(first_ind++);\n+        assert(larval_node != nullptr && larval_node->is_Con(), \"is_larval node not found\");\n+\n+        const TypeInt* larval_type = larval_node->bottom_type()->is_int();\n+        is_larval = new ConstantIntValue(larval_type->get_con());\n@@ -821,1 +828,1 @@\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init);\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init, is_larval);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -927,1 +927,8 @@\n-    if (tf()->returns_inline_type_as_fields()) {\n+    if (res->isa_InlineType() && VectorSupport::skip_value_scalarization(res->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+      InlineTypeNode* vt = res->as_InlineType();\n+      \/\/ Prevent returning uninitialized VBA, this will make associated box useless and\n+      \/\/ will be swept by dead code eliminator. Once VBA is expanded and initialized during\n+      \/\/ PhaseVector box users will be tied to newly allocated and initialized objects.\n+      assert(vt->get_is_buffered(), \"\");\n+      ret->add_req(vt->get_is_buffered()->get_int() ? vt->get_oop() : res);\n+    } else if (tf()->returns_inline_type_as_fields()) {\n@@ -1150,1 +1157,1 @@\n-  \/\/ record exit from a method if compiled while Dtrace is turned on.\n+  \/\/ record exit from a method if compiled while Dtrace is returned on.\n@@ -2370,2 +2377,9 @@\n-    if ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n-        return_type->is_inlinetypeptr()) {\n+    \/\/ Buffer vector return values, for regular inline object caller\n+    \/\/ expects scalarized fields to be passed back.\n+    bool is_vector_value = value->is_InlineType() &&\n+                           VectorSupport::skip_value_scalarization(value->as_InlineType()->inline_klass()->get_InlineKlass());\n+    \/\/ Defer returning VectorBoxAllocation node, they will be expanded and initialized\n+    \/\/ during box expansion and will replace all uses of box.\n+    bool skip_scalarization = is_vector_value && Compile::current()->inlining_incrementally();\n+    if (!is_vector_value && ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n+        return_type->is_inlinetypeptr())) {\n@@ -2385,1 +2399,2 @@\n-    } else if (value->is_InlineType()) {\n+    } else if (skip_scalarization ||\n+               (value->Opcode() != Op_VectorBox && value->is_InlineType())) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -342,1 +343,1 @@\n-  int holder_depth = field->type()->size();\n+  int holder_depth = field->type()->size() \/ field->type()->bundle_size();\n@@ -359,1 +360,1 @@\n-    int nargs = 1 + field->type()->size();\n+    int nargs = 1 + field->type()->size() \/ field->type()->bundle_size();\n@@ -368,1 +369,14 @@\n-  new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n+\n+  BasicType bt = field->type()->basic_type();\n+  int vec_len = field->secondary_fields_count();\n+  bool scalarize_fields = !field->is_multifield_base() || !is_java_primitive(bt) ||\n+                          !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n+  if (scalarize_fields) {\n+    for(int i = 0; i < vec_len; i++) {\n+      new_vt->set_field_value_by_offset(field->offset_in_bytes() + i * type2aelembytes(bt), val);\n+    }\n+  } else {\n+    val = _gvn.transform(VectorNode::scalar2vector(val, field->secondary_fields_count(), Type::get_const_type(field->type()), false));\n+    new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n+  }\n+\n@@ -372,1 +386,1 @@\n-    int nargs = 1 + field->type()->size();\n+    int nargs = 1 + InlineTypeNode::stack_size_for_field(field);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,9 +35,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n-\n@@ -181,1 +172,1 @@\n-  Node* vec_value = vec_box->in(VectorBoxNode::Value);\n+  Node* vec_value = vec_box->get_vec();\n@@ -192,1 +183,1 @@\n-        if (call->has_non_debug_use(vec_box) && vec_box->in(VectorBoxNode::Box)->is_Phi()) {\n+        if (call->has_non_debug_use(vec_box) && vec_box->get_oop()->is_Phi()) {\n@@ -216,1 +207,1 @@\n-        Node* vect = vec_box->in(VectorBoxNode::Value);\n+        Node* vect = vec_box->get_vec();\n@@ -239,59 +230,0 @@\n-\n-  \/\/ Process debug uses at safepoints\n-  Unique_Node_List safepoints(C->comp_arena());\n-\n-  Unique_Node_List worklist(C->comp_arena());\n-  worklist.push(vec_box);\n-  while (worklist.size() > 0) {\n-    Node* n = worklist.pop();\n-    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-      Node* use = n->fast_out(i);\n-      if (use->is_SafePoint()) {\n-        SafePointNode* sfpt = use->as_SafePoint();\n-        if (!sfpt->is_Call() || !sfpt->as_Call()->has_non_debug_use(n)) {\n-          safepoints.push(sfpt);\n-        }\n-      } else if (use->is_ConstraintCast()) {\n-        worklist.push(use); \/\/ reversed version of Node::uncast()\n-      }\n-    }\n-  }\n-\n-  ciInstanceKlass* iklass = vec_box->box_type()->instance_klass();\n-  int n_fields = iklass->nof_nonstatic_fields();\n-  assert(n_fields == 1, \"sanity\");\n-\n-  \/\/ If a mask is feeding into safepoint[s], then its value should be\n-  \/\/ packed into a boolean\/byte vector first, this will simplify the\n-  \/\/ re-materialization logic for both predicated and non-predicated\n-  \/\/ targets.\n-  bool is_mask = is_vector_mask(iklass);\n-  if (is_mask && vec_value->Opcode() != Op_VectorStoreMask) {\n-    const TypeVect* vt = vec_value->bottom_type()->is_vect();\n-    BasicType bt = vt->element_basic_type();\n-    vec_value = gvn.transform(VectorStoreMaskNode::make(gvn, vec_value, bt, vt->length()));\n-  }\n-\n-  while (safepoints.size() > 0) {\n-    SafePointNode* sfpt = safepoints.pop()->as_SafePoint();\n-\n-    uint first_ind = (sfpt->req() - sfpt->jvms()->scloff());\n-    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(), vec_box, first_ind, n_fields);\n-    sobj->init_req(0, C->root());\n-    sfpt->add_req(vec_value);\n-\n-    sobj = gvn.transform(sobj);\n-\n-    JVMState *jvms = sfpt->jvms();\n-\n-    jvms->set_endoff(sfpt->req());\n-    \/\/ Now make a pass over the debug information replacing any references\n-    \/\/ to the allocated object with vector value.\n-    for (uint i = jvms->debug_start(); i < jvms->debug_end(); i++) {\n-      Node* debug = sfpt->in(i);\n-      if (debug != nullptr && debug->uncast(\/*keep_deps*\/false) == vec_box) {\n-        sfpt->set_req(i, sobj);\n-      }\n-    }\n-    C->record_for_igvn(sfpt);\n-  }\n@@ -303,2 +235,3 @@\n-    Node* vbox = vec_box->in(VectorBoxNode::Box);\n-    Node* vect = vec_box->in(VectorBoxNode::Value);\n+    Node* vbox = vec_box->get_oop();\n+    Node* vect = vec_box->get_vec();\n+\n@@ -307,0 +240,1 @@\n+\n@@ -377,1 +311,1 @@\n-                                          Node* value,\n+                                          Node* vect,\n@@ -384,15 +318,9 @@\n-  ciInstanceKlass* box_klass = box_type->instance_klass();\n-  BasicType bt = vect_type->element_basic_type();\n-  int num_elem = vect_type->length();\n-\n-  bool is_mask = is_vector_mask(box_klass);\n-  \/\/ If boxed mask value is present in a predicate register, it must be\n-  \/\/ spilled to a vector though a VectorStoreMaskOperation before actual StoreVector\n-  \/\/ operation to vector payload field.\n-  if (is_mask && (value->bottom_type()->isa_vectmask() || bt != T_BOOLEAN)) {\n-    value = gvn.transform(VectorStoreMaskNode::make(gvn, value, bt, num_elem));\n-    \/\/ Although type of mask depends on its definition, in terms of storage everything is stored in boolean array.\n-    bt = T_BOOLEAN;\n-    assert(value->bottom_type()->is_vect()->element_basic_type() == bt,\n-           \"must be consistent with mask representation\");\n-  }\n+  ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());\n+\n+  \/\/ Re-generate an InlineTypeNode to represent the payload field. This is necessary\n+  \/\/ in case the input \"vect\" is not the original vector value when creating the\n+  \/\/ VectorBox (e.g. original vector value is a PhiNode).\n+  ciInlineKlass* payload = vk->declared_nonstatic_field_at(0)->type()->as_inline_klass();\n+  Node* payload_value = InlineTypeNode::make_uninitialized(gvn, payload, true);\n+  payload_value->as_InlineType()->set_field_value(0, vect);\n+  payload_value = gvn.transform(payload_value);\n@@ -400,17 +328,9 @@\n-  \/\/ Generate array allocation for the field which holds the values.\n-  const TypeKlassPtr* array_klass = TypeKlassPtr::make(ciTypeArrayKlass::make(bt));\n-  Node* arr = kit.new_array(kit.makecon(array_klass), kit.intcon(num_elem), 1);\n-\n-  \/\/ Store the vector value into the array.\n-  \/\/ (The store should be captured by InitializeNode and turned into initialized store later.)\n-  Node* arr_adr = kit.array_element_address(arr, kit.intcon(0), bt);\n-  const TypePtr* arr_adr_type = arr_adr->bottom_type()->is_ptr();\n-  Node* arr_mem = kit.memory(arr_adr);\n-  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n-                                                     kit.control(),\n-                                                     arr_mem,\n-                                                     arr_adr,\n-                                                     arr_adr_type,\n-                                                     value,\n-                                                     num_elem));\n-  kit.set_memory(vstore, arr_adr_type);\n+  \/\/ Re-generate an InlineTypeNode to represent the vector object. New a buffer\n+  \/\/ and save its field value to the buffer.\n+  InlineTypeNode* vector = InlineTypeNode::make_uninitialized(gvn, vk, false);\n+  vector->set_field_value(0, payload_value);\n+  vector = gvn.transform(vector)->as_InlineType();\n+\n+  Node* klass_node = kit.makecon(TypeKlassPtr::make(vk));\n+  Node* alloc_oop  = kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true);\n+  vector->store(&kit, alloc_oop, alloc_oop, vk);\n@@ -420,24 +340,1 @@\n-  \/\/ Generate the allocate for the Vector object.\n-  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n-  Node* klass_node = kit.makecon(klass_type);\n-  Node* vec_obj = kit.new_instance(klass_node);\n-\n-  \/\/ Store the allocated array into object.\n-  ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n-                                                                                     ciSymbols::object_signature(),\n-                                                                                     false);\n-  assert(field != nullptr, \"\");\n-  Node* vec_field = kit.basic_plus_adr(vec_obj, field->offset_in_bytes());\n-  const TypePtr* vec_adr_type = vec_field->bottom_type()->is_ptr();\n-\n-  \/\/ The store should be captured by InitializeNode and turned into initialized store later.\n-  Node* field_store = gvn.transform(kit.access_store_at(vec_obj,\n-                                                        vec_field,\n-                                                        vec_adr_type,\n-                                                        arr,\n-                                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                                        T_OBJECT,\n-                                                        IN_HEAP));\n-  kit.set_memory(field_store, vec_adr_type);\n-\n-  kit.replace_call(vbox_alloc, vec_obj, true);\n+  kit.replace_call(vbox_alloc, alloc_oop, true);\n@@ -445,2 +342,1 @@\n-\n-  return vec_obj;\n+  return alloc_oop;\n@@ -454,11 +350,3 @@\n-    Node* obj = vec_unbox->obj();\n-    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n-    ciInstanceKlass* from_kls = tinst->instance_klass();\n-    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n-    BasicType bt = vt->element_basic_type();\n-    BasicType masktype = bt;\n-\n-    if (is_vector_mask(from_kls)) {\n-      bt = T_BOOLEAN;\n-    } else if (is_vector_shuffle(from_kls)) {\n-      bt = T_BYTE;\n+    Node* node = vec_unbox->obj();\n+    while(node->is_InlineType()) {\n+      node = node->as_InlineType()->field_value(0);\n@@ -467,46 +355,2 @@\n-    ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n-                                                                                       ciSymbols::object_signature(),\n-                                                                                       false);\n-    assert(field != nullptr, \"\");\n-    int offset = field->offset_in_bytes();\n-    Node* vec_adr = kit.basic_plus_adr(obj, offset);\n-\n-    Node* mem = vec_unbox->mem();\n-    Node* ctrl = vec_unbox->in(0);\n-    Node* vec_field_ld;\n-    {\n-      DecoratorSet decorators = MO_UNORDERED | IN_HEAP;\n-      C2AccessValuePtr addr(vec_adr, vec_adr->bottom_type()->is_ptr());\n-      MergeMemNode* local_mem = MergeMemNode::make(mem);\n-      gvn.record_for_igvn(local_mem);\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      C2OptAccess access(gvn, ctrl, local_mem, decorators, T_OBJECT, obj, addr);\n-      const Type* type = TypeOopPtr::make_from_klass(field->type()->as_klass());\n-      vec_field_ld = bs->load_at(access, type);\n-    }\n-\n-    \/\/ For proper aliasing, attach concrete payload type.\n-    ciKlass* payload_klass = ciTypeArrayKlass::make(bt);\n-    const Type* payload_type = TypeAryPtr::make_from_klass(payload_klass)->cast_to_ptr_type(TypePtr::NotNull);\n-    vec_field_ld = gvn.transform(new CastPPNode(vec_field_ld, payload_type));\n-\n-    Node* adr = kit.array_element_address(vec_field_ld, gvn.intcon(0), bt);\n-    const TypePtr* adr_type = adr->bottom_type()->is_ptr();\n-    int num_elem = vt->length();\n-    Node* vec_val_load = LoadVectorNode::make(0,\n-                                              ctrl,\n-                                              mem,\n-                                              adr,\n-                                              adr_type,\n-                                              num_elem,\n-                                              bt);\n-    vec_val_load = gvn.transform(vec_val_load);\n-\n-    C->set_max_vector_size(MAX2(C->max_vector_size(), vt->length_in_bytes()));\n-\n-    if (is_vector_mask(from_kls)) {\n-      vec_val_load = gvn.transform(new VectorLoadMaskNode(vec_val_load, TypeVect::makemask(masktype, num_elem)));\n-    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n-    }\n+    assert(node->bottom_type()->isa_vect() != NULL, \"not a vector\");\n+    assert(Type::cmp(vec_unbox->bottom_type(), node->bottom_type()) == 0, \"type is not matched\");\n@@ -514,0 +358,1 @@\n+    C->set_max_vector_size(MAX2(C->max_vector_size(), vec_unbox->bottom_type()->is_vect()->length_in_bytes()));\n@@ -516,1 +361,1 @@\n-    C->gvn_replace_by(vec_unbox, vec_val_load);\n+    C->gvn_replace_by(vec_unbox, node);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":35,"deletions":190,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciKlass.hpp\"\n@@ -39,1 +40,1 @@\n-  Node* expand_vbox_node_helper(Node* vbox,\n+  Node* expand_vbox_node_helper(Node* vbox_alloc,\n@@ -44,0 +45,1 @@\n+\n@@ -45,1 +47,1 @@\n-                               Node* value,\n+                               Node* vect,\n@@ -48,0 +50,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,8 @@\n+static bool is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+}\n+\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n@@ -62,8 +70,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -158,2 +158,15 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));\n-  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vt);\n+\n+  if (is_vector_shuffle(vbox_type->instance_klass())) {\n+    assert(elem_bt == T_BYTE, \"must be consistent with shuffle representation\");\n+  }\n+\n+  \/\/ VectorMask format conversion\n+  if (is_vector_mask(vbox_type->instance_klass()) &&\n+      (vector->bottom_type()->isa_vectmask() || elem_bt != T_BOOLEAN)) {\n+    vector = gvn().transform(VectorStoreMaskNode::make(gvn(), vector, elem_bt, num_elem));\n+    elem_bt = T_BOOLEAN;\n+    assert(vector->bottom_type()->is_vect()->element_basic_type() == elem_bt,\n+           \"must be consistent with mask representation\");\n+  }\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  Node* vbox = VectorBoxNode::make_box_node(gvn(), C, ret, vector, vbox_type, vt);\n@@ -163,1 +176,1 @@\n-Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem) {\n@@ -172,0 +185,1 @@\n+\n@@ -173,2 +187,9 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n+  BasicType unbox_bt = elem_bt;\n+  if (is_vector_mask(vbox_type->instance_klass())) {\n+    unbox_bt = T_BOOLEAN;\n+  }\n+  const TypeVect* vt = TypeVect::make(unbox_bt, num_elem);\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory()));\n+  if (is_vector_mask(vbox_type->instance_klass())) {\n+    unbox = gvn().transform(new VectorLoadMaskNode(unbox, TypeVect::makemask(elem_bt, num_elem)));\n+  }\n@@ -733,1 +754,1 @@\n-  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem, true);\n+  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);\n@@ -806,1 +827,4 @@\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n+  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem);\n+  if (shuffle_vec == nullptr) {\n+    return false;\n+  }\n@@ -2076,1 +2100,0 @@\n-  BasicType shuffle_bt = elem_bt;\n@@ -2118,1 +2141,1 @@\n-  Node* shuffle = unbox_vector(argument(6), shbox_type, shuffle_bt, num_elem);\n+  Node* shuffle = unbox_vector(argument(6), shbox_type, T_BYTE, num_elem);\n@@ -2138,0 +2161,1 @@\n+  shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, TypeVect::make(elem_bt, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -989,0 +990,4 @@\n+  case Op_ReplicateF:\n+    return n->in(1)->bottom_type() == TypeF::ZERO;\n+  case Op_ReplicateD:\n+    return n->in(1)->bottom_type() == TypeD::ZERO;\n@@ -1413,0 +1418,17 @@\n+Node* VectorLoadMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1)->Opcode() == Op_VectorStoreMask) {\n+    if (Type::cmp(bottom_type(), in(1)->in(1)->bottom_type()) == 0) {\n+      \/\/ \/\/ Handled by VectorLoadMaskNode::Identity()\n+    } else {\n+      const TypeVect* out_vt = vect_type();\n+      const TypeVect* in_vt = in(1)->in(1)->bottom_type()->is_vect();\n+      if (out_vt->length() == in_vt->length() &&\n+          out_vt->length_in_bytes() == in_vt->length_in_bytes()) {\n+        const TypeVect* vmask_type = TypeVect::makemask(out_vt->element_basic_type(), out_vt->length());\n+        return new VectorMaskCastNode(in(1)->in(1), vmask_type);\n+      }\n+    }\n+  }\n+  return VectorNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1414,1 +1436,1 @@\n-  BasicType out_bt = type()->is_vect()->element_basic_type();\n+  BasicType out_bt = vect_type()->element_basic_type();\n@@ -1419,0 +1441,5 @@\n+  \/\/ VectorLoadMask (VectorStoreMask mask) ==> mask\n+  if (in(1)->Opcode() == Op_VectorStoreMask &&\n+      Type::cmp(bottom_type(), in(1)->in(1)->bottom_type()) == 0) {\n+    return in(1)->in(1);\n+  }\n@@ -1743,37 +1770,0 @@\n-Node* VectorUnboxNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  Node* n = obj()->uncast();\n-  if (EnableVectorReboxing && n->Opcode() == Op_VectorBox) {\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n-      \/\/ Handled by VectorUnboxNode::Identity()\n-    } else {\n-      VectorBoxNode* vbox = static_cast<VectorBoxNode*>(n);\n-      ciKlass* vbox_klass = vbox->box_type()->instance_klass();\n-      const TypeVect* in_vt = vbox->vec_type();\n-      const TypeVect* out_vt = type()->is_vect();\n-\n-      if (in_vt->length() == out_vt->length()) {\n-        Node* value = vbox->in(VectorBoxNode::Value);\n-\n-        bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-        bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-        if (is_vector_mask) {\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n-          const TypeVect* vmask_type = TypeVect::makemask(out_vt->element_basic_type(), out_vt->length());\n-          return new VectorMaskCastNode(value, vmask_type);\n-        } else if (is_vector_shuffle) {\n-          if (!is_shuffle_to_vector()) {\n-            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n-            return new VectorLoadShuffleNode(value, out_vt);\n-          }\n-        } else {\n-          \/\/ Vector type mismatch is only supported for masks and shuffles, but sometimes it happens in pathological cases.\n-        }\n-      } else {\n-        \/\/ Vector length mismatch.\n-        \/\/ Sometimes happen in pathological cases (e.g., when unboxing happens in effectively dead code).\n-      }\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -1781,1 +1771,18 @@\n-  Node* n = obj()->uncast();\n+  Node* n = obj();\n+  assert(n->is_InlineType(), \"\");\n+  if (!n->is_VectorBox()) {\n+    \/\/ FIXME: Directly return Vector loaded from multi-field for concrete\n+    \/\/ vector InlineType nodes. This can save deferring unbox expansion.\n+    \/\/ For masks\/shuffle emit additional pruning IR to match the vector size.\n+  }\n+  \/\/ Vector APIs are lazily intrinsified, during parsing compiler emits a\n+  \/\/ call to intrinsic function, since most of the APIs return an abstract vector\n+  \/\/ hence a subsequent checkcast results into a graph shape comprising of CheckPP\n+  \/\/ and CheckCastPP chain. During lazy inline expansion, call gets replaced by\n+  \/\/ a VectorBox but we still need to traverse back through chain of cast nodes\n+  \/\/ to get to the VectorBox.\n+  if (!n->is_VectorBox() &&\n+      VectorSupport::is_vector(n->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+    n = n->as_InlineType()->get_oop();\n+  }\n+  n = n->uncast();\n@@ -1783,4 +1790,2 @@\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n-      return n->in(VectorBoxNode::Value); \/\/ VectorUnbox (VectorBox v) ==> v\n-    } else {\n-      \/\/ Handled by VectorUnboxNode::Ideal().\n+    if (Type::cmp(bottom_type(), n->as_VectorBox()->get_vec()->bottom_type()) == 0) {\n+      return n->as_VectorBox()->get_vec(); \/\/ VectorUnbox (VectorBox v) ==> v\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":48,"deletions":43,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1497,0 +1498,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1674,1 +1676,1 @@\n-class VectorBoxNode : public Node {\n+class VectorBoxNode : public InlineTypeNode {\n@@ -1676,12 +1678,31 @@\n-  const TypeInstPtr* const _box_type;\n-  const TypeVect*    const _vec_type;\n- public:\n-  enum {\n-     Box   = 1,\n-     Value = 2\n-  };\n-  VectorBoxNode(Compile* C, Node* box, Node* val,\n-                const TypeInstPtr* box_type, const TypeVect* vt)\n-    : Node(nullptr, box, val), _box_type(box_type), _vec_type(vt) {\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n+  const TypeInstPtr* _box_type;\n+  const TypeVect*    _vec_type;\n+\n+ public:\n+  void set_box_type(const TypeInstPtr* box_type) { _box_type = box_type; }\n+  void set_vec_type(const TypeVect* vec_type) { _vec_type = vec_type; }\n+\n+  VectorBoxNode(Compile* C, ciInlineKlass* vk, Node* oop, const TypeInstPtr* box_type, const TypeVect* vt, bool null_free) :\n+    InlineTypeNode(vk, oop, null_free) {\n+      init_flags(Flag_is_macro);\n+      init_class_id(Class_VectorBox);\n+      set_vec_type(vt);\n+      set_box_type(box_type);\n+      C->add_macro_node(this);\n+  }\n+\n+  static VectorBoxNode* make_box_node(PhaseGVN& gvn, Compile* C, Node* box, Node* val,\n+                                      const TypeInstPtr* box_type, const TypeVect* vt) {\n+    ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());\n+    VectorBoxNode* box_node = new VectorBoxNode(C, vk, box, box_type, vt, false);\n+\n+    ciInlineKlass* payload = vk->declared_nonstatic_field_at(0)->type()->as_inline_klass();\n+    Node* payload_value = InlineTypeNode::make_uninitialized(gvn, payload, true);\n+    payload_value->as_InlineType()->set_field_value(0, val);\n+    payload_value = gvn.transform(payload_value);\n+\n+    box_node->set_field_value(0, payload_value);\n+    box_node->set_is_buffered(gvn, false);\n+    box_node->set_is_init(gvn);\n+\n+    return box_node;\n@@ -1693,0 +1714,5 @@\n+  Node*  get_vec() {\n+    assert(field_value(0)->is_InlineType(), \"\");\n+    return field_value(0)->as_InlineType()->field_value(0);\n+  }\n+\n@@ -1716,2 +1742,0 @@\n- private:\n-  bool _shuffle_to_vector;\n@@ -1721,1 +1745,1 @@\n-  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem, bool shuffle_to_vector)\n+  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem)\n@@ -1723,1 +1747,0 @@\n-    _shuffle_to_vector = shuffle_to_vector;\n@@ -1733,2 +1756,0 @@\n-  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  bool is_shuffle_to_vector() { return _shuffle_to_vector; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":40,"deletions":19,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmClassMacros.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -41,0 +43,2 @@\n+#include \"runtime\/deoptimization.hpp\"\n+#include \"utilities\/debug.hpp\"\n@@ -72,2 +76,2 @@\n-bool VectorSupport::is_vector_mask(Klass* klass) {\n-  return klass->is_subclass_of(vmClasses::vector_VectorMask_klass());\n+bool VectorSupport::is_vector_payload_mf(Klass* klass) {\n+  return klass->is_subclass_of(vmClasses::vector_VectorPayloadMF_klass());\n@@ -76,123 +80,3 @@\n-bool VectorSupport::is_vector_shuffle(Klass* klass) {\n-  return klass->is_subclass_of(vmClasses::vector_VectorShuffle_klass());\n-}\n-\n-BasicType VectorSupport::klass2bt(InstanceKlass* ik) {\n-  assert(ik->is_subclass_of(vmClasses::vector_VectorPayload_klass()), \"%s not a VectorPayload\", ik->name()->as_C_string());\n-  fieldDescriptor fd; \/\/ find_field initializes fd if found\n-  \/\/ static final Class<?> ETYPE;\n-  Klass* holder = ik->find_field(vmSymbols::ETYPE_name(), vmSymbols::class_signature(), &fd);\n-\n-  assert(holder != nullptr, \"sanity\");\n-  assert(fd.is_static(), \"\");\n-  assert(fd.offset() > 0, \"\");\n-\n-  if (is_vector_shuffle(ik)) {\n-    return T_BYTE;\n-  } else if (is_vector_mask(ik)) {\n-    return T_BOOLEAN;\n-  } else { \/\/ vector and mask\n-    oop value = ik->java_mirror()->obj_field(fd.offset());\n-    BasicType elem_bt = java_lang_Class::as_BasicType(value);\n-    return elem_bt;\n-  }\n-}\n-\n-jint VectorSupport::klass2length(InstanceKlass* ik) {\n-  fieldDescriptor fd; \/\/ find_field initializes fd if found\n-  \/\/ static final int VLENGTH;\n-  Klass* holder = ik->find_field(vmSymbols::VLENGTH_name(), vmSymbols::int_signature(), &fd);\n-\n-  assert(holder != nullptr, \"sanity\");\n-  assert(fd.is_static(), \"\");\n-  assert(fd.offset() > 0, \"\");\n-\n-  jint vlen = ik->java_mirror()->int_field(fd.offset());\n-  assert(vlen > 0, \"\");\n-  return vlen;\n-}\n-\n-\/\/ Masks require special handling: when boxed they are packed and stored in boolean\n-\/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n-\/\/ For example, Int512Mask is represented in memory as boolean[16], but\n-\/\/ occupies the whole 512-bit vector register when scalarized.\n-\/\/ During scalarization inserting a VectorStoreMask node between mask\n-\/\/ and safepoint node always ensures the existence of masks in a boolean array.\n-\n-void VectorSupport::init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr) {\n-  switch (elem_bt) {\n-    case T_BOOLEAN: arr->bool_at_put(index, *(jboolean*)addr); break;\n-    case T_BYTE:    arr->byte_at_put(index, *(jbyte*)addr); break;\n-    case T_SHORT:   arr->short_at_put(index, *(jshort*)addr); break;\n-    case T_INT:     arr->int_at_put(index, *(jint*)addr); break;\n-    case T_FLOAT:   arr->float_at_put(index, *(jfloat*)addr); break;\n-    case T_LONG:    arr->long_at_put(index, *(jlong*)addr); break;\n-    case T_DOUBLE:  arr->double_at_put(index, *(jdouble*)addr); break;\n-    default: fatal(\"unsupported: %s\", type2name(elem_bt));\n-  }\n-}\n-\n-Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS) {\n-  int num_elem = klass2length(ik);\n-  BasicType elem_bt = klass2bt(ik);\n-  int elem_size = type2aelembytes(elem_bt);\n-\n-  \/\/ On-heap vector values are represented as primitive arrays.\n-  TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n-\n-  typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n-\n-  if (location.is_register()) {\n-    \/\/ Value was in a callee-saved register.\n-    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n-\n-    for (int i = 0; i < num_elem; i++) {\n-      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n-      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n-\n-      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-      init_payload_element(arr, elem_bt, i, elem_addr);\n-    }\n-  } else {\n-    \/\/ Value was directly saved on the stack.\n-    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n-    for (int i = 0; i < num_elem; i++) {\n-      init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n-    }\n-  }\n-  return Handle(THREAD, arr);\n-}\n-\n-Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS) {\n-  if (payload->is_location()) {\n-    Location location = payload->as_LocationValue()->location();\n-    if (location.type() == Location::vector) {\n-      \/\/ Vector value in an aligned adjacent tuple (1, 2, 4, 8, or 16 slots).\n-      return allocate_vector_payload_helper(ik, fr, reg_map, location, THREAD); \/\/ safepoint\n-    }\n-#ifdef ASSERT\n-    \/\/ Other payload values are: 'oop' type location and scalar-replaced boxed vector representation.\n-    \/\/ They will be processed in Deoptimization::reassign_fields() after all objects are reallocated.\n-    else {\n-      Location::Type loc_type = location.type();\n-      assert(loc_type == Location::oop || loc_type == Location::narrowoop,\n-             \"expected 'oop'(%d) or 'narrowoop'(%d) types location but got: %d\", Location::oop, Location::narrowoop, loc_type);\n-    }\n-  } else if (!payload->is_object() && !payload->is_constant_oop()) {\n-    stringStream ss;\n-    payload->print_on(&ss);\n-    assert(false, \"expected 'object' value for scalar-replaced boxed vector but got: %s\", ss.freeze());\n-#endif\n-  }\n-  return Handle(THREAD, nullptr);\n-}\n-\n-instanceOop VectorSupport::allocate_vector(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n-  assert(is_vector(ik), \"%s not a vector\", ik->name()->as_C_string());\n-  assert(ov->field_size() == 1, \"%s not a vector\", ik->name()->as_C_string());\n-\n-  ScopeValue* payload_value = ov->field_at(0);\n-  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, fr, reg_map, payload_value, CHECK_NULL);\n-  instanceOop vbox = ik->allocate_instance(CHECK_NULL);\n-  vector_VectorPayload::set_payload(vbox, payload_instance());\n-  return vbox;\n+bool VectorSupport::skip_value_scalarization(Klass* klass) {\n+  return VectorSupport::is_vector(klass) ||\n+         VectorSupport::is_vector_payload_mf(klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":9,"deletions":125,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -40,8 +40,0 @@\n- private:\n-  static Handle allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS);\n-  static Handle allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS);\n-\n-  static void init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr);\n-\n-  static BasicType klass2bt(InstanceKlass* ik);\n-  static jint klass2length(InstanceKlass* ik);\n@@ -146,2 +138,0 @@\n-  static instanceOop allocate_vector(InstanceKlass* holder, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n-\n@@ -149,2 +139,2 @@\n-  static bool is_vector_mask(Klass* klass);\n-  static bool is_vector_shuffle(Klass* klass);\n+  static bool is_vector_payload_mf(Klass* klass);\n+  static bool skip_value_scalarization(Klass* klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2301,0 +2301,4 @@\n+bool Arguments::enable_valhalla(const char* prop_value) {\n+  return strstr(prop_value, \"jdk.incubator.vector\");\n+}\n+\n@@ -2410,0 +2414,3 @@\n+      if (enable_valhalla(tail)) {\n+        EnablePrimitiveClasses = true;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -323,0 +323,2 @@\n+  static bool enable_valhalla(const char* prop_value);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1279,7 +1279,0 @@\n-#ifdef COMPILER2\n-        if (EnableVectorSupport && VectorSupport::is_vector(ik)) {\n-          obj = VectorSupport::allocate_vector(ik, fr, reg_map, sv, THREAD);\n-        } else {\n-          obj = ik->allocate_instance(THREAD);\n-        }\n-#else\n@@ -1287,1 +1280,0 @@\n-#endif \/\/ COMPILER2\n@@ -1307,0 +1299,8 @@\n+    if (k->is_inline_klass()) {\n+      intptr_t is_larval = StackValue::create_stack_value(fr, reg_map, sv->is_larval())->get_int();\n+      jint larval = (jint)*((jint*)&is_larval);\n+      if (larval == 1) {\n+        obj->set_mark(obj->mark().enter_larval_state());\n+      }\n+    }\n+\n@@ -1511,0 +1511,1 @@\n+  int _secondary_fields_count;\n@@ -1512,1 +1513,1 @@\n-  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false) { }\n+  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false), _secondary_fields_count(0) { }\n@@ -1519,0 +1520,36 @@\n+static void init_multi_field(oop obj, int offset, BasicType elem_bt, address addr) {\n+  switch (elem_bt) {\n+    case T_BOOLEAN: obj->bool_field_put(offset, *(jboolean*)addr); break;\n+    case T_BYTE:    obj->byte_field_put(offset, *(jbyte*)addr); break;\n+    case T_SHORT:   obj->short_field_put(offset, *(jshort*)addr); break;\n+    case T_INT:     obj->int_field_put(offset, *(jint*)addr); break;\n+    case T_FLOAT:   obj->float_field_put(offset, *(jfloat*)addr); break;\n+    case T_LONG:    obj->long_field_put(offset, *(jlong*)addr); break;\n+    case T_DOUBLE:  obj->double_field_put(offset, *(jdouble*)addr); break;\n+    default: fatal(\"unsupported: %s\", type2name(elem_bt));\n+  }\n+}\n+\n+static void reassign_vectorized_multi_fields(frame* fr, RegisterMap* reg_map, Location location, oop obj, int offset, BasicType elem_bt, int fields_count) {\n+  int elem_size = type2aelembytes(elem_bt);\n+  if (location.is_register()) {\n+    \/\/ Value was in a callee-saved register.\n+    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+\n+    for (int i = 0; i < fields_count; i++) {\n+      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+      int second_offset = offset + i * elem_size;\n+      init_multi_field(obj, second_offset, elem_bt, elem_addr);\n+    }\n+  } else {\n+    \/\/ Value was directly saved on the stack.\n+    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+    for (int i = 0; i < fields_count; i++) {\n+      int second_offset = offset + i * elem_size;\n+      init_multi_field(obj, second_offset, elem_bt, base_addr + i * elem_size);\n+    }\n+  }\n+}\n+\n@@ -1526,1 +1563,1 @@\n-      if (!fs.access_flags().is_static() && (!skip_internal || !fs.field_flags().is_injected())) {\n+      if (!fs.access_flags().is_static() && !fs.is_multifield() && (!skip_internal || !fs.field_flags().is_injected())) {\n@@ -1530,0 +1567,1 @@\n+        field._secondary_fields_count = fs.is_multifield_base() ? fs.field_descriptor().secondary_fields_count(fs.index()) : 1;\n@@ -1557,19 +1595,35 @@\n-    intptr_t val;\n-    ScopeValue* scope_field = sv->field_at(svIndex);\n-    StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n-    switch (type) {\n-      case T_OBJECT:\n-      case T_ARRAY:\n-        assert(value->type() == T_OBJECT, \"Agreement.\");\n-        obj->obj_field_put(offset, value->get_obj()());\n-        break;\n-\n-      \/\/ Have to cast to INT (32 bits) pointer to avoid little\/big-endian problem.\n-      case T_INT: case T_FLOAT: { \/\/ 4 bytes.\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        bool big_value = false;\n-        if (i+1 < fields->length() && fields->at(i+1)._type == T_INT) {\n-          if (scope_field->is_location()) {\n-            Location::Type type = ((LocationValue*) scope_field)->location().type();\n-            if (type == Location::dbl || type == Location::lng) {\n-              big_value = true;\n+\n+    int secondary_fields_count = fields->at(i)._secondary_fields_count;\n+    if (sv->field_at(svIndex)->is_location()) {\n+      Location location = sv->field_at(svIndex)->as_LocationValue()->location();\n+      if (location.type() == Location::vector) {\n+        \/\/ Re-assign vectorized multi-fields\n+        reassign_vectorized_multi_fields(fr, reg_map, location, obj, offset, type, secondary_fields_count);\n+        svIndex++;\n+        continue;\n+      }\n+    }\n+\n+    assert(secondary_fields_count <= sv->field_size(), \"\");\n+    for (int j = 0; j < secondary_fields_count; j++) {\n+      intptr_t val;\n+      ScopeValue* scope_field = sv->field_at(svIndex);\n+      StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n+      int sec_offset = offset + j * type2aelembytes(type);\n+      switch (type) {\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          assert(value->type() == T_OBJECT, \"Agreement.\");\n+          obj->obj_field_put(sec_offset, value->get_obj()());\n+          break;\n+\n+        \/\/ Have to cast to INT (32 bits) pointer to avoid little\/big-endian problem.\n+        case T_INT: case T_FLOAT: { \/\/ 4 bytes.\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          bool big_value = false;\n+          if (i+1 < fields->length() && fields->at(i+1)._type == T_INT) {\n+            if (scope_field->is_location()) {\n+              Location::Type type = ((LocationValue*) scope_field)->location().type();\n+              if (type == Location::dbl || type == Location::lng) {\n+                big_value = true;\n+              }\n@@ -1577,5 +1631,5 @@\n-          }\n-          if (scope_field->is_constant_int()) {\n-            ScopeValue* next_scope_field = sv->field_at(svIndex + 1);\n-            if (next_scope_field->is_constant_long() || next_scope_field->is_constant_double()) {\n-              big_value = true;\n+            if (scope_field->is_constant_int()) {\n+              ScopeValue* next_scope_field = sv->field_at(svIndex + 1);\n+              if (next_scope_field->is_constant_long() || next_scope_field->is_constant_double()) {\n+                big_value = true;\n+              }\n@@ -1584,0 +1638,10 @@\n+\n+          if (big_value) {\n+            i++;\n+            assert(i < fields->length(), \"second T_INT field needed\");\n+            assert(fields->at(i)._type == T_INT, \"T_INT field needed\");\n+          } else {\n+            val = value->get_int();\n+            obj->int_field_put(sec_offset, (jint)*((jint*)&val));\n+            break;\n+          }\n@@ -1585,0 +1649,1 @@\n+          \/* no break *\/\n@@ -1586,7 +1651,9 @@\n-        if (big_value) {\n-          i++;\n-          assert(i < fields->length(), \"second T_INT field needed\");\n-          assert(fields->at(i)._type == T_INT, \"T_INT field needed\");\n-        } else {\n-          val = value->get_int();\n-          obj->int_field_put(offset, (jint)*((jint*)&val));\n+        case T_LONG: case T_DOUBLE: {\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          StackValue* low = StackValue::create_stack_value(fr, reg_map, sv->field_at(++svIndex));\n+  #ifdef _LP64\n+          jlong res = (jlong)low->get_int();\n+  #else\n+          jlong res = jlong_from((jint)value->get_int(), (jint)low->get_int());\n+  #endif\n+          obj->long_field_put(sec_offset, res);\n@@ -1595,14 +1662,0 @@\n-      }\n-        \/* no break *\/\n-\n-      case T_LONG: case T_DOUBLE: {\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        StackValue* low = StackValue::create_stack_value(fr, reg_map, sv->field_at(++svIndex));\n-#ifdef _LP64\n-        jlong res = (jlong)low->get_int();\n-#else\n-        jlong res = jlong_from((jint)value->get_int(), (jint)low->get_int());\n-#endif\n-        obj->long_field_put(offset, res);\n-        break;\n-      }\n@@ -1610,5 +1663,5 @@\n-      case T_SHORT:\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        val = value->get_int();\n-        obj->short_field_put(offset, (jshort)*((jint*)&val));\n-        break;\n+        case T_SHORT:\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          val = value->get_int();\n+          obj->short_field_put(sec_offset, (jshort)*((jint*)&val));\n+          break;\n@@ -1616,5 +1669,5 @@\n-      case T_CHAR:\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        val = value->get_int();\n-        obj->char_field_put(offset, (jchar)*((jint*)&val));\n-        break;\n+        case T_CHAR:\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          val = value->get_int();\n+          obj->char_field_put(sec_offset, (jchar)*((jint*)&val));\n+          break;\n@@ -1622,5 +1675,5 @@\n-      case T_BYTE:\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        val = value->get_int();\n-        obj->byte_field_put(offset, (jbyte)*((jint*)&val));\n-        break;\n+        case T_BYTE:\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          val = value->get_int();\n+          obj->byte_field_put(sec_offset, (jbyte)*((jint*)&val));\n+          break;\n@@ -1628,5 +1681,5 @@\n-      case T_BOOLEAN:\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        val = value->get_int();\n-        obj->bool_field_put(offset, (jboolean)*((jint*)&val));\n-        break;\n+        case T_BOOLEAN:\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          val = value->get_int();\n+          obj->bool_field_put(sec_offset, (jboolean)*((jint*)&val));\n+          break;\n@@ -1634,2 +1687,4 @@\n-      default:\n-        ShouldNotReachHere();\n+        default:\n+          ShouldNotReachHere();\n+      }\n+      svIndex++;\n@@ -1637,1 +1692,0 @@\n-    svIndex++;\n@@ -1680,21 +1734,1 @@\n-#ifdef COMPILER2\n-    if (EnableVectorSupport && VectorSupport::is_vector(k)) {\n-      assert(sv->field_size() == 1, \"%s not a vector\", k->name()->as_C_string());\n-      ScopeValue* payload = sv->field_at(0);\n-      if (payload->is_location() &&\n-          payload->as_LocationValue()->location().type() == Location::vector) {\n-#ifndef PRODUCT\n-        if (PrintDeoptimizationDetails) {\n-          tty->print_cr(\"skip field reassignment for this vector - it should be assigned already\");\n-          if (Verbose) {\n-            Handle obj = sv->value();\n-            k->oop_print_on(obj(), tty);\n-          }\n-        }\n-#endif \/\/ !PRODUCT\n-        continue; \/\/ Such vector's value was already restored in VectorSupport::allocate_vector().\n-      }\n-      \/\/ Else fall-through to do assignment for scalar-replaced boxed vector representation\n-      \/\/ which could be restored after vector object allocation.\n-    }\n-#endif \/* !COMPILER2 *\/\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":133,"deletions":99,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,1 +101,2 @@\n-  guarantee(_fieldinfo.name_index() != 0 && _fieldinfo.signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n+  \/\/ assert to be extended to allow multifield names\n+  guarantee(\/*_fieldinfo.name_index() != 0 &&*\/ _fieldinfo.signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,5 @@\n+  inline bool is_multifield()            const;\n+  inline bool is_multifield_base()       const;\n+  inline u2   multifield_base()          const;\n+  inline jbyte multifield_index()        const;\n+  inline int secondary_fields_count(int base_idx) const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  return field().name(_cp());\n+  return field().name(field_holder()->multifield_info(),  _cp());\n@@ -72,0 +72,23 @@\n+inline bool fieldDescriptor::is_multifield() const { return field().is_multifield(); }\n+inline bool fieldDescriptor::is_multifield_base() const { return field().is_multifield_base(); }\n+inline u2   fieldDescriptor::multifield_base() const {\n+  return is_multifield() ? field_holder()->multifield_info(field().secondary_index()).base_index() : index();\n+}\n+inline jbyte fieldDescriptor::multifield_index() const {\n+ return  is_multifield() ? field_holder()->multifield_info(field().secondary_index()).multifield_index() : (jbyte)0;\n+}\n+\n+inline int fieldDescriptor::secondary_fields_count(int base_idx) const {\n+  Array<MultiFieldInfo>* multifield_info = field_holder()->multifield_info();\n+  if (!is_multifield_base() || nullptr == multifield_info) {\n+    return 1;\n+  }\n+  int sec_fields_count = 1;\n+  for (int i = 0; i < multifield_info->length(); i++) {\n+    if (field_holder()->multifield_info(i).base_index() == base_idx) {\n+      sec_fields_count++;\n+    }\n+  }\n+  return  sec_fields_count;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -556,0 +557,3 @@\n+JRT_LEAF(int, SharedRuntime::skip_value_scalarization(InlineKlass* klass))\n+  return (int) VectorSupport::skip_value_scalarization(klass);\n+JRT_END\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+  static int skip_value_scalarization(InlineKlass* klass);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+* Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.  Oracle designates this\n+* particular file as subject to the \"Classpath\" exception as provided\n+* by Oracle in the LICENSE file that accompanied this code.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+* <p>An annotation expressing that the field has to be\n+* replicated several times and all replication must be\n+* layed out contiguously in memory. The annotation is\n+* ignored if the type of the field is not one of the\n+* eight Java basic primitive types: boolean, byte, short,\n+* char, int, long, float, double.\n+*\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.FIELD})\n+public @interface MultiField {\n+\n+   \/**\n+    * The total number of fields (initial plus replicated).\n+    * This tag is only meaningful for field level annotations.\n+    *\n+    * @return total number of fields to layout.\n+    *\/\n+   byte value() default 0;\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/MultiField.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Objects;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -29,0 +31,1 @@\n+import jdk.internal.vm.annotation.MultiField;\n@@ -32,0 +35,1 @@\n+import java.lang.reflect.*;\n@@ -151,1 +155,1 @@\n-    public static class VectorSpecies<E> {}\n+    public static class VectorSpecies<E> { }\n@@ -153,5 +157,1 @@\n-    \/**\n-     * @hidden\n-     *\/\n-    public static class VectorPayload {\n-        private final Object payload; \/\/ array of primitives\n+    public abstract static class VectorPayload { }\n@@ -159,2 +159,76 @@\n-        public VectorPayload(Object payload) {\n-            this.payload = payload;\n+    public static abstract class Vector<E> extends VectorPayload { }\n+\n+    public static abstract class VectorMask<E> extends VectorPayload { }\n+\n+    public static abstract class VectorShuffle<E> extends VectorPayload { }\n+\n+    public abstract static class VectorPayloadMF {\n+        public abstract long multiFieldOffset();\n+\n+        @ForceInline\n+        public static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n+            if (elemType == boolean.class) {\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF8Z();\n+                    case  2: return new VectorPayloadMF16Z();\n+                    case  4: return new VectorPayloadMF32Z();\n+                    case  8: return new VectorPayloadMF64Z();\n+                    case 16: return new VectorPayloadMF128Z();\n+                    case 32: return new VectorPayloadMF256Z();\n+                    case 64: return new VectorPayloadMF512Z();\n+                    default: assert false : \"Unhandled vector mask size\";\n+                }\n+            } else if (elemType == byte.class) {\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF8B();\n+                    case  2: return new VectorPayloadMF16B();\n+                    case  4: return new VectorPayloadMF32B();\n+                    case  8: return new VectorPayloadMF64B();\n+                    case 16: return new VectorPayloadMF128B();\n+                    case 32: return new VectorPayloadMF256B();\n+                    case 64: return new VectorPayloadMF512B();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == short.class) {\n+                switch(length) {\n+                    case  4: return new VectorPayloadMF64S();\n+                    case  8: return new VectorPayloadMF128S();\n+                    case 16: return new VectorPayloadMF256S();\n+                    case 32: return new VectorPayloadMF512S();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == int.class) {\n+                switch(length) {\n+                    case  2: return new VectorPayloadMF64I();\n+                    case  4: return new VectorPayloadMF128I();\n+                    case  8: return new VectorPayloadMF256I();\n+                    case 16: return new VectorPayloadMF512I();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == long.class) {\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF64L();\n+                    case  2: return new VectorPayloadMF128L();\n+                    case  4: return new VectorPayloadMF256L();\n+                    case  8: return new VectorPayloadMF512L();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else if (elemType == float.class) {\n+                switch(length) {\n+                    case  2: return new VectorPayloadMF64F();\n+                    case  4: return new VectorPayloadMF128F();\n+                    case  8: return new VectorPayloadMF256F();\n+                    case 16: return new VectorPayloadMF512F();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            } else {\n+                assert elemType == double.class;\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF64D();\n+                    case  2: return new VectorPayloadMF128D();\n+                    case  4: return new VectorPayloadMF256D();\n+                    case  8: return new VectorPayloadMF512D();\n+                    default: assert false : \"Unhandled vector size\";\n+                }\n+            }\n+            return null;\n@@ -163,2 +237,10 @@\n-        protected final Object getPayload() {\n-            return VectorSupport.maybeRebox(this).payload;\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceB(int length, byte [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(byte.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putByte(obj, start_offset + i * Byte.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n@@ -166,1 +248,0 @@\n-    }\n@@ -168,6 +249,10 @@\n-    \/**\n-     * @hidden\n-     *\/\n-    public static class Vector<E> extends VectorPayload {\n-        public Vector(Object payload) {\n-            super(payload);\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceS(int length, short [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(short.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putShort(obj, start_offset + i * Short.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n@@ -175,1 +260,0 @@\n-    }\n@@ -177,6 +261,10 @@\n-    \/**\n-     * @hidden\n-     *\/\n-    public static class VectorShuffle<E> extends VectorPayload {\n-        public VectorShuffle(Object payload) {\n-            super(payload);\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceI(int length, int [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(int.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putInt(obj, start_offset + i * Integer.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n@@ -184,7 +272,60 @@\n-    }\n-    \/**\n-     * @hidden\n-     *\/\n-    public static class VectorMask<E> extends VectorPayload {\n-        public VectorMask(Object payload) {\n-            super(payload);\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceL(int length, long [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(long.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putLong(obj, start_offset + i * Long.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceF(int length, float [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(float.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putFloat(obj, start_offset + i * Float.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        @ForceInline\n+        public static VectorPayloadMF createVectPayloadInstanceD(int length, double [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(double.class, length);\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            long start_offset = obj.multiFieldOffset();\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putDouble(obj, start_offset + i * Double.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public int length() {\n+            try {\n+                var field = this.getClass().getDeclaredField(\"mfield\");\n+                var msanno = field.getAnnotationsByType(MultiField.class);\n+\n+                Objects.nonNull(msanno);\n+\n+                assert msanno.length == 1;\n+                return msanno[0].value();\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1;\n+        }\n+\n+        public static long multiFieldOffset(Class<? extends VectorPayloadMF> cls) {\n+            try {\n+                var field = cls.getDeclaredField(\"mfield\");\n+                return Unsafe.getUnsafe().objectFieldOffset(field);\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1L;\n@@ -194,0 +335,306 @@\n+    public primitive static class VectorPayloadMF8Z extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF16Z extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF32Z extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64Z extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128Z extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256Z extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512Z extends VectorPayloadMF {\n+        @MultiField(value = 64)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF8B extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF16B extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF32B extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64B extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128B extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256B extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512B extends VectorPayloadMF {\n+        @MultiField(value = 64)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64S extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128S extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256S extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512S extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        short mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512S.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64I extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128I extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256I extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512I extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        int mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512I.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64L extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128L extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256L extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512L extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        long mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512L.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64F extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128F extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256F extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512F extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        float mfield = 0.0f;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512F.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64D extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128D extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256D extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512D extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        double mfield = 0.0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512D.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":478,"deletions":31,"binary":false,"changes":509,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n@@ -38,3 +40,0 @@\n-    AbstractMask(boolean[] bits) {\n-        super(bits);\n-    }\n@@ -43,1 +42,24 @@\n-    abstract boolean[] getBits();\n+    abstract VectorPayloadMF getBits();\n+\n+    static VectorPayloadMF prepare(VectorPayloadMF payload, int offset, int length) {\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(payload, mOffset + i + offset);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, b);\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return res;\n+    }\n+\n+    static VectorPayloadMF prepare(boolean val, int length) {\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, val);\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return res;\n+    }\n@@ -51,1 +73,13 @@\n-    abstract AbstractMask<E> uOp(MUnOp f);\n+    AbstractMask<E> uOpMF(MUnOp f) {\n+        int length = vspecies().laneCount();\n+        VectorPayloadMF bits = getBits();\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, f.apply(i, b));\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return vspecies().maskFactory(res);\n+    }\n@@ -59,1 +93,25 @@\n-    abstract AbstractMask<E> bOp(VectorMask<E> o, MBinOp f);\n+    AbstractMask<E> bOpMF(AbstractMask<E> m, MBinOp f) {\n+        int length = vspecies().laneCount();\n+        VectorPayloadMF bits = getBits();\n+        VectorPayloadMF mbits = m.getBits();\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+            boolean mb = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, f.apply(i, b, mb));\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return vspecies().maskFactory(res);\n+    }\n+\n+    \/\/ Store operator\n+\n+    void stOpMF(boolean[] arr, int idx) {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < vspecies().laneCount(); i++) {\n+            arr[idx++] = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+        }\n+    }\n@@ -70,0 +128,14 @@\n+    @Override\n+    @ForceInline\n+    public <F> VectorMask<F> cast(VectorSpecies<F> dsp) {\n+        AbstractSpecies<F> species = (AbstractSpecies<F>) dsp;\n+        if (length() != species.laneCount())\n+            throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), vspecies().elementType(), vspecies().laneCount,\n+                species.maskType(), species.elementType(), vspecies().laneCount,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.getBits()).check(s));\n+    }\n+\n@@ -79,2 +151,1 @@\n-            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));\n-\n+            (c, idx, s) -> s.stOpMF(c, (int) idx));\n@@ -85,1 +156,3 @@\n-        return getBits().clone();\n+        boolean[] arr = new boolean[length()];\n+        intoArray(arr, 0);\n+        return arr;\n@@ -140,1 +213,7 @@\n-    static boolean anyTrueHelper(boolean[] bits) {\n+    boolean laneIsSetHelper(int idx) {\n+        VectorPayloadMF bits = getBits();\n+        return Unsafe.getUnsafe().getBoolean(bits, bits.multiFieldOffset() + idx);\n+    }\n+\n+    \/*package-private*\/\n+    boolean anyTrueHelper() {\n@@ -142,2 +221,4 @@\n-        for (boolean i : bits) {\n-            if (i) return true;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return true;\n@@ -149,1 +230,1 @@\n-    static boolean allTrueHelper(boolean[] bits) {\n+    boolean allTrueHelper() {\n@@ -151,2 +232,4 @@\n-        for (boolean i : bits) {\n-            if (!i) return false;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (!Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return false;\n@@ -158,1 +241,1 @@\n-    static int trueCountHelper(boolean[] bits) {\n+    int trueCountHelper() {\n@@ -160,2 +243,4 @@\n-        for (boolean i : bits) {\n-            if (i) c++;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) c++;\n@@ -167,3 +252,5 @@\n-    static int firstTrueHelper(boolean[] bits) {\n-        for (int i = 0; i < bits.length; i++) {\n-            if (bits[i])  return i;\n+    int firstTrueHelper() {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return i;\n@@ -171,1 +258,1 @@\n-        return bits.length;\n+        return length();\n@@ -175,3 +262,5 @@\n-    static int lastTrueHelper(boolean[] bits) {\n-        for (int i = bits.length-1; i >= 0; i--) {\n-            if (bits[i])  return i;\n+    int lastTrueHelper() {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = length() - 1; i >= 0; i--) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return i;\n@@ -183,1 +272,1 @@\n-    static long toLongHelper(boolean[] bits) {\n+    long toLongHelper() {\n@@ -186,2 +275,4 @@\n-        for (int i = 0; i < bits.length; i++) {\n-            res = bits[i] ? res | set : res;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            res = Unsafe.getUnsafe().getBoolean(bits, mOffset + i) ? res | set : res;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":119,"deletions":28,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -30,0 +31,2 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n@@ -36,17 +39,2 @@\n-    AbstractShuffle(int length, byte[] reorder) {\n-        super(reorder);\n-        assert(length == reorder.length);\n-        assert(indexesInRange(reorder));\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder) {\n-        this(length, reorder, 0);\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder, int offset) {\n-        super(prepare(length, reorder, offset));\n-    }\n-\n-    AbstractShuffle(int length, IntUnaryOperator f) {\n-        super(prepare(length, f));\n-    }\n+    \/*package-private*\/\n+    abstract VectorPayloadMF indices();\n@@ -54,2 +42,4 @@\n-    private static byte[] prepare(int length, int[] reorder, int offset) {\n-        byte[] a = new byte[length];\n+    static VectorPayloadMF prepare(int length, int[] indices, int offset) {\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long mf_offset = payload.multiFieldOffset();\n@@ -57,1 +47,1 @@\n-            int si = reorder[offset + i];\n+            int si = indices[offset + i];\n@@ -59,1 +49,1 @@\n-            a[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(payload, mf_offset + i * Byte.BYTES, (byte) si);\n@@ -61,1 +51,2 @@\n-        return a;\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return payload;\n@@ -64,3 +55,5 @@\n-    private static byte[] prepare(int length, IntUnaryOperator f) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < a.length; i++) {\n+    static VectorPayloadMF prepare(int length, IntUnaryOperator f) {\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long offset = payload.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n@@ -69,1 +62,1 @@\n-            a[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n@@ -71,5 +64,2 @@\n-        return a;\n-    }\n-\n-    byte[] reorder() {\n-        return (byte[])getPayload();\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return payload;\n@@ -90,2 +80,3 @@\n-        byte[] reorder = reorder();\n-        int vlen = reorder.length;\n+        VectorPayloadMF indices = indices();\n+        int vlen = indices.length();\n+        long mf_offset = indices.multiFieldOffset();\n@@ -93,1 +84,1 @@\n-            int sourceIndex = reorder[i];\n+            int sourceIndex = Unsafe.getUnsafe().getByte(indices, mf_offset + i * Byte.BYTES);\n@@ -102,2 +93,2 @@\n-        byte[] reorder = reorder();\n-        int[] a = new int[reorder.length];\n+        VectorPayloadMF indices = indices();\n+        int[] a = new int[indices.length()];\n@@ -129,2 +120,3 @@\n-            byte[] reorder = reorder();\n-            throw checkIndexFailed(reorder[vecmask.firstTrue()], length());\n+            VectorPayloadMF indices = indices();\n+            long offset = indices.multiFieldOffset();\n+            throw checkIndexFailed(Unsafe.getUnsafe().getByte(indices, offset + vecmask.firstTrue() * Byte.BYTES), length());\n@@ -141,2 +133,2 @@\n-            byte[] reorder = reorder();\n-            return wrapAndRebuild(reorder);\n+            VectorPayloadMF indices = indices();\n+            return wrapAndRebuild(indices);\n@@ -148,3 +140,5 @@\n-    public final VectorShuffle<E> wrapAndRebuild(byte[] oldReorder) {\n-        int length = oldReorder.length;\n-        byte[] reorder = new byte[length];\n+    public final VectorShuffle<E> wrapAndRebuild(VectorPayloadMF oldIndices) {\n+        int length = oldIndices.length();\n+        VectorPayloadMF indices = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        long offset = oldIndices.multiFieldOffset();\n+        indices = Unsafe.getUnsafe().makePrivateBuffer(indices);\n@@ -152,1 +146,1 @@\n-            int si = oldReorder[i];\n+            int si = Unsafe.getUnsafe().getByte(oldIndices, offset + i * Byte.BYTES);\n@@ -161,1 +155,1 @@\n-            reorder[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(indices, offset + i * Byte.BYTES, (byte) si);\n@@ -163,1 +157,2 @@\n-        return vspecies().dummyVector().shuffleFromBytes(reorder);\n+        indices = Unsafe.getUnsafe().finishPrivateBuffer(indices);\n+        return vspecies().dummyVectorMF().shuffleFromBytes(indices);\n@@ -224,3 +219,5 @@\n-    static boolean indexesInRange(byte[] reorder) {\n-        int length = reorder.length;\n-        for (byte si : reorder) {\n+    static boolean indexesInRange(VectorPayloadMF indices) {\n+        int length = indices.length();\n+        long offset = indices.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            byte si = Unsafe.getUnsafe().getByte(indices, offset + i * Byte.BYTES);\n@@ -232,1 +229,1 @@\n-                                  java.util.Arrays.toString(reorder));\n+                            indices.toString());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":48,"deletions":51,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.vector.VectorSupport;\n@@ -36,1 +38,3 @@\n-abstract class AbstractSpecies<E> extends jdk.internal.vm.vector.VectorSupport.VectorSpecies<E>\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>\n@@ -112,1 +116,1 @@\n-    AbstractVector<E> dummyVector;\n+    AbstractVector<E> dummyVectorMF;\n@@ -306,1 +310,1 @@\n-    AbstractVector<E> dummyVector() {\n+    AbstractVector<E> dummyVectorMF() {\n@@ -308,1 +312,1 @@\n-        AbstractVector<E> dummy = dummyVector;\n+        AbstractVector<E> dummy = dummyVectorMF;\n@@ -311,5 +315,49 @@\n-        return makeDummyVector();\n-    }\n-    private AbstractVector<E> makeDummyVector() {\n-        Object za = Array.newInstance(elementType(), laneCount);\n-        return dummyVector = vectorFactory.apply(za);\n+        return makeDummyVectorMF();\n+    }\n+\n+    @ForceInline\n+    VectorSupport.VectorPayloadMF createVectorMF(Object initarr) {\n+        VectorSupport.VectorPayloadMF za = null;\n+        switch (laneType.switchKey) {\n+        case LaneType.SK_FLOAT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(laneCount, (float[])initarr);\n+            break;\n+        case LaneType.SK_DOUBLE:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(laneCount, (double[])initarr);\n+            break;\n+        case LaneType.SK_BYTE:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(laneCount, (byte[])initarr);\n+            break;\n+        case LaneType.SK_SHORT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(laneCount, (short[])initarr);\n+            break;\n+        case LaneType.SK_INT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(laneCount, (int[])initarr);\n+            break;\n+        case LaneType.SK_LONG:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(laneCount, (long[])initarr);\n+            break;\n+        default:\n+            assert false : \"Unsupported elemType in createVectorMF\";\n+            break;\n+        }\n+        return za;\n+    }\n+\n+    @ForceInline\n+    private AbstractVector<E> makeDummyVectorMF() {\n+        Object za = null;\n+        switch (laneType.switchKey) {\n+        case LaneType.SK_FLOAT:\n+        case LaneType.SK_DOUBLE:\n+        case LaneType.SK_BYTE:\n+        case LaneType.SK_SHORT:\n+        case LaneType.SK_INT:\n+        case LaneType.SK_LONG:\n+            za = VectorPayloadMF.newInstanceFactory(elementType(), laneCount);\n+            break;\n+        default:\n+            assert false : \"Unsupported elemType in makeDummyVectorMF\";\n+            break;\n+        }\n+        return dummyVectorMF = vectorFactory.apply(za);\n@@ -327,2 +375,2 @@\n-    AbstractMask<E> maskFactory(boolean[] bits) {\n-        return dummyVector().maskFromArray(bits);\n+    AbstractMask<E> maskFactory(VectorPayloadMF payload) {\n+        return dummyVectorMF().maskFromPayload(payload);\n@@ -335,1 +383,1 @@\n-        return dummyVector().shuffleFromArray(sourceIndexes, offset);\n+        return dummyVectorMF().shuffleFromArray(sourceIndexes, offset);\n@@ -342,1 +390,1 @@\n-        return dummyVector().shuffleFromArray(sourceIndexes, 0);\n+        return dummyVectorMF().shuffleFromArray(sourceIndexes, 0);\n@@ -349,1 +397,1 @@\n-        return dummyVector().shuffleFromOp(fn);\n+        return dummyVectorMF().shuffleFromOp(fn);\n@@ -358,1 +406,1 @@\n-            return dummyVector().iotaShuffle();\n+            return dummyVectorMF().iotaShuffle();\n@@ -360,1 +408,1 @@\n-            return dummyVector().iotaShuffle(start, step, wrap);\n+            return dummyVectorMF().iotaShuffle(start, step, wrap);\n@@ -366,1 +414,1 @@\n-        return dummyVector()\n+        return dummyVectorMF()\n@@ -455,1 +503,1 @@\n-    abstract AbstractVector<E> rvOp(RVOp f);\n+    abstract AbstractVector<E> rvOpMF(RVOp f);\n@@ -463,3 +511,5 @@\n-        boolean[] res = new boolean[laneCount];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i);\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(boolean.class, laneCount);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long mOffset = payload.multiFieldOffset();\n+        for (int i = 0; i < laneCount; i++) {\n+            Unsafe.getUnsafe().putBoolean(payload, mOffset + i, f.apply(i));\n@@ -467,1 +517,2 @@\n-        return dummyVector().maskFromArray(res);\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return maskFactory(payload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":74,"deletions":23,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n@@ -36,1 +37,1 @@\n-@SuppressWarnings(\"cast\")\n+@SuppressWarnings({\"cast\", \"missing-explicit-ctor\"})\n@@ -71,5 +72,0 @@\n-    \/*package-private*\/\n-    AbstractVector(Object bits) {\n-        super(bits);\n-    }\n-\n@@ -78,0 +74,3 @@\n+    \/*package-private*\/\n+    abstract VectorPayloadMF vec();\n+\n@@ -81,0 +80,3 @@\n+    \/*package-private*\/\n+    abstract long multiFieldOffset();\n+\n@@ -149,1 +151,1 @@\n-        AbstractVector<?> other = ((AbstractSpecies<?>)species).dummyVector();\n+        AbstractVector<?> other = ((AbstractSpecies<?>)species).dummyVectorMF();\n@@ -188,2 +190,1 @@\n-\n-    abstract AbstractMask<E> maskFromArray(boolean[] bits);\n+    abstract AbstractMask<E> maskFromPayload(VectorPayloadMF payload);\n@@ -196,1 +197,1 @@\n-    abstract AbstractShuffle<E> shuffleFromBytes(byte[] reorder);\n+    abstract AbstractShuffle<E> shuffleFromBytes(VectorPayloadMF indexes);\n@@ -702,2 +703,2 @@\n-            rvtype = rspi.dummyVector().getClass();\n-            vtype = vspi.dummyVector().getClass();\n+            rvtype = rspi.dummyVectorMF().getClass();\n+            vtype = vspi.dummyVectorMF().getClass();\n@@ -716,1 +717,1 @@\n-            rvtype = rsp.dummyVector().getClass();  \/\/ (profile)\n+            rvtype = rsp.dummyVectorMF().getClass();  \/\/ (profile)\n@@ -728,1 +729,1 @@\n-            rvtype = rsp.dummyVector().getClass();  \/\/ (profile)\n+            rvtype = rsp.dummyVectorMF().getClass();  \/\/ (profile)\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Byte128Vector extends ByteVector {\n+value class Byte128Vector extends ByteVector {\n@@ -57,2 +58,6 @@\n-    Byte128Vector(byte[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128B.class);\n+\n+    private final VectorPayloadMF128B payload;\n+\n+    Byte128Vector(Object value) {\n+        this.payload = (VectorPayloadMF128B) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Byte128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Byte128Vector(Object v) {\n-        this((byte[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Byte128Vector ZERO = new Byte128Vector(new byte[VLENGTH]);\n-    static final Byte128Vector IOTA = new Byte128Vector(VSPECIES.iotaArray());\n+    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.newInstanceFactory(byte.class, 16));\n+    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Byte128Mask maskFromArray(boolean[] bits) {\n-        return new Byte128Mask(bits);\n+    Byte128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte128Mask(payload);\n@@ -157,1 +157,1 @@\n-    Byte128Shuffle shuffleFromBytes(byte[] reorder) { return new Byte128Shuffle(reorder); }\n+    Byte128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Byte128Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Byte128Vector vectorFactory(byte[] vec) {\n+    Byte128Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Byte128Vector uOp(FUnOp f) {\n-        return (Byte128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Byte128Vector uOpMF(FUnOp f) {\n+        return (Byte128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Byte128Vector uOp(VectorMask<Byte> m, FUnOp f) {\n+    Byte128Vector uOpMF(VectorMask<Byte> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Byte128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Byte128Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Byte128Vector bOp(Vector<Byte> v, FBinOp f) {\n-        return (Byte128Vector) super.bOpTemplate((Byte128Vector)v, f);  \/\/ specialize\n+    Byte128Vector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (Byte128Vector) super.bOpTemplateMF((Byte128Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Byte128Vector bOp(Vector<Byte> v,\n+    Byte128Vector bOpMF(Vector<Byte> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Byte128Vector)v, (Byte128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Byte128Vector)v, (Byte128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Byte128Vector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+    Byte128Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Byte128Vector)v1, (Byte128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte128Vector)v1, (Byte128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Byte128Vector tOp(Vector<Byte> v1, Vector<Byte> v2,\n+    Byte128Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Byte128Vector)v1, (Byte128Vector)v2,\n-                              (Byte128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte128Vector)v1, (Byte128Vector)v2,\n+                                (Byte128Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -536,6 +536,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n@@ -569,1 +570,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -573,3 +574,6 @@\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -581,1 +585,1 @@\n-    static final class Byte128Mask extends AbstractMask<Byte> {\n+    static final value class Byte128Mask extends AbstractMask<Byte> {\n@@ -585,3 +589,1 @@\n-        Byte128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -589,2 +591,2 @@\n-        Byte128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -593,2 +595,2 @@\n-        Byte128Mask(boolean val) {\n-            super(prepare(val));\n+        Byte128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -597,12 +599,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -621,4 +613,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -626,18 +614,2 @@\n-        Byte128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte128Mask(res);\n-        }\n-\n-        @Override\n-        Byte128Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -653,27 +625,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -700,1 +645,1 @@\n-            return (Byte128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -713,3 +658,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -723,3 +668,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -733,3 +678,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -744,1 +689,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).trueCountHelper());\n@@ -751,1 +696,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).firstTrueHelper());\n@@ -758,1 +703,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).lastTrueHelper());\n@@ -768,1 +713,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte128Mask) m).toLongHelper());\n@@ -778,1 +723,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Byte128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -788,1 +733,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));\n+                                         (m, __) -> ((Byte128Mask) m).anyTrueHelper());\n@@ -796,1 +741,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));\n+                                         (m, __) -> ((Byte128Mask) m).allTrueHelper());\n@@ -813,1 +758,1 @@\n-    static final class Byte128Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte128Shuffle extends AbstractShuffle<Byte> {\n@@ -817,2 +762,6 @@\n-        Byte128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Byte128Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -821,2 +770,2 @@\n-        public Byte128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Byte128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -825,2 +774,2 @@\n-        public Byte128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Byte128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -830,1 +779,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -867,6 +822,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -874,0 +832,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Byte256Vector extends ByteVector {\n+value class Byte256Vector extends ByteVector {\n@@ -57,2 +58,6 @@\n-    Byte256Vector(byte[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256B.class);\n+\n+    private final VectorPayloadMF256B payload;\n+\n+    Byte256Vector(Object value) {\n+        this.payload = (VectorPayloadMF256B) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Byte256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Byte256Vector(Object v) {\n-        this((byte[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Byte256Vector ZERO = new Byte256Vector(new byte[VLENGTH]);\n-    static final Byte256Vector IOTA = new Byte256Vector(VSPECIES.iotaArray());\n+    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.newInstanceFactory(byte.class, 32));\n+    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Byte256Mask maskFromArray(boolean[] bits) {\n-        return new Byte256Mask(bits);\n+    Byte256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte256Mask(payload);\n@@ -157,1 +157,1 @@\n-    Byte256Shuffle shuffleFromBytes(byte[] reorder) { return new Byte256Shuffle(reorder); }\n+    Byte256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Byte256Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Byte256Vector vectorFactory(byte[] vec) {\n+    Byte256Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Byte256Vector uOp(FUnOp f) {\n-        return (Byte256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Byte256Vector uOpMF(FUnOp f) {\n+        return (Byte256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Byte256Vector uOp(VectorMask<Byte> m, FUnOp f) {\n+    Byte256Vector uOpMF(VectorMask<Byte> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Byte256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Byte256Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Byte256Vector bOp(Vector<Byte> v, FBinOp f) {\n-        return (Byte256Vector) super.bOpTemplate((Byte256Vector)v, f);  \/\/ specialize\n+    Byte256Vector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (Byte256Vector) super.bOpTemplateMF((Byte256Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Byte256Vector bOp(Vector<Byte> v,\n+    Byte256Vector bOpMF(Vector<Byte> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Byte256Vector)v, (Byte256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Byte256Vector)v, (Byte256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Byte256Vector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+    Byte256Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Byte256Vector)v1, (Byte256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte256Vector)v1, (Byte256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Byte256Vector tOp(Vector<Byte> v1, Vector<Byte> v2,\n+    Byte256Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Byte256Vector)v1, (Byte256Vector)v2,\n-                              (Byte256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte256Vector)v1, (Byte256Vector)v2,\n+                                (Byte256Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -552,6 +552,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n@@ -601,1 +602,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -605,3 +606,6 @@\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -613,1 +617,1 @@\n-    static final class Byte256Mask extends AbstractMask<Byte> {\n+    static final value class Byte256Mask extends AbstractMask<Byte> {\n@@ -617,3 +621,1 @@\n-        Byte256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF256Z payload;\n@@ -621,2 +623,2 @@\n-        Byte256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF256Z) payload;\n@@ -625,2 +627,2 @@\n-        Byte256Mask(boolean val) {\n-            super(prepare(val));\n+        Byte256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -629,12 +631,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -653,4 +645,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -658,18 +646,2 @@\n-        Byte256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte256Mask(res);\n-        }\n-\n-        @Override\n-        Byte256Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -685,27 +657,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -732,1 +677,1 @@\n-            return (Byte256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -745,3 +690,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -755,3 +700,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -765,3 +710,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -776,1 +721,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).trueCountHelper());\n@@ -783,1 +728,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).firstTrueHelper());\n@@ -790,1 +735,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).lastTrueHelper());\n@@ -800,1 +745,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte256Mask) m).toLongHelper());\n@@ -810,1 +755,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Byte256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -820,1 +765,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));\n+                                         (m, __) -> ((Byte256Mask) m).anyTrueHelper());\n@@ -828,1 +773,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));\n+                                         (m, __) -> ((Byte256Mask) m).allTrueHelper());\n@@ -845,1 +790,1 @@\n-    static final class Byte256Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte256Shuffle extends AbstractShuffle<Byte> {\n@@ -849,2 +794,6 @@\n-        Byte256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF256B payload;\n+\n+        Byte256Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF256B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -853,2 +802,2 @@\n-        public Byte256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Byte256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -857,2 +806,2 @@\n-        public Byte256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Byte256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -862,1 +811,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -899,6 +854,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -906,0 +864,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Byte512Vector extends ByteVector {\n+value class Byte512Vector extends ByteVector {\n@@ -57,2 +58,6 @@\n-    Byte512Vector(byte[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512B.class);\n+\n+    private final VectorPayloadMF512B payload;\n+\n+    Byte512Vector(Object value) {\n+        this.payload = (VectorPayloadMF512B) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Byte512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Byte512Vector(Object v) {\n-        this((byte[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Byte512Vector ZERO = new Byte512Vector(new byte[VLENGTH]);\n-    static final Byte512Vector IOTA = new Byte512Vector(VSPECIES.iotaArray());\n+    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.newInstanceFactory(byte.class, 64));\n+    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Byte512Mask maskFromArray(boolean[] bits) {\n-        return new Byte512Mask(bits);\n+    Byte512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte512Mask(payload);\n@@ -157,1 +157,1 @@\n-    Byte512Shuffle shuffleFromBytes(byte[] reorder) { return new Byte512Shuffle(reorder); }\n+    Byte512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Byte512Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Byte512Vector vectorFactory(byte[] vec) {\n+    Byte512Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Byte512Vector uOp(FUnOp f) {\n-        return (Byte512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Byte512Vector uOpMF(FUnOp f) {\n+        return (Byte512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Byte512Vector uOp(VectorMask<Byte> m, FUnOp f) {\n+    Byte512Vector uOpMF(VectorMask<Byte> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Byte512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Byte512Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Byte512Vector bOp(Vector<Byte> v, FBinOp f) {\n-        return (Byte512Vector) super.bOpTemplate((Byte512Vector)v, f);  \/\/ specialize\n+    Byte512Vector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (Byte512Vector) super.bOpTemplateMF((Byte512Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Byte512Vector bOp(Vector<Byte> v,\n+    Byte512Vector bOpMF(Vector<Byte> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Byte512Vector)v, (Byte512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Byte512Vector)v, (Byte512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Byte512Vector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+    Byte512Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Byte512Vector)v1, (Byte512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte512Vector)v1, (Byte512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Byte512Vector tOp(Vector<Byte> v1, Vector<Byte> v2,\n+    Byte512Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Byte512Vector)v1, (Byte512Vector)v2,\n-                              (Byte512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte512Vector)v1, (Byte512Vector)v2,\n+                                (Byte512Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -584,6 +584,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n@@ -665,1 +666,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -669,3 +670,6 @@\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -677,1 +681,1 @@\n-    static final class Byte512Mask extends AbstractMask<Byte> {\n+    static final value class Byte512Mask extends AbstractMask<Byte> {\n@@ -681,3 +685,1 @@\n-        Byte512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF512Z payload;\n@@ -685,2 +687,2 @@\n-        Byte512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF512Z) payload;\n@@ -689,2 +691,2 @@\n-        Byte512Mask(boolean val) {\n-            super(prepare(val));\n+        Byte512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -693,12 +695,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -717,4 +709,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -722,18 +710,2 @@\n-        Byte512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte512Mask(res);\n-        }\n-\n-        @Override\n-        Byte512Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -749,27 +721,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -796,1 +741,1 @@\n-            return (Byte512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -809,3 +754,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -819,3 +764,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -829,3 +774,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -840,1 +785,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).trueCountHelper());\n@@ -847,1 +792,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).firstTrueHelper());\n@@ -854,1 +799,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).lastTrueHelper());\n@@ -864,1 +809,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte512Mask) m).toLongHelper());\n@@ -874,1 +819,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Byte512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -884,1 +829,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));\n+                                         (m, __) -> ((Byte512Mask) m).anyTrueHelper());\n@@ -892,1 +837,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));\n+                                         (m, __) -> ((Byte512Mask) m).allTrueHelper());\n@@ -909,1 +854,1 @@\n-    static final class Byte512Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte512Shuffle extends AbstractShuffle<Byte> {\n@@ -913,2 +858,6 @@\n-        Byte512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF512B payload;\n+\n+        Byte512Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF512B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -917,2 +866,2 @@\n-        public Byte512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Byte512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -921,2 +870,2 @@\n-        public Byte512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Byte512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -926,1 +875,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -963,6 +918,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -970,0 +928,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Byte64Vector extends ByteVector {\n+value class Byte64Vector extends ByteVector {\n@@ -57,2 +58,6 @@\n-    Byte64Vector(byte[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64B.class);\n+\n+    private final VectorPayloadMF64B payload;\n+\n+    Byte64Vector(Object value) {\n+        this.payload = (VectorPayloadMF64B) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Byte64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Byte64Vector(Object v) {\n-        this((byte[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Byte64Vector ZERO = new Byte64Vector(new byte[VLENGTH]);\n-    static final Byte64Vector IOTA = new Byte64Vector(VSPECIES.iotaArray());\n+    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.newInstanceFactory(byte.class, 8));\n+    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Byte64Mask maskFromArray(boolean[] bits) {\n-        return new Byte64Mask(bits);\n+    Byte64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte64Mask(payload);\n@@ -157,1 +157,1 @@\n-    Byte64Shuffle shuffleFromBytes(byte[] reorder) { return new Byte64Shuffle(reorder); }\n+    Byte64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Byte64Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Byte64Vector vectorFactory(byte[] vec) {\n+    Byte64Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Byte64Vector uOp(FUnOp f) {\n-        return (Byte64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Byte64Vector uOpMF(FUnOp f) {\n+        return (Byte64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Byte64Vector uOp(VectorMask<Byte> m, FUnOp f) {\n+    Byte64Vector uOpMF(VectorMask<Byte> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Byte64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Byte64Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Byte64Vector bOp(Vector<Byte> v, FBinOp f) {\n-        return (Byte64Vector) super.bOpTemplate((Byte64Vector)v, f);  \/\/ specialize\n+    Byte64Vector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (Byte64Vector) super.bOpTemplateMF((Byte64Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Byte64Vector bOp(Vector<Byte> v,\n+    Byte64Vector bOpMF(Vector<Byte> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Byte64Vector)v, (Byte64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Byte64Vector)v, (Byte64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Byte64Vector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+    Byte64Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Byte64Vector)v1, (Byte64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte64Vector)v1, (Byte64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Byte64Vector tOp(Vector<Byte> v1, Vector<Byte> v2,\n+    Byte64Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Byte64Vector)v1, (Byte64Vector)v2,\n-                              (Byte64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte64Vector)v1, (Byte64Vector)v2,\n+                                (Byte64Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -528,6 +528,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n@@ -553,1 +554,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -557,3 +558,6 @@\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -565,1 +569,1 @@\n-    static final class Byte64Mask extends AbstractMask<Byte> {\n+    static final value class Byte64Mask extends AbstractMask<Byte> {\n@@ -569,3 +573,1 @@\n-        Byte64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -573,2 +575,2 @@\n-        Byte64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -577,2 +579,2 @@\n-        Byte64Mask(boolean val) {\n-            super(prepare(val));\n+        Byte64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -581,12 +583,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -605,4 +597,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -610,18 +598,2 @@\n-        Byte64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte64Mask(res);\n-        }\n-\n-        @Override\n-        Byte64Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -637,27 +609,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -684,1 +629,1 @@\n-            return (Byte64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -697,3 +642,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -707,3 +652,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -717,3 +662,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -728,1 +673,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).trueCountHelper());\n@@ -735,1 +680,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).firstTrueHelper());\n@@ -742,1 +687,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).lastTrueHelper());\n@@ -752,1 +697,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte64Mask) m).toLongHelper());\n@@ -762,1 +707,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Byte64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -772,1 +717,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));\n+                                         (m, __) -> ((Byte64Mask) m).anyTrueHelper());\n@@ -780,1 +725,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));\n+                                         (m, __) -> ((Byte64Mask) m).allTrueHelper());\n@@ -797,1 +742,1 @@\n-    static final class Byte64Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte64Shuffle extends AbstractShuffle<Byte> {\n@@ -801,2 +746,6 @@\n-        Byte64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Byte64Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -805,2 +754,2 @@\n-        public Byte64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Byte64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -809,2 +758,2 @@\n-        public Byte64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Byte64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -814,1 +763,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -851,6 +806,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -858,0 +816,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -1,931 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class ByteMaxVector extends ByteVector {\n-    static final ByteSpecies VSPECIES =\n-        (ByteSpecies) ByteVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<ByteMaxVector> VCLASS = ByteMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n-\n-    ByteMaxVector(byte[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as ByteMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    ByteMaxVector(Object v) {\n-        this((byte[]) v);\n-    }\n-\n-    static final ByteMaxVector ZERO = new ByteMaxVector(new byte[VLENGTH]);\n-    static final ByteMaxVector IOTA = new ByteMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public ByteSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Byte> elementType() { return byte.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Byte.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxVector broadcast(byte e) {\n-        return (ByteMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxVector broadcast(long e) {\n-        return (ByteMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxMask maskFromArray(boolean[] bits) {\n-        return new ByteMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle iotaShuffle() { return ByteMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    ByteMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromBytes(byte[] reorder) { return new ByteMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ByteMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new ByteMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector vectorFactory(byte[] vec) {\n-        return new ByteMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector uOp(FUnOp f) {\n-        return (ByteMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector uOp(VectorMask<Byte> m, FUnOp f) {\n-        return (ByteMaxVector)\n-            super.uOpTemplate((ByteMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector bOp(Vector<Byte> v, FBinOp f) {\n-        return (ByteMaxVector) super.bOpTemplate((ByteMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector bOp(Vector<Byte> v,\n-                     VectorMask<Byte> m, FBinOp f) {\n-        return (ByteMaxVector)\n-            super.bOpTemplate((ByteMaxVector)v, (ByteMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n-        return (ByteMaxVector)\n-            super.tOpTemplate((ByteMaxVector)v1, (ByteMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector tOp(Vector<Byte> v1, Vector<Byte> v2,\n-                     VectorMask<Byte> m, FTriOp f) {\n-        return (ByteMaxVector)\n-            super.tOpTemplate((ByteMaxVector)v1, (ByteMaxVector)v2,\n-                              (ByteMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Byte,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector lanewise(Unary op) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector lanewise(Unary op, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector lanewise(Binary op, Vector<Byte> v) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline ByteMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e) {\n-        return (ByteMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline ByteMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseShiftTemplate(op, ByteMaxMask.class, e, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    ByteMaxVector\n-    lanewise(Ternary op, Vector<Byte> v1, Vector<Byte> v2) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    ByteMaxVector\n-    lanewise(Ternary op, Vector<Byte> v1, Vector<Byte> v2, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v1, v2, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    ByteMaxVector addIndex(int scale) {\n-        return (ByteMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final byte reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final byte reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Byte> m) {\n-        return super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Byte> m) {\n-        return (long) super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask test(Test op) {\n-        return super.testTemplate(ByteMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask test(Test op, VectorMask<Byte> m) {\n-        return super.testTemplate(ByteMaxMask.class, op, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask compare(Comparison op, Vector<Byte> v) {\n-        return super.compareTemplate(ByteMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask compare(Comparison op, byte s) {\n-        return super.compareTemplate(ByteMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(ByteMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask compare(Comparison op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return super.compareTemplate(ByteMaxMask.class, op, v, (ByteMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector blend(Vector<Byte> v, VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.blendTemplate(ByteMaxMask.class,\n-                                (ByteMaxVector) v,\n-                                (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector slice(int origin, Vector<Byte> v) {\n-        return (ByteMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector slice(int origin) {\n-        return (ByteMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector unslice(int origin, Vector<Byte> w, int part) {\n-        return (ByteMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector unslice(int origin, Vector<Byte> w, int part, VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.unsliceTemplate(ByteMaxMask.class,\n-                                  origin, w, part,\n-                                  (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector unslice(int origin) {\n-        return (ByteMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector rearrange(VectorShuffle<Byte> s) {\n-        return (ByteMaxVector)\n-            super.rearrangeTemplate(ByteMaxShuffle.class,\n-                                    (ByteMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector rearrange(VectorShuffle<Byte> shuffle,\n-                                  VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.rearrangeTemplate(ByteMaxShuffle.class,\n-                                    ByteMaxMask.class,\n-                                    (ByteMaxShuffle) shuffle,\n-                                    (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector rearrange(VectorShuffle<Byte> s,\n-                                  Vector<Byte> v) {\n-        return (ByteMaxVector)\n-            super.rearrangeTemplate(ByteMaxShuffle.class,\n-                                    (ByteMaxShuffle) s,\n-                                    (ByteMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector compress(VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.compressTemplate(ByteMaxMask.class,\n-                                   (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector expand(VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.expandTemplate(ByteMaxMask.class,\n-                                   (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector selectFrom(Vector<Byte> v) {\n-        return (ByteMaxVector)\n-            super.selectFromTemplate((ByteMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector selectFrom(Vector<Byte> v,\n-                                   VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.selectFromTemplate((ByteMaxVector) v,\n-                                     (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public byte lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return laneHelper(i);\n-    }\n-\n-    public byte laneHelper(int i) {\n-        return (byte) VectorSupport.extract(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public ByteMaxVector withLane(int i, byte e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public ByteMaxVector withLaneHelper(int i, byte e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)e,\n-                                (v, ix, bits) -> {\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class ByteMaxMask extends AbstractMask<Byte> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n-\n-        ByteMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        ByteMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        ByteMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public ByteSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        ByteMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new ByteMaxMask(res);\n-        }\n-\n-        @Override\n-        ByteMaxMask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((ByteMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new ByteMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        ByteMaxVector toVector() {\n-            return (ByteMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        \/*package-private*\/\n-        ByteMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n-            return (ByteMaxMask) VectorSupport.indexPartiallyInUpperRange(\n-                ByteMaxMask.class, byte.class, VLENGTH, offset, limit,\n-                (o, l) -> (ByteMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask compress() {\n-            return (ByteMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask and(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            ByteMaxMask m = (ByteMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask or(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            ByteMaxMask m = (ByteMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask xor(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            ByteMaxMask m = (ByteMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ laneIsSet\n-\n-        @Override\n-        @ForceInline\n-        public boolean laneIsSet(int i) {\n-            Objects.checkIndex(i, length());\n-            return VectorSupport.extract(ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static ByteMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final ByteMaxMask  TRUE_MASK = new ByteMaxMask(true);\n-        private static final ByteMaxMask FALSE_MASK = new ByteMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class ByteMaxShuffle extends AbstractShuffle<Byte> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n-\n-        ByteMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public ByteMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public ByteMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public ByteMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public ByteSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final ByteMaxShuffle IOTA = new ByteMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ByteMaxVector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            ByteMaxShuffle s = (ByteMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new ByteMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromArray0(byte[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m, int offsetInRange) {\n-        return super.fromArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n-        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m, int offsetInRange) {\n-        return super.fromBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(byte[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n-        super.intoBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n-        super.intoMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":0,"deletions":931,"binary":false,"changes":931,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    ByteVector(byte[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public ByteVector() {}\n@@ -96,3 +96,0 @@\n-    \/*package-private*\/\n-    abstract byte[] vec();\n-\n@@ -103,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -106,1 +103,1 @@\n-    abstract ByteVector vectorFactory(byte[] vec);\n+    abstract ByteVector vectorFactory(VectorPayloadMF vec);\n@@ -115,2 +112,2 @@\n-    AbstractMask<Byte> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Byte> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -127,1 +124,1 @@\n-    ByteVector vOp(FVOp f) {\n+    ByteVector vOpMF(FVOp f) {\n@@ -132,1 +129,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +135,1 @@\n-    ByteVector vOp(VectorMask<Byte> m, FVOp f) {\n+    ByteVector vOpMF(VectorMask<Byte> m, FVOp f) {\n@@ -139,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -141,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -145,1 +144,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +157,1 @@\n-    ByteVector uOp(FUnOp f);\n+    ByteVector uOpMF(FUnOp f);\n@@ -160,5 +160,8 @@\n-    ByteVector uOpTemplate(FUnOp f) {\n-        byte[] vec = vec();\n-        byte[] res = new byte[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    ByteVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v));\n@@ -166,1 +169,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +175,1 @@\n-    ByteVector uOp(VectorMask<Byte> m,\n+    ByteVector uOpMF(VectorMask<Byte> m,\n@@ -175,1 +179,1 @@\n-    ByteVector uOpTemplate(VectorMask<Byte> m,\n+    ByteVector uOpTemplateMF(VectorMask<Byte> m,\n@@ -178,1 +182,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,5 +184,10 @@\n-        byte[] vec = vec();\n-        byte[] res = new byte[length()];\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -186,1 +195,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +208,1 @@\n-    ByteVector bOp(Vector<Byte> o,\n+    ByteVector bOpMF(Vector<Byte> o,\n@@ -202,1 +212,1 @@\n-    ByteVector bOpTemplate(Vector<Byte> o,\n+    ByteVector bOpTemplateMF(Vector<Byte> o,\n@@ -204,5 +214,9 @@\n-        byte[] res = new byte[length()];\n-        byte[] vec1 = this.vec();\n-        byte[] vec2 = ((ByteVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +224,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +230,1 @@\n-    ByteVector bOp(Vector<Byte> o,\n+    ByteVector bOpMF(Vector<Byte> o,\n@@ -220,1 +235,1 @@\n-    ByteVector bOpTemplate(Vector<Byte> o,\n+    ByteVector bOpTemplateMF(Vector<Byte> o,\n@@ -224,1 +239,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,6 +241,12 @@\n-        byte[] res = new byte[length()];\n-        byte[] vec1 = this.vec();\n-        byte[] vec2 = ((ByteVector)o).vec();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -233,1 +254,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +267,1 @@\n-    ByteVector tOp(Vector<Byte> o1,\n+    ByteVector tOpMF(Vector<Byte> o1,\n@@ -250,1 +272,1 @@\n-    ByteVector tOpTemplate(Vector<Byte> o1,\n+    ByteVector tOpTemplateMF(Vector<Byte> o1,\n@@ -253,6 +275,11 @@\n-        byte[] res = new byte[length()];\n-        byte[] vec1 = this.vec();\n-        byte[] vec2 = ((ByteVector)o1).vec();\n-        byte[] vec3 = ((ByteVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ByteVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v3 = Unsafe.getUnsafe().getByte(vec3, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +287,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +293,1 @@\n-    ByteVector tOp(Vector<Byte> o1,\n+    ByteVector tOpMF(Vector<Byte> o1,\n@@ -271,1 +299,1 @@\n-    ByteVector tOpTemplate(Vector<Byte> o1,\n+    ByteVector tOpTemplateMF(Vector<Byte> o1,\n@@ -276,1 +304,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,7 +306,14 @@\n-        byte[] res = new byte[length()];\n-        byte[] vec1 = this.vec();\n-        byte[] vec2 = ((ByteVector)o1).vec();\n-        byte[] vec3 = ((ByteVector)o2).vec();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ByteVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v3 = Unsafe.getUnsafe().getByte(vec3, vOffset + i * Byte.BYTES);\n+            byte v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f);\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    byte rOpTemplate(byte v, VectorMask<Byte> m, FBinOp f) {\n+    byte rOpTemplateMF(byte v, VectorMask<Byte> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,4 +337,8 @@\n-        byte[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -311,4 +351,7 @@\n-    byte rOpTemplate(byte v, FBinOp f) {\n-        byte[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    byte rOpTemplateMF(byte v, FBinOp f) {\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +372,1 @@\n-    <M> ByteVector ldOp(M memory, int offset,\n+    <M> ByteVector ldOpMF(M memory, int offset,\n@@ -331,4 +374,7 @@\n-        \/\/dummy; no vec = vec();\n-        byte[] res = new byte[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                byte.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +382,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +389,1 @@\n-    <M> ByteVector ldOp(M memory, int offset,\n+    <M> ByteVector ldOpMF(M memory, int offset,\n@@ -345,6 +392,10 @@\n-        \/\/byte[] vec = vec();\n-        byte[] res = new byte[length()];\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                byte.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +404,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +408,1 @@\n+\n@@ -364,1 +417,1 @@\n-    ByteVector ldLongOp(MemorySegment memory, long offset,\n+    ByteVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +419,7 @@\n-        \/\/dummy; no vec = vec();\n-        byte[] res = new byte[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                byte.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +427,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +434,1 @@\n-    ByteVector ldLongOp(MemorySegment memory, long offset,\n+    ByteVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,6 +437,10 @@\n-        \/\/byte[] vec = vec();\n-        byte[] res = new byte[length()];\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                byte.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +449,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +464,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +466,5 @@\n-        byte[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -411,1 +475,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +477,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,5 +480,8 @@\n-        byte[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -425,0 +492,1 @@\n+\n@@ -432,1 +500,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +502,5 @@\n-        byte[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -443,1 +513,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,5 +516,8 @@\n-        byte[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -469,1 +542,1 @@\n-    AbstractMask<Byte> bTest(int cond,\n+    AbstractMask<Byte> bTestMF(int cond,\n@@ -472,5 +545,11 @@\n-        byte[] vec1 = vec();\n-        byte[] vec2 = ((ByteVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        int length = vspecies().length();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -478,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -565,1 +645,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -725,1 +805,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) -a);\n+                    v0.uOpMF(m, (i, a) -> (byte) -a);\n@@ -727,1 +807,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (byte) Math.abs(a));\n@@ -729,1 +809,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> (byte) bitCount(a));\n@@ -731,1 +811,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (byte) numberOfTrailingZeros(a));\n@@ -733,1 +813,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (byte) numberOfLeadingZeros(a));\n@@ -735,1 +815,1 @@\n-                    v0.uOp(m, (i, a) -> reverse(a));\n+                    v0.uOpMF(m, (i, a) -> reverse(a));\n@@ -737,1 +817,1 @@\n-                    v0.uOp(m, (i, a) -> a);\n+                    v0.uOpMF(m, (i, a) -> a);\n@@ -787,1 +867,1 @@\n-            BIN_IMPL.find(op, opc, ByteVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, ByteVector::binaryOperationsMF));\n@@ -847,1 +927,35 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+            default: return null;\n+        }\n+    }\n+\n+    private static BinaryOperation<ByteVector, VectorMask<Byte>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a + b));\n@@ -849,1 +963,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a - b));\n@@ -851,1 +965,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a * b));\n@@ -853,1 +967,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a \/ b));\n@@ -855,1 +969,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.max(a, b));\n@@ -857,1 +971,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.min(a, b));\n@@ -859,1 +973,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a & b));\n@@ -861,1 +975,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a | b));\n@@ -863,1 +977,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a ^ b));\n@@ -865,1 +979,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (byte)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)(a << n));\n@@ -867,1 +981,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (byte)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)(a >> n));\n@@ -869,1 +983,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n@@ -871,1 +985,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -873,1 +987,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -878,0 +992,1 @@\n+\n@@ -1042,1 +1157,1 @@\n-                    v.uOp(m, (i, a) -> (byte)(a << n));\n+                    v.uOpMF(m, (i, a) -> (byte)(a << n));\n@@ -1044,1 +1159,1 @@\n-                    v.uOp(m, (i, a) -> (byte)(a >> n));\n+                    v.uOpMF(m, (i, a) -> (byte)(a >> n));\n@@ -1046,1 +1161,1 @@\n-                    v.uOp(m, (i, a) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1048,1 +1163,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -1050,1 +1165,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -2049,1 +2164,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2071,1 +2186,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2200,1 +2315,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2407,1 +2522,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2439,1 +2554,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2467,1 +2582,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2475,1 +2590,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2817,1 +2932,1 @@\n-                    toBits(v.rOp((byte)0, m, (i, a, b) -> (byte)(a + b)));\n+                    toBits(v.rOpMF((byte)0, m, (i, a, b) -> (byte)(a + b)));\n@@ -2819,1 +2934,1 @@\n-                    toBits(v.rOp((byte)1, m, (i, a, b) -> (byte)(a * b)));\n+                    toBits(v.rOpMF((byte)1, m, (i, a, b) -> (byte)(a * b)));\n@@ -2821,1 +2936,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (byte) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (byte) Math.min(a, b)));\n@@ -2823,1 +2938,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (byte) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (byte) Math.max(a, b)));\n@@ -2825,1 +2940,1 @@\n-                    toBits(v.rOp((byte)-1, m, (i, a, b) -> (byte)(a & b)));\n+                    toBits(v.rOpMF((byte)-1, m, (i, a, b) -> (byte)(a & b)));\n@@ -2827,1 +2942,1 @@\n-                    toBits(v.rOp((byte)0, m, (i, a, b) -> (byte)(a | b)));\n+                    toBits(v.rOpMF((byte)0, m, (i, a, b) -> (byte)(a | b)));\n@@ -2829,1 +2944,1 @@\n-                    toBits(v.rOp((byte)0, m, (i, a, b) -> (byte)(a ^ b)));\n+                    toBits(v.rOpMF((byte)0, m, (i, a, b) -> (byte)(a ^ b)));\n@@ -2977,1 +3092,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -3008,1 +3123,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3012,1 +3127,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3052,1 +3167,1 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3098,1 +3213,1 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3127,1 +3242,1 @@\n-        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+        return vsp.dummyVectorMF().fromBooleanArray0(a, offset);\n@@ -3164,1 +3279,1 @@\n-            return vsp.dummyVector().fromBooleanArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromBooleanArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3168,1 +3283,1 @@\n-        return vsp.dummyVector().fromBooleanArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromBooleanArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3209,1 +3324,1 @@\n-        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        return vsp.vOpMF(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n@@ -3256,1 +3371,1 @@\n-        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        return vsp.vOpMF(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n@@ -3297,1 +3412,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3350,1 +3465,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3354,1 +3469,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3384,1 +3499,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3386,0 +3501,1 @@\n+\n@@ -3457,1 +3573,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -3499,1 +3615,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -3537,1 +3653,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3620,1 +3736,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -3668,1 +3784,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -3746,1 +3862,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3763,1 +3879,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3780,1 +3896,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3797,1 +3913,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3811,1 +3927,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, ByteVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, ByteVector::memorySegmentGet);\n@@ -3827,1 +3943,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);\n@@ -3846,1 +3962,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3863,1 +3979,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3882,1 +3998,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3895,1 +4011,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, ByteVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, ByteVector::memorySegmentSet);\n@@ -3912,1 +4028,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, ByteVector::memorySegmentSet);\n@@ -4142,1 +4258,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -4193,1 +4309,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -4208,2 +4324,2 @@\n-        ByteVector dummyVector() {\n-            return (ByteVector) super.dummyVector();\n+        ByteVector dummyVectorMF() {\n+            return (ByteVector) super.dummyVectorMF();\n@@ -4215,1 +4331,1 @@\n-        ByteVector rvOp(RVOp f) {\n+        ByteVector rvOpMF(RVOp f) {\n@@ -4221,1 +4337,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4224,1 +4341,1 @@\n-        ByteVector vOp(FVOp f) {\n+        ByteVector vOpMF(FVOp f) {\n@@ -4229,1 +4346,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4232,1 +4350,1 @@\n-        ByteVector vOp(VectorMask<Byte> m, FVOp f) {\n+        ByteVector vOpMF(VectorMask<Byte> m, FVOp f) {\n@@ -4234,1 +4352,2 @@\n-            boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -4236,1 +4355,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -4240,1 +4359,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4245,1 +4365,1 @@\n-        <M> ByteVector ldOp(M memory, int offset,\n+        <M> ByteVector ldOpMF(M memory, int offset,\n@@ -4247,1 +4367,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -4252,1 +4372,1 @@\n-        <M> ByteVector ldOp(M memory, int offset,\n+        <M> ByteVector ldOpMF(M memory, int offset,\n@@ -4255,1 +4375,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -4258,0 +4378,1 @@\n+\n@@ -4260,1 +4381,1 @@\n-        ByteVector ldLongOp(MemorySegment memory, long offset,\n+        ByteVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -4262,1 +4383,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -4267,1 +4388,1 @@\n-        ByteVector ldLongOp(MemorySegment memory, long offset,\n+        ByteVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -4270,1 +4391,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -4275,2 +4396,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -4281,2 +4402,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Byte> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Byte> m,\n@@ -4284,1 +4405,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -4287,0 +4408,1 @@\n+\n@@ -4289,2 +4411,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -4295,1 +4417,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -4298,1 +4420,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -4312,2 +4434,3 @@\n-            if ((Class<?>) vectorType() == ByteMaxVector.class)\n-                return ByteMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n+            \/\/    return ByteMaxVector.ZERO;\n@@ -4326,2 +4449,3 @@\n-            if ((Class<?>) vectorType() == ByteMaxVector.class)\n-                return ByteMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n+            \/\/    return ByteMaxVector.IOTA;\n@@ -4341,2 +4465,3 @@\n-            if ((Class<?>) vectorType() == ByteMaxVector.class)\n-                return ByteMaxVector.ByteMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n+            \/\/    return ByteMaxVector.ByteMaxMask.maskAll(bit);\n@@ -4351,0 +4476,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            byte [] init = new byte[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (byte)i;\n+            }\n+           return init;\n+        }\n@@ -4367,1 +4502,2 @@\n-            case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n@@ -4401,1 +4537,2 @@\n-    public static final VectorSpecies<Byte> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Byte> SPECIES_MAX\n@@ -4406,0 +4543,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":386,"deletions":248,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Double128Vector extends DoubleVector {\n+value class Double128Vector extends DoubleVector {\n@@ -57,2 +58,6 @@\n-    Double128Vector(double[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128D.class);\n+\n+    private final VectorPayloadMF128D payload;\n+\n+    Double128Vector(Object value) {\n+        this.payload = (VectorPayloadMF128D) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Double128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Double128Vector(Object v) {\n-        this((double[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Double128Vector ZERO = new Double128Vector(new double[VLENGTH]);\n-    static final Double128Vector IOTA = new Double128Vector(VSPECIES.iotaArray());\n+    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.newInstanceFactory(double.class, 2));\n+    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Double128Mask maskFromArray(boolean[] bits) {\n-        return new Double128Mask(bits);\n+    Double128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double128Mask(payload);\n@@ -157,1 +157,1 @@\n-    Double128Shuffle shuffleFromBytes(byte[] reorder) { return new Double128Shuffle(reorder); }\n+    Double128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Double128Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Double128Vector vectorFactory(double[] vec) {\n+    Double128Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Double128Vector uOp(FUnOp f) {\n-        return (Double128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Double128Vector uOpMF(FUnOp f) {\n+        return (Double128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Double128Vector uOp(VectorMask<Double> m, FUnOp f) {\n+    Double128Vector uOpMF(VectorMask<Double> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Double128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Double128Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Double128Vector bOp(Vector<Double> v, FBinOp f) {\n-        return (Double128Vector) super.bOpTemplate((Double128Vector)v, f);  \/\/ specialize\n+    Double128Vector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (Double128Vector) super.bOpTemplateMF((Double128Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Double128Vector bOp(Vector<Double> v,\n+    Double128Vector bOpMF(Vector<Double> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Double128Vector)v, (Double128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Double128Vector)v, (Double128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Double128Vector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+    Double128Vector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Double128Vector)v1, (Double128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Double128Vector)v1, (Double128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Double128Vector tOp(Vector<Double> v1, Vector<Double> v2,\n+    Double128Vector tOpMF(Vector<Double> v1, Vector<Double> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Double128Vector)v1, (Double128Vector)v2,\n-                              (Double128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Double128Vector)v1, (Double128Vector)v2,\n+                                (Double128Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -514,2 +514,3 @@\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n@@ -534,3 +535,6 @@\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -542,1 +546,1 @@\n-    static final class Double128Mask extends AbstractMask<Double> {\n+    static final value class Double128Mask extends AbstractMask<Double> {\n@@ -546,3 +550,1 @@\n-        Double128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -550,2 +552,2 @@\n-        Double128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -554,10 +556,2 @@\n-        Double128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -566,4 +560,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -582,14 +574,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Double128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double128Mask(res);\n-        }\n-\n@@ -597,8 +575,2 @@\n-        Double128Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -614,27 +586,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -661,1 +606,1 @@\n-            return (Double128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -674,3 +619,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -684,3 +629,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -694,3 +639,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -705,1 +650,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).trueCountHelper());\n@@ -712,1 +657,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).firstTrueHelper());\n@@ -719,1 +664,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).lastTrueHelper());\n@@ -729,1 +674,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double128Mask) m).toLongHelper());\n@@ -739,1 +684,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Double128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -749,1 +694,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));\n+                                         (m, __) -> ((Double128Mask) m).anyTrueHelper());\n@@ -757,1 +702,1 @@\n-                                         (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));\n+                                         (m, __) -> ((Double128Mask) m).allTrueHelper());\n@@ -774,1 +719,1 @@\n-    static final class Double128Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double128Shuffle extends AbstractShuffle<Double> {\n@@ -778,2 +723,6 @@\n-        Double128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Double128Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -782,2 +731,2 @@\n-        public Double128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Double128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -786,2 +735,2 @@\n-        public Double128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Double128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -791,1 +740,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -828,6 +783,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -835,0 +793,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":102,"deletions":143,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Double256Vector extends DoubleVector {\n+value class Double256Vector extends DoubleVector {\n@@ -57,2 +58,6 @@\n-    Double256Vector(double[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256D.class);\n+\n+    private final VectorPayloadMF256D payload;\n+\n+    Double256Vector(Object value) {\n+        this.payload = (VectorPayloadMF256D) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Double256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Double256Vector(Object v) {\n-        this((double[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Double256Vector ZERO = new Double256Vector(new double[VLENGTH]);\n-    static final Double256Vector IOTA = new Double256Vector(VSPECIES.iotaArray());\n+    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.newInstanceFactory(double.class, 4));\n+    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Double256Mask maskFromArray(boolean[] bits) {\n-        return new Double256Mask(bits);\n+    Double256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double256Mask(payload);\n@@ -157,1 +157,1 @@\n-    Double256Shuffle shuffleFromBytes(byte[] reorder) { return new Double256Shuffle(reorder); }\n+    Double256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Double256Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Double256Vector vectorFactory(double[] vec) {\n+    Double256Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Double256Vector uOp(FUnOp f) {\n-        return (Double256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Double256Vector uOpMF(FUnOp f) {\n+        return (Double256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Double256Vector uOp(VectorMask<Double> m, FUnOp f) {\n+    Double256Vector uOpMF(VectorMask<Double> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Double256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Double256Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Double256Vector bOp(Vector<Double> v, FBinOp f) {\n-        return (Double256Vector) super.bOpTemplate((Double256Vector)v, f);  \/\/ specialize\n+    Double256Vector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (Double256Vector) super.bOpTemplateMF((Double256Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Double256Vector bOp(Vector<Double> v,\n+    Double256Vector bOpMF(Vector<Double> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Double256Vector)v, (Double256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Double256Vector)v, (Double256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Double256Vector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+    Double256Vector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Double256Vector)v1, (Double256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Double256Vector)v1, (Double256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Double256Vector tOp(Vector<Double> v1, Vector<Double> v2,\n+    Double256Vector tOpMF(Vector<Double> v1, Vector<Double> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Double256Vector)v1, (Double256Vector)v2,\n-                              (Double256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Double256Vector)v1, (Double256Vector)v2,\n+                                (Double256Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -516,2 +516,3 @@\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n@@ -538,3 +539,6 @@\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -546,1 +550,1 @@\n-    static final class Double256Mask extends AbstractMask<Double> {\n+    static final value class Double256Mask extends AbstractMask<Double> {\n@@ -550,3 +554,1 @@\n-        Double256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -554,2 +556,2 @@\n-        Double256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -558,10 +560,2 @@\n-        Double256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -570,4 +564,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -586,14 +578,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Double256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double256Mask(res);\n-        }\n-\n@@ -601,8 +579,2 @@\n-        Double256Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -618,27 +590,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -665,1 +610,1 @@\n-            return (Double256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -678,3 +623,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -688,3 +633,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -698,3 +643,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -709,1 +654,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).trueCountHelper());\n@@ -716,1 +661,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).firstTrueHelper());\n@@ -723,1 +668,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).lastTrueHelper());\n@@ -733,1 +678,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double256Mask) m).toLongHelper());\n@@ -743,1 +688,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Double256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -753,1 +698,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));\n+                                         (m, __) -> ((Double256Mask) m).anyTrueHelper());\n@@ -761,1 +706,1 @@\n-                                         (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));\n+                                         (m, __) -> ((Double256Mask) m).allTrueHelper());\n@@ -778,1 +723,1 @@\n-    static final class Double256Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double256Shuffle extends AbstractShuffle<Double> {\n@@ -782,2 +727,6 @@\n-        Double256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Double256Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -786,2 +735,2 @@\n-        public Double256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Double256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -790,2 +739,2 @@\n-        public Double256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Double256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -795,1 +744,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -832,6 +787,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -839,0 +797,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":102,"deletions":143,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Double512Vector extends DoubleVector {\n+value class Double512Vector extends DoubleVector {\n@@ -57,2 +58,6 @@\n-    Double512Vector(double[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512D.class);\n+\n+    private final VectorPayloadMF512D payload;\n+\n+    Double512Vector(Object value) {\n+        this.payload = (VectorPayloadMF512D) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Double512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Double512Vector(Object v) {\n-        this((double[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Double512Vector ZERO = new Double512Vector(new double[VLENGTH]);\n-    static final Double512Vector IOTA = new Double512Vector(VSPECIES.iotaArray());\n+    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.newInstanceFactory(double.class, 8));\n+    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Double512Mask maskFromArray(boolean[] bits) {\n-        return new Double512Mask(bits);\n+    Double512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double512Mask(payload);\n@@ -157,1 +157,1 @@\n-    Double512Shuffle shuffleFromBytes(byte[] reorder) { return new Double512Shuffle(reorder); }\n+    Double512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Double512Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Double512Vector vectorFactory(double[] vec) {\n+    Double512Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Double512Vector uOp(FUnOp f) {\n-        return (Double512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Double512Vector uOpMF(FUnOp f) {\n+        return (Double512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Double512Vector uOp(VectorMask<Double> m, FUnOp f) {\n+    Double512Vector uOpMF(VectorMask<Double> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Double512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Double512Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Double512Vector bOp(Vector<Double> v, FBinOp f) {\n-        return (Double512Vector) super.bOpTemplate((Double512Vector)v, f);  \/\/ specialize\n+    Double512Vector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (Double512Vector) super.bOpTemplateMF((Double512Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Double512Vector bOp(Vector<Double> v,\n+    Double512Vector bOpMF(Vector<Double> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Double512Vector)v, (Double512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Double512Vector)v, (Double512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Double512Vector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+    Double512Vector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Double512Vector)v1, (Double512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Double512Vector)v1, (Double512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Double512Vector tOp(Vector<Double> v1, Vector<Double> v2,\n+    Double512Vector tOpMF(Vector<Double> v1, Vector<Double> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Double512Vector)v1, (Double512Vector)v2,\n-                              (Double512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Double512Vector)v1, (Double512Vector)v2,\n+                                (Double512Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -520,2 +520,3 @@\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n@@ -546,3 +547,6 @@\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -554,1 +558,1 @@\n-    static final class Double512Mask extends AbstractMask<Double> {\n+    static final value class Double512Mask extends AbstractMask<Double> {\n@@ -558,3 +562,1 @@\n-        Double512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -562,2 +564,2 @@\n-        Double512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -566,10 +568,2 @@\n-        Double512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -578,4 +572,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -594,14 +586,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Double512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double512Mask(res);\n-        }\n-\n@@ -609,8 +587,2 @@\n-        Double512Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -626,27 +598,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -673,1 +618,1 @@\n-            return (Double512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -686,3 +631,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -696,3 +641,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -706,3 +651,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -717,1 +662,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).trueCountHelper());\n@@ -724,1 +669,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).firstTrueHelper());\n@@ -731,1 +676,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).lastTrueHelper());\n@@ -741,1 +686,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double512Mask) m).toLongHelper());\n@@ -751,1 +696,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Double512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -761,1 +706,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));\n+                                         (m, __) -> ((Double512Mask) m).anyTrueHelper());\n@@ -769,1 +714,1 @@\n-                                         (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));\n+                                         (m, __) -> ((Double512Mask) m).allTrueHelper());\n@@ -786,1 +731,1 @@\n-    static final class Double512Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double512Shuffle extends AbstractShuffle<Double> {\n@@ -790,2 +735,6 @@\n-        Double512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Double512Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -794,2 +743,2 @@\n-        public Double512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Double512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -798,2 +747,2 @@\n-        public Double512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Double512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -803,1 +752,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -840,6 +795,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -847,0 +805,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":102,"deletions":143,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Double64Vector extends DoubleVector {\n+value class Double64Vector extends DoubleVector {\n@@ -57,2 +58,6 @@\n-    Double64Vector(double[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64D.class);\n+\n+    private final VectorPayloadMF64D payload;\n+\n+    Double64Vector(Object value) {\n+        this.payload = (VectorPayloadMF64D) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Double64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Double64Vector(Object v) {\n-        this((double[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Double64Vector ZERO = new Double64Vector(new double[VLENGTH]);\n-    static final Double64Vector IOTA = new Double64Vector(VSPECIES.iotaArray());\n+    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.newInstanceFactory(double.class, 1));\n+    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Double64Mask maskFromArray(boolean[] bits) {\n-        return new Double64Mask(bits);\n+    Double64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double64Mask(payload);\n@@ -157,1 +157,1 @@\n-    Double64Shuffle shuffleFromBytes(byte[] reorder) { return new Double64Shuffle(reorder); }\n+    Double64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Double64Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Double64Vector vectorFactory(double[] vec) {\n+    Double64Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Double64Vector uOp(FUnOp f) {\n-        return (Double64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Double64Vector uOpMF(FUnOp f) {\n+        return (Double64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Double64Vector uOp(VectorMask<Double> m, FUnOp f) {\n+    Double64Vector uOpMF(VectorMask<Double> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Double64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Double64Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Double64Vector bOp(Vector<Double> v, FBinOp f) {\n-        return (Double64Vector) super.bOpTemplate((Double64Vector)v, f);  \/\/ specialize\n+    Double64Vector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (Double64Vector) super.bOpTemplateMF((Double64Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Double64Vector bOp(Vector<Double> v,\n+    Double64Vector bOpMF(Vector<Double> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Double64Vector)v, (Double64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Double64Vector)v, (Double64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Double64Vector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+    Double64Vector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Double64Vector)v1, (Double64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Double64Vector)v1, (Double64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Double64Vector tOp(Vector<Double> v1, Vector<Double> v2,\n+    Double64Vector tOpMF(Vector<Double> v1, Vector<Double> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Double64Vector)v1, (Double64Vector)v2,\n-                              (Double64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Double64Vector)v1, (Double64Vector)v2,\n+                                (Double64Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -513,2 +513,3 @@\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n@@ -532,3 +533,6 @@\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -540,1 +544,1 @@\n-    static final class Double64Mask extends AbstractMask<Double> {\n+    static final value class Double64Mask extends AbstractMask<Double> {\n@@ -544,3 +548,1 @@\n-        Double64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF8Z payload;\n@@ -548,2 +550,2 @@\n-        Double64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF8Z) payload;\n@@ -552,10 +554,2 @@\n-        Double64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -564,4 +558,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -580,14 +572,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Double64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double64Mask(res);\n-        }\n-\n@@ -595,8 +573,2 @@\n-        Double64Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -612,27 +584,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -659,1 +604,1 @@\n-            return (Double64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -672,3 +617,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -682,3 +627,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -692,3 +637,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -703,1 +648,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).trueCountHelper());\n@@ -710,1 +655,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).firstTrueHelper());\n@@ -717,1 +662,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).lastTrueHelper());\n@@ -727,1 +672,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double64Mask) m).toLongHelper());\n@@ -737,1 +682,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Double64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -747,1 +692,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));\n+                                         (m, __) -> ((Double64Mask) m).anyTrueHelper());\n@@ -755,1 +700,1 @@\n-                                         (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));\n+                                         (m, __) -> ((Double64Mask) m).allTrueHelper());\n@@ -772,1 +717,1 @@\n-    static final class Double64Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double64Shuffle extends AbstractShuffle<Double> {\n@@ -776,2 +721,6 @@\n-        Double64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF8B payload;\n+\n+        Double64Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF8B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -780,2 +729,2 @@\n-        public Double64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Double64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -784,2 +733,2 @@\n-        public Double64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Double64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -789,1 +738,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -826,6 +781,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -833,0 +791,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":102,"deletions":143,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -1,912 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class DoubleMaxVector extends DoubleVector {\n-    static final DoubleSpecies VSPECIES =\n-        (DoubleSpecies) DoubleVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<DoubleMaxVector> VCLASS = DoubleMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n-\n-    DoubleMaxVector(double[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as DoubleMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    DoubleMaxVector(Object v) {\n-        this((double[]) v);\n-    }\n-\n-    static final DoubleMaxVector ZERO = new DoubleMaxVector(new double[VLENGTH]);\n-    static final DoubleMaxVector IOTA = new DoubleMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public DoubleSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Double> elementType() { return double.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Double.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxVector broadcast(double e) {\n-        return (DoubleMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxVector broadcast(long e) {\n-        return (DoubleMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxMask maskFromArray(boolean[] bits) {\n-        return new DoubleMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle iotaShuffle() { return DoubleMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    DoubleMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromBytes(byte[] reorder) { return new DoubleMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromArray(int[] indexes, int i) { return new DoubleMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new DoubleMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector vectorFactory(double[] vec) {\n-        return new DoubleMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector uOp(FUnOp f) {\n-        return (DoubleMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector uOp(VectorMask<Double> m, FUnOp f) {\n-        return (DoubleMaxVector)\n-            super.uOpTemplate((DoubleMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector bOp(Vector<Double> v, FBinOp f) {\n-        return (DoubleMaxVector) super.bOpTemplate((DoubleMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector bOp(Vector<Double> v,\n-                     VectorMask<Double> m, FBinOp f) {\n-        return (DoubleMaxVector)\n-            super.bOpTemplate((DoubleMaxVector)v, (DoubleMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n-        return (DoubleMaxVector)\n-            super.tOpTemplate((DoubleMaxVector)v1, (DoubleMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector tOp(Vector<Double> v1, Vector<Double> v2,\n-                     VectorMask<Double> m, FTriOp f) {\n-        return (DoubleMaxVector)\n-            super.tOpTemplate((DoubleMaxVector)v1, (DoubleMaxVector)v2,\n-                              (DoubleMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Double,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector lanewise(Unary op) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector lanewise(Unary op, VectorMask<Double> m) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector lanewise(Binary op, Vector<Double> v) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    DoubleMaxVector\n-    lanewise(Ternary op, Vector<Double> v1, Vector<Double> v2) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    DoubleMaxVector\n-    lanewise(Ternary op, Vector<Double> v1, Vector<Double> v2, VectorMask<Double> m) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v1, v2, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    DoubleMaxVector addIndex(int scale) {\n-        return (DoubleMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final double reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final double reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Double> m) {\n-        return super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Double> m) {\n-        return (long) super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask test(Test op) {\n-        return super.testTemplate(DoubleMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask test(Test op, VectorMask<Double> m) {\n-        return super.testTemplate(DoubleMaxMask.class, op, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask compare(Comparison op, Vector<Double> v) {\n-        return super.compareTemplate(DoubleMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask compare(Comparison op, double s) {\n-        return super.compareTemplate(DoubleMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(DoubleMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask compare(Comparison op, Vector<Double> v, VectorMask<Double> m) {\n-        return super.compareTemplate(DoubleMaxMask.class, op, v, (DoubleMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector blend(Vector<Double> v, VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.blendTemplate(DoubleMaxMask.class,\n-                                (DoubleMaxVector) v,\n-                                (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector slice(int origin, Vector<Double> v) {\n-        return (DoubleMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector slice(int origin) {\n-        return (DoubleMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector unslice(int origin, Vector<Double> w, int part) {\n-        return (DoubleMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector unslice(int origin, Vector<Double> w, int part, VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.unsliceTemplate(DoubleMaxMask.class,\n-                                  origin, w, part,\n-                                  (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector unslice(int origin) {\n-        return (DoubleMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector rearrange(VectorShuffle<Double> s) {\n-        return (DoubleMaxVector)\n-            super.rearrangeTemplate(DoubleMaxShuffle.class,\n-                                    (DoubleMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector rearrange(VectorShuffle<Double> shuffle,\n-                                  VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.rearrangeTemplate(DoubleMaxShuffle.class,\n-                                    DoubleMaxMask.class,\n-                                    (DoubleMaxShuffle) shuffle,\n-                                    (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector rearrange(VectorShuffle<Double> s,\n-                                  Vector<Double> v) {\n-        return (DoubleMaxVector)\n-            super.rearrangeTemplate(DoubleMaxShuffle.class,\n-                                    (DoubleMaxShuffle) s,\n-                                    (DoubleMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector compress(VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.compressTemplate(DoubleMaxMask.class,\n-                                   (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector expand(VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.expandTemplate(DoubleMaxMask.class,\n-                                   (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector selectFrom(Vector<Double> v) {\n-        return (DoubleMaxVector)\n-            super.selectFromTemplate((DoubleMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector selectFrom(Vector<Double> v,\n-                                   VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.selectFromTemplate((DoubleMaxVector) v,\n-                                     (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public double lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        long bits = laneHelper(i);\n-        return Double.longBitsToDouble(bits);\n-    }\n-\n-    public long laneHelper(int i) {\n-        return (long) VectorSupport.extract(\n-                     VCLASS, ETYPE, VLENGTH,\n-                     this, i,\n-                     (vec, ix) -> {\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n-                     });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public DoubleMaxVector withLane(int i, double e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public DoubleMaxVector withLaneHelper(int i, double e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)Double.doubleToLongBits(e),\n-                                (v, ix, bits) -> {\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class DoubleMaxMask extends AbstractMask<Double> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n-\n-        DoubleMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        DoubleMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        DoubleMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public DoubleSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        DoubleMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new DoubleMaxMask(res);\n-        }\n-\n-        @Override\n-        DoubleMaxMask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((DoubleMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new DoubleMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        DoubleMaxVector toVector() {\n-            return (DoubleMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        \/*package-private*\/\n-        DoubleMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n-            return (DoubleMaxMask) VectorSupport.indexPartiallyInUpperRange(\n-                DoubleMaxMask.class, double.class, VLENGTH, offset, limit,\n-                (o, l) -> (DoubleMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask compress() {\n-            return (DoubleMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask and(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            DoubleMaxMask m = (DoubleMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask or(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            DoubleMaxMask m = (DoubleMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask xor(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            DoubleMaxMask m = (DoubleMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ laneIsSet\n-\n-        @Override\n-        @ForceInline\n-        public boolean laneIsSet(int i) {\n-            Objects.checkIndex(i, length());\n-            return VectorSupport.extract(DoubleMaxMask.class, double.class, VLENGTH,\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static DoubleMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final DoubleMaxMask  TRUE_MASK = new DoubleMaxMask(true);\n-        private static final DoubleMaxMask FALSE_MASK = new DoubleMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class DoubleMaxShuffle extends AbstractShuffle<Double> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n-\n-        DoubleMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public DoubleMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public DoubleMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public DoubleMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public DoubleSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final DoubleMaxShuffle IOTA = new DoubleMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((DoubleMaxVector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n-            DoubleMaxShuffle s = (DoubleMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new DoubleMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromArray0(double[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m, int offsetInRange) {\n-        return super.fromArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(double[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(double[] a, int offset, VectorMask<Double> m) {\n-        super.intoArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        super.intoArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n-        super.intoMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":0,"deletions":912,"binary":false,"changes":912,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    DoubleVector(double[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public DoubleVector() {}\n@@ -96,3 +96,0 @@\n-    \/*package-private*\/\n-    abstract double[] vec();\n-\n@@ -103,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -106,1 +103,1 @@\n-    abstract DoubleVector vectorFactory(double[] vec);\n+    abstract DoubleVector vectorFactory(VectorPayloadMF vec);\n@@ -115,2 +112,2 @@\n-    AbstractMask<Double> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Double> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -127,1 +124,1 @@\n-    DoubleVector vOp(FVOp f) {\n+    DoubleVector vOpMF(FVOp f) {\n@@ -132,1 +129,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +135,1 @@\n-    DoubleVector vOp(VectorMask<Double> m, FVOp f) {\n+    DoubleVector vOpMF(VectorMask<Double> m, FVOp f) {\n@@ -139,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -141,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -145,1 +144,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +157,1 @@\n-    DoubleVector uOp(FUnOp f);\n+    DoubleVector uOpMF(FUnOp f);\n@@ -160,5 +160,8 @@\n-    DoubleVector uOpTemplate(FUnOp f) {\n-        double[] vec = vec();\n-        double[] res = new double[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    DoubleVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v));\n@@ -166,1 +169,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +175,1 @@\n-    DoubleVector uOp(VectorMask<Double> m,\n+    DoubleVector uOpMF(VectorMask<Double> m,\n@@ -175,1 +179,1 @@\n-    DoubleVector uOpTemplate(VectorMask<Double> m,\n+    DoubleVector uOpTemplateMF(VectorMask<Double> m,\n@@ -178,1 +182,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,5 +184,10 @@\n-        double[] vec = vec();\n-        double[] res = new double[length()];\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -186,1 +195,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +208,1 @@\n-    DoubleVector bOp(Vector<Double> o,\n+    DoubleVector bOpMF(Vector<Double> o,\n@@ -202,1 +212,1 @@\n-    DoubleVector bOpTemplate(Vector<Double> o,\n+    DoubleVector bOpTemplateMF(Vector<Double> o,\n@@ -204,5 +214,9 @@\n-        double[] res = new double[length()];\n-        double[] vec1 = this.vec();\n-        double[] vec2 = ((DoubleVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +224,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +230,1 @@\n-    DoubleVector bOp(Vector<Double> o,\n+    DoubleVector bOpMF(Vector<Double> o,\n@@ -220,1 +235,1 @@\n-    DoubleVector bOpTemplate(Vector<Double> o,\n+    DoubleVector bOpTemplateMF(Vector<Double> o,\n@@ -224,1 +239,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,6 +241,12 @@\n-        double[] res = new double[length()];\n-        double[] vec1 = this.vec();\n-        double[] vec2 = ((DoubleVector)o).vec();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -233,1 +254,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +267,1 @@\n-    DoubleVector tOp(Vector<Double> o1,\n+    DoubleVector tOpMF(Vector<Double> o1,\n@@ -250,1 +272,1 @@\n-    DoubleVector tOpTemplate(Vector<Double> o1,\n+    DoubleVector tOpTemplateMF(Vector<Double> o1,\n@@ -253,6 +275,11 @@\n-        double[] res = new double[length()];\n-        double[] vec1 = this.vec();\n-        double[] vec2 = ((DoubleVector)o1).vec();\n-        double[] vec3 = ((DoubleVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o1).vec();\n+        VectorPayloadMF vec3 = ((DoubleVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v3 = Unsafe.getUnsafe().getDouble(vec3, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +287,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +293,1 @@\n-    DoubleVector tOp(Vector<Double> o1,\n+    DoubleVector tOpMF(Vector<Double> o1,\n@@ -271,1 +299,1 @@\n-    DoubleVector tOpTemplate(Vector<Double> o1,\n+    DoubleVector tOpTemplateMF(Vector<Double> o1,\n@@ -276,1 +304,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,7 +306,14 @@\n-        double[] res = new double[length()];\n-        double[] vec1 = this.vec();\n-        double[] vec2 = ((DoubleVector)o1).vec();\n-        double[] vec3 = ((DoubleVector)o2).vec();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o1).vec();\n+        VectorPayloadMF vec3 = ((DoubleVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v3 = Unsafe.getUnsafe().getDouble(vec3, vOffset + i * Double.BYTES);\n+            double v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f);\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    double rOpTemplate(double v, VectorMask<Double> m, FBinOp f) {\n+    double rOpTemplateMF(double v, VectorMask<Double> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,4 +337,8 @@\n-        double[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -311,4 +351,7 @@\n-    double rOpTemplate(double v, FBinOp f) {\n-        double[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    double rOpTemplateMF(double v, FBinOp f) {\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +372,1 @@\n-    <M> DoubleVector ldOp(M memory, int offset,\n+    <M> DoubleVector ldOpMF(M memory, int offset,\n@@ -331,4 +374,7 @@\n-        \/\/dummy; no vec = vec();\n-        double[] res = new double[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                double.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +382,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +389,1 @@\n-    <M> DoubleVector ldOp(M memory, int offset,\n+    <M> DoubleVector ldOpMF(M memory, int offset,\n@@ -345,6 +392,10 @@\n-        \/\/double[] vec = vec();\n-        double[] res = new double[length()];\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                double.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +404,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +408,1 @@\n+\n@@ -364,1 +417,1 @@\n-    DoubleVector ldLongOp(MemorySegment memory, long offset,\n+    DoubleVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +419,7 @@\n-        \/\/dummy; no vec = vec();\n-        double[] res = new double[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                double.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +427,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +434,1 @@\n-    DoubleVector ldLongOp(MemorySegment memory, long offset,\n+    DoubleVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,6 +437,10 @@\n-        \/\/double[] vec = vec();\n-        double[] res = new double[length()];\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                double.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +449,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +464,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +466,5 @@\n-        double[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -411,1 +475,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +477,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,5 +480,8 @@\n-        double[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -425,0 +492,1 @@\n+\n@@ -432,1 +500,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +502,5 @@\n-        double[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -443,1 +513,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,5 +516,8 @@\n-        double[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -469,1 +542,1 @@\n-    AbstractMask<Double> bTest(int cond,\n+    AbstractMask<Double> bTestMF(int cond,\n@@ -472,5 +545,11 @@\n-        double[] vec1 = vec();\n-        double[] vec2 = ((DoubleVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        int length = vspecies().length();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -478,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -554,1 +634,1 @@\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                        ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -708,1 +788,1 @@\n-                    v0.uOp(m, (i, a) -> (double) -a);\n+                    v0.uOpMF(m, (i, a) -> (double) -a);\n@@ -710,1 +790,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.abs(a));\n@@ -712,1 +792,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.sin(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.sin(a));\n@@ -714,1 +794,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.cos(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.cos(a));\n@@ -716,1 +796,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.tan(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.tan(a));\n@@ -718,1 +798,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.asin(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.asin(a));\n@@ -720,1 +800,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.acos(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.acos(a));\n@@ -722,1 +802,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.atan(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.atan(a));\n@@ -724,1 +804,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.exp(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.exp(a));\n@@ -726,1 +806,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.log(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.log(a));\n@@ -728,1 +808,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.log10(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.log10(a));\n@@ -730,1 +810,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.sqrt(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.sqrt(a));\n@@ -732,1 +812,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.cbrt(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.cbrt(a));\n@@ -734,1 +814,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.sinh(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.sinh(a));\n@@ -736,1 +816,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.cosh(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.cosh(a));\n@@ -738,1 +818,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.tanh(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.tanh(a));\n@@ -740,1 +820,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.expm1(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.expm1(a));\n@@ -742,1 +822,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.log1p(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.log1p(a));\n@@ -777,1 +857,1 @@\n-            BIN_IMPL.find(op, opc, DoubleVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, DoubleVector::binaryOperationsMF));\n@@ -821,1 +901,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a + b));\n@@ -823,1 +903,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a - b));\n@@ -825,1 +905,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a * b));\n@@ -827,1 +907,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a \/ b));\n@@ -829,1 +909,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.max(a, b));\n@@ -831,1 +911,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.min(a, b));\n@@ -833,1 +913,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -835,1 +915,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.atan2(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.atan2(a, b));\n@@ -837,1 +917,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.pow(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.pow(a, b));\n@@ -839,1 +919,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.hypot(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.hypot(a, b));\n@@ -844,0 +924,27 @@\n+    private static BinaryOperation<DoubleVector, VectorMask<Double>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.min(a, b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.hypot(a, b));\n+            default: return null;\n+        }\n+    }\n+\n+\n@@ -1031,1 +1138,1 @@\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+                    v0.tOpMF(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n@@ -1895,1 +2002,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -1917,1 +2024,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2042,1 +2149,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2249,1 +2356,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2281,1 +2388,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2309,1 +2416,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2317,1 +2424,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2637,1 +2744,1 @@\n-                    toBits(v.rOp((double)0, m, (i, a, b) -> (double)(a + b)));\n+                    toBits(v.rOpMF((double)0, m, (i, a, b) -> (double)(a + b)));\n@@ -2639,1 +2746,1 @@\n-                    toBits(v.rOp((double)1, m, (i, a, b) -> (double)(a * b)));\n+                    toBits(v.rOpMF((double)1, m, (i, a, b) -> (double)(a * b)));\n@@ -2641,1 +2748,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (double) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (double) Math.min(a, b)));\n@@ -2643,1 +2750,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (double) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (double) Math.max(a, b)));\n@@ -2775,1 +2882,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -2806,1 +2913,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -2810,1 +2917,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -2860,1 +2967,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -2869,1 +2976,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -2872,0 +2979,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -2886,1 +2995,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -2936,1 +3045,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -2980,1 +3089,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3038,1 +3147,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3042,1 +3151,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3072,1 +3181,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3074,0 +3183,1 @@\n+\n@@ -3153,1 +3263,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3161,1 +3271,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3164,0 +3274,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3180,1 +3292,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -3303,1 +3415,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3320,1 +3432,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3346,1 +3458,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3355,1 +3467,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3358,0 +3470,2 @@\n+             *\/\n+            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3373,1 +3487,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -3388,1 +3502,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, DoubleVector::memorySegmentGet);\n@@ -3404,1 +3518,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);\n@@ -3423,1 +3537,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3440,1 +3554,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3462,1 +3576,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3470,1 +3584,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3473,0 +3587,3 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n+\n@@ -3490,1 +3607,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -3507,1 +3624,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, DoubleVector::memorySegmentSet);\n@@ -3524,1 +3641,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, DoubleVector::memorySegmentSet);\n@@ -3745,1 +3862,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -3796,1 +3913,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -3811,2 +3928,2 @@\n-        DoubleVector dummyVector() {\n-            return (DoubleVector) super.dummyVector();\n+        DoubleVector dummyVectorMF() {\n+            return (DoubleVector) super.dummyVectorMF();\n@@ -3818,1 +3935,1 @@\n-        DoubleVector rvOp(RVOp f) {\n+        DoubleVector rvOpMF(RVOp f) {\n@@ -3824,1 +3941,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3827,1 +3945,1 @@\n-        DoubleVector vOp(FVOp f) {\n+        DoubleVector vOpMF(FVOp f) {\n@@ -3832,1 +3950,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3835,1 +3954,1 @@\n-        DoubleVector vOp(VectorMask<Double> m, FVOp f) {\n+        DoubleVector vOpMF(VectorMask<Double> m, FVOp f) {\n@@ -3837,1 +3956,2 @@\n-            boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3839,1 +3959,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -3843,1 +3963,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3848,1 +3969,1 @@\n-        <M> DoubleVector ldOp(M memory, int offset,\n+        <M> DoubleVector ldOpMF(M memory, int offset,\n@@ -3850,1 +3971,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -3855,1 +3976,1 @@\n-        <M> DoubleVector ldOp(M memory, int offset,\n+        <M> DoubleVector ldOpMF(M memory, int offset,\n@@ -3858,1 +3979,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -3861,0 +3982,1 @@\n+\n@@ -3863,1 +3985,1 @@\n-        DoubleVector ldLongOp(MemorySegment memory, long offset,\n+        DoubleVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3865,1 +3987,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -3870,1 +3992,1 @@\n-        DoubleVector ldLongOp(MemorySegment memory, long offset,\n+        DoubleVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3873,1 +3995,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -3878,2 +4000,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -3884,2 +4006,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Double> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Double> m,\n@@ -3887,1 +4009,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -3890,0 +4012,1 @@\n+\n@@ -3892,2 +4015,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -3898,1 +4021,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -3901,1 +4024,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -3915,2 +4038,3 @@\n-            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-                return DoubleMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+            \/\/    return DoubleMaxVector.ZERO;\n@@ -3929,2 +4053,3 @@\n-            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-                return DoubleMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+            \/\/    return DoubleMaxVector.IOTA;\n@@ -3944,2 +4069,3 @@\n-            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-                return DoubleMaxVector.DoubleMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+            \/\/    return DoubleMaxVector.DoubleMaxMask.maskAll(bit);\n@@ -3954,0 +4080,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            double [] init = new double[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (double)i;\n+            }\n+           return init;\n+        }\n@@ -3970,1 +4106,2 @@\n-            case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n@@ -4004,1 +4141,2 @@\n-    public static final VectorSpecies<Double> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Double> SPECIES_MAX\n@@ -4009,0 +4147,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":385,"deletions":246,"binary":false,"changes":631,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Float128Vector extends FloatVector {\n+value class Float128Vector extends FloatVector {\n@@ -57,2 +58,6 @@\n-    Float128Vector(float[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128F.class);\n+\n+    private final VectorPayloadMF128F payload;\n+\n+    Float128Vector(Object value) {\n+        this.payload = (VectorPayloadMF128F) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Float128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Float128Vector(Object v) {\n-        this((float[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Float128Vector ZERO = new Float128Vector(new float[VLENGTH]);\n-    static final Float128Vector IOTA = new Float128Vector(VSPECIES.iotaArray());\n+    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.newInstanceFactory(float.class, 4));\n+    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Float128Mask maskFromArray(boolean[] bits) {\n-        return new Float128Mask(bits);\n+    Float128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float128Mask(payload);\n@@ -157,1 +157,1 @@\n-    Float128Shuffle shuffleFromBytes(byte[] reorder) { return new Float128Shuffle(reorder); }\n+    Float128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Float128Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Float128Vector vectorFactory(float[] vec) {\n+    Float128Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Float128Vector uOp(FUnOp f) {\n-        return (Float128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Float128Vector uOpMF(FUnOp f) {\n+        return (Float128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Float128Vector uOp(VectorMask<Float> m, FUnOp f) {\n+    Float128Vector uOpMF(VectorMask<Float> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Float128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Float128Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Float128Vector bOp(Vector<Float> v, FBinOp f) {\n-        return (Float128Vector) super.bOpTemplate((Float128Vector)v, f);  \/\/ specialize\n+    Float128Vector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (Float128Vector) super.bOpTemplateMF((Float128Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Float128Vector bOp(Vector<Float> v,\n+    Float128Vector bOpMF(Vector<Float> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Float128Vector)v, (Float128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Float128Vector)v, (Float128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Float128Vector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+    Float128Vector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Float128Vector)v1, (Float128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Float128Vector)v1, (Float128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Float128Vector tOp(Vector<Float> v1, Vector<Float> v2,\n+    Float128Vector tOpMF(Vector<Float> v1, Vector<Float> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Float128Vector)v1, (Float128Vector)v2,\n-                              (Float128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Float128Vector)v1, (Float128Vector)v2,\n+                                (Float128Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -516,2 +516,3 @@\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n@@ -538,3 +539,6 @@\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -546,1 +550,1 @@\n-    static final class Float128Mask extends AbstractMask<Float> {\n+    static final value class Float128Mask extends AbstractMask<Float> {\n@@ -550,3 +554,1 @@\n-        Float128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -554,2 +556,2 @@\n-        Float128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -558,10 +560,2 @@\n-        Float128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -570,4 +564,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -586,14 +578,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Float128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float128Mask(res);\n-        }\n-\n@@ -601,8 +579,2 @@\n-        Float128Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -618,27 +590,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -665,1 +610,1 @@\n-            return (Float128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -678,3 +623,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -688,3 +633,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -698,3 +643,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -709,1 +654,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).trueCountHelper());\n@@ -716,1 +661,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).firstTrueHelper());\n@@ -723,1 +668,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).lastTrueHelper());\n@@ -733,1 +678,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float128Mask) m).toLongHelper());\n@@ -743,1 +688,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Float128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -753,1 +698,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));\n+                                         (m, __) -> ((Float128Mask) m).anyTrueHelper());\n@@ -761,1 +706,1 @@\n-                                         (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));\n+                                         (m, __) -> ((Float128Mask) m).allTrueHelper());\n@@ -778,1 +723,1 @@\n-    static final class Float128Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float128Shuffle extends AbstractShuffle<Float> {\n@@ -782,2 +727,6 @@\n-        Float128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Float128Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -786,2 +735,2 @@\n-        public Float128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Float128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -790,2 +739,2 @@\n-        public Float128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Float128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -795,1 +744,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -832,6 +787,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -839,0 +797,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":102,"deletions":143,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Float256Vector extends FloatVector {\n+value class Float256Vector extends FloatVector {\n@@ -57,2 +58,6 @@\n-    Float256Vector(float[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256F.class);\n+\n+    private final VectorPayloadMF256F payload;\n+\n+    Float256Vector(Object value) {\n+        this.payload = (VectorPayloadMF256F) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Float256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Float256Vector(Object v) {\n-        this((float[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Float256Vector ZERO = new Float256Vector(new float[VLENGTH]);\n-    static final Float256Vector IOTA = new Float256Vector(VSPECIES.iotaArray());\n+    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.newInstanceFactory(float.class, 8));\n+    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Float256Mask maskFromArray(boolean[] bits) {\n-        return new Float256Mask(bits);\n+    Float256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float256Mask(payload);\n@@ -157,1 +157,1 @@\n-    Float256Shuffle shuffleFromBytes(byte[] reorder) { return new Float256Shuffle(reorder); }\n+    Float256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Float256Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Float256Vector vectorFactory(float[] vec) {\n+    Float256Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Float256Vector uOp(FUnOp f) {\n-        return (Float256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Float256Vector uOpMF(FUnOp f) {\n+        return (Float256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Float256Vector uOp(VectorMask<Float> m, FUnOp f) {\n+    Float256Vector uOpMF(VectorMask<Float> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Float256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Float256Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Float256Vector bOp(Vector<Float> v, FBinOp f) {\n-        return (Float256Vector) super.bOpTemplate((Float256Vector)v, f);  \/\/ specialize\n+    Float256Vector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (Float256Vector) super.bOpTemplateMF((Float256Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Float256Vector bOp(Vector<Float> v,\n+    Float256Vector bOpMF(Vector<Float> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Float256Vector)v, (Float256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Float256Vector)v, (Float256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Float256Vector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+    Float256Vector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Float256Vector)v1, (Float256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Float256Vector)v1, (Float256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Float256Vector tOp(Vector<Float> v1, Vector<Float> v2,\n+    Float256Vector tOpMF(Vector<Float> v1, Vector<Float> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Float256Vector)v1, (Float256Vector)v2,\n-                              (Float256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Float256Vector)v1, (Float256Vector)v2,\n+                                (Float256Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -520,2 +520,3 @@\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n@@ -546,3 +547,6 @@\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -554,1 +558,1 @@\n-    static final class Float256Mask extends AbstractMask<Float> {\n+    static final value class Float256Mask extends AbstractMask<Float> {\n@@ -558,3 +562,1 @@\n-        Float256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -562,2 +564,2 @@\n-        Float256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -566,10 +568,2 @@\n-        Float256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -578,4 +572,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -594,14 +586,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Float256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float256Mask(res);\n-        }\n-\n@@ -609,8 +587,2 @@\n-        Float256Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -626,27 +598,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -673,1 +618,1 @@\n-            return (Float256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -686,3 +631,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -696,3 +641,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -706,3 +651,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -717,1 +662,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).trueCountHelper());\n@@ -724,1 +669,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).firstTrueHelper());\n@@ -731,1 +676,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).lastTrueHelper());\n@@ -741,1 +686,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float256Mask) m).toLongHelper());\n@@ -751,1 +696,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Float256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -761,1 +706,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));\n+                                         (m, __) -> ((Float256Mask) m).anyTrueHelper());\n@@ -769,1 +714,1 @@\n-                                         (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));\n+                                         (m, __) -> ((Float256Mask) m).allTrueHelper());\n@@ -786,1 +731,1 @@\n-    static final class Float256Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float256Shuffle extends AbstractShuffle<Float> {\n@@ -790,2 +735,6 @@\n-        Float256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Float256Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -794,2 +743,2 @@\n-        public Float256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Float256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -798,2 +747,2 @@\n-        public Float256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Float256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -803,1 +752,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -840,6 +795,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -847,0 +805,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":102,"deletions":143,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Float512Vector extends FloatVector {\n+value class Float512Vector extends FloatVector {\n@@ -57,2 +58,6 @@\n-    Float512Vector(float[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512F.class);\n+\n+    private final VectorPayloadMF512F payload;\n+\n+    Float512Vector(Object value) {\n+        this.payload = (VectorPayloadMF512F) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Float512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Float512Vector(Object v) {\n-        this((float[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Float512Vector ZERO = new Float512Vector(new float[VLENGTH]);\n-    static final Float512Vector IOTA = new Float512Vector(VSPECIES.iotaArray());\n+    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.newInstanceFactory(float.class, 16));\n+    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Float512Mask maskFromArray(boolean[] bits) {\n-        return new Float512Mask(bits);\n+    Float512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float512Mask(payload);\n@@ -157,1 +157,1 @@\n-    Float512Shuffle shuffleFromBytes(byte[] reorder) { return new Float512Shuffle(reorder); }\n+    Float512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Float512Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Float512Vector vectorFactory(float[] vec) {\n+    Float512Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Float512Vector uOp(FUnOp f) {\n-        return (Float512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Float512Vector uOpMF(FUnOp f) {\n+        return (Float512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Float512Vector uOp(VectorMask<Float> m, FUnOp f) {\n+    Float512Vector uOpMF(VectorMask<Float> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Float512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Float512Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Float512Vector bOp(Vector<Float> v, FBinOp f) {\n-        return (Float512Vector) super.bOpTemplate((Float512Vector)v, f);  \/\/ specialize\n+    Float512Vector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (Float512Vector) super.bOpTemplateMF((Float512Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Float512Vector bOp(Vector<Float> v,\n+    Float512Vector bOpMF(Vector<Float> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Float512Vector)v, (Float512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Float512Vector)v, (Float512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Float512Vector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+    Float512Vector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Float512Vector)v1, (Float512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Float512Vector)v1, (Float512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Float512Vector tOp(Vector<Float> v1, Vector<Float> v2,\n+    Float512Vector tOpMF(Vector<Float> v1, Vector<Float> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Float512Vector)v1, (Float512Vector)v2,\n-                              (Float512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Float512Vector)v1, (Float512Vector)v2,\n+                                (Float512Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -528,2 +528,3 @@\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n@@ -562,3 +563,6 @@\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -570,1 +574,1 @@\n-    static final class Float512Mask extends AbstractMask<Float> {\n+    static final value class Float512Mask extends AbstractMask<Float> {\n@@ -574,3 +578,1 @@\n-        Float512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -578,2 +580,2 @@\n-        Float512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -582,10 +584,2 @@\n-        Float512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -594,4 +588,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -610,14 +602,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Float512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float512Mask(res);\n-        }\n-\n@@ -625,8 +603,2 @@\n-        Float512Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -642,27 +614,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -689,1 +634,1 @@\n-            return (Float512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -702,3 +647,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -712,3 +657,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -722,3 +667,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -733,1 +678,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).trueCountHelper());\n@@ -740,1 +685,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).firstTrueHelper());\n@@ -747,1 +692,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).lastTrueHelper());\n@@ -757,1 +702,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float512Mask) m).toLongHelper());\n@@ -767,1 +712,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Float512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -777,1 +722,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));\n+                                         (m, __) -> ((Float512Mask) m).anyTrueHelper());\n@@ -785,1 +730,1 @@\n-                                         (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));\n+                                         (m, __) -> ((Float512Mask) m).allTrueHelper());\n@@ -802,1 +747,1 @@\n-    static final class Float512Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float512Shuffle extends AbstractShuffle<Float> {\n@@ -806,2 +751,6 @@\n-        Float512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Float512Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -810,2 +759,2 @@\n-        public Float512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Float512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -814,2 +763,2 @@\n-        public Float512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Float512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -819,1 +768,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -856,6 +811,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -863,0 +821,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":102,"deletions":143,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Float64Vector extends FloatVector {\n+value class Float64Vector extends FloatVector {\n@@ -57,2 +58,6 @@\n-    Float64Vector(float[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64F.class);\n+\n+    private final VectorPayloadMF64F payload;\n+\n+    Float64Vector(Object value) {\n+        this.payload = (VectorPayloadMF64F) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Float64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Float64Vector(Object v) {\n-        this((float[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Float64Vector ZERO = new Float64Vector(new float[VLENGTH]);\n-    static final Float64Vector IOTA = new Float64Vector(VSPECIES.iotaArray());\n+    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.newInstanceFactory(float.class, 2));\n+    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Float64Mask maskFromArray(boolean[] bits) {\n-        return new Float64Mask(bits);\n+    Float64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float64Mask(payload);\n@@ -157,1 +157,1 @@\n-    Float64Shuffle shuffleFromBytes(byte[] reorder) { return new Float64Shuffle(reorder); }\n+    Float64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Float64Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Float64Vector vectorFactory(float[] vec) {\n+    Float64Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Float64Vector uOp(FUnOp f) {\n-        return (Float64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Float64Vector uOpMF(FUnOp f) {\n+        return (Float64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Float64Vector uOp(VectorMask<Float> m, FUnOp f) {\n+    Float64Vector uOpMF(VectorMask<Float> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Float64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Float64Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Float64Vector bOp(Vector<Float> v, FBinOp f) {\n-        return (Float64Vector) super.bOpTemplate((Float64Vector)v, f);  \/\/ specialize\n+    Float64Vector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (Float64Vector) super.bOpTemplateMF((Float64Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Float64Vector bOp(Vector<Float> v,\n+    Float64Vector bOpMF(Vector<Float> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Float64Vector)v, (Float64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Float64Vector)v, (Float64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Float64Vector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+    Float64Vector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Float64Vector)v1, (Float64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Float64Vector)v1, (Float64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Float64Vector tOp(Vector<Float> v1, Vector<Float> v2,\n+    Float64Vector tOpMF(Vector<Float> v1, Vector<Float> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Float64Vector)v1, (Float64Vector)v2,\n-                              (Float64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Float64Vector)v1, (Float64Vector)v2,\n+                                (Float64Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -514,2 +514,3 @@\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n@@ -534,3 +535,6 @@\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -542,1 +546,1 @@\n-    static final class Float64Mask extends AbstractMask<Float> {\n+    static final value class Float64Mask extends AbstractMask<Float> {\n@@ -546,3 +550,1 @@\n-        Float64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -550,2 +552,2 @@\n-        Float64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -554,10 +556,2 @@\n-        Float64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -566,4 +560,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -582,14 +574,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Float64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float64Mask(res);\n-        }\n-\n@@ -597,8 +575,2 @@\n-        Float64Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -614,27 +586,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -661,1 +606,1 @@\n-            return (Float64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -674,3 +619,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -684,3 +629,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -694,3 +639,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -705,1 +650,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).trueCountHelper());\n@@ -712,1 +657,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).firstTrueHelper());\n@@ -719,1 +664,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).lastTrueHelper());\n@@ -729,1 +674,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float64Mask) m).toLongHelper());\n@@ -739,1 +684,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Float64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -749,1 +694,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));\n+                                         (m, __) -> ((Float64Mask) m).anyTrueHelper());\n@@ -757,1 +702,1 @@\n-                                         (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));\n+                                         (m, __) -> ((Float64Mask) m).allTrueHelper());\n@@ -774,1 +719,1 @@\n-    static final class Float64Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float64Shuffle extends AbstractShuffle<Float> {\n@@ -778,2 +723,6 @@\n-        Float64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Float64Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -782,2 +731,2 @@\n-        public Float64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Float64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -786,2 +735,2 @@\n-        public Float64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Float64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -791,1 +740,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -828,6 +783,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -835,0 +793,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":102,"deletions":143,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -1,912 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class FloatMaxVector extends FloatVector {\n-    static final FloatSpecies VSPECIES =\n-        (FloatSpecies) FloatVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<FloatMaxVector> VCLASS = FloatMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n-\n-    FloatMaxVector(float[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as FloatMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    FloatMaxVector(Object v) {\n-        this((float[]) v);\n-    }\n-\n-    static final FloatMaxVector ZERO = new FloatMaxVector(new float[VLENGTH]);\n-    static final FloatMaxVector IOTA = new FloatMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public FloatSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Float> elementType() { return float.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Float.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxVector broadcast(float e) {\n-        return (FloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxVector broadcast(long e) {\n-        return (FloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxMask maskFromArray(boolean[] bits) {\n-        return new FloatMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle iotaShuffle() { return FloatMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    FloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new FloatMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new FloatMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new FloatMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector vectorFactory(float[] vec) {\n-        return new FloatMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector uOp(FUnOp f) {\n-        return (FloatMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector uOp(VectorMask<Float> m, FUnOp f) {\n-        return (FloatMaxVector)\n-            super.uOpTemplate((FloatMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector bOp(Vector<Float> v, FBinOp f) {\n-        return (FloatMaxVector) super.bOpTemplate((FloatMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector bOp(Vector<Float> v,\n-                     VectorMask<Float> m, FBinOp f) {\n-        return (FloatMaxVector)\n-            super.bOpTemplate((FloatMaxVector)v, (FloatMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n-        return (FloatMaxVector)\n-            super.tOpTemplate((FloatMaxVector)v1, (FloatMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector tOp(Vector<Float> v1, Vector<Float> v2,\n-                     VectorMask<Float> m, FTriOp f) {\n-        return (FloatMaxVector)\n-            super.tOpTemplate((FloatMaxVector)v1, (FloatMaxVector)v2,\n-                              (FloatMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Float,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector lanewise(Unary op) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector lanewise(Unary op, VectorMask<Float> m) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector lanewise(Binary op, Vector<Float> v) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    FloatMaxVector\n-    lanewise(Ternary op, Vector<Float> v1, Vector<Float> v2) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    FloatMaxVector\n-    lanewise(Ternary op, Vector<Float> v1, Vector<Float> v2, VectorMask<Float> m) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v1, v2, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    FloatMaxVector addIndex(int scale) {\n-        return (FloatMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final float reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final float reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Float> m) {\n-        return super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Float> m) {\n-        return (long) super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask test(Test op) {\n-        return super.testTemplate(FloatMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask test(Test op, VectorMask<Float> m) {\n-        return super.testTemplate(FloatMaxMask.class, op, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask compare(Comparison op, Vector<Float> v) {\n-        return super.compareTemplate(FloatMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask compare(Comparison op, float s) {\n-        return super.compareTemplate(FloatMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(FloatMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask compare(Comparison op, Vector<Float> v, VectorMask<Float> m) {\n-        return super.compareTemplate(FloatMaxMask.class, op, v, (FloatMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector blend(Vector<Float> v, VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.blendTemplate(FloatMaxMask.class,\n-                                (FloatMaxVector) v,\n-                                (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector slice(int origin, Vector<Float> v) {\n-        return (FloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector slice(int origin) {\n-        return (FloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector unslice(int origin, Vector<Float> w, int part) {\n-        return (FloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector unslice(int origin, Vector<Float> w, int part, VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.unsliceTemplate(FloatMaxMask.class,\n-                                  origin, w, part,\n-                                  (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector unslice(int origin) {\n-        return (FloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector rearrange(VectorShuffle<Float> s) {\n-        return (FloatMaxVector)\n-            super.rearrangeTemplate(FloatMaxShuffle.class,\n-                                    (FloatMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector rearrange(VectorShuffle<Float> shuffle,\n-                                  VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.rearrangeTemplate(FloatMaxShuffle.class,\n-                                    FloatMaxMask.class,\n-                                    (FloatMaxShuffle) shuffle,\n-                                    (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector rearrange(VectorShuffle<Float> s,\n-                                  Vector<Float> v) {\n-        return (FloatMaxVector)\n-            super.rearrangeTemplate(FloatMaxShuffle.class,\n-                                    (FloatMaxShuffle) s,\n-                                    (FloatMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector compress(VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.compressTemplate(FloatMaxMask.class,\n-                                   (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector expand(VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.expandTemplate(FloatMaxMask.class,\n-                                   (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector selectFrom(Vector<Float> v) {\n-        return (FloatMaxVector)\n-            super.selectFromTemplate((FloatMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector selectFrom(Vector<Float> v,\n-                                   VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.selectFromTemplate((FloatMaxVector) v,\n-                                     (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public float lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        int bits = laneHelper(i);\n-        return Float.intBitsToFloat(bits);\n-    }\n-\n-    public int laneHelper(int i) {\n-        return (int) VectorSupport.extract(\n-                     VCLASS, ETYPE, VLENGTH,\n-                     this, i,\n-                     (vec, ix) -> {\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n-                     });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public FloatMaxVector withLane(int i, float e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public FloatMaxVector withLaneHelper(int i, float e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)Float.floatToIntBits(e),\n-                                (v, ix, bits) -> {\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class FloatMaxMask extends AbstractMask<Float> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n-\n-        FloatMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        FloatMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        FloatMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public FloatSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        FloatMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new FloatMaxMask(res);\n-        }\n-\n-        @Override\n-        FloatMaxMask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((FloatMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new FloatMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        FloatMaxVector toVector() {\n-            return (FloatMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        \/*package-private*\/\n-        FloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n-            return (FloatMaxMask) VectorSupport.indexPartiallyInUpperRange(\n-                FloatMaxMask.class, float.class, VLENGTH, offset, limit,\n-                (o, l) -> (FloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask compress() {\n-            return (FloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask and(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            FloatMaxMask m = (FloatMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask or(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            FloatMaxMask m = (FloatMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask xor(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            FloatMaxMask m = (FloatMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ laneIsSet\n-\n-        @Override\n-        @ForceInline\n-        public boolean laneIsSet(int i) {\n-            Objects.checkIndex(i, length());\n-            return VectorSupport.extract(FloatMaxMask.class, float.class, VLENGTH,\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static FloatMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final FloatMaxMask  TRUE_MASK = new FloatMaxMask(true);\n-        private static final FloatMaxMask FALSE_MASK = new FloatMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class FloatMaxShuffle extends AbstractShuffle<Float> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n-\n-        FloatMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public FloatMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public FloatMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public FloatMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public FloatSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final FloatMaxShuffle IOTA = new FloatMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((FloatMaxVector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n-            FloatMaxShuffle s = (FloatMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new FloatMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromArray0(float[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m, int offsetInRange) {\n-        return super.fromArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(float[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(float[] a, int offset, VectorMask<Float> m) {\n-        super.intoArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        super.intoArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n-        super.intoMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":0,"deletions":912,"binary":false,"changes":912,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    FloatVector(float[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public FloatVector() {}\n@@ -96,3 +96,0 @@\n-    \/*package-private*\/\n-    abstract float[] vec();\n-\n@@ -103,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -106,1 +103,1 @@\n-    abstract FloatVector vectorFactory(float[] vec);\n+    abstract FloatVector vectorFactory(VectorPayloadMF vec);\n@@ -115,2 +112,2 @@\n-    AbstractMask<Float> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Float> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -127,1 +124,1 @@\n-    FloatVector vOp(FVOp f) {\n+    FloatVector vOpMF(FVOp f) {\n@@ -132,1 +129,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +135,1 @@\n-    FloatVector vOp(VectorMask<Float> m, FVOp f) {\n+    FloatVector vOpMF(VectorMask<Float> m, FVOp f) {\n@@ -139,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -141,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -145,1 +144,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +157,1 @@\n-    FloatVector uOp(FUnOp f);\n+    FloatVector uOpMF(FUnOp f);\n@@ -160,5 +160,8 @@\n-    FloatVector uOpTemplate(FUnOp f) {\n-        float[] vec = vec();\n-        float[] res = new float[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    FloatVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v));\n@@ -166,1 +169,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +175,1 @@\n-    FloatVector uOp(VectorMask<Float> m,\n+    FloatVector uOpMF(VectorMask<Float> m,\n@@ -175,1 +179,1 @@\n-    FloatVector uOpTemplate(VectorMask<Float> m,\n+    FloatVector uOpTemplateMF(VectorMask<Float> m,\n@@ -178,1 +182,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,5 +184,10 @@\n-        float[] vec = vec();\n-        float[] res = new float[length()];\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -186,1 +195,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +208,1 @@\n-    FloatVector bOp(Vector<Float> o,\n+    FloatVector bOpMF(Vector<Float> o,\n@@ -202,1 +212,1 @@\n-    FloatVector bOpTemplate(Vector<Float> o,\n+    FloatVector bOpTemplateMF(Vector<Float> o,\n@@ -204,5 +214,9 @@\n-        float[] res = new float[length()];\n-        float[] vec1 = this.vec();\n-        float[] vec2 = ((FloatVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +224,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +230,1 @@\n-    FloatVector bOp(Vector<Float> o,\n+    FloatVector bOpMF(Vector<Float> o,\n@@ -220,1 +235,1 @@\n-    FloatVector bOpTemplate(Vector<Float> o,\n+    FloatVector bOpTemplateMF(Vector<Float> o,\n@@ -224,1 +239,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,6 +241,12 @@\n-        float[] res = new float[length()];\n-        float[] vec1 = this.vec();\n-        float[] vec2 = ((FloatVector)o).vec();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -233,1 +254,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +267,1 @@\n-    FloatVector tOp(Vector<Float> o1,\n+    FloatVector tOpMF(Vector<Float> o1,\n@@ -250,1 +272,1 @@\n-    FloatVector tOpTemplate(Vector<Float> o1,\n+    FloatVector tOpTemplateMF(Vector<Float> o1,\n@@ -253,6 +275,11 @@\n-        float[] res = new float[length()];\n-        float[] vec1 = this.vec();\n-        float[] vec2 = ((FloatVector)o1).vec();\n-        float[] vec3 = ((FloatVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o1).vec();\n+        VectorPayloadMF vec3 = ((FloatVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v3 = Unsafe.getUnsafe().getFloat(vec3, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +287,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +293,1 @@\n-    FloatVector tOp(Vector<Float> o1,\n+    FloatVector tOpMF(Vector<Float> o1,\n@@ -271,1 +299,1 @@\n-    FloatVector tOpTemplate(Vector<Float> o1,\n+    FloatVector tOpTemplateMF(Vector<Float> o1,\n@@ -276,1 +304,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,7 +306,14 @@\n-        float[] res = new float[length()];\n-        float[] vec1 = this.vec();\n-        float[] vec2 = ((FloatVector)o1).vec();\n-        float[] vec3 = ((FloatVector)o2).vec();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o1).vec();\n+        VectorPayloadMF vec3 = ((FloatVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v3 = Unsafe.getUnsafe().getFloat(vec3, vOffset + i * Float.BYTES);\n+            float v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f);\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    float rOpTemplate(float v, VectorMask<Float> m, FBinOp f) {\n+    float rOpTemplateMF(float v, VectorMask<Float> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,4 +337,8 @@\n-        float[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -311,4 +351,7 @@\n-    float rOpTemplate(float v, FBinOp f) {\n-        float[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    float rOpTemplateMF(float v, FBinOp f) {\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +372,1 @@\n-    <M> FloatVector ldOp(M memory, int offset,\n+    <M> FloatVector ldOpMF(M memory, int offset,\n@@ -331,4 +374,7 @@\n-        \/\/dummy; no vec = vec();\n-        float[] res = new float[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                float.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +382,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +389,1 @@\n-    <M> FloatVector ldOp(M memory, int offset,\n+    <M> FloatVector ldOpMF(M memory, int offset,\n@@ -345,6 +392,10 @@\n-        \/\/float[] vec = vec();\n-        float[] res = new float[length()];\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                float.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +404,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +408,1 @@\n+\n@@ -364,1 +417,1 @@\n-    FloatVector ldLongOp(MemorySegment memory, long offset,\n+    FloatVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +419,7 @@\n-        \/\/dummy; no vec = vec();\n-        float[] res = new float[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                float.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +427,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +434,1 @@\n-    FloatVector ldLongOp(MemorySegment memory, long offset,\n+    FloatVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,6 +437,10 @@\n-        \/\/float[] vec = vec();\n-        float[] res = new float[length()];\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                float.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +449,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +464,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +466,5 @@\n-        float[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -411,1 +475,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +477,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,5 +480,8 @@\n-        float[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -425,0 +492,1 @@\n+\n@@ -432,1 +500,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +502,5 @@\n-        float[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -443,1 +513,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,5 +516,8 @@\n-        float[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -469,1 +542,1 @@\n-    AbstractMask<Float> bTest(int cond,\n+    AbstractMask<Float> bTestMF(int cond,\n@@ -472,5 +545,11 @@\n-        float[] vec1 = vec();\n-        float[] vec2 = ((FloatVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        int length = vspecies().length();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -478,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -554,1 +634,1 @@\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                        ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -708,1 +788,1 @@\n-                    v0.uOp(m, (i, a) -> (float) -a);\n+                    v0.uOpMF(m, (i, a) -> (float) -a);\n@@ -710,1 +790,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.abs(a));\n@@ -712,1 +792,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.sin(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.sin(a));\n@@ -714,1 +794,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.cos(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.cos(a));\n@@ -716,1 +796,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.tan(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.tan(a));\n@@ -718,1 +798,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.asin(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.asin(a));\n@@ -720,1 +800,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.acos(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.acos(a));\n@@ -722,1 +802,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.atan(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.atan(a));\n@@ -724,1 +804,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.exp(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.exp(a));\n@@ -726,1 +806,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.log(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.log(a));\n@@ -728,1 +808,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.log10(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.log10(a));\n@@ -730,1 +810,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.sqrt(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.sqrt(a));\n@@ -732,1 +812,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.cbrt(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.cbrt(a));\n@@ -734,1 +814,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.sinh(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.sinh(a));\n@@ -736,1 +816,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.cosh(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.cosh(a));\n@@ -738,1 +818,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.tanh(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.tanh(a));\n@@ -740,1 +820,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.expm1(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.expm1(a));\n@@ -742,1 +822,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.log1p(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.log1p(a));\n@@ -777,1 +857,1 @@\n-            BIN_IMPL.find(op, opc, FloatVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, FloatVector::binaryOperationsMF));\n@@ -821,1 +901,27 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.min(a, b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.hypot(a, b));\n+            default: return null;\n+        }\n+    }\n+\n+    private static BinaryOperation<FloatVector, VectorMask<Float>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a + b));\n@@ -823,1 +929,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a - b));\n@@ -825,1 +931,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a * b));\n@@ -827,1 +933,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a \/ b));\n@@ -829,1 +935,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.max(a, b));\n@@ -831,1 +937,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.min(a, b));\n@@ -833,1 +939,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -835,1 +941,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.atan2(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.atan2(a, b));\n@@ -837,1 +943,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.pow(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.pow(a, b));\n@@ -839,1 +945,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.hypot(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.hypot(a, b));\n@@ -844,0 +950,1 @@\n+\n@@ -1031,1 +1138,1 @@\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+                    v0.tOpMF(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n@@ -1907,1 +2014,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -1929,1 +2036,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2054,1 +2161,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2261,1 +2368,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2293,1 +2400,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2321,1 +2428,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2329,1 +2436,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2657,1 +2764,1 @@\n-                    toBits(v.rOp((float)0, m, (i, a, b) -> (float)(a + b)));\n+                    toBits(v.rOpMF((float)0, m, (i, a, b) -> (float)(a + b)));\n@@ -2659,1 +2766,1 @@\n-                    toBits(v.rOp((float)1, m, (i, a, b) -> (float)(a * b)));\n+                    toBits(v.rOpMF((float)1, m, (i, a, b) -> (float)(a * b)));\n@@ -2661,1 +2768,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (float) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (float) Math.min(a, b)));\n@@ -2663,1 +2770,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (float) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (float) Math.max(a, b)));\n@@ -2799,1 +2906,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -2830,1 +2937,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -2834,1 +2941,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -2892,1 +2999,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -2942,1 +3049,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -2986,1 +3093,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3044,1 +3151,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3048,1 +3155,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3078,1 +3185,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3080,0 +3187,1 @@\n+\n@@ -3167,1 +3275,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -3290,1 +3398,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3307,1 +3415,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3342,1 +3450,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -3357,1 +3465,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, FloatVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, FloatVector::memorySegmentGet);\n@@ -3373,1 +3481,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);\n@@ -3392,1 +3500,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3409,1 +3517,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3440,1 +3548,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -3457,1 +3565,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, FloatVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, FloatVector::memorySegmentSet);\n@@ -3474,1 +3582,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, FloatVector::memorySegmentSet);\n@@ -3695,1 +3803,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -3746,1 +3854,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -3761,2 +3869,2 @@\n-        FloatVector dummyVector() {\n-            return (FloatVector) super.dummyVector();\n+        FloatVector dummyVectorMF() {\n+            return (FloatVector) super.dummyVectorMF();\n@@ -3768,1 +3876,1 @@\n-        FloatVector rvOp(RVOp f) {\n+        FloatVector rvOpMF(RVOp f) {\n@@ -3774,1 +3882,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3777,1 +3886,1 @@\n-        FloatVector vOp(FVOp f) {\n+        FloatVector vOpMF(FVOp f) {\n@@ -3782,1 +3891,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3785,1 +3895,1 @@\n-        FloatVector vOp(VectorMask<Float> m, FVOp f) {\n+        FloatVector vOpMF(VectorMask<Float> m, FVOp f) {\n@@ -3787,1 +3897,2 @@\n-            boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3789,1 +3900,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -3793,1 +3904,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3798,1 +3910,1 @@\n-        <M> FloatVector ldOp(M memory, int offset,\n+        <M> FloatVector ldOpMF(M memory, int offset,\n@@ -3800,1 +3912,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -3805,1 +3917,1 @@\n-        <M> FloatVector ldOp(M memory, int offset,\n+        <M> FloatVector ldOpMF(M memory, int offset,\n@@ -3808,1 +3920,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -3811,0 +3923,1 @@\n+\n@@ -3813,1 +3926,1 @@\n-        FloatVector ldLongOp(MemorySegment memory, long offset,\n+        FloatVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3815,1 +3928,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -3820,1 +3933,1 @@\n-        FloatVector ldLongOp(MemorySegment memory, long offset,\n+        FloatVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3823,1 +3936,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -3828,2 +3941,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -3834,2 +3947,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Float> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Float> m,\n@@ -3837,1 +3950,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -3840,0 +3953,1 @@\n+\n@@ -3842,2 +3956,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -3848,1 +3962,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -3851,1 +3965,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -3865,2 +3979,3 @@\n-            if ((Class<?>) vectorType() == FloatMaxVector.class)\n-                return FloatMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n+            \/\/    return FloatMaxVector.ZERO;\n@@ -3879,2 +3994,3 @@\n-            if ((Class<?>) vectorType() == FloatMaxVector.class)\n-                return FloatMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n+            \/\/    return FloatMaxVector.IOTA;\n@@ -3894,2 +4010,3 @@\n-            if ((Class<?>) vectorType() == FloatMaxVector.class)\n-                return FloatMaxVector.FloatMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n+            \/\/    return FloatMaxVector.FloatMaxMask.maskAll(bit);\n@@ -3904,0 +4021,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            float [] init = new float[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (float)i;\n+            }\n+           return init;\n+        }\n@@ -3920,1 +4047,2 @@\n-            case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n@@ -3954,1 +4082,2 @@\n-    public static final VectorSpecies<Float> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Float> SPECIES_MAX\n@@ -3959,0 +4088,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":368,"deletions":238,"binary":false,"changes":606,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Int128Vector extends IntVector {\n+value class Int128Vector extends IntVector {\n@@ -57,2 +58,6 @@\n-    Int128Vector(int[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128I.class);\n+\n+    private final VectorPayloadMF128I payload;\n+\n+    Int128Vector(Object value) {\n+        this.payload = (VectorPayloadMF128I) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Int128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Int128Vector(Object v) {\n-        this((int[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Int128Vector ZERO = new Int128Vector(new int[VLENGTH]);\n-    static final Int128Vector IOTA = new Int128Vector(VSPECIES.iotaArray());\n+    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.newInstanceFactory(int.class, 4));\n+    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Int128Mask maskFromArray(boolean[] bits) {\n-        return new Int128Mask(bits);\n+    Int128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int128Mask(payload);\n@@ -157,1 +157,1 @@\n-    Int128Shuffle shuffleFromBytes(byte[] reorder) { return new Int128Shuffle(reorder); }\n+    Int128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Int128Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Int128Vector vectorFactory(int[] vec) {\n+    Int128Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Int128Vector uOp(FUnOp f) {\n-        return (Int128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Int128Vector uOpMF(FUnOp f) {\n+        return (Int128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Int128Vector uOp(VectorMask<Integer> m, FUnOp f) {\n+    Int128Vector uOpMF(VectorMask<Integer> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Int128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Int128Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Int128Vector bOp(Vector<Integer> v, FBinOp f) {\n-        return (Int128Vector) super.bOpTemplate((Int128Vector)v, f);  \/\/ specialize\n+    Int128Vector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (Int128Vector) super.bOpTemplateMF((Int128Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Int128Vector bOp(Vector<Integer> v,\n+    Int128Vector bOpMF(Vector<Integer> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Int128Vector)v, (Int128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Int128Vector)v, (Int128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Int128Vector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+    Int128Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Int128Vector)v1, (Int128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Int128Vector)v1, (Int128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Int128Vector tOp(Vector<Integer> v1, Vector<Integer> v2,\n+    Int128Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Int128Vector)v1, (Int128Vector)v2,\n-                              (Int128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Int128Vector)v1, (Int128Vector)v2,\n+                                (Int128Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -524,6 +524,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n@@ -545,1 +546,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -549,3 +550,6 @@\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -557,1 +561,1 @@\n-    static final class Int128Mask extends AbstractMask<Integer> {\n+    static final value class Int128Mask extends AbstractMask<Integer> {\n@@ -561,3 +565,1 @@\n-        Int128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -565,2 +567,2 @@\n-        Int128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -569,2 +571,2 @@\n-        Int128Mask(boolean val) {\n-            super(prepare(val));\n+        Int128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -573,12 +575,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -597,4 +589,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -602,18 +590,2 @@\n-        Int128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int128Mask(res);\n-        }\n-\n-        @Override\n-        Int128Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -629,27 +601,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -676,1 +621,1 @@\n-            return (Int128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -689,3 +634,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -699,3 +644,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -709,3 +654,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -720,1 +665,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).trueCountHelper());\n@@ -727,1 +672,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).firstTrueHelper());\n@@ -734,1 +679,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).lastTrueHelper());\n@@ -744,1 +689,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int128Mask) m).toLongHelper());\n@@ -754,1 +699,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Int128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -764,1 +709,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));\n+                                         (m, __) -> ((Int128Mask) m).anyTrueHelper());\n@@ -772,1 +717,1 @@\n-                                         (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));\n+                                         (m, __) -> ((Int128Mask) m).allTrueHelper());\n@@ -789,1 +734,1 @@\n-    static final class Int128Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int128Shuffle extends AbstractShuffle<Integer> {\n@@ -793,2 +738,6 @@\n-        Int128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Int128Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -797,2 +746,2 @@\n-        public Int128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Int128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -801,2 +750,2 @@\n-        public Int128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Int128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -806,1 +755,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -843,6 +798,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -850,0 +808,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Int256Vector extends IntVector {\n+value class Int256Vector extends IntVector {\n@@ -57,2 +58,6 @@\n-    Int256Vector(int[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256I.class);\n+\n+    private final VectorPayloadMF256I payload;\n+\n+    Int256Vector(Object value) {\n+        this.payload = (VectorPayloadMF256I) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Int256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Int256Vector(Object v) {\n-        this((int[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Int256Vector ZERO = new Int256Vector(new int[VLENGTH]);\n-    static final Int256Vector IOTA = new Int256Vector(VSPECIES.iotaArray());\n+    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.newInstanceFactory(int.class, 8));\n+    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Int256Mask maskFromArray(boolean[] bits) {\n-        return new Int256Mask(bits);\n+    Int256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int256Mask(payload);\n@@ -157,1 +157,1 @@\n-    Int256Shuffle shuffleFromBytes(byte[] reorder) { return new Int256Shuffle(reorder); }\n+    Int256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Int256Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Int256Vector vectorFactory(int[] vec) {\n+    Int256Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Int256Vector uOp(FUnOp f) {\n-        return (Int256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Int256Vector uOpMF(FUnOp f) {\n+        return (Int256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Int256Vector uOp(VectorMask<Integer> m, FUnOp f) {\n+    Int256Vector uOpMF(VectorMask<Integer> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Int256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Int256Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Int256Vector bOp(Vector<Integer> v, FBinOp f) {\n-        return (Int256Vector) super.bOpTemplate((Int256Vector)v, f);  \/\/ specialize\n+    Int256Vector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (Int256Vector) super.bOpTemplateMF((Int256Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Int256Vector bOp(Vector<Integer> v,\n+    Int256Vector bOpMF(Vector<Integer> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Int256Vector)v, (Int256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Int256Vector)v, (Int256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Int256Vector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+    Int256Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Int256Vector)v1, (Int256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Int256Vector)v1, (Int256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Int256Vector tOp(Vector<Integer> v1, Vector<Integer> v2,\n+    Int256Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Int256Vector)v1, (Int256Vector)v2,\n-                              (Int256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Int256Vector)v1, (Int256Vector)v2,\n+                                (Int256Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -528,6 +528,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n@@ -553,1 +554,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -557,3 +558,6 @@\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -565,1 +569,1 @@\n-    static final class Int256Mask extends AbstractMask<Integer> {\n+    static final value class Int256Mask extends AbstractMask<Integer> {\n@@ -569,3 +573,1 @@\n-        Int256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -573,2 +575,2 @@\n-        Int256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -577,2 +579,2 @@\n-        Int256Mask(boolean val) {\n-            super(prepare(val));\n+        Int256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -581,12 +583,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -605,4 +597,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -610,18 +598,2 @@\n-        Int256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int256Mask(res);\n-        }\n-\n-        @Override\n-        Int256Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -637,27 +609,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -684,1 +629,1 @@\n-            return (Int256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -697,3 +642,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -707,3 +652,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -717,3 +662,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -728,1 +673,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).trueCountHelper());\n@@ -735,1 +680,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).firstTrueHelper());\n@@ -742,1 +687,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).lastTrueHelper());\n@@ -752,1 +697,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int256Mask) m).toLongHelper());\n@@ -762,1 +707,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Int256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -772,1 +717,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));\n+                                         (m, __) -> ((Int256Mask) m).anyTrueHelper());\n@@ -780,1 +725,1 @@\n-                                         (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));\n+                                         (m, __) -> ((Int256Mask) m).allTrueHelper());\n@@ -797,1 +742,1 @@\n-    static final class Int256Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int256Shuffle extends AbstractShuffle<Integer> {\n@@ -801,2 +746,6 @@\n-        Int256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Int256Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -805,2 +754,2 @@\n-        public Int256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Int256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -809,2 +758,2 @@\n-        public Int256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Int256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -814,1 +763,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -851,6 +806,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -858,0 +816,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Int512Vector extends IntVector {\n+value class Int512Vector extends IntVector {\n@@ -57,2 +58,6 @@\n-    Int512Vector(int[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512I.class);\n+\n+    private final VectorPayloadMF512I payload;\n+\n+    Int512Vector(Object value) {\n+        this.payload = (VectorPayloadMF512I) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Int512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Int512Vector(Object v) {\n-        this((int[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Int512Vector ZERO = new Int512Vector(new int[VLENGTH]);\n-    static final Int512Vector IOTA = new Int512Vector(VSPECIES.iotaArray());\n+    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.newInstanceFactory(int.class, 16));\n+    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Int512Mask maskFromArray(boolean[] bits) {\n-        return new Int512Mask(bits);\n+    Int512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int512Mask(payload);\n@@ -157,1 +157,1 @@\n-    Int512Shuffle shuffleFromBytes(byte[] reorder) { return new Int512Shuffle(reorder); }\n+    Int512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Int512Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Int512Vector vectorFactory(int[] vec) {\n+    Int512Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Int512Vector uOp(FUnOp f) {\n-        return (Int512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Int512Vector uOpMF(FUnOp f) {\n+        return (Int512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Int512Vector uOp(VectorMask<Integer> m, FUnOp f) {\n+    Int512Vector uOpMF(VectorMask<Integer> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Int512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Int512Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Int512Vector bOp(Vector<Integer> v, FBinOp f) {\n-        return (Int512Vector) super.bOpTemplate((Int512Vector)v, f);  \/\/ specialize\n+    Int512Vector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (Int512Vector) super.bOpTemplateMF((Int512Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Int512Vector bOp(Vector<Integer> v,\n+    Int512Vector bOpMF(Vector<Integer> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Int512Vector)v, (Int512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Int512Vector)v, (Int512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Int512Vector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+    Int512Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Int512Vector)v1, (Int512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Int512Vector)v1, (Int512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Int512Vector tOp(Vector<Integer> v1, Vector<Integer> v2,\n+    Int512Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Int512Vector)v1, (Int512Vector)v2,\n-                              (Int512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Int512Vector)v1, (Int512Vector)v2,\n+                                (Int512Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -536,6 +536,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n@@ -569,1 +570,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -573,3 +574,6 @@\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -581,1 +585,1 @@\n-    static final class Int512Mask extends AbstractMask<Integer> {\n+    static final value class Int512Mask extends AbstractMask<Integer> {\n@@ -585,3 +589,1 @@\n-        Int512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -589,2 +591,2 @@\n-        Int512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -593,2 +595,2 @@\n-        Int512Mask(boolean val) {\n-            super(prepare(val));\n+        Int512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -597,12 +599,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -621,4 +613,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -626,18 +614,2 @@\n-        Int512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int512Mask(res);\n-        }\n-\n-        @Override\n-        Int512Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -653,27 +625,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -700,1 +645,1 @@\n-            return (Int512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -713,3 +658,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -723,3 +668,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -733,3 +678,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -744,1 +689,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).trueCountHelper());\n@@ -751,1 +696,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).firstTrueHelper());\n@@ -758,1 +703,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).lastTrueHelper());\n@@ -768,1 +713,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int512Mask) m).toLongHelper());\n@@ -778,1 +723,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Int512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -788,1 +733,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));\n+                                         (m, __) -> ((Int512Mask) m).anyTrueHelper());\n@@ -796,1 +741,1 @@\n-                                         (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));\n+                                         (m, __) -> ((Int512Mask) m).allTrueHelper());\n@@ -813,1 +758,1 @@\n-    static final class Int512Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int512Shuffle extends AbstractShuffle<Integer> {\n@@ -817,2 +762,6 @@\n-        Int512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Int512Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -821,2 +770,2 @@\n-        public Int512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Int512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -825,2 +774,2 @@\n-        public Int512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Int512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -830,1 +779,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -867,6 +822,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -874,0 +832,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Int64Vector extends IntVector {\n+value class Int64Vector extends IntVector {\n@@ -57,2 +58,6 @@\n-    Int64Vector(int[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64I.class);\n+\n+    private final VectorPayloadMF64I payload;\n+\n+    Int64Vector(Object value) {\n+        this.payload = (VectorPayloadMF64I) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Int64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Int64Vector(Object v) {\n-        this((int[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Int64Vector ZERO = new Int64Vector(new int[VLENGTH]);\n-    static final Int64Vector IOTA = new Int64Vector(VSPECIES.iotaArray());\n+    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.newInstanceFactory(int.class, 2));\n+    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Int64Mask maskFromArray(boolean[] bits) {\n-        return new Int64Mask(bits);\n+    Int64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int64Mask(payload);\n@@ -157,1 +157,1 @@\n-    Int64Shuffle shuffleFromBytes(byte[] reorder) { return new Int64Shuffle(reorder); }\n+    Int64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Int64Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Int64Vector vectorFactory(int[] vec) {\n+    Int64Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Int64Vector uOp(FUnOp f) {\n-        return (Int64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Int64Vector uOpMF(FUnOp f) {\n+        return (Int64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Int64Vector uOp(VectorMask<Integer> m, FUnOp f) {\n+    Int64Vector uOpMF(VectorMask<Integer> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Int64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Int64Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Int64Vector bOp(Vector<Integer> v, FBinOp f) {\n-        return (Int64Vector) super.bOpTemplate((Int64Vector)v, f);  \/\/ specialize\n+    Int64Vector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (Int64Vector) super.bOpTemplateMF((Int64Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Int64Vector bOp(Vector<Integer> v,\n+    Int64Vector bOpMF(Vector<Integer> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Int64Vector)v, (Int64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Int64Vector)v, (Int64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Int64Vector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+    Int64Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Int64Vector)v1, (Int64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Int64Vector)v1, (Int64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Int64Vector tOp(Vector<Integer> v1, Vector<Integer> v2,\n+    Int64Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Int64Vector)v1, (Int64Vector)v2,\n-                              (Int64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Int64Vector)v1, (Int64Vector)v2,\n+                                (Int64Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -522,6 +522,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n@@ -541,1 +542,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -545,3 +546,6 @@\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -553,1 +557,1 @@\n-    static final class Int64Mask extends AbstractMask<Integer> {\n+    static final value class Int64Mask extends AbstractMask<Integer> {\n@@ -557,3 +561,1 @@\n-        Int64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -561,2 +563,2 @@\n-        Int64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -565,2 +567,2 @@\n-        Int64Mask(boolean val) {\n-            super(prepare(val));\n+        Int64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -569,12 +571,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -593,4 +585,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -598,18 +586,2 @@\n-        Int64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int64Mask(res);\n-        }\n-\n-        @Override\n-        Int64Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -625,27 +597,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -672,1 +617,1 @@\n-            return (Int64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -685,3 +630,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -695,3 +640,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -705,3 +650,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -716,1 +661,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).trueCountHelper());\n@@ -723,1 +668,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).firstTrueHelper());\n@@ -730,1 +675,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).lastTrueHelper());\n@@ -740,1 +685,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int64Mask) m).toLongHelper());\n@@ -750,1 +695,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Int64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -760,1 +705,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));\n+                                         (m, __) -> ((Int64Mask) m).anyTrueHelper());\n@@ -768,1 +713,1 @@\n-                                         (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));\n+                                         (m, __) -> ((Int64Mask) m).allTrueHelper());\n@@ -785,1 +730,1 @@\n-    static final class Int64Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int64Shuffle extends AbstractShuffle<Integer> {\n@@ -789,2 +734,6 @@\n-        Int64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Int64Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -793,2 +742,2 @@\n-        public Int64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Int64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -797,2 +746,2 @@\n-        public Int64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Int64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -802,1 +751,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -839,6 +794,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -846,0 +804,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -1,935 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class IntMaxVector extends IntVector {\n-    static final IntSpecies VSPECIES =\n-        (IntSpecies) IntVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<IntMaxVector> VCLASS = IntMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n-\n-    IntMaxVector(int[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as IntMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    IntMaxVector(Object v) {\n-        this((int[]) v);\n-    }\n-\n-    static final IntMaxVector ZERO = new IntMaxVector(new int[VLENGTH]);\n-    static final IntMaxVector IOTA = new IntMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public IntSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Integer> elementType() { return int.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Integer.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxVector broadcast(int e) {\n-        return (IntMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxVector broadcast(long e) {\n-        return (IntMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxMask maskFromArray(boolean[] bits) {\n-        return new IntMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle iotaShuffle() { return IntMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    IntMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromBytes(byte[] reorder) { return new IntMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromArray(int[] indexes, int i) { return new IntMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new IntMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    IntMaxVector vectorFactory(int[] vec) {\n-        return new IntMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector uOp(FUnOp f) {\n-        return (IntMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector uOp(VectorMask<Integer> m, FUnOp f) {\n-        return (IntMaxVector)\n-            super.uOpTemplate((IntMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector bOp(Vector<Integer> v, FBinOp f) {\n-        return (IntMaxVector) super.bOpTemplate((IntMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector bOp(Vector<Integer> v,\n-                     VectorMask<Integer> m, FBinOp f) {\n-        return (IntMaxVector)\n-            super.bOpTemplate((IntMaxVector)v, (IntMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n-        return (IntMaxVector)\n-            super.tOpTemplate((IntMaxVector)v1, (IntMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector tOp(Vector<Integer> v1, Vector<Integer> v2,\n-                     VectorMask<Integer> m, FTriOp f) {\n-        return (IntMaxVector)\n-            super.tOpTemplate((IntMaxVector)v1, (IntMaxVector)v2,\n-                              (IntMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Integer,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector lanewise(Unary op) {\n-        return (IntMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector lanewise(Unary op, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector lanewise(Binary op, Vector<Integer> v) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline IntMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e) {\n-        return (IntMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline IntMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseShiftTemplate(op, IntMaxMask.class, e, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    IntMaxVector\n-    lanewise(Ternary op, Vector<Integer> v1, Vector<Integer> v2) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    IntMaxVector\n-    lanewise(Ternary op, Vector<Integer> v1, Vector<Integer> v2, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v1, v2, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    IntMaxVector addIndex(int scale) {\n-        return (IntMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final int reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final int reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Integer> m) {\n-        return super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Integer> m) {\n-        return (long) super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask test(Test op) {\n-        return super.testTemplate(IntMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask test(Test op, VectorMask<Integer> m) {\n-        return super.testTemplate(IntMaxMask.class, op, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask compare(Comparison op, Vector<Integer> v) {\n-        return super.compareTemplate(IntMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask compare(Comparison op, int s) {\n-        return super.compareTemplate(IntMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(IntMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask compare(Comparison op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return super.compareTemplate(IntMaxMask.class, op, v, (IntMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector blend(Vector<Integer> v, VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.blendTemplate(IntMaxMask.class,\n-                                (IntMaxVector) v,\n-                                (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector slice(int origin, Vector<Integer> v) {\n-        return (IntMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector slice(int origin) {\n-        return (IntMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector unslice(int origin, Vector<Integer> w, int part) {\n-        return (IntMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector unslice(int origin, Vector<Integer> w, int part, VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.unsliceTemplate(IntMaxMask.class,\n-                                  origin, w, part,\n-                                  (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector unslice(int origin) {\n-        return (IntMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector rearrange(VectorShuffle<Integer> s) {\n-        return (IntMaxVector)\n-            super.rearrangeTemplate(IntMaxShuffle.class,\n-                                    (IntMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector rearrange(VectorShuffle<Integer> shuffle,\n-                                  VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.rearrangeTemplate(IntMaxShuffle.class,\n-                                    IntMaxMask.class,\n-                                    (IntMaxShuffle) shuffle,\n-                                    (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector rearrange(VectorShuffle<Integer> s,\n-                                  Vector<Integer> v) {\n-        return (IntMaxVector)\n-            super.rearrangeTemplate(IntMaxShuffle.class,\n-                                    (IntMaxShuffle) s,\n-                                    (IntMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector compress(VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.compressTemplate(IntMaxMask.class,\n-                                   (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector expand(VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.expandTemplate(IntMaxMask.class,\n-                                   (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector selectFrom(Vector<Integer> v) {\n-        return (IntMaxVector)\n-            super.selectFromTemplate((IntMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector selectFrom(Vector<Integer> v,\n-                                   VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.selectFromTemplate((IntMaxVector) v,\n-                                     (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public int lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return laneHelper(i);\n-    }\n-\n-    public int laneHelper(int i) {\n-        return (int) VectorSupport.extract(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public IntMaxVector withLane(int i, int e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public IntMaxVector withLaneHelper(int i, int e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)e,\n-                                (v, ix, bits) -> {\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class IntMaxMask extends AbstractMask<Integer> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n-\n-        IntMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        IntMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        IntMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public IntSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        IntMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new IntMaxMask(res);\n-        }\n-\n-        @Override\n-        IntMaxMask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((IntMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new IntMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        IntMaxVector toVector() {\n-            return (IntMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        \/*package-private*\/\n-        IntMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n-            return (IntMaxMask) VectorSupport.indexPartiallyInUpperRange(\n-                IntMaxMask.class, int.class, VLENGTH, offset, limit,\n-                (o, l) -> (IntMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask compress() {\n-            return (IntMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask and(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            IntMaxMask m = (IntMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask or(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            IntMaxMask m = (IntMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask xor(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            IntMaxMask m = (IntMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ laneIsSet\n-\n-        @Override\n-        @ForceInline\n-        public boolean laneIsSet(int i) {\n-            Objects.checkIndex(i, length());\n-            return VectorSupport.extract(IntMaxMask.class, int.class, VLENGTH,\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static IntMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final IntMaxMask  TRUE_MASK = new IntMaxMask(true);\n-        private static final IntMaxMask FALSE_MASK = new IntMaxMask(false);\n-\n-\n-        static boolean[] maskLowerHalf() {\n-            boolean[] a = new boolean[VLENGTH];\n-            int len = a.length >> 1;\n-            for (int i = 0; i < len; i++) {\n-                a[i] = true;\n-            }\n-            return a;\n-        }\n-\n-        static final IntMaxMask LOWER_HALF_TRUE_MASK = new IntMaxMask(maskLowerHalf());\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class IntMaxShuffle extends AbstractShuffle<Integer> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n-\n-        IntMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public IntMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public IntMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public IntMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public IntSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final IntMaxShuffle IOTA = new IntMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, IntMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((IntMaxVector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            IntMaxShuffle s = (IntMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new IntMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromArray0(int[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m, int offsetInRange) {\n-        return super.fromArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(int[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(int[] a, int offset, VectorMask<Integer> m) {\n-        super.intoArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        super.intoArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n-        super.intoMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":0,"deletions":935,"binary":false,"changes":935,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    IntVector(int[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public IntVector() {}\n@@ -96,3 +96,0 @@\n-    \/*package-private*\/\n-    abstract int[] vec();\n-\n@@ -103,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -106,1 +103,1 @@\n-    abstract IntVector vectorFactory(int[] vec);\n+    abstract IntVector vectorFactory(VectorPayloadMF vec);\n@@ -115,2 +112,2 @@\n-    AbstractMask<Integer> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Integer> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -127,1 +124,1 @@\n-    IntVector vOp(FVOp f) {\n+    IntVector vOpMF(FVOp f) {\n@@ -132,1 +129,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +135,1 @@\n-    IntVector vOp(VectorMask<Integer> m, FVOp f) {\n+    IntVector vOpMF(VectorMask<Integer> m, FVOp f) {\n@@ -139,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -141,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -145,1 +144,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +157,1 @@\n-    IntVector uOp(FUnOp f);\n+    IntVector uOpMF(FUnOp f);\n@@ -160,5 +160,8 @@\n-    IntVector uOpTemplate(FUnOp f) {\n-        int[] vec = vec();\n-        int[] res = new int[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    IntVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v));\n@@ -166,1 +169,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +175,1 @@\n-    IntVector uOp(VectorMask<Integer> m,\n+    IntVector uOpMF(VectorMask<Integer> m,\n@@ -175,1 +179,1 @@\n-    IntVector uOpTemplate(VectorMask<Integer> m,\n+    IntVector uOpTemplateMF(VectorMask<Integer> m,\n@@ -178,1 +182,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,5 +184,10 @@\n-        int[] vec = vec();\n-        int[] res = new int[length()];\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -186,1 +195,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +208,1 @@\n-    IntVector bOp(Vector<Integer> o,\n+    IntVector bOpMF(Vector<Integer> o,\n@@ -202,1 +212,1 @@\n-    IntVector bOpTemplate(Vector<Integer> o,\n+    IntVector bOpTemplateMF(Vector<Integer> o,\n@@ -204,5 +214,9 @@\n-        int[] res = new int[length()];\n-        int[] vec1 = this.vec();\n-        int[] vec2 = ((IntVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +224,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +230,1 @@\n-    IntVector bOp(Vector<Integer> o,\n+    IntVector bOpMF(Vector<Integer> o,\n@@ -220,1 +235,1 @@\n-    IntVector bOpTemplate(Vector<Integer> o,\n+    IntVector bOpTemplateMF(Vector<Integer> o,\n@@ -224,1 +239,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,6 +241,12 @@\n-        int[] res = new int[length()];\n-        int[] vec1 = this.vec();\n-        int[] vec2 = ((IntVector)o).vec();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -233,1 +254,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +267,1 @@\n-    IntVector tOp(Vector<Integer> o1,\n+    IntVector tOpMF(Vector<Integer> o1,\n@@ -250,1 +272,1 @@\n-    IntVector tOpTemplate(Vector<Integer> o1,\n+    IntVector tOpTemplateMF(Vector<Integer> o1,\n@@ -253,6 +275,11 @@\n-        int[] res = new int[length()];\n-        int[] vec1 = this.vec();\n-        int[] vec2 = ((IntVector)o1).vec();\n-        int[] vec3 = ((IntVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o1).vec();\n+        VectorPayloadMF vec3 = ((IntVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v3 = Unsafe.getUnsafe().getInt(vec3, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +287,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +293,1 @@\n-    IntVector tOp(Vector<Integer> o1,\n+    IntVector tOpMF(Vector<Integer> o1,\n@@ -271,1 +299,1 @@\n-    IntVector tOpTemplate(Vector<Integer> o1,\n+    IntVector tOpTemplateMF(Vector<Integer> o1,\n@@ -276,1 +304,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,7 +306,14 @@\n-        int[] res = new int[length()];\n-        int[] vec1 = this.vec();\n-        int[] vec2 = ((IntVector)o1).vec();\n-        int[] vec3 = ((IntVector)o2).vec();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o1).vec();\n+        VectorPayloadMF vec3 = ((IntVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v3 = Unsafe.getUnsafe().getInt(vec3, vOffset + i * Integer.BYTES);\n+            int v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f);\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    int rOpTemplate(int v, VectorMask<Integer> m, FBinOp f) {\n+    int rOpTemplateMF(int v, VectorMask<Integer> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,4 +337,8 @@\n-        int[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -311,4 +351,7 @@\n-    int rOpTemplate(int v, FBinOp f) {\n-        int[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    int rOpTemplateMF(int v, FBinOp f) {\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +372,1 @@\n-    <M> IntVector ldOp(M memory, int offset,\n+    <M> IntVector ldOpMF(M memory, int offset,\n@@ -331,4 +374,7 @@\n-        \/\/dummy; no vec = vec();\n-        int[] res = new int[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                int.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +382,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +389,1 @@\n-    <M> IntVector ldOp(M memory, int offset,\n+    <M> IntVector ldOpMF(M memory, int offset,\n@@ -345,6 +392,10 @@\n-        \/\/int[] vec = vec();\n-        int[] res = new int[length()];\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                int.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +404,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +408,1 @@\n+\n@@ -364,1 +417,1 @@\n-    IntVector ldLongOp(MemorySegment memory, long offset,\n+    IntVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +419,7 @@\n-        \/\/dummy; no vec = vec();\n-        int[] res = new int[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                int.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +427,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +434,1 @@\n-    IntVector ldLongOp(MemorySegment memory, long offset,\n+    IntVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,6 +437,10 @@\n-        \/\/int[] vec = vec();\n-        int[] res = new int[length()];\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                int.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +449,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +464,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +466,5 @@\n-        int[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -411,1 +475,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +477,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,5 +480,8 @@\n-        int[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -425,0 +492,1 @@\n+\n@@ -432,1 +500,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +502,5 @@\n-        int[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -443,1 +513,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,5 +516,8 @@\n-        int[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -469,1 +542,1 @@\n-    AbstractMask<Integer> bTest(int cond,\n+    AbstractMask<Integer> bTestMF(int cond,\n@@ -472,5 +545,11 @@\n-        int[] vec1 = vec();\n-        int[] vec2 = ((IntVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        int length = vspecies().length();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -478,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -565,1 +645,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -725,1 +805,1 @@\n-                    v0.uOp(m, (i, a) -> (int) -a);\n+                    v0.uOpMF(m, (i, a) -> (int) -a);\n@@ -727,1 +807,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Math.abs(a));\n@@ -729,1 +809,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.bitCount(a));\n@@ -731,1 +811,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.numberOfTrailingZeros(a));\n@@ -733,1 +813,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.numberOfLeadingZeros(a));\n@@ -735,1 +815,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.reverse(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.reverse(a));\n@@ -737,1 +817,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.reverseBytes(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.reverseBytes(a));\n@@ -787,1 +867,1 @@\n-            BIN_IMPL.find(op, opc, IntVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, IntVector::binaryOperationsMF));\n@@ -847,1 +927,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a + b));\n@@ -849,1 +929,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a - b));\n@@ -851,1 +931,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a * b));\n@@ -853,1 +933,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a \/ b));\n@@ -855,1 +935,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.max(a, b));\n@@ -857,1 +937,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.min(a, b));\n@@ -859,1 +939,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a & b));\n@@ -861,1 +941,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a | b));\n@@ -863,1 +943,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a ^ b));\n@@ -865,1 +945,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (int)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)(a << n));\n@@ -867,1 +947,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (int)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)(a >> n));\n@@ -869,1 +949,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n@@ -871,1 +951,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -873,1 +953,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -875,1 +955,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> Integer.compress(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Integer.compress(a, n));\n@@ -877,1 +957,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> Integer.expand(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Integer.expand(a, n));\n@@ -882,0 +962,39 @@\n+    private static BinaryOperation<IntVector, VectorMask<Integer>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Integer.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Integer.expand(a, n));\n+            default: return null;\n+        }\n+    }\n+\n+\n@@ -1046,1 +1165,1 @@\n-                    v.uOp(m, (i, a) -> (int)(a << n));\n+                    v.uOpMF(m, (i, a) -> (int)(a << n));\n@@ -1048,1 +1167,1 @@\n-                    v.uOp(m, (i, a) -> (int)(a >> n));\n+                    v.uOpMF(m, (i, a) -> (int)(a >> n));\n@@ -1050,1 +1169,1 @@\n-                    v.uOp(m, (i, a) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1052,1 +1171,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -1054,1 +1173,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -2034,1 +2153,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2056,1 +2175,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2185,1 +2304,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2392,1 +2511,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2424,1 +2543,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2452,1 +2571,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2460,1 +2579,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2802,1 +2921,1 @@\n-                    toBits(v.rOp((int)0, m, (i, a, b) -> (int)(a + b)));\n+                    toBits(v.rOpMF((int)0, m, (i, a, b) -> (int)(a + b)));\n@@ -2804,1 +2923,1 @@\n-                    toBits(v.rOp((int)1, m, (i, a, b) -> (int)(a * b)));\n+                    toBits(v.rOpMF((int)1, m, (i, a, b) -> (int)(a * b)));\n@@ -2806,1 +2925,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (int) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (int) Math.min(a, b)));\n@@ -2808,1 +2927,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (int) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (int) Math.max(a, b)));\n@@ -2810,1 +2929,1 @@\n-                    toBits(v.rOp((int)-1, m, (i, a, b) -> (int)(a & b)));\n+                    toBits(v.rOpMF((int)-1, m, (i, a, b) -> (int)(a & b)));\n@@ -2812,1 +2931,1 @@\n-                    toBits(v.rOp((int)0, m, (i, a, b) -> (int)(a | b)));\n+                    toBits(v.rOpMF((int)0, m, (i, a, b) -> (int)(a | b)));\n@@ -2814,1 +2933,1 @@\n-                    toBits(v.rOp((int)0, m, (i, a, b) -> (int)(a ^ b)));\n+                    toBits(v.rOpMF((int)0, m, (i, a, b) -> (int)(a ^ b)));\n@@ -2955,1 +3074,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -2986,1 +3105,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -2990,1 +3109,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3048,1 +3167,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -3098,1 +3217,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -3142,1 +3261,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3200,1 +3319,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3204,1 +3323,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3234,1 +3353,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3236,0 +3355,1 @@\n+\n@@ -3323,1 +3443,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -3446,1 +3566,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3463,1 +3583,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3498,1 +3618,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -3513,1 +3633,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, IntVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, IntVector::memorySegmentGet);\n@@ -3529,1 +3649,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);\n@@ -3548,1 +3668,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3565,1 +3685,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3596,1 +3716,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -3613,1 +3733,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, IntVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, IntVector::memorySegmentSet);\n@@ -3630,1 +3750,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, IntVector::memorySegmentSet);\n@@ -3851,1 +3971,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -3902,1 +4022,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -3917,2 +4037,2 @@\n-        IntVector dummyVector() {\n-            return (IntVector) super.dummyVector();\n+        IntVector dummyVectorMF() {\n+            return (IntVector) super.dummyVectorMF();\n@@ -3924,1 +4044,1 @@\n-        IntVector rvOp(RVOp f) {\n+        IntVector rvOpMF(RVOp f) {\n@@ -3930,1 +4050,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3933,1 +4054,1 @@\n-        IntVector vOp(FVOp f) {\n+        IntVector vOpMF(FVOp f) {\n@@ -3938,1 +4059,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3941,1 +4063,1 @@\n-        IntVector vOp(VectorMask<Integer> m, FVOp f) {\n+        IntVector vOpMF(VectorMask<Integer> m, FVOp f) {\n@@ -3943,1 +4065,2 @@\n-            boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3945,1 +4068,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -3949,1 +4072,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3954,1 +4078,1 @@\n-        <M> IntVector ldOp(M memory, int offset,\n+        <M> IntVector ldOpMF(M memory, int offset,\n@@ -3956,1 +4080,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -3961,1 +4085,1 @@\n-        <M> IntVector ldOp(M memory, int offset,\n+        <M> IntVector ldOpMF(M memory, int offset,\n@@ -3964,1 +4088,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -3967,0 +4091,1 @@\n+\n@@ -3969,1 +4094,1 @@\n-        IntVector ldLongOp(MemorySegment memory, long offset,\n+        IntVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3971,1 +4096,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -3976,1 +4101,1 @@\n-        IntVector ldLongOp(MemorySegment memory, long offset,\n+        IntVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3979,1 +4104,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -3984,2 +4109,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -3990,2 +4115,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Integer> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Integer> m,\n@@ -3993,1 +4118,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -3996,0 +4121,1 @@\n+\n@@ -3998,2 +4124,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -4004,1 +4130,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -4007,1 +4133,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -4021,2 +4147,3 @@\n-            if ((Class<?>) vectorType() == IntMaxVector.class)\n-                return IntMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n+            \/\/    return IntMaxVector.ZERO;\n@@ -4035,2 +4162,3 @@\n-            if ((Class<?>) vectorType() == IntMaxVector.class)\n-                return IntMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n+            \/\/    return IntMaxVector.IOTA;\n@@ -4050,2 +4178,3 @@\n-            if ((Class<?>) vectorType() == IntMaxVector.class)\n-                return IntMaxVector.IntMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n+            \/\/    return IntMaxVector.IntMaxMask.maskAll(bit);\n@@ -4060,0 +4189,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            int [] init = new int[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (int)i;\n+            }\n+           return init;\n+        }\n@@ -4076,1 +4215,2 @@\n-            case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;\n@@ -4110,1 +4250,2 @@\n-    public static final VectorSpecies<Integer> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Integer> SPECIES_MAX\n@@ -4115,0 +4256,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":382,"deletions":240,"binary":false,"changes":622,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Long128Vector extends LongVector {\n+value class Long128Vector extends LongVector {\n@@ -57,2 +58,6 @@\n-    Long128Vector(long[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128L.class);\n+\n+    private final VectorPayloadMF128L payload;\n+\n+    Long128Vector(Object value) {\n+        this.payload = (VectorPayloadMF128L) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Long128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Long128Vector(Object v) {\n-        this((long[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Long128Vector ZERO = new Long128Vector(new long[VLENGTH]);\n-    static final Long128Vector IOTA = new Long128Vector(VSPECIES.iotaArray());\n+    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.newInstanceFactory(long.class, 2));\n+    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -131,2 +131,2 @@\n-    Long128Mask maskFromArray(boolean[] bits) {\n-        return new Long128Mask(bits);\n+    Long128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long128Mask(payload);\n@@ -152,1 +152,1 @@\n-    Long128Shuffle shuffleFromBytes(byte[] reorder) { return new Long128Shuffle(reorder); }\n+    Long128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Long128Shuffle(indexes); }\n@@ -165,1 +165,1 @@\n-    Long128Vector vectorFactory(long[] vec) {\n+    Long128Vector vectorFactory(VectorPayloadMF vec) {\n@@ -185,2 +185,2 @@\n-    Long128Vector uOp(FUnOp f) {\n-        return (Long128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Long128Vector uOpMF(FUnOp f) {\n+        return (Long128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -191,1 +191,1 @@\n-    Long128Vector uOp(VectorMask<Long> m, FUnOp f) {\n+    Long128Vector uOpMF(VectorMask<Long> m, FUnOp f) {\n@@ -193,1 +193,1 @@\n-            super.uOpTemplate((Long128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Long128Mask)m, f);  \/\/ specialize\n@@ -200,2 +200,2 @@\n-    Long128Vector bOp(Vector<Long> v, FBinOp f) {\n-        return (Long128Vector) super.bOpTemplate((Long128Vector)v, f);  \/\/ specialize\n+    Long128Vector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (Long128Vector) super.bOpTemplateMF((Long128Vector)v, f);  \/\/ specialize\n@@ -206,1 +206,1 @@\n-    Long128Vector bOp(Vector<Long> v,\n+    Long128Vector bOpMF(Vector<Long> v,\n@@ -209,2 +209,2 @@\n-            super.bOpTemplate((Long128Vector)v, (Long128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Long128Vector)v, (Long128Mask)m,\n+                                f);  \/\/ specialize\n@@ -217,1 +217,1 @@\n-    Long128Vector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+    Long128Vector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n@@ -219,2 +219,2 @@\n-            super.tOpTemplate((Long128Vector)v1, (Long128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Long128Vector)v1, (Long128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -225,1 +225,1 @@\n-    Long128Vector tOp(Vector<Long> v1, Vector<Long> v2,\n+    Long128Vector tOpMF(Vector<Long> v1, Vector<Long> v2,\n@@ -228,2 +228,2 @@\n-            super.tOpTemplate((Long128Vector)v1, (Long128Vector)v2,\n-                              (Long128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Long128Vector)v1, (Long128Vector)v2,\n+                                (Long128Mask)m, f);  \/\/ specialize\n@@ -234,2 +234,2 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -512,6 +512,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n@@ -531,1 +532,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -535,3 +536,6 @@\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -543,1 +547,1 @@\n-    static final class Long128Mask extends AbstractMask<Long> {\n+    static final value class Long128Mask extends AbstractMask<Long> {\n@@ -547,3 +551,1 @@\n-        Long128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -551,2 +553,2 @@\n-        Long128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -555,2 +557,2 @@\n-        Long128Mask(boolean val) {\n-            super(prepare(val));\n+        Long128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -559,12 +561,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -583,4 +575,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -588,18 +576,2 @@\n-        Long128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long128Mask(res);\n-        }\n-\n-        @Override\n-        Long128Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -615,27 +587,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -662,1 +607,1 @@\n-            return (Long128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -675,3 +620,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -685,3 +630,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -695,3 +640,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -706,1 +651,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).trueCountHelper());\n@@ -713,1 +658,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).firstTrueHelper());\n@@ -720,1 +665,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).lastTrueHelper());\n@@ -730,1 +675,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long128Mask) m).toLongHelper());\n@@ -740,1 +685,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Long128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -750,1 +695,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));\n+                                         (m, __) -> ((Long128Mask) m).anyTrueHelper());\n@@ -758,1 +703,1 @@\n-                                         (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));\n+                                         (m, __) -> ((Long128Mask) m).allTrueHelper());\n@@ -775,1 +720,1 @@\n-    static final class Long128Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long128Shuffle extends AbstractShuffle<Long> {\n@@ -779,2 +724,6 @@\n-        Long128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Long128Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -783,2 +732,2 @@\n-        public Long128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Long128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -787,2 +736,2 @@\n-        public Long128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Long128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -792,1 +741,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -829,6 +784,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -836,0 +794,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Long256Vector extends LongVector {\n+value class Long256Vector extends LongVector {\n@@ -57,2 +58,6 @@\n-    Long256Vector(long[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256L.class);\n+\n+    private final VectorPayloadMF256L payload;\n+\n+    Long256Vector(Object value) {\n+        this.payload = (VectorPayloadMF256L) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Long256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Long256Vector(Object v) {\n-        this((long[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Long256Vector ZERO = new Long256Vector(new long[VLENGTH]);\n-    static final Long256Vector IOTA = new Long256Vector(VSPECIES.iotaArray());\n+    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.newInstanceFactory(long.class, 4));\n+    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -131,2 +131,2 @@\n-    Long256Mask maskFromArray(boolean[] bits) {\n-        return new Long256Mask(bits);\n+    Long256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long256Mask(payload);\n@@ -152,1 +152,1 @@\n-    Long256Shuffle shuffleFromBytes(byte[] reorder) { return new Long256Shuffle(reorder); }\n+    Long256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Long256Shuffle(indexes); }\n@@ -165,1 +165,1 @@\n-    Long256Vector vectorFactory(long[] vec) {\n+    Long256Vector vectorFactory(VectorPayloadMF vec) {\n@@ -185,2 +185,2 @@\n-    Long256Vector uOp(FUnOp f) {\n-        return (Long256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Long256Vector uOpMF(FUnOp f) {\n+        return (Long256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -191,1 +191,1 @@\n-    Long256Vector uOp(VectorMask<Long> m, FUnOp f) {\n+    Long256Vector uOpMF(VectorMask<Long> m, FUnOp f) {\n@@ -193,1 +193,1 @@\n-            super.uOpTemplate((Long256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Long256Mask)m, f);  \/\/ specialize\n@@ -200,2 +200,2 @@\n-    Long256Vector bOp(Vector<Long> v, FBinOp f) {\n-        return (Long256Vector) super.bOpTemplate((Long256Vector)v, f);  \/\/ specialize\n+    Long256Vector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (Long256Vector) super.bOpTemplateMF((Long256Vector)v, f);  \/\/ specialize\n@@ -206,1 +206,1 @@\n-    Long256Vector bOp(Vector<Long> v,\n+    Long256Vector bOpMF(Vector<Long> v,\n@@ -209,2 +209,2 @@\n-            super.bOpTemplate((Long256Vector)v, (Long256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Long256Vector)v, (Long256Mask)m,\n+                                f);  \/\/ specialize\n@@ -217,1 +217,1 @@\n-    Long256Vector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+    Long256Vector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n@@ -219,2 +219,2 @@\n-            super.tOpTemplate((Long256Vector)v1, (Long256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Long256Vector)v1, (Long256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -225,1 +225,1 @@\n-    Long256Vector tOp(Vector<Long> v1, Vector<Long> v2,\n+    Long256Vector tOpMF(Vector<Long> v1, Vector<Long> v2,\n@@ -228,2 +228,2 @@\n-            super.tOpTemplate((Long256Vector)v1, (Long256Vector)v2,\n-                              (Long256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Long256Vector)v1, (Long256Vector)v2,\n+                                (Long256Mask)m, f);  \/\/ specialize\n@@ -234,2 +234,2 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -514,6 +514,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n@@ -535,1 +536,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -539,3 +540,6 @@\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -547,1 +551,1 @@\n-    static final class Long256Mask extends AbstractMask<Long> {\n+    static final value class Long256Mask extends AbstractMask<Long> {\n@@ -551,3 +555,1 @@\n-        Long256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -555,2 +557,2 @@\n-        Long256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -559,2 +561,2 @@\n-        Long256Mask(boolean val) {\n-            super(prepare(val));\n+        Long256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -563,12 +565,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -587,4 +579,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -592,18 +580,2 @@\n-        Long256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long256Mask(res);\n-        }\n-\n-        @Override\n-        Long256Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -619,27 +591,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -666,1 +611,1 @@\n-            return (Long256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -679,3 +624,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -689,3 +634,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -699,3 +644,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -710,1 +655,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).trueCountHelper());\n@@ -717,1 +662,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).firstTrueHelper());\n@@ -724,1 +669,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).lastTrueHelper());\n@@ -734,1 +679,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long256Mask) m).toLongHelper());\n@@ -744,1 +689,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Long256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -754,1 +699,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));\n+                                         (m, __) -> ((Long256Mask) m).anyTrueHelper());\n@@ -762,1 +707,1 @@\n-                                         (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));\n+                                         (m, __) -> ((Long256Mask) m).allTrueHelper());\n@@ -779,1 +724,1 @@\n-    static final class Long256Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long256Shuffle extends AbstractShuffle<Long> {\n@@ -783,2 +728,6 @@\n-        Long256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Long256Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -787,2 +736,2 @@\n-        public Long256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Long256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -791,2 +740,2 @@\n-        public Long256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Long256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -796,1 +745,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -833,6 +788,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -840,0 +798,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Long512Vector extends LongVector {\n+value class Long512Vector extends LongVector {\n@@ -57,2 +58,6 @@\n-    Long512Vector(long[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512L.class);\n+\n+    private final VectorPayloadMF512L payload;\n+\n+    Long512Vector(Object value) {\n+        this.payload = (VectorPayloadMF512L) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Long512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Long512Vector(Object v) {\n-        this((long[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Long512Vector ZERO = new Long512Vector(new long[VLENGTH]);\n-    static final Long512Vector IOTA = new Long512Vector(VSPECIES.iotaArray());\n+    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.newInstanceFactory(long.class, 8));\n+    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -131,2 +131,2 @@\n-    Long512Mask maskFromArray(boolean[] bits) {\n-        return new Long512Mask(bits);\n+    Long512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long512Mask(payload);\n@@ -152,1 +152,1 @@\n-    Long512Shuffle shuffleFromBytes(byte[] reorder) { return new Long512Shuffle(reorder); }\n+    Long512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Long512Shuffle(indexes); }\n@@ -165,1 +165,1 @@\n-    Long512Vector vectorFactory(long[] vec) {\n+    Long512Vector vectorFactory(VectorPayloadMF vec) {\n@@ -185,2 +185,2 @@\n-    Long512Vector uOp(FUnOp f) {\n-        return (Long512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Long512Vector uOpMF(FUnOp f) {\n+        return (Long512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -191,1 +191,1 @@\n-    Long512Vector uOp(VectorMask<Long> m, FUnOp f) {\n+    Long512Vector uOpMF(VectorMask<Long> m, FUnOp f) {\n@@ -193,1 +193,1 @@\n-            super.uOpTemplate((Long512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Long512Mask)m, f);  \/\/ specialize\n@@ -200,2 +200,2 @@\n-    Long512Vector bOp(Vector<Long> v, FBinOp f) {\n-        return (Long512Vector) super.bOpTemplate((Long512Vector)v, f);  \/\/ specialize\n+    Long512Vector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (Long512Vector) super.bOpTemplateMF((Long512Vector)v, f);  \/\/ specialize\n@@ -206,1 +206,1 @@\n-    Long512Vector bOp(Vector<Long> v,\n+    Long512Vector bOpMF(Vector<Long> v,\n@@ -209,2 +209,2 @@\n-            super.bOpTemplate((Long512Vector)v, (Long512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Long512Vector)v, (Long512Mask)m,\n+                                f);  \/\/ specialize\n@@ -217,1 +217,1 @@\n-    Long512Vector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+    Long512Vector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n@@ -219,2 +219,2 @@\n-            super.tOpTemplate((Long512Vector)v1, (Long512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Long512Vector)v1, (Long512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -225,1 +225,1 @@\n-    Long512Vector tOp(Vector<Long> v1, Vector<Long> v2,\n+    Long512Vector tOpMF(Vector<Long> v1, Vector<Long> v2,\n@@ -228,2 +228,2 @@\n-            super.tOpTemplate((Long512Vector)v1, (Long512Vector)v2,\n-                              (Long512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Long512Vector)v1, (Long512Vector)v2,\n+                                (Long512Mask)m, f);  \/\/ specialize\n@@ -234,2 +234,2 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -518,6 +518,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n@@ -543,1 +544,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -547,3 +548,6 @@\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -555,1 +559,1 @@\n-    static final class Long512Mask extends AbstractMask<Long> {\n+    static final value class Long512Mask extends AbstractMask<Long> {\n@@ -559,3 +563,1 @@\n-        Long512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -563,2 +565,2 @@\n-        Long512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -567,2 +569,2 @@\n-        Long512Mask(boolean val) {\n-            super(prepare(val));\n+        Long512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -571,12 +573,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -595,4 +587,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -600,18 +588,2 @@\n-        Long512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long512Mask(res);\n-        }\n-\n-        @Override\n-        Long512Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -627,27 +599,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -674,1 +619,1 @@\n-            return (Long512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -687,3 +632,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -697,3 +642,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -707,3 +652,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -718,1 +663,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).trueCountHelper());\n@@ -725,1 +670,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).firstTrueHelper());\n@@ -732,1 +677,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).lastTrueHelper());\n@@ -742,1 +687,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long512Mask) m).toLongHelper());\n@@ -752,1 +697,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Long512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -762,1 +707,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));\n+                                         (m, __) -> ((Long512Mask) m).anyTrueHelper());\n@@ -770,1 +715,1 @@\n-                                         (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));\n+                                         (m, __) -> ((Long512Mask) m).allTrueHelper());\n@@ -787,1 +732,1 @@\n-    static final class Long512Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long512Shuffle extends AbstractShuffle<Long> {\n@@ -791,2 +736,6 @@\n-        Long512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Long512Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -795,2 +744,2 @@\n-        public Long512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Long512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -799,2 +748,2 @@\n-        public Long512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Long512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -804,1 +753,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -841,6 +796,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -848,0 +806,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Long64Vector extends LongVector {\n+value class Long64Vector extends LongVector {\n@@ -57,2 +58,6 @@\n-    Long64Vector(long[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64L.class);\n+\n+    private final VectorPayloadMF64L payload;\n+\n+    Long64Vector(Object value) {\n+        this.payload = (VectorPayloadMF64L) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Long64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Long64Vector(Object v) {\n-        this((long[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Long64Vector ZERO = new Long64Vector(new long[VLENGTH]);\n-    static final Long64Vector IOTA = new Long64Vector(VSPECIES.iotaArray());\n+    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.newInstanceFactory(long.class, 1));\n+    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -131,2 +131,2 @@\n-    Long64Mask maskFromArray(boolean[] bits) {\n-        return new Long64Mask(bits);\n+    Long64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long64Mask(payload);\n@@ -152,1 +152,1 @@\n-    Long64Shuffle shuffleFromBytes(byte[] reorder) { return new Long64Shuffle(reorder); }\n+    Long64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Long64Shuffle(indexes); }\n@@ -165,1 +165,1 @@\n-    Long64Vector vectorFactory(long[] vec) {\n+    Long64Vector vectorFactory(VectorPayloadMF vec) {\n@@ -185,2 +185,2 @@\n-    Long64Vector uOp(FUnOp f) {\n-        return (Long64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Long64Vector uOpMF(FUnOp f) {\n+        return (Long64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -191,1 +191,1 @@\n-    Long64Vector uOp(VectorMask<Long> m, FUnOp f) {\n+    Long64Vector uOpMF(VectorMask<Long> m, FUnOp f) {\n@@ -193,1 +193,1 @@\n-            super.uOpTemplate((Long64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Long64Mask)m, f);  \/\/ specialize\n@@ -200,2 +200,2 @@\n-    Long64Vector bOp(Vector<Long> v, FBinOp f) {\n-        return (Long64Vector) super.bOpTemplate((Long64Vector)v, f);  \/\/ specialize\n+    Long64Vector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (Long64Vector) super.bOpTemplateMF((Long64Vector)v, f);  \/\/ specialize\n@@ -206,1 +206,1 @@\n-    Long64Vector bOp(Vector<Long> v,\n+    Long64Vector bOpMF(Vector<Long> v,\n@@ -209,2 +209,2 @@\n-            super.bOpTemplate((Long64Vector)v, (Long64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Long64Vector)v, (Long64Mask)m,\n+                                f);  \/\/ specialize\n@@ -217,1 +217,1 @@\n-    Long64Vector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+    Long64Vector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n@@ -219,2 +219,2 @@\n-            super.tOpTemplate((Long64Vector)v1, (Long64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Long64Vector)v1, (Long64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -225,1 +225,1 @@\n-    Long64Vector tOp(Vector<Long> v1, Vector<Long> v2,\n+    Long64Vector tOpMF(Vector<Long> v1, Vector<Long> v2,\n@@ -228,2 +228,2 @@\n-            super.tOpTemplate((Long64Vector)v1, (Long64Vector)v2,\n-                              (Long64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Long64Vector)v1, (Long64Vector)v2,\n+                                (Long64Mask)m, f);  \/\/ specialize\n@@ -234,2 +234,2 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -511,6 +511,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n@@ -529,1 +530,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -533,3 +534,6 @@\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -541,1 +545,1 @@\n-    static final class Long64Mask extends AbstractMask<Long> {\n+    static final value class Long64Mask extends AbstractMask<Long> {\n@@ -545,3 +549,1 @@\n-        Long64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF8Z payload;\n@@ -549,2 +551,2 @@\n-        Long64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF8Z) payload;\n@@ -553,2 +555,2 @@\n-        Long64Mask(boolean val) {\n-            super(prepare(val));\n+        Long64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -557,12 +559,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -581,4 +573,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -586,18 +574,2 @@\n-        Long64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long64Mask(res);\n-        }\n-\n-        @Override\n-        Long64Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -613,27 +585,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -660,1 +605,1 @@\n-            return (Long64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -673,3 +618,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -683,3 +628,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -693,3 +638,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -704,1 +649,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).trueCountHelper());\n@@ -711,1 +656,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).firstTrueHelper());\n@@ -718,1 +663,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).lastTrueHelper());\n@@ -728,1 +673,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long64Mask) m).toLongHelper());\n@@ -738,1 +683,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Long64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -748,1 +693,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));\n+                                         (m, __) -> ((Long64Mask) m).anyTrueHelper());\n@@ -756,1 +701,1 @@\n-                                         (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));\n+                                         (m, __) -> ((Long64Mask) m).allTrueHelper());\n@@ -773,1 +718,1 @@\n-    static final class Long64Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long64Shuffle extends AbstractShuffle<Long> {\n@@ -777,2 +722,6 @@\n-        Long64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF8B payload;\n+\n+        Long64Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF8B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -781,2 +730,2 @@\n-        public Long64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Long64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -785,2 +734,2 @@\n-        public Long64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Long64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -790,1 +739,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -827,6 +782,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -834,0 +792,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -1,914 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class LongMaxVector extends LongVector {\n-    static final LongSpecies VSPECIES =\n-        (LongSpecies) LongVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<LongMaxVector> VCLASS = LongMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n-\n-    LongMaxVector(long[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as LongMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    LongMaxVector(Object v) {\n-        this((long[]) v);\n-    }\n-\n-    static final LongMaxVector ZERO = new LongMaxVector(new long[VLENGTH]);\n-    static final LongMaxVector IOTA = new LongMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public LongSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Long> elementType() { return long.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Long.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxVector broadcast(long e) {\n-        return (LongMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    LongMaxMask maskFromArray(boolean[] bits) {\n-        return new LongMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle iotaShuffle() { return LongMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    LongMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromBytes(byte[] reorder) { return new LongMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromArray(int[] indexes, int i) { return new LongMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new LongMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    LongMaxVector vectorFactory(long[] vec) {\n-        return new LongMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector uOp(FUnOp f) {\n-        return (LongMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector uOp(VectorMask<Long> m, FUnOp f) {\n-        return (LongMaxVector)\n-            super.uOpTemplate((LongMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector bOp(Vector<Long> v, FBinOp f) {\n-        return (LongMaxVector) super.bOpTemplate((LongMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector bOp(Vector<Long> v,\n-                     VectorMask<Long> m, FBinOp f) {\n-        return (LongMaxVector)\n-            super.bOpTemplate((LongMaxVector)v, (LongMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n-        return (LongMaxVector)\n-            super.tOpTemplate((LongMaxVector)v1, (LongMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector tOp(Vector<Long> v1, Vector<Long> v2,\n-                     VectorMask<Long> m, FTriOp f) {\n-        return (LongMaxVector)\n-            super.tOpTemplate((LongMaxVector)v1, (LongMaxVector)v2,\n-                              (LongMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Long,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector lanewise(Unary op) {\n-        return (LongMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector lanewise(Unary op, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector lanewise(Binary op, Vector<Long> v) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline LongMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e) {\n-        return (LongMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline LongMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseShiftTemplate(op, LongMaxMask.class, e, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    LongMaxVector\n-    lanewise(Ternary op, Vector<Long> v1, Vector<Long> v2) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    LongMaxVector\n-    lanewise(Ternary op, Vector<Long> v1, Vector<Long> v2, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v1, v2, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    LongMaxVector addIndex(int scale) {\n-        return (LongMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Long> m) {\n-        return super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Long> m) {\n-        return (long) super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask test(Test op) {\n-        return super.testTemplate(LongMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask test(Test op, VectorMask<Long> m) {\n-        return super.testTemplate(LongMaxMask.class, op, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask compare(Comparison op, Vector<Long> v) {\n-        return super.compareTemplate(LongMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(LongMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask compare(Comparison op, Vector<Long> v, VectorMask<Long> m) {\n-        return super.compareTemplate(LongMaxMask.class, op, v, (LongMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector blend(Vector<Long> v, VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.blendTemplate(LongMaxMask.class,\n-                                (LongMaxVector) v,\n-                                (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector slice(int origin, Vector<Long> v) {\n-        return (LongMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector slice(int origin) {\n-        return (LongMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector unslice(int origin, Vector<Long> w, int part) {\n-        return (LongMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector unslice(int origin, Vector<Long> w, int part, VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.unsliceTemplate(LongMaxMask.class,\n-                                  origin, w, part,\n-                                  (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector unslice(int origin) {\n-        return (LongMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector rearrange(VectorShuffle<Long> s) {\n-        return (LongMaxVector)\n-            super.rearrangeTemplate(LongMaxShuffle.class,\n-                                    (LongMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector rearrange(VectorShuffle<Long> shuffle,\n-                                  VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.rearrangeTemplate(LongMaxShuffle.class,\n-                                    LongMaxMask.class,\n-                                    (LongMaxShuffle) shuffle,\n-                                    (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector rearrange(VectorShuffle<Long> s,\n-                                  Vector<Long> v) {\n-        return (LongMaxVector)\n-            super.rearrangeTemplate(LongMaxShuffle.class,\n-                                    (LongMaxShuffle) s,\n-                                    (LongMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector compress(VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.compressTemplate(LongMaxMask.class,\n-                                   (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector expand(VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.expandTemplate(LongMaxMask.class,\n-                                   (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector selectFrom(Vector<Long> v) {\n-        return (LongMaxVector)\n-            super.selectFromTemplate((LongMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector selectFrom(Vector<Long> v,\n-                                   VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.selectFromTemplate((LongMaxVector) v,\n-                                     (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public long lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return laneHelper(i);\n-    }\n-\n-    public long laneHelper(int i) {\n-        return (long) VectorSupport.extract(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public LongMaxVector withLane(int i, long e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public LongMaxVector withLaneHelper(int i, long e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)e,\n-                                (v, ix, bits) -> {\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class LongMaxMask extends AbstractMask<Long> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n-\n-        LongMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        LongMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        LongMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public LongSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        LongMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new LongMaxMask(res);\n-        }\n-\n-        @Override\n-        LongMaxMask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((LongMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new LongMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        LongMaxVector toVector() {\n-            return (LongMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        \/*package-private*\/\n-        LongMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n-            return (LongMaxMask) VectorSupport.indexPartiallyInUpperRange(\n-                LongMaxMask.class, long.class, VLENGTH, offset, limit,\n-                (o, l) -> (LongMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask compress() {\n-            return (LongMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask and(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            LongMaxMask m = (LongMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask or(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            LongMaxMask m = (LongMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask xor(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            LongMaxMask m = (LongMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ laneIsSet\n-\n-        @Override\n-        @ForceInline\n-        public boolean laneIsSet(int i) {\n-            Objects.checkIndex(i, length());\n-            return VectorSupport.extract(LongMaxMask.class, long.class, VLENGTH,\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static LongMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final LongMaxMask  TRUE_MASK = new LongMaxMask(true);\n-        private static final LongMaxMask FALSE_MASK = new LongMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class LongMaxShuffle extends AbstractShuffle<Long> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n-\n-        LongMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public LongMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public LongMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public LongMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public LongSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final LongMaxShuffle IOTA = new LongMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, LongMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((LongMaxVector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n-            LongMaxShuffle s = (LongMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new LongMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromArray0(long[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m, int offsetInRange) {\n-        return super.fromArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(long[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(long[] a, int offset, VectorMask<Long> m) {\n-        super.intoArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        super.intoArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n-        super.intoMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":0,"deletions":914,"binary":false,"changes":914,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    LongVector(long[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public LongVector() {}\n@@ -96,3 +96,0 @@\n-    \/*package-private*\/\n-    abstract long[] vec();\n-\n@@ -103,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -106,1 +103,1 @@\n-    abstract LongVector vectorFactory(long[] vec);\n+    abstract LongVector vectorFactory(VectorPayloadMF vec);\n@@ -115,2 +112,2 @@\n-    AbstractMask<Long> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Long> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -127,1 +124,1 @@\n-    LongVector vOp(FVOp f) {\n+    LongVector vOpMF(FVOp f) {\n@@ -132,1 +129,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +135,1 @@\n-    LongVector vOp(VectorMask<Long> m, FVOp f) {\n+    LongVector vOpMF(VectorMask<Long> m, FVOp f) {\n@@ -139,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -141,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -145,1 +144,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +157,1 @@\n-    LongVector uOp(FUnOp f);\n+    LongVector uOpMF(FUnOp f);\n@@ -160,5 +160,8 @@\n-    LongVector uOpTemplate(FUnOp f) {\n-        long[] vec = vec();\n-        long[] res = new long[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    LongVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v));\n@@ -166,1 +169,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +175,1 @@\n-    LongVector uOp(VectorMask<Long> m,\n+    LongVector uOpMF(VectorMask<Long> m,\n@@ -175,1 +179,1 @@\n-    LongVector uOpTemplate(VectorMask<Long> m,\n+    LongVector uOpTemplateMF(VectorMask<Long> m,\n@@ -178,1 +182,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,5 +184,10 @@\n-        long[] vec = vec();\n-        long[] res = new long[length()];\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -186,1 +195,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +208,1 @@\n-    LongVector bOp(Vector<Long> o,\n+    LongVector bOpMF(Vector<Long> o,\n@@ -202,1 +212,1 @@\n-    LongVector bOpTemplate(Vector<Long> o,\n+    LongVector bOpTemplateMF(Vector<Long> o,\n@@ -204,5 +214,9 @@\n-        long[] res = new long[length()];\n-        long[] vec1 = this.vec();\n-        long[] vec2 = ((LongVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +224,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +230,1 @@\n-    LongVector bOp(Vector<Long> o,\n+    LongVector bOpMF(Vector<Long> o,\n@@ -220,1 +235,1 @@\n-    LongVector bOpTemplate(Vector<Long> o,\n+    LongVector bOpTemplateMF(Vector<Long> o,\n@@ -224,1 +239,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,6 +241,12 @@\n-        long[] res = new long[length()];\n-        long[] vec1 = this.vec();\n-        long[] vec2 = ((LongVector)o).vec();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -233,1 +254,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +267,1 @@\n-    LongVector tOp(Vector<Long> o1,\n+    LongVector tOpMF(Vector<Long> o1,\n@@ -250,1 +272,1 @@\n-    LongVector tOpTemplate(Vector<Long> o1,\n+    LongVector tOpTemplateMF(Vector<Long> o1,\n@@ -253,6 +275,11 @@\n-        long[] res = new long[length()];\n-        long[] vec1 = this.vec();\n-        long[] vec2 = ((LongVector)o1).vec();\n-        long[] vec3 = ((LongVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o1).vec();\n+        VectorPayloadMF vec3 = ((LongVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v3 = Unsafe.getUnsafe().getLong(vec3, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +287,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +293,1 @@\n-    LongVector tOp(Vector<Long> o1,\n+    LongVector tOpMF(Vector<Long> o1,\n@@ -271,1 +299,1 @@\n-    LongVector tOpTemplate(Vector<Long> o1,\n+    LongVector tOpTemplateMF(Vector<Long> o1,\n@@ -276,1 +304,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,7 +306,14 @@\n-        long[] res = new long[length()];\n-        long[] vec1 = this.vec();\n-        long[] vec2 = ((LongVector)o1).vec();\n-        long[] vec3 = ((LongVector)o2).vec();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o1).vec();\n+        VectorPayloadMF vec3 = ((LongVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v3 = Unsafe.getUnsafe().getLong(vec3, vOffset + i * Long.BYTES);\n+            long v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f);\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    long rOpTemplate(long v, VectorMask<Long> m, FBinOp f) {\n+    long rOpTemplateMF(long v, VectorMask<Long> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,4 +337,8 @@\n-        long[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -311,4 +351,7 @@\n-    long rOpTemplate(long v, FBinOp f) {\n-        long[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    long rOpTemplateMF(long v, FBinOp f) {\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +372,1 @@\n-    <M> LongVector ldOp(M memory, int offset,\n+    <M> LongVector ldOpMF(M memory, int offset,\n@@ -331,4 +374,7 @@\n-        \/\/dummy; no vec = vec();\n-        long[] res = new long[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                long.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +382,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +389,1 @@\n-    <M> LongVector ldOp(M memory, int offset,\n+    <M> LongVector ldOpMF(M memory, int offset,\n@@ -345,6 +392,10 @@\n-        \/\/long[] vec = vec();\n-        long[] res = new long[length()];\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                long.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +404,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +408,1 @@\n+\n@@ -364,1 +417,1 @@\n-    LongVector ldLongOp(MemorySegment memory, long offset,\n+    LongVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +419,7 @@\n-        \/\/dummy; no vec = vec();\n-        long[] res = new long[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                long.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +427,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +434,1 @@\n-    LongVector ldLongOp(MemorySegment memory, long offset,\n+    LongVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,6 +437,10 @@\n-        \/\/long[] vec = vec();\n-        long[] res = new long[length()];\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                long.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +449,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +464,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +466,5 @@\n-        long[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -411,1 +475,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +477,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,5 +480,8 @@\n-        long[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -425,0 +492,1 @@\n+\n@@ -432,1 +500,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +502,5 @@\n-        long[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -443,1 +513,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,5 +516,8 @@\n-        long[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -469,1 +542,1 @@\n-    AbstractMask<Long> bTest(int cond,\n+    AbstractMask<Long> bTestMF(int cond,\n@@ -472,5 +545,11 @@\n-        long[] vec1 = vec();\n-        long[] vec2 = ((LongVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        int length = vspecies().length();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -478,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -565,1 +645,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -683,1 +763,1 @@\n-                    v0.uOp(m, (i, a) -> (long) -a);\n+                    v0.uOpMF(m, (i, a) -> (long) -a);\n@@ -685,1 +765,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Math.abs(a));\n@@ -687,1 +767,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.bitCount(a));\n@@ -689,1 +769,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.numberOfTrailingZeros(a));\n@@ -691,1 +771,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.numberOfLeadingZeros(a));\n@@ -693,1 +773,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.reverse(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.reverse(a));\n@@ -695,1 +775,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.reverseBytes(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.reverseBytes(a));\n@@ -745,1 +825,1 @@\n-            BIN_IMPL.find(op, opc, LongVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, LongVector::binaryOperationsMF));\n@@ -805,1 +885,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a + b));\n@@ -807,1 +887,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a - b));\n@@ -809,1 +889,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a * b));\n@@ -811,1 +891,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a \/ b));\n@@ -813,1 +893,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.max(a, b));\n@@ -815,1 +895,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.min(a, b));\n@@ -817,1 +897,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a & b));\n@@ -819,1 +899,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a | b));\n@@ -821,1 +901,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a ^ b));\n@@ -823,1 +903,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (long)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)(a << n));\n@@ -825,1 +905,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (long)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)(a >> n));\n@@ -827,1 +907,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n@@ -829,1 +909,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -831,1 +911,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -833,1 +913,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> Long.compress(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Long.compress(a, n));\n@@ -835,1 +915,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> Long.expand(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Long.expand(a, n));\n@@ -840,0 +920,39 @@\n+    private static BinaryOperation<LongVector, VectorMask<Long>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Long.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Long.expand(a, n));\n+            default: return null;\n+        }\n+    }\n+\n+\n@@ -959,1 +1078,1 @@\n-                    v.uOp(m, (i, a) -> (long)(a << n));\n+                    v.uOpMF(m, (i, a) -> (long)(a << n));\n@@ -961,1 +1080,1 @@\n-                    v.uOp(m, (i, a) -> (long)(a >> n));\n+                    v.uOpMF(m, (i, a) -> (long)(a >> n));\n@@ -963,1 +1082,1 @@\n-                    v.uOp(m, (i, a) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n@@ -965,1 +1084,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -967,1 +1086,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -1947,1 +2066,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -1969,1 +2088,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2072,1 +2191,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2258,1 +2377,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2290,1 +2409,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2318,1 +2437,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2326,1 +2445,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2668,1 +2787,1 @@\n-                    toBits(v.rOp((long)0, m, (i, a, b) -> (long)(a + b)));\n+                    toBits(v.rOpMF((long)0, m, (i, a, b) -> (long)(a + b)));\n@@ -2670,1 +2789,1 @@\n-                    toBits(v.rOp((long)1, m, (i, a, b) -> (long)(a * b)));\n+                    toBits(v.rOpMF((long)1, m, (i, a, b) -> (long)(a * b)));\n@@ -2672,1 +2791,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (long) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (long) Math.min(a, b)));\n@@ -2674,1 +2793,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (long) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (long) Math.max(a, b)));\n@@ -2676,1 +2795,1 @@\n-                    toBits(v.rOp((long)-1, m, (i, a, b) -> (long)(a & b)));\n+                    toBits(v.rOpMF((long)-1, m, (i, a, b) -> (long)(a & b)));\n@@ -2678,1 +2797,1 @@\n-                    toBits(v.rOp((long)0, m, (i, a, b) -> (long)(a | b)));\n+                    toBits(v.rOpMF((long)0, m, (i, a, b) -> (long)(a | b)));\n@@ -2680,1 +2799,1 @@\n-                    toBits(v.rOp((long)0, m, (i, a, b) -> (long)(a ^ b)));\n+                    toBits(v.rOpMF((long)0, m, (i, a, b) -> (long)(a ^ b)));\n@@ -2816,1 +2935,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -2847,1 +2966,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -2851,1 +2970,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -2901,1 +3020,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -2910,1 +3029,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -2913,0 +3032,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -2927,1 +3048,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -2977,1 +3098,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -3021,1 +3142,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3079,1 +3200,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3083,1 +3204,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3113,1 +3234,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3115,0 +3236,1 @@\n+\n@@ -3194,1 +3316,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3202,1 +3324,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3205,0 +3327,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3221,1 +3345,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -3344,1 +3468,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3361,1 +3485,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3387,1 +3511,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3396,1 +3520,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3399,0 +3523,2 @@\n+             *\/\n+            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3414,1 +3540,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -3429,1 +3555,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, LongVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, LongVector::memorySegmentGet);\n@@ -3445,1 +3571,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);\n@@ -3464,1 +3590,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3481,1 +3607,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3503,1 +3629,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3511,1 +3637,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3514,0 +3640,3 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n+\n@@ -3531,1 +3660,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -3548,1 +3677,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, LongVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, LongVector::memorySegmentSet);\n@@ -3565,1 +3694,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, LongVector::memorySegmentSet);\n@@ -3786,1 +3915,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -3828,1 +3957,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -3843,2 +3972,2 @@\n-        LongVector dummyVector() {\n-            return (LongVector) super.dummyVector();\n+        LongVector dummyVectorMF() {\n+            return (LongVector) super.dummyVectorMF();\n@@ -3850,1 +3979,1 @@\n-        LongVector rvOp(RVOp f) {\n+        LongVector rvOpMF(RVOp f) {\n@@ -3856,1 +3985,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3859,1 +3989,1 @@\n-        LongVector vOp(FVOp f) {\n+        LongVector vOpMF(FVOp f) {\n@@ -3864,1 +3994,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3867,1 +3998,1 @@\n-        LongVector vOp(VectorMask<Long> m, FVOp f) {\n+        LongVector vOpMF(VectorMask<Long> m, FVOp f) {\n@@ -3869,1 +4000,2 @@\n-            boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3871,1 +4003,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -3875,1 +4007,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3880,1 +4013,1 @@\n-        <M> LongVector ldOp(M memory, int offset,\n+        <M> LongVector ldOpMF(M memory, int offset,\n@@ -3882,1 +4015,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -3887,1 +4020,1 @@\n-        <M> LongVector ldOp(M memory, int offset,\n+        <M> LongVector ldOpMF(M memory, int offset,\n@@ -3890,1 +4023,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -3893,0 +4026,1 @@\n+\n@@ -3895,1 +4029,1 @@\n-        LongVector ldLongOp(MemorySegment memory, long offset,\n+        LongVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3897,1 +4031,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -3902,1 +4036,1 @@\n-        LongVector ldLongOp(MemorySegment memory, long offset,\n+        LongVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3905,1 +4039,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -3910,2 +4044,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -3916,2 +4050,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Long> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Long> m,\n@@ -3919,1 +4053,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -3922,0 +4056,1 @@\n+\n@@ -3924,2 +4059,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -3930,1 +4065,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -3933,1 +4068,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -3947,2 +4082,3 @@\n-            if ((Class<?>) vectorType() == LongMaxVector.class)\n-                return LongMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n+            \/\/    return LongMaxVector.ZERO;\n@@ -3961,2 +4097,3 @@\n-            if ((Class<?>) vectorType() == LongMaxVector.class)\n-                return LongMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n+            \/\/    return LongMaxVector.IOTA;\n@@ -3976,2 +4113,3 @@\n-            if ((Class<?>) vectorType() == LongMaxVector.class)\n-                return LongMaxVector.LongMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n+            \/\/    return LongMaxVector.LongMaxMask.maskAll(bit);\n@@ -3986,0 +4124,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            long [] init = new long[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (long)i;\n+            }\n+           return init;\n+        }\n@@ -4002,1 +4150,2 @@\n-            case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;\n@@ -4036,1 +4185,2 @@\n-    public static final VectorSpecies<Long> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Long> SPECIES_MAX\n@@ -4041,0 +4191,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":399,"deletions":248,"binary":false,"changes":647,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Short128Vector extends ShortVector {\n+value class Short128Vector extends ShortVector {\n@@ -57,2 +58,6 @@\n-    Short128Vector(short[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF128S.class);\n+\n+    private final VectorPayloadMF128S payload;\n+\n+    Short128Vector(Object value) {\n+        this.payload = (VectorPayloadMF128S) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Short128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Short128Vector(Object v) {\n-        this((short[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Short128Vector ZERO = new Short128Vector(new short[VLENGTH]);\n-    static final Short128Vector IOTA = new Short128Vector(VSPECIES.iotaArray());\n+    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.newInstanceFactory(short.class, 8));\n+    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Short128Mask maskFromArray(boolean[] bits) {\n-        return new Short128Mask(bits);\n+    Short128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short128Mask(payload);\n@@ -157,1 +157,1 @@\n-    Short128Shuffle shuffleFromBytes(byte[] reorder) { return new Short128Shuffle(reorder); }\n+    Short128Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Short128Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Short128Vector vectorFactory(short[] vec) {\n+    Short128Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Short128Vector uOp(FUnOp f) {\n-        return (Short128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Short128Vector uOpMF(FUnOp f) {\n+        return (Short128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Short128Vector uOp(VectorMask<Short> m, FUnOp f) {\n+    Short128Vector uOpMF(VectorMask<Short> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Short128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Short128Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Short128Vector bOp(Vector<Short> v, FBinOp f) {\n-        return (Short128Vector) super.bOpTemplate((Short128Vector)v, f);  \/\/ specialize\n+    Short128Vector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (Short128Vector) super.bOpTemplateMF((Short128Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Short128Vector bOp(Vector<Short> v,\n+    Short128Vector bOpMF(Vector<Short> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Short128Vector)v, (Short128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Short128Vector)v, (Short128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Short128Vector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+    Short128Vector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Short128Vector)v1, (Short128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Short128Vector)v1, (Short128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Short128Vector tOp(Vector<Short> v1, Vector<Short> v2,\n+    Short128Vector tOpMF(Vector<Short> v1, Vector<Short> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Short128Vector)v1, (Short128Vector)v2,\n-                              (Short128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Short128Vector)v1, (Short128Vector)v2,\n+                                (Short128Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -528,6 +528,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n@@ -553,1 +554,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -557,3 +558,6 @@\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -565,1 +569,1 @@\n-    static final class Short128Mask extends AbstractMask<Short> {\n+    static final value class Short128Mask extends AbstractMask<Short> {\n@@ -569,3 +573,1 @@\n-        Short128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -573,2 +575,2 @@\n-        Short128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -577,2 +579,2 @@\n-        Short128Mask(boolean val) {\n-            super(prepare(val));\n+        Short128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -581,12 +583,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -605,4 +597,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -610,18 +598,2 @@\n-        Short128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short128Mask(res);\n-        }\n-\n-        @Override\n-        Short128Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -637,27 +609,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -684,1 +629,1 @@\n-            return (Short128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -697,3 +642,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -707,3 +652,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -717,3 +662,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -728,1 +673,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).trueCountHelper());\n@@ -735,1 +680,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).firstTrueHelper());\n@@ -742,1 +687,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).lastTrueHelper());\n@@ -752,1 +697,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short128Mask) m).toLongHelper());\n@@ -762,1 +707,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Short128Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -772,1 +717,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));\n+                                         (m, __) -> ((Short128Mask) m).anyTrueHelper());\n@@ -780,1 +725,1 @@\n-                                         (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));\n+                                         (m, __) -> ((Short128Mask) m).allTrueHelper());\n@@ -797,1 +742,1 @@\n-    static final class Short128Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short128Shuffle extends AbstractShuffle<Short> {\n@@ -801,2 +746,6 @@\n-        Short128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Short128Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -805,2 +754,2 @@\n-        public Short128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Short128Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -809,2 +758,2 @@\n-        public Short128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Short128Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -814,1 +763,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -851,6 +806,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -858,0 +816,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Short256Vector extends ShortVector {\n+value class Short256Vector extends ShortVector {\n@@ -57,2 +58,6 @@\n-    Short256Vector(short[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF256S.class);\n+\n+    private final VectorPayloadMF256S payload;\n+\n+    Short256Vector(Object value) {\n+        this.payload = (VectorPayloadMF256S) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Short256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Short256Vector(Object v) {\n-        this((short[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Short256Vector ZERO = new Short256Vector(new short[VLENGTH]);\n-    static final Short256Vector IOTA = new Short256Vector(VSPECIES.iotaArray());\n+    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.newInstanceFactory(short.class, 16));\n+    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Short256Mask maskFromArray(boolean[] bits) {\n-        return new Short256Mask(bits);\n+    Short256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short256Mask(payload);\n@@ -157,1 +157,1 @@\n-    Short256Shuffle shuffleFromBytes(byte[] reorder) { return new Short256Shuffle(reorder); }\n+    Short256Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Short256Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Short256Vector vectorFactory(short[] vec) {\n+    Short256Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Short256Vector uOp(FUnOp f) {\n-        return (Short256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Short256Vector uOpMF(FUnOp f) {\n+        return (Short256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Short256Vector uOp(VectorMask<Short> m, FUnOp f) {\n+    Short256Vector uOpMF(VectorMask<Short> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Short256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Short256Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Short256Vector bOp(Vector<Short> v, FBinOp f) {\n-        return (Short256Vector) super.bOpTemplate((Short256Vector)v, f);  \/\/ specialize\n+    Short256Vector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (Short256Vector) super.bOpTemplateMF((Short256Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Short256Vector bOp(Vector<Short> v,\n+    Short256Vector bOpMF(Vector<Short> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Short256Vector)v, (Short256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Short256Vector)v, (Short256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Short256Vector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+    Short256Vector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Short256Vector)v1, (Short256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Short256Vector)v1, (Short256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Short256Vector tOp(Vector<Short> v1, Vector<Short> v2,\n+    Short256Vector tOpMF(Vector<Short> v1, Vector<Short> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Short256Vector)v1, (Short256Vector)v2,\n-                              (Short256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Short256Vector)v1, (Short256Vector)v2,\n+                                (Short256Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -536,6 +536,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n@@ -569,1 +570,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -573,3 +574,6 @@\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -581,1 +585,1 @@\n-    static final class Short256Mask extends AbstractMask<Short> {\n+    static final value class Short256Mask extends AbstractMask<Short> {\n@@ -585,3 +589,1 @@\n-        Short256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -589,2 +591,2 @@\n-        Short256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -593,2 +595,2 @@\n-        Short256Mask(boolean val) {\n-            super(prepare(val));\n+        Short256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -597,12 +599,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -621,4 +613,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -626,18 +614,2 @@\n-        Short256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short256Mask(res);\n-        }\n-\n-        @Override\n-        Short256Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -653,27 +625,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -700,1 +645,1 @@\n-            return (Short256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -713,3 +658,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -723,3 +668,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -733,3 +678,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -744,1 +689,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).trueCountHelper());\n@@ -751,1 +696,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).firstTrueHelper());\n@@ -758,1 +703,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).lastTrueHelper());\n@@ -768,1 +713,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short256Mask) m).toLongHelper());\n@@ -778,1 +723,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Short256Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -788,1 +733,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));\n+                                         (m, __) -> ((Short256Mask) m).anyTrueHelper());\n@@ -796,1 +741,1 @@\n-                                         (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));\n+                                         (m, __) -> ((Short256Mask) m).allTrueHelper());\n@@ -813,1 +758,1 @@\n-    static final class Short256Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short256Shuffle extends AbstractShuffle<Short> {\n@@ -817,2 +762,6 @@\n-        Short256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Short256Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -821,2 +770,2 @@\n-        public Short256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Short256Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -825,2 +774,2 @@\n-        public Short256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Short256Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -830,1 +779,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -867,6 +822,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -874,0 +832,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Short512Vector extends ShortVector {\n+value class Short512Vector extends ShortVector {\n@@ -57,2 +58,6 @@\n-    Short512Vector(short[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF512S.class);\n+\n+    private final VectorPayloadMF512S payload;\n+\n+    Short512Vector(Object value) {\n+        this.payload = (VectorPayloadMF512S) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Short512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Short512Vector(Object v) {\n-        this((short[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Short512Vector ZERO = new Short512Vector(new short[VLENGTH]);\n-    static final Short512Vector IOTA = new Short512Vector(VSPECIES.iotaArray());\n+    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.newInstanceFactory(short.class, 32));\n+    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Short512Mask maskFromArray(boolean[] bits) {\n-        return new Short512Mask(bits);\n+    Short512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short512Mask(payload);\n@@ -157,1 +157,1 @@\n-    Short512Shuffle shuffleFromBytes(byte[] reorder) { return new Short512Shuffle(reorder); }\n+    Short512Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Short512Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Short512Vector vectorFactory(short[] vec) {\n+    Short512Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Short512Vector uOp(FUnOp f) {\n-        return (Short512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Short512Vector uOpMF(FUnOp f) {\n+        return (Short512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Short512Vector uOp(VectorMask<Short> m, FUnOp f) {\n+    Short512Vector uOpMF(VectorMask<Short> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Short512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Short512Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Short512Vector bOp(Vector<Short> v, FBinOp f) {\n-        return (Short512Vector) super.bOpTemplate((Short512Vector)v, f);  \/\/ specialize\n+    Short512Vector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (Short512Vector) super.bOpTemplateMF((Short512Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Short512Vector bOp(Vector<Short> v,\n+    Short512Vector bOpMF(Vector<Short> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Short512Vector)v, (Short512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Short512Vector)v, (Short512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Short512Vector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+    Short512Vector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Short512Vector)v1, (Short512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Short512Vector)v1, (Short512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Short512Vector tOp(Vector<Short> v1, Vector<Short> v2,\n+    Short512Vector tOpMF(Vector<Short> v1, Vector<Short> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Short512Vector)v1, (Short512Vector)v2,\n-                              (Short512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Short512Vector)v1, (Short512Vector)v2,\n+                                (Short512Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -552,6 +552,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n@@ -601,1 +602,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -605,3 +606,6 @@\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -613,1 +617,1 @@\n-    static final class Short512Mask extends AbstractMask<Short> {\n+    static final value class Short512Mask extends AbstractMask<Short> {\n@@ -617,3 +621,1 @@\n-        Short512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF256Z payload;\n@@ -621,2 +623,2 @@\n-        Short512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF256Z) payload;\n@@ -625,2 +627,2 @@\n-        Short512Mask(boolean val) {\n-            super(prepare(val));\n+        Short512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -629,12 +631,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -653,4 +645,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -658,18 +646,2 @@\n-        Short512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short512Mask(res);\n-        }\n-\n-        @Override\n-        Short512Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -685,27 +657,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -732,1 +677,1 @@\n-            return (Short512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -745,3 +690,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -755,3 +700,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -765,3 +710,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -776,1 +721,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).trueCountHelper());\n@@ -783,1 +728,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).firstTrueHelper());\n@@ -790,1 +735,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).lastTrueHelper());\n@@ -800,1 +745,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short512Mask) m).toLongHelper());\n@@ -810,1 +755,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Short512Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -820,1 +765,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));\n+                                         (m, __) -> ((Short512Mask) m).anyTrueHelper());\n@@ -828,1 +773,1 @@\n-                                         (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));\n+                                         (m, __) -> ((Short512Mask) m).allTrueHelper());\n@@ -845,1 +790,1 @@\n-    static final class Short512Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short512Shuffle extends AbstractShuffle<Short> {\n@@ -849,2 +794,6 @@\n-        Short512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF256B payload;\n+\n+        Short512Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF256B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -853,2 +802,2 @@\n-        public Short512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Short512Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -857,2 +806,2 @@\n-        public Short512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Short512Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -862,1 +811,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -899,6 +854,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -906,0 +864,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Short64Vector extends ShortVector {\n+value class Short64Vector extends ShortVector {\n@@ -57,2 +58,6 @@\n-    Short64Vector(short[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF64S.class);\n+\n+    private final VectorPayloadMF64S payload;\n+\n+    Short64Vector(Object value) {\n+        this.payload = (VectorPayloadMF64S) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as Short64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Short64Vector(Object v) {\n-        this((short[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final Short64Vector ZERO = new Short64Vector(new short[VLENGTH]);\n-    static final Short64Vector IOTA = new Short64Vector(VSPECIES.iotaArray());\n+    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.newInstanceFactory(short.class, 4));\n+    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -136,2 +136,2 @@\n-    Short64Mask maskFromArray(boolean[] bits) {\n-        return new Short64Mask(bits);\n+    Short64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short64Mask(payload);\n@@ -157,1 +157,1 @@\n-    Short64Shuffle shuffleFromBytes(byte[] reorder) { return new Short64Shuffle(reorder); }\n+    Short64Shuffle shuffleFromBytes(VectorPayloadMF indexes) { return new Short64Shuffle(indexes); }\n@@ -170,1 +170,1 @@\n-    Short64Vector vectorFactory(short[] vec) {\n+    Short64Vector vectorFactory(VectorPayloadMF vec) {\n@@ -190,2 +190,2 @@\n-    Short64Vector uOp(FUnOp f) {\n-        return (Short64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Short64Vector uOpMF(FUnOp f) {\n+        return (Short64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +196,1 @@\n-    Short64Vector uOp(VectorMask<Short> m, FUnOp f) {\n+    Short64Vector uOpMF(VectorMask<Short> m, FUnOp f) {\n@@ -198,1 +198,1 @@\n-            super.uOpTemplate((Short64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Short64Mask)m, f);  \/\/ specialize\n@@ -205,2 +205,2 @@\n-    Short64Vector bOp(Vector<Short> v, FBinOp f) {\n-        return (Short64Vector) super.bOpTemplate((Short64Vector)v, f);  \/\/ specialize\n+    Short64Vector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (Short64Vector) super.bOpTemplateMF((Short64Vector)v, f);  \/\/ specialize\n@@ -211,1 +211,1 @@\n-    Short64Vector bOp(Vector<Short> v,\n+    Short64Vector bOpMF(Vector<Short> v,\n@@ -214,2 +214,2 @@\n-            super.bOpTemplate((Short64Vector)v, (Short64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Short64Vector)v, (Short64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +222,1 @@\n-    Short64Vector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+    Short64Vector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n@@ -224,2 +224,2 @@\n-            super.tOpTemplate((Short64Vector)v1, (Short64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Short64Vector)v1, (Short64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +230,1 @@\n-    Short64Vector tOp(Vector<Short> v1, Vector<Short> v2,\n+    Short64Vector tOpMF(Vector<Short> v1, Vector<Short> v2,\n@@ -233,2 +233,2 @@\n-            super.tOpTemplate((Short64Vector)v1, (Short64Vector)v2,\n-                              (Short64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Short64Vector)v1, (Short64Vector)v2,\n+                                (Short64Mask)m, f);  \/\/ specialize\n@@ -239,2 +239,2 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -524,6 +524,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n@@ -545,1 +546,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -549,3 +550,6 @@\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -557,1 +561,1 @@\n-    static final class Short64Mask extends AbstractMask<Short> {\n+    static final value class Short64Mask extends AbstractMask<Short> {\n@@ -561,3 +565,1 @@\n-        Short64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -565,2 +567,2 @@\n-        Short64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -569,2 +571,2 @@\n-        Short64Mask(boolean val) {\n-            super(prepare(val));\n+        Short64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -573,12 +575,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -597,4 +589,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -602,18 +590,2 @@\n-        Short64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short64Mask(res);\n-        }\n-\n-        @Override\n-        Short64Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -629,27 +601,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -676,1 +621,1 @@\n-            return (Short64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -689,3 +634,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -699,3 +644,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -709,3 +654,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -720,1 +665,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).trueCountHelper());\n@@ -727,1 +672,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).firstTrueHelper());\n@@ -734,1 +679,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).lastTrueHelper());\n@@ -744,1 +689,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short64Mask) m).toLongHelper());\n@@ -754,1 +699,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> (((Short64Mask) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -764,1 +709,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));\n+                                         (m, __) -> ((Short64Mask) m).anyTrueHelper());\n@@ -772,1 +717,1 @@\n-                                         (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));\n+                                         (m, __) -> ((Short64Mask) m).allTrueHelper());\n@@ -789,1 +734,1 @@\n-    static final class Short64Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short64Shuffle extends AbstractShuffle<Short> {\n@@ -793,2 +738,6 @@\n-        Short64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Short64Shuffle(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -797,2 +746,2 @@\n-        public Short64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public Short64Shuffle(int[] indexes) {\n+            this(indexes, 0);\n@@ -801,2 +750,2 @@\n-        public Short64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public Short64Shuffle(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -806,1 +755,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -843,6 +798,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -850,0 +808,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":107,"deletions":148,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -1,931 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class ShortMaxVector extends ShortVector {\n-    static final ShortSpecies VSPECIES =\n-        (ShortSpecies) ShortVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<ShortMaxVector> VCLASS = ShortMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n-\n-    ShortMaxVector(short[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as ShortMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    ShortMaxVector(Object v) {\n-        this((short[]) v);\n-    }\n-\n-    static final ShortMaxVector ZERO = new ShortMaxVector(new short[VLENGTH]);\n-    static final ShortMaxVector IOTA = new ShortMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public ShortSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Short> elementType() { return short.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Short.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxVector broadcast(short e) {\n-        return (ShortMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxVector broadcast(long e) {\n-        return (ShortMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxMask maskFromArray(boolean[] bits) {\n-        return new ShortMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle iotaShuffle() { return ShortMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    ShortMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromBytes(byte[] reorder) { return new ShortMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ShortMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new ShortMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector vectorFactory(short[] vec) {\n-        return new ShortMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector uOp(FUnOp f) {\n-        return (ShortMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector uOp(VectorMask<Short> m, FUnOp f) {\n-        return (ShortMaxVector)\n-            super.uOpTemplate((ShortMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector bOp(Vector<Short> v, FBinOp f) {\n-        return (ShortMaxVector) super.bOpTemplate((ShortMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector bOp(Vector<Short> v,\n-                     VectorMask<Short> m, FBinOp f) {\n-        return (ShortMaxVector)\n-            super.bOpTemplate((ShortMaxVector)v, (ShortMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n-        return (ShortMaxVector)\n-            super.tOpTemplate((ShortMaxVector)v1, (ShortMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector tOp(Vector<Short> v1, Vector<Short> v2,\n-                     VectorMask<Short> m, FTriOp f) {\n-        return (ShortMaxVector)\n-            super.tOpTemplate((ShortMaxVector)v1, (ShortMaxVector)v2,\n-                              (ShortMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Short,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector lanewise(Unary op) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector lanewise(Unary op, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector lanewise(Binary op, Vector<Short> v) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline ShortMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e) {\n-        return (ShortMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline ShortMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseShiftTemplate(op, ShortMaxMask.class, e, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    ShortMaxVector\n-    lanewise(Ternary op, Vector<Short> v1, Vector<Short> v2) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    ShortMaxVector\n-    lanewise(Ternary op, Vector<Short> v1, Vector<Short> v2, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v1, v2, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    ShortMaxVector addIndex(int scale) {\n-        return (ShortMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final short reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final short reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Short> m) {\n-        return super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Short> m) {\n-        return (long) super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask test(Test op) {\n-        return super.testTemplate(ShortMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask test(Test op, VectorMask<Short> m) {\n-        return super.testTemplate(ShortMaxMask.class, op, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask compare(Comparison op, Vector<Short> v) {\n-        return super.compareTemplate(ShortMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask compare(Comparison op, short s) {\n-        return super.compareTemplate(ShortMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(ShortMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask compare(Comparison op, Vector<Short> v, VectorMask<Short> m) {\n-        return super.compareTemplate(ShortMaxMask.class, op, v, (ShortMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector blend(Vector<Short> v, VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.blendTemplate(ShortMaxMask.class,\n-                                (ShortMaxVector) v,\n-                                (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector slice(int origin, Vector<Short> v) {\n-        return (ShortMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector slice(int origin) {\n-        return (ShortMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector unslice(int origin, Vector<Short> w, int part) {\n-        return (ShortMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector unslice(int origin, Vector<Short> w, int part, VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.unsliceTemplate(ShortMaxMask.class,\n-                                  origin, w, part,\n-                                  (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector unslice(int origin) {\n-        return (ShortMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector rearrange(VectorShuffle<Short> s) {\n-        return (ShortMaxVector)\n-            super.rearrangeTemplate(ShortMaxShuffle.class,\n-                                    (ShortMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector rearrange(VectorShuffle<Short> shuffle,\n-                                  VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.rearrangeTemplate(ShortMaxShuffle.class,\n-                                    ShortMaxMask.class,\n-                                    (ShortMaxShuffle) shuffle,\n-                                    (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector rearrange(VectorShuffle<Short> s,\n-                                  Vector<Short> v) {\n-        return (ShortMaxVector)\n-            super.rearrangeTemplate(ShortMaxShuffle.class,\n-                                    (ShortMaxShuffle) s,\n-                                    (ShortMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector compress(VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.compressTemplate(ShortMaxMask.class,\n-                                   (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector expand(VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.expandTemplate(ShortMaxMask.class,\n-                                   (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector selectFrom(Vector<Short> v) {\n-        return (ShortMaxVector)\n-            super.selectFromTemplate((ShortMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector selectFrom(Vector<Short> v,\n-                                   VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.selectFromTemplate((ShortMaxVector) v,\n-                                     (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public short lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return laneHelper(i);\n-    }\n-\n-    public short laneHelper(int i) {\n-        return (short) VectorSupport.extract(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public ShortMaxVector withLane(int i, short e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public ShortMaxVector withLaneHelper(int i, short e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)e,\n-                                (v, ix, bits) -> {\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class ShortMaxMask extends AbstractMask<Short> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n-\n-        ShortMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        ShortMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        ShortMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public ShortSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        ShortMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new ShortMaxMask(res);\n-        }\n-\n-        @Override\n-        ShortMaxMask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((ShortMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new ShortMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        ShortMaxVector toVector() {\n-            return (ShortMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        \/*package-private*\/\n-        ShortMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n-            return (ShortMaxMask) VectorSupport.indexPartiallyInUpperRange(\n-                ShortMaxMask.class, short.class, VLENGTH, offset, limit,\n-                (o, l) -> (ShortMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask compress() {\n-            return (ShortMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask and(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            ShortMaxMask m = (ShortMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask or(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            ShortMaxMask m = (ShortMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask xor(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            ShortMaxMask m = (ShortMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ laneIsSet\n-\n-        @Override\n-        @ForceInline\n-        public boolean laneIsSet(int i) {\n-            Objects.checkIndex(i, length());\n-            return VectorSupport.extract(ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static ShortMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final ShortMaxMask  TRUE_MASK = new ShortMaxMask(true);\n-        private static final ShortMaxMask FALSE_MASK = new ShortMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class ShortMaxShuffle extends AbstractShuffle<Short> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n-\n-        ShortMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public ShortMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public ShortMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public ShortMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public ShortSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final ShortMaxShuffle IOTA = new ShortMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ShortMaxVector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n-            ShortMaxShuffle s = (ShortMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new ShortMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromArray0(short[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m, int offsetInRange) {\n-        return super.fromArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromCharArray0(char[] a, int offset) {\n-        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m, int offsetInRange) {\n-        return super.fromCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(short[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(short[] a, int offset, VectorMask<Short> m) {\n-        super.intoArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n-        super.intoMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {\n-        super.intoCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);\n-    }\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":0,"deletions":931,"binary":false,"changes":931,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    ShortVector(short[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public ShortVector() {}\n@@ -96,3 +96,0 @@\n-    \/*package-private*\/\n-    abstract short[] vec();\n-\n@@ -103,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -106,1 +103,1 @@\n-    abstract ShortVector vectorFactory(short[] vec);\n+    abstract ShortVector vectorFactory(VectorPayloadMF vec);\n@@ -115,2 +112,2 @@\n-    AbstractMask<Short> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Short> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -127,1 +124,1 @@\n-    ShortVector vOp(FVOp f) {\n+    ShortVector vOpMF(FVOp f) {\n@@ -132,1 +129,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +135,1 @@\n-    ShortVector vOp(VectorMask<Short> m, FVOp f) {\n+    ShortVector vOpMF(VectorMask<Short> m, FVOp f) {\n@@ -139,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -141,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -145,1 +144,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +157,1 @@\n-    ShortVector uOp(FUnOp f);\n+    ShortVector uOpMF(FUnOp f);\n@@ -160,5 +160,8 @@\n-    ShortVector uOpTemplate(FUnOp f) {\n-        short[] vec = vec();\n-        short[] res = new short[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    ShortVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v));\n@@ -166,1 +169,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +175,1 @@\n-    ShortVector uOp(VectorMask<Short> m,\n+    ShortVector uOpMF(VectorMask<Short> m,\n@@ -175,1 +179,1 @@\n-    ShortVector uOpTemplate(VectorMask<Short> m,\n+    ShortVector uOpTemplateMF(VectorMask<Short> m,\n@@ -178,1 +182,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,5 +184,10 @@\n-        short[] vec = vec();\n-        short[] res = new short[length()];\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -186,1 +195,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +208,1 @@\n-    ShortVector bOp(Vector<Short> o,\n+    ShortVector bOpMF(Vector<Short> o,\n@@ -202,1 +212,1 @@\n-    ShortVector bOpTemplate(Vector<Short> o,\n+    ShortVector bOpTemplateMF(Vector<Short> o,\n@@ -204,5 +214,9 @@\n-        short[] res = new short[length()];\n-        short[] vec1 = this.vec();\n-        short[] vec2 = ((ShortVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +224,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +230,1 @@\n-    ShortVector bOp(Vector<Short> o,\n+    ShortVector bOpMF(Vector<Short> o,\n@@ -220,1 +235,1 @@\n-    ShortVector bOpTemplate(Vector<Short> o,\n+    ShortVector bOpTemplateMF(Vector<Short> o,\n@@ -224,1 +239,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,6 +241,12 @@\n-        short[] res = new short[length()];\n-        short[] vec1 = this.vec();\n-        short[] vec2 = ((ShortVector)o).vec();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -233,1 +254,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +267,1 @@\n-    ShortVector tOp(Vector<Short> o1,\n+    ShortVector tOpMF(Vector<Short> o1,\n@@ -250,1 +272,1 @@\n-    ShortVector tOpTemplate(Vector<Short> o1,\n+    ShortVector tOpTemplateMF(Vector<Short> o1,\n@@ -253,6 +275,11 @@\n-        short[] res = new short[length()];\n-        short[] vec1 = this.vec();\n-        short[] vec2 = ((ShortVector)o1).vec();\n-        short[] vec3 = ((ShortVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ShortVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v3 = Unsafe.getUnsafe().getShort(vec3, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +287,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +293,1 @@\n-    ShortVector tOp(Vector<Short> o1,\n+    ShortVector tOpMF(Vector<Short> o1,\n@@ -271,1 +299,1 @@\n-    ShortVector tOpTemplate(Vector<Short> o1,\n+    ShortVector tOpTemplateMF(Vector<Short> o1,\n@@ -276,1 +304,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,7 +306,14 @@\n-        short[] res = new short[length()];\n-        short[] vec1 = this.vec();\n-        short[] vec2 = ((ShortVector)o1).vec();\n-        short[] vec3 = ((ShortVector)o2).vec();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ShortVector)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v3 = Unsafe.getUnsafe().getShort(vec3, vOffset + i * Short.BYTES);\n+            short v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f);\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    short rOpTemplate(short v, VectorMask<Short> m, FBinOp f) {\n+    short rOpTemplateMF(short v, VectorMask<Short> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,4 +337,8 @@\n-        short[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -311,4 +351,7 @@\n-    short rOpTemplate(short v, FBinOp f) {\n-        short[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    short rOpTemplateMF(short v, FBinOp f) {\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +372,1 @@\n-    <M> ShortVector ldOp(M memory, int offset,\n+    <M> ShortVector ldOpMF(M memory, int offset,\n@@ -331,4 +374,7 @@\n-        \/\/dummy; no vec = vec();\n-        short[] res = new short[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                short.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +382,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +389,1 @@\n-    <M> ShortVector ldOp(M memory, int offset,\n+    <M> ShortVector ldOpMF(M memory, int offset,\n@@ -345,6 +392,10 @@\n-        \/\/short[] vec = vec();\n-        short[] res = new short[length()];\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                short.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +404,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +408,1 @@\n+\n@@ -364,1 +417,1 @@\n-    ShortVector ldLongOp(MemorySegment memory, long offset,\n+    ShortVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +419,7 @@\n-        \/\/dummy; no vec = vec();\n-        short[] res = new short[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                short.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +427,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +434,1 @@\n-    ShortVector ldLongOp(MemorySegment memory, long offset,\n+    ShortVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,6 +437,10 @@\n-        \/\/short[] vec = vec();\n-        short[] res = new short[length()];\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                short.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +449,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +464,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +466,5 @@\n-        short[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -411,1 +475,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +477,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,5 +480,8 @@\n-        short[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -425,0 +492,1 @@\n+\n@@ -432,1 +500,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +502,5 @@\n-        short[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -443,1 +513,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,5 +516,8 @@\n-        short[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -469,1 +542,1 @@\n-    AbstractMask<Short> bTest(int cond,\n+    AbstractMask<Short> bTestMF(int cond,\n@@ -472,5 +545,11 @@\n-        short[] vec1 = vec();\n-        short[] vec2 = ((ShortVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        int length = vspecies().length();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -478,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -565,1 +645,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -725,1 +805,1 @@\n-                    v0.uOp(m, (i, a) -> (short) -a);\n+                    v0.uOpMF(m, (i, a) -> (short) -a);\n@@ -727,1 +807,1 @@\n-                    v0.uOp(m, (i, a) -> (short) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (short) Math.abs(a));\n@@ -729,1 +809,1 @@\n-                    v0.uOp(m, (i, a) -> (short) bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> (short) bitCount(a));\n@@ -731,1 +811,1 @@\n-                    v0.uOp(m, (i, a) -> (short) numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (short) numberOfTrailingZeros(a));\n@@ -733,1 +813,1 @@\n-                    v0.uOp(m, (i, a) -> (short) numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (short) numberOfLeadingZeros(a));\n@@ -735,1 +815,1 @@\n-                    v0.uOp(m, (i, a) -> reverse(a));\n+                    v0.uOpMF(m, (i, a) -> reverse(a));\n@@ -737,1 +817,1 @@\n-                    v0.uOp(m, (i, a) -> (short) Short.reverseBytes(a));\n+                    v0.uOpMF(m, (i, a) -> (short) Short.reverseBytes(a));\n@@ -787,1 +867,1 @@\n-            BIN_IMPL.find(op, opc, ShortVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, ShortVector::binaryOperationsMF));\n@@ -847,1 +927,35 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+            default: return null;\n+        }\n+    }\n+\n+    private static BinaryOperation<ShortVector, VectorMask<Short>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a + b));\n@@ -849,1 +963,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a - b));\n@@ -851,1 +965,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a * b));\n@@ -853,1 +967,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a \/ b));\n@@ -855,1 +969,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.max(a, b));\n@@ -857,1 +971,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.min(a, b));\n@@ -859,1 +973,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a & b));\n@@ -861,1 +975,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a | b));\n@@ -863,1 +977,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a ^ b));\n@@ -865,1 +979,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (short)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)(a << n));\n@@ -867,1 +981,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (short)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)(a >> n));\n@@ -869,1 +983,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n@@ -871,1 +985,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -873,1 +987,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -878,0 +992,1 @@\n+\n@@ -1042,1 +1157,1 @@\n-                    v.uOp(m, (i, a) -> (short)(a << n));\n+                    v.uOpMF(m, (i, a) -> (short)(a << n));\n@@ -1044,1 +1159,1 @@\n-                    v.uOp(m, (i, a) -> (short)(a >> n));\n+                    v.uOpMF(m, (i, a) -> (short)(a >> n));\n@@ -1046,1 +1161,1 @@\n-                    v.uOp(m, (i, a) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1048,1 +1163,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -1050,1 +1165,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -2050,1 +2165,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2072,1 +2187,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2201,1 +2316,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2408,1 +2523,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2440,1 +2555,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2468,1 +2583,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2476,1 +2591,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2818,1 +2933,1 @@\n-                    toBits(v.rOp((short)0, m, (i, a, b) -> (short)(a + b)));\n+                    toBits(v.rOpMF((short)0, m, (i, a, b) -> (short)(a + b)));\n@@ -2820,1 +2935,1 @@\n-                    toBits(v.rOp((short)1, m, (i, a, b) -> (short)(a * b)));\n+                    toBits(v.rOpMF((short)1, m, (i, a, b) -> (short)(a * b)));\n@@ -2822,1 +2937,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (short) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (short) Math.min(a, b)));\n@@ -2824,1 +2939,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (short) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (short) Math.max(a, b)));\n@@ -2826,1 +2941,1 @@\n-                    toBits(v.rOp((short)-1, m, (i, a, b) -> (short)(a & b)));\n+                    toBits(v.rOpMF((short)-1, m, (i, a, b) -> (short)(a & b)));\n@@ -2828,1 +2943,1 @@\n-                    toBits(v.rOp((short)0, m, (i, a, b) -> (short)(a | b)));\n+                    toBits(v.rOpMF((short)0, m, (i, a, b) -> (short)(a | b)));\n@@ -2830,1 +2945,1 @@\n-                    toBits(v.rOp((short)0, m, (i, a, b) -> (short)(a ^ b)));\n+                    toBits(v.rOpMF((short)0, m, (i, a, b) -> (short)(a ^ b)));\n@@ -2978,1 +3093,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -3009,1 +3124,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3013,1 +3128,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3053,1 +3168,1 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3099,1 +3214,1 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3124,1 +3239,1 @@\n-        return vsp.dummyVector().fromCharArray0(a, offset);\n+        return vsp.dummyVectorMF().fromCharArray0(a, offset);\n@@ -3157,1 +3272,1 @@\n-            return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3161,1 +3276,1 @@\n-        return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3202,1 +3317,1 @@\n-        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3249,1 +3364,1 @@\n-        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3291,1 +3406,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3349,1 +3464,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -3353,1 +3468,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -3383,1 +3498,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3385,0 +3500,1 @@\n+\n@@ -3456,1 +3572,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -3498,1 +3614,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -3531,1 +3647,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3608,1 +3724,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -3653,1 +3769,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -3732,1 +3848,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3749,1 +3865,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3765,1 +3881,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3782,1 +3898,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3797,1 +3913,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, ShortVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, ShortVector::memorySegmentGet);\n@@ -3813,1 +3929,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);\n@@ -3832,1 +3948,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3849,1 +3965,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3864,1 +3980,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, ShortVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, ShortVector::memorySegmentSet);\n@@ -3881,1 +3997,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, ShortVector::memorySegmentSet);\n@@ -3899,1 +4015,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -4136,1 +4252,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -4187,1 +4303,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -4202,2 +4318,2 @@\n-        ShortVector dummyVector() {\n-            return (ShortVector) super.dummyVector();\n+        ShortVector dummyVectorMF() {\n+            return (ShortVector) super.dummyVectorMF();\n@@ -4209,1 +4325,1 @@\n-        ShortVector rvOp(RVOp f) {\n+        ShortVector rvOpMF(RVOp f) {\n@@ -4215,1 +4331,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4218,1 +4335,1 @@\n-        ShortVector vOp(FVOp f) {\n+        ShortVector vOpMF(FVOp f) {\n@@ -4223,1 +4340,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4226,1 +4344,1 @@\n-        ShortVector vOp(VectorMask<Short> m, FVOp f) {\n+        ShortVector vOpMF(VectorMask<Short> m, FVOp f) {\n@@ -4228,1 +4346,2 @@\n-            boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -4230,1 +4349,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -4234,1 +4353,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4239,1 +4359,1 @@\n-        <M> ShortVector ldOp(M memory, int offset,\n+        <M> ShortVector ldOpMF(M memory, int offset,\n@@ -4241,1 +4361,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -4246,1 +4366,1 @@\n-        <M> ShortVector ldOp(M memory, int offset,\n+        <M> ShortVector ldOpMF(M memory, int offset,\n@@ -4249,1 +4369,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -4252,0 +4372,1 @@\n+\n@@ -4254,1 +4375,1 @@\n-        ShortVector ldLongOp(MemorySegment memory, long offset,\n+        ShortVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -4256,1 +4377,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -4261,1 +4382,1 @@\n-        ShortVector ldLongOp(MemorySegment memory, long offset,\n+        ShortVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -4264,1 +4385,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -4269,2 +4390,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -4275,2 +4396,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Short> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Short> m,\n@@ -4278,1 +4399,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -4281,0 +4402,1 @@\n+\n@@ -4283,2 +4405,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -4289,1 +4411,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -4292,1 +4414,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -4306,2 +4428,3 @@\n-            if ((Class<?>) vectorType() == ShortMaxVector.class)\n-                return ShortMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n+            \/\/    return ShortMaxVector.ZERO;\n@@ -4320,2 +4443,3 @@\n-            if ((Class<?>) vectorType() == ShortMaxVector.class)\n-                return ShortMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n+            \/\/    return ShortMaxVector.IOTA;\n@@ -4335,2 +4459,3 @@\n-            if ((Class<?>) vectorType() == ShortMaxVector.class)\n-                return ShortMaxVector.ShortMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n+            \/\/    return ShortMaxVector.ShortMaxMask.maskAll(bit);\n@@ -4345,0 +4470,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            short [] init = new short[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (short)i;\n+            }\n+           return init;\n+        }\n@@ -4361,1 +4496,2 @@\n-            case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n@@ -4395,1 +4531,2 @@\n-    public static final VectorSpecies<Short> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Short> SPECIES_MAX\n@@ -4400,0 +4537,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":386,"deletions":248,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -1174,1 +1174,1 @@\n-@SuppressWarnings(\"exports\")\n+@SuppressWarnings({\"exports\", \"missing-explicit-ctor\"})\n@@ -1177,5 +1177,4 @@\n-    \/\/ This type is sealed within its package.\n-    \/\/ Users cannot roll their own vector types.\n-    Vector(Object bits) {\n-        super(bits);\n-    }\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public Vector() {}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,5 @@\n-    VectorMask(boolean[] bits) { super(bits); }\n+\n+    \/**\n+     * Default Constructor for abstract VectorMask.\n+     *\/\n+    public VectorMask() {}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,3 +136,4 @@\n-    VectorShuffle(byte[] reorder) {\n-        super(reorder);\n-    }\n+    \/**\n+     * Default Constructor for abstract VectorShuffle.\n+     *\/\n+    public VectorShuffle() {}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    $abstractvectortype$($type$[] vec) {\n-        super(vec);\n-    }\n-\n@@ -63,0 +59,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public $abstractvectortype$() {}\n@@ -100,3 +100,0 @@\n-    \/*package-private*\/\n-    abstract $type$[] vec();\n-\n@@ -107,1 +104,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -110,1 +107,1 @@\n-    abstract $abstractvectortype$ vectorFactory($type$[] vec);\n+    abstract $abstractvectortype$ vectorFactory(VectorPayloadMF vec);\n@@ -119,2 +116,2 @@\n-    AbstractMask<$Boxtype$> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<$Boxtype$> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -131,1 +128,1 @@\n-    $abstractvectortype$ vOp(FVOp f) {\n+    $abstractvectortype$ vOpMF(FVOp f) {\n@@ -136,1 +133,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -141,1 +139,1 @@\n-    $abstractvectortype$ vOp(VectorMask<$Boxtype$> m, FVOp f) {\n+    $abstractvectortype$ vOpMF(VectorMask<$Boxtype$> m, FVOp f) {\n@@ -143,1 +141,2 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -145,1 +144,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -149,1 +148,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -161,1 +161,1 @@\n-    $abstractvectortype$ uOp(FUnOp f);\n+    $abstractvectortype$ uOpMF(FUnOp f);\n@@ -164,5 +164,8 @@\n-    $abstractvectortype$ uOpTemplate(FUnOp f) {\n-        $type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    $abstractvectortype$ uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v));\n@@ -170,1 +173,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -175,1 +179,1 @@\n-    $abstractvectortype$ uOp(VectorMask<$Boxtype$> m,\n+    $abstractvectortype$ uOpMF(VectorMask<$Boxtype$> m,\n@@ -179,1 +183,1 @@\n-    $abstractvectortype$ uOpTemplate(VectorMask<$Boxtype$> m,\n+    $abstractvectortype$ uOpTemplateMF(VectorMask<$Boxtype$> m,\n@@ -182,1 +186,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -184,5 +188,10 @@\n-        $type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -190,1 +199,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -202,1 +212,1 @@\n-    $abstractvectortype$ bOp(Vector<$Boxtype$> o,\n+    $abstractvectortype$ bOpMF(Vector<$Boxtype$> o,\n@@ -206,1 +216,1 @@\n-    $abstractvectortype$ bOpTemplate(Vector<$Boxtype$> o,\n+    $abstractvectortype$ bOpTemplateMF(Vector<$Boxtype$> o,\n@@ -208,5 +218,9 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v1, v2));\n@@ -214,1 +228,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -219,1 +234,1 @@\n-    $abstractvectortype$ bOp(Vector<$Boxtype$> o,\n+    $abstractvectortype$ bOpMF(Vector<$Boxtype$> o,\n@@ -224,1 +239,1 @@\n-    $abstractvectortype$ bOpTemplate(Vector<$Boxtype$> o,\n+    $abstractvectortype$ bOpTemplateMF(Vector<$Boxtype$> o,\n@@ -228,1 +243,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -230,6 +245,12 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -237,1 +258,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -249,1 +271,1 @@\n-    $abstractvectortype$ tOp(Vector<$Boxtype$> o1,\n+    $abstractvectortype$ tOpMF(Vector<$Boxtype$> o1,\n@@ -254,1 +276,1 @@\n-    $abstractvectortype$ tOpTemplate(Vector<$Boxtype$> o1,\n+    $abstractvectortype$ tOpTemplateMF(Vector<$Boxtype$> o1,\n@@ -257,6 +279,11 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o1).vec();\n-        $type$[] vec3 = (($abstractvectortype$)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec();\n+        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v1, v2, v3));\n@@ -264,1 +291,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -269,1 +297,1 @@\n-    $abstractvectortype$ tOp(Vector<$Boxtype$> o1,\n+    $abstractvectortype$ tOpMF(Vector<$Boxtype$> o1,\n@@ -275,1 +303,1 @@\n-    $abstractvectortype$ tOpTemplate(Vector<$Boxtype$> o1,\n+    $abstractvectortype$ tOpTemplateMF(Vector<$Boxtype$> o1,\n@@ -280,1 +308,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -282,7 +310,14 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o1).vec();\n-        $type$[] vec3 = (($abstractvectortype$)o2).vec();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec();\n+        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -290,1 +325,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -297,1 +333,1 @@\n-    $type$ rOp($type$ v, VectorMask<$Boxtype$> m, FBinOp f);\n+    $type$ rOpMF($type$ v, VectorMask<$Boxtype$> m, FBinOp f);\n@@ -301,1 +337,1 @@\n-    $type$ rOpTemplate($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n+    $type$ rOpTemplateMF($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n@@ -303,1 +339,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -305,4 +341,8 @@\n-        $type$[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -315,4 +355,7 @@\n-    $type$ rOpTemplate($type$ v, FBinOp f) {\n-        $type$[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    $type$ rOpTemplateMF($type$ v, FBinOp f) {\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -333,1 +376,1 @@\n-    <M> $abstractvectortype$ ldOp(M memory, int offset,\n+    <M> $abstractvectortype$ ldOpMF(M memory, int offset,\n@@ -335,4 +378,7 @@\n-        \/\/dummy; no vec = vec();\n-        $type$[] res = new $type$[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                $type$.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -340,1 +386,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -346,1 +393,1 @@\n-    <M> $abstractvectortype$ ldOp(M memory, int offset,\n+    <M> $abstractvectortype$ ldOpMF(M memory, int offset,\n@@ -349,6 +396,10 @@\n-        \/\/$type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                $type$.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -357,1 +408,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -360,0 +412,1 @@\n+\n@@ -368,1 +421,1 @@\n-    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+    $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,\n@@ -370,4 +423,7 @@\n-        \/\/dummy; no vec = vec();\n-        $type$[] res = new $type$[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                $type$.class, length));\n+        long vOffset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -375,1 +431,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -381,1 +438,1 @@\n-    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+    $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,\n@@ -384,6 +441,10 @@\n-        \/\/$type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n+                $type$.class, length));\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -392,1 +453,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -406,1 +468,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -408,3 +470,5 @@\n-        $type$[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -415,1 +479,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -417,1 +481,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -420,5 +484,8 @@\n-        $type$[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -429,0 +496,1 @@\n+\n@@ -436,1 +504,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -438,3 +506,5 @@\n-        $type$[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -447,1 +517,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -450,5 +520,8 @@\n-        $type$[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -473,1 +546,1 @@\n-    AbstractMask<$Boxtype$> bTest(int cond,\n+    AbstractMask<$Boxtype$> bTestMF(int cond,\n@@ -476,5 +549,11 @@\n-        $type$[] vec1 = vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        int length = vspecies().length();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -482,1 +561,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -580,1 +660,1 @@\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                        ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -584,1 +664,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -751,1 +831,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) -a);\n+                    v0.uOpMF(m, (i, a) -> ($type$) -a);\n@@ -753,1 +833,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.abs(a));\n@@ -757,1 +837,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.bitCount(a));\n@@ -759,1 +839,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.numberOfTrailingZeros(a));\n@@ -761,1 +841,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.numberOfLeadingZeros(a));\n@@ -763,1 +843,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverse(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.reverse(a));\n@@ -766,1 +846,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) bitCount(a));\n@@ -768,1 +848,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) numberOfTrailingZeros(a));\n@@ -770,1 +850,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) numberOfLeadingZeros(a));\n@@ -772,1 +852,1 @@\n-                    v0.uOp(m, (i, a) -> reverse(a));\n+                    v0.uOpMF(m, (i, a) -> reverse(a));\n@@ -777,1 +857,1 @@\n-                    v0.uOp(m, (i, a) -> a);\n+                    v0.uOpMF(m, (i, a) -> a);\n@@ -780,1 +860,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverseBytes(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.reverseBytes(a));\n@@ -786,1 +866,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sin(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.sin(a));\n@@ -788,1 +868,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cos(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.cos(a));\n@@ -790,1 +870,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.tan(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.tan(a));\n@@ -792,1 +872,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.asin(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.asin(a));\n@@ -794,1 +874,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.acos(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.acos(a));\n@@ -796,1 +876,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.atan(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.atan(a));\n@@ -798,1 +878,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.exp(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.exp(a));\n@@ -800,1 +880,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.log(a));\n@@ -802,1 +882,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log10(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.log10(a));\n@@ -804,1 +884,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sqrt(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.sqrt(a));\n@@ -806,1 +886,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cbrt(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.cbrt(a));\n@@ -808,1 +888,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sinh(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.sinh(a));\n@@ -810,1 +890,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cosh(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.cosh(a));\n@@ -812,1 +892,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.tanh(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.tanh(a));\n@@ -814,1 +894,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.expm1(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.expm1(a));\n@@ -816,1 +896,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log1p(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.log1p(a));\n@@ -871,1 +951,1 @@\n-            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));\n+            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperationsMF));\n@@ -942,1 +1022,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a + b));\n@@ -944,1 +1024,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a - b));\n@@ -946,1 +1026,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a * b));\n@@ -948,1 +1028,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n@@ -950,1 +1030,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n@@ -952,1 +1032,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n@@ -955,1 +1035,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a & b));\n@@ -957,1 +1037,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a | b));\n@@ -959,1 +1039,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n@@ -961,1 +1041,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)(a << n));\n@@ -963,1 +1043,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)(a >> n));\n@@ -965,1 +1045,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n@@ -967,1 +1047,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -969,1 +1049,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -972,1 +1052,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n@@ -974,1 +1054,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n@@ -979,1 +1059,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -981,1 +1061,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n@@ -983,1 +1063,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n@@ -985,1 +1065,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n@@ -991,0 +1071,53 @@\n+    private static BinaryOperation<$abstractvectortype$, VectorMask<$Boxtype$>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n+#if[BITWISE]\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+#if[intOrLong]\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n+#end[intOrLong]\n+#end[BITWISE]\n+#if[FP]\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n+#end[FP]\n+            default: return null;\n+        }\n+    }\n+\n+\n@@ -1170,1 +1303,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)(a << n));\n+                    v.uOpMF(m, (i, a) -> ($type$)(a << n));\n@@ -1172,1 +1305,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)(a >> n));\n+                    v.uOpMF(m, (i, a) -> ($type$)(a >> n));\n@@ -1174,1 +1307,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1176,1 +1309,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -1178,1 +1311,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -1297,1 +1430,1 @@\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+                    v0.tOpMF(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n@@ -2420,1 +2553,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2442,1 +2575,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2575,1 +2708,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2784,1 +2917,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2816,1 +2949,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2844,1 +2977,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2852,1 +2985,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -3323,1 +3456,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a + b)));\n+                    toBits(v.rOpMF(($type$)0, m, (i, a, b) -> ($type$)(a + b)));\n@@ -3325,1 +3458,1 @@\n-                    toBits(v.rOp(($type$)1, m, (i, a, b) -> ($type$)(a * b)));\n+                    toBits(v.rOpMF(($type$)1, m, (i, a, b) -> ($type$)(a * b)));\n@@ -3327,1 +3460,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> ($type$) Math.min(a, b)));\n@@ -3329,1 +3462,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> ($type$) Math.max(a, b)));\n@@ -3332,1 +3465,1 @@\n-                    toBits(v.rOp(($type$)-1, m, (i, a, b) -> ($type$)(a & b)));\n+                    toBits(v.rOpMF(($type$)-1, m, (i, a, b) -> ($type$)(a & b)));\n@@ -3334,1 +3467,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a | b)));\n+                    toBits(v.rOpMF(($type$)0, m, (i, a, b) -> ($type$)(a | b)));\n@@ -3336,1 +3469,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a ^ b)));\n+                    toBits(v.rOpMF(($type$)0, m, (i, a, b) -> ($type$)(a ^ b)));\n@@ -3549,1 +3682,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -3580,1 +3713,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3584,1 +3717,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3625,1 +3758,1 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3645,1 +3778,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3654,1 +3787,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3657,0 +3790,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3677,1 +3812,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -3725,1 +3860,1 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3739,1 +3874,1 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            return vsp.dummyVectorMF().fromArray0(a, offset, indexMap, mapOffset, m);\n@@ -3767,1 +3902,1 @@\n-        return vsp.dummyVector().fromCharArray0(a, offset);\n+        return vsp.dummyVectorMF().fromCharArray0(a, offset);\n@@ -3800,1 +3935,1 @@\n-            return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3804,1 +3939,1 @@\n-        return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -3845,1 +3980,1 @@\n-        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3892,1 +4027,1 @@\n-        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3922,1 +4057,1 @@\n-        return vsp.dummyVector().fromBooleanArray0(a, offset);\n+        return vsp.dummyVectorMF().fromBooleanArray0(a, offset);\n@@ -3959,1 +4094,1 @@\n-            return vsp.dummyVector().fromBooleanArray0(a, offset, m, OFFSET_IN_RANGE);\n+            return vsp.dummyVectorMF().fromBooleanArray0(a, offset, m, OFFSET_IN_RANGE);\n@@ -3963,1 +4098,1 @@\n-        return vsp.dummyVector().fromBooleanArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+        return vsp.dummyVectorMF().fromBooleanArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n@@ -4004,1 +4139,1 @@\n-        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        return vsp.vOpMF(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n@@ -4051,1 +4186,1 @@\n-        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        return vsp.vOpMF(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n@@ -4093,1 +4228,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -4155,1 +4290,1 @@\n-            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+            return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n@@ -4159,1 +4294,1 @@\n-        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+        return vsp.dummyVectorMF().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n@@ -4189,1 +4324,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -4191,0 +4326,1 @@\n+\n@@ -4263,1 +4399,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -4283,1 +4419,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -4291,1 +4427,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -4294,0 +4430,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -4316,1 +4454,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -4360,1 +4498,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -4408,1 +4546,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -4485,1 +4623,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -4530,1 +4668,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -4569,1 +4707,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -4652,1 +4790,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -4700,1 +4838,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -4779,1 +4917,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -4796,1 +4934,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -4824,1 +4962,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -4833,1 +4971,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -4836,0 +4974,2 @@\n+             *\/\n+            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -4857,1 +4997,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -4873,1 +5013,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -4890,1 +5030,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -4907,1 +5047,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -4924,1 +5064,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -4939,1 +5079,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);\n@@ -4955,1 +5095,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);\n@@ -4974,1 +5114,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -4991,1 +5131,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -5015,1 +5155,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -5023,1 +5163,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -5026,0 +5166,3 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n+\n@@ -5049,1 +5192,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -5072,1 +5215,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -5086,1 +5229,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, $abstractvectortype$::memorySegmentSet);\n@@ -5103,1 +5246,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentSet);\n@@ -5122,1 +5265,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -5394,1 +5537,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -5452,1 +5595,1 @@\n-            return dummyVector().fromArray0(va, 0);\n+            return dummyVectorMF().fromArray0(va, 0);\n@@ -5467,2 +5610,2 @@\n-        $abstractvectortype$ dummyVector() {\n-            return ($abstractvectortype$) super.dummyVector();\n+        $abstractvectortype$ dummyVectorMF() {\n+            return ($abstractvectortype$) super.dummyVectorMF();\n@@ -5474,1 +5617,1 @@\n-        $abstractvectortype$ rvOp(RVOp f) {\n+        $abstractvectortype$ rvOpMF(RVOp f) {\n@@ -5480,1 +5623,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -5483,1 +5627,1 @@\n-        $Type$Vector vOp(FVOp f) {\n+        $Type$Vector vOpMF(FVOp f) {\n@@ -5488,1 +5632,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -5491,1 +5636,1 @@\n-        $Type$Vector vOp(VectorMask<$Boxtype$> m, FVOp f) {\n+        $Type$Vector vOpMF(VectorMask<$Boxtype$> m, FVOp f) {\n@@ -5493,1 +5638,2 @@\n-            boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -5495,1 +5641,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -5499,1 +5645,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -5504,1 +5651,1 @@\n-        <M> $abstractvectortype$ ldOp(M memory, int offset,\n+        <M> $abstractvectortype$ ldOpMF(M memory, int offset,\n@@ -5506,1 +5653,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -5511,1 +5658,1 @@\n-        <M> $abstractvectortype$ ldOp(M memory, int offset,\n+        <M> $abstractvectortype$ ldOpMF(M memory, int offset,\n@@ -5514,1 +5661,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -5517,0 +5664,1 @@\n+\n@@ -5519,1 +5667,1 @@\n-        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+        $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,\n@@ -5521,1 +5669,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -5526,1 +5674,1 @@\n-        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+        $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,\n@@ -5529,1 +5677,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -5534,2 +5682,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -5540,2 +5688,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<$Boxtype$> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<$Boxtype$> m,\n@@ -5543,1 +5691,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -5546,0 +5694,1 @@\n+\n@@ -5548,2 +5697,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -5554,1 +5703,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -5557,1 +5706,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -5571,2 +5720,3 @@\n-            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-                return $Type$MaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+            \/\/    return $Type$MaxVector.ZERO;\n@@ -5585,2 +5735,3 @@\n-            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-                return $Type$MaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+            \/\/    return $Type$MaxVector.IOTA;\n@@ -5600,2 +5751,3 @@\n-            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-                return $Type$MaxVector.$Type$MaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+            \/\/    return $Type$MaxVector.$Type$MaxMask.maskAll(bit);\n@@ -5610,0 +5762,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            $type$ [] init = new $type$[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = ($type$)i;\n+            }\n+           return init;\n+        }\n@@ -5626,1 +5788,2 @@\n-            case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;\n@@ -5660,1 +5823,2 @@\n-    public static final VectorSpecies<$Boxtype$> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<$Boxtype$> SPECIES_MAX\n@@ -5665,0 +5829,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":466,"deletions":301,"binary":false,"changes":767,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class $vectortype$ extends $abstractvectortype$ {\n+value class $vectortype$ extends $abstractvectortype$ {\n@@ -57,2 +58,6 @@\n-    $vectortype$($type$[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorPayloadMF$bits$$Boxinitials$.class);\n+\n+    private final VectorPayloadMF$bits$$Boxinitials$ payload;\n+\n+    $vectortype$(Object value) {\n+        this.payload = (VectorPayloadMF$bits$$Boxinitials$) value;\n@@ -61,4 +66,4 @@\n-    \/\/ For compatibility as $vectortype$::new,\n-    \/\/ stored into species.vectorFactory.\n-    $vectortype$(Object v) {\n-        this(($type$[]) v);\n+    @ForceInline\n+    @Override\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -67,2 +72,2 @@\n-    static final $vectortype$ ZERO = new $vectortype$(new $type$[VLENGTH]);\n-    static final $vectortype$ IOTA = new $vectortype$(VSPECIES.iotaArray());\n+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.newInstanceFactory($type$.class, $numLanes$));\n+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$[])(VSPECIES.iotaArray())));\n@@ -74,1 +79,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,1 +118,0 @@\n-    \/*package-private*\/\n@@ -115,6 +119,2 @@\n-    final @Override\n-    $type$[] vec() {\n-        return ($type$[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n@@ -138,2 +138,2 @@\n-    $masktype$ maskFromArray(boolean[] bits) {\n-        return new $masktype$(bits);\n+    $masktype$ maskFromPayload(VectorPayloadMF payload) {\n+        return new $masktype$(payload);\n@@ -159,1 +159,1 @@\n-    $shuffletype$ shuffleFromBytes(byte[] reorder) { return new $shuffletype$(reorder); }\n+    $shuffletype$ shuffleFromBytes(VectorPayloadMF indexes) { return new $shuffletype$(indexes); }\n@@ -172,1 +172,1 @@\n-    $vectortype$ vectorFactory($type$[] vec) {\n+    $vectortype$ vectorFactory(VectorPayloadMF vec) {\n@@ -192,2 +192,2 @@\n-    $vectortype$ uOp(FUnOp f) {\n-        return ($vectortype$) super.uOpTemplate(f);  \/\/ specialize\n+    $vectortype$ uOpMF(FUnOp f) {\n+        return ($vectortype$) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -198,1 +198,1 @@\n-    $vectortype$ uOp(VectorMask<$Boxtype$> m, FUnOp f) {\n+    $vectortype$ uOpMF(VectorMask<$Boxtype$> m, FUnOp f) {\n@@ -200,1 +200,1 @@\n-            super.uOpTemplate(($masktype$)m, f);  \/\/ specialize\n+            super.uOpTemplateMF(($masktype$)m, f);  \/\/ specialize\n@@ -207,2 +207,2 @@\n-    $vectortype$ bOp(Vector<$Boxtype$> v, FBinOp f) {\n-        return ($vectortype$) super.bOpTemplate(($vectortype$)v, f);  \/\/ specialize\n+    $vectortype$ bOpMF(Vector<$Boxtype$> v, FBinOp f) {\n+        return ($vectortype$) super.bOpTemplateMF(($vectortype$)v, f);  \/\/ specialize\n@@ -213,1 +213,1 @@\n-    $vectortype$ bOp(Vector<$Boxtype$> v,\n+    $vectortype$ bOpMF(Vector<$Boxtype$> v,\n@@ -216,2 +216,2 @@\n-            super.bOpTemplate(($vectortype$)v, ($masktype$)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF(($vectortype$)v, ($masktype$)m,\n+                                f);  \/\/ specialize\n@@ -224,1 +224,1 @@\n-    $vectortype$ tOp(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2, FTriOp f) {\n+    $vectortype$ tOpMF(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2, FTriOp f) {\n@@ -226,2 +226,2 @@\n-            super.tOpTemplate(($vectortype$)v1, ($vectortype$)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF(($vectortype$)v1, ($vectortype$)v2,\n+                                f);  \/\/ specialize\n@@ -232,1 +232,1 @@\n-    $vectortype$ tOp(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2,\n+    $vectortype$ tOpMF(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2,\n@@ -235,2 +235,2 @@\n-            super.tOpTemplate(($vectortype$)v1, ($vectortype$)v2,\n-                              ($masktype$)m, f);  \/\/ specialize\n+            super.tOpTemplateMF(($vectortype$)v1, ($vectortype$)v2,\n+                                ($masktype$)m, f);  \/\/ specialize\n@@ -241,2 +241,2 @@\n-    $type$ rOp($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    $type$ rOpMF($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -563,2 +563,3 @@\n-                     $type$[] vecarr = vec.vec();\n-                     return (long)$Type$.$type$To$Bitstype$Bits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)$Type$.$type$To$Bitstype$Bits(Unsafe.getUnsafe().get$Type$(vecpayload, start_offset + ix * $Boxtype$.BYTES));\n@@ -612,3 +613,6 @@\n-                                    $type$[] res = v.vec().clone();\n-                                    res[ix] = $Type$.$bitstype$BitsTo$Type$(($bitstype$)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().put$Type$(tpayload, start_offset + ix * $Boxtype$.BYTES, $Type$.$bitstype$BitsTo$Type$(($bitstype$)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -711,6 +715,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    $type$[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().get$Type$(vecpayload, start_offset + ix * $Boxtype$.BYTES);\n+                             });\n@@ -811,1 +816,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -815,3 +820,6 @@\n-                                    $type$[] res = v.vec().clone();\n-                                    res[ix] = ($type$)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().put$Type$(tpayload, start_offset + ix * $Boxtype$.BYTES, ($type$)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -824,1 +832,1 @@\n-    static final class $masktype$ extends AbstractMask<$Boxtype$> {\n+    static final value class $masktype$ extends AbstractMask<$Boxtype$> {\n@@ -828,7 +836,1 @@\n-        $masktype$(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        $masktype$(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n+        private final VectorPayloadMF$vectorsizeinbytes$Z payload;\n@@ -836,2 +838,2 @@\n-        $masktype$(boolean val) {\n-            super(prepare(val));\n+        $masktype$(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$Z) payload;\n@@ -840,6 +842,2 @@\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        $masktype$(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -848,4 +846,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        $masktype$(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -864,4 +860,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -869,18 +861,2 @@\n-        $masktype$ uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new $masktype$(res);\n-        }\n-\n-        @Override\n-        $masktype$ bOp(VectorMask<$Boxtype$> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = (($masktype$)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new $masktype$(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -896,27 +872,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -943,1 +892,1 @@\n-            return ($masktype$)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return ($masktype$) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -956,3 +905,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOpMF(m2, (i, a, b) -> a & b));\n@@ -966,3 +915,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOpMF(m2, (i, a, b) -> a | b));\n@@ -976,3 +925,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOpMF(m2, (i, a, b) -> a ^ b));\n@@ -987,1 +936,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).trueCountHelper());\n@@ -994,1 +943,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).firstTrueHelper());\n@@ -1001,1 +950,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).lastTrueHelper());\n@@ -1011,1 +960,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> (($masktype$) m).toLongHelper());\n@@ -1021,1 +970,1 @@\n-                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+                                         this, i, (m, idx) -> ((($masktype$) m).laneIsSetHelper(idx) ? 1L : 0L)) == 1L;\n@@ -1031,1 +980,1 @@\n-                                         (m, __) -> anyTrueHelper((($masktype$)m).getBits()));\n+                                         (m, __) -> (($masktype$) m).anyTrueHelper());\n@@ -1039,1 +988,1 @@\n-                                         (m, __) -> allTrueHelper((($masktype$)m).getBits()));\n+                                         (m, __) -> (($masktype$) m).allTrueHelper());\n@@ -1054,3 +1003,5 @@\n-        static boolean[] maskLowerHalf() {\n-            boolean[] a = new boolean[VLENGTH];\n-            int len = a.length >> 1;\n+        static VectorPayloadMF maskLowerHalf() {\n+            VectorPayloadMF newObj = VectorPayloadMF.newInstanceFactory(boolean.class, VLENGTH);\n+            newObj = Unsafe.getUnsafe().makePrivateBuffer(newObj);\n+            long mf_offset = newObj.multiFieldOffset();\n+            int len = VLENGTH >> 1;\n@@ -1058,1 +1009,1 @@\n-                a[i] = true;\n+                Unsafe.getUnsafe().putBoolean(newObj, mf_offset + i, true);\n@@ -1060,1 +1011,2 @@\n-            return a;\n+            newObj = Unsafe.getUnsafe().finishPrivateBuffer(newObj);\n+            return newObj;\n@@ -1071,1 +1023,1 @@\n-    static final class $shuffletype$ extends AbstractShuffle<$Boxtype$> {\n+    static final value class $shuffletype$ extends AbstractShuffle<$Boxtype$> {\n@@ -1075,2 +1027,6 @@\n-        $shuffletype$(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF$vectorsizeinbytes$B payload;\n+\n+        $shuffletype$(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$B) payload;\n+            assert(VLENGTH == payload.length());\n+            assert(indexesInRange(payload));\n@@ -1079,2 +1035,2 @@\n-        public $shuffletype$(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        public $shuffletype$(int[] indexes) {\n+            this(indexes, 0);\n@@ -1083,2 +1039,2 @@\n-        public $shuffletype$(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        public $shuffletype$(int[] indexes, int i) {\n+            this(prepare(VLENGTH, indexes, i));\n@@ -1088,1 +1044,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF indices() {\n+            return payload;\n@@ -1125,6 +1087,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF indices1 = indices();\n+            VectorPayloadMF indices2 = s.indices();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(indices2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(indices1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -1132,0 +1097,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":124,"deletions":158,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+  Boxinitials=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})\"\n+  Boxbitsinitials=$Boxinitials\n@@ -109,0 +111,1 @@\n+      Boxbitsinitials=I\n@@ -117,0 +120,1 @@\n+      Boxbitsinitials=L\n@@ -122,1 +126,1 @@\n-  args=\"$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n+  args=\"$args -K$kind -DBoxtype=$Boxtype -DBoxinitials=$Boxinitials -DBoxbitsinitials=$Boxbitsinitials -DWideboxtype=$Wideboxtype\"\n@@ -147,1 +151,2 @@\n-  for bits in 64 128 256 512 Max\n+  # for bits in 64 128 256 512 Max\n+  for bits in 64 128 256 512\n@@ -155,0 +160,1 @@\n+    vectorsizeinbytes=$((bits \/ sizeInBytes))\n@@ -193,1 +199,1 @@\n-    bitargs=\"$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape\"\n+    bitargs=\"$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -DnumLanes=$numLanes  -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape -Dvectorsizeinbytes=$vectorsizeinbytes\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ByteMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch ByteMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation DoubleMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch DoubleMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation IntMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch IntMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation LongMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch LongMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ShortMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch ShortMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  for bits in 64 128 256 512 Max\n+  for bits in 64 128 256 512\n@@ -211,1 +211,1 @@\n-  for bits in 64 128 256 512 Max\n+  for bits in 64 128 256 512\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}