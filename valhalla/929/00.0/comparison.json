{"files":[{"patch":"@@ -1257,3 +1257,3 @@\n-void InterpreterMacroAssembler::read_inlined_field(Register holder_klass,\n-                                                     Register field_index, Register field_offset,\n-                                                     Register obj) {\n+void InterpreterMacroAssembler::read_flat_field(Register holder_klass,\n+                                                Register field_index, Register field_offset,\n+                                                Register obj) {\n@@ -1297,1 +1297,1 @@\n-  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_inlined_field),\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flat_field),\n@@ -1303,3 +1303,3 @@\n-void InterpreterMacroAssembler::read_flattened_element(Register array, Register index,\n-                                                       Register t1, Register t2,\n-                                                       Register obj) {\n+void InterpreterMacroAssembler::read_flat_element(Register array, Register index,\n+                                                  Register t1, Register t2,\n+                                                  Register obj) {\n@@ -2180,1 +2180,1 @@\n-    test_non_flattened_array_oop(array, tmp, not_flat);\n+    test_non_flat_array_oop(array, tmp, not_flat);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  _original_holder(nullptr), _is_flattened(false), _known_to_link_with_put(nullptr), _known_to_link_with_get(nullptr) {\n+  _original_holder(nullptr), _is_flat(false), _known_to_link_with_put(nullptr), _known_to_link_with_get(nullptr) {\n@@ -239,1 +239,1 @@\n-  \/\/ Trust final flattened fields\n+  \/\/ Trust final flat fields\n@@ -244,2 +244,2 @@\n-  assert(!field->is_flattened(), \"field must not be flattened\");\n-  _is_flattened = false;\n+  assert(!field->is_flat(), \"field must not be flat\");\n+  _is_flat = false;\n@@ -299,2 +299,2 @@\n-  _is_flattened = fd->is_inlined();\n-  _is_null_free = fd->signature()->is_Q_signature();\n+  _is_flat = fd->is_flat();\n+  _is_null_free = fd->is_null_free_inline_type();\n@@ -503,1 +503,1 @@\n-  tty->print(\" is_flattened=%s\", bool_to_str(_is_flattened));\n+  tty->print(\" is_flat=%s\", bool_to_str(_is_flat));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  ciInstanceKlass* _original_holder; \/\/ For flattened fields\n+  ciInstanceKlass* _original_holder; \/\/ For fields nested in flat fields\n@@ -55,1 +55,1 @@\n-  bool             _is_flattened;\n+  bool             _is_flat;\n@@ -184,1 +184,1 @@\n-  bool is_flattened            () const { return _is_flattened; }\n+  bool is_flat                 () const { return _is_flat; }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,2 +50,1 @@\n-\/\/ belongs to a flattened inline type field, return the index of the field\n-\/\/ in the flattened inline type.\n+\/\/ belongs to a flat field, return the index of the field in the inline type of the flat field.\n@@ -65,1 +64,1 @@\n-      \/\/ flattened inline type field that holds the field we are looking for.\n+      \/\/ flat field that holds the field we are looking for.\n@@ -75,3 +74,3 @@\n-\/\/ Are arrays containing this inline type flattened?\n-bool ciInlineKlass::flatten_array() const {\n-  GUARDED_VM_ENTRY(return to_InlineKlass()->flatten_array();)\n+\/\/ Are arrays containing this inline type flat arrays?\n+bool ciInlineKlass::flat_array() const {\n+  GUARDED_VM_ENTRY(return to_InlineKlass()->flat_array();)\n@@ -93,1 +92,1 @@\n-  \/\/ are not flattened\n+  \/\/ are not flat\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  \/\/ Fields declared in the bytecode (without flattened inline type fields)\n+  \/\/ Fields declared in the bytecode (without nested fields in flat fields)\n@@ -81,1 +81,1 @@\n-  bool flatten_array() const;\n+  bool flat_array() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-ciField* ciInstanceKlass::get_non_flattened_field_by_offset(int field_offset) {\n+ciField* ciInstanceKlass::get_non_flat_field_by_offset(int field_offset) {\n@@ -444,1 +444,1 @@\n-    ciField* f = super()->get_non_flattened_field_by_offset(field_offset);\n+    ciField* f = super()->get_non_flat_field_by_offset(field_offset);\n@@ -565,1 +565,1 @@\n-GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool flatten) {\n+GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool is_flat) {\n@@ -602,1 +602,1 @@\n-    if (fd.is_inlined() && flatten) {\n+    if (fd.is_flat() && is_flat) {\n@@ -609,1 +609,1 @@\n-      \/\/ Iterate over fields of the flattened inline type and copy them to 'this'\n+      \/\/ Iterate over fields of the flat inline type and copy them to 'this'\n@@ -611,1 +611,1 @@\n-        ciField* flattened_field = vk->nonstatic_field_at(i);\n+        ciField* flat_field = vk->nonstatic_field_at(i);\n@@ -613,2 +613,2 @@\n-        int offset = field_offset + (flattened_field->offset_in_bytes() - vk->first_field_offset());\n-        \/\/ A flattened field can be treated as final if the non-flattened\n+        int offset = field_offset + (flat_field->offset_in_bytes() - vk->first_field_offset());\n+        \/\/ A flat field can be treated as final if the non-flat\n@@ -618,1 +618,1 @@\n-        ciType* ftype = flattened_field->type();\n+        ciType* ftype = flat_field->type();\n@@ -623,3 +623,3 @@\n-        if (flattened_field->is_multifield_base() && !scalarize_multifield) {\n-          field = new (arena) ciMultiField(flattened_field, this, offset, is_final);\n-          static_cast<ciMultiField*>(field)->set_secondary_fields(static_cast<ciMultiField*>(flattened_field)->secondary_fields());\n+        if (flat_field->is_multifield_base() && !scalarize_multifield) {\n+          field = new (arena) ciMultiField(flat_field, this, offset, is_final);\n+          static_cast<ciMultiField*>(field)->set_secondary_fields(static_cast<ciMultiField*>(flat_field)->secondary_fields());\n@@ -627,1 +627,1 @@\n-          field = new (arena) ciField(flattened_field, this, offset, is_final);\n+          field = new (arena) ciField(flat_field, this, offset, is_final);\n@@ -789,1 +789,1 @@\n-  void do_field_helper(fieldDescriptor* fd, oop obj, bool flattened);\n+  void do_field_helper(fieldDescriptor* fd, oop obj, bool is_flat);\n@@ -826,1 +826,1 @@\n-void StaticFieldPrinter::do_field_helper(fieldDescriptor* fd, oop mirror, bool flattened) {\n+void StaticFieldPrinter::do_field_helper(fieldDescriptor* fd, oop mirror, bool is_flat) {\n@@ -845,0 +845,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall-through\n@@ -846,21 +847,25 @@\n-    case T_OBJECT: {\n-      _out->print(\"%s \", fd->signature()->as_quoted_ascii());\n-      oop value =  mirror->obj_field_acquire(fd->offset());\n-      if (value == nullptr) {\n-        _out->print_cr(\"null\");\n-      } else if (value->is_instance()) {\n-        assert(fd->field_type() == T_OBJECT, \"\");\n-        if (value->is_a(vmClasses::String_klass())) {\n-          const char* ascii_value = java_lang_String::as_quoted_ascii(value);\n-          _out->print(\"\\\"%s\\\"\", (ascii_value != nullptr) ? ascii_value : \"\");\n-         } else {\n-          const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n-          _out->print(\"%s\", klass_name);\n-        }\n-      } else if (value->is_array()) {\n-        typeArrayOop ta = (typeArrayOop)value;\n-        _out->print(\"%d\", ta->length());\n-        if (value->is_objArray() || value->is_flatArray()) {\n-          objArrayOop oa = (objArrayOop)value;\n-          const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n-          _out->print(\" %s\", klass_name);\n+    case T_OBJECT:\n+      if (!fd->is_null_free_inline_type()) {\n+        _out->print(\"%s \", fd->signature()->as_quoted_ascii());\n+        oop value =  mirror->obj_field_acquire(fd->offset());\n+        if (value == nullptr) {\n+          _out->print_cr(\"null\");\n+        } else if (value->is_instance()) {\n+          assert(fd->field_type() == T_OBJECT, \"\");\n+          if (value->is_a(vmClasses::String_klass())) {\n+            const char* ascii_value = java_lang_String::as_quoted_ascii(value);\n+            _out->print(\"\\\"%s\\\"\", (ascii_value != nullptr) ? ascii_value : \"\");\n+          } else {\n+            const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n+            _out->print(\"%s\", klass_name);\n+          }\n+        } else if (value->is_array()) {\n+          typeArrayOop ta = (typeArrayOop)value;\n+          _out->print(\"%d\", ta->length());\n+          if (value->is_objArray() || value->is_flatArray()) {\n+            objArrayOop oa = (objArrayOop)value;\n+            const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n+            _out->print(\" %s\", klass_name);\n+          }\n+        } else {\n+          ShouldNotReachHere();\n@@ -868,0 +873,1 @@\n+        break;\n@@ -869,22 +875,22 @@\n-        ShouldNotReachHere();\n-      }\n-      break;\n-    }\n-    case T_PRIMITIVE_OBJECT: {\n-      ResetNoHandleMark rnhm;\n-      Thread* THREAD = Thread::current();\n-      SignatureStream ss(fd->signature(), false);\n-      Symbol* name = ss.as_symbol();\n-      assert(!HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n-      InstanceKlass* holder = fd->field_holder();\n-      InstanceKlass* k = SystemDictionary::find_instance_klass(THREAD, name,\n-                                                               Handle(THREAD, holder->class_loader()),\n-                                                               Handle(THREAD, holder->protection_domain()));\n-      assert(k != nullptr && !HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n-      InlineKlass* vk = InlineKlass::cast(k);\n-      oop obj;\n-      if (flattened) {\n-        int field_offset = fd->offset() - vk->first_field_offset();\n-        obj = cast_to_oop(cast_from_oop<address>(mirror) + field_offset);\n-      } else {\n-        obj = mirror->obj_field_acquire(fd->offset());\n+        \/\/ handling of null free inline type\n+        ResetNoHandleMark rnhm;\n+        Thread* THREAD = Thread::current();\n+        SignatureStream ss(fd->signature(), false);\n+        Symbol* name = ss.as_symbol();\n+        assert(!HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n+        InstanceKlass* holder = fd->field_holder();\n+        InstanceKlass* k = SystemDictionary::find_instance_klass(THREAD, name,\n+                                                                 Handle(THREAD, holder->class_loader()),\n+                                                                 Handle(THREAD, holder->protection_domain()));\n+        assert(k != nullptr && !HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n+        InlineKlass* vk = InlineKlass::cast(k);\n+        oop obj;\n+        if (is_flat) {\n+          int field_offset = fd->offset() - vk->first_field_offset();\n+          obj = cast_to_oop(cast_from_oop<address>(mirror) + field_offset);\n+        } else {\n+          obj = mirror->obj_field_acquire(fd->offset());\n+        }\n+        InlineTypeFieldPrinter print_field(_out, obj);\n+        vk->do_nonstatic_fields(&print_field);\n+        break;\n@@ -892,4 +898,0 @@\n-      InlineTypeFieldPrinter print_field(_out, obj);\n-      vk->do_nonstatic_fields(&print_field);\n-      break;\n-    }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":64,"deletions":62,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-  ciField* get_non_flattened_field_by_offset(int field_offset);\n+  ciField* get_non_flat_field_by_offset(int field_offset);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1611,0 +1611,6 @@\n+    \/\/ Here, we still detect that the field's type is an inline type by checking if it has\n+    \/\/ a Q-descriptor. This test will be replaced later by something not relying on Q-desriptors.\n+    \/\/ From this point forward, checking if a field's type is an inline type should be performed\n+    \/\/ using the inline_type flag of FieldFlags, and not by looking for a Q-descriptor in its signature\n+    if (type == T_PRIMITIVE_OBJECT) fieldFlags.update_null_free_inline_type(true);\n+\n@@ -5893,1 +5899,1 @@\n-      if (fs.field_descriptor().is_inline_type()) {\n+      if (fs.field_descriptor().is_null_free_inline_type()) {\n@@ -6648,1 +6654,1 @@\n-      if (Signature::basic_type(sig) == T_PRIMITIVE_OBJECT && !fieldinfo.access_flags().is_static()) {\n+      if (fieldinfo.field_flags().is_null_free_inline_type() && !fieldinfo.access_flags().is_static()) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  assert(kind == REGULAR || kind == INLINED || kind == INHERITED || kind == MULTIFIELD,\n+  assert(kind == REGULAR || kind == FLAT || kind == INHERITED || kind == MULTIFIELD,\n@@ -111,2 +111,2 @@\n-void FieldGroup::add_inlined_field(int idx, InlineKlass* vk) {\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false, -1);\n+void FieldGroup::add_flat_field(int idx, InlineKlass* vk) {\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, vk->get_exact_size_in_bytes(), vk->get_alignment(), false, -1);\n@@ -258,2 +258,2 @@\n-         && block->kind() != LayoutRawBlock::INLINED\n-         && block->kind() != LayoutRawBlock::MULTIFIELD) {\n+         && block->kind() != LayoutRawBlock::MULTIFIELD\n+         && block->kind() != LayoutRawBlock::FLAT) {\n@@ -444,1 +444,1 @@\n-      if (type == T_PRIMITIVE_OBJECT) {\n+      if (fs.field_flags().is_null_free_inline_type()) {\n@@ -583,1 +583,1 @@\n-      case LayoutRawBlock::INLINED: {\n+      case LayoutRawBlock::FLAT: {\n@@ -591,1 +591,1 @@\n-                         \"INLINED\");\n+                         \"FLAT\");\n@@ -735,1 +735,0 @@\n-    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n@@ -740,0 +739,1 @@\n+      BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n@@ -753,7 +753,3 @@\n-        if (group != _static_fields) _nonstatic_oopmap_count++;\n-        group->add_oop_field(idx);\n-        break;\n-      case T_PRIMITIVE_OBJECT:\n-        _has_inline_type_fields = true;\n-        if (group == _static_fields) {\n-          \/\/ static fields are never inlined\n+      case T_PRIMITIVE_OBJECT:  \/\/ T_PRIMITIVE_OBJECT is going to me removed, inline types are detected below\n+        if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+          if (group != _static_fields) _nonstatic_oopmap_count++;\n@@ -762,27 +758,3 @@\n-          _has_flattening_information = true;\n-          \/\/ Flattening decision to be taken here\n-          \/\/ This code assumes all verification already have been performed\n-          \/\/ (field's type has been loaded and it is an inline klass)\n-          JavaThread* THREAD = JavaThread::current();\n-          Klass* klass =  _inline_type_field_klasses->at(idx);\n-          assert(klass != nullptr, \"Sanity check\");\n-          InlineKlass* vk = InlineKlass::cast(klass);\n-          bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                     (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-          bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-          bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n-          if (vk->is_naturally_atomic()) {\n-            too_atomic_to_flatten = false;\n-            \/\/too_volatile_to_flatten = false; \/\/FIXME\n-            \/\/ volatile fields are currently never inlined, this could change in the future\n-          }\n-          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n-            group->add_inlined_field(idx, vk);\n-            _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-            _field_info->adr_at(idx)->field_flags_addr()->update_inlined(true);\n-            if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-              _has_nonatomic_values = true;\n-              _atomic_field_count--;  \/\/ every other field is atomic but this one\n-            }\n-          } else {\n-            _nonstatic_oopmap_count++;\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never flat\n@@ -790,0 +762,30 @@\n+          } else {\n+            _has_flattening_information = true;\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verification already have been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            JavaThread* THREAD = JavaThread::current();\n+            Klass* klass =  _inline_type_field_klasses->at(idx);\n+            assert(klass != nullptr, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ Currently, volatile fields are never flat, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n+              group->add_flat_field(idx, vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              _field_info->adr_at(idx)->field_flags_addr()->update_flat(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              group->add_oop_field(idx);\n+            }\n@@ -791,0 +793,3 @@\n+          break;\n+        default:\n+          fatal(\"Something wrong?\");\n@@ -792,3 +797,0 @@\n-        break;\n-      default:\n-        fatal(\"Something wrong?\");\n@@ -815,1 +817,1 @@\n- *     currently only based in the size of the fields to be inlined, the size\n+ *     currently only based in the size of the fields to be flattened, the size\n@@ -854,11 +856,6 @@\n-        if (group != _static_fields) {\n-          _nonstatic_oopmap_count++;\n-          field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n-        }\n-        group->add_oop_field(fieldinfo.index());\n-        break;\n-      case T_PRIMITIVE_OBJECT: {\n-  \/\/      fs.set_inline(true);\n-        _has_inline_type_fields = true;\n-        if (group == _static_fields) {\n-          \/\/ static fields are never inlined\n+      case T_PRIMITIVE_OBJECT: \/\/ T_PRIMITIVE_OBJECT is going to be removed, online types are detected below\n+        if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+          if (group != _static_fields) {\n+            _nonstatic_oopmap_count++;\n+            field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+          }\n@@ -867,28 +864,3 @@\n-          \/\/ Flattening decision to be taken here\n-          \/\/ This code assumes all verifications have already been performed\n-          \/\/ (field's type has been loaded and it is an inline klass)\n-          JavaThread* THREAD = JavaThread::current();\n-          Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n-          assert(klass != nullptr, \"Sanity check\");\n-          InlineKlass* vk = InlineKlass::cast(klass);\n-          bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                     (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-          bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-          bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n-          if (vk->is_naturally_atomic()) {\n-            too_atomic_to_flatten = false;\n-            \/\/too_volatile_to_flatten = false; \/\/FIXME\n-            \/\/ volatile fields are currently never inlined, this could change in the future\n-          }\n-          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n-            group->add_inlined_field(fieldinfo.index(), vk);\n-            _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-            field_alignment = vk->get_alignment();\n-            _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_inlined(true);\n-            if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-              _has_nonatomic_values = true;\n-              _atomic_field_count--;  \/\/ every other field is atomic but this one\n-            }\n-          } else {\n-            _nonstatic_oopmap_count++;\n-            field_alignment = type2aelembytes(T_OBJECT);\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never flat\n@@ -896,0 +868,31 @@\n+          } else {\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verifications have already been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            JavaThread* THREAD = JavaThread::current();\n+            Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n+            assert(klass != nullptr, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ Currently, volatile fields are never flat, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n+              group->add_flat_field(fieldinfo.index(), vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              field_alignment = vk->get_alignment();\n+              _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_flat(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              field_alignment = type2aelembytes(T_OBJECT);\n+              group->add_oop_field(fieldinfo.index());\n+            }\n@@ -899,1 +902,0 @@\n-      }\n@@ -933,1 +935,1 @@\n- *   - primitive fields (both primitive types and flattened inline types) are allocated\n+ *   - primitive fields (both primitive types and flat inline types) are allocated\n@@ -998,1 +1000,1 @@\n- *   - big primitive fields (primitive types and flattened inline type smaller\n+ *   - big primitive fields (primitive types and flat inline type smaller\n@@ -1045,1 +1047,1 @@\n-void FieldLayoutBuilder::add_inlined_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_maps,\n+void FieldLayoutBuilder::add_flat_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_maps,\n@@ -1060,1 +1062,1 @@\n-      if (f->kind() == LayoutRawBlock::INLINED) {\n+      if (f->kind() == LayoutRawBlock::FLAT) {\n@@ -1064,1 +1066,1 @@\n-          add_inlined_field_oopmap(nonstatic_oop_maps, vk, f->offset());\n+          add_flat_field_oopmap(nonstatic_oop_maps, vk, f->offset());\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":94,"deletions":92,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-    REGULAR,          \/\/ primitive or oop field (including inline type fields not inlined)\n-    INLINED,          \/\/ field inlined\n-    INHERITED,        \/\/ field(s) inherited from super classes\n+    REGULAR,          \/\/ primitive or oop field (including not flat inline type fields)\n+    FLAT,             \/\/ flat field\n+    INHERITED,         \/\/ field(s) inherited from super classes\n@@ -162,1 +162,1 @@\n-\/\/ oop, or inlined.\n+\/\/ oop, or flat.\n@@ -191,1 +191,1 @@\n-  void add_inlined_field(int idx, InlineKlass* vk);\n+  void add_flat_field(int idx, InlineKlass* vk);\n@@ -340,1 +340,1 @@\n-  void add_inlined_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_map, InlineKlass* vk, int offset);\n+  void add_flat_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_map, InlineKlass* vk, int offset);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1304,1 +1304,1 @@\n-    MN_FLATTENED             = 0x00400000, \/\/ flattened field\n+    MN_FLAT_FIELD            = 0x00400000, \/\/ flat field\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    friend class FieldDesc;\n@@ -77,6 +78,7 @@\n-      _ff_inlined,           \/\/ or \"flattened\"\n-      _ff_initialized,       \/\/ has ConstantValue initializer attribute\n-      _ff_injected,          \/\/ internal field injected by the JVM\n-      _ff_generic,           \/\/ has a generic signature\n-      _ff_stable,            \/\/ trust as stable b\/c declared as @Stable\n-      _ff_contended,         \/\/ is contended, may have contention-group\n+      _ff_null_free_inline_type,  \/\/ field's type is an inline type and the field is null free\n+      _ff_flat,         \/\/ field is a flat field\n+      _ff_initialized,  \/\/ has ConstantValue initializer attribute\n+      _ff_injected,     \/\/ internal field injected by the JVM\n+      _ff_generic,      \/\/ has a generic signature\n+      _ff_stable,       \/\/ trust as stable b\/c declared as @Stable\n+      _ff_contended,    \/\/ is contended, may have contention-group\n@@ -115,1 +117,2 @@\n-    bool is_inlined() const         { return test_flag(_ff_inlined); }\n+    bool is_null_free_inline_type() const { return test_flag(_ff_null_free_inline_type); }\n+    bool is_flat() const            { return test_flag(_ff_flat); }\n@@ -123,6 +126,7 @@\n-    void update_initialized(bool z)      { update_flag(_ff_initialized, z); }\n-    void update_inlined(bool z)          { update_flag(_ff_inlined, z); }\n-    void update_injected(bool z)         { update_flag(_ff_injected, z); }\n-    void update_generic(bool z)          { update_flag(_ff_generic, z); }\n-    void update_stable(bool z)           { update_flag(_ff_stable, z); }\n-    void update_contended(bool z)        { update_flag(_ff_contended, z); }\n+    void update_initialized(bool z) { update_flag(_ff_initialized, z); }\n+    void update_null_free_inline_type(bool z) { update_flag(_ff_null_free_inline_type, z); }\n+    void update_flat(bool z)        { update_flag(_ff_flat, z); }\n+    void update_injected(bool z)    { update_flag(_ff_injected, z); }\n+    void update_generic(bool z)     { update_flag(_ff_generic, z); }\n+    void update_stable(bool z)      { update_flag(_ff_stable, z); }\n+    void update_contended(bool z)   { update_flag(_ff_contended, z); }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -118,2 +118,6 @@\n-  bool is_inlined() {\n-    return field()->field_flags().is_inlined();\n+  bool is_null_free_inline_type() {\n+    return field()->field_flags().is_null_free_inline_type();\n+  }\n+\n+  bool is_flat() {\n+    return field()->field_flags().is_flat();\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-oop InlineKlass::read_inlined_field(oop obj, int offset, TRAPS) {\n+oop InlineKlass::read_flat_field(oop obj, int offset, TRAPS) {\n@@ -141,1 +141,1 @@\n-void InlineKlass::write_inlined_field(oop obj, int offset, oop value, TRAPS) {\n+void InlineKlass::write_flat_field(oop obj, int offset, oop value, TRAPS) {\n@@ -152,1 +152,1 @@\n-bool InlineKlass::flatten_array() {\n+bool InlineKlass::flat_array() {\n@@ -187,1 +187,1 @@\n-        if (flatten_array()) {\n+        if (flat_array()) {\n@@ -222,1 +222,1 @@\n-\/\/ function collects the inlined field (recursively)\n+\/\/ function collects the flat field (recursively)\n@@ -247,2 +247,2 @@\n-    if (fs.is_inlined()) {\n-      \/\/ Resolve klass of inlined field and recursively collect fields\n+    if (fs.is_flat()) {\n+      \/\/ Resolve klass of flat field and recursively collect fields\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-  bool flatten_array();\n+  bool flat_array();\n@@ -210,1 +210,1 @@\n-  \/\/ \"in-lined\" (flattened) into containing oops, these methods reside here in InlineKlass.\n+  \/\/ \"in-lined\" (flat layout) into containing oops, these methods reside here in InlineKlass.\n@@ -219,2 +219,2 @@\n-  oop read_inlined_field(oop obj, int offset, TRAPS);\n-  void write_inlined_field(oop obj, int offset, oop value, TRAPS);\n+  oop read_flat_field(oop obj, int offset, TRAPS);\n+  void write_flat_field(oop obj, int offset, oop value, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  return Signature::basic_type(field_signature(index)) == T_PRIMITIVE_OBJECT;\n+  return field(index).field_flags().is_null_free_inline_type();\n@@ -1314,1 +1314,1 @@\n-      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+      if (fs.is_null_free_inline_type()) {\n@@ -2823,1 +2823,1 @@\n-      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+      if (fs.is_null_free_inline_type()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-  bool    field_is_inlined(int index) const { return field_flags(index).is_inlined(); }\n+  bool    field_is_flat(int index) const { return field_flags(index).is_flat(); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-        \/\/ Result might still be allocated (for example, if it has been stored to a non-flattened field)\n+        \/\/ Result might still be allocated (for example, if it has been stored to a non-flat field)\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1207,1 +1207,1 @@\n-  \/\/ Split if can cause the flattened array branch of an array load to\n+  \/\/ Split if can cause the flat array branch of an array load to\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1028,1 +1028,1 @@\n-\/\/ note that these functions assume that the _adr_type field is flattened\n+\/\/ note that these functions assume that the _adr_type field is flat\n@@ -1046,1 +1046,1 @@\n-  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::INLINES && Compile::current()->flattened_accesses_share_alias()), \"flatten at\");\n+  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::INLINES && Compile::current()->flat_accesses_share_alias()), \"flatten at\");\n@@ -1174,2 +1174,2 @@\n-  \/\/ Flat array element shouldn't get their own memory slice until flattened_accesses_share_alias is cleared.\n-  \/\/ It could be the graph has no loads\/stores and flattened_accesses_share_alias is never cleared. EA could still\n+  \/\/ Flat array element shouldn't get their own memory slice until flat_accesses_share_alias is cleared.\n+  \/\/ It could be the graph has no loads\/stores and flat_accesses_share_alias is never cleared. EA could still\n@@ -1180,1 +1180,1 @@\n-         !Compile::current()->flattened_accesses_share_alias() ||\n+         !Compile::current()->flat_accesses_share_alias() ||\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1062,2 +1062,2 @@\n-  _has_flattened_accesses = false;\n-  _flattened_accesses_share_alias = true;\n+  _has_flat_accesses = false;\n+  _flat_accesses_share_alias = true;\n@@ -1390,1 +1390,1 @@\n-    \/\/ For flattened inline type array, each field has its own slice so\n+    \/\/ For flat inline type array, each field has its own slice so\n@@ -1439,1 +1439,1 @@\n-    if (ta->is_flat() && ta->elem() != TypeInstPtr::BOTTOM && _flattened_accesses_share_alias) {\n+    if (ta->is_flat() && ta->elem() != TypeInstPtr::BOTTOM && _flat_accesses_share_alias) {\n@@ -2041,7 +2041,1 @@\n-          InlineTypeNode* vt2 = u->as_InlineType();\n-          for (uint i = 0; i < vt2->field_count(); ++i) {\n-            if (vt2->field_value(i) == vt && !vt2->field_is_flattened(i)) {\n-              \/\/ Use in non-flat field\n-              must_be_buffered = true;\n-            }\n-          }\n+          \/\/ InlineType uses don't need buffering because they are about to be replaced as well\n@@ -2050,1 +2044,1 @@\n-        } else if (u->Opcode() != Op_Return || !tf()->returns_inline_type_as_fields()) {\n+        } else {\n@@ -2066,2 +2060,2 @@\n-void Compile::adjust_flattened_array_access_aliases(PhaseIterGVN& igvn) {\n-  if (!_has_flattened_accesses) {\n+void Compile::adjust_flat_array_access_aliases(PhaseIterGVN& igvn) {\n+  if (!_has_flat_accesses) {\n@@ -2070,1 +2064,1 @@\n-  \/\/ Initially, all flattened array accesses share the same slice to\n+  \/\/ Initially, all flat array accesses share the same slice to\n@@ -2072,3 +2066,3 @@\n-  \/\/ to a flattened array) correct. We're done with parsing so we\n-  \/\/ now know all flattened array accesses in this compile\n-  \/\/ unit. Let's move flattened array accesses to their own slice,\n+  \/\/ to a flat array) correct. We're done with parsing so we\n+  \/\/ now know all flat array accesses in this compile\n+  \/\/ unit. Let's move flat array accesses to their own slice,\n@@ -2084,1 +2078,1 @@\n-  \/\/ Alias index currently shared by all flattened memory accesses\n+  \/\/ Alias index currently shared by all flat memory accesses\n@@ -2087,1 +2081,1 @@\n-  \/\/ Find MergeMem nodes and flattened array accesses\n+  \/\/ Find MergeMem nodes and flat array accesses\n@@ -2115,1 +2109,1 @@\n-    _flattened_accesses_share_alias = false;\n+    _flat_accesses_share_alias = false;\n@@ -2117,1 +2111,1 @@\n-    \/\/ We are going to change the slice for the flattened array\n+    \/\/ We are going to change the slice for the flat array\n@@ -2163,1 +2157,1 @@\n-    \/\/ Now let's fix the memory graph so each flattened array access\n+    \/\/ Now let's fix the memory graph so each flat array access\n@@ -2269,1 +2263,1 @@\n-              \/\/ branch that handles flattened arrays hidden under\n+              \/\/ branch that handles flat arrays hidden under\n@@ -2273,1 +2267,1 @@\n-              \/\/ known flattened array.\n+              \/\/ known flat array.\n@@ -2333,1 +2327,1 @@\n-  if (!_flattened_accesses_share_alias) {\n+  if (!_flat_accesses_share_alias) {\n@@ -2792,1 +2786,1 @@\n-  adjust_flattened_array_access_aliases(igvn);\n+  adjust_flat_array_access_aliases(igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":21,"deletions":27,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1678,1 +1678,1 @@\n-    \/\/ Store to non-flattened field. Buffer the inline type and make sure\n+    \/\/ Store to non-flat field. Buffer the inline type and make sure\n@@ -3571,2 +3571,2 @@\n-  bool not_flattened = !UseFlatArray || not_inline || (toop->is_inlinetypeptr() && !toop->inline_klass()->flatten_array());\n-  if (EnableValhalla && not_flattened) {\n+  bool not_flat = !UseFlatArray || not_inline || (toop->is_inlinetypeptr() && !toop->inline_klass()->flat_array());\n+  if (EnableValhalla && not_flat) {\n@@ -3599,1 +3599,1 @@\n-          \/\/ Casting array element to a non-flattened type, mark array as not flat.\n+          \/\/ Casting array element to a non-flat type, mark array as not flat.\n@@ -3869,1 +3869,1 @@\n-    bool can_be_flattened = false;\n+    bool can_be_flat = false;\n@@ -3874,1 +3874,1 @@\n-      can_be_flattened = ary_type->can_be_inline_array() && (!elem->is_inlinetypeptr() || elem->inline_klass()->flatten_array());\n+      can_be_flat = ary_type->can_be_inline_array() && (!elem->is_inlinetypeptr() || elem->inline_klass()->flat_array());\n@@ -3876,1 +3876,1 @@\n-    if (!can_be_flattened && (xklass || (klass_t->isa_aryklassptr() && klass_t->is_aryklassptr()->elem() != Type::BOTTOM))) {\n+    if (!can_be_flat && (xklass || (klass_t->isa_aryklassptr() && klass_t->is_aryklassptr()->elem() != Type::BOTTOM))) {\n@@ -3961,1 +3961,1 @@\n-        \/\/ Initially all flattened array accesses share a single slice\n+        \/\/ Initially all flat array accesses share a single slice\n@@ -3963,1 +3963,1 @@\n-        \/\/ it can optimize flattened array accesses properly once they\n+        \/\/ it can optimize flat array accesses properly once they\n@@ -3965,2 +3965,2 @@\n-        assert(C->flattened_accesses_share_alias(), \"should be set at parse time\");\n-        C->set_flattened_accesses_share_alias(false);\n+        assert(C->flat_accesses_share_alias(), \"should be set at parse time\");\n+        C->set_flat_accesses_share_alias(false);\n@@ -3977,1 +3977,1 @@\n-          \/\/ Compile::adjust_flattened_array_access_aliases().\n+          \/\/ Compile::adjust_flat_array_access_aliases().\n@@ -3980,1 +3980,1 @@\n-        C->set_flattened_accesses_share_alias(true);\n+        C->set_flat_accesses_share_alias(true);\n@@ -4272,2 +4272,2 @@\n-  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n-  \/\/ Check if array is a null-free, non-flattened inline type array\n+  \/\/ - null-free, flat     : MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n+  \/\/ Check if array is a null-free, non-flat inline type array\n@@ -4292,1 +4292,1 @@\n-    \/\/ Null-free, non-flattened inline type array, initialize with the default value\n+    \/\/ Null-free, non-flat inline type array, initialize with the default value\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    bool no_circularity = !gvn->C->has_circular_inline_type() || !gvn->is_IterGVN() || field_is_flattened(i);\n+    bool no_circularity = !gvn->C->has_circular_inline_type() || !gvn->is_IterGVN() || field_is_flat(i);\n@@ -177,0 +177,3 @@\n+      if (val2->is_Phi()) {\n+        val2 = gvn->transform(val2);\n+      }\n@@ -222,1 +225,1 @@\n-\/\/ If 'recursive' is true, flattened inline type fields will be resolved recursively.\n+\/\/ If 'recursive' is true, flat inline type fields will be resolved recursively.\n@@ -224,1 +227,1 @@\n-  \/\/ If the field at 'offset' belongs to a flattened inline type field, 'index' refers to the\n+  \/\/ If the field at 'offset' belongs to a flat inline type field, 'index' refers to the\n@@ -231,2 +234,2 @@\n-    if (field_is_flattened(index)) {\n-      \/\/ Flattened inline type field\n+    if (field_is_flat(index)) {\n+      \/\/ Flat inline type field\n@@ -287,1 +290,1 @@\n-bool InlineTypeNode::field_is_flattened(uint index) const {\n+bool InlineTypeNode::field_is_flat(uint index) const {\n@@ -290,2 +293,2 @@\n-  assert(!field->is_flattened() || field->type()->is_inlinetype(), \"must be an inline type\");\n-  return field->is_flattened();\n+  assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+  return field->is_flat();\n@@ -297,1 +300,1 @@\n-  assert(!field->is_flattened() || field->type()->is_inlinetype(), \"must be an inline type\");\n+  assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n@@ -340,1 +343,1 @@\n-    Node* value = field_value_by_offset(offset, true \/* include flattened inline type fields *\/);\n+    Node* value = field_value_by_offset(offset, true \/* include flat inline type fields *\/);\n@@ -397,1 +400,1 @@\n-  \/\/ Now scalarize non-flattened fields\n+  \/\/ Now scalarize non-flat fields\n@@ -414,1 +417,1 @@\n-    \/\/ In the case of a flattened inline type array, each field has its own slice\n+    \/\/ In the case of a flat inline type array, each field has its own slice\n@@ -443,1 +446,1 @@\n-      if (!field_is_flattened(i) && visited.contains(ft)) {\n+      if (!field_is_flat(i) && visited.contains(ft)) {\n@@ -478,3 +481,3 @@\n-    } else if (field_is_flattened(i)) {\n-      \/\/ Recursively load the flattened inline type field\n-      value = make_from_flattened_impl(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators, visited);\n+    } else if (field_is_flat(i)) {\n+      \/\/ Recursively load the flat inline type field\n+      value = make_from_flat_impl(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators, visited);\n@@ -485,2 +488,1 @@\n-      ciField* field = holder->get_field_by_offset(offset, false);\n-      if (base->is_Con() && !is_array && !mismatched && !field->is_multifield_base()) {\n+      if (base->is_Con() && !is_array && !mismatched && !is_multifield_base(i)) {\n@@ -490,0 +492,1 @@\n+        ciField* field = holder->get_field_by_offset(offset, false);\n@@ -507,0 +510,1 @@\n+        ciField* field = inline_klass()->get_field_by_offset(field_offset(i), false);\n@@ -528,1 +532,1 @@\n-void InlineTypeNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n+void InlineTypeNode::store_flat(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n@@ -530,1 +534,1 @@\n-    kit->C->set_flattened_accesses();\n+    kit->C->set_flat_accesses();\n@@ -545,0 +549,1 @@\n+    int offset = holder_offset + field_offset(i);\n@@ -547,4 +552,3 @@\n-    int offset = holder_offset + field_offset(i);\n-    if (field_is_flattened(i)) {\n-      \/\/ Recursively store the flattened inline type field\n-      value->as_InlineType()->store_flattened(kit, base, ptr, holder, offset, decorators);\n+    if (field_is_flat(i)) {\n+      \/\/ Recursively store the flat inline type field\n+      value->as_InlineType()->store_flat(kit, base, ptr, holder, offset, decorators);\n@@ -714,2 +718,2 @@\n-     if (field_is_flattened(i)) {\n-       \/\/ Flattened inline type field\n+     if (field_is_flat(i)) {\n+       \/\/ Flat inline type field\n@@ -718,1 +722,1 @@\n-       \/\/ Non-flattened inline type field\n+       \/\/ Non-flat inline type field\n@@ -855,1 +859,1 @@\n-    if (!vt->field_is_flattened(i) && visited.contains(ft)) {\n+    if (!vt->field_is_flat(i) && visited.contains(ft)) {\n@@ -968,1 +972,1 @@\n-  assert(!null_free || vt->is_allocated(&gvn), \"inline type should be allocated\");\n+  assert(vt->is_allocated(&gvn) || (null_free && !vk->is_initialized()), \"inline type should be allocated\");\n@@ -973,1 +977,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n+InlineTypeNode* InlineTypeNode::make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n@@ -976,1 +980,1 @@\n-  return make_from_flattened_impl(kit, vk, obj, ptr, holder, holder_offset, decorators, visited);\n+  return make_from_flat_impl(kit, vk, obj, ptr, holder, holder_offset, decorators, visited);\n@@ -979,2 +983,2 @@\n-\/\/ GraphKit wrapper for the 'make_from_flattened' method\n-InlineTypeNode* InlineTypeNode::make_from_flattened_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n+\/\/ GraphKit wrapper for the 'make_from_flat' method\n+InlineTypeNode* InlineTypeNode::make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n@@ -982,1 +986,1 @@\n-    kit->C->set_flattened_accesses();\n+    kit->C->set_flat_accesses();\n@@ -985,1 +989,1 @@\n-  \/\/ a flattened inline type field at 'holder_offset' or from an inline type array.\n+  \/\/ a flat inline type field at 'holder_offset' or from an inline type array.\n@@ -1089,1 +1093,1 @@\n-      } else if (field_is_flattened(i) && vt->is_InlineType()) {\n+      } else if (field_is_flat(i) && vt->is_InlineType()) {\n@@ -1142,2 +1146,2 @@\n-    if (field_is_flattened(i)) {\n-      \/\/ Flattened inline type field\n+    if (field_is_flat(i)) {\n+      \/\/ Flat inline type field\n@@ -1147,1 +1151,1 @@\n-        \/\/ Non-flattened inline type field\n+        \/\/ Non-flat inline type field\n@@ -1200,2 +1204,2 @@\n-    if (field_is_flattened(i)) {\n-      \/\/ Flattened inline type field\n+    if (field_is_flat(i)) {\n+      \/\/ Flat inline type field\n@@ -1233,1 +1237,1 @@\n-      \/\/ Non-flattened inline type field\n+      \/\/ Non-flat inline type field\n@@ -1322,1 +1326,1 @@\n-    if (!vt->field_is_flattened(i) && visited.contains(ft)) {\n+    if (!vt->field_is_flat(i) && visited.contains(ft)) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":47,"deletions":43,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  static InlineTypeNode* make_from_flattened_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n@@ -87,2 +87,2 @@\n-  \/\/ Create and initialize by loading the field values from a flattened field or array\n-  static InlineTypeNode* make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n+  \/\/ Create and initialize by loading the field values from a flat field or array\n+  static InlineTypeNode* make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n@@ -136,1 +136,1 @@\n-  bool          field_is_flattened(uint index) const;\n+  bool          field_is_flat(uint index) const;\n@@ -142,2 +142,2 @@\n-  \/\/ Store the inline type as a flattened (headerless) representation\n-  void store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n+  \/\/ Store the inline type as a flat (headerless) representation\n+  void store_flat(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n@@ -157,1 +157,1 @@\n-  \/\/ Allocate all non-flattened inline type fields\n+  \/\/ Allocate all non-flat inline type fields\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2368,1 +2368,0 @@\n-        ciField* field = vk->get_non_flattened_field_by_offset(off);\n@@ -2374,0 +2373,1 @@\n+        ciField* field = vk->get_non_flat_field_by_offset(off);\n@@ -2376,1 +2376,1 @@\n-          if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_PRIMITIVE_OBJECT && !field->is_flattened())) {\n+          if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_PRIMITIVE_OBJECT && !field->is_flat())) {\n@@ -2460,1 +2460,1 @@\n-      field = k->get_non_flattened_field_by_offset(off);\n+      field = k->get_non_flat_field_by_offset(off);\n@@ -2466,1 +2466,1 @@\n-    if (field != nullptr && bt == T_PRIMITIVE_OBJECT && !field->is_flattened()) {\n+    if (field != nullptr && bt == T_PRIMITIVE_OBJECT && !field->is_flat()) {\n@@ -2558,1 +2558,1 @@\n-    if (heap_base_oop != top() && field != nullptr && field->is_constant() && !field->is_flattened() && !mismatched) {\n+    if (heap_base_oop != top() && field != nullptr && field->is_constant() && !field->is_flat() && !mismatched) {\n@@ -2568,1 +2568,1 @@\n-          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, base, holder, offset, decorators);\n+          p = InlineTypeNode::make_from_flat(this, inline_klass, base, base, holder, offset, decorators);\n@@ -2570,1 +2570,1 @@\n-          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, adr, nullptr, 0, decorators);\n+          p = InlineTypeNode::make_from_flat(this, inline_klass, base, adr, nullptr, 0, decorators);\n@@ -2621,1 +2621,1 @@\n-        val->as_InlineType()->store_flattened(this, base, base, holder, offset, decorators);\n+        val->as_InlineType()->store_flat(this, base, base, holder, offset, decorators);\n@@ -2623,1 +2623,1 @@\n-        val->as_InlineType()->store_flattened(this, base, adr, nullptr, 0, decorators);\n+        val->as_InlineType()->store_flat(this, base, adr, nullptr, 0, decorators);\n@@ -5372,1 +5372,1 @@\n-        \/\/ Flattened inline type array may have object field that would require a\n+        \/\/ Flat inline type array may have object field that would require a\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3066,1 +3066,1 @@\n-        phase->C->flattened_accesses_share_alias()) {\n+        phase->C->flat_accesses_share_alias()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -619,1 +619,1 @@\n-      \/\/ Speculate on varargs Object array being not null-free (and therefore also not flattened)\n+      \/\/ Speculate on varargs Object array being not null-free (and therefore also not flat)\n@@ -2391,1 +2391,1 @@\n-        \/\/ Returning from root or an incrementally inlined method. Make sure all non-flattened\n+        \/\/ Returning from root or an incrementally inlined method. Make sure all non-flat\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-  } else if (val->is_InlineType() && !field->is_null_free()) {\n+  } else if (val->is_InlineType() && !field->is_flat()) {\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1510,0 +1510,1 @@\n+  bool _is_flat;\n@@ -1512,6 +1513,1 @@\n-  ReassignedField() {\n-    _offset = 0;\n-    _type = T_ILLEGAL;\n-    _klass = nullptr;\n-    _secondary_fields_count = 0;\n-  }\n+  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false), _secondary_fields_count(0) { }\n@@ -1572,3 +1568,4 @@\n-        if (fs.signature()->is_Q_signature()) {\n-          if (fs.is_inlined()) {\n-            \/\/ Resolve klass of flattened inline type field\n+        if (fs.is_null_free_inline_type()) {\n+          if (fs.is_flat()) {\n+            field._is_flat = true;\n+            \/\/ Resolve klass of flat inline type field\n@@ -1577,1 +1574,1 @@\n-            field._type = T_OBJECT;\n+            field._type = T_OBJECT;  \/\/ Can be removed once Q-descriptors have been removed.\n@@ -1589,3 +1586,3 @@\n-    \/\/ Check for flattened inline type field before accessing the ScopeValue because it might not have any fields\n-    if (type == T_PRIMITIVE_OBJECT) {\n-      \/\/ Recursively re-assign flattened inline type fields\n+    \/\/ Check for flat inline type field before accessing the ScopeValue because it might not have any fields\n+    if (fields->at(i)._is_flat) {\n+      \/\/ Recursively re-assign flat inline type fields\n@@ -1702,1 +1699,1 @@\n-  assert(vk->flatten_array(), \"should only be used for flattened inline type arrays\");\n+  assert(vk->flat_array(), \"should only be used for flat inline type arrays\");\n@@ -1705,1 +1702,1 @@\n-  \/\/ Initialize all elements of the flattened inline type array\n+  \/\/ Initialize all elements of the flat inline type array\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  if (ft != T_PRIMITIVE_OBJECT) {\n+  if (!is_null_free_inline_type()) {\n@@ -164,0 +164,2 @@\n+    case T_ARRAY:\n+    case T_OBJECT:\n@@ -165,2 +167,3 @@\n-      if (is_inlined()) {\n-        \/\/ Print fields of inlined fields (recursively)\n+      if (is_flat()) { \/\/ only some inline types can be flat\n+        assert(is_null_free_inline_type(), \"Only null free inline type fields can be flat\");\n+        \/\/ Print fields of flat fields (recursively)\n@@ -170,1 +173,1 @@\n-        st->print_cr(\"Inline type field inlined '%s':\", vk->name()->as_C_string());\n+        st->print_cr(\"Flat inline type field '%s':\", vk->name()->as_C_string());\n@@ -175,3 +178,1 @@\n-      \/\/ inline type field not inlined, fall through\n-    case T_ARRAY:\n-    case T_OBJECT:\n+      \/\/ Not flat inline type field, fall through\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-  inline bool is_inlined()        const;\n-  inline bool is_inline_type()    const;\n+  inline bool is_flat()        const;\n+  inline bool is_null_free_inline_type()    const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-inline bool fieldDescriptor::is_inlined()  const  { return field().field_flags().is_inlined(); }\n-inline bool fieldDescriptor::is_inline_type() const { return field_type() == T_PRIMITIVE_OBJECT; }\n+inline bool fieldDescriptor::is_flat()  const  { return field().field_flags().is_flat(); }\n+inline bool fieldDescriptor::is_null_free_inline_type() const { return field().field_flags().is_null_free_inline_type(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}